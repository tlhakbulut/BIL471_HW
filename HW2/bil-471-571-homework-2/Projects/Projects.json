{
  "questions": [
    "Kuş Bakışı Atış Oyunu (Top-Down Shooter)\nBIL 211 - Proje\nTeslim Tarihi: 27 Mart 2025 23:59\n1 Amaç\nBu ödevde amacınız, Java Swing kullanarak kuş bakışı bir atış oyunu (top-down shooter) tasarlamaktır.\nOyunda, yönettiğimiz karakterin üzerine dalga dalga gelen çeşitli zombileri fare ile hedef alarak farklı silahlar\nkullanıp öldürmemiz gerekmektedir. Karakterimiz öldüğünde oyun sona erecektir. Her dalga başına ve\nöldürülen zombi başına kazanılan puan artacaktır. Dalgalar ilerledikçe gelen zombilerin sayısı ve çeşitleri\nartarak zorluk seviyesi yükselecektir.\n2 Gereksinimler\nOyun derste öğrendiğiniz OOP ilkelerine uygun sınıf/arayüz tasarımları ile geliştirilmelidir.\n- Zorluk seviyesi arttıkça zombi sayısı ve çeşitliliği artmalıdır.\n- Oyun duraklatılabilmeli ve kaydedilip tekrar yüklenilebilmelidir (FileIO kullanılmalıdır).\n- Sol üst köşede seçili silah ve kalan mermi miktarı gösterilmelidir.\n- Sağ üst köşede oyuncunun canı ve toplam puanı gösterilmelidir.\n- Oyunun duraklatılması, kaydedilmesi ve devam ettirilmesi için bir menü bulunmalıdır.\n3 Silahlar\nOyunda farklı silahlar bulunmaktadır. Belirli zombi dalgaları temizlendikten sonra oyun ödül olarak yeni bir\nsilahverecektir. Hersilahınkendineözgübirçalışmamekanizmasıvardır. Silahlarınşarjörkapasitesisınırlıdır\nve şarjördeki mermiler bittiğinde tekrar doldurulmadan ateş edilemez. Toplam mermi sayısı oyuncunun o\nsilaha ait elinde ne kadar mermi olduğunu gösterir. R tuşuna basarak şarjör yeniden doldurulabilir.\n3.1 Tabanca\n- Şarjör kapasitesi: 12 mermi\n- Ateş hızı: 120 mermi/dakika\n- Elde etme: Oyuncu oyuna bu silahla başlar.\n- Özellik: Düz atış yapar, sapma yoktur. Sınırsız yedek şarjör (diğer tüm silahlar için yedek şarjör ve\nmermiler rastgele bir şekilde dalga sırasında ve sonlarında zombilerden düşer).\n3.2 Piyade Tüfeği\n- Şarjör kapasitesi: 30 mermi\n- Ateş hızı: 600 mermi/dakika\n- Elde etme: 1. dalga tamamlandıktan sonra\n- Özellik: Düzatışyaparancak30derecesapmasıvardır. Sapmaaçısı, karakterinbaktığıyöndemerminin\nher iki dönme yönüne de saçılabileceği maksimum açıdır.\n1\n\n3.3 Pompalı Tüfek\n- Şarjör kapasitesi: 5 mermi\n- Ateş hızı: 60 mermi/dakika\n- Elde etme: 3. dalga tamamlandıktan sonra\n- Özellik: Her atış 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi atar (yani karakter merkezli mermi\nhız vektörleri arasında 5 derece açı olmalıdır).\n3.4 Keskin Nişancı Tüfeği\n- Şarjör kapasitesi: 5 mermi\n- Ateş hızı: 30 mermi/dakika\n- Elde etme: 5. dalga tamamlandıktan sonra\n- Özellik: Mermileri zombileri delip arasındaki zombilere de hasar verir.\n3.5 Roketatar\n- Şarjör kapasitesi: 1 roket\n- Ateş hızı: 10 roket/dakika\n- Elde etme: 10. dalga tamamlandıktan sonra\n- Özellik: Patlama etkisiyle birden fazla zombiye zarar verir.\n4 Zombiler\nZombiler oyundaki düşman tipleridir. Zombiler oyuncuya doğru ilerlerler ve eğer oyuncuya temas ederlerse\noyuncuya hasar verirler. Zorluk seviyesi arttıkça zombilerin sayısı ve çeşitliliği artmaktadır. Zombi tipleri\nbirbirinden renk ya da şekil olarak ayırt edilebilmelidir.\n4.1 Normal Zombi\n- Can: Orta\n- Hız: Yavaş\n- Hasar: Orta\n4.2 Sürünge Zombi\n- Can: Düşük\n- Hız: Hızlı\n- Hasar: Orta\n- Özellik: Oyuncunun yakınına geldiğinde zıplar.\n4.3 Tank Zombi\n- Can: Yüksek\n- Hız: Çok yavaş\n- Hasar: Yüksek\n2\n\n4.4 Asit Tüküren Zombi\n- Can: Düşük\n- Hız: Yavaş\n- Hasar: Orta (uzaktan asit tükürebilir)\n- Özellik: Öldürüldüğünde yanındaki birimlere zarar verir.\n5 Rapor ve Teslim Formatı\n- Oyun, OOPprensiplerineuygunolaraktasarlanmalıvesınıfdiyagramları, arayüztasarımıfinalraporda\nsunulmalıdır.\n- Oyun test edilerek ekran görüntüleri rapora eklenmelidir.\n- Rapor PDF formatında olmalı ve ismi proje_rapor.pdf olmalıdır.\n- Oyunun mainfonksiyonu Gameisimli bir sınıf içinde bulunmalıdır ( java Game komutuyla çalışmalı).\n- Kaynak kodun tamamı source.zip (uzantı 7z, rar, tar.gz de olabilir) şeklinde sıkıştırılmış olmalıdır.\n- Sıkıştırılmış kaynak kod ve rapor uzak sistemine yüklenmelidir.\n6 Yardımcı Kaynaklar\nDahaöncehiçkuşbakışıatışoyunuoynamadıysanızaşağıdakioyunlarıreferansolarakalabilirsiniz. Buradaki\noyunlarıngrafikleriilemekaniklerisizdenbeklenendenfarklıolsadaharitatasarımı, karakterhareketi,kamera\nhareketi, ateş etme mekanikleri ve zombilerin yapay zekası ile ilgili temel fikirler edinebilirsiniz.\n- Little Top-Down Shooter: https://www.youtube.com/watch?v=pj3m3Fu3i5A\n- Super C - Stage 2: https://www.youtube.com/watch?v=oS2T_V5SUj4\n- Neon Chrome: https://www.youtube.com/watch?v=puhw1bEVtro\n3"
  ],
  "answers": [
    {
      "id": "8435496",
      "ExplodingBullet.java": "package Guns;\n\npublic class ExplodingBullet extends Bullet {\n    public static int radius = 150;\n\n    public ExplodingBullet(int x, int y, double rotation) {\n        super(x, y, rotation, false);\n    }\n}\n",
      "Gun.java": "package Guns;\n\nimport GameClasses.Player;\n\nimport java.io.Serializable;\nimport java.util.Set;\n\npublic abstract class Gun implements Serializable {\n    final int magazineCapacity;\n    final double cooldownSeconds;\n    public String name = \"Gun\";\n    long lastTime;\n    int bullets;\n    int magazines;\n    boolean infiniteMagazines;\n\n    public Gun(int magazineCapacity, int magazines, double cooldownSeconds) {\n        this.magazineCapacity = magazineCapacity;\n        this.magazines = magazines;\n        this.cooldownSeconds = cooldownSeconds;\n\n        this.bullets = this.magazineCapacity;\n    }\n\n    public Gun(int magazineCapacity, int magazines, int shotsPerMinute) {\n        this(magazineCapacity, magazines, 60.0 / shotsPerMinute);\n    }\n\n    public Gun(int magazineCapacity, int shotsPerMinute) {\n        this(magazineCapacity, -1, shotsPerMinute);\n        this.infiniteMagazines = true;\n    }\n\n    public boolean reload() {\n        if (infiniteMagazines) {\n            bullets = magazineCapacity;\n            return true;\n        }\n\n        if (magazines > 0 && bullets == 0) {\n            magazines--;\n            bullets = magazineCapacity;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public boolean shoot(int x, int y, double rotation, Set<Bullet> bullets) {\n        long delay = System.currentTimeMillis() - this.lastTime;\n        if (this.bullets > 0 && delay > cooldownSeconds * 1000) {\n            this.bullets--;\n\n            int bulletDx = (int) Math.round(Player.WIDTH / 2.0 * Math.cos(rotation));\n            int bulletDy = (int) Math.round(Player.HEIGHT / 2.0 * Math.sin(rotation));\n            bullets.add(new Bullet(x + bulletDx,\n                    y + bulletDy, rotation));\n            this.lastTime = System.currentTimeMillis();\n            return true;\n        }\n        return false;\n    }\n\n    public void addMagazine() {\n        magazines++;\n    }\n\n    public String getTotalBullets() {\n        if (infiniteMagazines) return \"Sonsuz\";\n        return Integer.toString(bullets + magazines * magazineCapacity);\n    }\n\n    public int getBullets() {\n        return bullets;\n    }\n}\n",
      "Bullet.java": "package Guns;\n\nimport GameClasses.GameObject;\n\nimport java.awt.*;\n\npublic class Bullet extends GameObject {\n    public static Color COLOR = new Color(239, 201, 19);\n    protected boolean penetrate;\n    int speed = 30;\n\n    public Bullet(int x, int y, double rotation, boolean penetrate) {\n        super(x, y);\n        this.rotation = rotation;\n        this.penetrate = penetrate;\n    }\n\n    public Bullet(int x, int y, double rotation) {\n        this(x, y, rotation, false);\n    }\n\n    public void move() {\n        int dx = (int) Math.round(Math.cos(this.rotation) * speed);\n        int dy = (int) Math.round(Math.sin(this.rotation) * speed);\n\n        this.x += dx;\n        this.y += dy;\n    }\n\n    public boolean canPenetrate() {\n        return penetrate;\n    }\n}",
      "Shotgun.java": "package Guns;\n\nimport GameClasses.Player;\n\nimport java.util.Set;\n\npublic class Shotgun extends Gun {\n    public Shotgun() {\n        super(5, 0, 60);\n        name = \"Pompalı Tüfek\";\n    }\n\n    @Override\n    public boolean shoot(int x, int y, double rotation, Set<Bullet> bullets) {\n        long delay = System.currentTimeMillis() - this.lastTime;\n        if (this.bullets > 0 && delay > this.cooldownSeconds * 1000) {\n            this.bullets--;\n\n            double step = Math.PI / 36;\n\n            double tol = 0.01d;\n            for (double rad = -4 * step; rad <= 4 * step + tol; rad += step) {\n                int bulletDx = (int) Math.round(Player.WIDTH / 2.0 * Math.cos(rotation + rad));\n                int bulletDy = (int) Math.round(Player.HEIGHT / 2.0 * Math.sin(rotation + rad));\n                bullets.add(new Bullet(x + bulletDx,\n                        y + bulletDy, rotation + rad));\n                this.lastTime = System.currentTimeMillis();\n            }\n\n            return true;\n        }\n        return false;\n    }\n}\n",
      "SniperRifle.java": "package Guns;\n\nimport GameClasses.Player;\n\nimport java.util.Set;\n\npublic class SniperRifle extends Gun {\n    public SniperRifle() {\n        super(5, 0, 30);\n        name = \"Keskin Nişancı Tüfeği\";\n    }\n\n    public boolean shoot(int x, int y, double rotation, Set<Bullet> bullets) {\n        long delay = System.currentTimeMillis() - this.lastTime;\n        if (this.bullets > 0 && delay > cooldownSeconds * 1000) {\n            this.bullets--;\n\n            int bulletDx = (int) Math.round(Player.WIDTH / 2.0 * Math.cos(rotation));\n            int bulletDy = (int) Math.round(Player.HEIGHT / 2.0 * Math.sin(rotation));\n            bullets.add(new Bullet(x + bulletDx,\n                    y + bulletDy, rotation, true));\n            this.lastTime = System.currentTimeMillis();\n            return true;\n        }\n        return false;\n    }\n}\n",
      "Pistol.java": "package Guns;\n\npublic class Pistol extends Gun {\n    public Pistol() {\n        super(12, 120);\n        name = \"Tabanca\";\n    }\n}\n",
      "AssaultRifle.java": "package Guns;\n\nimport GameClasses.Player;\n\nimport java.util.Set;\n\npublic class AssaultRifle extends Gun {\n    public AssaultRifle() {\n        super(30, 0, 600);\n        name = \"Piyade Tüfeği\";\n    }\n\n    @Override\n    public boolean shoot(int x, int y, double rotation, Set<Bullet> bullets) {\n        long delay = System.currentTimeMillis() - this.lastTime;\n        if (this.bullets > 0 && delay > cooldownSeconds * 1000) {\n            this.bullets--;\n\n            double f = Math.random() / Math.nextDown(1.0);\n            double spreadRad = Math.PI / 6;\n            double randomRad = -spreadRad * (1.0 - f) + spreadRad * f;\n\n            int bulletDx = (int) Math.round(Player.WIDTH / 2.0 * Math.cos(rotation + randomRad));\n            int bulletDy = (int) Math.round(Player.HEIGHT / 2.0 * Math.sin(rotation + randomRad));\n            bullets.add(new Bullet(x + bulletDx,\n                    y + bulletDy, rotation + randomRad));\n            this.lastTime = System.currentTimeMillis();\n            return true;\n        }\n        return false;\n    }\n}\n",
      "Explosion.java": "package Guns;\n\nimport GameClasses.GameObject;\n\nimport java.awt.*;\n\npublic class Explosion extends GameObject\n{\n    public int radius;\n    public int damage = 15;\n\n    public Explosion(int x, int y, int radius) {\n        super(x, y);\n\n        this.radius = radius;\n    }\n\n    public void draw(Graphics2D g) {\n        g.fillOval(x - radius / 2, y - radius / 2, radius, radius);\n    }\n}\n",
      "Ammo.java": "package Guns;\n\nimport GameClasses.GameObject;\n\npublic class Ammo extends GameObject {\n    public int radius;\n    int type;\n\n    public Ammo(int type, int x, int y) {\n        this(type, x, y, 15);\n    }\n\n    public Ammo(int type, int x, int y, int radius) {\n        super(x, y);\n        this.type = type;\n        this.radius = radius;\n    }\n\n    public int getType() {\n        return type;\n    }\n}\n",
      "RocketLauncher.java": "package Guns;\n\nimport GameClasses.Player;\n\nimport java.util.Set;\n\npublic class RocketLauncher extends Gun {\n    public RocketLauncher() {\n        super(1, 0, 10);\n        name = \"Roketatar\";\n    }\n\n    @Override\n    public boolean shoot(int x, int y, double rotation, Set<Bullet> bullets) {\n        long delay = System.currentTimeMillis() - this.lastTime;\n        if (this.bullets > 0 && delay > cooldownSeconds * 1000) {\n            this.bullets--;\n\n            int bulletDx = (int) Math.round(Player.WIDTH / 2.0 * Math.cos(rotation));\n            int bulletDy = (int) Math.round(Player.HEIGHT / 2.0 * Math.sin(rotation));\n            bullets.add(new ExplodingBullet(x + bulletDx,\n                    y + bulletDy, rotation));\n            this.lastTime = System.currentTimeMillis();\n            return true;\n        }\n        return false;\n    }\n}\n",
      "HealthPack.java": "package GameClasses;\n\npublic class HealthPack extends GameObject\n{\n    int radius = 10;\n    int health;\n\n    public HealthPack(int x, int y)\n    {\n        this(x, y, 1);\n    }\n\n    public HealthPack(int x, int y, int health)\n    {\n        super(x, y);\n        this.health = health;\n    }\n}\n",
      "GameWave.java": "package GameClasses;\n\nimport Guns.Ammo;\nimport Zombies.AcidSpittingZombie;\nimport Zombies.CrawlerZombie;\nimport Zombies.TankZombie;\nimport Zombies.Zombie;\n\nimport java.util.Collection;\nimport java.util.LinkedList;\n\npublic class GameWave {\n    private final LinkedList<Zombie> zombies = new LinkedList<>();\n    private final LinkedList<Ammo> ammos = new LinkedList<>();\n    private final LinkedList<HealthPack> healthPacks = new LinkedList<>();\n\n    public GameWave(int wave, Player player) {\n        switch (wave) {\n            case 1:\n                addZombie(0, 5, player);\n\n                addHealthPack(1);\n                break;\n            case 2:\n                addZombie(0, 5, player);\n                addZombie(1, 1, player);\n\n                addAmmo(2, 5);\n\n                addHealthPack(2);\n                break;\n            case 3:\n                addZombie(0, 5, player);\n                addZombie(1, 2, player);\n                addZombie(2, 3, player);\n\n                addAmmo(2, 6);\n                addAmmo(3, 8);\n\n                addHealthPack(3);\n                break;\n            case 4:\n                addZombie(0, 3, player);\n                addZombie(1, 2, player);\n                addZombie(2, 2, player);\n                addZombie(3, 4, player);\n\n                addAmmo(2, 3);\n                addAmmo(3, 2);\n                addAmmo(4, 6);\n\n                addHealthPack(4);\n                break;\n            case 5:\n                addZombie(0, 4, player);\n                addZombie(1, 3, player);\n                addZombie(2, 3, player);\n                addZombie(3, 4, player);\n\n                addAmmo(2, 1);\n                addAmmo(3, 3);\n                addAmmo(4, 2);\n                addAmmo(5, 5);\n\n                addHealthPack(5);\n                break;\n            default:\n                addZombie(3, 10, player);\n                addAmmo(2, 5);\n                addAmmo(3, 5);\n                addAmmo(4, 5);\n                addAmmo(5, 5);\n\n                addHealthPack(6);\n        }\n    }\n\n    public GameWave(Player player, int i)\n    {\n        addZombie(0, i, player);\n        addZombie(1, i, player);\n        addZombie(2, i, player);\n        addZombie(3, i, player);\n    }\n\n    private void addZombie(int type, int n, Player player) {\n        for (int i = 0; i < n; i++) {\n            int x = (int) (Math.random() * (GamePanel.PANEL_WIDTH - Zombie.WIDTH)) + Zombie.WIDTH / 2;\n            int y = (int) (Math.random() * (GamePanel.PANEL_HEIGHT - Zombie.WIDTH)) + Zombie.WIDTH / 2;\n            switch (type) {\n                case 0:\n                    zombies.add(new Zombie(x, y, player));\n                    break;\n                case 1:\n                    zombies.add(new CrawlerZombie(x, y, player));\n                    break;\n                case 2:\n                    zombies.add(new TankZombie(x, y, player));\n                    break;\n                case 3:\n                    zombies.add(new AcidSpittingZombie(x, y, player));\n                    break;\n            }\n        }\n    }\n\n    private void addAmmo(int type, int n) {\n        for (int i = 0; i < n; i++) {\n            int x = (int) (Math.random() * (GamePanel.PANEL_WIDTH - 30)) + 15;\n            int y = (int) (Math.random() * (GamePanel.PANEL_HEIGHT- 30)) + 15;\n            switch (type) {\n                case 1:\n                    ammos.add(new Ammo(1, x, y));\n                    break;\n                case 2:\n                    ammos.add(new Ammo(2, x, y));\n                    break;\n                case 3:\n                    ammos.add(new Ammo(3, x, y));\n                    break;\n                case 4:\n                    ammos.add(new Ammo(4, x, y));\n                    break;\n            }\n        }\n    }\n\n    private void addHealthPack(int n) {\n        for (int i = 0; i < n; i++) {\n            int x = (int) (Math.random() * (GamePanel.PANEL_WIDTH - 30)) + 15;\n            int y = (int) (Math.random() * (GamePanel.PANEL_HEIGHT- 30)) + 15;\n            healthPacks.add(new HealthPack(x, y));\n        }\n    }\n\n    public Collection<Zombie> getZombies() {\n        return zombies;\n    }\n\n    public Collection<Ammo> getAmmos() {\n        return ammos;\n    }\n\n    public Collection<HealthPack> getHealthPacks()\n    {\n        return healthPacks;\n    }\n}\n",
      "GameMover.java": "package GameClasses;\n\nimport Guns.Bullet;\nimport Zombies.Zombie;\n\nimport java.util.ArrayList;\n\npublic abstract class GameMover extends GameObject {\n    public static final int WIDTH = 50;\n    public static final int HEIGHT = 50;\n\n    public static double collisionRadius = 40;\n    boolean up = false;\n    boolean down = false;\n    boolean left = false;\n    boolean right = false;\n    protected int speed = 5;\n\n    public GameMover(int x, int y) {\n        super(x, y);\n    }\n\n    public void collidedWith(GameMover mover, double angle) {\n        if (this instanceof Player) {\n            ((Player) this).changeHealth(\n                    -(((Zombie) mover).getDamage() + ((Player) this).state.getWave()));\n        }\n        System.out.println(((Zombie) mover).getDamage());\n    }\n\n    public void move() {\n        int dx = 0;\n        int dy = 0;\n\n        if (up) dy -= 1;\n        if (down) dy += 1;\n        if (left) dx -= 1;\n        if (right) dx += 1;\n\n        double l = Math.sqrt(dx * dx + dy * dy);\n\n        dx = (int) Math.round(dx / l * speed);\n        dy = (int) Math.round(dy / l * speed);\n\n        this.x += dx;\n        this.y += dy;\n\n        if (this.x < WIDTH / 2) this.x = WIDTH / 2;\n        if (this.y < HEIGHT / 2) this.y = HEIGHT / 2;\n        if (this.x > GamePanel.PANEL_WIDTH - WIDTH / 2) this.x = GamePanel.PANEL_WIDTH - WIDTH / 2;\n        if (this.y > GamePanel.PANEL_HEIGHT - HEIGHT / 2) this.y = GamePanel.PANEL_HEIGHT - HEIGHT / 2;\n\n        if (this instanceof Player player) {\n            if (player.mouseX != 0) {\n                double rdx = player.mouseX - x;\n                double rdy = player.mouseY - y;\n                this.rotation = Math.atan2(rdy, rdx);\n            }\n\n            if (player.reload) {\n                player.selectedGun.reload();\n            }\n\n            ArrayList<Bullet> removeList = new ArrayList<>();\n            for (Bullet bullet : player.bullets) {\n                bullet.move();\n                if (bullet.x < 0 || bullet.x > GamePanel.PANEL_WIDTH) {\n                    removeList.add(bullet);\n                } else if (bullet.y < 0 || bullet.y > GamePanel.PANEL_HEIGHT) {\n                    removeList.add(bullet);\n                }\n            }\n            removeList.forEach(player.bullets::remove);\n            if (player.shoot) {\n                player.selectedGun.shoot(player.x, player.y, player.rotation, player.bullets);\n            }\n        }\n    }\n}\n",
      "Collision.java": "package GameClasses;\n\nimport Guns.*;\nimport Zombies.AcidSpit;\nimport Zombies.AcidSpittingZombie;\nimport Zombies.CrawlerZombie;\nimport Zombies.Zombie;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Collision implements Serializable {\n    private final Player player;\n    LinkedList<Zombie> zombies;\n    LinkedList<Explosion> explosions;\n    LinkedList<Ammo> ammos;\n    LinkedList<HealthPack> healthPacks;\n\n    public Collision(Player player, LinkedList<Zombie> zombies, LinkedList<Explosion> explosions,\n                     LinkedList<Ammo> ammos, LinkedList<HealthPack> healthPacks) {\n        this.player = player;\n        this.zombies = zombies;\n        this.explosions = explosions;\n        this.ammos = ammos;\n        this.healthPacks = healthPacks;\n    }\n\n    public void detectCollisions() {\n        List<Zombie> toHitZ = new ArrayList<>();\n        List<Bullet> toRemoveB = new ArrayList<>();\n        List<Explosion> toRemoveE = new ArrayList<>();\n        List<Ammo> toRemoveA = new ArrayList<>();\n        List<HealthPack> toRemoveHP = new ArrayList<>();\n\n        int length = zombies.size();\n        Iterator<Zombie> iter = zombies.iterator();\n        int i = 1;\n        while (iter.hasNext()) {\n            Zombie z1 = iter.next();\n            boolean dead = false;\n            for (Bullet bullet : player.bullets) {\n                if (checkBullet(bullet, z1)) {\n                    dead = true;\n                    if (!bullet.canPenetrate()) {\n                        toRemoveB.add(bullet);\n                    }\n                    break;\n                }\n            }\n\n            if (!dead) {\n                checkCollision(player, z1);\n            } else {\n                toHitZ.add(z1);\n            }\n\n            if (i < length) {\n                Iterator<Zombie> iter2 = zombies.listIterator(i++);\n                while (iter2.hasNext()) {\n                    Zombie z2 = iter2.next();\n                    checkCollision(z1, z2);\n                }\n            }\n        }\n\n        for (Explosion e : explosions) {\n            for (Zombie z1 : zombies) {\n                double distance = Math.sqrt((e.x - z1.x) * (e.x - z1.x) + (e.y - z1.y) * (e.y - z1.y));\n                if (distance < e.radius) {\n                    toHitZ.add(z1);\n                }\n            }\n\n            double distance = Math.sqrt((e.x - player.x) * (e.x - player.x) + (e.y - player.y) * (e.y - player.y));\n            if (distance < e.radius) {\n                player.changeHealth(-e.damage);\n            }\n            toRemoveE.add(e);\n        }\n\n        for (AcidSpit as : player.acidSpits)\n        {\n            double distance = Math.sqrt((as.x - player.x) * (as.x - player.x) + (as.y - player.y) * (as.y - player.y));\n            if (distance < GameMover.collisionRadius)\n            {\n                player.changeHealth(-as.damage);\n            }\n        }\n\n        Gun gun = player.selectedGun;\n        int gunType = player.gunIndex + 1;\n        for (Ammo ammo : ammos) {\n            double distance = Math.sqrt((ammo.x - player.x) * (ammo.x - player.x) +\n                    (ammo.y - player.y) * (ammo.y - player.y));\n            if (distance < ammo.radius + GameMover.collisionRadius && gunType == ammo.getType())\n            {\n                gun.addMagazine();\n                toRemoveA.add(ammo);\n            }\n        }\n\n        for (HealthPack hp : healthPacks)\n        {\n            double distance = Math.sqrt((player.x - hp.x) * (player.x - hp.x) +\n                    (player.y - hp.y) * (player.y - hp.y));\n            if (distance < hp.radius + GameMover.collisionRadius)\n            {\n                player.changeHealth(hp.health);\n                toRemoveHP.add(hp);\n            }\n        }\n\n        for (Zombie z : toHitZ) {\n            if (z.hit()) {\n                player.changeScore(z.getPoints() + player.state.getWave());\n                if (z instanceof AcidSpittingZombie) {\n                    explosions.add(new Explosion(z.x, z.y, AcidSpittingZombie.explosionRadius));\n                }\n                zombies.remove(z);\n            }\n        }\n\n        for (Bullet b : toRemoveB) {\n            if (b instanceof ExplodingBullet) {\n                explosions.add(new Explosion(b.x, b.y, ExplodingBullet.radius));\n            }\n            player.bullets.remove(b);\n        }\n        for (Explosion e : toRemoveE) {\n            explosions.remove(e);\n        }\n        for (Ammo ammo : toRemoveA) {\n            ammos.remove(ammo);\n        }\n        for (HealthPack hp : toRemoveHP)\n        {\n            healthPacks.remove(hp);\n        }\n    }\n\n    private void checkCollision(GameMover o1, GameMover o2) {\n        double distance = Math.sqrt((o1.x - o2.x) * (o1.x - o2.x) + (o1.y - o2.y) * (o1.y - o2.y));\n\n        double angle = Math.atan2((o1.x - o2.x), (o1.y - o2.y));\n\n        if (distance < GameMover.collisionRadius) {\n            o1.collidedWith(o2, angle);\n            o2.collidedWith(o1, -angle);\n        } else if (o1 instanceof Player && o2 instanceof CrawlerZombie &&\n                distance < CrawlerZombie.jumpRadius && !((CrawlerZombie) o2).jumped) {\n            ((CrawlerZombie) o2).jump();\n        }\n    }\n\n    private boolean checkBullet(Bullet bullet, Zombie z) {\n        return Math.sqrt((z.x - bullet.x) * (z.x - bullet.x) +\n                (z.y - bullet.y) * (z.y - bullet.y)) < GameMover.collisionRadius;\n    }\n}\n",
      "GamePanel.java": "package GameClasses;\n\nimport Guns.Ammo;\nimport Guns.Bullet;\nimport Guns.Explosion;\nimport Zombies.AcidSpit;\nimport Zombies.Zombie;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\n\npublic class GamePanel extends JPanel implements Runnable {\n    public static final int PANEL_WIDTH = 1200;\n    public static final int PANEL_HEIGHT = 800;\n\n    private final int fps = 30;\n\n    private final ImageIcon background;\n\n    GameState state;\n    Collision collision;\n    Player player;\n\n    String saveFile = \".save\";\n\n    private long totalTime = 0;\n    private int frameCount = 0;\n    private double averageFps;\n\n    private Thread thread;\n\n    private BufferedImage image;\n    private Graphics2D g;\n\n    public GamePanel() {\n        super();\n        setPreferredSize(new Dimension(PANEL_WIDTH, PANEL_HEIGHT));\n\n        setFocusable(true);\n        requestFocus();\n\n        this.state = new GameState();\n        this.player = state.player;\n\n        collision = new Collision(player, state.zombies, state.explosions, state.ammos,\n                state.healthPacks);\n\n        GameInput input = new GameInput(state, this);\n        addKeyListener(input);\n        addMouseMotionListener(input);\n        addMouseListener(input);\n\n        background = new ImageIcon(\"res/background.png\");\n    }\n\n    @Override\n    public void run() {\n        image = new BufferedImage(PANEL_WIDTH, PANEL_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        g = (Graphics2D) image.getGraphics();\n\n        while (true) {\n            long start = System.nanoTime();\n\n            gameLoop();\n\n            long time = Math.round((System.nanoTime() - start) / 1000000.0);\n            long target = 1000 / fps;\n            try {\n                if (target > time)\n                    Thread.sleep(target - time);\n            } catch (InterruptedException e) {\n                e.fillInStackTrace();\n            }\n\n            totalTime += System.nanoTime() - start;\n            frameCount++;\n            if (frameCount == fps) {\n                averageFps = 1000.0 / ((1.0 * totalTime / frameCount) / 1000000.0);\n                frameCount = 0;\n                totalTime = 0;\n            }\n        }\n    }\n\n    private void gameLoop() {\n        if (state.running)\n        {\n            gameUpdate();\n            gameRender();\n        }\n        else if (state.lost)\n        {\n            renderLoseMenu();\n        }\n        else if (state.transition)\n        {\n            renderTransition();\n        }\n        else\n        {\n            renderMenu();\n        }\n\n        repaint();\n    }\n\n    private void gameUpdate() {\n        player.move();\n\n        for (Zombie z : state.zombies) {\n            z.move();\n        }\n\n        collision.detectCollisions();\n\n        state.checkState();\n    }\n\n    private void gameRender() {\n        g.setFont(new Font(\"Arial\", Font.PLAIN, 18));\n\n        g.setColor(Color.DARK_GRAY);\n        g.drawImage(background.getImage(), 0, 0, PANEL_WIDTH, PANEL_HEIGHT, this);\n\n        for (Ammo ammo : state.ammos) {\n            g.setColor(Color.BLACK);\n            g.fillOval(ammo.x - ammo.radius, ammo.y - ammo.radius,\n                    ammo.radius * 2, ammo.radius * 2);\n            g.setColor(Color.WHITE);\n            g.drawString(\"\" + ammo.getType(), ammo.x, ammo.y);\n        }\n\n        for(HealthPack hp : state.healthPacks)\n        {\n            g.setColor(Color.WHITE);\n            g.fillOval(hp.x - hp.radius, hp.y - hp.radius,\n                    hp.radius * 2, hp.radius * 2);\n            g.setColor(Color.BLACK);\n            g.drawString(\"C\", hp.x - hp.radius * 3 / 4, hp.y + hp.radius * 2 / 3);\n        }\n\n        AffineTransform backup = g.getTransform();\n        AffineTransform a;\n        for (Zombie z : state.zombies) {\n            a = AffineTransform.getRotateInstance(z.rotation, z.x, z.y);\n            a.rotate(0, 0, 0);\n            g.setTransform(a);\n            g.drawImage(z.getImage(), z.x - Zombie.WIDTH / 2, z.y - Zombie.HEIGHT / 2,\n                    Zombie.WIDTH, Zombie.HEIGHT, this);\n        }\n        a = AffineTransform.getRotateInstance(player.rotation, player.x, player.y);\n        a.rotate(0, 0, 0);\n        g.setTransform(a);\n        g.drawImage(player.getImage(), player.x - Player.WIDTH / 2, player.y - Player.HEIGHT / 2,\n                Player.WIDTH, Player.HEIGHT, this);\n        g.setTransform(backup);\n\n        g.setColor(Color.GREEN);\n        g.drawString(\"Can: \" + player.getHealth(), PANEL_WIDTH - 100, 25);\n        g.setColor(Color.WHITE);\n        g.drawString(\"Toplam Puan: \" + player.getScore(), PANEL_WIDTH - 300, 25);\n\n        g.drawString(\"(\" + (player.gunIndex + 1) + \") \" + player.selectedGunName + \": \", 25, 25);\n        g.drawString(player.selectedGun.getTotalBullets() + \" / \" + player.selectedGun.getBullets() + \" mermi \",\n                45 + 12 * player.lengthOfGunName, 25);\n\n        g.setColor(Bullet.COLOR);\n        for (Bullet bullet : player.bullets) {\n            if (bullet instanceof AcidSpit)\n            {\n                g.setColor(AcidSpit.COLOR);\n                g.fillOval(bullet.x, bullet.y, 15, 15);\n                g.setColor(Bullet.COLOR);\n                continue;\n            }\n            g.fillOval(bullet.x, bullet.y, 10, 10);\n        }\n        g.setColor(Color.WHITE);\n\n        g.setColor(new Color(255, 255, 255, 64));\n        for (Explosion e : state.explosions) {\n            e.draw(g);\n        }\n\n        g.setColor(Color.WHITE);\n        g.drawString(\"Fps: \" + averageFps, 20, PANEL_HEIGHT - 25);\n        g.drawString(\"Toplam Zombi: \" + state.zombies.size(),\n                PANEL_WIDTH - 200, PANEL_HEIGHT - 25);\n    }\n\n    private void renderLoseMenu() {\n        g.setFont(new Font(\"Arial\", Font.BOLD, 70));\n        g.setColor(Color.RED);\n        g.drawString(\"You Lost, Press G to start again\", 50, PANEL_HEIGHT / 2);\n        g.drawString(\"Press L to load.\", 300, PANEL_HEIGHT / 2 + 100);\n    }\n\n\n    private void renderMenu() {\n        g.setFont(new Font(\"Arial\", Font.BOLD, 60));\n        g.setColor(Color.WHITE);\n        g.drawString(\"You paused, press Esc to start again\", 50, PANEL_HEIGHT / 2 - 100);\n        g.drawString(\"Press F to save, L to load.\", 200, PANEL_HEIGHT / 2 + 100);\n    }\n\n    private void renderTransition()\n    {\n        gameUpdate();\n        gameRender();\n        g.setFont(new Font(\"Arial\", Font.BOLD, 45));\n        g.setColor(Color.WHITE);\n\n        g.drawString(state.getWave() + \". dalgayı atlattın. Kaydetmek için F e\",\n                50, PANEL_HEIGHT / 2 - 100);\n        g.drawString(\"devam etmek için C ye bas. (Silah değişterebilirsin)\",\n                50, PANEL_HEIGHT / 2 );\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        g.drawImage(image, 0, 0, this);\n    }\n\n    @Override\n    public void addNotify() {\n        super.addNotify();\n        if (thread == null) {\n            thread = new Thread(this);\n            thread.start();\n        }\n    }\n\n    public void save() {\n        if (state.running || state.lost) {\n            return;\n        }\n        try {\n            FileOutputStream fos = new FileOutputStream(saveFile);\n            BufferedOutputStream bos = new BufferedOutputStream(fos);\n            ObjectOutputStream oos = new ObjectOutputStream(bos);\n            oos.writeObject(state);\n            oos.writeObject(collision);\n            oos.close();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void load() {\n        if (!new File(saveFile).exists() || state.running)\n            return;\n        try {\n            FileInputStream fis = new FileInputStream(saveFile);\n            BufferedInputStream bis = new BufferedInputStream(fis);\n            ObjectInputStream ois = new ObjectInputStream(bis);\n            state = (GameState) ois.readObject();\n            if (!state.transition) state.running = true;\n            collision = (Collision) ois.readObject();\n            player = state.player;\n            player.clearInputs();\n\n            GameInput input = new GameInput(state, this);\n            addKeyListener(input);\n            addMouseMotionListener(input);\n            addMouseListener(input);\n\n            ois.close();\n        } catch (IOException | ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
      "GameInput.java": "package GameClasses;\n\nimport java.awt.event.*;\n\npublic class GameInput implements KeyListener, MouseMotionListener, MouseListener {\n    Player player;\n    GameState state;\n    GamePanel panel;\n\n    public GameInput(GameState state, GamePanel panel) {\n        this.state = state;\n        this.player = state.player;\n        this.panel = panel;\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int code = e.getExtendedKeyCode();\n        if (code == KeyEvent.VK_UP || code == KeyEvent.VK_W) {\n            player.up = true;\n        }\n        if (code == KeyEvent.VK_DOWN || code == KeyEvent.VK_S) {\n            player.down = true;\n        }\n        if (code == KeyEvent.VK_LEFT || code == KeyEvent.VK_A) {\n            player.left = true;\n        }\n        if (code == KeyEvent.VK_RIGHT || code == KeyEvent.VK_D) {\n            player.right = true;\n        }\n\n        if (code == KeyEvent.VK_X) {\n            player.shoot = true;\n        }\n        if (code == KeyEvent.VK_R) {\n            player.reload = true;\n        }\n\n        if (code == KeyEvent.VK_ESCAPE) {\n            state.esc();\n        }\n        if (code == KeyEvent.VK_G) {\n            state.refresh();\n        }\n\n        if (code == KeyEvent.VK_F) {\n            panel.save();\n        }\n        if (code == KeyEvent.VK_L) {\n            panel.load();\n        }\n\n        if (code == KeyEvent.VK_C) {\n            state.nextWave();\n        }\n\n        if (code == KeyEvent.VK_1) {\n            player.changeGun(1);\n        }\n        if (code == KeyEvent.VK_2) {\n            player.changeGun(2);\n        }\n        if (code == KeyEvent.VK_3) {\n            player.changeGun(3);\n        }\n        if (code == KeyEvent.VK_4) {\n            player.changeGun(4);\n        }\n        if (code == KeyEvent.VK_5) {\n            player.changeGun(5);\n        }\n\n        if (code == KeyEvent.VK_Q) {\n            player.changeGunLeft();\n        }\n        if (code == KeyEvent.VK_E) {\n            player.changeGunRight();\n        }\n\n        if (code == KeyEvent.VK_M) {\n            state.testZombie(300);\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int code = e.getExtendedKeyCode();\n        if (code == KeyEvent.VK_UP || code == KeyEvent.VK_W) {\n            player.up = false;\n        }\n        if (code == KeyEvent.VK_DOWN || code == KeyEvent.VK_S) {\n            player.down = false;\n        }\n        if (code == KeyEvent.VK_LEFT || code == KeyEvent.VK_A) {\n            player.left = false;\n        }\n        if (code == KeyEvent.VK_RIGHT || code == KeyEvent.VK_D) {\n            player.right = false;\n        }\n\n        if (code == KeyEvent.VK_X) {\n            player.shoot = false;\n        }\n        if (code == KeyEvent.VK_R) {\n            player.reload = false;\n        }\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        player.mouseX = (e.getX());\n        player.mouseY = (e.getY());\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        player.mouseX = (e.getX());\n        player.mouseY = (e.getY());\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        player.mouseX = (e.getX());\n        player.mouseY = (e.getY());\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n\n        if (e.getButton() == MouseEvent.BUTTON1) {\n            player.shoot = true;\n        }\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        if (e.getButton() == MouseEvent.BUTTON1) {\n            player.shoot = false;\n        }\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e) {\n    }\n}",
      "Game.java": "package GameClasses;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class Game {\n    public static final String NAME = \"YsoShooter\";\n    public static final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n\n    public static void main(String[] args) {\n        JFrame window = new JFrame(NAME);\n        window.setLocation(screenSize.width / 2 - GamePanel.PANEL_WIDTH / 2,\n                -30 + screenSize.height / 2 - GamePanel.PANEL_HEIGHT / 2);\n        window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        window.setContentPane(new GamePanel());\n        window.setResizable(false);\n\n        window.requestFocus();\n\n        window.pack();\n        window.setVisible(true);\n    }\n}",
      "Player.java": "package GameClasses;\n\nimport Guns.*;\nimport Zombies.AcidSpit;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Player extends GameMover {\n    public boolean INVINCIBLE = false;\n\n    public static final int WIDTH = 50;\n    public static final int HEIGHT = 50;\n\n    final GameState state;\n\n    protected boolean shoot;\n    protected boolean reload;\n\n    protected int mouseX;\n    protected int mouseY;\n\n    public Set<Bullet> bullets = new HashSet<>();\n    public Set<AcidSpit> acidSpits = new HashSet<>();\n    ArrayList<Gun> inventory = new ArrayList<>();\n    Gun selectedGun;\n    String selectedGunName;\n    int lengthOfGunName;\n    int gunIndex = -1;\n\n    private ArrayList<ImageIcon> icons;\n    private ImageIcon currentIcon;\n\n    private int health = 100;\n    private int score = 0;\n\n    public Player(GameState state) {\n        this(GamePanel.PANEL_WIDTH / 2, GamePanel.PANEL_HEIGHT / 2, state);\n\n        icons = new ArrayList<>();\n        icons.add(new ImageIcon(\"res/player_pistol.png\"));\n        icons.add(new ImageIcon(\"res/assault_rifle_player.png\"));\n        icons.add(new ImageIcon(\"res/shotgun_player.png\"));\n        icons.add(new ImageIcon(\"res/sniper_rifle_player.png\"));\n        icons.add(new ImageIcon(\"res/rocket_launcher_player.png\"));\n\n        inventory.add(new Pistol());\n        inventory.add(new AssaultRifle());\n        inventory.add(new Shotgun());\n        inventory.add(new SniperRifle());\n        inventory.add(new RocketLauncher());\n\n        gunIndex = 0;\n        selectedGun = inventory.get(gunIndex);\n        selectedGunName = selectedGun.name;\n        lengthOfGunName = selectedGunName.length();\n        currentIcon = icons.get(gunIndex);\n    }\n\n    public Player(int x, int y, GameState state) {\n        super(x, y);\n        this.state = state;\n    }\n\n    protected void changeGun(int i) {\n        i--;\n        if (i == gunIndex) return;\n        if (i < inventory.size() && i < state.unlockedGuns()) {\n            selectedGun = inventory.get(i);\n            selectedGunName = selectedGun.name;\n            lengthOfGunName = selectedGunName.length();\n            gunIndex = i;\n            currentIcon = icons.get(i);\n        }\n    }\n\n    public void changeGunLeft()\n    {\n        if (gunIndex > 0)\n        {\n            changeGun(gunIndex);\n        }\n    }\n\n    public void changeGunRight()\n    {\n        if (gunIndex < state.unlockedGuns() - 1)\n        {\n            changeGun(gunIndex+2);\n        }\n    }\n\n    public void changeScore(int change) {\n        score += change;\n    }\n\n    public void changeHealth(int change) {\n        if (INVINCIBLE)\n        {\n            health = 100;\n            return;\n        }\n        health += change;\n        if (health <= 0) {\n            health = 0;\n            state.lose();\n        }\n    }\n\n    public void clearInputs() {\n        up = false;\n        down = false;\n        left = false;\n        right = false;\n\n        shoot = false;\n    }\n\n    public void refresh() {\n        clearInputs();\n\n        x = GamePanel.PANEL_WIDTH / 2;\n        y = GamePanel.PANEL_HEIGHT / 2;\n        health = 100;\n        score = 0;\n\n        bullets.clear();\n        acidSpits.clear();\n        inventory.clear();\n        inventory.add(new Pistol());\n        inventory.add(new AssaultRifle());\n        inventory.add(new Shotgun());\n        inventory.add(new SniperRifle());\n        inventory.add(new RocketLauncher());\n\n        changeGun(1);\n    }\n\n    public Image getImage() {\n        return currentIcon.getImage();\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public int getScore()\n    {\n        return score;\n    }\n\n    public int getX()\n    {\n        return x;\n    }\n\n    public int getY()\n    {\n        return y;\n    }\n}",
      "GameObject.java": "package GameClasses;\n\nimport java.io.Serializable;\n\npublic abstract class GameObject implements Serializable {\n    protected int x;\n    protected int y;\n    protected double rotation;\n\n    public GameObject(int x, int y) {\n        this(x, y, 0);\n    }\n\n    public GameObject(int x, int y, int rotation) {\n        this.x = x;\n        this.y = y;\n        this.rotation = rotation;\n    }\n}\n",
      "GameState.java": "package GameClasses;\n\nimport Guns.Ammo;\nimport Guns.Explosion;\nimport Zombies.Zombie;\n\nimport java.io.Serializable;\nimport java.util.LinkedList;\n\npublic class GameState implements Serializable\n{\n    final Player player;\n\n    public boolean lost = false;\n\n    public LinkedList<Zombie> zombies = new LinkedList<>();\n    public LinkedList<Explosion> explosions = new LinkedList<>();\n    public LinkedList<Ammo> ammos = new LinkedList<>();\n    public LinkedList<HealthPack> healthPacks = new LinkedList<>();\n\n    boolean running = true;\n    private int wave = 1;\n    private int unlockedGuns = 1;\n    boolean transition;\n\n    public GameState()\n    {\n        this.player = new Player(this);\n\n        GameWave gw = new GameWave(wave, this.player);\n        zombies.addAll(gw.getZombies());\n        ammos.addAll(gw.getAmmos());\n        healthPacks.addAll(gw.getHealthPacks());\n    }\n\n    public void checkState()\n    {\n        if (zombies.isEmpty() && !transition)\n        {\n            transition = true;\n            running = false;\n            player.bullets.clear();\n            unlockedGuns++;\n        }\n        else if (zombies.isEmpty() && player.INVINCIBLE)\n        {\n            player.INVINCIBLE = false;\n            refresh();\n            transition = false;\n        }\n    }\n\n    public void nextWave()\n    {\n        if (transition)\n        {\n            player.bullets.clear();\n            explosions.clear();\n            wave++;\n\n            GameWave gw = new GameWave(wave, player);\n            zombies.addAll(gw.getZombies());\n            ammos.addAll(gw.getAmmos());\n            healthPacks.addAll(gw.getHealthPacks());\n\n            transition = false;\n            running = true;\n        }\n    }\n\n    public void lose()\n    {\n        running = false;\n        lost = true;\n    }\n\n    public void esc()\n    {\n        if (!lost && !transition)\n        {\n            running = !running;\n        }\n    }\n\n    public int unlockedGuns()\n    {\n        return unlockedGuns;\n    }\n\n    public void refresh()\n    {\n        if (running)\n        {\n            return;\n        }\n        player.refresh();\n        lost = false;\n        running = true;\n        wave = 1;\n        unlockedGuns = 1;\n\n        zombies.clear();\n        explosions.clear();\n        ammos.clear();\n        healthPacks.clear();\n\n        player.changeGun(unlockedGuns);\n        GameWave gw = new GameWave(wave, player);\n        zombies.addAll(gw.getZombies());\n        ammos.addAll(gw.getAmmos());\n    }\n\n    public int getWave()\n    {\n        return wave;\n    }\n\n    public void testZombie(int i)\n    {\n        if (player.INVINCIBLE)\n        {\n            return;\n        }\n        player.refresh();\n        player.INVINCIBLE = true;\n\n        GameWave gw = new GameWave(player, i);\n        zombies.addAll(gw.getZombies());\n\n        running = true;\n    }\n}\n\n",
      "Zombie.java": "package Zombies;\n\nimport GameClasses.GameMover;\nimport GameClasses.GamePanel;\nimport GameClasses.Player;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class Zombie extends GameMover {\n    public static final int WIDTH = 50;\n    public static final int HEIGHT = 50;\n\n    protected int bulletsToDie = 2;\n    protected int speed = 4;\n    protected int damage = 2;\n    protected int points = 10;\n\n    ImageIcon icon;\n    Player player;\n\n    private final int sight = 600;\n\n\n    public Zombie(int x, int y, Player player) {\n        super(x, y);\n        this.icon = new ImageIcon(\"res/zombie.png\");\n        this.player = player;\n    }\n\n    @Override\n    public void collidedWith(GameMover mover, double angle) {\n        angle -= Math.PI / 2;\n        int force = 10;\n        if (mover instanceof Zombie) {\n            force = 8;\n        }\n        double dx = Math.cos(angle) * force;\n        double dy = Math.sin(angle) * force;\n\n        this.x += (int) Math.round(dx);\n        this.y += (int) Math.round(dy);\n    }\n\n    @Override\n    public void move() {\n        int dx = player.getX() - this.x;\n        int dy = player.getY() - this.y;\n\n        double l = Math.sqrt(dx * dx + dy * dy);\n\n        if (l < sight && l > GameMover.collisionRadius) {\n            this.x += (int) Math.round(dx / l * speed);\n            this.y += (int) Math.round(dy / l * speed);\n\n            double rdx = player.getX() - this.x;\n            double rdy = player.getY() - this.y;\n            this.rotation = Math.atan2(rdy, rdx);\n        }\n\n        if (this.x < WIDTH / 2) {\n            this.x = WIDTH / 2 + 20;\n            rotation += Math.PI;\n        }\n        if (this.y < HEIGHT / 2) {\n            this.y = HEIGHT / 2 + 20;\n            rotation += Math.PI;\n        }\n        if (this.x > GamePanel.PANEL_WIDTH - WIDTH / 2) {\n            this.x = GamePanel.PANEL_WIDTH - WIDTH / 2 - 20;\n            rotation += Math.PI;\n        }\n        if (this.y > GamePanel.PANEL_HEIGHT - HEIGHT / 2) {\n            this.y = GamePanel.PANEL_HEIGHT - HEIGHT / 2 - 20;\n            rotation += Math.PI;\n        }\n\n        if (l > sight) {\n            this.rotation += Math.PI / 10 * (Math.random() - 0.5);\n\n            this.x += (int) Math.round(Math.cos(rotation) * speed);\n            this.y += (int) Math.round(Math.sin(rotation) * speed);\n        }\n    }\n\n    public boolean hit() {\n        bulletsToDie--;\n        return bulletsToDie == 0;\n    }\n\n    public Image getImage() {\n        return icon.getImage();\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public int getPoints() {\n        return points;\n    }\n}\n",
      "AcidSpit.java": "package Zombies;\n\n\nimport Guns.ExplodingBullet;\n\nimport java.awt.*;\n\npublic class AcidSpit extends ExplodingBullet\n{\n    public static final Color COLOR = Color.GREEN;\n    public int damage = 10;\n\n    public AcidSpit(int x, int y, double rotation)\n    {\n        super(x, y, rotation);\n    }\n}\n",
      "AcidSpittingZombie.java": "package Zombies;\n\nimport GameClasses.Player;\n\nimport javax.swing.*;\n\npublic class AcidSpittingZombie extends Zombie {\n    public static int explosionRadius = 150;\n\n    long spitTime = 4000;\n\n    long timer;\n    long startTime = System.currentTimeMillis();\n\n    public AcidSpittingZombie(int x, int y, Player player) {\n        super(x, y, player);\n        this.bulletsToDie = 1;\n        this.speed = 3;\n        this.damage = 2;\n\n        this.icon = new ImageIcon(\"res/acid_spitting_zombie.png\");\n\n        points = 12;\n    }\n\n    @Override\n    public void move()\n    {\n        super.move();\n        timer = System.currentTimeMillis() - startTime;\n        if (timer > spitTime)\n        {\n            spit();\n            startTime = System.currentTimeMillis();\n        }\n    }\n\n    public void spit()\n    {\n        int x = this.x + (int) Math.round(Math.cos(rotation) * 50);\n        int y = this.y + (int) Math.round(Math.sin(rotation) * 50);\n        AcidSpit as = new AcidSpit(x, y, rotation);\n        player.acidSpits.add(as);\n        player.bullets.add(as);\n    }\n}\n",
      "CrawlerZombie.java": "package Zombies;\n\nimport GameClasses.Player;\n\nimport javax.swing.*;\n\npublic class CrawlerZombie extends Zombie {\n    public static double jumpRadius = 175;\n\n    public boolean jumped;\n    private final int jumpLength = 120;\n\n    public CrawlerZombie(int x, int y, Player player) {\n        super(x, y, player);\n        this.bulletsToDie = 1;\n        this.speed = 6;\n        this.damage = 2;\n\n        this.icon = new ImageIcon(\"res/crawler_zombie.png\");\n\n        points = 6;\n    }\n\n    public void jump() {\n        double dx = Math.cos(rotation) * jumpLength;\n        double dy = Math.sin(rotation) * jumpLength;\n\n        this.x += (int) Math.round(dx);\n        this.y += (int) Math.round(dy);\n        jumped = true;\n    }\n}\n",
      "TankZombie.java": "package Zombies;\n\nimport GameClasses.Player;\n\nimport javax.swing.*;\n\npublic class TankZombie extends Zombie {\n    public TankZombie(int x, int y, Player player) {\n        super(x, y, player);\n        this.bulletsToDie = 5;\n        this.speed = 2;\n        this.damage = 5;\n\n        this.icon = new ImageIcon(\"res/tank_zombie.png\");\n\n        points = 15;\n    }\n}\n"
    },
    {
      "id": "8964453",
      "ShellCasing.java": "import java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class ShellCasing {\n    double x, y;\n    double dx, dy;\n    int life = 80;\n    BufferedImage image;\n\n    public ShellCasing(int startX, int startY) {\n        x = startX;\n        y = startY;\n\n        double angle = Math.toRadians(Math.random() * 360);\n        double speed = 1.0 + Math.random() * 2.5;\n\n        dx = Math.cos(angle) * speed;\n        dy = Math.sin(angle) * speed;\n\n        try {\n            image = ImageIO.read(new File(\"Sprites/Effects/shell.png\"));\n            image = resizeImage(image, 3, 6);\n        } catch (IOException e) {\n            System.out.println(\"[HATA] Shell image yüklenemedi.\");\n        }\n    }\n\n    public void update() {\n        x += dx;\n        y += dy;\n        life--;\n    }\n\n    public boolean isAlive() {\n        return life > 0;\n    }\n\n    public void draw(Graphics2D g2d) {\n        g2d.drawImage(image, (int) x - image.getWidth() / 2, (int) y - image.getHeight() / 2, null);\n    }\n\n    private BufferedImage resizeImage(BufferedImage originalImage, int targetWidth, int targetHeight) {\n        Image scaledImage = originalImage.getScaledInstance(targetWidth, targetHeight, Image.SCALE_SMOOTH);\n        BufferedImage resizedImage = new BufferedImage(targetWidth, targetHeight, BufferedImage.TYPE_INT_ARGB);\n\n        Graphics2D g2 = resizedImage.createGraphics();\n        g2.drawImage(scaledImage, 0, 0, null);\n        g2.dispose();\n\n        return resizedImage;\n    }\n}\n",
      "Zombie.java": "import java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\nimport javax.imageio.ImageIO;\n\npublic abstract class Zombie {\n    protected int x, y;\n    protected int health;\n    protected double speed;\n    protected int damage;\n    protected boolean alive = true;\n    protected boolean isAttacking = false;\n    protected int attackIndex = 0, attackCounter = 0, attackDelay = 6;\n    protected int walkIndex = 0, walkCounter = 0, walkDelay = 10;\n    protected int attackCooldown = 0;\n    protected int defaultCooldown = 60;\n\n    protected BufferedImage[] walkFrames;\n    protected BufferedImage[] attackFrames;\n\n    public Zombie(int x, int y, int health, double speed, int damage) {\n        this.x = x;\n        this.y = y;\n        this.health = health;\n        this.speed = speed;\n        this.damage = damage;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public abstract void draw(Graphics2D g2d);\n\n    public void takeDamage(int amount) {\n        health -= amount;\n        if (health <= 0) {\n            alive = false;\n            onDeath();\n        }\n    }\n\n    public void takeDamage(int amount, double pushAngle) {\n        takeDamage(amount);\n\n        x += (int) (Math.cos(pushAngle) * 8);\n        y += (int) (Math.sin(pushAngle) * 8);\n    }\n\n    public boolean isAlive() {\n        return alive;\n    }\n\n    public boolean justDied() {\n        return !alive && health <= 0;\n    }\n\n    protected void onDeath() {\n        // override if needed\n    }\n\n    public boolean isCollidingWithPlayer(Player player) {\n        Rectangle zombieRect = new Rectangle(x, y, 32, 32);\n        Rectangle playerRect = new Rectangle(player.getX(), player.getY(), player.getSize(), player.getSize());\n        return zombieRect.intersects(playerRect);\n    }\n\n    protected BufferedImage resizeImage(BufferedImage original, int w, int h) {\n        Image scaled = original.getScaledInstance(w, h, Image.SCALE_SMOOTH);\n        BufferedImage resized = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2 = resized.createGraphics();\n        g2.drawImage(scaled, 0, 0, null);\n        g2.dispose();\n        return resized;\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 32, 32);\n    }\n\n    public abstract void update(Player player, List<Zombie> zombies, List<Rectangle> obstacles);\n\n}\n\nclass Guts {\n    private int x, y;\n    private int duration = 120; // 3 saniye\n    private BufferedImage sprite;\n\n    public Guts(int x, int y) {\n        this.x = x;\n        this.y = y;\n\n        try {\n            sprite = ImageIO.read(new File(\"Sprites/Effects/guts.png\"));\n        } catch (IOException e) {\n            System.out.println(\"[HATA] Acid sprite yüklenemedi.\");\n        }\n    }\n\n    public void update() {\n        duration--;\n    }\n\n    public boolean isAlive() {\n        return duration > 0;\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 16, 16);\n    }\n\n    public void draw(Graphics2D g2d) {\n        g2d.drawImage(sprite, x, y, 16, 16, null);\n    }\n}\n",
      "PiercingBullet.java": "import java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class PiercingBullet extends Bullet {\n    private BufferedImage image;\n    private final int width = 6, height = 6;\n    private int lifetime = 120; // 2 saniye\n\n    public PiercingBullet(int x, int y, double angle) {\n        super(x, y, angle);\n        try {\n            image = ImageIO.read(new File(\"Sprites/Effects/bullet.png\"));\n        } catch (IOException e) {\n            System.out.println(\"[HATA] PiercingBullet görseli yok.\");\n        }\n    }\n\n    @Override\n    public void update() {\n        x += dx;\n        y += dy;\n        lifetime--;\n    }\n\n    public boolean isAlive() {\n        return lifetime > 0;\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, width, height);\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        if (image != null) {\n            g2d.drawImage(image, x, y, width, height, null);\n        } else {\n            g2d.setColor(Color.CYAN);\n            g2d.fillOval(x, y, width, height);\n        }\n    }\n}\n",
      "PlayerBlood.java": "import java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Random;\nimport javax.imageio.ImageIO;\n\npublic class PlayerBlood {\n    private int x, y;\n    private int duration = 60; // kaç frame sonra kaybolsun\n    private BufferedImage image;\n\n    private static final int OFFSET_RANGE = 12; // +/- max offset\n    private static final Random rand = new Random();\n\n    public PlayerBlood(int x, int y) {\n        int offsetX = rand.nextInt(OFFSET_RANGE * 2 + 1) - OFFSET_RANGE;\n        int offsetY = rand.nextInt(OFFSET_RANGE * 2 + 1) - OFFSET_RANGE;\n\n        this.x = x + offsetX;\n        this.y = y + offsetY;\n\n        try {\n            image = ImageIO.read(new File(\"Sprites/Effects/guts.png\"));\n        } catch (IOException e) {\n            System.out.println(\"[HATA] Player kan efekti yüklenemedi.\");\n        }\n    }\n\n    public void update() {\n        duration--;\n    }\n\n    public boolean isAlive() {\n        return duration > 0;\n    }\n\n    public void draw(Graphics2D g2d) {\n        if (image != null)\n            g2d.drawImage(image, x, y, 8, 8, null);\n    }\n}\n",
      "AcidZombie.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\nimport javax.imageio.ImageIO;\n\npublic class AcidZombie extends Zombie {\n\n    private final double ATTACK_RANGE = 20;\n\n    public AcidZombie(int x, int y) {\n        super(x, y, 50, 1.1, 30);\n\n        walkFrames = new BufferedImage[4];\n        attackFrames = new BufferedImage[6];\n\n        try {\n            for (int i = 0; i < 4; i++) {\n                String path = String.format(\"Sprites/Zombie/AcidZombie/AcidZombie_Walk/%02d_AcidZombie_Walk.png\", i);\n                walkFrames[i] = resizeImage(ImageIO.read(new File(path)), 32, 32);\n            }\n\n            for (int i = 0; i < 6; i++) {\n                String path = String.format(\"Sprites/Zombie/AcidZombie/AcidZombie_Attack/%02d_AcidZombie_Attack.png\",\n                        i);\n                attackFrames[i] = resizeImage(ImageIO.read(new File(path)), 32, 32);\n            }\n\n        } catch (IOException e) {\n            System.out.println(\"[HATA] AcidZombie sprite'ları yüklenemedi.\");\n        }\n    }\n\n    @Override\n    protected void onDeath() {\n        // Ölünce yere asit bırakma kodu GamePanel'de yazılıyor\n    }\n\n    @Override\n    public void update(Player player, List<Zombie> zombies, List<Rectangle> obstacles) {\n        if (!alive)\n            return;\n\n        double dx = player.getX() - x;\n        double dy = player.getY() - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        // === SALDIRI ===\n        if (distance < ATTACK_RANGE) {\n            if (attackCooldown <= 0) {\n                player.takeDamage(damage);\n                attackCooldown = defaultCooldown;\n                attackIndex = 0;\n                attackCounter = 0;\n                isAttacking = true;\n            }\n        }\n\n        // === HAREKET ===\n        if (!isAttacking && distance >= ATTACK_RANGE) {\n            double nextX = x + speed * dx / distance;\n            double nextY = y + speed * dy / distance;\n            Rectangle nextBounds = new Rectangle((int) nextX, (int) nextY, 32, 32);\n\n            boolean blocked = false;\n\n            for (Zombie other : zombies) {\n                if (other != this && other.isAlive() && nextBounds.intersects(other.getBounds())) {\n                    blocked = true;\n                    break;\n                }\n            }\n\n            for (Rectangle rect : obstacles) {\n                if (nextBounds.intersects(rect)) {\n                    blocked = true;\n                    break;\n                }\n            }\n\n            if (!blocked) {\n                x = (int) nextX;\n                y = (int) nextY;\n            }\n        }\n\n        // === COOLDOWN ===\n        if (attackCooldown > 0)\n            attackCooldown--;\n\n        // === ANİMASYON ===\n        if (isAttacking) {\n            attackCounter++;\n            if (attackCounter >= attackDelay) {\n                attackCounter = 0;\n                attackIndex++;\n                if (attackIndex >= attackFrames.length) {\n                    attackIndex = 0;\n                    isAttacking = false;\n                }\n            }\n        } else {\n            walkCounter++;\n            if (walkCounter >= walkDelay) {\n                walkCounter = 0;\n                walkIndex = (walkIndex + 1) % walkFrames.length;\n            }\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        BufferedImage frame = isAttacking ? attackFrames[attackIndex] : walkFrames[walkIndex];\n        g2d.drawImage(frame, x, y, null);\n    }\n}\n",
      "Weapon.java": "import java.util.List;\n\npublic abstract class Weapon {\n    protected int magSize;\n    protected int currentAmmo;\n    protected int reserveAmmo;\n    protected double fireRate;\n    protected long lastShotTime = 0;\n\n    public Weapon(int magSize, int reserveAmmo, double fireRate) {\n        this.magSize = magSize;\n        this.reserveAmmo = reserveAmmo;\n        this.currentAmmo = magSize;\n        this.fireRate = fireRate;\n    }\n\n    public boolean canShoot() {\n        long now = System.currentTimeMillis();\n        return currentAmmo > 0 && (now - lastShotTime) >= (60000 / fireRate);\n    }\n\n    public void shoot() {\n        if (canShoot()) {\n            currentAmmo--;\n            lastShotTime = System.currentTimeMillis();\n        }\n    }\n\n    public void reload() {\n        int needed = magSize - currentAmmo;\n        int taken = Math.min(needed, reserveAmmo);\n        currentAmmo += taken;\n        reserveAmmo -= taken;\n    }\n\n    public boolean needsReload() {\n        return currentAmmo < magSize && reserveAmmo > 0;\n    }\n\n    public void addReserveAmmo(int amount) {\n        reserveAmmo += amount;\n    }\n\n    public int getAmmo() {\n        return currentAmmo;\n    }\n\n    public int getMagSize() {\n        return magSize;\n    }\n\n    public int getReserveAmmo() {\n        return reserveAmmo;\n    }\n\n    public abstract void fire(double angle, int x, int y,\n            List<Bullet> bullets,\n            List<RocketAmmo> rockets,\n            List<SmokeEffect> smoke);\n\n    public abstract String getName();\n}\n\n// Örnek Handgun\nclass Handgun extends Weapon {\n    public Handgun() {\n        super(12, 9999, 120);\n    }\n\n    @Override\n    public void fire(double angle, int x, int y, List<Bullet> bullets,\n            List<RocketAmmo> rockets, List<SmokeEffect> smoke) {\n        if (!canShoot())\n            return;\n        shoot();\n        bullets.add(new Bullet(x, y, angle));\n    }\n\n    @Override\n    public String getName() {\n        return \"Handgun\";\n    }\n}\n\n// Rifle\nclass Rifle extends Weapon {\n    public Rifle() {\n        super(30, 120, 600);\n    }\n\n    @Override\n    public void fire(double angle, int x, int y, List<Bullet> bullets,\n            List<RocketAmmo> rockets, List<SmokeEffect> smoke) {\n        if (!canShoot())\n            return;\n        shoot();\n        double spread = Math.toRadians(30);\n        double offset = (Math.random() - 0.5) * spread;\n        bullets.add(new Bullet(x, y, angle + offset));\n    }\n\n    @Override\n    public String getName() {\n        return \"Rifle\";\n    }\n}\n\n// Shotgun\nclass Shotgun extends Weapon {\n    public Shotgun() {\n        super(5, 25, 60);\n    }\n\n    @Override\n    public void fire(double angle, int x, int y, List<Bullet> bullets,\n            List<RocketAmmo> rockets, List<SmokeEffect> smoke) {\n        if (!canShoot())\n            return;\n        shoot();\n        int pelletCount = 9;\n        double totalSpread = Math.toRadians(45);\n        double delta = totalSpread / (pelletCount - 1);\n        for (int i = 0; i < pelletCount; i++) {\n            double offset = -totalSpread / 2 + delta * i;\n            bullets.add(new Bullet(x, y, angle + offset));\n        }\n    }\n\n    @Override\n    public String getName() {\n        return \"Shotgun\";\n    }\n}\n\n// Sniper => PiercingBullet\nclass Sniper extends Weapon {\n    public Sniper() {\n        super(5, 15, 30);\n    }\n\n    @Override\n    public void fire(double angle, int x, int y, List<Bullet> bullets,\n            List<RocketAmmo> rockets, List<SmokeEffect> smoke) {\n        if (!canShoot())\n            return;\n        shoot();\n        bullets.add(new PiercingBullet(x, y, angle));\n    }\n\n    @Override\n    public String getName() {\n        return \"Sniper\";\n    }\n}\n\n// Rocket => rocket ammo\nclass Rocket extends Weapon {\n    public Rocket() {\n        super(1, 5, 10);\n    }\n\n    @Override\n    public void fire(double angle, int x, int y,\n            List<Bullet> bullets, List<RocketAmmo> rockets,\n            List<SmokeEffect> smokeList) {\n        if (!canShoot())\n            return;\n        shoot();\n        rockets.add(new RocketAmmo(x, y, angle, smokeList));\n    }\n\n    @Override\n    public String getName() {\n        return \"Rocket\";\n    }\n}\n",
      "Bullet.java": "import java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\nclass Bullet {\n    int x, y;\n    double dx, dy;\n    int speed = 10;\n    BufferedImage bulletImage;\n\n    public Bullet(int startX, int startY, double angle) {\n        x = startX;\n        y = startY;\n        dx = Math.cos(angle) * speed;\n        dy = Math.sin(angle) * speed;\n\n        try {\n            bulletImage = ImageIO.read(new File(\"Sprites/Effects/shell.png\"));\n            bulletImage = resizeImage(bulletImage, 2, 4);\n        } catch (IOException e) {\n            System.out.println(\"[HATA] Bullet Shell yüklenemedi.\");\n        }\n    }\n\n    public void update() {\n        x += dx;\n        y += dy;\n    }\n\n    public void draw(Graphics2D g2d) {\n        g2d.drawImage(bulletImage, x - bulletImage.getWidth() / 2, y - bulletImage.getHeight() / 2, null);\n    }\n\n    private BufferedImage resizeImage(BufferedImage originalImage, int targetWidth, int targetHeight) {\n        Image scaledImage = originalImage.getScaledInstance(targetWidth, targetHeight, Image.SCALE_SMOOTH);\n        BufferedImage resizedImage = new BufferedImage(targetWidth, targetHeight, BufferedImage.TYPE_INT_ARGB);\n\n        Graphics2D g2d = resizedImage.createGraphics();\n        g2d.drawImage(scaledImage, 0, 0, null);\n        g2d.dispose();\n\n        return resizedImage;\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, bulletImage.getWidth(), bulletImage.getHeight());\n    }\n\n}\n",
      "Acid.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class Acid {\n    private int x, y;\n    private int duration = 180; // 3 saniye\n    private BufferedImage sprite;\n\n    public Acid(int x, int y) {\n        this.x = x;\n        this.y = y;\n\n        try {\n            sprite = ImageIO.read(new File(\"Sprites/Effects/acid.png\"));\n        } catch (IOException e) {\n            System.out.println(\"[HATA] Acid sprite yüklenemedi.\");\n        }\n    }\n\n    public void update() {\n        duration--;\n    }\n\n    public boolean isAlive() {\n        return duration > 0;\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 32, 32);\n    }\n\n    public void draw(Graphics2D g2d) {\n        g2d.drawImage(sprite, x, y, 32, 32, null);\n    }\n}\n",
      "GameWindow.java": "import javax.swing.ImageIcon;\nimport javax.swing.JFrame;\n\npublic class GameWindow extends JFrame {\n    private GamePanel panel;\n\n    public GameWindow(boolean load) {\n        setTitle(\"ALPOCALYPSE - In Game\");\n        panel = new GamePanel(this);\n        if (load) {\n            panel.loadGame();\n        }\n        setIconImage(new ImageIcon(\"Sprites/Menu/background.png\").getImage());\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        setResizable(false);\n        add(panel);\n        pack();\n        setLocationRelativeTo(null);\n        setVisible(true);\n        panel.startGameThread();\n    }\n\n    public void returnToMenu() {\n        // panel istemciden \"Game Over\" verirse burası çağrılır\n        dispose();\n        new MainMenu();\n    }\n}\n",
      "NormalZombie.java": "import java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\nimport javax.imageio.ImageIO;\n\npublic class NormalZombie extends Zombie {\n\n    public NormalZombie(int x, int y) {\n        super(x, y, 100, 1.3, 20); // can, hız, hasar\n\n        walkFrames = new BufferedImage[17];\n        attackFrames = new BufferedImage[9];\n\n        try {\n            for (int i = 0; i < 17; i++) {\n                walkFrames[i] = resizeImage(ImageIO.read(new File(String.format(\n                        \"Sprites/Zombie/NormalZombie/Move/skeleton-move_%d.png\", i))), 32, 32);\n\n            }\n            for (int i = 0; i < 9; i++) {\n                attackFrames[i] = resizeImage(ImageIO.read(new File(String.format(\n                        \"Sprites/Zombie/NormalZombie/Attack/skeleton-attack_%d.png\", i))), 32, 32);\n            }\n\n        } catch (IOException e) {\n            System.out.println(\"[HATA] NormalZombie sprite'lari yüklenemedi.\");\n        }\n    }\n\n    @Override\n    public void update(Player player, List<Zombie> zombies, List<Rectangle> obstacles) {\n        if (!alive)\n            return;\n\n        final double ATTACK_RANGE = 20;\n\n        double dx = player.getX() - x;\n        double dy = player.getY() - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance <= ATTACK_RANGE) {\n            if (attackCooldown <= 0) {\n                player.takeDamage(damage);\n                attackCooldown = defaultCooldown;\n                attackIndex = 0;\n                attackCounter = 0;\n                isAttacking = true;\n            }\n        } else if (!isAttacking) {\n            double nextX = x + speed * dx / distance;\n            double nextY = y + speed * dy / distance;\n            Rectangle nextBounds = new Rectangle((int) nextX, (int) nextY, 32, 32);\n\n            boolean blocked = false;\n\n            for (Zombie z : zombies) {\n                if (z != this && z.isAlive() && nextBounds.intersects(z.getBounds())) {\n                    blocked = true;\n                    break;\n                }\n            }\n\n            for (Rectangle rect : obstacles) {\n                if (nextBounds.intersects(rect)) {\n                    blocked = true;\n                    break;\n                }\n            }\n\n            if (!blocked) {\n                x = (int) nextX;\n                y = (int) nextY;\n            }\n        }\n\n        if (attackCooldown > 0)\n            attackCooldown--;\n\n        if (isAttacking) {\n            attackCounter++;\n            if (attackCounter >= attackDelay) {\n                attackCounter = 0;\n                attackIndex++;\n                if (attackIndex >= attackFrames.length) {\n                    attackIndex = 0;\n                    isAttacking = false;\n                }\n            }\n        } else {\n            walkCounter++;\n            if (walkCounter >= walkDelay) {\n                walkCounter = 0;\n                walkIndex = (walkIndex + 1) % walkFrames.length;\n            }\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        BufferedImage frame = isAttacking ? attackFrames[attackIndex] : walkFrames[walkIndex];\n        g2d.drawImage(frame, x, y, null);\n    }\n}\n",
      "RocketAmmo.java": "import java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\nimport javax.imageio.ImageIO;\n\npublic class RocketAmmo {\n    public int x, y;\n    public double dx, dy;\n    private final int speed = 3;\n    private boolean exploded = false;\n    private BufferedImage image;\n    private final int radius = 120;\n    private int width = 20, height = 30;\n    private List<SmokeEffect> smokeList;\n\n    public RocketAmmo(int startX, int startY, double angle, List<SmokeEffect> smokeList) {\n        x = startX;\n        y = startY;\n        dx = Math.cos(angle) * speed;\n        dy = Math.sin(angle) * speed;\n        this.smokeList = smokeList;\n\n        try {\n            image = ImageIO.read(new File(\"Sprites/Effects/rocketammo.png\"));\n        } catch (IOException e) {\n            System.out.println(\"[HATA] Roket sprite yuklenemedi.\");\n        }\n    }\n\n    public void update(List<Zombie> zombies) {\n        if (exploded)\n            return;\n\n        x += dx;\n        y += dy;\n\n        Rectangle rocketRect = new Rectangle(x, y, width, height);\n        for (Zombie z : zombies) {\n            if (z.isAlive() && rocketRect.intersects(z.getBounds())) {\n                explode(zombies);\n                break;\n            }\n        }\n    }\n\n    public void explode(List<Zombie> zombies) {\n        exploded = true;\n\n        // Roketin merkezini bulalım\n        int rocketCenterX = x + width / 2;\n        int rocketCenterY = y + height / 2;\n\n        // Alan hasarı\n        for (Zombie z : zombies) {\n            if (!z.isAlive())\n                continue;\n            int zx = z.getX() + 16;\n            int zy = z.getY() + 16;\n            double dist = Point.distance(rocketCenterX, rocketCenterY, zx, zy);\n            if (dist <= radius) {\n                z.takeDamage(50);\n            }\n        }\n        // Duman\n        if (smokeList != null) {\n            smokeList.add(new SmokeEffect(rocketCenterX, rocketCenterY));\n        }\n    }\n\n    public boolean isExploded() {\n        return exploded;\n    }\n\n    public void draw(Graphics2D g2d) {\n        if (!exploded && image != null) {\n            g2d.drawImage(image, x, y, width, height, null);\n        }\n    }\n}\n",
      "SmokeEffect.java": "import java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class SmokeEffect {\n    private int x, y;\n    private int duration = 120; // kaç frame kalacak\n    private BufferedImage image;\n\n    public SmokeEffect(int x, int y) {\n        this.x = x;\n        this.y = y;\n\n        try {\n            image = ImageIO.read(new File(\"Sprites/Effects/smoke.png\"));\n        } catch (IOException e) {\n            System.out.println(\"[HATA] Duman efekti yüklenemedi.\");\n        }\n    }\n\n    public void update() {\n        duration--;\n    }\n\n    public boolean isAlive() {\n        return duration > 0;\n    }\n\n    public void draw(Graphics2D g2d) {\n        if (image != null) {\n            g2d.drawImage(image, x - 16, y - 16, 16, 16, null);\n        }\n    }\n}\n",
      "MainMenu.java": "import java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport javax.swing.*;\n\npublic class MainMenu extends JFrame {\n\n    private JButton newGameBtn, loadGameBtn, scoreboardBtn, exitBtn;\n    private JLabel backgroundLabel;\n\n    public MainMenu() {\n        setTitle(\"ALPOCALYPSE MAIN MENU\");\n        setSize(600, 400);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setIconImage(new ImageIcon(\"Sprites/Menu/background.png\").getImage());\n        setLayout(null);\n\n        // Arka plan resmi (isteğe bağlı)\n        ImageIcon bgIcon = new ImageIcon(\"Sprites/Menu/background.png\");\n        Image bgscaled = bgIcon.getImage().getScaledInstance(600, 400, Image.SCALE_SMOOTH);\n        ImageIcon newBg = new ImageIcon(bgscaled);\n        backgroundLabel = new JLabel(newBg);\n        backgroundLabel.setBounds(0, 0, 600, 400);\n\n        // New Game butonu\n        ImageIcon newGameIcon = new ImageIcon(\"Sprites/Menu/newgame.jpg\");\n        Image scaledNew = newGameIcon.getImage().getScaledInstance(150, 40, Image.SCALE_SMOOTH);\n        ImageIcon scaledNewIcon = new ImageIcon(scaledNew);\n        newGameBtn = new JButton(scaledNewIcon);\n        newGameBtn.setBounds(50, 50, 150, 40);\n        newGameBtn.setBorderPainted(false);\n        newGameBtn.setContentAreaFilled(false);\n        newGameBtn.setFocusPainted(false);\n        newGameBtn.addActionListener(e -> {\n            startNewGame();\n        });\n\n        // Load Game butonu\n        ImageIcon loadGameIcon = new ImageIcon(\"Sprites/Menu/loadgame.jpg\");\n        Image scaledLoad = loadGameIcon.getImage().getScaledInstance(150, 40, Image.SCALE_SMOOTH);\n        ImageIcon scaledLoadIcon = new ImageIcon(scaledLoad);\n        loadGameBtn = new JButton(scaledLoadIcon);\n        loadGameBtn.setBounds(50, 110, 150, 40);\n        loadGameBtn.setBorderPainted(false);\n        loadGameBtn.setContentAreaFilled(false);\n        loadGameBtn.setFocusPainted(false);\n        loadGameBtn.addActionListener(e -> {\n            File f = new File(\"savegame.txt\");\n            if (!f.exists()) {\n                JOptionPane.showMessageDialog(this, \"No saved game found!\");\n                return;\n            }\n            startLoadedGame();\n        });\n\n        // Scoreboard butonu\n        ImageIcon scoreGameIcon = new ImageIcon(\"Sprites/Menu/scoreboard.jpg\");\n        Image scaledScore = scoreGameIcon.getImage().getScaledInstance(150, 40, Image.SCALE_SMOOTH);\n        ImageIcon scaledScoreIcon = new ImageIcon(scaledScore);\n        scoreboardBtn = new JButton(scaledScoreIcon);\n        scoreboardBtn.setBounds(50, 170, 150, 40);\n        scoreboardBtn.setBorderPainted(false);\n        scoreboardBtn.setContentAreaFilled(false);\n        scoreboardBtn.setFocusPainted(false);\n        scoreboardBtn.addActionListener(e -> {\n            JOptionPane.showMessageDialog(this,\n                    \"Max Score so far = \" + Game.maxScore);\n        });\n\n        // Exit butonu\n        ImageIcon exitGameIcon = new ImageIcon(\"Sprites/Menu/exit.jpg\");\n        Image scaledExit = exitGameIcon.getImage().getScaledInstance(150, 40, Image.SCALE_SMOOTH);\n        ImageIcon scaledExitIcon = new ImageIcon(scaledExit);\n        exitBtn = new JButton(scaledExitIcon);\n        exitBtn.setBounds(50, 230, 150, 40);\n        exitBtn.setBorderPainted(false);\n        exitBtn.setContentAreaFilled(false);\n        exitBtn.setFocusPainted(false);\n        exitBtn.addActionListener(e -> System.exit(0));\n\n        // Ekleme sırası\n        add(newGameBtn);\n        add(loadGameBtn);\n        add(scoreboardBtn);\n        add(exitBtn);\n        add(backgroundLabel);\n\n        setLocationRelativeTo(null);\n        setVisible(true);\n    }\n\n    private void startNewGame() {\n        new GameWindow(false);\n        dispose(); // menüyü kapat\n    }\n\n    private void startLoadedGame() {\n        new GameWindow(true);\n        dispose();\n    }\n\n    protected BufferedImage resizeImage(BufferedImage original, int w, int h) {\n        Image scaled = original.getScaledInstance(w, h, Image.SCALE_SMOOTH);\n        BufferedImage resized = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2 = resized.createGraphics();\n        g2.drawImage(scaled, 0, 0, null);\n        g2.dispose();\n        return resized;\n    }\n}\n",
      "GamePanel.java": "import java.awt.*;\nimport java.awt.event.*;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\n\npublic class GamePanel extends JPanel\n        implements KeyListener, Runnable, MouseMotionListener, MouseListener, MouseWheelListener {\n\n    public static final int SWID = 1440;\n    public static final int SHEI = 980;\n\n    private Thread gameThread;\n    private final int FPS = 60;\n\n    private Player player;\n    private TileManager mapper;\n    private Point aim = new Point(SWID / 2, SHEI / 2);\n    private boolean gameOverTriggered = false;\n\n    private List<Zombie> zombies = new ArrayList<>();\n    private List<Bullet> bullets = new ArrayList<>();\n    private List<RocketAmmo> rockets = new ArrayList<>();\n    private List<SmokeEffect> smokeList = new ArrayList<>();\n    private List<ShellCasing> shells = new ArrayList<>();\n    private List<MuzzleFlash> flashes = new ArrayList<>();\n    private List<Acid> acids = new ArrayList<>();\n    private List<Guts> guts = new ArrayList<>();\n    private List<PlayerBlood> playerBloods = new ArrayList<>();\n\n    private List<Rectangle> obstacles;\n    private int score = 0;\n    private int combo = 1;\n    private int comboTimer = 0;\n    private final int COMBO_RESET_TIME = 300;\n\n    private double zoom = 2.5;\n\n    private int currentLevel = 1;\n    private final int[] zombiesPerLevel = { 10, 15, 20, 25, 30 };\n    private final int MAX_LEVEL = 5;\n\n    private Random rand = new Random();\n\n    private boolean paused = false;\n\n    private GameWindow parentWindow; // Referans\n\n    public GamePanel(GameWindow parent) {\n        this.parentWindow = parent;\n        setPreferredSize(new Dimension(SWID, SHEI));\n        setFocusable(true);\n\n        BufferedImage blankImg = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);\n        Cursor blankCursor = Toolkit.getDefaultToolkit()\n                .createCustomCursor(blankImg, new Point(0, 0), \"blank cursor\");\n        setCursor(blankCursor);\n\n        // Devam...\n        addKeyListener(this);\n        addMouseListener(this);\n        addMouseMotionListener(this);\n        addMouseWheelListener(this);\n\n        mapper = new TileManager();\n        player = new Player(32 * 25, 32 * 15);\n        player.setBloodList(playerBloods);\n\n        obstacles = mapper.getSolidRectangles();\n        spawnZombiesForLevel(currentLevel);\n    }\n\n    private void spawnZombiesForLevel(int level) {\n        zombies.clear();\n        int zombieCount = zombiesPerLevel[level - 1];\n        int mapH = mapper.mapH;\n        int mapW = mapper.mapW;\n\n        // Her zombi => random tile 0..mapH-1,0..mapW-1\n        for (int i = 0; i < zombieCount; i++) {\n            Zombie z = createRandomZombie();\n            // Tekrar dene 50 kez\n            for (int tries = 0; tries < 50; tries++) {\n                int r = rand.nextInt(mapH);\n                int c = rand.nextInt(mapW);\n                int tile = mapper.getMap()[r][c];\n                if (tile == 0 || tile == 1 || tile == 2 || tile == 3) {\n                    // spawn\n                    z.x = c * 32;\n                    z.y = r * 32;\n                    break;\n                }\n            }\n            zombies.add(z);\n        }\n        System.out.println(\"[INFO] Level \" + level + \" zombileri spawn: \" + zombieCount);\n    }\n\n    private Zombie createRandomZombie() {\n        int t = rand.nextInt(4);\n        switch (t) {\n            case 0:\n                return new NormalZombie(0, 0);\n            case 1:\n                return new TankZombie(0, 0);\n            case 2:\n                return new AcidZombie(0, 0);\n            default:\n                return new JumperZombie(0, 0);\n        }\n    }\n\n    public void startGameThread() {\n        gameThread = new Thread(this);\n        gameThread.start();\n    }\n\n    @Override\n    public void run() {\n        double interval = 1000000000.0 / FPS;\n        double nextDrawTime = System.nanoTime() + interval;\n\n        while (gameThread != null) {\n            if (!paused) {\n                updateGame();\n            }\n            repaint();\n\n            try {\n                double remainingTime = nextDrawTime - System.nanoTime();\n                remainingTime = Math.max(remainingTime / 1_000_000, 0);\n                Thread.sleep((long) remainingTime);\n                nextDrawTime += interval;\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void updateGame() {\n        clampPlayerPosition();\n        player.update(aim, mapper);\n\n        // KARAKTER ÖLDÜ MÜ?\n        if (player.getHealth() <= 0) {\n            if (!gameOverTriggered) {\n                gameOverTriggered = true; // artık 2. kez girmesin\n                System.out.println(\"[INFO] PLAYER DEAD -> GAME OVER\");\n                gameOver();\n            }\n            return; // updateGame durdur\n        }\n\n        // ZOMBIE\n        zombies.removeIf(z -> {\n            z.update(player, zombies, obstacles);\n            if (!z.isAlive()) {\n                score += 10 * combo;\n                combo++;\n                comboTimer = COMBO_RESET_TIME;\n                if (z instanceof AcidZombie) {\n                    acids.add(new Acid(z.getX(), z.getY()));\n                }\n                guts.add(new Guts(z.getX(), z.getY()));\n                return true;\n            }\n            return false;\n        });\n\n        if (zombies.isEmpty()) {\n            // dalga bitti => +50 ammo\n            player.getAllWeapons().forEach(w -> w.addReserveAmmo(50));\n            currentLevel++;\n            if (currentLevel <= MAX_LEVEL) {\n                spawnZombiesForLevel(currentLevel);\n            } else {\n                System.out.println(\"[INFO] Tüm level bitti. Oyun Sonu.\");\n                Game.updateTotalScore(score);\n                // kapat\n                gameOver();\n                return;\n            }\n        }\n\n        // rockets\n        rockets.forEach(r -> r.update(zombies));\n        rockets.removeIf(r -> r.isExploded());\n\n        // smoke\n        List<SmokeEffect> tempSmoke = new ArrayList<>();\n        for (SmokeEffect s : smokeList) {\n            s.update();\n            if (s.isAlive())\n                tempSmoke.add(s);\n        }\n        smokeList = tempSmoke;\n\n        // acid\n        List<Acid> tempAcids = new ArrayList<>();\n        for (Acid a : acids) {\n            a.update();\n            if (a.getBounds().intersects(player.getBounds())) {\n                player.takeDamage(5);\n                playerBloods.add(new PlayerBlood(player.getX(), player.getY()));\n            }\n            if (a.isAlive())\n                tempAcids.add(a);\n        }\n        acids = tempAcids;\n\n        // guts\n        List<Guts> tempGuts = new ArrayList<>();\n        for (Guts g : guts) {\n            g.update();\n            if (g.isAlive())\n                tempGuts.add(g);\n        }\n        guts = tempGuts;\n\n        // bullets\n        bullets.forEach(Bullet::update);\n        for (int i = 0; i < bullets.size(); i++) {\n            Bullet b = bullets.get(i);\n            if (b instanceof PiercingBullet) {\n                PiercingBullet pb = (PiercingBullet) b;\n                for (Zombie z : zombies) {\n                    if (z.isAlive() && z.getBounds().intersects(pb.getBounds())) {\n                        double angle = Math.atan2(z.getY() - b.y, z.getX() - b.x);\n                        z.takeDamage(10, angle);\n                    }\n                }\n                if (!pb.isAlive()) {\n                    bullets.remove(i);\n                    i--;\n                }\n            } else {\n                boolean hit = false;\n                for (Zombie z : zombies) {\n                    if (z.isAlive() && z.getBounds().intersects(b.getBounds())) {\n                        double angle = Math.atan2(z.getY() - b.y, z.getX() - b.x);\n                        z.takeDamage(10, angle);\n                        hit = true;\n                        break;\n                    }\n                }\n                if (hit) {\n                    bullets.remove(i);\n                    i--;\n                }\n            }\n        }\n\n        // playerBlood\n        playerBloods.removeIf(pb -> {\n            pb.update();\n            return !pb.isAlive();\n        });\n        shells.removeIf(sh -> {\n            sh.update();\n            return !sh.isAlive();\n        });\n        flashes.removeIf(f -> {\n            f.update();\n            return !f.isAlive();\n        });\n\n        checkItemPickup();\n\n        if (comboTimer > 0)\n            comboTimer--;\n        else\n            combo = 1;\n    }\n\n    private void gameOver() {\n        Game.updateTotalScore(score);\n\n        JOptionPane.showMessageDialog(\n                this,\n                \"Game Over!\\nYour Score = \" + score\n                        + \"\\nYou Reached Level \" + currentLevel);\n\n        // Ana menüye dön\n        parentWindow.returnToMenu();\n    }\n\n    private void clampPlayerPosition() {\n        int mapWidth = mapper.getMapWidth();\n        int mapHeight = mapper.getMapHeight();\n        int pSize = player.getSize();\n        int minPos = mapper.getTileSize();\n\n        if (player.getX() < minPos)\n            player.setX(minPos);\n        if (player.getY() < minPos)\n            player.setY(minPos);\n        if (player.getX() > mapWidth - pSize - minPos)\n            player.setX(mapWidth - pSize - minPos);\n        if (player.getY() > mapHeight - pSize - minPos)\n            player.setY(mapHeight - pSize - minPos);\n    }\n\n    private void checkItemPickup() {\n        int tileSize = mapper.getTileSize();\n        Rectangle bounds = player.getBounds();\n        int startTileX = bounds.x / tileSize;\n        int startTileY = bounds.y / tileSize;\n        int endTileX = (bounds.x + bounds.width - 1) / tileSize;\n        int endTileY = (bounds.y + bounds.height - 1) / tileSize;\n\n        int maxCol = mapper.getMap()[0].length - 1;\n        int maxRow = mapper.getMap().length - 1;\n        for (int ty = startTileY; ty <= endTileY; ty++) {\n            for (int tx = startTileX; tx <= endTileX; tx++) {\n                int clampedTx = Math.max(0, Math.min(tx, maxCol));\n                int clampedTy = Math.max(0, Math.min(ty, maxRow));\n                int tile = mapper.getTile(clampedTx, clampedTy);\n                if (tile == 6) {\n                    player.heal(20);\n                    mapper.setTile(clampedTx, clampedTy, 4);\n                } else if (tile == 7) {\n                    player.getAllWeapons().forEach(w -> w.addReserveAmmo(30));\n                    mapper.setTile(clampedTx, clampedTy, 4);\n                }\n            }\n        }\n    }\n\n    public void saveGame() {\n        try (PrintWriter pw = new PrintWriter(\"savegame.txt\")) {\n            pw.println(currentLevel);\n            pw.println(score);\n            pw.println(player.getX());\n            pw.println(player.getY());\n            pw.println(player.getHealth());\n\n            int[][] mapData = mapper.getMap();\n            pw.println(mapData.length + \" \" + mapData[0].length);\n            for (int r = 0; r < mapData.length; r++) {\n                for (int c = 0; c < mapData[0].length; c++) {\n                    pw.print(mapData[r][c] + \" \");\n                }\n                pw.println();\n            }\n            System.out.println(\"[INFO] Game saved!\");\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    public void loadGame() {\n        File f = new File(\"savegame.txt\");\n        if (!f.exists()) {\n            System.out.println(\"[INFO] No savegame found!\");\n            return;\n        }\n        try (Scanner sc = new Scanner(f)) {\n            currentLevel = sc.nextInt();\n            score = sc.nextInt();\n            int px = sc.nextInt();\n            int py = sc.nextInt();\n            int hp = sc.nextInt();\n            player.setX(px);\n            player.setY(py);\n\n            int rows = sc.nextInt();\n            int cols = sc.nextInt();\n            int[][] mapData = new int[rows][cols];\n            for (int r = 0; r < rows; r++) {\n                for (int c = 0; c < cols; c++) {\n                    mapData[r][c] = sc.nextInt();\n                }\n            }\n            mapper.setMap(mapData);\n            obstacles = mapper.getSolidRectangles();\n            spawnZombiesForLevel(currentLevel);\n\n            System.out.println(\"[INFO] Loaded game from savegame.txt\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handlePauseMenuInput(int keyCode) {\n        if (keyCode == KeyEvent.VK_ESCAPE) {\n            paused = false;\n        } else if (keyCode == KeyEvent.VK_S) {\n            saveGame();\n        } else if (keyCode == KeyEvent.VK_E) {\n            System.exit(0);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n        if (!paused) {\n            drawGame((Graphics2D) g);\n        } else {\n            drawGame((Graphics2D) g);\n            drawPauseMenu((Graphics2D) g);\n        }\n    }\n\n    private void drawGame(Graphics2D g2dMaster) {\n        Graphics2D g2d = (Graphics2D) g2dMaster.create();\n        g2d.setColor(Color.DARK_GRAY);\n        g2d.fillRect(0, 0, getWidth(), getHeight());\n\n        double camX = player.getX() + player.getSize() / 2.0 - (SWID / 2.0) / zoom;\n        double camY = player.getY() + player.getSize() / 2.0 - (SHEI / 2.0) / zoom;\n\n        int mapWidth = mapper.getMapWidth();\n        int mapHeight = mapper.getMapHeight();\n        double viewWidth = SWID / zoom;\n        double viewHeight = SHEI / zoom;\n        int margin = mapper.getTileSize();\n\n        if (mapWidth - 2 * margin >= viewWidth) {\n            if (camX < margin)\n                camX = margin;\n            else if (camX > mapWidth - viewWidth - margin)\n                camX = mapWidth - viewWidth - margin;\n        } else {\n            camX = (mapWidth - viewWidth) / 2.0;\n        }\n        if (mapHeight - 2 * margin >= viewHeight) {\n            if (camY < margin)\n                camY = margin;\n            else if (camY > mapHeight - viewHeight - margin)\n                camY = mapHeight - viewHeight - margin;\n        } else {\n            camY = (mapHeight - viewHeight) / 2.0;\n        }\n\n        g2d.scale(zoom, zoom);\n        g2d.translate(-camX, -camY);\n\n        mapper.draw(g2d, camX, camY, zoom);\n\n        for (Guts gobj : guts)\n            gobj.draw(g2d);\n        acids.forEach(a -> a.draw(g2d));\n        rockets.forEach(r -> r.draw(g2d));\n        shells.forEach(s -> s.draw(g2d));\n        flashes.forEach(f -> f.draw(g2d));\n        bullets.forEach(b -> b.draw(g2d));\n        zombies.forEach(z -> z.draw(g2d));\n        player.draw(g2d);\n        playerBloods.forEach(pb -> pb.draw(g2d));\n        smokeList.forEach(sm -> sm.draw(g2d));\n\n        g2d.setTransform(new AffineTransform());\n        drawHUD(g2d);\n        g2d.dispose();\n    }\n\n    private void drawHUD(Graphics2D g2d) {\n        g2d.setFont(new Font(\"Arial\", Font.BOLD, 18));\n        FontMetrics fm = g2d.getFontMetrics();\n\n        int leftX = 20;\n        int leftY = 30;\n        int lineHeight = 22;\n        g2d.setColor(Color.WHITE);\n\n        g2d.drawString(\"Weapon: \" + player.getCurrentWeapon().getName(), leftX, leftY);\n        g2d.drawString(\"Ammo: \" + player.getCurrentAmmo() + \" / \" + player.getMaxAmmo(),\n                leftX, leftY + lineHeight);\n        g2d.drawString(\"Reserve: \" + player.getCurrentWeapon().getReserveAmmo(),\n                leftX, leftY + lineHeight * 2);\n\n        // HP, Score, Level kısımları\n        String healthText = \"HP: \" + player.getHealth();\n        String scoreText = \"Score: \" + score;\n        String levelText = \"Level: \" + currentLevel;\n        int rightMargin = 20;\n\n        int rightX = getWidth() - fm.stringWidth(healthText) - rightMargin;\n        int rightY = 30;\n        g2d.drawString(healthText, rightX + 720, rightY);\n\n        rightX = getWidth() - fm.stringWidth(scoreText) - rightMargin;\n        rightY += lineHeight;\n        g2d.drawString(scoreText, rightX + 720, rightY);\n\n        rightX = getWidth() - fm.stringWidth(levelText) - rightMargin;\n        rightY += lineHeight;\n        g2d.drawString(levelText, rightX + 720, rightY);\n\n        // === COMBO DISPLAY ===\n        if (combo > 1) {\n            // Örneğin combo'yu sol tarafta, ammo/reserve altına yazarız\n            g2d.setColor(Color.YELLOW);\n            g2d.drawString(\"Combo x\" + combo, leftX, leftY + lineHeight * 4);\n            g2d.setColor(Color.WHITE);\n        }\n    }\n\n    private void drawPauseMenu(Graphics2D g2d) {\n        g2d.setColor(new Color(0, 0, 0, 150));\n        g2d.fillRect(0, 0, getWidth(), getHeight());\n        g2d.setColor(Color.WHITE);\n        g2d.setFont(new Font(\"Arial\", Font.BOLD, 24));\n        String pausedText = \"GAME PAUSED (ESC->Resume, S->Save, E->Exit)\";\n        int strW = g2d.getFontMetrics().stringWidth(pausedText);\n        g2d.drawString(pausedText, (getWidth() - strW) / 2, getHeight() / 2);\n    }\n\n    // MOUSE\n    @Override\n    public void mouseWheelMoved(MouseWheelEvent e) {\n        if (paused)\n            return;\n        int notches = e.getWheelRotation();\n        if (notches > 0) {\n            player.nextWeapon();\n        } else if (notches < 0) {\n            player.previousWeapon();\n        }\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        if (!paused) {\n            player.keyPressed(e);\n            if (e.getKeyCode() == KeyEvent.VK_R) {\n                if (player.getCurrentWeapon().needsReload() && !player.isReloading()) {\n                    player.startReload();\n                }\n            } else if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {\n                paused = true;\n            }\n        } else {\n            handlePauseMenuInput(e.getKeyCode());\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        player.keyReleased(e);\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        if (paused)\n            return;\n        if (player.isReloading())\n            return;\n        Point muzzle = player.getMuzzlePosition();\n        double angle = player.getAngleToMouse();\n        Weapon weapon = player.getCurrentWeapon();\n        if (!weapon.canShoot())\n            return;\n\n        weapon.fire(angle, muzzle.x, muzzle.y, bullets, rockets, smokeList);\n        if (!(weapon instanceof Rocket)) {\n            flashes.add(new MuzzleFlash(muzzle.x, muzzle.y, angle));\n            shells.add(new ShellCasing(muzzle.x, muzzle.y));\n        }\n        player.setState(Player.PlayerState.SHOOT);\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        if (!paused) {\n            aim = getMouseWorldPosition(e.getPoint());\n        }\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        mouseMoved(e);\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e) {\n    }\n\n    public Point getMouseWorldPosition(Point screenMouse) {\n        double camX = player.getX() + player.getSize() / 2.0 - (SWID / 2.0) / zoom;\n        double camY = player.getY() + player.getSize() / 2.0 - (SHEI / 2.0) / zoom;\n        return new Point(\n                (int) ((screenMouse.x / zoom) + camX),\n                (int) ((screenMouse.y / zoom) + camY));\n    }\n}\n",
      "JumperZombie.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\nimport javax.imageio.ImageIO;\n\npublic class JumperZombie extends Zombie {\n\n    private boolean jumping = false;\n    private int jumpCooldown = 120; // 2 saniye bekleme\n    private int jumpTimer = 0;\n    private int jumpDuration = 12;\n    private int jumpFrame = 0;\n\n    private final double ATTACK_RANGE = 20;\n\n    public JumperZombie(int x, int y) {\n        super(x, y, 70, 1.7, 30);\n\n        walkFrames = new BufferedImage[9];\n        attackFrames = new BufferedImage[9];\n\n        try {\n            for (int i = 0; i < 9; i++) {\n                walkFrames[i] = resizeImage(ImageIO.read(new File(String.format(\n                        \"Sprites/Zombie/JumperZombie/walk/%02d_walk.png\", i))), 32, 32);\n                attackFrames[i] = resizeImage(ImageIO.read(new File(String.format(\n                        \"Sprites/Zombie/JumperZombie/attack/%02d_attack.png\", i))), 32, 32);\n            }\n        } catch (IOException e) {\n            System.out.println(\"[HATA] JumperZombie sprite'ları yüklenemedi.\");\n        }\n    }\n\n    @Override\n    public void update(Player player, List<Zombie> zombies, List<Rectangle> obstacles) {\n        if (!alive)\n            return;\n\n        double dx = player.getX() - x;\n        double dy = player.getY() - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        // === Saldırı ===\n        if (distance < ATTACK_RANGE) {\n            if (attackCooldown <= 0) {\n                player.takeDamage(damage);\n                attackCooldown = defaultCooldown;\n                attackIndex = 0;\n                attackCounter = 0;\n                isAttacking = true;\n            }\n        }\n\n        // === Zıplama Hareketi ===\n        if (!isAttacking && distance >= ATTACK_RANGE) {\n            if (!jumping && jumpTimer <= 0) {\n                jumping = true;\n                jumpFrame = 0;\n            }\n\n            if (jumping) {\n                double moveX = speed * 3 * dx / distance;\n                double moveY = speed * 3 * dy / distance;\n\n                Rectangle nextBounds = new Rectangle((int) (x + moveX), (int) (y + moveY), 32, 32);\n                boolean blocked = false;\n\n                for (Zombie z : zombies) {\n                    if (z != this && z.isAlive() && nextBounds.intersects(z.getBounds())) {\n                        blocked = true;\n                        break;\n                    }\n                }\n\n                for (Rectangle r : obstacles) {\n                    if (nextBounds.intersects(r)) {\n                        blocked = true;\n                        break;\n                    }\n                }\n\n                if (!blocked) {\n                    x += moveX;\n                    y += moveY;\n                }\n\n                walkCounter++;\n                if (walkCounter >= walkDelay) {\n                    walkCounter = 0;\n                    walkIndex = (walkIndex + 1) % walkFrames.length;\n                }\n\n                jumpFrame++;\n                if (jumpFrame >= jumpDuration) {\n                    jumping = false;\n                    jumpTimer = jumpCooldown;\n                }\n            } else {\n                jumpTimer--;\n            }\n        }\n\n        // === Cooldown yönetimi ===\n        if (attackCooldown > 0)\n            attackCooldown--;\n\n        // === Animasyonlar ===\n        if (isAttacking) {\n            attackCounter++;\n            if (attackCounter >= attackDelay) {\n                attackCounter = 0;\n                attackIndex++;\n                if (attackIndex >= attackFrames.length) {\n                    attackIndex = 0;\n                    isAttacking = false;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        BufferedImage frame = isAttacking ? attackFrames[attackIndex] : walkFrames[walkIndex];\n        g2d.drawImage(frame, x, y, null);\n    }\n}\n",
      "TankZombie.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\nimport javax.imageio.ImageIO;\n\npublic class TankZombie extends Zombie {\n\n    private final double ATTACK_RANGE = 20;\n\n    public TankZombie(int x, int y) {\n        super(x, y, 300, 1.0, 25);\n\n        walkFrames = new BufferedImage[12];\n        attackFrames = new BufferedImage[9];\n\n        try {\n            for (int i = 0; i < 12; i++) {\n                String path = String.format(\"Sprites/Zombie/TankZombie/TankWalk/%02d_tankzombie_walk.png\", i);\n                walkFrames[i] = resizeImage(ImageIO.read(new File(path)), 32, 32);\n            }\n            for (int i = 0; i < 9; i++) {\n                String path = String.format(\"Sprites/Zombie/TankZombie/TankAttack/%02d_tankzombie_hit.png\", i);\n                attackFrames[i] = resizeImage(ImageIO.read(new File(path)), 32, 32);\n            }\n        } catch (IOException e) {\n            System.out.println(\"[HATA] TankZombie sprite'ları yüklenemedi.\");\n        }\n    }\n\n    @Override\n    public void update(Player player, List<Zombie> zombies, List<Rectangle> obstacles) {\n        if (!alive)\n            return;\n\n        double dx = player.getX() - x;\n        double dy = player.getY() - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        // === SALDIRI ===\n        if (distance <= ATTACK_RANGE) {\n            if (attackCooldown <= 0) {\n                player.takeDamage(damage);\n                attackCooldown = defaultCooldown;\n                attackIndex = 0;\n                attackCounter = 0;\n                isAttacking = true;\n            }\n        }\n\n        // === HAREKET ===\n        if (!isAttacking && distance > ATTACK_RANGE) {\n            double nextX = x + speed * dx / distance;\n            double nextY = y + speed * dy / distance;\n            Rectangle nextBounds = new Rectangle((int) nextX, (int) nextY, 32, 32);\n\n            boolean blocked = false;\n            for (Zombie z : zombies) {\n                if (z != this && z.isAlive() && nextBounds.intersects(z.getBounds())) {\n                    blocked = true;\n                    break;\n                }\n            }\n\n            for (Rectangle rect : obstacles) {\n                if (nextBounds.intersects(rect)) {\n                    blocked = true;\n                    break;\n                }\n            }\n\n            if (!blocked) {\n                x = (int) nextX;\n                y = (int) nextY;\n            }\n        }\n\n        // === SALDIRI COOLDOWN ===\n        if (attackCooldown > 0)\n            attackCooldown--;\n\n        // === ANİMASYON ===\n        if (isAttacking) {\n            attackCounter++;\n            if (attackCounter >= attackDelay) {\n                attackCounter = 0;\n                attackIndex++;\n                if (attackIndex >= attackFrames.length) {\n                    attackIndex = 0;\n                    isAttacking = false;\n                }\n            }\n        } else {\n            walkCounter++;\n            if (walkCounter >= walkDelay) {\n                walkCounter = 0;\n                walkIndex = (walkIndex + 1) % walkFrames.length;\n            }\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        BufferedImage frame = isAttacking ? attackFrames[attackIndex] : walkFrames[walkIndex];\n        g2d.drawImage(frame, (int) x, (int) y, null);\n    }\n}\n",
      "MuzzleFlash.java": "import java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class MuzzleFlash {\n    private int x, y;\n    private int life = 3;\n    private double angle;\n    private BufferedImage flashImage;\n\n    public MuzzleFlash(int x, int y, double angle) {\n        this.x = x;\n        this.y = y;\n        this.angle = angle;\n\n        try {\n            flashImage = ImageIO.read(new File(\"Sprites/Effects/bullet.png\"));\n            flashImage = resizeImage(flashImage, 16, 16);\n        } catch (IOException e) {\n            System.out.println(\"[HATA] Muzzle flash yüklenemedi.\");\n        }\n    }\n\n    public void update() {\n        life--;\n    }\n\n    public boolean isAlive() {\n        return life > 0;\n    }\n\n    public void draw(Graphics2D g) {\n        AffineTransform old = g.getTransform();\n\n        g.rotate(angle, x, y);\n        g.drawImage(flashImage, x - flashImage.getWidth() / 2, y - flashImage.getHeight() / 2, null);\n\n        g.setTransform(old);\n    }\n\n    private BufferedImage resizeImage(BufferedImage originalImage, int targetWidth, int targetHeight) {\n        Image scaledImage = originalImage.getScaledInstance(targetWidth, targetHeight, Image.SCALE_SMOOTH);\n        BufferedImage resizedImage = new BufferedImage(targetWidth, targetHeight, BufferedImage.TYPE_INT_ARGB);\n\n        Graphics2D g2d = resizedImage.createGraphics();\n        g2d.drawImage(scaledImage, 0, 0, null);\n        g2d.dispose();\n\n        return resizedImage;\n    }\n}\n",
      "Game.java": "public class Game {\n    public static int totalScore = 0;\n    public static int maxScore = 0;\n\n    public static void main(String[] args) {\n        new MainMenu();\n    }\n\n    public static void updateTotalScore(int localScore) {\n        totalScore += localScore;\n        if (localScore > maxScore) {\n            maxScore = localScore;\n        }\n    }\n}\n",
      "TileManager.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.imageio.ImageIO;\n\npublic class TileManager {\n    int[][] map;\n    BufferedImage[] tiles;\n    boolean[] solid;\n    final int tileSize = 32;\n\n    int mapW = 45;\n    int mapH = 30;\n\n    public TileManager() {\n        generateRandomMap();\n        loadTiles();\n    }\n\n    private void generateRandomMap() {\n        map = new int[mapH][mapW];\n        for (int row = 0; row < mapH; row++) {\n            for (int col = 0; col < mapW; col++) {\n                double random = Math.random();\n                if (random < 0.1) {\n                    map[row][col] = 0;\n                } else if (random < 0.15) {\n                    map[row][col] = 1;\n                } else if (random < 0.5) {\n                    map[row][col] = 2;\n                } else if (random < 0.97) {\n                    map[row][col] = 3;\n                } else if (random < 0.99) {\n                    map[row][col] = 4;\n                } else if (random < 1.00) {\n                    map[row][col] = 5;\n                }\n            }\n        }\n        for (int i = 0; i < 5; i++) {\n            int r = (int) (Math.random() * mapH);\n            int c = (int) (Math.random() * mapW);\n            if (map[r][c] != 4 && map[r][c] != 5) {\n                map[r][c] = 6; // medkit\n            }\n        }\n        for (int i = 0; i < 5; i++) {\n            int r = (int) (Math.random() * mapH);\n            int c = (int) (Math.random() * mapW);\n            if (map[r][c] != 4 && map[r][c] != 5)\n                map[r][c] = 7; // ammo\n        }\n        for (int row = 13; row <= 16; row++) {\n            for (int col = 23; col <= 26; col++) {\n                map[row][col] = 0;\n            }\n        }\n        System.out.println(\"[SUCCESS] MAP GENERATED SUCCESFULLY!\");\n    }\n\n    private void loadTiles() {\n        tiles = new BufferedImage[8];\n        solid = new boolean[8];\n        try {\n            tiles[0] = ImageIO.read(getClass().getResource(\"/Sprites/Grounds/0.jpg\"));\n            solid[0] = false;\n            tiles[1] = ImageIO.read(getClass().getResource(\"/Sprites/Grounds/1.jpg\"));\n            solid[1] = false;\n            tiles[2] = ImageIO.read(getClass().getResource(\"/Sprites/Grounds/2.jpg\"));\n            solid[2] = false;\n            tiles[3] = ImageIO.read(getClass().getResource(\"/Sprites/Grounds/3.jpg\"));\n            solid[3] = false;\n            tiles[4] = ImageIO.read(getClass().getResource(\"/Sprites/Grounds/4.png\"));\n            solid[4] = true;\n            tiles[5] = ImageIO.read(getClass().getResource(\"/Sprites/Grounds/5.png\"));\n            solid[5] = true;\n            tiles[6] = ImageIO.read(getClass().getResource(\"/Sprites/Grounds/6.png\"));\n            solid[6] = false;\n            tiles[7] = ImageIO.read(getClass().getResource(\"/Sprites/Grounds/7.png\"));\n            solid[7] = false;\n        } catch (IOException e) {\n            System.out.println(\"[HATA] TILE MAP YÜKLENİRKEN FILE IO HATA OLUŞTU!\");\n        }\n    }\n\n    public void setMap(int[][] newMap) {\n        this.map = newMap;\n    }\n\n    // Dış alanları da bir border tile (örneğin tiles[0]) ile dolduruyoruz\n    public void draw(Graphics2D g2d, double camX, double camY, double zoom) {\n        int startCol = (int) (camX / tileSize);\n        int startRow = (int) (camY / tileSize);\n        int endCol = startCol + (int) (GamePanel.SWID / tileSize / zoom) + 2;\n        int endRow = startRow + (int) (GamePanel.SHEI / tileSize / zoom) + 2;\n\n        for (int row = startRow; row < endRow; row++) {\n            for (int col = startCol; col < endCol; col++) {\n                int x = col * tileSize;\n                int y = row * tileSize;\n                BufferedImage tileImage;\n                if (row >= 0 && row < map.length && col >= 0 && col < map[0].length) {\n                    int tileNum = map[row][col];\n                    tileImage = tiles[tileNum];\n                } else {\n                    // Eğer map dışındaysa, border tile olarak tiles[0] kullanıyoruz.\n                    tileImage = tiles[4];\n                }\n                g2d.drawImage(tileImage, x, y, null);\n            }\n        }\n    }\n\n    public List<Rectangle> getSolidRectangles() {\n        List<Rectangle> list = new ArrayList<>();\n        for (int y = 0; y < mapH; y++) {\n            for (int x = 0; x < mapW; x++) {\n                int tile = map[y][x];\n                if (tile == 4 || tile == 5) {\n                    list.add(new Rectangle(x * tileSize, y * tileSize, tileSize, tileSize));\n                }\n            }\n        }\n        return list;\n    }\n\n    public int[][] getMap() {\n        return map;\n    }\n\n    public boolean isSolid(int x, int y) {\n        int col = x / tileSize;\n        int row = y / tileSize;\n        if (row < 0 || col < 0 || row >= mapH || col >= mapW)\n            return true;\n        return solid[map[row][col]];\n    }\n\n    public int getTile(int x, int y) {\n        int col = x / tileSize;\n        int row = y / tileSize;\n        if (row < 0 || col < 0 || row >= mapH || col >= mapW)\n            return -1;\n        return map[row][col];\n    }\n\n    public void setTile(int x, int y, int value) {\n        int col = x / tileSize;\n        int row = y / tileSize;\n        if (row >= 0 && col >= 0 && row < mapH && col < mapW) {\n            map[row][col] = value;\n        }\n    }\n\n    // Piksel cinsinden harita genişliği\n    public int getMapWidth() {\n        return map[0].length * tileSize;\n    }\n\n    // Piksel cinsinden harita yüksekliği\n    public int getMapHeight() {\n        return map.length * tileSize;\n    }\n\n    public int getTileSize() {\n        return tileSize;\n    }\n}\n",
      "Player.java": "import java.awt.*;\nimport java.awt.event.KeyEvent;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.List;\nimport javax.imageio.ImageIO;\n\npublic class Player {\n\n    private int x, y;\n    private final int speed = 3;\n    private int health = 100;\n    private final int size = 32;\n    private boolean isDead = false;\n\n    private boolean up, down, left, right;\n    private int frameIndex = 0, frameCounter = 0, frameDelay = 8;\n    private double angleMouse = 0;\n\n    private int centerX, centerY;\n\n    private List<Weapon> allWeapons = new ArrayList<>();\n    private Weapon currentWeapon;\n    private int currentWeaponIndex = 0;\n\n    private PlayerState currentState = PlayerState.IDLE;\n    private boolean isReloading = false;\n    private int reloadFrame = 0;\n\n    private final Map<String, Map<PlayerState, BufferedImage[]>> animations = new HashMap<>();\n\n    public enum PlayerState {\n        IDLE, MOVE, SHOOT, RELOAD\n    }\n\n    private List<PlayerBlood> bloodList;\n\n    public void setBloodList(List<PlayerBlood> bloodList) {\n        this.bloodList = bloodList;\n    }\n\n    public Player(int x, int y) {\n        this.x = x;\n        this.y = y;\n\n        // FARKLI SİLAHLAR\n        allWeapons.add(new Shotgun());\n        allWeapons.add(new Rifle());\n        allWeapons.add(new Handgun());\n        allWeapons.add(new Sniper());\n        allWeapons.add(new Rocket());\n\n        currentWeapon = allWeapons.get(2);\n\n        loadAllAnimations();\n    }\n\n    private void loadAllAnimations() {\n        try {\n            loadWeaponAnimations(\"handgun\", 20, 3, 15);\n            loadWeaponAnimations(\"rifle\", 20, 3, 20);\n            loadWeaponAnimations(\"shotgun\", 20, 3, 20);\n            loadWeaponAnimations(\"rocket\", 20, 3, 20);\n            loadWeaponAnimations(\"sniper\", 20, 3, 20);\n        } catch (IOException e) {\n            System.out.println(\"[HATA] GÖRSELLER YÜKLENEMEDİ!\");\n        }\n        System.out.println(\"[CHECK] Player Animation Successfully Uploaded\");\n    }\n\n    private void loadWeaponAnimations(String weapon, int idleMove, int shoot, int reload) throws IOException {\n        Map<PlayerState, BufferedImage[]> map = new HashMap<>();\n        map.put(PlayerState.IDLE, loadFrames(weapon, \"idle\", idleMove));\n        map.put(PlayerState.MOVE, loadFrames(weapon, \"move\", idleMove));\n        map.put(PlayerState.SHOOT, loadFrames(weapon, \"shoot\", shoot));\n        map.put(PlayerState.RELOAD, loadFrames(weapon, \"reload\", reload));\n        animations.put(weapon.toLowerCase(), map);\n    }\n\n    private BufferedImage[] loadFrames(String weapon, String state, int count) throws IOException {\n        BufferedImage[] frames = new BufferedImage[count];\n        for (int i = 0; i < count; i++) {\n            String path = String.format(\"Sprites/Player/%s/%s/survivor-%s_%s_%d.png\",\n                    weapon, state, state, weapon, i);\n            File f = new File(path);\n            if (!f.exists())\n                break; // tolerans\n            BufferedImage original = ImageIO.read(f);\n            frames[i] = resizeImage(original, size, size);\n        }\n        return frames;\n    }\n\n    private BufferedImage resizeImage(BufferedImage original, int w, int h) {\n        if (original == null)\n            return null;\n        Image scaled = original.getScaledInstance(w, h, Image.SCALE_SMOOTH);\n        BufferedImage resized = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2d = resized.createGraphics();\n        g2d.drawImage(scaled, 0, 0, null);\n        g2d.dispose();\n        return resized;\n    }\n\n    public void update(Point mousePos, TileManager tileManager) {\n        int nextX = x + (right ? speed : 0) - (left ? speed : 0);\n        int nextY = y + (down ? speed : 0) - (up ? speed : 0);\n\n        if (!isBlocked(nextX, y, tileManager))\n            x = nextX;\n        if (!isBlocked(x, nextY, tileManager))\n            y = nextY;\n\n        centerX = x + size / 2;\n        centerY = y + size / 2;\n        angleMouse = Math.atan2(mousePos.y - centerY, mousePos.x - centerX);\n\n        if (isReloading) {\n            reloadFrame++;\n            String name = currentWeapon.getName().toLowerCase();\n            Map<PlayerState, BufferedImage[]> map = animations.get(name);\n            if (map != null) {\n                BufferedImage[] reloadFrames = map.get(PlayerState.RELOAD);\n                if (reloadFrames != null && reloadFrame >= reloadFrames.length * frameDelay) {\n                    isReloading = false;\n                    currentWeapon.reload();\n                }\n            }\n        }\n\n        frameCounter++;\n        if (frameCounter >= frameDelay) {\n            frameCounter = 0;\n            String animKey = currentWeapon.getName().toLowerCase().replace(\" \", \"_\");\n            Map<PlayerState, BufferedImage[]> stateMap = animations.get(animKey);\n            if (stateMap != null) {\n                BufferedImage[] frames = stateMap.get(currentState);\n                if (frames != null && frames.length > 0) {\n                    frameIndex = (frameIndex + 1) % frames.length;\n                }\n            }\n        }\n\n        if (!isReloading) {\n            if (up || down || left || right) {\n                setState(PlayerState.MOVE);\n            } else {\n                setState(PlayerState.IDLE);\n            }\n        } else {\n            setState(PlayerState.RELOAD);\n        }\n    }\n\n    private boolean isBlocked(int testX, int testY, TileManager map) {\n        return map.isSolid(testX, testY) ||\n                map.isSolid(testX + size - 1, testY) ||\n                map.isSolid(testX, testY + size - 1) ||\n                map.isSolid(testX + size - 1, testY + size - 1);\n    }\n\n    public void draw(Graphics2D g2d) {\n        String animKey = currentWeapon.getName().toLowerCase().replace(\" \", \"_\");\n        BufferedImage frame = null;\n\n        Map<PlayerState, BufferedImage[]> stateMap = animations.get(animKey);\n        if (stateMap != null) {\n            BufferedImage[] frames = stateMap.get(currentState);\n            if (frames != null && frames.length > 0) {\n                frame = frames[frameIndex % frames.length];\n            }\n        }\n\n        if (frame == null) {\n            // System.out.println(\"[HATA] Frame bulunamadı: \" + animKey + \" \" +\n            // currentState);\n            return;\n        }\n\n        AffineTransform old = g2d.getTransform();\n        g2d.rotate(angleMouse, centerX, centerY);\n        g2d.drawImage(frame, x, y, null);\n        g2d.setTransform(old);\n    }\n\n    // SCROLL\n    public void nextWeapon() {\n        if (!allWeapons.isEmpty()) {\n            currentWeaponIndex = (currentWeaponIndex + 1) % allWeapons.size();\n            setWeapon(allWeapons.get(currentWeaponIndex));\n        }\n    }\n\n    public void previousWeapon() {\n        if (!allWeapons.isEmpty()) {\n            currentWeaponIndex = (currentWeaponIndex - 1 + allWeapons.size()) % allWeapons.size();\n            setWeapon(allWeapons.get(currentWeaponIndex));\n        }\n    }\n\n    private void setWeapon(Weapon w) {\n        currentWeapon = w;\n        int idx = allWeapons.indexOf(w);\n        if (idx >= 0)\n            currentWeaponIndex = idx;\n        frameIndex = 0;\n    }\n\n    public void keyPressed(KeyEvent e) {\n        switch (e.getKeyCode()) {\n            case KeyEvent.VK_W:\n                up = true;\n                break;\n            case KeyEvent.VK_S:\n                down = true;\n                break;\n            case KeyEvent.VK_A:\n                left = true;\n                break;\n            case KeyEvent.VK_D:\n                right = true;\n                break;\n        }\n    }\n\n    public void keyReleased(KeyEvent e) {\n        switch (e.getKeyCode()) {\n            case KeyEvent.VK_W:\n                up = false;\n                break;\n            case KeyEvent.VK_S:\n                down = false;\n                break;\n            case KeyEvent.VK_A:\n                left = false;\n                break;\n            case KeyEvent.VK_D:\n                right = false;\n                break;\n        }\n    }\n\n    public void setState(PlayerState s) {\n        if (currentState != s) {\n            currentState = s;\n            frameIndex = 0;\n        }\n    }\n\n    public void startReload() {\n        if (!isReloading && currentWeapon.needsReload()) {\n            isReloading = true;\n            setState(PlayerState.RELOAD);\n            reloadFrame = 0;\n        }\n    }\n\n    // GET/SET\n    public Weapon getCurrentWeapon() {\n        return currentWeapon;\n    }\n\n    public List<Weapon> getAllWeapons() {\n        return allWeapons;\n    }\n\n    public int getCurrentAmmo() {\n        return currentWeapon.getAmmo();\n    }\n\n    public int getMaxAmmo() {\n        return currentWeapon.getMagSize();\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setX(int val) {\n        x = val;\n    }\n\n    public void setY(int val) {\n        y = val;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public boolean isReloading() {\n        return isReloading;\n    }\n\n    public double getAngleToMouse() {\n        return angleMouse;\n    }\n\n    public void heal(int amount) {\n        health = Math.min(100, health + amount);\n    }\n\n    public void takeDamage(int dmg) {\n        health -= dmg;\n        if (health <= 0) {\n            isDead = true;\n        }\n        if (bloodList != null) {\n            bloodList.add(new PlayerBlood(x, y));\n        }\n    }\n\n    public Point getMuzzlePosition() {\n        int offsetX = 15, offsetY = 10;\n        double rx = Math.cos(angleMouse) * offsetX - Math.sin(angleMouse) * offsetY;\n        double ry = Math.sin(angleMouse) * offsetX + Math.cos(angleMouse) * offsetY;\n        return new Point((int) (x + size / 2 + rx), (int) (y + size / 2 + ry));\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, size, size);\n    }\n}\n"
    },
    {
      "id": "7817361",
      "Entity.java": "package entity;\n\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport main.GamePanel;\nimport main.Bullet;\n\npublic class Entity {\n\n    GamePanel gp;\n    public int worldX, worldY;\n    public int speed;\n\n    public BufferedImage up1, up2, left1, left2, right1, right2, down1, down2;\n    public String direction = \"down\";\n\n    public int spriteCounter = 0;\n    public int spriteNum = 1;\n\n    public Rectangle solidArea = new Rectangle(0, 0, 48, 48);\n    public boolean collisionOn = false;\n    public int solidAreaDefaultX, solidAreaDefaultY;\n    public BufferedImage image, image2, image3;\n    public String name;\n    public boolean collision = false;\n\n    // Character Life\n    public int maxLife;\n    public int life;\n    \n    // Bullets\n    public ArrayList<Bullet> bullets = new ArrayList<>();\n\n    public Entity(GamePanel gp) {\n        this.gp = gp;\n        gp.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (e.getButton() == MouseEvent.BUTTON1) { // Left mouse button\n                    shoot();\n                }\n            }\n        });\n    }\n\n    public void update() {\n        // Update bullets\n        for (int i = 0; i < bullets.size(); i++) {\n            bullets.get(i).update();\n            if (!bullets.get(i).active) {\n                bullets.remove(i);\n                i--;\n            }\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        BufferedImage image = null;\n        \n        switch (direction) {\n            case \"up\":\n                image = up1;\n                break;\n            case \"down\":\n                image = up1;\n                break;\n            case \"left\":\n                image = up1;\n                break;\n            case \"right\":\n                image = up1;\n                break;\n        }\n        \n        if (image != null) {\n            g2.drawImage(image, worldX, worldY, gp.tileSize, gp.tileSize, null);\n        }\n        \n        // Draw bullets\n        for (Bullet bullet : bullets) {\n            bullet.draw(g2);\n        }\n    }\n    \n    public void shoot() {\n        bullets.add(new Bullet(worldX, worldY, direction, gp));\n    }\n}\n\n\n",
      "Player.java": "package entity;\n\nimport main.CollisionChecker;\nimport main.GamePanel;\nimport main.KeyHandler;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseMotionListener;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\nimport java.io.IOException;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.AffineTransformOp;\n\npublic class Player extends Entity implements MouseMotionListener {\n    \n    GamePanel gp;\n    KeyHandler keyH;\n    public final int screenX;\n    public final int screenY;\n    private int mouseX, mouseY;\n    private double angle;\n    \n\n    public Player(GamePanel gp, KeyHandler keyH) {\n        super(gp);\n        this.gp = gp;\n        this.keyH = keyH;\n\n        screenX = gp.screenWidth / 2 - (gp.tileSize / 2);\n        screenY = gp.screenHeight / 2 - (gp.tileSize / 2);\n\n        solidArea = new Rectangle();\n        solidArea.x = 8;\n        solidArea.y = 16;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        solidArea.width = 32;\n        solidArea.height = 32;\n        \n        setDefaultValues();\n        getPlayerImage();\n        gp.addMouseMotionListener(this);\n    }\n\n    public void setDefaultValues() {\n        worldX = gp.tileSize * 50;\n        worldY = gp.tileSize * 50;\n        speed = 4;\n        angle = 0;\n\n        maxLife= 6;\n        life = maxLife;\n    }\n\n    public void getPlayerImage() {\n        try {\n            down1 = ImageIO.read(getClass().getResourceAsStream(\"/GameSprite/Player/playerWalkDown/playerWalkRight_1.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void update() {\n        if (keyH.upPressed){\n            direction = \"up\";\n            worldY -= speed;\n        }\n            \n        if (keyH.downPressed){ \n            direction = \"down\";\n            worldY += speed;\n            \n        }\n        if (keyH.leftPressed){ \n            direction = \"left\";\n            worldX -= speed;\n            \n        }\n        if (keyH.rightPressed){\n            direction = \"right\";\n            worldX += speed;\n           \n        }\n        \n        \n        \n        // Fare konumuna göre açıyı hesapla\n        double dx = mouseX - screenX;\n        double dy = mouseY - screenY;\n        angle = Math.atan2(dy, dx);\n\n        collisionOn = false;\n        gp.cChecker.checkTile(this);\n\n        if(collisionOn == false){\n            if(keyH.upPressed){\n                worldY -= speed;\n            }\n            if(keyH.downPressed){\n                worldY += speed;\n            }\n            if(keyH.leftPressed){\n                worldX -= speed;\n            }\n            if(keyH.rightPressed){\n                worldX += speed;\n            }\n        }\n\n\n\n        int objIndex = gp.cChecker.checkObject(this,true);\n        pickUpObject(objIndex);\n\n        gp.eHandler.checkEvent();\n        \n    }\n    public void pickUpObject (int index){\n\n        if(index != 999){\n            \n        }\n\n    }\n\n    public void draw(Graphics2D g2) {\n        if (down1 == null) return;\n        \n        // Karakteri döndür\n        BufferedImage rotatedImage = rotateImage(down1, Math.toDegrees(angle));\n        \n        g2.drawImage(rotatedImage, screenX, screenY, gp.tileSize, gp.tileSize, null);\n    }\n\n    private BufferedImage rotateImage(BufferedImage image, double angle) {\n        double rads = Math.toRadians(angle);\n        double sin = Math.abs(Math.sin(rads)), cos = Math.abs(Math.cos(rads));\n        int w = image.getWidth(), h = image.getHeight();\n        int newWidth = (int) Math.floor(w * cos + h * sin);\n        int newHeight = (int) Math.floor(h * cos + w * sin);\n        \n        BufferedImage rotated = new BufferedImage(newWidth, newHeight, image.getType());\n        Graphics2D g2d = rotated.createGraphics();\n        AffineTransform at = new AffineTransform();\n        at.translate((newWidth - w) / 2, (newHeight - h) / 2);\n        at.rotate(rads, w / 2, h / 2);\n        g2d.setTransform(at);\n        g2d.drawImage(image, 0, 0, null);\n        g2d.dispose();\n        return rotated;\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        // Gerekli değil\n    }\n}",
      "Bullet.java": "package main;\n\nimport java.awt.Graphics2D;\n\nimport entity.Entity;\n\npublic class Bullet {\n    int x, y;\n    int speed = 5;\n    String direction;\n    public boolean active = true;\n    GamePanel gp;\n    \n    public Bullet(int x, int y, String direction, GamePanel gp) {\n        this.x = x;\n        this.y = y;\n        this.direction = direction;\n        this.gp = gp;\n    }\n    \n    public void update() {\n        switch (direction) {\n            case \"up\":\n                y -= speed;\n                break;\n            case \"down\":\n                y += speed;\n                break;\n            case \"left\":\n                x -= speed;\n                break;\n            case \"right\":\n                x += speed;\n                break;\n        }\n        \n        if (x < 0 || x > gp.screenWidth || y < 0 || y > gp.screenHeight) {\n            active = false;\n        }\n        \n        // Check collision with zombies\n        for (Entity zombie : gp.zombies) {\n            if (this.x >= zombie.worldX && this.x <= zombie.worldX + gp.tileSize &&\n                this.y >= zombie.worldY && this.y <= zombie.worldY + gp.tileSize) {\n                zombie.life--;\n                if (zombie.life <= 0) {\n                    gp.zombies.remove(zombie);\n                }\n                this.active = false;\n                break;\n            }\n        }\n    }\n    \n    public void draw(Graphics2D g2) {\n        g2.fillOval(x, y, 10, 10);\n    }\n}",
      "Main.java": "package main;\n\nimport javax.swing.JFrame;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        JFrame window = new JFrame();\n        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        window.setResizable(false);\n        window.setTitle(\"Top-Down Shooter\");\n\n        GamePanel gamePanel = new GamePanel();\n        window.add(gamePanel);\n\n        window.pack();\n\n        window.setLocationRelativeTo(null);\n        window.setVisible(true);\n\n\n        gamePanel.setupGame();\n        gamePanel.startGameThread();\n\n\n    }\n\n}\n",
      "GamePanel.java": "package main;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.util.ArrayList;\n\nimport javax.swing.JPanel;\n\nimport entity.Entity;\nimport entity.Player;\nimport main.object.SuperObject;\nimport tile.TileManager;\n\npublic class GamePanel extends JPanel implements Runnable{\n\n    //EKRAN AYARLARI\n\n    final int originalTileSize = 16; //\n    final int scale = 3;\n\n    public final int tileSize = originalTileSize * scale;\n    public final int maxScreenCol = 32;\n    public final int maxScreenRow = 18;\n    public final int screenWidth = tileSize * maxScreenCol; \n    public final int screenHeight = tileSize * maxScreenRow;\n\n    //Dünya ayarları\n    public final int maxWorldCol=100;\n    public final int maxWorldRow=100;\n    public final int worldWidth = tileSize * maxWorldCol;\n    public final int worldHeight = tileSize * maxWorldRow;\n\n    int FPS = 60;\n\n    TileManager tileM = new TileManager(this);\n    KeyHandler keyH = new KeyHandler(this);\n    public UI ui = new UI(this);\n    public EventHandler eHandler = new EventHandler(this);\n    Thread gameThread;\n    public Player player = new Player(this, keyH );\n    public SuperObject obj[] = new SuperObject[10];\n    public ArrayList<Entity> zombies = new ArrayList<>();\n    public AssetSetter aSetter = new AssetSetter(this);\n    public CollisionChecker cChecker = new CollisionChecker(this);\n\n    public int gameState;\n    public final int titleState = 0;\n    public final int playState= 1;\n    public final int pauseState = 2;\n\n    int playerX = 100;\n    int playerY = 100;\n    int playerSpeed = 4;\n\n    public ArrayList<SuperObject> inventory = new ArrayList<>();\n\n    public GamePanel(){\n\n        this.setPreferredSize(new Dimension(screenWidth, screenHeight));\n        this.setBackground(Color.BLACK);\n        this.setDoubleBuffered(true);\n        this.addKeyListener(keyH);\n        this.setFocusable(true);\n    }\n    public void setupGame(){\n        aSetter.setObject();\n        gameState = titleState;\n        aSetter.setMonster();\n        \n\n    }\n\n    public void startGameThread(){\n\n        gameThread = new Thread(this);\n        gameThread.start();\n\n    }\n\n    @Override\n    public void run(){\n\n        double drawInterval = 1000000000/FPS;\n        double nextDrawTime = System.nanoTime() + drawInterval;\n\n\n        while(gameThread != null){\n\n            long currentTime = System.nanoTime();\n\n            update();\n\n            repaint();\n\n            try{\n                double remainingTime = nextDrawTime - System.nanoTime();\n                remainingTime = remainingTime/100000;\n\n                if(remainingTime <0){\n                    remainingTime = 0;\n                }\n\n                Thread.sleep((long) remainingTime);\n\n                nextDrawTime += drawInterval; \n\n            }catch(InterruptedException e){\n\n                e.printStackTrace();\n\n            }\n\n           \n        }\n\n    }\n    public void update(){\n\n        if(gameState == playState){\n            player.update();\n\n            for(int i = 0; i<zombies.size(); i++){\n                if(zombies.get(i) != null){\n                    zombies.get(i).update();\n                }\n            }\n            \n        }\n        if(gameState == pauseState){\n            //nothing\n        }\n\n        player.update();\n    }\n    public void paintComponent(Graphics g){\n\n        super.paintComponent(g);\n\n        Graphics2D g2 = (Graphics2D)g;\n\n        if(gameState == titleState){\n            ui.draw(g2);\n        }\n        else {\n            tileM.draw(g2);\n\n            obj[0].draw(g2, this);\n\n            player.draw(g2);\n\n            zombies.get(0).draw(g2);\n\n\n        }\n\n\n\n        \n\n        \n\n        ui.draw(g2);\n\n        g2.dispose();\n    }\n\n}\n",
      "UI.java": "package main;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.nio.Buffer;\n\nimport main.object.OBJ_Heart;\nimport main.object.SuperObject; \n\npublic class UI {\n\n    GamePanel gp;\n    Graphics2D g2;\n    Font arial_40, arial_80B;\n    BufferedImage heart_full, heart_half, heart_blank;\n    public boolean messageOn = false;\n    public String message = \"\";\n    public boolean gameFinished = false;\n    public double playTime;\n    public int commandNum = 0;\n\n    public UI(GamePanel gp){\n        this.gp = gp;\n\n        arial_40 = new Font(\"Arial\", Font.PLAIN, 40);\n        arial_80B = new Font(\"Arial\", Font.BOLD, 80);\n\n        SuperObject heart = new OBJ_Heart(gp);\n        heart_full = heart.image3;\n        heart_half = heart.image2;\n        heart_blank = heart.image;\n    }\n\n    public void showMessage(String text){\n        message = text;\n        messageOn = true;\n    }\n    public void draw(Graphics2D g2){\n\n        this.g2 = g2;\n\n        g2.setFont(arial_40);\n        g2.setColor(Color.white);\n\n        if(gp.gameState == gp.titleState){\n            \n            drawTitleScreen();\n        }\n\n        if(gp.gameState == gp.playState){\n            //add something later\n            drawPlayerLife();\n        }\n        if(gp.gameState == gp.pauseState){\n            \n            drawPlayerLife();\n            drawPauseScreen();\n            \n        }\n        \n    }\n    public void drawPlayerLife(){\n        int x = gp.tileSize/2;\n        int y = gp.tileSize/2;\n        int i = 0;\n\n        //draw blank hearts first\n        while(i<gp.player.maxLife/2){\n            g2.drawImage(heart_blank,x,y,null);\n            i++;\n            x+=gp.tileSize;\n        }\n        //RESET\n        x = gp.tileSize/2;\n        y = gp.tileSize/2;\n        i = 0;\n        //draw current hearts\n        while(i<gp.player.life){\n            g2.drawImage(heart_half,x,y,null);\n            i++;\n            if(i<gp.player.life){\n                g2.drawImage(heart_full,x,y,null);\n            }\n            i++;\n            x+=gp.tileSize;\n                \n        }\n    }\n    public void drawTitleScreen(){\n\n        g2.setBackground(Color.black);\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD,96F));\n        String text = \"TOP-DOWN SHOOTER\";\n        int x = getXForCenteredText(text);\n        int y = gp.tileSize*3;\n        g2.setColor(Color.white);\n        g2.drawString(text,x,y);\n\n\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD,48F));\n\n\n        text = \"NEW GAME\";\n        x = getXForCenteredText(text);\n        y += gp.tileSize*8;\n        g2.drawString(text,x,y);\n        if(commandNum == 0){\n            g2.drawString(\">\", x-gp.tileSize, y);\n        }\n\n        text = \"LOAD GAME\";\n        x = getXForCenteredText(text);  \n        y += gp.tileSize*2;\n        g2.drawString(text,x,y);\n        if(commandNum == 1){\n            g2.drawString(\">\", x-gp.tileSize, y);\n        }\n\n        text = \"QUIT\";\n        x = getXForCenteredText(text);\n        y += gp.tileSize*2;\n        g2.drawString(text,x,y);\n        if(commandNum == 2){\n            g2.drawString(\">\", x-gp.tileSize, y);\n        }\n\n        \n        \n    }\n    public void drawPauseScreen(){\n        String text = \"PAUSED\";\n\n        int length = (int)g2.getFontMetrics().getStringBounds(text, g2).getWidth();\n        \n        int x,y=gp.screenHeight/2;\n        x = getXForCenteredText(text);\n        g2.drawString(text,x,y);\n    }\n    public int getXForCenteredText(String text){\n        int length = (int)g2.getFontMetrics().getStringBounds(text, g2).getWidth();\n        int x = gp.screenWidth/2-length/2;\n        return x;\n    }\n\n}\n",
      "AssetSetter.java": "package main;\n\nimport main.monster.ZOM_Base;\nimport main.object.OBJ_Magazine;\n\npublic class AssetSetter {\n\n    GamePanel gp;\n    \n    public AssetSetter(GamePanel gp){\n        this.gp = gp;\n    }\n\n    public void setObject(){\n        gp.obj[0] = new OBJ_Magazine(gp);\n        gp.obj[0].worldX = 40*gp.tileSize;\n        gp.obj[0].worldY = 50*gp.tileSize;\n    }\n    public void setMonster(){\n        ZOM_Base zombie = new ZOM_Base(gp);\n        gp.zombies.add(zombie);\n        gp.zombies.get(0).worldX = 53*gp.tileSize;\n        gp.zombies.get(0).worldY = 54*gp.tileSize;\n    }\n\n}\n",
      "KeyHandler.java": "package main;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\nimport entity.Entity;\n\npublic class KeyHandler implements KeyListener {\n\n\n    GamePanel gp;\n    public boolean upPressed, downPressed, leftPressed, rightPressed;\n    public Entity entity;\n    @Override\n    public void keyTyped(KeyEvent e) {\n        \n    }\n    public KeyHandler(GamePanel gp){\n        this.gp = gp;\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        \n        int code = e.getKeyCode();\n        //TITLE STATE\n        if(gp.gameState == gp.titleState){\n            if(code == KeyEvent.VK_W){\n                gp.ui.commandNum--;\n                if(gp.ui.commandNum == -1){\n                    gp.ui.commandNum = 2;\n                }\n        \n\n            }\n            if(code == KeyEvent.VK_S){\n                gp.ui.commandNum++;\n                if(gp.ui.commandNum ==3){\n                    gp.ui.commandNum = 0;\n        \n                }\n            }\n            if(code == KeyEvent.VK_ENTER){\n                if(gp.ui.commandNum == 0){\n                    gp.gameState = gp.playState;\n                }\n                if(gp.ui.commandNum == 1){\n                    //add later\n                }\n                if(gp.ui.commandNum == 2){\n                    System.exit(0);\n                }\n            }\n        }\n\n        //PLAY STATE\n        if(gp.gameState == gp.playState){\n            if(code == KeyEvent.VK_W){\n            \n                upPressed = true;\n                \n            }\n            if(code == KeyEvent.VK_S){\n                   \n                downPressed = true; \n                \n            }\n            if(code == KeyEvent.VK_A){\n                 \n                leftPressed = true;\n                \n            }\n            if(code == KeyEvent.VK_D){\n                  \n                rightPressed = true;       \n                 \n            }\n            if(code == KeyEvent.VK_P){\n                if(gp.gameState == gp.playState){\n                    gp.gameState = gp.pauseState;\n                }\n                else if(gp.gameState == gp.pauseState){\n                    gp.gameState = gp.playState;\n                }\n            }\n        }\n        \n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n\n        int code = e.getKeyCode();\n\n        if(code == KeyEvent.VK_W){\n            upPressed = false;\n        }\n        if(code == KeyEvent.VK_S){\n            downPressed = false;    \n        }\n        if(code == KeyEvent.VK_A){\n            leftPressed = false;\n        }\n        if(code == KeyEvent.VK_D){\n            rightPressed = false;            \n        }\n \n    }\n\n}\n",
      "CollisionChecker.java": "package main;\n\nimport entity.Entity;\n\npublic class CollisionChecker {\n\n    GamePanel gp;\n    KeyHandler keyH = new KeyHandler(gp);\n\n    public CollisionChecker(GamePanel gp){\n        this.gp = gp;\n    }\n    public void checkTile(Entity entity){\n\n        int entityLeftWorldX = entity.worldX + entity.solidArea.x;\n        int entityRightWorldX = entity.worldX + entity.solidArea.x + entity.solidArea.width;\n        int entityTopWorldY = entity.worldY + entity.solidArea.y;\n        int entityBottomWorldY = entity.worldY + entity.solidArea.y + entity.solidArea.height;\n\n        int entityLeftCol = entityLeftWorldX / gp.tileSize;\n        int entityRightCol = entityRightWorldX / gp.tileSize;\n        int entityTopRow = entityTopWorldY / gp.tileSize;\n        int entityBottomRow = entityBottomWorldY / gp.tileSize;\n        \n        int tileNum1, tileNum2;\n\n        if(keyH.upPressed){\n            entityTopRow = (entityTopWorldY - entity.speed) / gp.tileSize;\n            tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];\n            tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];\n            if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true){\n                entity.collisionOn = true;\n            }\n        }\n        if(keyH.downPressed){\n            entityBottomRow = (entityBottomWorldY + entity.speed) / gp.tileSize;\n            tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];\n            tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];\n            if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true){\n                entity.collisionOn = true;\n            }   \n        }\n        if(keyH.leftPressed){\n            entityLeftCol = (entityLeftWorldX - entity.speed) / gp.tileSize;\n            tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];\n            tileNum2 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];\n            if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true){\n                entity.collisionOn = true;\n            }\n        }\n        if(keyH.rightPressed){\n            entityRightCol = (entityRightWorldX + entity.speed) / gp.tileSize;\n            tileNum1 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];\n            tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];\n            if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true){\n                entity.collisionOn = true;\n            }\n        }\n\n    }\n    public int checkObject(Entity entity, boolean player){\n\n        int index = 999;\n\n        for(int i = 0; i<gp.obj.length; i++){\n            if(gp.obj[i]!= null){\n\n\n\n                entity.solidArea.x = entity.worldX + entity.solidArea.x;\n                entity.solidArea.y = entity.worldY + entity.solidArea.y;\n\n                gp.obj[i].solidArea.x = gp.obj[i].worldX + gp.obj[i].solidArea.x;\n                gp.obj[i].solidArea.y = gp.obj[i].worldY + gp.obj[i].solidArea.y;\n\n                if(keyH.upPressed){\n                    entity.solidArea.y -= entity.speed;\n                    if(entity.solidArea.intersects(gp.obj[i].solidArea)){\n                        if(gp.obj[i].collision == true){\n                            entity.collisionOn = true;\n                        }\n                        if(player == true){\n                            index = i;\n                        }\n                    }\n                }\n                if(keyH.downPressed){\n                    entity.solidArea.y += entity.speed;\n                    if(entity.solidArea.intersects(gp.obj[i].solidArea)){\n                        if(gp.obj[i].collision == true){\n                            entity.collisionOn = true;\n                        }\n                        if(player == true){\n                            index = i;\n                        }\n                    }\n                }\n                if(keyH.leftPressed){    \n                    entity.solidArea.x -= entity.speed;\n                    if(entity.solidArea.intersects(gp.obj[i].solidArea)){\n                        if(gp.obj[i].collision == true){\n                            entity.collisionOn = true;\n                        }\n                        if(player == true){\n                            index = i;\n                        }\n                    }\n                }\n                if(keyH.rightPressed){  \n                    entity.solidArea.x += entity.speed;\n                    if(entity.solidArea.intersects(gp.obj[i].solidArea)){\n                        if(gp.obj[i].collision == true){\n                            entity.collisionOn = true;\n                        }\n                        if(player == true){\n                            index = i;\n                        }\n                    }\n                }\n                entity.solidArea.x = entity.solidAreaDefaultX;\n                entity.solidArea.y = entity.solidAreaDefaultY;\n                gp.obj[i].solidArea.x = gp.obj[i].solidAreaDefaultX;\n                gp.obj[i].solidArea.y = gp.obj[i].solidAreaDefaultY;\n\n\n            }\n        }\n        System.out.println(index);\n\n        return index;\n    }\n\n}\n",
      "EventHandler.java": "package main;\n\nimport java.awt.Rectangle;\n\npublic class EventHandler {\n\n    GamePanel gp;\n    Rectangle eventRect;\n    int eventRectDefaultX, eventRectDefaultY;\n    \n    public EventHandler(GamePanel gp) {\n        this.gp = gp;\n\n        eventRect = new Rectangle();\n        eventRect.x = 23;\n        eventRect.y = 23;\n        eventRect.width = 2;\n        eventRect.height = 2;\n        eventRectDefaultX = eventRect.x;\n        eventRectDefaultY = eventRect.y;\n    }\n\n    public void checkEvent(){\n\n        if(hit(27,16,  \"right\" ) == true){\n            damagePit(gp.playState);\n        }\n\n    }\n    public boolean hit(int eventCol, int eventRow, String reqDirection){\n\n        boolean hit = false;\n\n        gp.player.solidArea.x = gp.player.worldX + gp.player.solidArea.x;\n        gp.player.solidArea.y = gp.player.worldY + gp.player.solidArea.y;\n        eventRect.x = eventCol * gp.tileSize + eventRect.x;\n        eventRect.y = eventRow * gp.tileSize + eventRect.y;\n\n        if(gp.player.solidArea.intersects(eventRect)){\n            if(gp.player.direction.contentEquals(reqDirection)|| reqDirection.contentEquals(\"any\")){\n                hit = true;\n            }\n        }\n\n        gp.player.solidArea.x = gp.player.solidAreaDefaultX;\n        gp.player.solidArea.y = gp.player.solidAreaDefaultY;\n        eventRect.x = eventRectDefaultX;\n        eventRect.y = eventRectDefaultY;\n\n        return hit;\n    }\n    public void damagePit(int gameState){\n        gp.gameState = gameState;\n        gp.player.life -=1;\n    }\n\n}\n",
      "ZOM_Base.java": "package main.monster;\n\nimport java.awt.Graphics2D;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\nimport entity.Entity;\nimport main.GamePanel;\n\npublic class ZOM_Base extends Entity {\n\n    GamePanel gp;\n\n    public ZOM_Base(GamePanel gp) {\n        super(gp);\n        this.gp = gp;\n        \n        String name = \"Normal Zombi\";\n        speed = 1;\n        maxLife = 3;\n        life = maxLife;\n        \n        solidArea.x = 3;\n        solidArea.y = 18;\n        solidArea.width = 42;\n        solidArea.height = 30;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        getImage();\n\n        update();\n    }\n    \n    public void getImage() {\n        try {\n            up1 = ImageIO.read(getClass().getResourceAsStream(\"/GameSprite/Zombies/pjqNXJ.png\"));\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public void update() {\n        int playerX = gp.player.worldX;\n        int playerY = gp.player.worldY;\n        \n        if (worldX < playerX) {\n            worldX += speed; // Sağ git\n        } else if (worldX > playerX) {\n            worldX -= speed; // Sol git\n        }\n        \n        if (worldY < playerY) {\n            worldY += speed; // Aşağı git\n        } else if (worldY > playerY) {\n            worldY -= speed; // Yukarı git\n        }\n    }\n\n    \n}\n",
      "OBJ_Heart.java": "package main.object;\n\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport main.GamePanel;\n\npublic class OBJ_Heart extends SuperObject{\n    GamePanel gp;\n\n    public OBJ_Heart(GamePanel gp){\n\n        this.gp = gp;\n        name = \"Heart\";\n        try{\n            image = ImageIO.read(getClass().getResource(\"/GameSprite/Object/health/blank_Heart.png\"));\n            image2 = ImageIO.read(getClass().getResource(\"/GameSprite/Object/health/half_Heart.png\"));\n            image3 = ImageIO.read(getClass().getResource(\"/GameSprite/Object/health/full_Heart.png\"));\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n\n    }\n\n}\n",
      "OBJ_Magazine.java": "package main.object;\n\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport entity.Entity;\nimport main.GamePanel;\n\npublic class OBJ_Magazine extends SuperObject{\n\n    GamePanel gp;\n\n    public OBJ_Magazine(GamePanel gp){\n\n        this.gp = gp;\n\n        name = \"Magazine\";\n        try{\n\n            image = ImageIO.read(getClass().getResourceAsStream(\"/GameSprite/Object/Ammo.png\"));\n            \n        }catch(IOException e){\n            e.printStackTrace();\n        }\n        collision = true;\n    }\n\n}\n",
      "SuperObject.java": "package main.object;\n\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\n\nimport main.GamePanel;\n\npublic class SuperObject {\n\n    public BufferedImage image, image2, image3;\n    public String name;\n    public boolean collision = false;\n    public int worldX, worldY;\n    public Rectangle solidArea = new Rectangle(0,0,48,48);\n    public int solidAreaDefaultX = 0;\n    public int solidAreaDefaultY = 0;\n    \n\n    public void draw(Graphics2D g2, GamePanel gp){\n\n        int screenX = worldX - gp.player.worldX + gp.player.screenX;\n        int screenY = worldY - gp.player.worldY + gp.player.screenY;\n            \n        if(worldX + gp.tileSize > gp.player.worldX - gp.player.screenX &&\n            worldX - gp.tileSize < gp.player.worldX + gp.player.screenX &&\n            worldY + gp.tileSize > gp.player.worldY - gp.player.screenY &&\n            worldY - gp.tileSize < gp.player.worldY + gp.player.screenY){\n\n            g2.drawImage(image, screenX,screenY, gp.tileSize,gp.tileSize,null);\n\n        }\n\n    }\n\n}\n",
      "Tile.java": "package tile;\nimport java.awt.image.BufferedImage;\n\n\npublic class Tile {\n\n    BufferedImage image;\n    public boolean collision = false;\n\n}\n",
      "TileManager.java": "package tile;\n\nimport java.awt.Graphics2D;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\nimport javax.imageio.ImageIO;\n\nimport main.GamePanel;\n\npublic class TileManager {\n\n    GamePanel gp;\n    public Tile[] tile;\n    public int mapTileNum[][];\n\n    public TileManager(GamePanel gp){\n\n        this.gp = gp;\n\n        tile = new Tile[10];\n        mapTileNum= new int[gp.maxWorldCol][gp.maxWorldRow];\n\n        getTileImage();\n        loadMap(\"/GameSprite/Map/World.txt\");\n\n    }\n    public void getTileImage(){\n\n        try{\n\n            tile[0] = new Tile();\n            tile[0].image = ImageIO.read(getClass().getResourceAsStream(\"/GameSprite/Tiles/grass.png\"));\n            tile[0].collision = false;\n\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n\n    }\n    public void loadMap(String filePath){\n        try{\n\n            InputStream is = getClass().getResourceAsStream(filePath);\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n\n            int col = 0;\n            int row = 0;\n\n            while(col<gp.maxWorldCol && row< gp.maxWorldRow){\n\n                String line = br.readLine();\n\n                while(col<gp.maxWorldCol ){\n\n                    String[] numbers = line.split(\" \");\n\n                    int num = Integer.parseInt(numbers[col]);\n\n                    mapTileNum[col][row] = num;\n                    col++;\n                    \n                }\n                if(col == gp.maxWorldCol){\n                    col = 0;\n                    row++;\n                }\n\n\n\n            }\n            br.close();\n\n        }catch(Exception e){\n\n        }\n    }\n    public void draw(Graphics2D g2){\n\n        int worldCol = 0;\n        int worldRow =0;\n       \n\n        while (worldCol< gp.maxWorldCol && worldRow< gp.maxWorldRow){\n\n            int tileNum = mapTileNum[worldCol][worldRow];\n\n            int worldX = worldCol * gp.tileSize;\n            int worldY = worldRow * gp.tileSize;\n            int screenX = worldX - gp.player.worldX + gp.player.screenX;\n            int screenY = worldY - gp.player.worldY + gp.player.screenY;\n            \n            if(worldX + gp.tileSize > gp.player.worldX - gp.player.screenX &&\n               worldX - gp.tileSize < gp.player.worldX + gp.player.screenX &&\n               worldY + gp.tileSize > gp.player.worldY - gp.player.screenY &&\n               worldY - gp.tileSize < gp.player.worldY + gp.player.screenY){\n\n                g2.drawImage(tile[tileNum].image, screenX,screenY, gp.tileSize,gp.tileSize,null);\n\n               }\n\n            \n            worldCol++;\n           \n\n            if(worldCol == gp.maxWorldCol){\n                worldCol = 0;\n                \n                worldRow++;\n                \n            }\n        \n        }\n\n        \n        \n\n    }\n\n}\n"
    },
    {
      "id": "6275288",
      "Sniper.java": "public class Sniper extends Silahlar {\n    public Sniper(GamePanel gp) {\n        super(gp);\n        this.Ateş_Hizi = 30;\n        this.maxŞarjör = 5;\n        this.Şarjör_kapasite = 5;\n        this.Sapma_Açisi = 0;\n        this.Şarjör_Sayisi = 5;\n        this.name = \"sniper\";\n    }\n}\n",
      "Normal_Zombi.java": "\nimport javax.imageio.ImageIO;\n\npublic class Normal_Zombi extends Zombi {\n\n    public Normal_Zombi(GamePanel gp) {\n        super(gp);\n        this.name = \"normal zombi\";\n        this.can = 3;\n        this.Hasar = 2;\n        this.Hiz = 1;\n\n    }\n\n    public void getImage() {\n        if (situation.equals(\"walk\")) {\n            try {\n                if (direction.equals(\"left\")) {\n                    switch (z) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (1.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (2.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (3.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (4.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (5.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (6.png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (7.png\"));\n                            break;\n                        case 7:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (8.png\"));\n                            break;\n                        case 8:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (9.png\"));\n                            break;\n                        case 9:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (10.png\"));\n                            break;\n                    }\n                } else {\n                    switch (z) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (1).png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (2).png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (3).png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (4).png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (5).png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (6).png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (7).png\"));\n                            break;\n                        case 7:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (8).png\"));\n                            break;\n                        case 8:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (9).png\"));\n                            break;\n                        case 9:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (10).png\"));\n                            break;\n                    }\n                }\n            } catch (Exception e) {\n\n            }\n        } else if (situation.equals(\"attack\")) {\n            if (direction.equals(\"left\")) {\n                try {\n                    switch (t) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (1.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (2.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (3.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (4.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (5.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (6.png\"));\n                            break;\n\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            } else {\n                try {\n                    switch (t) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (1).png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (2).png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (3).png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (4).png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (5).png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (6).png\"));\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            }\n\n        } else if (situation.equals(\"hurt\")) {\n            if (oldDirection.equals(\"walk\")) {\n                try {\n                    if (direction.equals(\"left\")) {\n                        shooted = false;\n                        switch (z) {\n                            case 0:\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (1.png\"));\n                                break;\n                            case 1:\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (2.png\"));\n                                break;\n                            case 2:\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (3.png\"));\n                                break;\n                            case 3:\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (4.png\"));\n                                break;\n                            case 4:\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (5.png\"));\n                                break;\n                            case 5:\n\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (6.png\"));\n                                break;\n                            case 6:\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (7.png\"));\n                                break;\n                            case 7:\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (8.png\"));\n                                break;\n                            case 8:\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (9.png\"));\n                                break;\n                            case 9:\n\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (10.png\"));\n                                break;\n                        }\n                    } else {\n                        shooted = false;\n                        switch (z) {\n                            case 0:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (1).png\"));\n                                break;\n                            case 1:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (2).png\"));\n                                break;\n                            case 2:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (3).png\"));\n                                break;\n                            case 3:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (4).png\"));\n                                break;\n                            case 4:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (5).png\"));\n                                break;\n                            case 5:\n\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (6).png\"));\n                                break;\n                            case 6:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (7).png\"));\n                                break;\n                            case 7:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (8).png\"));\n                                break;\n                            case 8:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (9).png\"));\n                                break;\n                            case 9:\n\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Walk (10).png\"));\n                                break;\n                        }\n                    }\n                } catch (Exception e) {\n\n                }\n            } else if (oldDirection.equals(\"attack\")) {\n                if (direction.equals(\"left\")) {\n                    shooted = false;\n                    try {\n                        switch (t) {\n                            case 0:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (1.png\"));\n                                break;\n                            case 1:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (2.png\"));\n                                break;\n                            case 2:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (3.png\"));\n                                break;\n                            case 3:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (4.png\"));\n                                break;\n                            case 4:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (5.png\"));\n                                break;\n                            case 5:\n\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (6.png\"));\n                                break;\n\n                        }\n                    } catch (Exception e) {\n                        // TODO: handle exception\n                    }\n                } else {\n                    shooted = false;\n                    try {\n                        switch (t) {\n                            case 0:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (1).png\"));\n                                break;\n                            case 1:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (2).png\"));\n                                break;\n                            case 2:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (3).png\"));\n                                break;\n                            case 3:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (4).png\"));\n                                break;\n                            case 4:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (5).png\"));\n                                break;\n                            case 5:\n\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Attack (6).png\"));\n                                break;\n                        }\n                    } catch (Exception e) {\n                        // TODO: handle exception\n                    }\n                }\n\n            }\n        } else if (situation.equals(\"dead\")) {\n            if (direction.equals(\"right\")) {\n\n                try {\n                    switch (d) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (1).png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (2).png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (3).png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (4).png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (5).png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (6).png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (7).png\"));\n                            break;\n                        case 7:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (8).png\"));\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            } else {\n                try {\n                    switch (d) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (1.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (2.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (3.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (4.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (5.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (6.png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (7.png\"));\n                            break;\n                        case 7:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi1\\\\Dead (8.png\"));\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            }\n\n        }\n    }\n}\n",
      "Silahlar.java": "\npublic abstract class Silahlar {\n    public int Şarjör_kapasite = 4;\n    public int maxŞarjör = 4;\n    public GamePanel gp;\n    public String name;\n    public int Ateş_Hizi;\n    public int Sapma_Açisi, Şarjör_Sayisi = 7;\n\n    public Silahlar(GamePanel gp) {\n        // this.gp = gp;\n    }\n\n    public boolean Şarjör_Yenile() {\n        if (Şarjör_Sayisi > 0) {\n            Şarjör_kapasite = maxŞarjör;\n            Şarjör_Sayisi--;\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n",
      "Asit_Zombisi.java": "import javax.imageio.ImageIO;\n\npublic class Asit_Zombisi extends Zombi {\n    public Asit_Zombisi(GamePanel gp) {\n        super(gp);\n        this.name = \"asit zombisi\";\n        this.can = 2;\n        this.Hiz = 1;\n        this.Hasar = 2;\n\n    }\n\n    public void getImage() {\n        if (situation.equals(\"walk\")) {\n            try {\n                if (direction.equals(\"left\")) {\n                    switch (z) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk1 (1).png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk2 (1).png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk3 (1).png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk4 (1).png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk5 (1).png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk6 (1).png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk6 (1).png\"));\n                            z = 0;\n                            break;\n\n                    }\n                } else {\n                    switch (z) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk1.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk2.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk3.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk4.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk5.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk6.png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Walk6.png\"));\n                            z = 0;\n                            break;\n\n                    }\n                }\n            } catch (Exception e) {\n\n            }\n        } else if (situation.equals(\"attack\")) {\n            if (direction.equals(\"left\")) {\n                try {\n                    switch (t) {\n                        case 0:\n                            gp.c.add(new zombi_asidi(gp));\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Attack1 (1).png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Attack2 (1).png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Attack3 (1).png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Attack4 (1).png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Attack5 (1).png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Attack6 (1).png\"));\n                            break;\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            } else if (direction.equals(\"right\")) {\n                try {\n                    switch (t) {\n                        case 0:\n                            gp.c.add(new zombi_asidi(gp));\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Attack1.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Attack2.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Attack3.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Attack4.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Attack5.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Attack6.png\"));\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            }\n\n        } else if (situation.equals(\"hurt\")) {\n            if (direction.equals(\"right\")) {\n\n                try {\n                    switch (h) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Hurt1.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Hurt2.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Hurt3.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Hurt4.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Hurt5.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Hurt5.png\"));\n                            shooted = false;\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            } else {\n                try {\n                    switch (h) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Hurt1 (1).png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Hurt2 (1).png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Hurt3 (1).png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Hurt4 (1).png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Hurt5 (1).png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Hurt5 (1).png\"));\n                            shooted = false;\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            }\n\n        } else if (situation.equals(\"dead\")) {\n            if (direction.equals(\"right\")) {\n                try {\n                    switch (d) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead1.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead2.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead3.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead4.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead5.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead6.png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead7.png\"));\n                            break;\n                        case 7:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead8.png\"));\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            } else {\n                try {\n                    switch (d) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead1 (1).png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead1 (1).png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead2 (1).png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead4 (1).png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead5 (3).png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead6 (6).png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead7 (2).png\"));\n                            break;\n                        case 7:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi2\\\\Dead8 (2).png\"));\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            }\n\n        }\n    }\n}\n",
      "Tabanca.java": "\npublic class Tabanca extends Silahlar {\n    public Tabanca(GamePanel gp) {\n        super(gp);\n        this.Ateş_Hizi = 120;\n        this.maxŞarjör = 12;\n        this.Şarjör_kapasite = 12;\n        this.Sapma_Açisi = 0;\n        this.Şarjör_Sayisi = Integer.MAX_VALUE;\n        this.name = \"tabanca\";\n    }\n}\n",
      "Entity.java": "import java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Entity {\n    public int worldX, worldY, speed = 4;\n    public BufferedImage up1, up2, down1, down2, left1, left2, right1, right2;\n    public String direction;\n    public int spriteNum = 1;\n    public int sprintCounter = 0;\n    public Rectangle solidArea;\n    public boolean collisionOn = false;\n}\n",
      "Bullet.java": "import java.awt.Graphics2D;\nimport java.awt.MouseInfo;\nimport java.awt.Point;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.Random;\n\nimport javax.imageio.ImageIO;\n\npublic class Bullet {\n    public double x, y;\n    int k = 0;\n    public boolean isReached = false;\n    public double speed = 4; // Mermi hızı\n    public double dx, dy; // Hareket yönü\n    private BufferedImage image;\n    GamePanel gp;\n    public double Max_spread;\n\n    public Bullet(int x, int y, GamePanel gp) {\n        Max_spread = Math.toRadians(gp.silah.Sapma_Açisi);\n        this.x = x;\n        this.y = y;\n        this.gp = gp;\n        Point mousePoint = MouseInfo.getPointerInfo().getLocation();\n        Point windowPoint = gp.getLocationOnScreen();\n        int targetX = mousePoint.x - windowPoint.x;\n        int targetY = mousePoint.y - windowPoint.y;\n        double angle = Math.atan2(targetY - y, targetX - x);\n        Random random = new Random();\n        double spread = (random.nextDouble() * 2 - 1) * Max_spread;\n        angle += spread;\n        dx = Math.cos(angle) * speed;\n        dy = Math.sin(angle) * speed;\n        getImage();\n\n    }\n\n    public void getImage() {\n        if (gp.player.direction.equals(\"up\")) {\n            try {\n                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\bullet\\\\bullet_up.png\"));\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        } else if (gp.player.direction.equals(\"down\")) {\n            try {\n                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\bullet\\\\bullet_down.png\"));\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        if (gp.player.direction.equals(\"right\")) {\n            try {\n                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\bullet\\\\bullet_right.png\"));\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        if (gp.player.direction.equals(\"left\")) {\n            try {\n                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\bullet\\\\bullet_left.png\"));\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void tick() {\n        x += dx;\n\n        y += dy;\n        for (int i = 0; i < gp.myZombis.size(); i++) {\n            int zombix = gp.myZombis.get(i).x;\n            int zombiy = gp.myZombis.get(i).y;\n            int zombieScreenX = zombix - gp.player.worldX + gp.player.screenX;\n            int zombieScreenY = zombiy - gp.player.worldY + gp.player.screenY;\n            if (gp.myZombis.get(i).shooted == false) {\n                if (Math.abs(x - zombieScreenX) < 20 && Math.abs(y - zombieScreenY) < 20) {\n                    gp.myZombis.get(i).can--;\n                    k = i;\n                    if (gp.silah.name.equals(\"roketatar\")) {\n                        gp.playSe(13);\n                        gp.boomX = zombieScreenX;\n                        gp.boomY = zombieScreenY;\n                        gp.patladi = true;\n                        for (int j = 0; j < gp.myZombis.size(); j++) {\n                            zombix = gp.myZombis.get(j).x;\n                            zombiy = gp.myZombis.get(j).y;\n                            zombieScreenX = zombix - gp.player.worldX + gp.player.screenX;\n                            zombieScreenY = zombiy - gp.player.worldY + gp.player.screenY;\n                            if (Math.abs(x - zombieScreenX) < 50 && Math.abs(y - zombieScreenY) < 50) {\n                                gp.myZombis.get(j).oldDirection = gp.myZombis.get(j).situation;\n                                gp.myZombis.get(j).can = 0;\n                                if (gp.myZombis.get(j).can < 1) {\n                                    gp.myZombis.get(j).situation = \"dead\";\n                                } else {\n                                    gp.myZombis.get(j).situation = \"hurt\";\n                                }\n                                gp.myZombis.get(j).shooted = true;\n                                isReached = true;\n\n                            }\n                        }\n                    } else {\n                        gp.myZombis.get(i).oldDirection = gp.myZombis.get(i).situation;\n                        if (gp.myZombis.get(i).can < 1) {\n                            gp.myZombis.get(i).situation = \"dead\";\n                        } else {\n                            gp.myZombis.get(i).situation = \"hurt\";\n                        }\n                        gp.myZombis.get(i).shooted = true;\n                        isReached = true;\n                        break;\n                    }\n                }\n                new Thread(() -> {\n                    try {\n                        Thread.sleep(1000);\n                        gp.myZombis.get(k).shooted = false;\n                    } catch (Exception e) {\n                        // TODO: handle exception\n                    }\n                }).start();\n            }\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        tick();\n        g2.drawImage(image, (int) x, (int) y, null);\n    }\n\n}\n",
      "Tile.java": "import java.awt.image.BufferedImage;\n\npublic class Tile {\n    public BufferedImage image;\n    public boolean collision = false;\n}\n",
      "Zombi.java": "import java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.util.Random;\n\npublic abstract class Zombi {\n    public int can;\n    public int Hiz = 1;\n    public int Hasar;\n    public BufferedImage image;\n    public String oldDirection;\n    public GamePanel gp;\n    public String yon, name;\n    public boolean shooted = false;\n    public String direction = \"left\";\n    String situation = \"walk\";\n    public int x, y, z = 0, Fps, t = 0, h = 0, d = 0;\n\n    public void update() {\n        int playerX = gp.player.worldX;\n        int playerY = gp.player.worldY;\n        int dx = playerX - x;\n        int dy = playerY - y;\n        if (x < playerX) {\n            direction = \"right\";\n        }\n        if (x > playerX) {\n            direction = \"left\";\n        }\n        if (!situation.equals(\"hurt\") && !situation.equals(\"dead\")) {\n            if (Math.abs(dx) < 2 && Math.abs(dy) < 2) {\n                oldDirection = situation;\n                situation = \"attack\";\n            } else {\n                oldDirection = situation;\n                situation = \"walk\";\n            }\n        }\n        if (x > playerX) {\n            if (y > playerY) {\n                y -= Hiz;\n            } else if (y < playerY) {\n                y += Hiz;\n            }\n            x -= Hiz;\n        }\n        if (x < playerX) {\n            if (y > playerY) {\n                y -= Hiz;\n            } else if (y < playerY) {\n                y += Hiz;\n            }\n            x += Hiz;\n        }\n        if (x == playerX) {\n            if (y > playerY) {\n                y -= Hiz;\n            } else if (y < playerY) {\n                y += Hiz;\n            }\n\n        }\n        Fps++;\n        if (Fps % 8 == 0) {\n            if (situation.equals(\"walk\")) {\n                z++;\n\n                if (z == 10) {\n                    z = 0;\n                }\n            }\n            if (situation.equals(\"hurt\")) {\n                h++;\n                if (h == 6) {\n                    h = 0;\n                    oldDirection = situation;\n                    situation = \"walk\";\n\n                }\n            }\n\n            if (situation.equals(\"attack\")) {\n                t++;\n                if (t == 6) {\n                    gp.player.can -= Hasar;\n                    System.out.println(\"Canın gidiyor.Kalan can:\" + gp.player.can);\n                    t = 0;\n                }\n            }\n            if (situation.equals(\"dead\")) {\n                d++;\n                if (d == 8) {\n                    if (name.equals(\"asit zombisi\")\n                            && (Math.abs(x - gp.player.worldX) < 20 && Math.abs(y - gp.player.worldY) < 20)) {\n                        System.out.println(\"asit zombisi yanında öldü al sana bombe\");\n                        gp.player.can -= 3;\n                    }\n                    situation = \"tam ölü\";\n                }\n            }\n\n        }\n\n    }\n\n    public Zombi(GamePanel gp) {\n        this.gp = gp;\n        randomLocation();\n    }\n\n    public void randomLocation() {\n\n        Random generator = new Random();\n        int spawnRange = 10;\n        x = (gp.player.worldX / gp.tileSize + generator.nextInt(spawnRange * 2) - spawnRange) * gp.tileSize;\n        y = (gp.player.worldY / gp.tileSize + generator.nextInt(spawnRange * 2) - spawnRange) * gp.tileSize;\n\n        System.out.println(\"Zombi doğdu! Konum: \" + x + \", \" + y);\n\n    }\n\n    public void getImage() {\n\n    }\n\n    public void draw(Graphics2D g2) {\n        update();\n        getImage();\n        int screenX = x - gp.player.worldX + gp.player.screenX;\n        int screenY = y - gp.player.worldY + gp.player.screenY;\n\n        if (screenX + gp.tileSize > 0 && screenX < gp.screenWidth &&\n                screenY + gp.tileSize > 0 && screenY < gp.screenHeight) {\n            g2.drawImage(image, screenX, screenY, gp.tileSize, gp.tileSize, null);\n        }\n\n    }\n}\n",
      "Main.java": "import javax.swing.JFrame;\n\npublic class Main {\n    public static void main(String[] args) {\n        JFrame window = new JFrame(\"My game\");\n        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        window.setResizable(false);\n        GamePanel gamePanel;\n\n        gamePanel = new GamePanel();\n        window.add(gamePanel);\n        window.pack();\n        window.setLocationRelativeTo(null);\n        window.setVisible(true);\n        gamePanel.startGameThread();\n\n    }\n}\n",
      "SuperObject.java": "import java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\n\npublic class SuperObject {\n    public BufferedImage image;\n    public String name;\n    public boolean collision = false;\n    public int worldX, worldY;\n\n    public void draw1(Graphics2D g2, GamePanel gp) {\n        int screenx = worldX - gp.player.worldX + gp.player.screenX;\n        int screeny = worldY - gp.player.worldY + gp.player.screenY;\n        g2.drawImage(image, screenx, screeny, gp.tileSize, gp.tileSize, null);\n\n        if (worldX + gp.tileSize > gp.player.worldX - gp.player.screenX &&\n                worldX - gp.tileSize < gp.player.worldX + gp.player.screenX &&\n                worldY + gp.tileSize > gp.player.worldY - gp.player.screenY &&\n                worldY - gp.tileSize < gp.player.worldY + gp.player.screenY) {\n            g2.drawImage(image, screenx, screeny, gp.tileSize, gp.tileSize, null);\n        }\n    }\n}\n",
      "Controller.java": "import java.awt.Graphics2D;\nimport java.util.LinkedList;\n\npublic class Controller {\n    LinkedList<Bullet> b = new LinkedList<>();\n    LinkedList<Bullet> bullets = new LinkedList<>();\n    LinkedList<zombi_asidi> asits = new LinkedList<>();\n    Bullet tempBullet;\n    public GamePanel gp;\n\n    public Controller(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    public void tick() {\n        for (int i = 0; i < b.size(); i++) {\n            tempBullet = b.get(i);\n            tempBullet.tick();\n        }\n    }\n\n    public void fireShotgun(int x, int y) {\n        int pelletCount = 9; // 9 mermi\n        double spreadAngle = Math.toRadians(5); // 5 derece açılarla yayılım\n        double baseAngle = 0;\n        boolean isvertical = false;\n        switch (gp.player.direction) {\n            case \"up\":\n                baseAngle = Math.toRadians(-90);\n                isvertical = true;\n                break;\n            case \"down\":\n                baseAngle = Math.toRadians(90);\n                isvertical = true;\n                break;\n            case \"left\":\n                baseAngle = Math.toRadians(240);\n                break;\n            case \"right\":\n                baseAngle = Math.toRadians(60);\n                break;\n        }\n        for (int i = 0; i < pelletCount; i++) {\n            double angleOffset = spreadAngle * (i - pelletCount / 2);\n            Bullet bullet = new Bullet(x, y, gp);\n            if (isvertical) {\n                bullet.dx = Math.sin(baseAngle + angleOffset) * bullet.speed;\n                bullet.dx = Math.cos(baseAngle + angleOffset) * bullet.speed;\n                add(bullet);\n            } else {\n                bullet.dx = Math.cos(baseAngle + angleOffset) * bullet.speed;\n                bullet.dx = Math.sin(baseAngle + angleOffset) * bullet.speed;\n                add(bullet);\n            }\n\n        }\n    }\n\n    public void add(Bullet bullet) {\n        b.add(bullet);\n    }\n\n    public void draw(Graphics2D g2) {\n        for (int i = 0; i < b.size(); i++) {\n            if (b.get(i) != null) {\n                tempBullet = b.get(i);\n                tempBullet.tick();\n                tempBullet.draw(g2);\n            }\n        }\n    }\n}",
      "zombi_asidi.java": "import java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\n\npublic class zombi_asidi extends Bullet {\n    BufferedImage image;\n    public int fps = 0;\n\n    public zombi_asidi(GamePanel gp) {\n        super(gp.player.screenX, gp.player.screenY, gp);\n    }\n\n    public void getImage() {\n        try {\n            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\bullet\\\\1743159763819.png\"));\n        } catch (Exception e) {\n            // TODO: handle exception\n        }\n    }\n\n    public void tick() {\n        y += 5;\n        fps++;\n    }\n\n    public void draw(Graphics2D g2) {\n        tick();\n        if (fps < 14) {\n            if (y < gp.player.screenY + 20) {\n                getImage();\n                g2.drawImage(image, (int) x, (int) y, 40, 40, null);\n            } else {\n                y -= 10;\n                getImage();\n                g2.drawImage(image, (int) x, (int) y, 40, 40, null);\n            }\n        }\n\n    }\n}\n",
      "Sound.java": "\nimport java.net.URL;\n\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\n\npublic class Sound {\n    Clip clip;\n    Clip effectClip;\n    URL[] soundUrl = new URL[20];\n\n    public Sound() {\n        soundUrl[0] = getClass().getResource(\"sound\\\\arkaplan4.wav\");\n        soundUrl[1] = getClass().getResource(\"sound\\\\arkaplan1.wav\");\n        soundUrl[2] = getClass().getResource(\"sound\\\\arkaplan3.wav\");\n        soundUrl[3] = getClass().getResource(\"sound\\\\arkaplan2.wav\");\n        soundUrl[4] = getClass().getResource(\"sound\\\\tabanca.wav\");\n        soundUrl[5] = getClass().getResource(\"sound\\\\tabancareload.wav\");\n        soundUrl[6] = getClass().getResource(\"sound\\\\ak47.wav\");\n        soundUrl[7] = getClass().getResource(\"sound\\\\Ak-47reload.wav\");\n        soundUrl[8] = getClass().getResource(\"sound\\\\pompalı.wav\");\n        soundUrl[9] = getClass().getResource(\"sound\\\\pompalıreload.wav\");\n        soundUrl[10] = getClass().getResource(\"sound\\\\sniper.wav\");\n        soundUrl[11] = getClass().getResource(\"sound\\\\sniperreload.wav\");\n        soundUrl[12] = getClass().getResource(\"sound\\\\roketsıkma.wav\");\n        soundUrl[13] = getClass().getResource(\"sound\\\\roketpatlama.wav\");\n        soundUrl[14] = getClass().getResource(\"sound\\\\zombiyürüme.wav\");\n        soundUrl[15] = getClass().getResource(\"sound\\\\zombiyeme.wav\");\n        soundUrl[16] = getClass().getResource(\"sound\\\\boşŞarjör.wav\");\n\n    }\n\n    public void setFile(int i) {\n        stop(); // Önce eski sesi tamamen durdur\n\n        try {\n            AudioInputStream ais = AudioSystem.getAudioInputStream(soundUrl[i]);\n            clip = AudioSystem.getClip(); // Yeni bir clip oluştur\n            clip.open(ais);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void setEffectFile(int i) {\n        try {\n            AudioInputStream ais = AudioSystem.getAudioInputStream(soundUrl[i]);\n            effectClip = AudioSystem.getClip(); // Yeni bir clip oluştur\n            effectClip.open(ais);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void play() {\n        clip.start();\n    }\n\n    public void playEffect() {\n        effectClip.start();\n    }\n\n    public void loop() {\n        clip.loop(Clip.LOOP_CONTINUOUSLY);\n    }\n\n    public void stop() {\n        if (clip != null) {\n            clip.stop();\n            clip.flush();\n            clip.close();\n            clip = null; // Belleği serbest bırak\n        }\n    }\n\n}\n",
      "PiyadeTüfek.java": "public class PiyadeTüfek extends Silahlar {\n    public PiyadeTüfek(GamePanel gp) {\n        super(gp);\n        this.Ateş_Hizi = 600;\n        this.maxŞarjör = 30;\n        this.Şarjör_kapasite = 30;\n        this.Sapma_Açisi = 0;\n        this.Şarjör_Sayisi = 6;\n        this.name = \"ak-47\";\n    }\n}\n",
      "MyBullet.java": "\npublic class MyBullet extends Bullet {\n    public MyBullet(int x, int y, GamePanel gp) throws Exception {\n\n        super(x, y, gp);\n    }\n}\n",
      "GamePanel.java": "import java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JPanel;\n\npublic class GamePanel extends JPanel implements Runnable, MouseListener {\n    final int originalTileSize = 16;\n    final int scale = 3;\n    public final int tileSize = scale * originalTileSize;\n    public Controller c;\n    public final int maxColumn = 16;\n    public final int maxRow = 12;\n\n    public final int screenWidth = tileSize * maxColumn;\n    public final int screenHeight = tileSize * maxRow;\n\n    ArrayList<Zombi> myZombis = new ArrayList<>();\n    // world map parameter\n    int roket = 0;\n    public final int maxWorldCol = 50;\n    public final int maxWorldRow = 50;\n    KeyHandler ky = new KeyHandler(this);\n    int FPSzombi = 10;\n    int Fpsscale = 2;\n    Silahlar silah = new Tabanca(this);\n    public int boomX, boomY;\n    public boolean patladi = false;\n    int FPS = 60 * Fpsscale;\n    Sound sound = new Sound();\n    int asama = 0;\n    TileManager tile = new TileManager(this);\n    Thread gameThread;\n    public AssetSetter aSetter = new AssetSetter(this);\n    Player player = new Player(this, ky);\n    Collision_Checker collision_Checker = new Collision_Checker(this);\n    SuperObject[] obj = new SuperObject[1];\n\n    public void setGame() {\n        if (asama == 0) {\n            player.getPlayerImage();\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Asit_Zombisi(this));\n            playMusic(0);\n        } else if (asama == 1) {\n            player.getPlayerImage();\n            silah = new PiyadeTüfek(this);\n            myZombis.add(new Normal_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            myZombis.add(new Normal_Zombi(this));\n            myZombis.add(new Normal_Zombi(this));\n            playMusic(0);\n\n        } else if (asama == 2) {\n            player.getPlayerImage();\n            myZombis.add(new Tank_Zombi(this));\n            myZombis.add(new Normal_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            myZombis.add(new Tank_Zombi(this));\n            myZombis.add(new Normal_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            playMusic(0);\n\n        } else if (asama == 3) {\n            player.getPlayerImage();\n            silah = new pompali(this);\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Tank_Zombi(this));\n            myZombis.add(new Normal_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            playMusic(1);\n\n        } else if (asama == 4) {\n            player.getPlayerImage();\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Tank_Zombi(this));\n            myZombis.add(new Normal_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            playMusic(1);\n\n        } else if (asama == 5) {\n            player.getPlayerImage();\n            silah = new Sniper(this);\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Tank_Zombi(this));\n            myZombis.add(new Normal_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            playMusic(1);\n\n        } else if (asama == 6) {\n            player.getPlayerImage();\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Tank_Zombi(this));\n            myZombis.add(new Normal_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            playMusic(2);\n\n        } else if (asama == 7) {\n            player.getPlayerImage();\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Tank_Zombi(this));\n            myZombis.add(new Normal_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            playMusic(2);\n\n        } else if (asama == 8) {\n            player.getPlayerImage();\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Tank_Zombi(this));\n            myZombis.add(new Normal_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            playMusic(2);\n\n        } else if (asama == 9) {\n            player.getPlayerImage();\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Tank_Zombi(this));\n            myZombis.add(new Normal_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            playMusic(3);\n\n        } else if (asama == 10) {\n            player.getPlayerImage();\n            silah = new RoketAtar(this);\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Tank_Zombi(this));\n            myZombis.add(new Normal_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            playMusic(3);\n\n        } else if (asama == 11) {\n            player.getPlayerImage();\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Asit_Zombisi(this));\n            myZombis.add(new Tank_Zombi(this));\n            myZombis.add(new Normal_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            myZombis.add(new Surungen_Zombi(this));\n            playMusic(3);\n\n        } else {\n            System.out.println(\"oyun bitti\");\n            System.exit(0);\n        }\n        asama++;\n    }\n\n    public void finished(int asama) {\n        setGame();\n    }\n\n    public BufferedImage roketatar() {\n        BufferedImage image = null;\n        try {\n            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\bullet\\\\1743148672724.png\"));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return image;\n    }\n\n    public GamePanel() {\n        this.setPreferredSize(new Dimension(screenWidth, screenHeight));\n        this.setBackground(Color.BLACK);\n        this.setDoubleBuffered(true);\n        this.addKeyListener(ky);\n        this.addMouseListener(this);\n        this.addMouseMotionListener(player.listener);\n        this.setFocusable(true);\n        setGame();\n        try {\n            c = new Controller(this);\n        } catch (Exception e) {\n            // TODO: handle exception\n        }\n    }\n\n    public void setUpGame(int i) {\n        aSetter.setObject();\n        playMusic(i);\n    }\n\n    public void startGameThread() {\n        gameThread = new Thread(this);\n        gameThread.start();\n\n    }\n\n    @Override\n    public void run() {\n        double drawInterwal = 1000000000 / 45;\n        double nextDrawTime = System.nanoTime() + drawInterwal;\n        while (gameThread != null) {\n            update();\n            repaint();\n            try {\n                double remainingTime = nextDrawTime - System.nanoTime();\n                remainingTime = remainingTime / 1000000;\n                if (remainingTime < 0) {\n                    remainingTime = 0;\n                }\n\n                Thread.sleep((long) remainingTime);\n\n                nextDrawTime += drawInterwal;\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n\n    public void update() {\n        player.update();\n        for (int i = 0; i < c.b.size(); i++) {\n            if (c.b.get(i) != null) {\n                c.b.get(i).tick();\n                if (c.b.get(i).x < 0 || c.b.get(i).x > screenWidth ||\n                        c.b.get(i).y < 0 || c.b.get(i).y > screenHeight) {\n                    c.b.remove(i);\n                }\n            }\n        }\n    }\n\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        roket++;\n\n        Graphics2D g2 = (Graphics2D) g;\n        Graphics2D g3 = (Graphics2D) g;\n        // Tile\n        tile.draw(g2);\n        // object\n        for (int i = 0; i < obj.length; i++) {\n            if (obj[i] != null) {\n                obj[i].draw1(g2, this);\n            }\n        }\n        // player\n        if (player.can > 0) {\n            player.draw(g3);\n        } else {\n            System.out.println(\"ulan nasıl öldün\");\n            System.exit(0);\n        }\n        // zombi\n        for (int i = 0; i < myZombis.size(); i++) {\n            if (!myZombis.get(i).situation.equals(\"tam ölü\")) {\n                myZombis.get(i).draw(g2);\n            } else {\n                myZombis.remove(i);\n                if (myZombis.size() == 0) {\n                    finished(asama);\n                }\n            }\n        }\n\n        if (patladi) {\n            g2.drawImage(roketatar(), boomX, boomY, 100, 100, null);\n        }\n        if (roket % 72 == 0) {\n            patladi = false;\n        }\n        // bullet\n        if (!silah.name.equals(\"sniper\")) {\n            for (int i = 0; i < c.b.size(); i++) {\n                if (c.b.get(i) instanceof zombi_asidi) {\n                    c.b.get(i).draw(g2);\n                } else if (c.b.get(i) != null && !c.b.get(i).isReached) {\n                    c.draw(g2);\n                }\n            }\n        } else {\n            for (int i = 0; i < c.b.size(); i++) {\n                if (c.b.get(i) != null) {\n                    c.b.get(i).draw(g2);\n                }\n            }\n        }\n\n        g2.dispose();\n    }\n\n    public void playMusic(int i) {\n        sound.setFile(i);\n        sound.play();\n        sound.loop();\n    }\n\n    public void stopMusic() {\n        sound.stop();\n    }\n\n    public void playSe(int i) {\n        sound.setEffectFile(i);\n        sound.playEffect();\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        if (!silah.name.equals(\"pompali\")) {\n            if (silah.Şarjör_kapasite > 0) {\n                try {\n                    c.add(new Bullet(player.screenX, player.screenY, this));\n                    silah.Şarjör_kapasite--;\n                    if (asama < 2) {\n                        this.playSe(4);\n                        System.out.println(\"burdayım be\");\n                    } else if (asama < 4) {\n                        System.out.println(\"niye burdayım ki\");\n                        this.playSe(6);\n                    } else if (asama < 6) {\n                        this.playSe(8);\n                    } else if (asama < 11) {\n                        this.playSe(10);\n                    } else {\n                        this.playSe(12);\n                    }\n                } catch (Exception e1) {\n                    // TODO Auto-generated catch block\n                    e1.printStackTrace();\n                }\n            } else {\n                this.playSe(16);\n            }\n        } else {\n            if (silah.Şarjör_kapasite > 0) {\n                try {\n                    c.fireShotgun(this.player.screenX, this.player.screenY);\n                    silah.Şarjör_kapasite--;\n                    if (asama < 2) {\n                        this.playSe(4);\n                    } else if (asama < 4) {\n                        this.playSe(6);\n                    } else if (asama < 6) {\n                        this.playSe(8);\n                    } else if (asama < 11) {\n                        this.playSe(10);\n                    } else {\n                        this.playSe(12);\n                    }\n                } catch (Exception e1) {\n                    // TODO Auto-generated catch block\n                    e1.printStackTrace();\n                }\n            } else {\n                this.playSe(16);\n            }\n        }\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e) {\n\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e) {\n\n    }\n}\n",
      "Collision_Checker.java": "public class Collision_Checker {\n    GamePanel gp;\n\n    public Collision_Checker(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    public void checkTile(Entity entity) {\n        int entityLeftWorldX = entity.worldX + entity.solidArea.x;\n        int entityRightWorldX = entity.worldX + entity.solidArea.x + entity.solidArea.width;\n        int entityTopWorldY = entity.worldY + entity.solidArea.y;\n        int entityBottomWorldY = entity.worldY + entity.solidArea.y + entity.solidArea.height;\n        int entityLeftCol = entityLeftWorldX / gp.tileSize;\n        int entityRightCol = entityRightWorldX / gp.tileSize;\n        int entityTopRow = entityTopWorldY / gp.tileSize;\n        int entityRowBottom = entityBottomWorldY / gp.tileSize;\n        int tilenum1, tilenum2;\n        switch (entity.direction) {\n            case \"up\":\n                entityTopRow = (entityTopWorldY - entity.speed) / gp.tileSize;\n                tilenum1 = gp.tile.mapTileNum[entityLeftCol][entityTopRow];\n                tilenum2 = gp.tile.mapTileNum[entityRightCol][entityTopRow];\n                if (gp.tile.tile[tilenum1].collision || gp.tile.tile[tilenum2].collision) {\n                    entity.collisionOn = true;\n                }\n                break;\n\n            case \"right\":\n                entityRightCol = (entityRightWorldX - entity.speed) / gp.tileSize;\n                tilenum1 = gp.tile.mapTileNum[entityRightCol][entityTopRow];\n                tilenum2 = gp.tile.mapTileNum[entityRightCol][entityRowBottom];\n                if (gp.tile.tile[tilenum1].collision || gp.tile.tile[tilenum2].collision) {\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"left\":\n                entityLeftCol = (entityLeftWorldX - entity.speed) / gp.tileSize;\n                tilenum1 = gp.tile.mapTileNum[entityLeftCol][entityTopRow];\n                tilenum2 = gp.tile.mapTileNum[entityLeftCol][entityRowBottom];\n                if (gp.tile.tile[tilenum1].collision || gp.tile.tile[tilenum2].collision) {\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"down\":\n                entityRowBottom = (entityBottomWorldY + entity.speed) / gp.tileSize;\n                tilenum1 = gp.tile.mapTileNum[entityLeftCol][entityRowBottom];\n                tilenum2 = gp.tile.mapTileNum[entityRightCol][entityRowBottom];\n                if (gp.tile.tile[tilenum1].collision || gp.tile.tile[tilenum2].collision) {\n                    entity.collisionOn = true;\n                }\n                break;\n        }\n    }\n}\n",
      "Mouse_Handler.java": "import java.awt.event.MouseEvent;\nimport java.awt.event.MouseMotionListener;\n\npublic class Mouse_Handler implements MouseMotionListener {\n    GamePanel gp;\n    public int x, y;\n\n    public Mouse_Handler(GamePanel gp) {\n        this.gp = gp;\n\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        // TODO Auto-generated method stub\n        throw new UnsupportedOperationException(\"Unimplemented method 'mouseDragged'\");\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        x = e.getX();\n        y = e.getY();\n    }\n\n}\n",
      "AssetSetter.java": "\npublic class AssetSetter {\n    public GamePanel gp;\n\n    public AssetSetter(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    public void setObject() {\n        gp.obj[0] = new OBJ_Key();\n        gp.obj[0].worldX = 23 * gp.tileSize;\n        gp.obj[0].worldY = 7 * gp.tileSize;\n    }\n}\n",
      "KeyHandler.java": "import java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\npublic class KeyHandler implements KeyListener {\n    public boolean upPressed, downPressed, leftPressed, rightPressed;\n    public GamePanel gp;\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n    }\n\n    public KeyHandler(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int code = e.getKeyCode();\n        if (code == KeyEvent.VK_W) {\n            upPressed = true;\n        }\n        if (code == KeyEvent.VK_A) {\n            leftPressed = true;\n        }\n        if (code == KeyEvent.VK_S) {\n            downPressed = true;\n        }\n        if (code == KeyEvent.VK_D) {\n            rightPressed = true;\n        }\n        if (code == KeyEvent.VK_R) {\n            try {\n                if (gp.silah.Şarjör_Yenile()) {\n                    if (gp.asama < 2) {\n                        gp.playSe(5);\n                    } else if (gp.asama < 4) {\n                        gp.playSe(7);\n                    } else if (gp.asama < 6) {\n                        gp.playSe(9);\n                    } else if (gp.asama < 11) {\n                        gp.playSe(11);\n                    } else {\n                        gp.playSe(9);\n                    }\n                } else {\n                    System.out.println(\"şarjörün kalmadı ölümü bekle\");\n                }\n            } catch (Exception e1) {\n                // TODO Auto-generated catch block\n\n            }\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int code = e.getKeyCode();\n        if (code == KeyEvent.VK_W) {\n            upPressed = false;\n        }\n        if (code == KeyEvent.VK_A) {\n            leftPressed = false;\n        }\n        if (code == KeyEvent.VK_S) {\n            downPressed = false;\n        }\n        if (code == KeyEvent.VK_D) {\n            rightPressed = false;\n        }\n\n    }\n\n}\n",
      "pompali.java": "public class pompali extends Silahlar {\n    public pompali(GamePanel gp) {\n        super(gp);\n        this.Ateş_Hizi = 60;\n        this.maxŞarjör = 5;\n        this.Şarjör_kapasite = 5;\n        this.Sapma_Açisi = 45;\n        this.Şarjör_Sayisi = 5;\n        this.name = \"pompali\";\n    }\n}\n",
      "Surungen_Zombi.java": "import java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class Surungen_Zombi extends Zombi {\n    public Surungen_Zombi(GamePanel gp) {\n        super(gp);\n        this.can = 2;\n        this.name = \"sürüngen zombi\";\n        this.Hasar = 2;\n        this.Hiz = 1;\n    }\n\n    public void getImage() {\n        if (situation.equals(\"walk\")) {\n            try {\n                if (direction.equals(\"left\")) {\n                    switch (z) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol1.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol1.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol1.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol1.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol1.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol2.png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol2.png\"));\n                            break;\n                        case 7:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol2.png\"));\n                            break;\n                        case 8:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol2.png\"));\n                            break;\n                        case 9:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol2.png\"));\n                            break;\n                    }\n                } else {\n                    switch (z) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ2.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ1.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ2.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ1.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ2.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ1.png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ2.png\"));\n                            break;\n                        case 7:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ1.png\"));\n                            break;\n                        case 8:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ2.png\"));\n                            break;\n                        case 9:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ1.png\"));\n                            break;\n                    }\n                }\n            } catch (Exception e) {\n\n            }\n        } else if (situation.equals(\"attack\")) {\n            if (direction.equals(\"left\")) {\n                try {\n                    switch (t) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump1 (1).png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump2 (1).png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump3 (1).png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump4 (1).png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump5 (1).png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump6 (1).png\"));\n                            break;\n\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            } else {\n                try {\n                    switch (t) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump1.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump2.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump3.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump4.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump5.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump6.png\"));\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            }\n\n        } else if (situation.equals(\"dead\")) {\n            if (direction.equals(\"right\")) {\n\n                try {\n                    switch (d) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead6.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead6.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead7.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead7.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead7.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead8.png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead8.png\"));\n                            break;\n                        case 7:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead8.png\"));\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            } else {\n                try {\n                    switch (d) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead6 (1).png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead6 (1).png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead7 (1).png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead7 (1).png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead7 (1).png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead7 (1).png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead8 (1).png\"));\n                            break;\n                        case 7:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Dead8 (1).png\"));\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            }\n        } else if (situation.equals(\"hurt\")) {\n            if (oldDirection.equals(\"walk\")) {\n                if (direction.equals(\"left\")) {\n                    try {\n                        switch (z) {\n                            case 0:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol1.png\"));\n                                break;\n                            case 1:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol1.png\"));\n                                break;\n                            case 2:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol1.png\"));\n                                break;\n                            case 3:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol1.png\"));\n                                break;\n                            case 4:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol1.png\"));\n                                break;\n                            case 5:\n                                shooted = false;\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol2.png\"));\n                                break;\n                            case 6:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol2.png\"));\n                                break;\n                            case 7:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol2.png\"));\n                                break;\n                            case 8:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol2.png\"));\n                                break;\n                            case 9:\n\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsol2.png\"));\n                                break;\n                        }\n\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                } else {\n                    try {\n                        switch (z) {\n                            case 0:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ2.png\"));\n                                break;\n                            case 1:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ1.png\"));\n                                break;\n                            case 2:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ2.png\"));\n                                break;\n                            case 3:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ1.png\"));\n                                break;\n                            case 4:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ2.png\"));\n                                break;\n                            case 5:\n                                shooted = false;\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ1.png\"));\n                                break;\n                            case 6:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ2.png\"));\n                                break;\n                            case 7:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ1.png\"));\n                                break;\n                            case 8:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ2.png\"));\n                                break;\n                            case 9:\n\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\sürünsağ1.png\"));\n                                break;\n                        }\n                    } catch (Exception e) {\n\n                    }\n                }\n\n            } else if (oldDirection.equals(\"attack\")) {\n                if (direction.equals(\"left\")) {\n                    try {\n                        switch (t) {\n                            case 0:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump1 (1).png\"));\n                                break;\n                            case 1:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump2 (1).png\"));\n                                break;\n                            case 2:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump3 (1).png\"));\n                                break;\n                            case 3:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump4 (1).png\"));\n                                break;\n                            case 4:\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump5 (1).png\"));\n                                break;\n                            case 5:\n                                shooted = false;\n                                image = ImageIO\n                                        .read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump6 (1).png\"));\n                                break;\n\n                        }\n                    } catch (Exception e) {\n                        // TODO: handle exception\n                    }\n                } else {\n                    try {\n                        switch (t) {\n                            case 0:\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump1.png\"));\n                                break;\n                            case 1:\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump2.png\"));\n                                break;\n                            case 2:\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump3.png\"));\n                                break;\n                            case 3:\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump4.png\"));\n                                break;\n                            case 4:\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump5.png\"));\n                                break;\n                            case 5:\n                                shooted = false;\n                                image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi4\\\\Jump6.png\"));\n                                break;\n                        }\n                    } catch (Exception e) {\n                        // TODO: handle exception\n                    }\n                }\n            }\n        }\n    }\n}\n",
      "RoketAtar.java": "public class RoketAtar extends Silahlar {\n    public RoketAtar(GamePanel gp) {\n        super(gp);\n        this.Ateş_Hizi = 10;\n        this.maxŞarjör = 1;\n        this.Şarjör_kapasite = 1;\n        this.Sapma_Açisi = 0;\n        this.Şarjör_Sayisi = 5;\n        this.name = \"roketatar\";\n    }\n}\n",
      "TileManager.java": "import java.awt.Graphics2D;\nimport java.io.InputStream;\nimport java.util.Scanner;\n\nimport javax.imageio.ImageIO;\n\npublic class TileManager {\n    GamePanel gp;\n    Tile[] tile;\n    int[][] mapTileNum;\n\n    TileManager(GamePanel gp) {\n        this.gp = gp;\n        tile = new Tile[4];\n        mapTileNum = new int[gp.maxWorldCol][gp.maxWorldRow];\n        loadmap();\n        getTileImage();\n\n    }\n\n    public void getTileImage() {\n        try {\n            tile[0] = new Tile();\n            tile[0].image = ImageIO.read(getClass().getResourceAsStream(\"\\\\tree\\\\sands\\\\earth.png\"));\n            tile[1] = new Tile();\n            tile[1].image = ImageIO.read(getClass().getResourceAsStream(\"tree\\\\sands\\\\earth.png\"));\n            // tile[1].collision = true;\n            tile[2] = new Tile();\n            tile[2].image = ImageIO.read(getClass().getResourceAsStream(\"tree\\\\sands\\\\sand.png\"));\n            // tile[2].collision = true;\n            tile[3] = new Tile();\n            tile[3].image = ImageIO.read(getClass().getResourceAsStream(\"tree\\\\sands\\\\sand.png\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void loadmap() {\n        try {\n            InputStream is = this.getClass().getResourceAsStream(\"tree\\\\map\\\\harita.txt\");\n            Scanner br = new Scanner(is);\n            int col = 0;\n            int row = 0;\n            while (col < gp.maxWorldCol && row < gp.maxWorldRow) {\n                String line = br.nextLine();\n                while (col < gp.maxWorldCol) {\n                    String[] numbers = line.split(\" \");\n                    int num = Integer.parseInt(numbers[col]);\n                    mapTileNum[col][row] = num;\n                    col++;\n\n                }\n                if (col == gp.maxWorldCol) {\n                    col = 0;\n                    row++;\n                }\n            }\n            br.close();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        int worldcol = 0;\n        int worldrow = 0;\n        while (worldcol < gp.maxWorldCol && worldrow < gp.maxWorldRow) {\n            int worldX = worldcol * gp.tileSize;\n            int worldY = worldrow * gp.tileSize;\n            int screeenx = worldX - gp.player.worldX + gp.player.screenX;\n            int screeny = worldY - gp.player.worldY + gp.player.screenY;\n\n            int tilenum = mapTileNum[worldcol][worldrow];\n\n            if (worldX + gp.tileSize > gp.player.worldX - gp.player.screenX &&\n                    worldX - gp.tileSize < gp.player.worldX + gp.player.screenX &&\n                    worldY + gp.tileSize > gp.player.worldY - gp.player.screenY &&\n                    worldY - gp.tileSize < gp.player.worldY + gp.player.screenY) {\n                g2.drawImage(tile[tilenum].image, screeenx, screeny, gp.tileSize, gp.tileSize, null);\n            }\n\n            worldcol++;\n            if (worldcol == gp.maxWorldCol) {\n                worldcol = 0;\n\n                worldrow++;\n\n            }\n\n        }\n\n    }\n}\n",
      "Tank_Zombi.java": "import javax.imageio.ImageIO;\n\npublic class Tank_Zombi extends Zombi {\n    public Tank_Zombi(GamePanel gp) {\n        super(gp);\n        this.name = \"tank zombi\";\n        this.can = 5;\n        this.Hasar = 3;\n        this.Hiz = 1;\n    }\n\n    public void getImage() {\n        if (situation.equals(\"walk\")) {\n            try {\n                if (direction.equals(\"left\")) {\n                    switch (z) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk1 (1).png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk2 (1).png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk3 (1).png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk4 (1).png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk5 (1).png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk6 (1).png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk6 (1).png\"));\n                            z = 0;\n                            break;\n\n                    }\n                } else {\n                    switch (z) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk1.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk2.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk3.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk4.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk5.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk6.png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Walk6.png\"));\n                            z = 0;\n                            break;\n                    }\n                }\n            } catch (Exception e) {\n\n            }\n        } else if (situation.equals(\"attack\")) {\n            if (direction.equals(\"left\")) {\n                try {\n                    switch (t) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack1 (1).png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack2 (1).png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack3 (1).png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack4 (1).png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack5 (1).png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack6 (1).png\"));\n                            break;\n                        case 6:\n                            gp.player.can -= Hasar;\n                            System.out.println(\"Canın gidiyor.Kalan can:\" + gp.player.can);\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack6 (1).png\"));\n                            t = 0;\n                            break;\n\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            } else {\n                try {\n                    switch (t) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack1.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack2.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack3.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack4.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack5.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack6.png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Attack6.png\"));\n                            t = 0;\n                            gp.player.can -= Hasar;\n                            System.out.println(\"Canın gidiyor.Kalan can:\" + gp.player.can);\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            }\n        } else if (situation.equals(\"hurt\")) {\n            if (direction.equals(\"right\")) {\n                try {\n                    switch (h) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Hurt1.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Hurt2.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Hurt3.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Hurt4.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Hurt5.png\"));\n                            break;\n                        case 5:\n                            shooted = false;\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Hurt5.png\"));\n                            break;\n                        case 6:\n\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi\\\\Hurt5.png\"));\n                            break;\n\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            } else {\n                try {\n                    switch (h) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Hurt1 (2).png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Hurt2 (2).png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Hurt3 (2).png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Hurt4 (2).png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Hurt5 (2).png\"));\n                            break;\n                        case 5:\n                            shooted = false;\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Hurt5 (2).png\"));\n                            break;\n                        case 6:\n\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Hurt5 (2).png\"));\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            }\n        } else if (situation.equals(\"dead\")) {\n            if (direction.equals(\"right\")) {\n                try {\n                    switch (d) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead1.png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead2.png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead3.png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead4.png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead5.png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead6.png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead7.png\"));\n                            break;\n                        case 7:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead8.png\"));\n\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            } else {\n                try {\n                    switch (d) {\n                        case 0:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead1 (1).png\"));\n                            break;\n                        case 1:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead2 (1).png\"));\n                            break;\n                        case 2:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead3 (1).png\"));\n                            break;\n                        case 3:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead4 (1).png\"));\n                            break;\n                        case 4:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead5 (1).png\"));\n                            break;\n                        case 5:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead6 (1).png\"));\n                            break;\n                        case 6:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead7 (1).png\"));\n                            break;\n                        case 7:\n                            image = ImageIO.read(getClass().getResourceAsStream(\"res\\\\zombi\\\\zombi3\\\\Dead8 (1).png\"));\n                            break;\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }\n            }\n\n        }\n    }\n}\n",
      "Player.java": "\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseMotionListener;\nimport java.awt.image.BufferedImage;\n\nimport javax.imageio.ImageIO;\n\npublic class Player extends Entity {\n    GamePanel gp;\n    KeyHandler ky;\n    public int can = 100;\n    int yon = 0;\n    double angle;\n    public final int screenX, screenY;\n\n    public Player(GamePanel gp, KeyHandler ky) {\n        this.gp = gp;\n        this.ky = ky;\n        screenX = gp.screenWidth / 2 - (gp.tileSize / 2);\n        screenY = gp.screenHeight / 2 - (gp.tileSize / 2);\n        setDefaultValues();\n        getPlayerImage();\n        solidArea = new Rectangle(10, 10, 10, 10);\n\n    }\n\n    public MouseMotionListener listener = new MouseMotionListener() {\n        int mousex, mousey;\n\n        @Override\n        public void mouseDragged(MouseEvent e) {\n            mousex = e.getX();\n            mousey = e.getY();\n            int dx = gp.player.screenX - mousex;\n            int dy = gp.player.screenY - mousey;\n            angle = Math.atan2(dy, dx);\n        }\n\n        @Override\n        public void mouseMoved(MouseEvent e) {\n            mousex = e.getX();\n            mousey = e.getY();\n            int dx = gp.player.screenX - mousex;\n            int dy = gp.player.screenY - mousey;\n            angle = Math.atan2(dy, dx);\n        }\n\n    };\n\n    public void setDefaultValues() {\n        this.worldX = gp.tileSize * 23;\n        this.worldY = gp.tileSize * 21;\n        this.speed = 4;\n        direction = \"right\";\n    }\n\n    public void getPlayerImage() {\n        try {\n            if (gp.asama < 1) {\n                left1 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (2).png\"));\n                left2 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (2).png\"));\n                right1 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (4).png\"));\n                right2 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (4).png\"));\n            } else if (gp.asama < 3) {\n                left1 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (1).png\"));\n                left2 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (1).png\"));\n                right1 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (5).png\"));\n                right2 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (5).png\"));\n            } else if (gp.asama < 5) {\n                left1 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (3).png\"));\n                left2 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (3).png\"));\n                right1 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (7).png\"));\n                right2 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (7).png\"));\n            } else if (gp.asama < 10) {\n                left1 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Remove background project.png\"));\n                left2 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Remove background project.png\"));\n                right1 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (8).png\"));\n                right2 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (8).png\"));\n            } else {\n                left1 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file.png\"));\n                left2 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file.png\"));\n                right1 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (6).png\"));\n                right2 = ImageIO.read(getClass().getResourceAsStream(\"res\\\\player\\\\Adobe Express - file (6).png\"));\n            }\n\n        } catch (Exception e) {\n            // TODO: handle exception\n        }\n    }\n\n    public void update() {\n        if (ky.upPressed) {\n            direction = \"up\";\n        }\n        if (ky.downPressed == true) {\n            direction = \"down\";\n        }\n        if (ky.rightPressed == true) {\n            direction = \"right\";\n        }\n        if (ky.leftPressed == true) {\n            direction = \"left\";\n        }\n        collisionOn = false;\n        gp.collision_Checker.checkTile(this);\n        if ((ky.rightPressed && collisionOn == false) || (ky.leftPressed && collisionOn == false)\n                || (ky.upPressed && collisionOn == false) || (ky.downPressed && collisionOn == false)) {\n            if (direction.equals(\"up\")) {\n                worldY = worldY - speed;\n            } else if (direction.equals(\"down\")) {\n                worldY += speed;\n            } else if (direction.equals(\"left\")) {\n                worldX -= speed;\n            } else if (direction.equals(\"right\")) {\n                worldX += speed;\n            }\n\n        }\n\n        if (ky.downPressed || ky.leftPressed || ky.rightPressed || ky.upPressed) {\n            sprintCounter++;\n            if (sprintCounter > 5) {\n                if (spriteNum == 1) {\n                    spriteNum = 2;\n                } else if (spriteNum == 2) {\n                    spriteNum = 1;\n                }\n                sprintCounter = 0;\n            }\n\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        BufferedImage image = null;\n        if (direction.equals(\"up\")) {\n            if (yon == 0) {\n                image = right1;\n            } else {\n                image = left1;\n            }\n        }\n        if (direction.equals(\"down\")) {\n            if (yon == 1) {\n                image = left1;\n            } else {\n                image = right1;\n            }\n        }\n        if (direction.equals(\"left\")) {\n            if (spriteNum == 1) {\n                image = left1;\n\n            } else if (spriteNum == 2) {\n                image = left2;\n            }\n            yon = 1;\n        }\n        if (direction.equals(\"right\")) {\n            if (spriteNum == 1) {\n                image = right1;\n            } else if (spriteNum == 2) {\n                image = right2;\n            }\n            yon = 0;\n        }\n        // // Önceki dönüşü kaydet\n        // AffineTransform old = g2.getTransform();\n\n        // // Yeni dönüş matrisi oluştur\n        // AffineTransform transform = new AffineTransform();\n        // transform.translate(screenX + gp.tileSize / 2, screenY + gp.tileSize / 2); //\n        // Karakterin tam merkezini al\n        // transform.rotate(-angle); // Açıyı uygula\n        // transform.translate(-(gp.tileSize / 2), -(gp.tileSize / 2)); // Dönüş\n        // // düzeltme\n        // // Dönüş matrisini uygula\n        // g2.setTransform(transform);\n        // // Karakteri tam olarak screenX, screenY noktasına yerleştirerek çiz\n        // g2.drawImage(image, 0, 0, gp.tileSize + 24, gp.tileSize + 24, null);\n        // // Önceki dönüş ayarını geri yükle\n        // g2.setTransform(old);\n        g2.drawImage(image, screenX, screenY, gp.tileSize, gp.tileSize, null);\n\n    }\n}\n",
      "OBJ_Key.java": "import java.awt.Graphics2D;\n\nimport javax.imageio.ImageIO;\n\npublic class OBJ_Key extends SuperObject {\n    public OBJ_Key() {\n        name = \"key\";\n        try {\n            image = ImageIO.read(getClass().getResourceAsStream(\"object\\\\chest.png\"));\n        } catch (Exception e) {\n            System.out.println(\"f\");\n        }\n    }\n\n    public void draw(Graphics2D g2, GamePanel gp) {\n        g2.drawImage(image, worldX, worldY, gp.tileSize, gp.tileSize, null);\n    }\n}\n"
    },
    {
      "id": "1762204",
      "Sniper.java": "import java.io.File;\n\npublic class Sniper extends Weapon {\n    public Sniper() {\n        super(0, 0, 55, 0, 60, 10, \"assets/WeaponSounds/Firing/sniper.wav\", \"assets/WeaponSounds/Reload/sniper.wav\");\n        this.appearanceImagePath = \"assets/Weapons/sniper.png\";\n        setImage(new File(appearanceImagePath));\n    }\n}\n",
      "GameOverPanel.java": "import java.awt.AlphaComposite;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.FontMetrics;\nimport java.awt.RenderingHints;\nimport java.awt.Image;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport javax.swing.JButton;\nimport javax.swing.JLabel;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.SwingConstants;\n\npublic class GameOverPanel extends JPanel {\n    private GameInfo gameInfo;\n    private final int PANEL_WIDTH = GameFrame.WIDTH;\n    private final int PANEL_HEIGHT = GameFrame.HEIGHT;\n    private Image backgroundImage;\n\n    private String scoreText = \"You survived %d waves, killed %d zombies and scored %d points\";\n    private String restartGameText = \"Play Again\";\n    private String loadSaveText = \"Resume from Last Save\";\n    private String exitGameText = \"Exit Game\";\n    private JLabel gameOverLabel;\n    private JLabel scoreLabel;\n    private JButton restartButton;\n    private JButton loadSaveButton;\n    private JButton exitButton;\n\n    public GameOverPanel(GameInfo gameInfo) {\n        this.gameInfo = gameInfo;\n        setPreferredSize(new Dimension(PANEL_WIDTH, PANEL_HEIGHT));\n        setLayout(null);\n        setVisible(false);\n        \n        if (gameInfo.backgroundImage != null) {\n            backgroundImage = gameInfo.backgroundImage;\n        } else {\n            setBackground(new Color(32, 32, 32));\n        }\n\n        // Game Over text with shadow effect\n        gameOverLabel = new JLabel(\"GAME OVER\") {\n            @Override\n            protected void paintComponent(Graphics g) {\n                Graphics2D g2d = (Graphics2D) g.create();\n                g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n                \n                // Draw shadow\n                g2d.setColor(new Color(0, 0, 0, 180));\n                g2d.setFont(getFont());\n                FontMetrics fm = g2d.getFontMetrics();\n                g2d.drawString(getText(), 4, fm.getAscent() + 4);\n                \n                // Draw text\n                g2d.setColor(getForeground());\n                g2d.drawString(getText(), 0, fm.getAscent());\n                \n                g2d.dispose();\n            }\n        };\n        gameOverLabel.setForeground(Color.RED);\n        gameOverLabel.setFont(new Font(\"Impact\", Font.BOLD, 72));\n        gameOverLabel.setHorizontalAlignment(SwingConstants.LEFT);\n        gameOverLabel.setBounds(50, PANEL_HEIGHT/4, PANEL_WIDTH, 80);\n        add(gameOverLabel);\n        \n        // Score display with background box\n        scoreLabel = new JLabel(String.format(scoreText, gameInfo.currentWave-1, gameInfo.zombiesKilled, gameInfo.player.score)) {\n            @Override\n            protected void paintComponent(Graphics g) {\n                Graphics2D g2d = (Graphics2D) g;\n                \n                // Get text dimensions to size the box properly\n                FontMetrics fm = g2d.getFontMetrics(getFont());\n                String text = getText();\n                int textWidth = fm.stringWidth(text) + 20; // Add padding\n                int textHeight = getHeight();\n                \n                // Create semi-transparent background with rounded corners\n                Composite originalComposite = g2d.getComposite();\n                g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.7f));\n                g2d.setColor(new Color(0, 0, 0));\n                g2d.fillRoundRect(0, 0, textWidth, textHeight, 10, 10);\n                g2d.setComposite(originalComposite);\n                \n                // Draw border for the box\n                g2d.setColor(new Color(180, 180, 180));\n                g2d.drawRoundRect(0, 0, textWidth-1, textHeight-1, 10, 10);\n                \n                // Draw the text\n                g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n                g2d.setColor(Color.WHITE);\n                int textX = 10;\n                int textY = fm.getAscent() + (textHeight - fm.getHeight()) / 2;\n                g2d.drawString(text, textX, textY);\n            }\n            \n            @Override\n            public Dimension getPreferredSize() {\n                FontMetrics fm = getFontMetrics(getFont());\n                String text = getText();\n                int width = fm.stringWidth(text) + 20; // Add padding\n                int height = super.getPreferredSize().height;\n                return new Dimension(width, height);\n            }\n        };\n        scoreLabel.setForeground(Color.WHITE);\n        scoreLabel.setFont(new Font(\"Courier New\", Font.BOLD, 28));\n        scoreLabel.setHorizontalAlignment(SwingConstants.LEFT);\n        scoreLabel.setBounds(50, PANEL_HEIGHT/4 + 100, PANEL_WIDTH - 100, 60);\n        add(scoreLabel);\n        \n        // Left-align all buttons like MainMenuPanel\n        int leftMargin = 50;\n        int buttonWidth = 250;\n        \n        // Restart button\n        restartButton = UIUtils.createTransparentButtonWithIcon(restartGameText, \"assets/Icons/cycle.png\");\n        restartButton.setBounds(leftMargin, PANEL_HEIGHT/2 + 50, buttonWidth, 60);\n        restartButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                gameInfo.restartGame();\n            }\n        });\n        add(restartButton);\n        \n        // Load save button\n        loadSaveButton = UIUtils.createTransparentButtonWithIcon(loadSaveText, \"assets/Icons/load.png\");\n        loadSaveButton.setBounds(leftMargin, PANEL_HEIGHT/2 + 120, buttonWidth + 200, 60);\n        loadSaveButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                loadLastSave();\n            }\n        });\n        add(loadSaveButton);\n        \n        // Exit button\n        exitButton = UIUtils.createTransparentButtonWithIcon(exitGameText, \"assets/Icons/power-button.png\");\n        exitButton.setBounds(leftMargin, PANEL_HEIGHT/2 + 190, buttonWidth, 60);\n        exitButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                MusicPlayer.dispose();\n                System.exit(0);\n            }\n        });\n        add(exitButton);\n    }\n    \n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        \n        if (backgroundImage != null) {\n            int imgWidth = backgroundImage.getWidth(this);\n            int imgHeight = backgroundImage.getHeight(this);\n            \n            // Calculate scaling factor to cover the entire panel\n            double scale = Math.max(\n                (double) getWidth() / imgWidth,\n                (double) getHeight() / imgHeight\n            );\n            \n            // Calculate new dimensions\n            int scaledWidth = (int) (imgWidth * scale);\n            int scaledHeight = (int) (imgHeight * scale);\n            \n            // Center the scaled image (excess will be cropped)\n            int x = (getWidth() - scaledWidth) / 2;\n            int y = (getHeight() - scaledHeight) / 2;\n            \n            g.drawImage(backgroundImage, x, y, scaledWidth, scaledHeight, this);\n        }\n    }\n\n    public void updateStats() {\n        scoreLabel.setText(String.format(scoreText, gameInfo.currentWave-1, gameInfo.zombiesKilled, gameInfo.player.score));\n        repaint();\n    }\n    \n    private void loadLastSave() {\n        boolean success = gameInfo.loadGame();\n        \n        if (success) {\n            setVisible(false);\n            gameInfo.gamePanel.setVisible(true);\n            gameInfo.statPanel.setVisible(true);\n        } else {\n            JOptionPane.showMessageDialog(this, \n                \"No saved game found or failed to load game!\", \n                \"Load Error\", \n                JOptionPane.ERROR_MESSAGE\n            );\n        }\n    }\n}",
      "Zombie.java": "import java.io.File;\nimport java.awt.Rectangle;\n\npublic class Zombie extends Entity {\n    protected static final int ZOMBIE_WIDTH = 96;\n    protected static final int ZOMBIE_HEIGHT = 96;\n\n    protected int attacksPerMinute = 60;\n    protected int attackRange = 80;\n    protected int health;\n    protected int maxHealth;\n    protected double damage;\n    protected boolean canAttack = true;\n    protected long lastAttackTime = 0;\n    protected int score = 100;\n    protected double attackDistancePercent = 0.5;\n\n    public Zombie(int x, int y, int health, double speed, double damage, String appearanceImagePath, int score) {\n        this(x, y, health, speed, damage, appearanceImagePath);\n        this.score = score;\n        lastAttackTime = System.currentTimeMillis();\n    }\n\n    public Zombie(int x, int y, int health, double speed, double damage, String appearanceImagePath) {\n        this.x = x;\n        this.y = y;\n        this.health = health;\n        this.maxHealth = health;\n        this.moveSpeed = speed;\n        this.damage = damage;\n        this.width = ZOMBIE_WIDTH;\n        this.height = ZOMBIE_HEIGHT;\n        this.appearanceImagePath = appearanceImagePath;\n        setImage(new File(appearanceImagePath));\n    }\n\n    public boolean canAttack() {\n        if (!canAttack) {\n            // Calculate if enough time has passed since last attack\n            long currentTime = System.currentTimeMillis();\n            long fireDelay = 60000 / attacksPerMinute;\n            long difference = currentTime - lastAttackTime;\n            if (difference >= fireDelay) {\n                canAttack = true;\n            }\n        }\n        return canAttack;\n    }\n\n    public boolean canMoveCloser(double distance) {\n        return distance > attackRange * attackDistancePercent;\n    }\n\n    public void attack() {\n        if (canAttack) {\n            canAttack = false;\n            lastAttackTime = System.currentTimeMillis();\n        }\n    }\n\n    public Rectangle getBounds() {\n        int reducedWidth = width / 2;\n        int reducedHeight = height / 2;\n        int topLeftX = (int)x + (width - reducedWidth) / 2;\n        int topLeftY = (int)y + (height - reducedHeight) / 2 + height / 8;\n        return new Rectangle(topLeftX, topLeftY, reducedWidth, reducedHeight);\n    }\n\n    public void reset(int x, int y) {\n        this.x = x;\n        this.y = y;\n        this.health = this.maxHealth;\n        this.canAttack = true;\n        this.lastAttackTime = System.currentTimeMillis();\n        if (image == null) {\n            setImage(new File(appearanceImagePath));\n        }\n    }\n}\n",
      "MusicPlayer.java": "import javax.sound.sampled.*;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class MusicPlayer {\n    private static Clip musicClip;\n    private static float musicVolume = 0.2f;\n    private static float sfxVolume = 0.75f;\n    private static ExecutorService audioExecutor = Executors.newSingleThreadExecutor();\n    private static List<String> musicPlaylist = new ArrayList<>();\n    private static String currentTrack = null;\n    private static Random random = new Random();\n\n\tpublic static void initializePlaylist(String musicDirectory) {\n        musicPlaylist.clear();\n        \n        File directory = new File(musicDirectory);\n        if (!directory.exists() || !directory.isDirectory()) {\n            System.err.println(\"Music directory not found: \" + musicDirectory);\n            return;\n        }\n        \n        File[] musicFiles = directory.listFiles((dir, name) -> \n            name.toLowerCase().endsWith(\".wav\"));\n        \n        if (musicFiles == null || musicFiles.length == 0) {\n            System.err.println(\"No music files found in \" + musicDirectory);\n            return;\n        }\n        \n        for (File file : musicFiles) {\n            musicPlaylist.add(file.getPath());\n        }\n    }\n\t\n    public static void playRandomMusic() {\n        if (musicPlaylist.isEmpty()) {\n            System.err.println(\"Music playlist is empty!\");\n            return;\n        }\n        \n        // Select a random track that's different from the current one if possible\n        String nextTrack;\n        if (musicPlaylist.size() > 1 && currentTrack != null) {\n            do {\n                nextTrack = musicPlaylist.get(random.nextInt(musicPlaylist.size()));\n            } while (nextTrack.equals(currentTrack) && musicPlaylist.size() > 1);\n        } else {\n            nextTrack = musicPlaylist.get(random.nextInt(musicPlaylist.size()));\n        }\n        \n        playBackgroundMusic(nextTrack);\n    }\n\n    public static void playBackgroundMusic(String musicPath) {\n        stopBackgroundMusic();\n\n        currentTrack = musicPath;\n        \n        audioExecutor.submit(() -> {\n            try {\n                File musicFile = new File(musicPath);\n                if (!musicFile.exists()) {\n                    System.err.println(\"Music file not found: \" + musicPath);\n                    return;\n                }\n                \n                AudioInputStream audioStream = AudioSystem.getAudioInputStream(musicFile);\n                musicClip = AudioSystem.getClip();\n                musicClip.open(audioStream);\n                \n                setMusicVolume(musicVolume);\n\n\t\t\t\tmusicClip.addLineListener(event -> {\n                    if (event.getType() == LineEvent.Type.STOP && !musicClip.isRunning()) {\n                        playRandomMusic();\n                    }\n                });\n                \n                musicClip.start();\n            } catch (UnsupportedAudioFileException | IOException | LineUnavailableException e) {\n                System.err.println(\"Error playing background music: \" + e.getMessage());\n            }\n        });\n    }\n    \n    public static void stopBackgroundMusic() {\n        if (musicClip != null && musicClip.isRunning()) {\n            musicClip.stop();\n            musicClip.close();\n        }\n    }\n    \n    public static void setSfxVolume(float volume) {\n        if (volume < 0f || volume > 1f)\n            return;\n            \n        MusicPlayer.sfxVolume = volume;\n    }\n    public static void setMusicVolume(float volume) {\n        if (volume < 0f || volume > 1f)\n            return;\n            \n        MusicPlayer.musicVolume = volume;\n        \n        if (musicClip != null) {\n            FloatControl gainControl = (FloatControl) musicClip.getControl(FloatControl.Type.MASTER_GAIN);\n            if (gainControl != null) {\n                // Convert volume to decibels\n                float dB = (float) (Math.log(volume) / Math.log(10.0) * 20.0);\n                gainControl.setValue(dB);\n            }\n        }\n    }\n\t\n    public static float getMusicVolume() {\n        return musicVolume;\n    }\n\n    public static float getSfxVolume() {\n        return sfxVolume;\n    }\n    \n    public static void dispose() {\n        stopBackgroundMusic();\n        audioExecutor.shutdown();\n    }\n}",
      "Entity.java": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.imageio.ImageIO;\nimport java.awt.Rectangle;\n\npublic class Entity implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    protected String appearanceImagePath = \"assets/default.png\";\n    protected double x = 0;\n    protected double y = 0;\n    protected double directionX = 0;\n    protected double directionY = 0;\n    protected int width = 32;\n    protected int height = 32;\n    protected transient BufferedImage image;\n    protected double rotation = 0;\n    protected boolean isFlashing = false;\n    protected long flashStartTime = 0;\n    protected double moveSpeed;\n    protected static final long FLASH_DURATION = 150;\n\n    protected static List<Entity> entities = new ArrayList<>();\n\n    public Entity() {\n        entities.add(this);\n    }\n\n    public Entity(double x, double y) {\n        this.x = x;\n        this.y = y;\n        entities.add(this);\n    }\n\n    public void calculatePreservedRatio() {\n        if (image != null) {\n            int originalWidth = image.getWidth();\n            int originalHeight = image.getHeight();\n            \n            double ratio = (double)originalHeight / originalWidth;\n            \n            height = (int)(width * ratio);\n        }\n    }\n\n    public void setImage(File imageFile) {\n        try {\n            BufferedImage originalImage = ImageIO.read(imageFile);\n            this.image = originalImage;\n            calculatePreservedRatio();\n        } catch (Exception e) {\n            System.out.println(\"Failed to load image: \" + image);\n            e.printStackTrace();\n        }\n    }\n\n    public void setImage(BufferedImage image) {\n        this.image = image;\n        calculatePreservedRatio();\n    }\n\n    public void setTargetWidth(int width) {\n        this.width = width;\n        calculatePreservedRatio();\n    }\n    public Rectangle getBounds() {\n        return new Rectangle((int)x, (int)y, width, height);\n    }\n    public double getCenterX() {\n        return x + width / 2;\n    }\n    public double getCenterY() {\n        return y + height / 2;\n    }\n\n    public void loadImage() {\n        setImage(new File(appearanceImagePath));\n    }\n\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        // Reload the image\n        loadImage();\n        if (!entities.contains(this)) {\n            entities.add(this);\n        }\n    }\n    \n    // Check if entity should be drawn with flash effect\n    public boolean isFlashing() {\n        if (!isFlashing) return false;\n        \n        long currentTime = System.currentTimeMillis();\n        if (currentTime - flashStartTime > FLASH_DURATION) {\n            isFlashing = false;\n            return false;\n        }\n        return true;\n    }\n    \n    // Trigger flash effect\n    public void startFlashEffect() {\n        isFlashing = true;\n        flashStartTime = System.currentTimeMillis();\n    }\n}",
      "AmmoDrop.java": "import java.util.Random;\n\npublic class AmmoDrop extends Drop {\n    private int ammoAmount;\n    private Weapon sourceWeapon;\n    private static final Random random = new Random();\n    private static final double VARIATION_PERCENTAGE = 0.3;\n\n    public AmmoDrop(double x, double y, int ammoAmount, Weapon sourceWeapon) {\n        super(x, y, sourceWeapon.appearanceImagePath);\n        this.ammoAmount = ammoAmount;\n        this.sourceWeapon = sourceWeapon;\n    }\n\n    public AmmoDrop(double x, double y, Weapon sourceWeapon, GameInfo gameInfo) {\n        super(x, y, sourceWeapon.appearanceImagePath);\n        int baseAmmo = sourceWeapon.maxAmmoInClip;\n        int minAmount = (int)(baseAmmo * (1 - VARIATION_PERCENTAGE));\n        int maxAmount = (int)(baseAmmo * (1 + VARIATION_PERCENTAGE));\n        \n        minAmount = Math.max(1, minAmount);\n        \n        this.ammoAmount = minAmount + random.nextInt(maxAmount - minAmount + 1);\n        \n        if (gameInfo.currentDifficulty == GameInfo.GameDifficulty.HARD) {\n            this.ammoAmount *= 2;\n        }\n        \n        this.sourceWeapon = sourceWeapon;\n    }\n\n    public int getAmmoAmount() {\n        return ammoAmount;\n    }\n\n    public Weapon getSourceWeapon() {\n        return sourceWeapon;\n    }\n}\n",
      "Weapon.java": "import java.io.File;\nimport java.io.IOException;\n\nimport javax.sound.sampled.AudioFormat;\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.UnsupportedAudioFileException;\n\npublic class Weapon extends Entity {\n    private static final int WEAPON_SIZE = 64;\n\n    protected double shootingAngle;\n    protected double damage;\n    protected int maxAmmoInClip;\n    protected int currentAmmo = 500000000;\n    protected int currentTotalAmmo;\n    protected boolean canShoot = true;\n    protected long lastShotTime = 0;\n    protected boolean isReloading = false;\n    protected long reloadStartTime = 0;\n    protected long reloadTimeMs = 2000;\n    protected String firingSoundPath;\n    protected String reloadSoundPath;\n    protected long fireDelay;\n\n    public Weapon(int x, int y, int shotsPerMinute, double shootingAngle, double damage, int maxAmmoInClip, String firingSoundPath, String reloadSoundPath) {\n        this.x = x;\n        this.y = y;\n        this.width = WEAPON_SIZE;\n        this.height = WEAPON_SIZE;\n        this.shootingAngle = shootingAngle;\n        this.damage = damage;\n        this.maxAmmoInClip = maxAmmoInClip;\n        this.firingSoundPath = firingSoundPath;\n        this.reloadSoundPath = reloadSoundPath;\n        this.fireDelay = 60000 / shotsPerMinute;\n        calculateReloadTimeFromSound();\n    }\n    \n    protected void calculateReloadTimeFromSound() {\n        if (reloadSoundPath != null) {\n            try {\n                File soundFile = new File(reloadSoundPath);\n                if (soundFile.exists()) {\n                    AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(soundFile);\n                    AudioFormat format = audioInputStream.getFormat();\n                    long frames = audioInputStream.getFrameLength();\n                    reloadTimeMs = (long) (frames / format.getFrameRate() * 1000);\n                    audioInputStream.close();\n                }\n            } catch (UnsupportedAudioFileException | IOException e) {\n                System.err.println(\"Error calculating sound duration: \" + e.getMessage());\n                // Keep the default reload time if there's an error\n            }\n        }\n    }\n\n    public void reload() {\n        if (!isReloading && currentAmmo < maxAmmoInClip && currentTotalAmmo > 0) {\n            isReloading = true;\n            reloadStartTime = System.currentTimeMillis();\n            playReloadSound();\n        }\n    }\n\n    public boolean canShoot() {\n        if (!canShoot) {\n            if (System.currentTimeMillis() - lastShotTime >= fireDelay) {\n                canShoot = true;\n            }\n        }\n        return canShoot && currentAmmo > 0 && !isReloading;\n    }\n\n    public void shoot() {\n        if (canShoot) {\n            canShoot = false;\n            lastShotTime = System.currentTimeMillis();\n            playFiringSound();\n        }\n    }\n    \n    public void playFiringSound() {\n        GameInfo.playSound(firingSoundPath);\n    }\n\n    public void playReloadSound() {\n        GameInfo.playSound(reloadSoundPath);\n    }\n    \n    public void updateForDifficulty(GameInfo.GameDifficulty difficulty) {\n        // Update fire delay\n        long baseFireDelay = 60000 / (60000 / fireDelay);\n        \n        if (difficulty == GameInfo.GameDifficulty.HARD) {\n            fireDelay = baseFireDelay / 2;\n        } else {\n            fireDelay = baseFireDelay;\n        }\n\n        // Update max ammo in clip\n        if (difficulty == GameInfo.GameDifficulty.HARD) {\n            maxAmmoInClip *= 2;\n            currentAmmo *= 2;\n        }\n    }\n}\n",
      "Bullet.java": "import java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.awt.Rectangle;\n\npublic class Bullet extends Entity {\n    public int bulletSize = 100;\n    protected ArrayList<Zombie> hitZombies = new ArrayList<Zombie>();\n    protected boolean isZombieBullet = false;\n    protected double damage = 0;\n    protected Weapon sourceWeapon;\n\n    public Bullet(double x, double y, Weapon sourceWeapon) {\n        super(x, y);\n        \n        reset(x, y, sourceWeapon);\n    }\n\n    public static class Pool {\n        private static final int INITIAL_POOL_SIZE = 100;\n        \n        private static List<Bullet> availableBullets;\n\n        static {\n            availableBullets = new ArrayList<>();\n            \n            // Pre-populate the pool with bullets\n            for (int i = 0; i < INITIAL_POOL_SIZE; i++) {\n                availableBullets.add(new Bullet(0, 0, null));\n            }\n        }\n        \n        public static Bullet getBullet(double x, double y, Weapon sourceWeapon) {\n            Bullet bullet;\n            \n            if (availableBullets.isEmpty()) {\n                // Create a new bullet if the pool is empty\n                bullet = new Bullet(x, y, sourceWeapon);\n            } else {\n                // Get a bullet from the pool\n                bullet = availableBullets.remove(availableBullets.size() - 1);\n                bullet.reset(x, y, sourceWeapon);\n            }\n            \n            return bullet;\n        }\n        \n        public static void returnBullet(Bullet bullet) {\n            bullet.hitZombies.clear();\n            availableBullets.add(bullet);\n        }\n        \n        public static int getPoolSize() {\n            return availableBullets.size();\n        }\n    }\n    \n    public void reset(double x, double y, Weapon sourceWeapon) {\n        this.sourceWeapon = sourceWeapon;\n        this.isZombieBullet = false;\n        this.damage = 0;\n        this.hitZombies.clear();\n        \n        // Update appearance based on weapon type\n        if (sourceWeapon instanceof Pistol) {\n            this.appearanceImagePath = \"assets/Laser Sprites/01.png\";\n            this.bulletSize = 100;\n        } else if (sourceWeapon instanceof Rifle) {\n            this.appearanceImagePath = \"assets/Laser Sprites/12.png\";\n            this.bulletSize = 100;\n        } else if (sourceWeapon instanceof Shotgun) {\n            this.appearanceImagePath = \"assets/Laser Sprites/33.png\";\n            this.bulletSize = 100;\n        } else if (sourceWeapon instanceof Sniper) {\n            this.appearanceImagePath = \"assets/Laser Sprites/65.png\";\n            this.bulletSize = 100;\n        } else if (sourceWeapon instanceof RocketLauncher) {\n            this.appearanceImagePath = \"assets/Laser Sprites/55.png\";\n            this.bulletSize = 200;\n        } else {\n            this.appearanceImagePath = \"assets/Laser Sprites/02.png\";\n            this.bulletSize = 100;\n        }\n        \n        this.x = x - bulletSize/2;\n        this.y = y - bulletSize/2;\n        this.width = bulletSize;\n        this.height = bulletSize;\n        this.moveSpeed = GameInfo.BULLET_SPEED;\n        \n        setImage(new File(appearanceImagePath));\n    }\n\n    public double getDamage() {\n        if (isZombieBullet) {\n            return damage;\n        }\n        return sourceWeapon.damage;\n    }\n    \n    public void setDamage(double damage) {\n        this.damage = damage;\n    }\n    \n    public Weapon getSourceWeapon() {\n        return sourceWeapon;\n    }\n    \n    public void setZombieBullet(boolean isZombieBullet) {\n        this.isZombieBullet = isZombieBullet;\n    }\n    \n    public boolean isZombieBullet() {\n        return isZombieBullet;\n    }\n\n    public Rectangle getBounds() {\n        int reducedWidth = width / 2;\n        int reducedHeight = height / 2;\n        int centerX = (int)x + (width - reducedWidth) / 2;\n        int centerY = (int)y + (height - reducedHeight) / 2;\n        return new Rectangle(centerX, centerY, reducedWidth, reducedHeight);\n    }\n}\n",
      "Shotgun.java": "import java.io.File;\n\npublic class Shotgun extends Weapon {\n    public Shotgun() {\n        super(0, 0, 80, 0, 30, 7, \"assets/WeaponSounds/Firing/shotgun.wav\", \"assets/WeaponSounds/Reload/shotgun.wav\");\n        this.appearanceImagePath = \"assets/Weapons/shotgun.png\";\n        setImage(new File(appearanceImagePath));\n    }\n}\n",
      "StatPanel.java": "import java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.RenderingHints;\nimport java.awt.GradientPaint;\nimport java.awt.BasicStroke;\nimport javax.imageio.ImageIO;\nimport javax.swing.ImageIcon;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.JProgressBar;\nimport javax.swing.SwingConstants;\nimport javax.swing.border.EmptyBorder;\n\npublic class StatPanel extends JPanel {\n    public static final int WIDTH = GameFrame.WIDTH;\n    public static final int HEIGHT = 75;\n\n    private GameInfo gameInfo;\n    private String ammoText = \"Ammo: \";\n    private String ammoClipText = \"Ammo Clip: \";\n    private String waveText = \"Wave: \";\n    private String zombiesRemainingText = \"Zombies: \";\n    private String scoreText = \"Score: \";\n    private JLabel ammoLabel;\n    private JLabel ammoClipLabel;\n    private JLabel waveLabel;\n    private JLabel zombiesRemainingLabel;\n    private JLabel scoreLabel;\n    private JProgressBar healthBar;\n    private JLabel healthLabel;\n    private JLabel healthPercentLabel;\n    private JLabel weaponNameLabel;\n    private JLabel weaponImageLabel;\n    private JLabel difficultyLabel;\n    private Image backgroundTexture;\n\n    public StatPanel(GameInfo gameInfo) {\n        this.gameInfo = gameInfo;\n        setBounds(0, 0, WIDTH, HEIGHT);\n        setLayout(null);\n        \n        // Load background texture\n        try {\n            backgroundTexture = ImageIO.read(new File(\"assets/Background/tile_0028.png\"));\n        } catch (IOException e) {\n            System.err.println(\"Could not load panel texture\");\n        }\n        \n        // Custom weaponNameLabel panel with background\n        JPanel weaponPanel = createStyledPanel(5, 5, 272, 65);\n        weaponPanel.setLayout(null);\n        \n        weaponNameLabel = new JLabel(getWeaponName(gameInfo.player.currentWeapon));\n        weaponNameLabel.setForeground(Color.YELLOW);\n        weaponNameLabel.setFont(new Font(\"Courier New\", Font.BOLD, 20));\n        weaponNameLabel.setBounds(10, 5, 200, 25);\n        weaponPanel.add(weaponNameLabel);\n\n        weaponImageLabel = new JLabel();\n        updateWeaponImage(gameInfo.player.currentWeapon);\n        weaponImageLabel.setBounds(200, 5, 64, 48);\n        weaponPanel.add(weaponImageLabel);\n        \n        add(weaponPanel);\n\n        // Create ammo panel\n        JPanel ammoPanel = createStyledPanel(285, 5, 240, 65);\n        ammoPanel.setLayout(null);\n        \n        ammoLabel = createLabelWithIcon(\n            ammoText + gameInfo.player.currentWeapon.currentAmmo,\n            \"assets/Icons/bullets.png\",\n            Color.WHITE\n        );\n        ammoLabel.setFont(new Font(\"Courier New\", Font.BOLD, 18));\n        ammoLabel.setBounds(10, 5, 220, 25);\n        ammoPanel.add(ammoLabel);\n\n        ammoClipLabel = createLabelWithIcon(\n            ammoClipText + gameInfo.player.currentWeapon.currentTotalAmmo,\n            \"assets/Icons/gun-magazine.png\",\n            Color.WHITE\n        );\n        ammoClipLabel.setFont(new Font(\"Courier New\", Font.BOLD, 18));\n        ammoClipLabel.setBounds(10, 35, 220, 25);  // Increased width\n        ammoPanel.add(ammoClipLabel);\n        \n        add(ammoPanel);\n\n        // Create wave panel (center) - make this stand out\n        JPanel wavePanel = createStyledPanel(WIDTH/2 - 100, 5, 200, 65);\n        wavePanel.setLayout(null);\n        \n        waveLabel = new JLabel(waveText + gameInfo.currentWave);\n        waveLabel.setForeground(new Color(255, 100, 100));\n        waveLabel.setFont(new Font(\"Impact\", Font.BOLD, 32));\n        waveLabel.setHorizontalAlignment(SwingConstants.CENTER);\n        waveLabel.setBounds(0, 5, 200, 40);\n        wavePanel.add(waveLabel);\n        \n        // Difficulty indicator\n        difficultyLabel = new JLabel(gameInfo.currentDifficulty == GameInfo.GameDifficulty.HARD ? \"HARD MODE\" : \"\");\n        difficultyLabel.setForeground(new Color(255, 50, 50));\n        difficultyLabel.setFont(new Font(\"Impact\", Font.BOLD, 14));\n        difficultyLabel.setHorizontalAlignment(SwingConstants.CENTER);\n        difficultyLabel.setBounds(0, 45, 200, 20);\n        wavePanel.add(difficultyLabel);\n        \n        add(wavePanel);\n\n        // Create zombies & score panel\n        JPanel zombiesScorePanel = createStyledPanel(WIDTH - 490, 5, 200, 65);\n        zombiesScorePanel.setLayout(null);\n        \n        zombiesRemainingLabel = createLabelWithIcon(\n            zombiesRemainingText + gameInfo.zombies.size(),\n            \"assets/Icons/shambling-zombie.png\",\n            Color.GREEN\n        );\n        zombiesRemainingLabel.setFont(new Font(\"Courier New\", Font.BOLD, 18));\n        zombiesRemainingLabel.setHorizontalAlignment(SwingConstants.LEFT);\n        zombiesRemainingLabel.setBounds(10, 5, 200, 25);\n        zombiesScorePanel.add(zombiesRemainingLabel);\n        \n        // Add score label under zombies\n        scoreLabel = createLabelWithIcon(\n            scoreText + gameInfo.player.score,\n            \"assets/Icons/stars-stack.png\",\n            Color.YELLOW\n        );\n        scoreLabel.setFont(new Font(\"Courier New\", Font.BOLD, 18));\n        scoreLabel.setBounds(10, 35, 200, 25);\n        zombiesScorePanel.add(scoreLabel);\n        \n        add(zombiesScorePanel);\n\n        // Create health panel\n        JPanel healthPanel = createStyledPanel(WIDTH - 280, 5, 275, 65);\n        healthPanel.setLayout(null);\n        \n        healthLabel = createLabelWithIcon(\n            \"\",\n            \"assets/Icons/health-normal.png\",\n            Color.RED,\n            48, 48\n        );\n        healthLabel.setFont(new Font(\"Courier New\", Font.BOLD, 16));\n        healthLabel.setBounds(10, 5, 50, 58);\n        healthPanel.add(healthLabel);\n\n        healthBar = createCustomHealthBar();\n        healthBar.setValue((int)((gameInfo.player.health / Player.PLAYER_HEALTH) * 100));\n        healthBar.setBounds(65, 5, 165, 58);\n        healthPanel.add(healthBar);\n\n        healthPercentLabel = new JLabel((int)((gameInfo.player.health / Player.PLAYER_HEALTH) * 100) + \"%\");\n        healthPercentLabel.setForeground(Color.RED);\n        healthPercentLabel.setFont(new Font(\"Courier New\", Font.BOLD, 14));\n        healthPercentLabel.setBounds(235, 20, 40, 25);\n        healthPanel.add(healthPercentLabel);\n        \n        add(healthPanel);\n\n        setVisible(false);\n    }\n\n    private JPanel createStyledPanel(int x, int y, int width, int height) {\n        JPanel panel = new JPanel() {\n            @Override\n            protected void paintComponent(Graphics g) {\n                Graphics2D g2d = (Graphics2D)g;\n                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n                \n                g2d.setColor(new Color(0, 0, 0, 220));\n                g2d.fillRoundRect(0, 0, getWidth(), getHeight(), 10, 10);\n                \n                g2d.setColor(new Color(70, 70, 70));\n                g2d.setStroke(new BasicStroke(2f));\n                g2d.drawRoundRect(1, 1, getWidth()-2, getHeight()-2, 10, 10);\n                \n                g2d.setColor(new Color(120, 120, 120, 100));\n                g2d.drawLine(5, 2, getWidth()-5, 2);\n            }\n        };\n        \n        panel.setOpaque(false);\n        panel.setBounds(x, y, width, height);\n        panel.setBorder(new EmptyBorder(5, 5, 5, 5));\n        return panel;\n    }\n\n    private JProgressBar createCustomHealthBar() {\n        JProgressBar bar = new JProgressBar(0, 100) {\n            @Override\n            protected void paintComponent(Graphics g) {\n                Graphics2D g2d = (Graphics2D)g;\n                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n                \n                g2d.setColor(new Color(20, 20, 20));\n                g2d.fillRoundRect(0, 0, getWidth(), getHeight(), 8, 8);\n                \n                int val = getValue();\n                int w = (int)(getWidth() * ((double)val / getMaximum()));\n                \n                Color startColor, endColor;\n                if (gameInfo.player.isFlashing()) {\n                    startColor = Color.WHITE;\n                    endColor = new Color(220, 220, 220);\n                } else if (val > 66) {\n                    startColor = new Color(20, 200, 20);\n                    endColor = new Color(100, 255, 100);\n                } else if (val > 33) {\n                    startColor = new Color(200, 150, 20);\n                    endColor = new Color(255, 200, 0);\n                } else {\n                    startColor = new Color(200, 20, 20);\n                    endColor = new Color(255, 100, 100);\n                }\n                \n                GradientPaint gradient = new GradientPaint(\n                    0, 0, startColor, \n                    0, getHeight(), endColor\n                );\n                g2d.setPaint(gradient);\n                g2d.fillRoundRect(0, 0, w, getHeight(), 8, 8);\n                \n                g2d.setColor(new Color(60, 60, 60));\n                g2d.setStroke(new BasicStroke(1.5f));\n                g2d.drawRoundRect(0, 0, getWidth()-1, getHeight()-1, 8, 8);\n            }\n        };\n        \n        bar.setBackground(new Color(30, 30, 30));\n        bar.setForeground(Color.GREEN);\n        bar.setBorderPainted(false);\n        bar.setStringPainted(false);\n        bar.setOpaque(false);\n        return bar;\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        \n        Graphics2D g2d = (Graphics2D)g;\n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        \n        GradientPaint gradient = new GradientPaint(\n            0, 0, new Color(40, 40, 40), \n            0, getHeight(), new Color(20, 20, 20)\n        );\n        g2d.setPaint(gradient);\n        g2d.fillRect(0, 0, getWidth(), getHeight());\n        \n        if (backgroundTexture != null) {\n            g2d.setComposite(java.awt.AlphaComposite.getInstance(\n                java.awt.AlphaComposite.SRC_OVER, 0.1f));\n                \n            int textureWidth = backgroundTexture.getWidth(this);\n            int textureHeight = backgroundTexture.getHeight(this);\n            \n            for (int x = 0; x < getWidth(); x += textureWidth) {\n                for (int y = 0; y < getHeight(); y += textureHeight) {\n                    g2d.drawImage(backgroundTexture, x, y, textureWidth, textureHeight, this);\n                }\n            }\n            g2d.setComposite(java.awt.AlphaComposite.SrcOver);\n        }\n        \n        g2d.setColor(new Color(80, 80, 80));\n        g2d.fillRect(0, getHeight()-2, getWidth(), 2);\n    }\n\n    public void update() {\n        Weapon weapon = gameInfo.player.currentWeapon;\n        weaponNameLabel.setText(getWeaponName(weapon));\n        updateWeaponImage(weapon);\n        ammoLabel.setText(ammoText + weapon.currentAmmo);\n        ammoClipLabel.setText(ammoClipText + (weapon instanceof Pistol ? \"∞\" : weapon.currentTotalAmmo));\n        zombiesRemainingLabel.setText(zombiesRemainingText + gameInfo.zombies.size());\n        scoreLabel.setText(scoreText + gameInfo.player.score);\n        waveLabel.setText(waveText + gameInfo.currentWave);\n        difficultyLabel.setText(gameInfo.currentDifficulty == GameInfo.GameDifficulty.HARD ? \"HARD MODE\" : \"\");\n\n        int healthValue = (int)((gameInfo.player.health / Player.PLAYER_HEALTH) * 100);\n        healthBar.setValue(healthValue);\n        healthPercentLabel.setText(healthValue + \"%\");\n        \n        Color healthColor;\n        if (gameInfo.player.isFlashing()) {\n            healthColor = Color.WHITE;\n        } else if (healthValue > 66) {\n            healthColor = new Color(100, 255, 100);\n        } else if (healthValue > 33) {\n            healthColor = new Color(255, 200, 0);\n        } else {\n            healthColor = new Color(255, 100, 100);\n        }\n        \n        healthPercentLabel.setForeground(healthColor);\n        healthBar.repaint();\n    }\n\n    private String getWeaponName(Weapon weapon) {\n        if (weapon instanceof Pistol) {\n            return \"Pistol\";\n        } else if (weapon instanceof Rifle) {\n            return \"Rifle\";\n        } else if (weapon instanceof Shotgun) {\n            return \"Shotgun\";\n        } else if (weapon instanceof Sniper) {\n            return \"Sniper\";\n        } else if (weapon instanceof RocketLauncher) {\n            return \"Rocket Launcher\";\n        } else {\n            return \"Unknown Weapon\";\n        }\n    }\n    \n    private void updateWeaponImage(Weapon weapon) {\n        try {\n            BufferedImage originalImage = ImageIO.read(new File(weapon.appearanceImagePath));\n            Image resizedImage = originalImage.getScaledInstance(64, 48, Image.SCALE_SMOOTH);\n            weaponImageLabel.setIcon(new ImageIcon(resizedImage));\n        } catch (IOException e) {\n            System.err.println(\"Could not load weapon image: \" + weapon.appearanceImagePath);\n        }\n    }\n    \n    private JLabel createLabelWithIcon(String text, String iconPath, Color textColor) {\n        return createLabelWithIcon(text, iconPath, textColor, 24, 24);\n    }\n    \n    private JLabel createLabelWithIcon(String text, String iconPath, Color textColor, int iconWidth, int iconHeight) {\n        JLabel label = new JLabel(text);\n        label.setForeground(textColor);\n        \n        try {\n            Image img = ImageIO.read(new File(iconPath));\n            Image resizedImg = img.getScaledInstance(iconWidth, iconHeight, Image.SCALE_SMOOTH);\n            label.setIcon(new ImageIcon(resizedImg));\n            \n            label.setIconTextGap(8);\n        } catch (IOException e) {\n            System.err.println(\"Could not load icon: \" + iconPath);\n        }\n        \n        return label;\n    }\n\n    @Override\n    public Dimension getPreferredSize() {\n        return new Dimension(WIDTH, HEIGHT);\n    }\n}\n",
      "ReptileZombie.java": "public class ReptileZombie extends Zombie {\n    private static final long JUMP_COOLDOWN = 3000;\n    private static final double JUMP_RANGE = 300;\n    protected static final double JUMP_SPEED = 10;\n    protected static final double JUMP_DISTANCE = 400;\n\n    protected boolean isJumping = false;\n    protected double jumpDirectionX = 0;\n    protected double jumpDirectionY = 0;\n    protected double jumpDistanceTraveled = 0;\n    private long lastJumpTime = 0;\n\n    public ReptileZombie(int x, int y) {\n        super(x, y, 50, 2, 10, \"assets/Zombies/reptile_zombie.png\", 75);\n        lastJumpTime = System.currentTimeMillis();\n    }\n\n    // Add a method to set random jump direction\n    public void prepareJump(double playerX, double playerY) {\n        // Calculate vector from zombie to player\n        double dx = playerX - this.getCenterX();\n        double dy = playerY - this.getCenterY();\n        \n        // Normalize the vector\n        double length = Math.sqrt(dx * dx + dy * dy);\n        if (length > 0) {\n            dx /= length;\n            dy /= length;\n        }\n        \n        jumpDirectionX = dx;\n        jumpDirectionY = dy;\n        \n        isJumping = true;\n        jumpDistanceTraveled = 0;\n        lastJumpTime = System.currentTimeMillis();\n    }\n\n    // Check if enough time has passed to jump again\n    public boolean canJump() {\n        return !isJumping && System.currentTimeMillis() - lastJumpTime >= JUMP_COOLDOWN;\n    }\n\n    public void updateJump() {\n        double moveAmount = moveSpeed * JUMP_SPEED;\n        \n        x += jumpDirectionX * moveAmount;\n        y += jumpDirectionY * moveAmount;\n        \n        jumpDistanceTraveled += moveAmount;\n        \n        if (jumpDistanceTraveled >= JUMP_RANGE) {\n            isJumping = false;\n        }\n    }\n}\n",
      "GameFrame.java": "import javax.swing.JFrame;\nimport javax.swing.JLayeredPane;\nimport java.awt.Dimension;\n\npublic class GameFrame extends JFrame {\n    public static final int WIDTH = 1920;\n    public static final int HEIGHT = 1080;\n    protected static final String GAME_TITLE = \"ZombieShot\";\n\n    public GameFrame() {\n        setTitle(GAME_TITLE);\n        setResizable(false);\n\n        // Use a layered pane for overlays\n        JLayeredPane layeredPane = new JLayeredPane();\n        layeredPane.setPreferredSize(new Dimension(WIDTH, HEIGHT));\n\n        // Create game components\n        GameInfo gameInfo = new GameInfo();\n\n        StatPanel statPanel = new StatPanel(gameInfo);\n        gameInfo.statPanel = statPanel;\n\n        GamePanel gamePanel = new GamePanel(gameInfo);\n        gameInfo.gamePanel = gamePanel;\n\n        GameOverPanel gameOverPanel = new GameOverPanel(gameInfo);\n        gameInfo.gameOverPanel = gameOverPanel;\n\n        MainMenuPanel mainMenuPanel = new MainMenuPanel(gameInfo);\n        gameInfo.mainMenuPanel = mainMenuPanel;\n\n        PauseGamePanel pauseGamePanel = new PauseGamePanel(gameInfo);\n        gameInfo.pauseGamePanel = pauseGamePanel;\n\n        // Set bounds for each panel\n        gamePanel.setBounds(0, StatPanel.HEIGHT, WIDTH, HEIGHT - StatPanel.HEIGHT);\n        statPanel.setBounds(0, 0, WIDTH, StatPanel.HEIGHT);\n        gameOverPanel.setBounds(0, 0, WIDTH, HEIGHT);\n        mainMenuPanel.setBounds(0, 0, WIDTH, HEIGHT);\n        pauseGamePanel.setBounds(0, 0, WIDTH, HEIGHT);\n\n        // Add panels to layered pane with different depths\n        layeredPane.add(gamePanel, JLayeredPane.DEFAULT_LAYER);\n        layeredPane.add(statPanel, JLayeredPane.PALETTE_LAYER);\n        layeredPane.add(gameOverPanel, JLayeredPane.MODAL_LAYER);\n        layeredPane.add(mainMenuPanel, JLayeredPane.MODAL_LAYER);\n        layeredPane.add(pauseGamePanel, JLayeredPane.POPUP_LAYER);\n\n        add(layeredPane);\n\n        pack();\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setLocationRelativeTo(null);\n        setVisible(true);\n    }\n}",
      "PauseGamePanel.java": "import javax.swing.JPanel;\nimport javax.swing.JButton;\nimport javax.swing.JLabel;\nimport javax.swing.SwingConstants;\nimport javax.swing.JOptionPane;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.ActionEvent;\nimport java.awt.RenderingHints;\nimport java.awt.FontMetrics;\n\npublic class PauseGamePanel extends JPanel {\n    private GameInfo gameInfo;\n    private final int PANEL_WIDTH = GameFrame.WIDTH;\n    private final int PANEL_HEIGHT = GameFrame.HEIGHT;\n    private Image backgroundImage;\n    \n    private JLabel pauseLabel;\n    private JButton resumeButton;\n    private JButton mainMenuButton;\n    private JButton exitButton;\n    \n    public PauseGamePanel(GameInfo gameInfo) {\n        this.gameInfo = gameInfo;\n        setPreferredSize(new Dimension(PANEL_WIDTH, PANEL_HEIGHT));\n        setLayout(null);\n        \n        if (gameInfo.backgroundImage != null) {\n            backgroundImage = gameInfo.backgroundImage;\n        }\n        \n        setOpaque(false);\n\n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {\n                    resumeGame();\n                }\n            }\n        });\n        \n        // Pause Title\n        pauseLabel = new JLabel(\"GAME PAUSED\") {\n            @Override\n            protected void paintComponent(Graphics g) {\n                Graphics2D g2d = (Graphics2D) g.create();\n                g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n                \n                // Draw shadow\n                g2d.setColor(new Color(0, 0, 0, 180));\n                g2d.setFont(getFont());\n                FontMetrics fm = g2d.getFontMetrics();\n                g2d.drawString(getText(), 4, fm.getAscent() + 4);\n                \n                // Draw text\n                g2d.setColor(getForeground());\n                g2d.drawString(getText(), 0, fm.getAscent());\n                \n                g2d.dispose();\n            }\n        };\n        pauseLabel.setForeground(Color.WHITE);\n        pauseLabel.setFont(new Font(\"Impact\", Font.BOLD, 72));\n        pauseLabel.setHorizontalAlignment(SwingConstants.CENTER);\n        pauseLabel.setBounds(50, PANEL_HEIGHT/4, PANEL_WIDTH, 80);\n        add(pauseLabel);\n        \n        // Left-align all buttons\n        int leftMargin = 50;\n        int buttonWidth = 250;\n        int buttonHeight = 60;\n        int buttonY = PANEL_HEIGHT/2;\n        int buttonGap = 80;\n        \n        // Resume button\n        resumeButton = UIUtils.createTransparentButtonWithIcon(\"Resume Game\", \"assets/Icons/play-button.png\");\n        resumeButton.setBounds(leftMargin, buttonY, buttonWidth + 40, buttonHeight);\n        resumeButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                resumeGame();\n            }\n        });\n        add(resumeButton);\n        \n        // Add Save Game button\n        JButton saveGameButton = UIUtils.createTransparentButtonWithIcon(\"Save Game\", \"assets/Icons/save.png\");\n        saveGameButton.setBounds(leftMargin, buttonY + buttonGap, buttonWidth, buttonHeight);\n        saveGameButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                saveGame();\n            }\n        });\n        add(saveGameButton);\n        \n        // Main menu button\n        mainMenuButton = UIUtils.createTransparentButtonWithIcon(\"Main Menu\", \"assets/Icons/house.png\");\n        mainMenuButton.setBounds(leftMargin, buttonY + buttonGap*2, buttonWidth, buttonHeight);\n        mainMenuButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                goToMainMenu();\n            }\n        });\n        add(mainMenuButton);\n        \n        // Exit button\n        exitButton = UIUtils.createTransparentButtonWithIcon(\"Exit Game\", \"assets/Icons/power-button.png\");\n        exitButton.setBounds(leftMargin, buttonY + buttonGap*3, buttonWidth, buttonHeight);\n        exitButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                exitGame();\n            }\n        });\n        add(exitButton);\n        \n        setVisible(false);\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        Graphics2D g2d = (Graphics2D) g.create();\n        \n        if (backgroundImage != null) {\n            int imgWidth = backgroundImage.getWidth(this);\n            int imgHeight = backgroundImage.getHeight(this);\n            \n            // Calculate scaling factor to cover the entire panel\n            double scale = Math.max(\n                (double) getWidth() / imgWidth,\n                (double) getHeight() / imgHeight\n            );\n            \n            // Calculate new dimensions\n            int scaledWidth = (int) (imgWidth * scale);\n            int scaledHeight = (int) (imgHeight * scale);\n            \n            // Center the scaled image (excess will be cropped)\n            int x = (getWidth() - scaledWidth) / 2;\n            int y = (getHeight() - scaledHeight) / 2;\n            \n            // Draw with reduced alpha for the background\n            g2d.drawImage(backgroundImage, x, y, scaledWidth, scaledHeight, this);\n        }\n        \n        g2d.dispose();\n        super.paintComponent(g);\n    }\n    \n    public void resumeGame() {\n        setVisible(false);\n        gameInfo.gamePanel.requestFocus();\n        gameInfo.gamePanel.resumeGame();\n    }\n    \n    private void goToMainMenu() {\n        setVisible(false);\n        gameInfo.gamePanel.setVisible(false);\n        gameInfo.statPanel.setVisible(false);\n        gameInfo.mainMenuPanel.setVisible(true);\n        \n        // Stop all game timers\n        if (gameInfo.gameTimer != null && gameInfo.gameTimer.isRunning()) {\n            gameInfo.gameTimer.stop();\n        }\n        if (gameInfo.zombieSpawnTimer != null && gameInfo.zombieSpawnTimer.isRunning()) {\n            gameInfo.zombieSpawnTimer.stop();\n        }\n    }\n    \n    private void exitGame() {\n        MusicPlayer.dispose();\n        System.exit(0);\n    }\n    \n    private void saveGame() {\n        boolean success = gameInfo.saveGame();\n        \n        if (success) {\n            // Show a message that game was saved\n            JOptionPane.showMessageDialog(this, \n                \"Game saved successfully!\", \n                \"Save Complete\", \n                JOptionPane.INFORMATION_MESSAGE\n            );\n        } else {\n            // Show error message if save failed\n            JOptionPane.showMessageDialog(this, \n                \"Failed to save game!\", \n                \"Save Error\", \n                JOptionPane.ERROR_MESSAGE\n            );\n        }\n\n        this.requestFocus();\n    }\n}",
      "GameInfo.java": "import java.util.ArrayList;\nimport java.util.List;\n\nimport javax.imageio.ImageIO;\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport javax.sound.sampled.FloatControl;\nimport javax.sound.sampled.LineEvent;\nimport javax.sound.sampled.LineUnavailableException;\nimport javax.sound.sampled.UnsupportedAudioFileException;\nimport javax.swing.Timer;\nimport java.io.*;\nimport java.util.HashMap;\nimport java.awt.Image;\nimport java.awt.event.KeyEvent;\n\npublic class GameInfo {\n    public enum GameDifficulty { NORMAL, HARD }\n\n    protected GameDifficulty currentDifficulty = GameDifficulty.NORMAL;\n\n    protected final int NORMAL_ZOMBIE_SPAWN_RATE = 400;\n    protected final int HARD_ZOMBIE_SPAWN_RATE = 200;\n    protected final int NORMAL_ZOMBIES_PER_WAVE = 10;\n    protected final int HARD_ZOMBIES_PER_WAVE = 15;\n    protected final int NORMAL_ZOMBIE_INCREASE_PERCENT = 50;\n    protected final int HARD_ZOMBIE_INCREASE_PERCENT = 75;\n    protected final double NORMAL_ZOMBIE_SPEED_MULTIPLIER = 1.0;\n    protected final double HARD_ZOMBIE_SPEED_MULTIPLIER = 1.3;\n\n    protected int currentZombieSpawnRate = NORMAL_ZOMBIE_SPAWN_RATE;\n    protected int currentZombiesPerWave = NORMAL_ZOMBIES_PER_WAVE;\n    protected int currentZombieIncreasePercent = NORMAL_ZOMBIE_INCREASE_PERCENT;\n    protected double currentZombieSpeedMultiplier = NORMAL_ZOMBIE_SPEED_MULTIPLIER;\n\n    protected static final int ZOMBIE_INCREASE_PERCENT = 50;\n    protected static final float HEALTH_DROP_CHANCE = 0.01f;\n    protected static final float AMMO_DROP_CHANCE = 0.3f;\n    protected static final float PLAYER_SPEED = 5.0f;\n    protected static final float BULLET_SPEED = 20.0f;\n    protected static final String BACKGROUND_IMAGE_PATH = \"assets/Backgrounds/menu_background.png\";\n    protected static final String BACKGROUND_MUSIC_PATH = \"assets/Musics/\";\n\n    protected Player player;\n    protected StatPanel statPanel;\n    protected GamePanel gamePanel;\n    protected GameOverPanel gameOverPanel;\n    protected MainMenuPanel mainMenuPanel;\n    protected PauseGamePanel pauseGamePanel;\n    protected List<Zombie> zombies = new ArrayList<>();\n    protected List<Bullet> bullets = new ArrayList<>();\n    protected List<Drop> drops = new ArrayList<>();\n    protected List<Animation> animations = new ArrayList<>();\n    protected Timer gameTimer;\n    protected Timer zombieSpawnTimer;\n    protected HashMap<String, Integer> keyBindings = new HashMap<>();\n    protected Image backgroundImage;\n\n    private int zombiesKilledLastWave = 0;\n    protected int currentWave = 1;\n    protected int zombiesKilled = 0;\n    protected int zombiesSpawned = 0;\n    protected int selectedCharacter = 1;\n    protected boolean isPaused = false;\n\n    public GameInfo() {\n        startBackgroundMusic();\n        player = new Player(0, 0, selectedCharacter);\n\n        setDifficulty(GameDifficulty.NORMAL);\n\n        keyBindings.put(\"moveUp\", KeyEvent.VK_W);\n        keyBindings.put(\"moveDown\", KeyEvent.VK_S);\n        keyBindings.put(\"moveLeft\", KeyEvent.VK_A);\n        keyBindings.put(\"moveRight\", KeyEvent.VK_D);\n        keyBindings.put(\"reload\", KeyEvent.VK_R);\n        keyBindings.put(\"weapon1\", KeyEvent.VK_1);\n        keyBindings.put(\"weapon2\", KeyEvent.VK_2);\n        keyBindings.put(\"weapon3\", KeyEvent.VK_3);\n        keyBindings.put(\"weapon4\", KeyEvent.VK_4);\n        keyBindings.put(\"weapon5\", KeyEvent.VK_5);\n        keyBindings.put(\"pause\", KeyEvent.VK_ESCAPE);\n        keyBindings.put(\"toggleFPS\", KeyEvent.VK_F1);\n        keyBindings.put(\"debug\", KeyEvent.VK_F3);\n\n        try {\n            backgroundImage = ImageIO.read(new File(BACKGROUND_IMAGE_PATH));\n        } catch (IOException e) {\n            System.err.println(\"Could not load background image: \" + BACKGROUND_IMAGE_PATH);\n        }\n        \n        // Try to load saved keybindings\n        loadSettings();\n    }\n\n    public void updateZombiesRemaining(int count) {\n        if (statPanel != null) {\n            statPanel.update();\n        }\n    }\n\n    public void incrementWaveIfNeeded() {\n        int maxZombiesForCurrentWave = getMaxZombiesPerWave();\n        if (zombies.isEmpty() && zombiesSpawned == maxZombiesForCurrentWave) {\n            zombiesKilledLastWave = zombiesKilled;\n            currentWave++;\n            if (statPanel != null) {\n                statPanel.update();\n            }\n        }\n    }\n\n    public int getMaxZombiesPerWave() {\n        return zombiesKilledLastWave + currentZombiesPerWave + \n               (currentZombiesPerWave * currentZombieIncreasePercent * (currentWave - 1) / 100);\n    }\n    \n    public void setDifficulty(GameDifficulty difficulty) {\n        this.currentDifficulty = difficulty;\n        \n        if (difficulty == GameDifficulty.HARD) {\n            currentZombieSpawnRate = HARD_ZOMBIE_SPAWN_RATE;\n            currentZombiesPerWave = HARD_ZOMBIES_PER_WAVE;\n            currentZombieIncreasePercent = HARD_ZOMBIE_INCREASE_PERCENT;\n            currentZombieSpeedMultiplier = HARD_ZOMBIE_SPEED_MULTIPLIER;\n            \n            for (Zombie zombie : zombies) {\n                zombie.moveSpeed *= HARD_ZOMBIE_SPEED_MULTIPLIER / NORMAL_ZOMBIE_SPEED_MULTIPLIER;\n            }\n            \n            if (player != null) {\n                for (Weapon weapon : player.weapons) {\n                    weapon.updateForDifficulty(difficulty);\n                }\n            }\n        } else {\n            currentZombieSpawnRate = NORMAL_ZOMBIE_SPAWN_RATE;\n            currentZombiesPerWave = NORMAL_ZOMBIES_PER_WAVE;\n            currentZombieIncreasePercent = NORMAL_ZOMBIE_INCREASE_PERCENT;\n            currentZombieSpeedMultiplier = NORMAL_ZOMBIE_SPEED_MULTIPLIER;\n            \n            for (Zombie zombie : zombies) {\n                zombie.moveSpeed *= NORMAL_ZOMBIE_SPEED_MULTIPLIER / HARD_ZOMBIE_SPEED_MULTIPLIER;\n            }\n            \n            if (player != null) {\n                for (Weapon weapon : player.weapons) {\n                    weapon.updateForDifficulty(difficulty);\n                }\n            }\n        }\n        \n        // Update the timer if it exists\n        if (zombieSpawnTimer != null) {\n            zombieSpawnTimer.setDelay(currentZombieSpawnRate);\n        }\n    }\n\n    public void addZombie(Zombie zombie) {\n        zombies.add(zombie);\n        zombiesSpawned++;\n        updateZombiesRemaining(zombies.size());\n    }\n    \n    public void addDrop(Drop drop) {\n        drops.add(drop);\n    }\n\n    public void showGameOver() {\n        if (gameOverPanel != null) {\n            gameOverPanel.updateStats();\n            gameOverPanel.setVisible(true);\n        }\n    }\n\n    public void setSelectedCharacter(int characterNumber) {\n        this.selectedCharacter = characterNumber;\n    }\n    \n    public void restartGame() {\n        if (gameTimer != null && gameTimer.isRunning()) {\n            gameTimer.stop();\n        }\n        if (zombieSpawnTimer != null && zombieSpawnTimer.isRunning()) {\n            zombieSpawnTimer.stop();\n        }\n        if (currentDifficulty == GameDifficulty.HARD) {\n            currentZombieSpeedMultiplier = HARD_ZOMBIE_SPEED_MULTIPLIER;\n        } else {\n            currentZombieSpeedMultiplier = NORMAL_ZOMBIE_SPEED_MULTIPLIER;\n        }\n    \n        isPaused = false;\n\n        player = new Player(0, 0, selectedCharacter);\n        gamePanel.centerplayer();\n\n        gamePanel.moveUp = false;\n        gamePanel.moveDown = false;\n        gamePanel.moveLeft = false;\n        gamePanel.moveRight = false;\n        gamePanel.leftMousePressed = false;\n\n        player.weapons.clear();\n        player.weapons.add(new Pistol());\n        player.weapons.add(new Rifle());\n        player.weapons.add(new Shotgun());\n        player.weapons.add(new Sniper());\n        player.weapons.add(new RocketLauncher());\n        player.currentWeapon = player.weapons.get(0);\n        \n        if (currentDifficulty == GameDifficulty.HARD) {\n            for (Weapon weapon : player.weapons) {\n                weapon.updateForDifficulty(currentDifficulty);\n            }\n        }\n\n        currentWave = 1;\n        zombiesKilled = 0;\n        zombiesSpawned = 0;\n        zombiesKilledLastWave = 0;\n        zombies.clear();\n        bullets.clear();\n        drops.clear();\n        player.health = Player.PLAYER_HEALTH;\n\n        if (statPanel != null) {\n            statPanel.update();\n        }\n        \n        gameOverPanel.setVisible(false);\n\n        if (!gameTimer.isRunning()) {\n            gameTimer.start();\n        }\n        if (!zombieSpawnTimer.isRunning()) {\n            zombieSpawnTimer.start();\n        }\n        if (zombieSpawnTimer != null) {\n            zombieSpawnTimer.setDelay(currentZombieSpawnRate);\n        }\n    }\n\n    public boolean saveGame() {\n        try {\n            File saveDir = new File(\"saves\");\n            if (!saveDir.exists()) {\n                saveDir.mkdirs();\n            }\n            \n            FileOutputStream fileOut = new FileOutputStream(\"saves/zombieshot_save.dat\");\n            ObjectOutputStream out = new ObjectOutputStream(fileOut);\n            \n            // Create a game state object with only the necessary data\n            GameState state = new GameState();\n            \n            // Save basic game state\n            state.currentWave = this.currentWave;\n            state.selectedCharacter = this.selectedCharacter;\n            state.player = this.player;\n            state.zombies = new ArrayList<>(this.zombies);\n            state.bullets = new ArrayList<>(this.bullets);\n            state.drops = new ArrayList<>(this.drops);\n            state.zombiesKilled = this.zombiesKilled;\n            state.zombiesSpawned = this.zombiesSpawned;\n            state.zombiesKilledLastWave = this.zombiesKilledLastWave;\n            state.difficulty = this.currentDifficulty;\n            \n            // Save background itself instead of just the offset\n            if (gamePanel != null && gamePanel.background != null) {\n                state.background = gamePanel.background;\n            }\n            \n            out.writeObject(state);\n            out.close();\n            fileOut.close();\n            \n            return true;\n        } catch (IOException e) {\n            System.err.println(\"Error saving game: \" + e.getMessage());\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public boolean loadGame() {\n        try {\n            File saveFile = new File(\"saves/zombieshot_save.dat\");\n            if (!saveFile.exists()) {\n                return false;\n            }\n            \n            FileInputStream fileIn = new FileInputStream(saveFile);\n            ObjectInputStream in = new ObjectInputStream(fileIn);\n            \n            GameState state = (GameState) in.readObject();\n            in.close();\n            fileIn.close();\n            \n            // Stop any running timers\n            if (gameTimer != null && gameTimer.isRunning()) {\n                gameTimer.stop();\n            }\n            if (zombieSpawnTimer != null && zombieSpawnTimer.isRunning()) {\n                zombieSpawnTimer.stop();\n            }\n            \n            // Restore game state\n            this.currentWave = state.currentWave;\n            this.selectedCharacter = state.selectedCharacter;\n            this.player = state.player;\n            \n            // Ensure the player has its images loaded\n            this.player.loadImage();\n            this.gamePanel.centerplayer();\n            \n            // Clear and restore entities\n            this.zombies.clear();\n            this.zombies.addAll(state.zombies);\n\n            this.bullets.clear();\n            this.bullets.addAll(state.bullets);\n            \n            this.drops.clear();\n            this.drops.addAll(state.drops);\n            \n            this.zombiesKilled = state.zombiesKilled;\n            this.zombiesSpawned = state.zombiesSpawned;\n            this.zombiesKilledLastWave = state.zombiesKilledLastWave;\n            this.currentDifficulty = state.difficulty;\n\n            if (this.currentDifficulty == GameDifficulty.HARD) {\n                this.currentZombieSpeedMultiplier = HARD_ZOMBIE_SPEED_MULTIPLIER;\n            } else {\n                this.currentZombieSpeedMultiplier = NORMAL_ZOMBIE_SPEED_MULTIPLIER;\n            }\n            \n            for (Zombie zombie : this.zombies) {\n                if (state.difficulty == GameDifficulty.HARD) {\n                    zombie.moveSpeed *= HARD_ZOMBIE_SPEED_MULTIPLIER / NORMAL_ZOMBIE_SPEED_MULTIPLIER;\n                }\n            }\n            \n            // Restore background\n            if (gamePanel != null && state.background != null) {\n                gamePanel.background = state.background;\n            }\n            \n            // Update UI\n            if (statPanel != null) {\n                statPanel.update();\n            }\n            \n            // Start the timers\n            gameTimer.start();\n            zombieSpawnTimer.start();\n\n            isPaused = false;\n            gamePanel.requestFocus();\n            \n            return true;\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error loading game: \" + e.getMessage());\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public boolean saveSettings() {\n        try {\n            File saveDir = new File(\"saves\");\n            if (!saveDir.exists()) {\n                saveDir.mkdirs();\n            }\n            \n            FileOutputStream fileOut = new FileOutputStream(\"saves/settings.dat\");\n            ObjectOutputStream out = new ObjectOutputStream(fileOut);\n            \n            // Create a settings object with all settings\n            HashMap<String, Object> allSettings = new HashMap<>();\n            allSettings.put(\"keyBindings\", keyBindings);\n            allSettings.put(\"musicVolume\", MusicPlayer.getMusicVolume());\n            allSettings.put(\"sfxVolume\", MusicPlayer.getSfxVolume());\n    \n            // Save all settings\n            out.writeObject(allSettings);\n            out.close();\n            fileOut.close();\n            \n            return true;\n        } catch (IOException e) {\n            System.err.println(\"Error saving settings: \" + e.getMessage());\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public boolean loadSettings() {\n        try {\n            File keybindsFile = new File(\"saves/settings.dat\");\n            if (!keybindsFile.exists()) {\n                return false;\n            }\n            \n            FileInputStream fileIn = new FileInputStream(keybindsFile);\n            ObjectInputStream in = new ObjectInputStream(fileIn);\n            \n            // Load key bindings hashmap\n            HashMap<String, Object> allSettings = (HashMap<String, Object>) in.readObject();\n            in.close();\n            fileIn.close();\n        \n            if (allSettings != null) {\n                // Load key bindings\n                if (allSettings.containsKey(\"keyBindings\")) {\n                    keyBindings = (HashMap<String, Integer>) allSettings.get(\"keyBindings\");\n                }\n                \n                // Load music volume\n                if (allSettings.containsKey(\"musicVolume\")) {\n                    float savedVolume = (Float) allSettings.get(\"musicVolume\");\n                    MusicPlayer.setMusicVolume(savedVolume);\n                }\n\n                // Load sfx volume\n                if (allSettings.containsKey(\"sfxVolume\")) {\n                    float savedVolume = (Float) allSettings.get(\"sfxVolume\");\n                    MusicPlayer.setSfxVolume(savedVolume);\n                }\n                \n                return true;\n            }\n            return false;\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error loading settings: \" + e.getMessage());\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public int getKeyBinding(String action) {\n        return keyBindings.getOrDefault(action, 0);\n    }\n\n    public void setKeyBinding(String action, int keyCode) {\n        keyBindings.put(action, keyCode);\n    }\n\n    // The GameState class holds all serializable game data\n    private static class GameState implements Serializable {\n        private static final long serialVersionUID = 1L;\n        int currentWave;\n        int selectedCharacter;\n        Player player;\n        List<Zombie> zombies;\n        List<Bullet> bullets;\n        List<Drop> drops;\n        int zombiesKilled;\n        int zombiesSpawned;\n        int zombiesKilledLastWave;\n        Background background;\n        GameDifficulty difficulty;\n    }\n\n    public static void playSound(String soundPath) {\n        if (soundPath != null) {\n            new Thread(() -> {\n                AudioInputStream audioStream = null;\n                Clip clip = null;\n                try {\n                    audioStream = AudioSystem.getAudioInputStream(new File(soundPath));\n                    clip = AudioSystem.getClip();\n                    clip.open(audioStream);\n\n                    FloatControl gainControl = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);\n                    if (gainControl != null) {\n                        float dB = (float) (Math.log(MusicPlayer.getSfxVolume()) / Math.log(10.0) * 20.0);\n                        gainControl.setValue(dB);\n                    }\n\n                    // Add a listener to close resources when playback completes\n                    final Clip finalClip = clip;\n                    final AudioInputStream finalStream = audioStream;\n                    clip.addLineListener(event -> {\n                        if (event.getType() == LineEvent.Type.STOP) {\n                            finalClip.close();\n                            try {\n                                finalStream.close();\n                            } catch (IOException e) {\n                                System.err.println(\"Error closing audio stream: \" + e.getMessage());\n                            }\n                        }\n                    });\n                    \n                    clip.start();\n                } catch (UnsupportedAudioFileException | IOException | LineUnavailableException e) {\n                    System.err.println(\"Error playing sound: \" + e.getMessage());\n                    // Clean up resources in case of error\n                    if (clip != null) clip.close();\n                    if (audioStream != null) {\n                        try {\n                            audioStream.close();\n                        } catch (IOException ex) {\n                            System.err.println(\"Error closing audio stream: \" + ex.getMessage());\n                        }\n                    }\n                }\n            }).start();\n        }\n    }\n    \n    public void startBackgroundMusic() {\n        MusicPlayer.initializePlaylist(BACKGROUND_MUSIC_PATH);\n        MusicPlayer.playRandomMusic();\n    }\n\n    public void stopBackgroundMusic() {\n        MusicPlayer.stopBackgroundMusic();\n    }\n}\n",
      "NormalZombie.java": "public class NormalZombie extends Zombie {\n    public NormalZombie(int x, int y) {\n        super(x, y, 100, 0.7, 10, \"assets/Zombies/normal_zombie.png\", 50);\n    }\n}\n",
      "MainMenuPanel.java": "import java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.Image;\nimport javax.swing.JButton;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.SwingConstants;\nimport javax.swing.JOptionPane;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.FontMetrics;\nimport java.awt.RenderingHints;\n\npublic class MainMenuPanel extends JPanel {\n    private final int PANEL_WIDTH = GameFrame.WIDTH;\n    private final int PANEL_HEIGHT = GameFrame.HEIGHT;\n\n    protected GameInfo gameInfo;\n    private CharacterSelectionPanel characterSelectionPanel;\n    private JPanel mainMenuContentPanel;\n    protected boolean startGameAfterSelection = false;\n    private ControlsPanel controlsPanel;\n    private Image backgroundImage;\n    private boolean startInHardMode = false;\n\n    public MainMenuPanel(GameInfo gameInfo) {\n        this.gameInfo = gameInfo;\n        setPreferredSize(new Dimension(PANEL_WIDTH, PANEL_HEIGHT));\n        setLayout(null);\n        if (gameInfo.backgroundImage != null) {\n            backgroundImage = gameInfo.backgroundImage;\n        } else {\n            setBackground(new Color(32, 32, 32));\n        }\n\n        // Create main content panel\n        mainMenuContentPanel = new JPanel() {\n            @Override\n            protected void paintComponent(Graphics g) {\n                g.setColor(new Color(0, 0, 0, 0));\n                g.fillRect(0, 0, getWidth(), getHeight());\n                super.paintComponent(g);\n            }\n        };\n        mainMenuContentPanel.setLayout(null);\n        mainMenuContentPanel.setBounds(0, 0, PANEL_WIDTH, PANEL_HEIGHT);\n        mainMenuContentPanel.setOpaque(false);\n\n        // Main menu text with shadow\n        JLabel mainMenuLabel = new JLabel(GameFrame.GAME_TITLE) {\n            @Override\n            protected void paintComponent(Graphics g) {\n                Graphics2D g2d = (Graphics2D) g.create();\n                g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n                \n                // Draw shadow\n                g2d.setColor(new Color(0, 0, 0, 180));\n                g2d.setFont(getFont());\n                FontMetrics fm = g2d.getFontMetrics();\n                g2d.drawString(getText(), 4, fm.getAscent() + 4);\n                \n                // Draw text\n                g2d.setColor(getForeground());\n                g2d.drawString(getText(), 0, fm.getAscent());\n                \n                g2d.dispose();\n            }\n        };\n        mainMenuLabel.setForeground(Color.WHITE);\n        mainMenuLabel.setFont(new Font(\"Impact\", Font.BOLD, 72));\n        mainMenuLabel.setHorizontalAlignment(SwingConstants.LEFT);\n        mainMenuLabel.setBounds(50, PANEL_HEIGHT/4, PANEL_WIDTH - 100, 80);\n        mainMenuContentPanel.add(mainMenuLabel);\n\n        // Add Start New Game button\n        JButton startButton = UIUtils.createTransparentButtonWithIcon(\"Start New Game\", \"assets/Icons/play-button.png\");\n        startButton.setBounds(50, PANEL_HEIGHT/2 + 30, 350, 60);\n        startButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                startInHardMode = false;\n                showCharacterSelectionForStart();\n            }\n        });\n        mainMenuContentPanel.add(startButton);\n\n        // Add Start New Game+ button\n        JButton hardModeButton = UIUtils.createTransparentButtonWithIcon(\"Start New Game+\", \"assets/Icons/crowned-skull.png\");\n        hardModeButton.setBounds(50, PANEL_HEIGHT/2 + 100, 350, 60);\n        hardModeButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                startInHardMode = true;\n                showCharacterSelectionForStart();\n            }\n        });\n        mainMenuContentPanel.add(hardModeButton);\n\n        // Load Game button\n        JButton loadButton = UIUtils.createTransparentButtonWithIcon(\"Load Game\", \"assets/Icons/load.png\");\n        loadButton.setBounds(50, PANEL_HEIGHT/2 + 170, 250, 60);\n        loadButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                loadGame();\n            }\n        });\n        mainMenuContentPanel.add(loadButton);\n        \n        // Controls button\n        JButton controlsButton = UIUtils.createTransparentButtonWithIcon(\"Settings\", \"assets/Icons/retro-controller.png\");\n        controlsButton.setBounds(50, PANEL_HEIGHT/2 + 240, 250, 60);\n        controlsButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                showControlsScreen();\n            }\n        });\n        mainMenuContentPanel.add(controlsButton);\n        \n        // Exit button\n        JButton exitButton = UIUtils.createTransparentButtonWithIcon(\"Exit Game\", \"assets/Icons/power-button.png\");\n        exitButton.setBounds(50, PANEL_HEIGHT/2 + 310, 250, 60);\n        exitButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                exitGame();\n            }\n        });\n        mainMenuContentPanel.add(exitButton);\n\n        add(mainMenuContentPanel);\n\n        characterSelectionPanel = new CharacterSelectionPanel(gameInfo);\n        characterSelectionPanel.setBounds(0, 0, PANEL_WIDTH, PANEL_HEIGHT);\n        characterSelectionPanel.setVisible(false);\n        add(characterSelectionPanel);\n\n        controlsPanel = new ControlsPanel(this);\n        controlsPanel.setBounds(0, 0, PANEL_WIDTH, PANEL_HEIGHT);\n        controlsPanel.setVisible(false);\n        add(controlsPanel);\n\n        setVisible(true);\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        \n        if (backgroundImage != null) {\n            int imgWidth = backgroundImage.getWidth(this);\n            int imgHeight = backgroundImage.getHeight(this);\n            \n            // Calculate scaling factor to cover the entire panel\n            double scale = Math.max(\n                (double) getWidth() / imgWidth,\n                (double) getHeight() / imgHeight\n            );\n            \n            // Calculate new dimensions\n            int scaledWidth = (int) (imgWidth * scale);\n            int scaledHeight = (int) (imgHeight * scale);\n            \n            // Center the scaled image (excess will be cropped)\n            int x = (getWidth() - scaledWidth) / 2;\n            int y = (getHeight() - scaledHeight) / 2;\n            \n            g.drawImage(backgroundImage, x, y, scaledWidth, scaledHeight, this);\n        }\n    }\n\n    private void showCharacterSelectionForStart() {\n        startGameAfterSelection = true;\n        mainMenuContentPanel.setVisible(false);\n        characterSelectionPanel.setVisible(true);\n    }\n\n    public void showMainMenuContent() {\n        mainMenuContentPanel.setVisible(true);\n        characterSelectionPanel.setVisible(false);\n    }\n\n    void startGame() {\n        // Set difficulty before restarting\n        if (startInHardMode) {\n            gameInfo.setDifficulty(GameInfo.GameDifficulty.HARD);\n        } else {\n            gameInfo.setDifficulty(GameInfo.GameDifficulty.NORMAL);\n        }\n        \n        gameInfo.restartGame();\n        \n        setVisible(false);\n        gameInfo.gameOverPanel.setVisible(false);\n        gameInfo.pauseGamePanel.setVisible(false);\n        gameInfo.statPanel.setVisible(true);\n        gameInfo.gamePanel.setVisible(true);\n        gameInfo.gamePanel.requestFocus();\n    }\n\n    private void exitGame() {\n        MusicPlayer.dispose();\n        System.exit(0);\n    }\n\n    private void loadGame() {\n        boolean success = gameInfo.loadGame();\n        \n        if (success) {\n            setVisible(false);\n            gameInfo.gameOverPanel.setVisible(false);\n            gameInfo.pauseGamePanel.setVisible(false);\n            gameInfo.statPanel.setVisible(true);\n            gameInfo.gamePanel.setVisible(true);\n            \n            // Start game timers\n            if (gameInfo.gameTimer != null && !gameInfo.gameTimer.isRunning()) {\n                gameInfo.gameTimer.start();\n            }\n            if (gameInfo.zombieSpawnTimer != null && !gameInfo.zombieSpawnTimer.isRunning()) {\n                gameInfo.zombieSpawnTimer.start();\n            }\n            \n            gameInfo.gamePanel.requestFocus();\n        } else {\n            JOptionPane.showMessageDialog(this, \n                \"No saved game found or failed to load game!\", \n                \"Load Error\", \n                JOptionPane.ERROR_MESSAGE);\n        }\n    }\n\n    private void showControlsScreen() {\n        mainMenuContentPanel.setVisible(false);\n        controlsPanel.setVisible(true);\n    }\n}\n",
      "ControlsPanel.java": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.HashMap;\n\npublic class ControlsPanel extends JPanel {\n    private final int PANEL_WIDTH = GameFrame.WIDTH;\n    private final int PANEL_HEIGHT = GameFrame.HEIGHT;\n    private JButton backButton;\n    private MainMenuPanel parentPanel;\n    private GameInfo gameInfo;\n    private HashMap<String, JLabel> keyLabels = new HashMap<>();\n    private String awaitingRebind = null;\n    private Image backgroundImage;\n\n    public ControlsPanel(MainMenuPanel parentPanel) {\n        this.parentPanel = parentPanel;\n        this.gameInfo = parentPanel.gameInfo;\n        setPreferredSize(new Dimension(PANEL_WIDTH, PANEL_HEIGHT));\n        setLayout(null);\n        setFocusable(true);\n        \n        if (gameInfo.backgroundImage != null) {\n            backgroundImage = gameInfo.backgroundImage;\n        } else {\n            setBackground(new Color(32, 32, 32));\n        }\n\n        // Title\n        JLabel titleLabel = new JLabel(\"GAME SETTINGS\");\n        titleLabel.setForeground(Color.WHITE);\n        titleLabel.setFont(new Font(\"Impact\", Font.BOLD, 72));\n        titleLabel.setHorizontalAlignment(SwingConstants.CENTER);\n        titleLabel.setBounds(0, 50, PANEL_WIDTH, 80);\n        add(titleLabel);\n\n        // Create controls info panel\n        JPanel controlsInfoPanel = createControlsInfoPanel();\n        controlsInfoPanel.setBounds(PANEL_WIDTH/2 - 450, 150, 900, 850);\n        add(controlsInfoPanel);\n\n        // Back button - left-aligned like MainMenuPanel\n        int leftMargin = 50;\n        backButton = UIUtils.createTransparentButtonWithIcon(\"Back to Menu\", \"assets/Icons/house.png\");\n        backButton.setBounds(leftMargin, PANEL_HEIGHT - 100, 300, 60);\n        backButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                goBack();\n            }\n        });\n        add(backButton);\n\n        // Key input listener for rebinding\n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                if (awaitingRebind != null) {\n                    // Update the key binding\n                    gameInfo.setKeyBinding(awaitingRebind, e.getKeyCode());\n                    \n                    // Update the label\n                    JLabel keyLabel = keyLabels.get(awaitingRebind);\n                    if (keyLabel != null) {\n                        keyLabel.setText(KeyEvent.getKeyText(e.getKeyCode()));\n                    }\n                    \n                    // Reset the awaiting state\n                    awaitingRebind = null;\n                    \n                    // Update the visual state of all rebinding buttons\n                    updateRebindButtonStates();\n                }\n            }\n        });\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        \n        if (backgroundImage != null) {\n            int imgWidth = backgroundImage.getWidth(this);\n            int imgHeight = backgroundImage.getHeight(this);\n            \n            // Calculate scaling factor to cover the entire panel\n            double scale = Math.max(\n                (double) getWidth() / imgWidth,\n                (double) getHeight() / imgHeight\n            );\n            \n            // Calculate new dimensions\n            int scaledWidth = (int) (imgWidth * scale);\n            int scaledHeight = (int) (imgHeight * scale);\n            \n            // Center the scaled image (excess will be cropped)\n            int x = (getWidth() - scaledWidth) / 2;\n            int y = (getHeight() - scaledHeight) / 2;\n            \n            g.drawImage(backgroundImage, x, y, scaledWidth, scaledHeight, this);\n        }\n    }\n\n    private JPanel createControlsInfoPanel() {\n        JPanel mainPanel = new JPanel(new GridBagLayout());\n        mainPanel.setBackground(new Color(40, 40, 40));\n        mainPanel.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));\n\n        GridBagConstraints gbc = new GridBagConstraints();\n        gbc.fill = GridBagConstraints.BOTH;\n        gbc.insets = new Insets(10, 10, 10, 10);\n\n        // Movement section\n        gbc.gridx = 0;\n        gbc.gridy = 0;\n        gbc.weightx = 0.5;\n        gbc.weighty = 0.5;\n        mainPanel.add(createSectionPanel(\"Movement\", new String[][]{\n            {\"moveUp\", \"Move Up\"},\n            {\"moveDown\", \"Move Down\"},\n            {\"moveLeft\", \"Move Left\"},\n            {\"moveRight\", \"Move Right\"}\n        }), gbc);\n\n        // Combat section\n        gbc.gridx = 1;\n        gbc.gridy = 0;\n        mainPanel.add(createSectionPanel(\"Combat\", new String[][]{\n            {\"reload\", \"Reload Weapon\"}\n        }), gbc);\n\n        // Weapon Selection section\n        gbc.gridx = 0;\n        gbc.gridy = 1;\n        mainPanel.add(createSectionPanel(\"Weapon Selection\", new String[][]{\n            {\"weapon1\", \"Pistol\"},\n            {\"weapon2\", \"Rifle\"},\n            {\"weapon3\", \"Shotgun\"},\n            {\"weapon4\", \"Sniper\"},\n            {\"weapon5\", \"Rocket Launcher\"}\n        }), gbc);\n\n        // Game Controls section\n        gbc.gridx = 1;\n        gbc.gridy = 1;\n        mainPanel.add(createSectionPanel(\"Game Controls\", new String[][]{\n            {\"pause\", \"Pause Game\"},\n            {\"toggleFPS\", \"Toggle FPS Display\"},\n            {\"debug\", \"Toggle Debug Mode\"}\n        }), gbc);\n        \n        // Audio Controls section\n        gbc.gridx = 0;\n        gbc.gridy = 2;\n        gbc.gridwidth = 2;\n        mainPanel.add(createAudioControlsPanel(), gbc);\n\n        return mainPanel;\n    }\n\n    private JPanel createSectionPanel(String title, String[][] controls) {\n        JPanel sectionPanel = new JPanel();\n        sectionPanel.setLayout(new BorderLayout());\n        sectionPanel.setBackground(new Color(50, 50, 50));\n        sectionPanel.setBorder(BorderFactory.createCompoundBorder(\n            BorderFactory.createLineBorder(Color.GRAY, 2),\n            BorderFactory.createEmptyBorder(10, 15, 15, 15)\n        ));\n\n        // Section title\n        JLabel titleLabel = new JLabel(title);\n        titleLabel.setFont(new Font(\"Arial\", Font.BOLD, 26));\n        titleLabel.setForeground(Color.YELLOW);\n        titleLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 10, 0));\n        sectionPanel.add(titleLabel, BorderLayout.NORTH);\n\n        // Controls content\n        JPanel controlsContent = new JPanel();\n        controlsContent.setLayout(new GridLayout(controls.length, 1, 0, 5));\n        controlsContent.setBackground(new Color(50, 50, 50));\n\n        for (String[] control : controls) {\n            JPanel controlRow = new JPanel();\n            controlRow.setLayout(new BorderLayout(10, 0));\n            controlRow.setBackground(new Color(50, 50, 50));\n\n            // Create key label that shows the current binding\n            String action = control[0];\n            int keyCode = gameInfo.getKeyBinding(action);\n            JLabel keyLabel = new JLabel(KeyEvent.getKeyText(keyCode));\n            keyLabel.setFont(new Font(\"Courier New\", Font.BOLD, 18));\n            keyLabel.setForeground(Color.WHITE);\n            keyLabel.setBorder(BorderFactory.createCompoundBorder(\n                BorderFactory.createLineBorder(Color.GRAY),\n                BorderFactory.createEmptyBorder(5, 10, 5, 10)\n            ));\n            \n            // Store the label for later updates\n            keyLabels.put(action, keyLabel);\n            \n            // Ensure key label has consistent width\n            keyLabel.setPreferredSize(new Dimension(140, 36));\n            \n            // Add rebind button\n            JButton rebindButton = UIUtils.createTransparentButton(\"Rebind\", 16);\n            rebindButton.setPreferredSize(new Dimension(80, 36));\n            rebindButton.setActionCommand(action);\n            rebindButton.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    awaitingRebind = e.getActionCommand();\n                    keyLabel.setText(\"Press key...\");\n                    updateRebindButtonStates();\n                    requestFocus();\n                }\n            });\n            \n            JLabel actionLabel = new JLabel(control[1]);\n            actionLabel.setFont(new Font(\"Arial\", Font.PLAIN, 18));\n            actionLabel.setForeground(Color.WHITE);\n\n            // Use a panel to hold key label and rebind button\n            JPanel keyBindPanel = new JPanel(new BorderLayout(5, 0));\n            keyBindPanel.setBackground(new Color(50, 50, 50));\n            keyBindPanel.add(keyLabel, BorderLayout.CENTER);\n            keyBindPanel.add(rebindButton, BorderLayout.EAST);\n            \n            controlRow.add(keyBindPanel, BorderLayout.WEST);\n            controlRow.add(actionLabel, BorderLayout.CENTER);\n\n            controlsContent.add(controlRow);\n        }\n\n        sectionPanel.add(controlsContent, BorderLayout.CENTER);\n        return sectionPanel;\n    }\n    \n    private void updateRebindButtonStates() {\n        Component[] components = getComponents();\n        for (Component c : components) {\n            if (c instanceof JPanel) {\n                updateButtonsInContainer((Container)c);\n            }\n        }\n        \n        // Save keybindings when changes are made\n        if (gameInfo != null && awaitingRebind == null) {\n            gameInfo.saveSettings();\n        }\n    }\n    \n    private void updateButtonsInContainer(Container container) {\n        Component[] components = container.getComponents();\n        for (Component c : components) {\n            if (c instanceof JButton) {\n                JButton button = (JButton)c;\n                if (button.getText().equals(\"Rebind\")) {\n                    button.setEnabled(awaitingRebind == null);\n                }\n            } else if (c instanceof Container) {\n                updateButtonsInContainer((Container)c);\n            }\n        }\n    }\n\n    private void goBack() {\n        // Finalize any pending key rebinds\n        awaitingRebind = null;\n        setVisible(false);\n        parentPanel.showMainMenuContent();\n    }\n\n    private JPanel createAudioControlsPanel() {\n        JPanel audioPanel = new JPanel();\n        audioPanel.setLayout(new BorderLayout(10, 10));\n        audioPanel.setBorder(BorderFactory.createCompoundBorder(\n            BorderFactory.createLineBorder(Color.GRAY, 2),\n            BorderFactory.createEmptyBorder(10, 15, 15, 15)\n        ));\n        audioPanel.setBackground(new Color(50, 50, 50));\n\n        // Title\n        JLabel titleLabel = new JLabel(\"Audio Settings\");\n        titleLabel.setFont(new Font(\"Arial\", Font.BOLD, 26));\n        titleLabel.setForeground(Color.YELLOW);\n        titleLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 10, 0));\n        audioPanel.add(titleLabel, BorderLayout.NORTH);\n\n        // Content panel\n        JPanel controlsPanel = new JPanel();\n        controlsPanel.setLayout(new GridLayout(3, 1, 0, 20));\n        controlsPanel.setBackground(new Color(50, 50, 50));\n\n        // Music Volume slider row\n        JPanel musicVolumePanel = new JPanel();\n        musicVolumePanel.setLayout(new BorderLayout(10, 0));\n        musicVolumePanel.setBackground(new Color(50, 50, 50));\n\n        JLabel musicVolumeLabel = new JLabel(\"Music Volume:\");\n        musicVolumeLabel.setFont(new Font(\"Arial\", Font.BOLD, 18));\n        musicVolumeLabel.setForeground(Color.WHITE);\n        musicVolumePanel.add(musicVolumeLabel, BorderLayout.WEST);\n\n        // Current volume value as percentage\n        JLabel musicVolumeValueLabel = new JLabel(Math.round(MusicPlayer.getMusicVolume() * 100) + \"%\");\n        musicVolumeValueLabel.setFont(new Font(\"Courier New\", Font.BOLD, 18));\n        musicVolumeValueLabel.setForeground(Color.WHITE);\n        musicVolumeValueLabel.setPreferredSize(new Dimension(50, 30));\n        musicVolumePanel.add(musicVolumeValueLabel, BorderLayout.EAST);\n\n        // Slider\n        JSlider musicVolumeSlider = new JSlider(JSlider.HORIZONTAL, 0, 100, (int)(MusicPlayer.getMusicVolume() * 100));\n        musicVolumeSlider.setMajorTickSpacing(25);\n        musicVolumeSlider.setMinorTickSpacing(5);\n        musicVolumeSlider.setPaintTicks(true);\n        musicVolumeSlider.setBackground(new Color(50, 50, 50));\n        musicVolumeSlider.setForeground(Color.WHITE);\n        musicVolumeSlider.addChangeListener(e -> {\n            int value = musicVolumeSlider.getValue();\n            float volumeValue = value / 100f;\n            MusicPlayer.setMusicVolume(volumeValue);\n            musicVolumeValueLabel.setText(value + \"%\");\n            gameInfo.saveSettings();\n        });\n        musicVolumePanel.add(musicVolumeSlider, BorderLayout.CENTER);\n        \n        // Sound Effects Volume slider row\n        JPanel sfxVolumePanel = new JPanel();\n        sfxVolumePanel.setLayout(new BorderLayout(10, 0));\n        sfxVolumePanel.setBackground(new Color(50, 50, 50));\n\n        JLabel sfxVolumeLabel = new JLabel(\"SFX Volume:\");\n        sfxVolumeLabel.setFont(new Font(\"Arial\", Font.BOLD, 18));\n        sfxVolumeLabel.setForeground(Color.WHITE);\n        sfxVolumePanel.add(sfxVolumeLabel, BorderLayout.WEST);\n\n        // Current SFX volume value as percentage\n        JLabel sfxVolumeValueLabel = new JLabel(Math.round(MusicPlayer.getSfxVolume() * 100) + \"%\");\n        sfxVolumeValueLabel.setFont(new Font(\"Courier New\", Font.BOLD, 18));\n        sfxVolumeValueLabel.setForeground(Color.WHITE);\n        sfxVolumeValueLabel.setPreferredSize(new Dimension(50, 30));\n        sfxVolumePanel.add(sfxVolumeValueLabel, BorderLayout.EAST);\n\n        // SFX Slider\n        JSlider sfxVolumeSlider = new JSlider(JSlider.HORIZONTAL, 0, 100, (int)(MusicPlayer.getSfxVolume() * 100));\n        sfxVolumeSlider.setMajorTickSpacing(25);\n        sfxVolumeSlider.setMinorTickSpacing(5);\n        sfxVolumeSlider.setPaintTicks(true);\n        sfxVolumeSlider.setBackground(new Color(50, 50, 50));\n        sfxVolumeSlider.setForeground(Color.WHITE);\n        sfxVolumeSlider.addChangeListener(e -> {\n            int value = sfxVolumeSlider.getValue();\n            float volumeValue = value / 100f;\n            MusicPlayer.setSfxVolume(volumeValue);\n            sfxVolumeValueLabel.setText(value + \"%\");\n            gameInfo.saveSettings();\n        });\n        sfxVolumePanel.add(sfxVolumeSlider, BorderLayout.CENTER);\n\n        controlsPanel.add(musicVolumePanel);\n        controlsPanel.add(sfxVolumePanel);\n        audioPanel.add(controlsPanel, BorderLayout.CENTER);\n\n        return audioPanel;\n    }\n}",
      "Pistol.java": "import java.io.File;\n\npublic class Pistol extends Weapon {\n    public Pistol() {\n        super(0, 0, 120, 0, 20, 12, \"assets/WeaponSounds/Firing/pistol.wav\", \"assets/WeaponSounds/Reload/pistol.wav\");\n        this.appearanceImagePath = \"assets/Weapons/pistol.png\";\n        this.currentAmmo = 12;\n        this.currentTotalAmmo = Integer.MAX_VALUE;\n        setImage(new File(appearanceImagePath));\n    }\n}\n",
      "GamePanel.java": "import javax.swing.JPanel;\nimport javax.swing.Timer;\nimport java.awt.event.ActionEvent;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.color.ColorSpace;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseMotionAdapter;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.awt.image.ColorConvertOp;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.AlphaComposite;\nimport java.awt.Color;\nimport java.awt.RenderingHints;\nimport java.awt.BasicStroke;\n\npublic class GamePanel extends JPanel implements ActionListener {\n    private final int PANEL_WIDTH = GameFrame.WIDTH;\n    private final int PANEL_HEIGHT = GameFrame.HEIGHT - StatPanel.HEIGHT;\n    \n    // Performance optimization variables\n    private int targetFPS = 120;\n    private boolean showFPS = false;\n    private long lastFPSCheck = 0;\n    private int currentFPS = 0;\n    private int frameCount = 0;\n    private boolean useViewportCulling = true;\n    private int cullingMargin = 0;\n    private boolean useImageCaching = true;\n    \n    // Pre-compute flash images for performance\n    private ColorConvertOp flashEffect = new ColorConvertOp(ColorSpace.getInstance(ColorSpace.CS_GRAY), null);\n    private BufferedImage playerFlashImage = null;\n    private BufferedImage[] zombieFlashImages = new BufferedImage[4]; // One for each zombie type\n\n    private GameInfo gameInfo;\n    private int mouseX = PANEL_WIDTH / 2;\n    private int mouseY = PANEL_HEIGHT / 2;\n    private Random random = new Random();\n\n    protected Background background;\n    protected boolean moveUp = false;\n    protected boolean moveDown = false;\n    protected boolean moveLeft = false;\n    protected boolean moveRight = false;\n    protected boolean leftMousePressed = false;\n\n    public GamePanel(GameInfo gameInfo) {\n        this.gameInfo = gameInfo;\n        setPreferredSize(new Dimension(PANEL_WIDTH, PANEL_HEIGHT));\n        setBackground(Color.GRAY);\n        setFocusable(true);\n\n        background = new Background(\n            new String[]{\n                \"assets/Background/tile_0000.png\",\n                \"assets/Background/tile_0001.png\",\n                \"assets/Background/tile_0002.png\",\n                \"assets/Background/tile_0043.png\"\n            }, new String[]{\n                \"assets/Background/tile_0027.png\",\n                \"assets/Background/tile_0028.png\",\n            }\n        );\n\n        // Mouse motion listener for player rotation\n        addMouseMotionListener(new MouseMotionAdapter() {\n            public void mouseMoved(MouseEvent evt) {\n                updateMousePosition(evt);\n            }\n            \n            public void mouseDragged(MouseEvent evt) {\n                updateMousePosition(evt);\n            }\n            \n            private void updateMousePosition(MouseEvent evt) {\n                if (gameInfo.isPaused) {\n                    return;\n                }\n                mouseX = evt.getX();\n                mouseY = evt.getY();\n                \n                // Calculate angle for gun rotation\n                double angle = Math.atan2(mouseY - gameInfo.player.y - gameInfo.player.height/2, mouseX - gameInfo.player.x - gameInfo.player.width/2);\n                gameInfo.player.rotation = Math.toDegrees(angle);\n                \n                // Track facing direction for player flipping\n                gameInfo.player.facingLeft = (mouseX < gameInfo.player.getCenterX());\n                \n                repaint();\n            }\n        });\n\n        // Mouse click listener for shooting\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (e.getButton() == MouseEvent.BUTTON1) {\n                    leftMousePressed = true;\n                }\n            }\n\n            @Override\n            public void mouseReleased(MouseEvent e) {\n                if (e.getButton() == MouseEvent.BUTTON1) {\n                    leftMousePressed = false;\n                }\n            }\n        });\n\n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent evt) {\n                int keyCode = evt.getKeyCode();\n                \n                if (keyCode == gameInfo.getKeyBinding(\"moveUp\")) {\n                    moveUp = true;\n                } else if (keyCode == gameInfo.getKeyBinding(\"moveDown\")) {\n                    moveDown = true;\n                } else if (keyCode == gameInfo.getKeyBinding(\"moveLeft\")) {\n                    moveLeft = true;\n                } else if (keyCode == gameInfo.getKeyBinding(\"moveRight\")) {\n                    moveRight = true;\n                } else if (keyCode == gameInfo.getKeyBinding(\"reload\")) {\n                    gameInfo.player.reload();\n                    if (gameInfo.statPanel != null)\n                        gameInfo.statPanel.update();\n                } else if (keyCode == gameInfo.getKeyBinding(\"weapon1\")) {\n                    if (gameInfo.player.weapons.size() >= 1) {\n                        gameInfo.player.currentWeapon = gameInfo.player.weapons.get(0);\n                        if (gameInfo.statPanel != null)\n                            gameInfo.statPanel.update();\n                    }\n                } else if (keyCode == gameInfo.getKeyBinding(\"weapon2\")) {\n                    if (gameInfo.player.weapons.size() >= 2) {\n                        gameInfo.player.currentWeapon = gameInfo.player.weapons.get(1);\n                        if (gameInfo.statPanel != null)\n                            gameInfo.statPanel.update();\n                    }\n                } else if (keyCode == gameInfo.getKeyBinding(\"weapon3\")) {\n                    if (gameInfo.player.weapons.size() >= 3) {\n                        gameInfo.player.currentWeapon = gameInfo.player.weapons.get(2);\n                        if (gameInfo.statPanel != null)\n                            gameInfo.statPanel.update();\n                    }\n                } else if (keyCode == gameInfo.getKeyBinding(\"weapon4\")) {\n                    if (gameInfo.player.weapons.size() >= 4) {\n                        gameInfo.player.currentWeapon = gameInfo.player.weapons.get(3);\n                        if (gameInfo.statPanel != null)\n                            gameInfo.statPanel.update();\n                    }\n                } else if (keyCode == gameInfo.getKeyBinding(\"weapon5\")) {\n                    if (gameInfo.player.weapons.size() >= 5) {\n                        gameInfo.player.currentWeapon = gameInfo.player.weapons.get(4);\n                        if (gameInfo.statPanel != null)\n                            gameInfo.statPanel.update();\n                    }\n                } else if (keyCode == gameInfo.getKeyBinding(\"pause\")) {\n                    togglePause();\n                } else if (keyCode == gameInfo.getKeyBinding(\"debug\")) {\n                    background.toggleDebugMode();\n                } else if (keyCode == gameInfo.getKeyBinding(\"toggleFPS\")) {\n                    toggleFPSDisplay();\n                }\n            }\n\n            @Override\n            public void keyReleased(KeyEvent evt) {\n                int keyCode = evt.getKeyCode();\n                \n                if (keyCode == gameInfo.getKeyBinding(\"moveUp\")) {\n                    moveUp = false;\n                } else if (keyCode == gameInfo.getKeyBinding(\"moveDown\")) {\n                    moveDown = false;\n                } else if (keyCode == gameInfo.getKeyBinding(\"moveLeft\")) {\n                    moveLeft = false;\n                } else if (keyCode == gameInfo.getKeyBinding(\"moveRight\")) {\n                    moveRight = false;\n                }\n            }\n        });\n\n        centerplayer();\n        gameInfo.gameTimer = new Timer(16, this);\n        \n        // Zombie spawn timer\n        gameInfo.zombieSpawnTimer = new Timer(gameInfo.currentZombieSpawnRate, new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                spawnRandomZombie();\n            }\n        });\n        \n        updateTimerDelay();\n        requestFocus();\n    }\n\n    private void spawnRandomZombie() {\n        if (gameInfo.zombiesSpawned >= gameInfo.getMaxZombiesPerWave()) {\n            return;\n        }\n\n        // Avoid spawning too close to the player\n        int safeDistance = 200; // Minimum distance from player\n        int x, y;\n        double distance;\n        boolean validPosition;\n\n        do {\n            // Generate random position within panel\n            x = random.nextInt(PANEL_WIDTH - Zombie.ZOMBIE_WIDTH);\n            y = random.nextInt(PANEL_HEIGHT - Zombie.ZOMBIE_HEIGHT);\n\n            // Calculate distance from player center\n            double charCenterX = gameInfo.player.getCenterX();\n            double charCenterY = gameInfo.player.getCenterY();\n            double zombieCenterX = x + Zombie.ZOMBIE_WIDTH / 2;\n            double zombieCenterY = y + Zombie.ZOMBIE_HEIGHT / 2;\n            \n            double dx = charCenterX - zombieCenterX;\n            double dy = charCenterY - zombieCenterY;\n            distance = Math.sqrt(dx*dx + dy*dy);\n            \n            // Check if position is valid (not on an obstacle)\n            validPosition = background.isValidSpawnPosition(x, y, Zombie.ZOMBIE_WIDTH, Zombie.ZOMBIE_HEIGHT);\n            \n        } while (distance < safeDistance || !validPosition);\n\n        // Create and add the new zombie\n        int zombieVariety = 0;\n        if (gameInfo.currentWave <= 2) {\n            zombieVariety = 1;\n        } else if (gameInfo.currentWave <= 4) {\n            zombieVariety = 2;\n        } else if (gameInfo.currentWave <= 6) {\n            zombieVariety = 3;\n        } else {\n            zombieVariety = 4;\n        }\n        int randomNumber = random.nextInt(zombieVariety);\n        Zombie newZombie;\n\n        if (randomNumber == 0) {\n            newZombie = new NormalZombie(x, y);\n        } else if (randomNumber == 1) {\n            newZombie = new ReptileZombie(x, y);\n        } else if (randomNumber == 2) {\n            newZombie = new TankZombie(x, y);\n        } else {\n            newZombie = new AcidicZombie(x, y);\n        }\n\n        newZombie.moveSpeed *= gameInfo.currentZombieSpeedMultiplier;\n        gameInfo.addZombie(newZombie);\n    }\n\n    public void centerplayer() {\n        // Initial position at center of screen\n        int x = (PANEL_WIDTH / 2) - (gameInfo.player.width / 2);\n        int y = (PANEL_HEIGHT / 2) - (gameInfo.player.height / 2);\n        \n        // Check if this is a valid spawn position (not on an obstacle)\n        boolean validPosition = background.isValidSpawnPosition(x, y, gameInfo.player.width, gameInfo.player.height);\n        \n        // If the center position isn't valid, find a nearby valid position using a spiral search pattern\n        if (!validPosition) {\n            int searchRadius = 25;\n            int spiralX = 0;\n            int spiralY = 0;\n            int spiralDx = 0;\n            int spiralDy = -1;\n            \n            // Search up to 25 tile cells away (should be enough to find an empty spot)\n            for (int i = 0; i < searchRadius * searchRadius; i++) {\n                // Try the current position in the spiral\n                int testX = x + (spiralX * background.TILE_SIZE);\n                int testY = y + (spiralY * background.TILE_SIZE);\n                \n                if (background.isValidSpawnPosition(testX, testY, gameInfo.player.width, gameInfo.player.height)) {\n                    // Found a valid position\n                    x = testX;\n                    y = testY;\n                    validPosition = true;\n                    break;\n                }\n                \n                // Move to the next position in the spiral\n                if (spiralX == spiralY || (spiralX < 0 && spiralX == -spiralY) || (spiralX > 0 && spiralX == 1-spiralY)) {\n                    // Change direction when we hit a corner in the spiral\n                    int temp = spiralDx;\n                    spiralDx = -spiralDy;\n                    spiralDy = temp;\n                }\n                spiralX += spiralDx;\n                spiralY += spiralDy;\n            }\n            \n            // If we still couldn't find a valid position, use the original center (fallback)\n            // This is very unlikely but we should handle it anyway\n            if (!validPosition) {\n                x = (PANEL_WIDTH / 2) - (gameInfo.player.width / 2);\n                y = (PANEL_HEIGHT / 2) - (gameInfo.player.height / 2);\n            }\n        }\n        \n        // Set player position\n        gameInfo.player.x = x;\n        gameInfo.player.y = y;\n    }\n\n    private void shootBullet() {\n        Weapon currentWeapon = gameInfo.player.currentWeapon;\n\n        if (currentWeapon.isReloading) {\n            return;\n        }\n\n        currentWeapon.currentAmmo -= 1;\n        if (currentWeapon.currentAmmo < 0) {\n            currentWeapon.currentAmmo = 0;\n            return;\n        }\n        if (gameInfo.statPanel != null) {\n            gameInfo.statPanel.update();\n        }\n        double centerX = currentWeapon.getCenterX();\n        double centerY = currentWeapon.getCenterY();\n\n        if (currentWeapon instanceof Shotgun) {\n            int bulletCount = 9;\n            double spreadAngle = 5.0;\n            double startAngle = currentWeapon.rotation - (spreadAngle * (bulletCount - 1) / 2);\n            \n            for (int i = 0; i < bulletCount; i++) {\n                Bullet bullet = Bullet.Pool.getBullet(centerX, centerY, currentWeapon);\n                \n                // Calculate angle for this bullet\n                double bulletAngle = startAngle + (spreadAngle * i);\n                double angleRadians = Math.toRadians(bulletAngle);\n                \n                bullet.directionX = Math.cos(angleRadians);\n                bullet.directionY = Math.sin(angleRadians);\n                bullet.rotation = bulletAngle;\n                \n                gameInfo.bullets.add(bullet);\n            }\n        } else {\n            Bullet bullet = Bullet.Pool.getBullet(centerX, centerY, currentWeapon);\n\n            double shootingAngleOffset = 0;\n            if (currentWeapon != null) {\n                shootingAngleOffset = currentWeapon.shootingAngle;\n            }\n\n            // Generate random angle within the gun's shooting angle range\n            double randomSpread = random.nextDouble() * shootingAngleOffset - (shootingAngleOffset / 2);\n\n            // Apply the player rotation plus random spread\n            double finalAngle = currentWeapon.rotation + randomSpread;\n            double angleRadians = Math.toRadians(finalAngle);\n\n            bullet.directionX = Math.cos(angleRadians);\n            bullet.directionY = Math.sin(angleRadians);\n            bullet.rotation = finalAngle;\n\n            gameInfo.bullets.add(bullet);\n        }\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2d = (Graphics2D) g;\n        \n        // Apply rendering hints\n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n        g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);\n\n        // Draw the background\n        background.draw(g2d, PANEL_WIDTH, PANEL_HEIGHT, gameInfo.player);\n\n        AffineTransform originalTransform = g2d.getTransform();\n\n        // Calculate viewport bounds (what's visible on screen) with culling margin\n        int viewportMinX = -cullingMargin;\n        int viewportMinY = -cullingMargin;\n        int viewportMaxX = PANEL_WIDTH + cullingMargin;\n        int viewportMaxY = PANEL_HEIGHT + cullingMargin;\n\n        // Draw all drops - with culling\n        for (Drop drop : gameInfo.drops) {\n            if (!drop.isCollected() && isEntityVisible(drop, viewportMinX, viewportMinY, viewportMaxX, viewportMaxY)) {\n                if (drop.image != null) {\n                    g2d.drawImage(drop.image, (int)drop.x, (int)drop.y, \n                                 drop.width, drop.height, null);\n                } else {\n                    // Fallback if image fails to load\n                    g2d.setColor(Color.YELLOW);\n                    g2d.fillRect((int)drop.x, (int)drop.y, drop.width, drop.height);\n                }\n            }\n        }\n\n        // Draw player\n        if (gameInfo.player.image != null) {\n            AffineTransform transform = g2d.getTransform();\n            \n            // Create a new transform for drawing the player\n            AffineTransform playerTransform = new AffineTransform();\n            \n            // Apply player position and flipping\n            if (gameInfo.player.facingLeft) {\n                playerTransform.translate(gameInfo.player.x + gameInfo.player.width, gameInfo.player.y);\n                playerTransform.scale(-1, 1);\n            } else {\n                playerTransform.translate(gameInfo.player.x, gameInfo.player.y);\n            }\n            \n            g2d.setTransform(playerTransform);\n            \n            // Apply flash effect if player is flashing\n            if (gameInfo.player.isFlashing()) {\n                // Use pre-cached flash image if available, otherwise create it\n                if (playerFlashImage == null && useImageCaching) {\n                    playerFlashImage = flashEffect.filter(gameInfo.player.image, null);\n                }\n                \n                BufferedImage flashImage = useImageCaching ? playerFlashImage : flashEffect.filter(gameInfo.player.image, null);\n                g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));\n                g2d.drawImage(flashImage, 0, 0, gameInfo.player.width, gameInfo.player.height, null);\n            } else {\n                g2d.drawImage(gameInfo.player.image, 0, 0, gameInfo.player.width, gameInfo.player.height, null);\n            }\n            \n            g2d.setTransform(transform);\n        } else {\n            g2d.setColor(Color.RED);\n            g2d.fillRect((int)gameInfo.player.x, (int)gameInfo.player.y, 50, 50);\n        }\n        drawCooldownBar(g2d);\n        drawReloadingBar(g2d);\n\n        // Draw the gun\n        gameInfo.player.updateGunPosition();\n        if (gameInfo.player.currentWeapon != null && gameInfo.player.currentWeapon.image != null) {\n            AffineTransform gunTransform = new AffineTransform();\n            \n            // First translate to player center\n            double playerCenterX = gameInfo.player.getCenterX();\n            double playerCenterY = gameInfo.player.getCenterY();\n            \n            // Calculate gun offset from player center\n            double gunOffsetX = gameInfo.player.width/2; // Offset from player center\n            \n            // Apply rotation around player center\n            // Add 45-degree offset to compensate for tilted weapon image\n            double weaponAngleOffset = Math.toRadians(45);\n            double angleRad = Math.toRadians(gameInfo.player.currentWeapon.rotation) + weaponAngleOffset;\n            \n            // Calculate gun position after rotation\n            double rotatedGunX = playerCenterX + Math.cos(angleRad) * gunOffsetX - gameInfo.player.currentWeapon.width/2;\n            \n            // Update gun position\n            gameInfo.player.currentWeapon.x = rotatedGunX;\n            gameInfo.player.currentWeapon.y = gameInfo.player.getCenterY() - gameInfo.player.currentWeapon.height/2;\n            \n            boolean facingLeft = mouseX < gameInfo.player.getCenterX();\n            if (facingLeft) {\n                angleRad += Math.toRadians(-90);\n            }\n            gunTransform.rotate(angleRad, playerCenterX, playerCenterY);\n            \n            if (facingLeft) {\n                gunTransform.scale(1, -1);\n                gunTransform.translate(0, -2 * gameInfo.player.currentWeapon.y - gameInfo.player.currentWeapon.height);\n            }\n\n            g2d.setTransform(gunTransform);\n\n            g2d.drawImage(gameInfo.player.currentWeapon.image, (int)gameInfo.player.currentWeapon.x, (int)gameInfo.player.currentWeapon.y, \n                         gameInfo.player.currentWeapon.width, gameInfo.player.currentWeapon.height, null);\n        }\n        g2d.setTransform(originalTransform);\n\n        // Draw all bullets - with culling\n        for (Bullet bullet : gameInfo.bullets) {\n            if (isEntityVisible(bullet, viewportMinX, viewportMinY, viewportMaxX, viewportMaxY)) {\n                if (bullet.image != null) {\n                    // Create rotation transform for the bullet\n                    AffineTransform bulletTransform = new AffineTransform();\n                    bulletTransform.rotate(Math.toRadians(bullet.rotation), bullet.getCenterX(), bullet.getCenterY());\n                    g2d.setTransform(bulletTransform);\n\n                    g2d.drawImage(bullet.image, (int)bullet.x, (int)bullet.y, \n                                 bullet.width, bullet.height, null);\n\n                    // Reset transform after drawing each bullet\n                    g2d.setTransform(originalTransform);\n                } else {\n                    // Fallback if bullet image fails to load\n                    g2d.setColor(Color.BLUE);\n                    g2d.fillOval((int)bullet.x, (int)bullet.y, bullet.width, bullet.height);\n                }\n            }\n        }\n\n        // Draw all zombies - with culling\n        for (Zombie zombie : gameInfo.zombies) {\n            if (isEntityVisible(zombie, viewportMinX, viewportMinY, viewportMaxX, viewportMaxY)) {\n                if (zombie.image != null) {\n                    AffineTransform transform = g2d.getTransform();\n                    AffineTransform zombieTransform = new AffineTransform();\n                    \n                    if (zombie.directionX < 0) {\n                        zombieTransform.translate(zombie.x + zombie.width, zombie.y);\n                        zombieTransform.scale(-1, 1);\n                    } else {\n                        zombieTransform.translate(zombie.x, zombie.y);\n                    }\n                    \n                    g2d.setTransform(zombieTransform);\n                    \n                    // Apply flash effect if zombie is flashing\n                    if (zombie.isFlashing()) {\n                        // Get zombie type to use appropriate cached image\n                        int zombieType = getZombieTypeIndex(zombie);\n                        \n                        // Use pre-cached flash image if available, otherwise create it\n                        if (useImageCaching && zombieFlashImages[zombieType] == null) {\n                            zombieFlashImages[zombieType] = flashEffect.filter(zombie.image, null);\n                        }\n                        \n                        BufferedImage flashImage = useImageCaching ? \n                            zombieFlashImages[zombieType] : flashEffect.filter(zombie.image, null);\n                        \n                        g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));\n                        g2d.drawImage(flashImage, 0, 0, zombie.width, zombie.height, null);\n                    } else {\n                        g2d.drawImage(zombie.image, 0, 0, zombie.width, zombie.height, null);\n                    }\n                    \n                    g2d.setTransform(transform);\n                    drawHealthBar(g2d, zombie);\n                }\n            }\n        }\n\n        // Draw all active animations - with culling\n        for (Animation animation : gameInfo.animations) {\n            if (isEntityVisible(animation, viewportMinX-animation.getWidth(), viewportMinY-animation.getHeight(), viewportMaxX+animation.getWidth(), viewportMaxY+animation.getHeight())) {\n                animation.draw(g2d);\n            }\n        }\n        \n        // Draw lines from player to zombies\n        drawZombieIndicators(g2d);\n        \n        // Display FPS if enabled\n        if (showFPS) {\n            // Calculate FPS\n            frameCount++;\n            long currentTime = System.currentTimeMillis();\n            double updateInterval = 1000;\n            if (currentTime - lastFPSCheck >= updateInterval) {\n                currentFPS = (int) (frameCount * 1000 / updateInterval);\n                frameCount = 0;\n                lastFPSCheck = currentTime;\n            }\n            \n            // Draw FPS counter\n            g2d.setColor(Color.WHITE);\n            g2d.setFont(new Font(\"Arial\", Font.BOLD, 14));\n            g2d.drawString(\"FPS: \" + currentFPS, PANEL_WIDTH - 100, 20);\n        }\n    }\n    \n    // Helper method to determine zombie type for caching\n    private int getZombieTypeIndex(Zombie zombie) {\n        if (zombie instanceof NormalZombie) return 0;\n        if (zombie instanceof ReptileZombie) return 1;\n        if (zombie instanceof TankZombie) return 2;\n        if (zombie instanceof AcidicZombie) return 3;\n        return 0; // Default to normal zombie\n    }\n    \n    // Helper method for viewport culling\n    private boolean isEntityVisible(Entity entity, int minX, int minY, int maxX, int maxY) {\n        if (!useViewportCulling) return true;\n        \n        return entity.x + entity.width >= minX && entity.x <= maxX &&\n               entity.y + entity.height >= minY && entity.y <= maxY;\n    }\n\n    // Game update loop\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        if (gameInfo.isPaused) {\n            return;\n        }\n\n        if (gameInfo.player.health <= 0) {\n            gameInfo.player.health = 0;\n            gameInfo.gameTimer.stop();\n            gameInfo.zombieSpawnTimer.stop();\n            gameInfo.showGameOver();\n            return;\n        }\n\n        Weapon currentWeapon = gameInfo.player.currentWeapon;\n\n        if (leftMousePressed && currentWeapon.canShoot()) {\n            shootBullet();\n            currentWeapon.shoot();\n        }\n\n        // Handle player movement\n        double horizontalMovement = 0;\n        double verticalMovement = 0;\n        \n        Player player = gameInfo.player;\n        if (moveUp) verticalMovement -= player.moveSpeed;\n        if (moveDown) verticalMovement += player.moveSpeed;\n        if (moveLeft) horizontalMovement -= player.moveSpeed;\n        if (moveRight) horizontalMovement += player.moveSpeed;\n\n        // Set player animation state based on movement\n        boolean isMoving = (horizontalMovement != 0 || verticalMovement != 0);\n        gameInfo.player.setMoving(isMoving);\n        gameInfo.player.updateAnimation();\n\n        // Normalize the direction vector\n        double movementLength = Math.sqrt(horizontalMovement * horizontalMovement + verticalMovement * verticalMovement);\n        if (movementLength > 0) {\n            horizontalMovement /= movementLength;\n            verticalMovement /= movementLength;\n        }\n        if (horizontalMovement != 0 || verticalMovement != 0) {\n            // Try to update the background position with collision detection\n            boolean moveSuccessful = background.update(horizontalMovement * player.moveSpeed, \n                                                      verticalMovement * player.moveSpeed,\n                                                        gameInfo.player.height);\n            \n            // Only move entities if the player's move was successful\n            if (moveSuccessful) {\n                for (Entity entity : Entity.entities) {\n                    if (entity instanceof Player || entity instanceof Weapon) {\n                        continue;\n                    }\n                    entity.x -= horizontalMovement * GameInfo.PLAYER_SPEED;\n                    entity.y -= verticalMovement * GameInfo.PLAYER_SPEED;\n                }\n            }\n        }\n        \n        // Update bullet positions\n        List<Bullet> bulletsToRemove = new ArrayList<>();\n        List<Zombie> zombiesToRemove = new ArrayList<>();\n        List<Drop> dropsToRemove = new ArrayList<>();\n        List<Animation> animationsToRemove = new ArrayList<>();\n\n        for (Bullet bullet : gameInfo.bullets) {\n            // Move bullet in its direction\n            bullet.x += bullet.directionX * bullet.moveSpeed;\n            bullet.y += bullet.directionY * bullet.moveSpeed;\n            \n            // Remove bullets that go off screen\n            if (bullet.x < -PANEL_WIDTH * 0.2 || bullet.x > PANEL_WIDTH*1.2 || bullet.y < -PANEL_HEIGHT * 0.2 || bullet.y > PANEL_HEIGHT*1.2) {\n                bulletsToRemove.add(bullet);\n                continue;\n            }\n\n            if (bullet.isZombieBullet()) {\n                // Check collision with player\n                if (bullet.getBounds().intersects(gameInfo.player.getBounds())) {\n                    gameInfo.player.health -= bullet.getDamage();\n                    gameInfo.player.startFlashEffect();\n                    if (gameInfo.statPanel != null) {\n                        gameInfo.statPanel.update();\n                    }\n                    bulletsToRemove.add(bullet);\n                }\n            } else {\n                for (Zombie zombie : gameInfo.zombies) {\n                    if (!bullet.hitZombies.contains(zombie) && bullet.getBounds().intersects(zombie.getBounds())) {\n                        if (bullet.getSourceWeapon() instanceof RocketLauncher) {\n                            GameInfo.playSound(((RocketLauncher)bullet.getSourceWeapon()).hitSoundPath);\n                            applyBlastDamageToZombies(zombiesToRemove, bullet, zombie, RocketLauncher.BLAST_RADIUS);\n\n                            // Create an explosion\n                            int explosionSize = (int) (RocketLauncher.BLAST_RADIUS * 1.5);\n                            Animation RPGExplosion = new Animation(\n                                zombie.getCenterX() - explosionSize/2,\n                                zombie.getCenterY() - explosionSize/2,\n                                explosionSize, explosionSize, 50, false, \"RPGExplosion\");\n                            RPGExplosion.loadFrames(\"assets/Explosion/RPG\");\n                            gameInfo.animations.add(RPGExplosion);\n                        } else {\n                            zombie.health -= bullet.getDamage();\n                            zombie.startFlashEffect();\n                            if (zombie.health <= 0) {\n                                zombiesToRemove.add(zombie);\n                                gameInfo.player.kills++;\n                                gameInfo.player.score += zombie.score;                \n                                createLootDrop(zombie);\n                                if (zombie instanceof AcidicZombie) {\n                                    Animation blastAnimation = new Animation(\n                                        zombie.getCenterX() - AcidicZombie.BLAST_RADIUS/2,\n                                        zombie.getCenterY() - AcidicZombie.BLAST_RADIUS/2,\n                                        AcidicZombie.BLAST_RADIUS, AcidicZombie.BLAST_RADIUS, 50, false, \"AcidicZombieExplosion\");\n                                    blastAnimation.loadFrames(\"assets/Explosion/AcidicZombie\");\n                                    gameInfo.animations.add(blastAnimation);\n                                    applyBlastDamageToZombies(zombiesToRemove, bullet, zombie, AcidicZombie.BLAST_RADIUS);\n                                }\n                            }\n                            bullet.hitZombies.add(zombie);\n                        }\n                        if (!(bullet.getSourceWeapon() instanceof Sniper)) {\n                            bulletsToRemove.add(bullet);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Update zombie positions\n        for (Zombie zombie : gameInfo.zombies) {\n            // Calculate direction vector from zombie to player\n            double zombieCenterX = zombie.getCenterX();\n            double zombieCenterY = zombie.getCenterY();\n            double charCenterX = gameInfo.player.getCenterX();\n            double charCenterY = gameInfo.player.getCenterY();\n\n            // Direction vector\n            double dx = charCenterX - zombieCenterX;\n            double dy = charCenterY - zombieCenterY;\n\n            // Normalize the direction vector\n            double length = Math.sqrt(dx * dx + dy * dy);\n            if (length > 0) {\n                dx /= length;\n                dy /= length;\n            }\n    \n            double distanceToplayer = length;\n\n            // Check if the zombie can hit the player\n            if (distanceToplayer < zombie.attackRange && zombie.canAttack()) {\n                if (zombie instanceof AcidicZombie) {\n                    AcidicZombie acidicZombie = (AcidicZombie)zombie;\n                    Bullet acidBullet = acidicZombie.shootAcid(charCenterX, charCenterY);\n                    gameInfo.bullets.add(acidBullet);\n                } else {\n                    gameInfo.player.health -= zombie.damage;\n                    gameInfo.player.startFlashEffect();\n                    if (gameInfo.statPanel != null) {\n                        gameInfo.statPanel.update();\n                    }\n                    zombie.attack();\n                }\n            }\n\n            // Update zombie positions\n            if (zombie instanceof ReptileZombie) {\n                ReptileZombie reptileZombie = (ReptileZombie)zombie;\n                \n                if (distanceToplayer < ReptileZombie.JUMP_DISTANCE) {\n                    if (!reptileZombie.isJumping && reptileZombie.canJump()) {\n                        reptileZombie.prepareJump(charCenterX, charCenterY);\n                    }\n                }\n\n                if (reptileZombie.isJumping) {\n                    double moveX = reptileZombie.jumpDirectionX * reptileZombie.moveSpeed * ReptileZombie.JUMP_SPEED;\n                    double moveY = reptileZombie.jumpDirectionY * reptileZombie.moveSpeed * ReptileZombie.JUMP_SPEED;\n                    \n                    // Check if move is valid before applying it\n                    if (background.isValidMoveForEntity(zombie.x, zombie.y, moveX, moveY, zombie.width, zombie.height)) {\n                        reptileZombie.updateJump();\n                    } else {\n                        // If movement is blocked, stop jumping and try normal movement next frame\n                        reptileZombie.isJumping = false;\n                    }\n                } else if (zombie.canMoveCloser(distanceToplayer)) {\n                    double moveX = dx * zombie.moveSpeed;\n                    double moveY = dy * zombie.moveSpeed;\n                    \n                    // Check if move is valid before applying it\n                    if (background.isValidMoveForEntity(zombie.x, zombie.y, moveX, moveY, zombie.width, zombie.height)) {\n                        zombie.x += moveX;\n                        zombie.y += moveY;\n                    } else {\n                        // Try to slide along walls by attempting to move in just X or Y direction\n                        if (background.isValidMoveForEntity(zombie.x, zombie.y, moveX, 0, zombie.width, zombie.height)) {\n                            zombie.x += moveX;\n                        } else if (background.isValidMoveForEntity(zombie.x, zombie.y, 0, moveY, zombie.width, zombie.height)) {\n                            zombie.y += moveY;\n                        }\n                    }\n                }\n            } else if (zombie.canMoveCloser(distanceToplayer)) {\n                double moveX = dx * zombie.moveSpeed;\n                double moveY = dy * zombie.moveSpeed;\n                \n                // Check if move is valid before applying it\n                if (background.isValidMoveForEntity(zombie.x, zombie.y, moveX, moveY, zombie.width, zombie.height)) {\n                    zombie.x += moveX;\n                    zombie.y += moveY;\n                } else {\n                    // Try to slide along walls by attempting to move in just X or Y direction\n                    if (background.isValidMoveForEntity(zombie.x, zombie.y, moveX, 0, zombie.width, zombie.height)) {\n                        zombie.x += moveX;\n                    } else if (background.isValidMoveForEntity(zombie.x, zombie.y, 0, moveY, zombie.width, zombie.height)) {\n                        zombie.y += moveY;\n                    }\n                }\n            }\n\n            // Store direction for flipping in the renderer\n            zombie.directionX = dx;\n            zombie.directionY = dy;\n        }\n\n        for (Drop drop : gameInfo.drops) {\n            if (!drop.isCollected() && gameInfo.player.getBounds().intersects(drop.getBounds())) {\n                if (drop instanceof HealthDrop) {\n                    HealthDrop healthDrop = (HealthDrop)drop;\n                    if (gameInfo.player.health < Player.PLAYER_HEALTH) {\n                        drop.collect();\n                        dropsToRemove.add(drop);\n                        \n                        if (gameInfo.player.health <= Player.PLAYER_HEALTH - healthDrop.getHealthAmount()) {\n                            gameInfo.player.health += healthDrop.getHealthAmount();\n                        } else {\n                            gameInfo.player.health = Player.PLAYER_HEALTH;\n                        }\n                    }\n                } else {\n                    drop.collect();\n                    dropsToRemove.add(drop);\n\n                    if (drop instanceof AmmoDrop) {\n                        AmmoDrop weaponDrop = (AmmoDrop)drop;\n\n                        int ammoToAdd = weaponDrop.getAmmoAmount();\n                        Weapon sourceWeapon = weaponDrop.getSourceWeapon();\n\n                        for (Weapon playerWeapon : gameInfo.player.weapons) {\n                            if (playerWeapon != null && playerWeapon.getClass().equals(sourceWeapon.getClass())) {\n                                if (playerWeapon instanceof RocketLauncher) {\n                                    playerWeapon.currentAmmo += ammoToAdd;\n                                } else {                    \n                                    if (playerWeapon.currentTotalAmmo <= Integer.MAX_VALUE - ammoToAdd) {\n                                        playerWeapon.currentTotalAmmo += ammoToAdd;\n                                    } else {\n                                        playerWeapon.currentTotalAmmo = Integer.MAX_VALUE;\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n     \n                // Update the stats panel\n                if (gameInfo.statPanel != null) {\n                    gameInfo.statPanel.update();\n                }\n            }\n        }\n\n        for (Animation animation : gameInfo.animations) {\n            if (!animation.update()) {\n                animationsToRemove.add(animation);\n            }\n        }\n\n        // Remove animations that have finished\n        gameInfo.animations.removeAll(animationsToRemove);\n\n        // Remove bullets that are off screen or have hit something\n        for (Bullet bullet : bulletsToRemove) {\n            gameInfo.bullets.remove(bullet);\n            Bullet.Pool.returnBullet(bullet);\n        }\n\n        // Remove zombies that were hit\n        for (Zombie zombie : zombiesToRemove) {\n            gameInfo.zombies.remove(zombie);\n        }\n\n        // Remove collected drops\n        gameInfo.drops.removeAll(dropsToRemove);\n\n        // Update zombies killed count\n        gameInfo.zombiesKilled += zombiesToRemove.size();\n        \n        // Update zombies remaining count\n        gameInfo.updateZombiesRemaining(gameInfo.zombies.size());\n        \n        // Check if we need to advance to the next wave\n        gameInfo.incrementWaveIfNeeded();\n\n        repaint();\n    }\n\n    private void applyBlastDamageToZombies(List<Zombie> zombiesToRemove, Bullet bullet, Zombie sourceZombie, double blastRadius) {\n        for (Zombie targetZombie : gameInfo.zombies) {\n            if (zombiesToRemove.contains(targetZombie)) {\n                continue;\n            }\n            double dx = targetZombie.getCenterX() - sourceZombie.getCenterX();\n            double dy = targetZombie.getCenterY() - sourceZombie.getCenterY();\n            double distance = Math.sqrt(dx * dx + dy * dy);\n            if (distance < blastRadius) {\n                targetZombie.health -= bullet.getDamage();\n                targetZombie.startFlashEffect();\n                if (targetZombie.health <= 0) {\n                    zombiesToRemove.add(targetZombie);\n                    gameInfo.player.kills++;\n                    gameInfo.player.score += targetZombie.score;    \n                    createLootDrop(targetZombie);\n                    if (targetZombie instanceof AcidicZombie) {\n                        Animation blastAnimation = new Animation(\n                            sourceZombie.getCenterX() - blastRadius/2,\n                            sourceZombie.getCenterY() - blastRadius/2,\n                            (int)blastRadius, (int)blastRadius, 50, false, \"AcidicZombieExplosion\");\n                        blastAnimation.loadFrames(\"assets/Explosion/AcidicZombie\");\n                        gameInfo.animations.add(blastAnimation);\n                        applyBlastDamageToZombies(zombiesToRemove, bullet, sourceZombie, AcidicZombie.BLAST_RADIUS);\n                    }\n                }\n                bullet.hitZombies.add(sourceZombie);\n            }\n        }\n    }\n\n    private void createLootDrop(Zombie zombie) {\n        if (random.nextFloat() < GameInfo.HEALTH_DROP_CHANCE) {\n            HealthDrop healthDrop = new HealthDrop(zombie.getCenterX(), zombie.getCenterY());\n            gameInfo.addDrop(healthDrop);\n        } else if (random.nextFloat() < GameInfo.AMMO_DROP_CHANCE) {\n            Weapon randomWeapon;\n            int randomWeaponVariety;\n            if (gameInfo.currentWave == 1) {\n                randomWeaponVariety = -1;\n            } else if (gameInfo.currentWave <= 3) {\n                randomWeaponVariety = 1;\n            } else if (gameInfo.currentWave <= 5) {\n                randomWeaponVariety = 2;\n            } else if (gameInfo.currentWave <= 10) {\n                randomWeaponVariety = 3;\n            } else {\n                randomWeaponVariety = 4;\n            }\n            if (randomWeaponVariety != -1) {\n                int randomWeaponNumber = random.nextInt(randomWeaponVariety);\n                if (randomWeaponNumber == 0) {\n                    randomWeapon = new Rifle();\n                } else if (randomWeaponNumber == 1) {\n                    randomWeapon = new Shotgun();\n                } else if (randomWeaponNumber == 2) {\n                    randomWeapon = new Sniper();\n                } else {\n                    randomWeapon = new RocketLauncher();\n                }\n                AmmoDrop ammoDrop = new AmmoDrop(zombie.getCenterX(), zombie.getCenterY(), randomWeapon, gameInfo);\n                gameInfo.addDrop(ammoDrop);\n            }\n        }\n    }\n\n    private void drawHealthBar(Graphics2D g2d, Zombie zombie) {\n        // Health bar dimensions and position\n        int barWidth = zombie.width;\n        int barHeight = 5;\n        int barX = (int)zombie.x;\n        int barY = (int)zombie.y - 10;\n        \n        // Draw background (empty health bar)\n        g2d.setColor(Color.DARK_GRAY);\n        g2d.fillRect(barX, barY, barWidth, barHeight);\n        \n        // Calculate filled portion based on health percentage\n        double healthPercentage = (double)zombie.health / zombie.maxHealth;\n        int filledWidth = (int)(barWidth * healthPercentage);\n        \n        // Choose color based on health percentage or flash white if being hit\n        if (zombie.isFlashing()) {\n            g2d.setColor(Color.WHITE);\n        } else if (healthPercentage > 0.66) {\n            g2d.setColor(Color.GREEN);\n        } else if (healthPercentage > 0.33) {\n            g2d.setColor(Color.ORANGE);\n        } else {\n            g2d.setColor(Color.RED);\n        }\n        \n        // Draw filled portion\n        g2d.fillRect(barX, barY, filledWidth, barHeight);\n        \n        // Draw border\n        g2d.setColor(Color.BLACK);\n        g2d.drawRect(barX, barY, barWidth, barHeight);\n    }\n\n    private void drawCooldownBar(Graphics2D g2d) {\n        Weapon currentWeapon = gameInfo.player.currentWeapon;\n        if (!currentWeapon.isReloading && !currentWeapon.canShoot() && currentWeapon.currentAmmo > 0) {\n            long currentTime = System.currentTimeMillis();\n            long lastShotTime = currentWeapon.lastShotTime;\n\n            double elapsedTime = currentTime - lastShotTime;\n            double cooldownPercentage = Math.min(1.0, elapsedTime / currentWeapon.fireDelay);\n\n            int barWidth = gameInfo.player.width;\n            int barHeight = 5;\n            int barX = (int)gameInfo.player.x;\n            int barY = (int)gameInfo.player.y - 15;\n            \n            g2d.setColor(Color.DARK_GRAY);\n            g2d.fillRect(barX, barY, barWidth, barHeight);\n            \n            int filledWidth = (int)(barWidth * cooldownPercentage);\n            \n            g2d.setColor(new Color(30, 144, 255));\n            g2d.fillRect(barX, barY, filledWidth, barHeight);\n            \n            g2d.setColor(Color.BLACK);\n            g2d.drawRect(barX, barY, barWidth, barHeight);\n        }\n    }\n\n    private void drawReloadingBar(Graphics2D g2d) {\n        Weapon currentWeapon = gameInfo.player.currentWeapon;\n        \n        // Only show when player is reloading\n        if (currentWeapon.isReloading) {\n            long currentTime = System.currentTimeMillis();\n            long reloadStartTime = currentWeapon.reloadStartTime;\n            long reloadTime = currentWeapon.reloadTimeMs;\n\n            double elapsedTime = currentTime - reloadStartTime;\n            double reloadPercentage = Math.min(1.0, elapsedTime / reloadTime);\n\n            int barWidth = gameInfo.player.width;\n            int barHeight = 5;\n            int barX = (int)gameInfo.player.x;\n            int barY = (int)gameInfo.player.y - 25; // Position above cooldown bar\n            \n            // Draw background (empty reload bar)\n            g2d.setColor(Color.DARK_GRAY);\n            g2d.fillRect(barX, barY, barWidth, barHeight);\n            \n            // Draw filled portion\n            int filledWidth = (int)(barWidth * reloadPercentage);\n            g2d.setColor(Color.YELLOW); // Yellow for reloading\n            g2d.fillRect(barX, barY, filledWidth, barHeight);\n            \n            // Draw border\n            g2d.setColor(Color.BLACK);\n            g2d.drawRect(barX, barY, barWidth, barHeight);\n            \n            // Optionally display \"RELOADING\" text\n            g2d.setColor(Color.WHITE);\n            g2d.setFont(new Font(\"Arial\", Font.BOLD, 10));\n            g2d.drawString(\"RELOADING\", barX + 2, barY - 2);\n        }\n    }\n\n    private void togglePause() {\n        if (gameInfo.isPaused) {\n            resumeGame();\n        } else {\n            pauseGame();\n        }\n    }\n\n    public void pauseGame() {\n        gameInfo.isPaused = true;\n\n        // Stop game timers\n        if (gameInfo.gameTimer != null && gameInfo.gameTimer.isRunning()) {\n            gameInfo.gameTimer.stop();\n        }\n        if (gameInfo.zombieSpawnTimer != null && gameInfo.zombieSpawnTimer.isRunning()) {\n            gameInfo.zombieSpawnTimer.stop();\n        }\n        \n        // Show pause panel\n        if (gameInfo.pauseGamePanel != null) {\n            gameInfo.pauseGamePanel.setVisible(true);\n        }\n    }\n    \n    public void resumeGame() {\n        gameInfo.isPaused = false;\n        \n        // Restart game timers\n        if (gameInfo.gameTimer != null && !gameInfo.gameTimer.isRunning()) {\n            gameInfo.gameTimer.start();\n        }\n        if (gameInfo.zombieSpawnTimer != null && !gameInfo.zombieSpawnTimer.isRunning()) {\n            gameInfo.zombieSpawnTimer.start();\n        }\n        \n        // Hide pause panel\n        if (gameInfo.pauseGamePanel != null) {\n            gameInfo.pauseGamePanel.setVisible(false);\n        }\n        \n        // Ensure focus returns to game panel\n        requestFocus();\n    }\n\n    private void toggleFPSDisplay() {\n        showFPS = !showFPS;\n    }\n    \n    private void updateTimerDelay() {\n        int delay = 1000 / targetFPS;\n        if (gameInfo.gameTimer != null) {\n            gameInfo.gameTimer.setDelay(delay);\n        }\n    }\n    \n    private void drawZombieIndicators(Graphics2D g2d) {\n        g2d.setColor(Color.RED);\n        g2d.setStroke(new BasicStroke(2));\n        \n        // Get player center position\n        double playerCenterX = gameInfo.player.getCenterX();\n        double playerCenterY = gameInfo.player.getCenterY();\n        \n        for (Zombie zombie : gameInfo.zombies) {\n            if (isEntityVisible(zombie, 0, 0, PANEL_WIDTH, PANEL_HEIGHT)) {\n                continue;\n            }\n            double zombieCenterX = zombie.getCenterX();\n            double zombieCenterY = zombie.getCenterY();\n        \n            double dirX = zombieCenterX - playerCenterX;\n            double dirY = zombieCenterY - playerCenterY;\n            \n            double length = Math.sqrt(dirX * dirX + dirY * dirY);\n            dirX /= length;\n            dirY /= length;\n            \n            double startX = playerCenterX + dirX * 100;\n            double startY = playerCenterY + dirY * 100;\n            \n            int arrowLength = 15;\n            double angle = Math.atan2(dirY, dirX);\n            \n            // Calculate arrow points\n            int[] xPoints = new int[3];\n            int[] yPoints = new int[3];\n            \n            // Arrow tip is at line start (near player)\n            xPoints[0] = (int)startX;\n            yPoints[0] = (int)startY;\n            \n            // Calculate the two base points of the arrow\n            xPoints[1] = (int)(startX - arrowLength * Math.cos(angle - Math.PI/6));\n            yPoints[1] = (int)(startY - arrowLength * Math.sin(angle - Math.PI/6));\n            \n            xPoints[2] = (int)(startX - arrowLength * Math.cos(angle + Math.PI/6));\n            yPoints[2] = (int)(startY - arrowLength * Math.sin(angle + Math.PI/6));\n            \n            // Fill the arrow\n            g2d.fillPolygon(xPoints, yPoints, 3);\n        }\n        \n        // Reset stroke to default\n        g2d.setStroke(new BasicStroke(1));\n    }\n}\n",
      "Drop.java": "import java.io.File;\n\npublic class Drop extends Entity {\n    private static final int DROP_SIZE = 48;\n\n    protected boolean isCollected = false;\n\n    public Drop(double x, double y, String appearanceImagePath) {\n        this.x = x;\n        this.y = y;\n        this.width = DROP_SIZE;\n        this.height = DROP_SIZE;\n        this.appearanceImagePath = appearanceImagePath;\n        setImage(new File(appearanceImagePath));\n    }\n\n    public boolean isCollected() {\n        return isCollected;\n    }\n\n    public void collect() {\n        isCollected = true;\n    }\n}\n",
      "AcidicZombie.java": "import java.io.File;\n\npublic class AcidicZombie extends Zombie {\n    public static final int BLAST_RADIUS = 300;\n    protected String firingSoundPath = \"assets/WeaponSounds/Firing/spitting.wav\";\n\n    public AcidicZombie(int x, int y) {\n        super(x, y, 50, 0.5, 10, \"assets/Zombies/acidic_zombie.png\", 150);\n        attackRange = 500;\n        attackDistancePercent = 0.75;\n    }\n    \n    public Bullet shootAcid(double playerX, double playerY) {\n        Bullet acidBullet = Bullet.Pool.getBullet(this.getCenterX(), this.getCenterY(), null);\n        \n        acidBullet.appearanceImagePath = \"assets/Laser Sprites/09.png\";\n        acidBullet.setImage(new File(acidBullet.appearanceImagePath));\n        acidBullet.bulletSize = 50;\n        \n        double dx = playerX - this.getCenterX();\n        double dy = playerY - this.getCenterY();\n        \n        double length = Math.sqrt(dx * dx + dy * dy);\n        if (length > 0) {\n            dx /= length;\n            dy /= length;\n        }\n        \n        acidBullet.directionX = dx;\n        acidBullet.directionY = dy;\n        acidBullet.rotation = Math.toDegrees(Math.atan2(dy, dx));\n        \n        // Prevent self-damage\n        acidBullet.hitZombies.add(this);\n        \n        attack();\n        acidBullet.setZombieBullet(true);\n        acidBullet.setDamage(damage);\n        acidBullet.moveSpeed = acidBullet.moveSpeed * 0.5;\n        playFiringSound();\n\n        return acidBullet;\n    }\n    \n    public void playFiringSound() {\n        GameInfo.playSound(firingSoundPath);\n    }\n}\n",
      "Rifle.java": "import java.io.File;\n\npublic class Rifle extends Weapon {\n    public Rifle() {\n        super(0, 0, 600, 30, 30, 30, \"assets/WeaponSounds/Firing/rifle.wav\", \"assets/WeaponSounds/Reload/rifle.wav\");\n        this.appearanceImagePath = \"assets/Weapons/rifle.png\";\n        setImage(new File(appearanceImagePath));\n    }\n    \n}\n",
      "CharacterSelectionPanel.java": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\nimport javax.imageio.ImageIO;\n\npublic class CharacterSelectionPanel extends JPanel {\n    private GameInfo gameInfo;\n    private List<CharacterOption> characterOptions = new ArrayList<>();\n    private int selectedIndex = 0;\n    private JButton selectButton;\n    private JButton backButton;\n    private Image backgroundImage;\n    \n    public CharacterSelectionPanel(GameInfo gameInfo) {\n        this.gameInfo = gameInfo;\n        setLayout(null);\n        if (gameInfo.backgroundImage != null) {\n            backgroundImage = gameInfo.backgroundImage;\n        } else {\n            setBackground(new Color(32, 32, 32));\n        }\n        \n        JLabel titleLabel = new JLabel(\"SELECT CHARACTER\") {\n            @Override\n            protected void paintComponent(Graphics g) {\n                Graphics2D g2d = (Graphics2D) g.create();\n                g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n                \n                // Draw shadow\n                g2d.setColor(new Color(0, 0, 0, 180));\n                g2d.setFont(getFont());\n                FontMetrics fm = g2d.getFontMetrics();\n                g2d.drawString(getText(), 4, fm.getAscent() + 4);\n                \n                // Draw text\n                g2d.setColor(getForeground());\n                g2d.drawString(getText(), 0, fm.getAscent());\n                \n                g2d.dispose();\n            }\n        };\n        titleLabel.setFont(new Font(\"Impact\", Font.BOLD, 72));\n        titleLabel.setForeground(Color.WHITE);\n        titleLabel.setHorizontalAlignment(SwingConstants.CENTER);\n        titleLabel.setBounds(50, 50, GameFrame.WIDTH, 80);\n        add(titleLabel);\n\n        // Load character options\n        loadCharacterOptions();\n\n        // Create UI components\n        int buttonWidth = 250;\n        int buttonHeight = 75;\n\n        int leftMargin = 50;\n        \n        selectButton = UIUtils.createTransparentButton(\"SELECT\");\n        selectButton.setFont(new Font(\"Courier New\", Font.BOLD, 20));\n        selectButton.setBounds(GameFrame.WIDTH/2 - buttonWidth/2, GameFrame.HEIGHT - 350, buttonWidth, buttonHeight);\n        selectButton.addActionListener(e -> selectCharacter());\n        add(selectButton);\n\n        backButton = UIUtils.createTransparentButton(\"BACK\");\n        backButton.setFont(new Font(\"Courier New\", Font.BOLD, 20));\n        backButton.setBounds(leftMargin, GameFrame.HEIGHT - 200, buttonWidth, buttonHeight);\n        backButton.addActionListener(e -> goBack());\n        add(backButton);\n\n        int characterDisplayWidth = 200;\n        int arrowButtonWidth = 60;\n        int arrowButtonHeight = 60;\n        int arrowButtonY = GameFrame.HEIGHT/2 - arrowButtonHeight/2;\n        int gap = 30;\n\n        JButton leftArrow = UIUtils.createTransparentButton(\"<\");\n        leftArrow.setFont(new Font(\"Arial\", Font.BOLD, 36));\n        leftArrow.setBounds(\n            (GameFrame.WIDTH/2) - (characterDisplayWidth/2) - arrowButtonWidth - gap, \n            arrowButtonY, \n            arrowButtonWidth, \n            arrowButtonHeight);\n        leftArrow.addActionListener(e -> previousCharacter());\n        add(leftArrow);\n\n        JButton rightArrow = UIUtils.createTransparentButton(\">\");\n        rightArrow.setFont(new Font(\"Arial\", Font.BOLD, 36));\n        rightArrow.setBounds(\n            (GameFrame.WIDTH/2) + (characterDisplayWidth/2) + gap, \n            arrowButtonY, \n            arrowButtonWidth, \n            arrowButtonHeight);\n        rightArrow.addActionListener(e -> nextCharacter());\n        add(rightArrow);\n    }\n    \n    private void loadCharacterOptions() {\n        // Get all character folders that match the pattern \"char_XX\"\n        File playerDir = new File(\"assets/Player\");\n        if (!playerDir.exists() || !playerDir.isDirectory()) {\n            System.err.println(\"Player directory not found: assets/Player\");\n            return;\n        }\n        \n        // Get all subdirectories that match the pattern char_XX\n        File[] characterDirs = playerDir.listFiles(file -> \n            file.isDirectory() && Pattern.matches(\"char_\\\\d+\", file.getName()));\n        \n        if (characterDirs == null || characterDirs.length == 0) {\n            System.err.println(\"No character directories found matching pattern 'char_XX'\");\n            return;\n        }\n        \n        for (File characterDir : characterDirs) {\n            try {\n                // Extract character number from folder name\n                String folderName = characterDir.getName();\n                String numStr = folderName.substring(folderName.lastIndexOf('_') + 1);\n                int characterNum = Integer.parseInt(numStr);\n                \n                String characterName = \"Character \" + characterNum;\n                File nameFile = new File(characterDir, \"name.txt\");\n                if (nameFile.exists()) {\n                    try (Scanner scanner = new Scanner(nameFile)) {\n                        if (scanner.hasNextLine()) {\n                            String line = scanner.nextLine();\n                            if (line != null && !line.trim().isEmpty()) {\n                                characterName = line.trim();\n                            }\n                        }\n                    }\n                }\n                \n                String characterPath = characterDir.getPath();\n                    \n                // Find the first walking animation image to display\n                File walkingDir = new File(characterPath + \"/walking\");\n                \n                if (walkingDir.exists() && walkingDir.isDirectory()) {\n                    File[] walkingFiles = walkingDir.listFiles((dir, name) -> \n                        name.toLowerCase().endsWith(\".png\"));\n                    \n                    if (walkingFiles != null && walkingFiles.length > 0) {\n                        BufferedImage characterImg = ImageIO.read(walkingFiles[0]);\n                        characterOptions.add(new CharacterOption(characterNum, characterImg, characterName));\n                    } else {\n                        // Try looking for any png in the character folder \n                        File[] files = characterDir.listFiles((dir, name) -> \n                            name.toLowerCase().endsWith(\".png\"));\n                        \n                        if (files != null && files.length > 0) {\n                            BufferedImage characterImg = ImageIO.read(files[0]);\n                            characterOptions.add(new CharacterOption(characterNum, characterImg, characterName));\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                System.err.println(\"Error loading character from \" + characterDir.getName() + \": \" + e.getMessage());\n            }\n        }\n        \n        if (characterOptions.isEmpty()) {\n            System.err.println(\"No characters found! Please check the assets directory structure.\");\n        }\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        \n        if (backgroundImage != null) {\n            int imgWidth = backgroundImage.getWidth(this);\n            int imgHeight = backgroundImage.getHeight(this);\n            \n            // Calculate scaling factor to cover the entire panel\n            double scale = Math.max(\n                (double) getWidth() / imgWidth,\n                (double) getHeight() / imgHeight\n            );\n            \n            // Calculate new dimensions\n            int scaledWidth = (int) (imgWidth * scale);\n            int scaledHeight = (int) (imgHeight * scale);\n            \n            // Center the scaled image (excess will be cropped)\n            int x = (getWidth() - scaledWidth) / 2;\n            int y = (getHeight() - scaledHeight) / 2;\n            \n            g.drawImage(backgroundImage, x, y, scaledWidth, scaledHeight, this);\n        }\n        \n        // Draw character preview\n        if (!characterOptions.isEmpty()) {\n            CharacterOption currentOption = characterOptions.get(selectedIndex);\n            int maxWidth = 200;\n            int maxHeight = 200;\n            int y = GameFrame.HEIGHT/2 - maxHeight/2;\n\n            // Set up character name text\n            String characterName = currentOption.name;\n            g.setFont(new Font(\"Courier New\", Font.BOLD, 24));\n            FontMetrics fm = g.getFontMetrics();\n            int nameWidth = fm.stringWidth(characterName);\n            int nameHeight = fm.getHeight();\n            int textY = y - 20;\n            int textX = GameFrame.WIDTH/2 - nameWidth/2;\n            \n            // Add background rectangle with padding\n            int padding = 20;\n            int boxX = textX - padding;\n            int boxY = textY - nameHeight - 3;\n            int boxWidth = nameWidth + (padding * 2);\n            int boxHeight = nameHeight + padding;\n            \n            // Draw semi-transparent background with rounded corners\n            Graphics2D g2d = (Graphics2D) g;\n            Composite originalComposite = g2d.getComposite();\n            g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.7f));\n            g2d.setColor(new Color(0, 0, 0));\n            g2d.fillRoundRect(boxX, boxY, boxWidth, boxHeight, 10, 10);\n            g2d.setComposite(originalComposite);\n            \n            // Draw border for the name box\n            g2d.setColor(new Color(180, 180, 180));\n            g2d.drawRoundRect(boxX, boxY, boxWidth, boxHeight, 10, 10);\n            \n            // Draw the text (white color stands out against dark background)\n            g.setColor(Color.WHITE);\n            g.drawString(characterName, textX, textY);\n            \n            if (currentOption.image != null) {\n                int origWidth = currentOption.image.getWidth();\n                int origHeight = currentOption.image.getHeight();\n                \n                int newWidth, newHeight;\n                \n                if (origWidth > origHeight) {\n                    newWidth = maxWidth;\n                    newHeight = (int)(((double)origHeight / origWidth) * maxWidth);\n                } else {\n                    newHeight = maxHeight;\n                    newWidth = (int)(((double)origWidth / origHeight) * maxHeight);\n                }\n                \n                int imgX = GameFrame.WIDTH/2 - newWidth/2;\n                int imgY = GameFrame.HEIGHT/2 - newHeight/2;\n                \n                g.drawImage(currentOption.image, imgX, imgY, newWidth, newHeight, null);\n            }\n        } else {\n            // Display a message if no characters were found\n            g.setFont(new Font(\"Courier New\", Font.BOLD, 24));\n            g.setColor(Color.RED);\n            String message = \"No character files found!\";\n            FontMetrics fm = g.getFontMetrics();\n            int msgWidth = fm.stringWidth(message);\n            g.drawString(message, GameFrame.WIDTH/2 - msgWidth/2, GameFrame.HEIGHT/2);\n        }\n    }\n    \n    private void previousCharacter() {\n        if (characterOptions.isEmpty()) return;\n        \n        selectedIndex--;\n        if (selectedIndex < 0) {\n            selectedIndex = characterOptions.size() - 1;\n        }\n        repaint();\n    }\n    \n    private void nextCharacter() {\n        if (characterOptions.isEmpty()) return;\n        \n        selectedIndex++;\n        if (selectedIndex >= characterOptions.size()) {\n            selectedIndex = 0;\n        }\n        repaint();\n    }\n    \n    private void selectCharacter() {\n        if (!characterOptions.isEmpty()) {\n            gameInfo.setSelectedCharacter(characterOptions.get(selectedIndex).id);\n            setVisible(false);\n            \n            Container parent = getParent();\n            if (parent instanceof MainMenuPanel) {\n                MainMenuPanel mainMenu = (MainMenuPanel) parent;\n                mainMenu.showMainMenuContent();\n                if (mainMenu.startGameAfterSelection) {\n                    mainMenu.startGame();\n                    mainMenu.startGameAfterSelection = false;\n                } else {\n                    mainMenu.showMainMenuContent();\n                }\n            }\n        }\n    }\n    \n    private void goBack() {\n        setVisible(false);\n        \n        Container parent = getParent();\n        if (parent instanceof MainMenuPanel) {\n            MainMenuPanel mainMenu = (MainMenuPanel) parent;\n            mainMenu.showMainMenuContent();\n            mainMenu.startGameAfterSelection = false;\n            mainMenu.showMainMenuContent();\n        }\n    }\n    \n    private static class CharacterOption {\n        int id;\n        BufferedImage image;\n        String name;\n        \n        CharacterOption(int id, BufferedImage image, String name) {\n            this.id = id;\n            this.image = image;\n            this.name = name;\n        }\n    }\n}",
      "Background.java": "import java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.awt.Color;\nimport java.awt.BasicStroke;\nimport java.awt.Font;\nimport java.io.Serializable;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\npublic class Background implements Serializable {\n    private static final long serialVersionUID = 1L;\n    \n    protected final int TILE_SIZE = 64;\n    private final double OBSTACLE_PROBABILITY = 0.25;\n    private transient List<BufferedImage> tileImages;\n    private double offsetX = 0;\n    private double offsetY = 0;\n    private transient Random random = new Random();\n    \n    // Store pattern for each cell position\n    private Map<String, Integer> cellPatterns;\n    \n    // Tile indices that represent obstacles (can't walk through)\n    private Set<Integer> obstacleTileIndices;\n    \n    // Store image paths for reloading after deserialization\n    private String[] backgroundImagePaths;\n    private String[] obstacleImagePaths;\n    \n    // Debug visualization settings\n    private boolean debugMode = false;\n    private int checkedCellX;\n    private int checkedCellY;\n    private boolean lastMoveBlocked = false;\n    \n    public Background(String[] backgroundTileImages, String[] obstacleTilePaths) {\n        // Store image paths for later reloading if needed\n        this.backgroundImagePaths = backgroundTileImages;\n        this.obstacleImagePaths = obstacleTilePaths;\n        \n        // Load all tile images (both background and obstacles)\n        loadTileImages(backgroundTileImages, obstacleTilePaths);\n        cellPatterns = new HashMap<>();\n        obstacleTileIndices = new HashSet<>();\n\n        int obstacleStartIndex = backgroundTileImages.length;\n        for (int i = 0; i < obstacleTilePaths.length; i++) {\n            obstacleTileIndices.add(obstacleStartIndex + i);\n        }\n    }\n    \n    public void toggleDebugMode() {\n        debugMode = !debugMode;\n    }\n    \n    private void loadTileImages(String[] backgroundPaths, String[] obstaclePaths) {\n        tileImages = new ArrayList<>();\n        \n        // Load background tiles\n        for (String path : backgroundPaths) {\n            try {\n                BufferedImage img = ImageIO.read(new File(path));\n                tileImages.add(img);\n            } catch (IOException e) {\n                System.err.println(\"Failed to load background tile: \" + path + \" - \" + e.getMessage());\n            }\n        }\n        \n        // Load obstacle tiles\n        for (String path : obstaclePaths) {\n            try {\n                BufferedImage img = ImageIO.read(new File(path));\n                tileImages.add(img);\n            } catch (IOException e) {\n                System.err.println(\"Failed to load obstacle tile: \" + path + \" - \" + e.getMessage());\n            }\n        }\n        \n        // If no images were loaded successfully, create a default one\n        if (tileImages.isEmpty()) {\n            createDefaultTile();\n        }\n    }\n    \n\n    private void createDefaultTile() {\n        BufferedImage defaultTile = new BufferedImage(TILE_SIZE, TILE_SIZE, BufferedImage.TYPE_INT_RGB);\n        Graphics2D g = defaultTile.createGraphics();\n        g.setColor(java.awt.Color.DARK_GRAY);\n        g.fillRect(0, 0, TILE_SIZE, TILE_SIZE);\n        g.setColor(java.awt.Color.GRAY);\n        g.drawRect(0, 0, TILE_SIZE-1, TILE_SIZE-1);\n        g.dispose();\n        \n        tileImages = new ArrayList<>();\n        tileImages.add(defaultTile);\n    }\n    \n\n    private int getTileForCell(int cellX, int cellY) {\n        String key = cellX + \",\" + cellY;\n        if (!cellPatterns.containsKey(key)) {\n            if (random.nextDouble() < OBSTACLE_PROBABILITY) {\n                cellPatterns.put(key, random.nextInt(tileImages.size()));\n            } else {\n                cellPatterns.put(key, 0);\n            }\n        }\n        return cellPatterns.get(key);\n    }\n\n    public boolean isValidMove(double dx, double dy, int playerHeight) {\n        // Calculate future position\n        double newOffsetX = offsetX + dx;\n        double newOffsetY = offsetY + dy;\n                \n        // Get the screen dimensions from the GamePanel class\n        int screenWidth = GameFrame.WIDTH;\n        int screenHeight = GameFrame.HEIGHT - StatPanel.HEIGHT;\n        \n        // Calculate center of screen (where player is)\n        int screenCenterX = screenWidth / 2;\n        int screenCenterY = screenHeight / 2 + playerHeight / 4;\n        \n        // Calculate the world coordinates of the player's center after movement\n        double playerWorldX = screenCenterX + newOffsetX;\n        double playerWorldY = screenCenterY + newOffsetY;\n        \n        // Convert to cell coordinates\n        int centerCellX = (int)Math.floor(playerWorldX / TILE_SIZE);\n        int centerCellY = (int)Math.floor(playerWorldY / TILE_SIZE);\n        \n        // Store for debug visualization\n        checkedCellX = centerCellX;\n        checkedCellY = centerCellY;\n        \n        // Check if this cell contains an obstacle\n        String key = centerCellX + \",\" + centerCellY;\n        if (cellPatterns.containsKey(key)) {\n            int tileIndex = cellPatterns.get(key);\n            boolean isObstacle = obstacleTileIndices.contains(tileIndex);\n            lastMoveBlocked = isObstacle;\n            return !isObstacle;\n        }\n        \n        // If cell doesn't exist yet, it's a new cell - allow movement\n        lastMoveBlocked = false;\n        return true;\n    }\n    \n    public boolean isValidMoveForEntity(double entityX, double entityY, double dx, double dy, int entityWidth, int entityHeight) {\n        // Calculate future position\n        double newX = entityX + dx;\n        double newY = entityY + dy;\n        \n        // Calculate the world coordinates of the entity's center after movement\n        double entityWorldCenterX = newX + entityWidth/2 + offsetX;\n        double entityWorldCenterY = newY + entityHeight/2 + offsetY + 32;\n        \n        // Convert to cell coordinates\n        int centerCellX = (int)Math.floor(entityWorldCenterX / TILE_SIZE);\n        int centerCellY = (int)Math.floor(entityWorldCenterY / TILE_SIZE);\n        \n        // Check if this cell contains an obstacle\n        String key = centerCellX + \",\" + centerCellY;\n        if (cellPatterns.containsKey(key)) {\n            int tileIndex = cellPatterns.get(key);\n            boolean isObstacle = obstacleTileIndices.contains(tileIndex);\n            return !isObstacle;\n        }\n        \n        // If cell doesn't exist yet, it's a new cell - allow movement\n        return true;\n    }\n\n    public boolean isValidSpawnPosition(double x, double y, int width, int height) {\n        // Calculate the world coordinates of the entity's center\n        double entityWorldCenterX = x + width/2 + offsetX;\n        double entityWorldCenterY = y + height/2 + offsetY + 32; // Same offset as in isValidMoveForEntity\n        \n        // Convert to cell coordinates\n        int centerCellX = (int)Math.floor(entityWorldCenterX / TILE_SIZE);\n        int centerCellY = (int)Math.floor(entityWorldCenterY / TILE_SIZE);\n        \n        // Check if this cell contains an obstacle\n        String key = centerCellX + \",\" + centerCellY;\n        if (cellPatterns.containsKey(key)) {\n            int tileIndex = cellPatterns.get(key);\n            boolean isObstacle = obstacleTileIndices.contains(tileIndex);\n            return !isObstacle; // Return true if NOT an obstacle\n        }\n        \n        // If cell doesn't exist yet, it's a new cell - allow spawning\n        return true;\n    }\n\n    public boolean update(double dx, double dy, int playerHeight) {\n        if (!isValidMove(dx, dy, playerHeight)) {\n            return false;\n        }\n        \n        offsetX += dx;\n        offsetY += dy;\n        boolean limitMapSize = false;\n\n        if (!limitMapSize) {\n            return true;\n        }\n\n        // Limit the map size by removing cells that are too far away\n        if (Math.abs(offsetX) > TILE_SIZE * 50 || Math.abs(offsetY) > TILE_SIZE * 50) {\n            // Reset offset and map when too far from origin\n            offsetX = offsetX % TILE_SIZE;\n            offsetY = offsetY % TILE_SIZE;\n            cellPatterns.clear();\n        }\n        \n        return true;\n    }\n    \n    public void draw(Graphics2D g2d, int width, int height, Player player) {\n        if (tileImages.isEmpty()) return;\n        \n        // Calculate visible range\n        int startCellX = (int)Math.floor(offsetX / TILE_SIZE) - 1;\n        int startCellY = (int)Math.floor(offsetY / TILE_SIZE) - 1;\n        int endCellX = startCellX + (width / TILE_SIZE) + 2;\n        int endCellY = startCellY + (height / TILE_SIZE) + 2;\n        \n        // Draw visible tiles\n        for (int cellY = startCellY; cellY <= endCellY; cellY++) {\n            for (int cellX = startCellX; cellX <= endCellX; cellX++) {\n                int tileIndex = getTileForCell(cellX, cellY);\n                BufferedImage tile = tileImages.get(tileIndex);\n                \n                int drawX = (int)((cellX * TILE_SIZE) - offsetX);\n                int drawY = (int)((cellY * TILE_SIZE) - offsetY);\n                \n                g2d.drawImage(tile, drawX, drawY, TILE_SIZE, TILE_SIZE, null);\n                \n                // Draw debug information if enabled\n                if (debugMode) {\n                    // Draw grid\n                    g2d.setColor(new Color(255, 255, 255, 80)); // Semi-transparent white\n                    g2d.drawRect(drawX, drawY, TILE_SIZE, TILE_SIZE);\n                    \n                    // Mark obstacles\n                    if (obstacleTileIndices.contains(tileIndex)) {\n                        g2d.setColor(new Color(255, 0, 0, 100)); // Semi-transparent red\n                        g2d.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);\n                    }\n                    \n                    // Draw cell coordinates\n                    g2d.setColor(Color.WHITE);\n                    g2d.setFont(new Font(\"Arial\", Font.PLAIN, 10));\n                    g2d.drawString(cellX + \",\" + cellY, drawX + 5, drawY + 15);\n                }\n            }\n        }\n        \n        // Draw debug visualization for collision checks\n        if (debugMode) {\n            // Draw a marker at the center of the screen (player position)\n            int screenCenterX = width / 2;\n            int screenCenterY = height / 2;\n            \n            g2d.setColor(Color.GREEN);\n            g2d.fillOval(screenCenterX - 5, screenCenterY - 5, 10, 10);\n            \n            // Draw the cell being checked for collision\n            int cellDrawX = (int)((checkedCellX * TILE_SIZE) - offsetX);\n            int cellDrawY = (int)((checkedCellY * TILE_SIZE) - offsetY);\n            \n            g2d.setStroke(new BasicStroke(2));\n            if (lastMoveBlocked) {\n                g2d.setColor(new Color(255, 0, 0, 180)); // Semi-transparent red for collision\n            } else {\n                g2d.setColor(new Color(0, 255, 0, 180)); // Semi-transparent green for no collision\n            }\n            g2d.drawRect(cellDrawX, cellDrawY, TILE_SIZE, TILE_SIZE);\n            \n            // Draw offset and other debug info\n            g2d.setColor(Color.WHITE);\n            g2d.setFont(new Font(\"Arial\", Font.BOLD, 12));\n            g2d.drawString(\"Offset: \" + String.format(\"%.1f, %.1f\", offsetX, offsetY), 10, 20);\n            g2d.drawString(\"Player Cell: \" + checkedCellX + \",\" + checkedCellY, 10, 40);\n            g2d.drawString(\"Player Screen Position: \" + String.format(\"%.1f, %.1f\", player.x, player.y), 10, 60);\n            g2d.drawString(\"Player World Position: \" + String.format(\"%.1f, %.1f\", player.x - offsetX, player.y - offsetY), 10, 80);\n            \n            // Draw player hitbox\n            g2d.setStroke(new BasicStroke(1));\n            g2d.setColor(new Color(0, 255, 255, 150)); // Cyan for player hitbox\n            g2d.drawRect((int)player.x, (int)player.y, player.width, player.height);\n        }\n    }\n    \n    public double getOffsetX() {\n        return offsetX;\n    }\n    \n    public double getOffsetY() {\n        return offsetY;\n    }\n\n    public int getCellXFromScreenPos(int screenX) {\n        return (int)Math.floor((screenX + offsetX) / TILE_SIZE);\n    }\n    \n    public int getCellYFromScreenPos(int screenY) {\n        return (int)Math.floor((screenY + offsetY) / TILE_SIZE);\n    }\n    \n    public void setOffset(double x, double y) {\n        this.offsetX = x;\n        this.offsetY = y;\n    }\n\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n    }\n\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        \n        // Reinitialize transient fields\n        random = new Random();\n        \n        // Reload tile images\n        loadTileImages(backgroundImagePaths, obstacleImagePaths);\n    }\n}",
      "TankZombie.java": "public class TankZombie extends Zombie {\n    public TankZombie(int x, int y) {\n        super(x, y, 200, 0.25, 20, \"assets/Zombies/tank_zombie.png\", 100);\n    }\n}\n",
      "Game.java": "public class Game {\n    public static void main(String[] args) {\n        new GameFrame();\n    }\n}\n",
      "Animation.java": "import java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.imageio.ImageIO;\n\npublic class Animation extends Entity {\n    private List<BufferedImage> frames;\n    private int width, height;\n    private int currentFrame = 0;\n    private long lastFrameTime = 0;\n    private boolean isCompleted = false;\n    private boolean loop = false;\n    private int frameDelay;\n    private String type; // Can be used to categorize animations (e.g., \"explosion\", \"powerup\", etc.)\n    \n    public Animation(double x, double y, int width, int height, int frameDelay, boolean loop, String type) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.frameDelay = frameDelay;\n        this.loop = loop;\n        this.type = type;\n        this.frames = new ArrayList<>();\n    }\n    \n    public void loadFrames(String directory) {\n        frames.clear();\n        File dir = new File(directory);\n        \n        if (!dir.exists() || !dir.isDirectory()) {\n            System.err.println(\"Animation directory not found: \" + directory);\n            return;\n        }\n        \n        // Get all PNG files in the directory\n        File[] files = dir.listFiles((d, name) -> name.toLowerCase().endsWith(\".png\"));\n        \n        if (files == null || files.length == 0) {\n            System.err.println(\"No frames found in: \" + directory);\n            return;\n        }\n        \n        java.util.Arrays.sort(files, (f1, f2) -> f1.getName().compareTo(f2.getName()));\n        \n        for (File file : files) {\n            try {\n                BufferedImage frame = ImageIO.read(file);\n                frames.add(frame);\n            } catch (IOException e) {\n                System.err.println(\"Error loading frame: \" + file.getName());\n            }\n        }\n        \n        lastFrameTime = System.currentTimeMillis();\n    }\n    \n    public void addFrame(BufferedImage frame) {\n        if (frames.isEmpty()) {\n            lastFrameTime = System.currentTimeMillis();\n        }\n        frames.add(frame);\n    }\n    \n    public void setFrames(List<BufferedImage> frames) {\n        this.frames = new ArrayList<>(frames);\n        lastFrameTime = System.currentTimeMillis();\n    }\n    \n    public boolean update() {\n        if (isCompleted || frames == null || frames.isEmpty()) {\n            return false;\n        }\n        \n        long currentTime = System.currentTimeMillis();\n        if (currentTime - lastFrameTime > frameDelay) {\n            currentFrame++;\n            \n            if (currentFrame >= frames.size()) {\n                if (loop) {\n                    currentFrame = 0;\n                } else {\n                    isCompleted = true;\n                    return false;\n                }\n            }\n            \n            lastFrameTime = currentTime;\n        }\n        return true;\n    }\n    \n    public void draw(Graphics2D g2d) {\n        if (isCompleted || frames == null || frames.isEmpty() || currentFrame < 0 || currentFrame >= frames.size()) {\n            return;\n        }\n        \n        BufferedImage currentImage = frames.get(currentFrame);\n        g2d.drawImage(currentImage, (int)x, (int)y, width, height, null);\n    }\n    \n    public void setPosition(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    public double getX() {\n        return x;\n    }\n    \n    public double getY() {\n        return y;\n    }\n    \n    public String getType() {\n        return type;\n    }\n    \n    public boolean isCompleted() {\n        return isCompleted;\n    }\n\n    public int getWidth() {\n        return width;\n    }\n    public int getHeight() {\n        return height;\n    }\n    public void setWidth(int width) {\n        this.width = width;\n    }\n    public void setHeight(int height) {\n        this.height = height;\n    }\n    \n    public void reset() {\n        currentFrame = 0;\n        isCompleted = false;\n        lastFrameTime = System.currentTimeMillis();\n    }\n    \n    public void setLoop(boolean loop) {\n        this.loop = loop;\n    }\n}",
      "RocketLauncher.java": "import java.io.File;\n\npublic class RocketLauncher extends Weapon {\n    public static final double BLAST_RADIUS = 200;\n    protected String hitSoundPath = \"assets/WeaponSounds/Hit/rocket_launcher.wav\";\n\n    public RocketLauncher() {\n        super(0, 0, 25, 0, 80, 5, \"assets/WeaponSounds/Firing/rocket_launcher.wav\", \"assets/WeaponSounds/Reload/rocket_launcher.wav\");\n        this.appearanceImagePath = \"assets/Weapons/rocket_launcher.png\";\n        setImage(new File(appearanceImagePath));\n    }\n    \n    @Override\n    public boolean canShoot() {\n        if (!canShoot) {\n            if (System.currentTimeMillis() - lastShotTime >= fireDelay) {\n                canShoot = true;\n            }\n        }\n        return canShoot && currentAmmo > 0;\n    }\n    \n    @Override\n    public void reload() {\n    }\n    \n    public void addAmmo(int amount) {\n        currentAmmo += amount;\n    }\n}\n",
      "HealthDrop.java": "import java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class HealthDrop extends Drop {\n    private int healthAmount;\n\n    private static final String FOOD_VEGETABLE_DIRECTORY = \"assets/Foods/Vegetables/\";\n    private static final String FOOD_FRUIT_DIRECTORY = \"assets/Foods/Fruits/\";\n    private static String[] availableFoodImages;\n    private static Random random = new Random();\n    \n    static {\n        loadAvailableFoodImages();\n    }\n\n    public HealthDrop(double x, double y) {\n        this(x, y, (int)(Math.random() * 21) + 20);\n    }\n\n    public HealthDrop(double x, double y, int healthAmount) {\n        super(x, y, getRandomFoodImagePath());\n        this.healthAmount = healthAmount;\n        this.width = 64;\n        this.height = 64;\n    }\n    \n    public int getHealthAmount() {\n        return healthAmount;\n    }\n\n    private static void loadAvailableFoodImages() {\n        // Use List to collect paths as we don't know the final size\n        List<String> foodImagePaths = new ArrayList<>();\n        \n        // Load vegetable images\n        loadImagesFromDirectory(FOOD_VEGETABLE_DIRECTORY, foodImagePaths);\n        \n        // Load fruit images\n        loadImagesFromDirectory(FOOD_FRUIT_DIRECTORY, foodImagePaths);\n        \n        // Convert list to array\n        if (!foodImagePaths.isEmpty()) {\n            availableFoodImages = foodImagePaths.toArray(new String[0]);\n        } else {\n            // Fallback if no images found\n            availableFoodImages = new String[]{\"assets/default.png\"};\n            System.err.println(\"No food images found, using default health image\");\n        }\n    }\n    \n    private static void loadImagesFromDirectory(String directoryPath, List<String> imageList) {\n        File directory = new File(directoryPath);\n        if (!directory.exists() || !directory.isDirectory()) {\n            System.err.println(\"Food directory not found: \" + directoryPath);\n            return;\n        }\n        File[] files = directory.listFiles((dir, name) -> \n            name.toLowerCase().endsWith(\".png\"));\n\n        if (files == null || files.length == 0) {\n            System.err.println(\"No food images found in \" + directoryPath);\n        }\n        for (File file : files) {\n            imageList.add(directoryPath + file.getName());\n        }\n    }\n\n    private static String getRandomFoodImagePath() {\n        if (availableFoodImages == null || availableFoodImages.length == 0) {\n            loadAvailableFoodImages();\n        }\n\n        if (availableFoodImages.length > 0) {\n            return availableFoodImages[random.nextInt(availableFoodImages.length)];\n        }\n        \n        // Fallback\n        return \"assets/default.png\";\n    }\n}\n",
      "Player.java": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.util.ArrayList;\nimport javax.imageio.ImageIO;\n\npublic class Player extends Entity {\n    private static final int PLAYER_WIDTH = 64;\n    private static final int PLAYER_HEIGHT = 64;\n    public static final int PLAYER_HEALTH = 100;\n    private static final int FRAME_DELAY = 100;\n\n    // Animation fields\n    private transient BufferedImage[] walkingFrames;\n    private int currentFrame = 0;\n    private long lastFrameTime = 0;\n    private boolean isMoving = false;\n    private int selectedCharacter;\n\n    protected ArrayList<Weapon> weapons = new ArrayList<Weapon>();\n    protected Weapon currentWeapon;\n    protected double health;\n    protected int score = 0;\n    protected int kills = 0;\n    public boolean facingLeft = false;\n\n    public Player(int x, int y, int characterNumber) {\n        this.x = x;\n        this.y = y;\n        this.width = PLAYER_WIDTH;\n        this.height = PLAYER_HEIGHT;\n        this.health = PLAYER_HEALTH;\n        this.moveSpeed = GameInfo.PLAYER_SPEED;\n        this.selectedCharacter = characterNumber;\n        String charNumString = characterNumber < 10 ? \"0\" + characterNumber : String.valueOf(characterNumber);\n        this.appearanceImagePath = \"assets/Player/char_\" + charNumString + \"/walking/walking_01.png\";\n        String walkingDirPath = \"assets/Player/char_\" + charNumString + \"/walking\";\n        setImage(new File(appearanceImagePath));\n        weapons.add(new Pistol());\n        weapons.add(new Rifle());\n        weapons.add(new Shotgun());\n        weapons.add(new Sniper());\n        weapons.add(new RocketLauncher());\n        currentWeapon = weapons.get(0);\n\n        loadWalkingFrames(walkingDirPath);\n    }\n    \n    private void loadWalkingFrames(String walkingDirPath) {\n        try {\n            File walkingDir = new File(walkingDirPath);\n            if (walkingDir.exists() && walkingDir.isDirectory()) {\n                File[] files = walkingDir.listFiles((dir, name) -> \n                    name.toLowerCase().endsWith(\".png\"));\n                if (files != null && files.length > 0) {\n                    walkingFrames = new BufferedImage[files.length];\n                    for (int i = 0; i < files.length; i++) {\n                        walkingFrames[i] = ImageIO.read(files[i]);\n                    }\n                } else {\n                    System.err.println(\"No PNG files found in walking directory: \" + walkingDirPath);\n                }\n            } else {\n                System.err.println(\"Walking animation directory not found: \" + walkingDirPath);\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error loading walking animation: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public void setMoving(boolean moving) {\n        this.isMoving = moving;\n    }\n\n    public void updateAnimation() {\n        if (walkingFrames == null) {\n            // Reload walking frames if they're null (after deserialization)\n            String charNumString = (selectedCharacter < 10) ? \"0\" + selectedCharacter : String.valueOf(selectedCharacter);\n            String walkingDirPath = \"assets/Player/char_\" + charNumString + \"/walking\";\n            loadWalkingFrames(walkingDirPath);\n        }\n        \n        if (isMoving && walkingFrames != null && walkingFrames.length > 0) {\n            long currentTime = System.currentTimeMillis();\n            if (currentTime - lastFrameTime > FRAME_DELAY) {\n                currentFrame = (currentFrame + 1) % walkingFrames.length;\n                image = walkingFrames[currentFrame];\n                lastFrameTime = currentTime;\n            }\n        } else {\n            // Reset to standing frame when not moving\n            if (walkingFrames != null && walkingFrames.length > 0 && currentFrame != 0) {\n                image = walkingFrames[0];\n                currentFrame = 0;\n            }\n        }\n    }\n\n    public void reload() {\n        Weapon currentWeapon = this.currentWeapon;\n\n        if (currentWeapon instanceof RocketLauncher) {\n            return;\n        }\n\n        currentWeapon.reload();\n        \n        if (currentWeapon.isReloading) {\n            new Thread(() -> {\n                try {\n                    Thread.sleep(currentWeapon.reloadTimeMs);\n                    \n                    int ammoNeeded = currentWeapon.maxAmmoInClip - currentWeapon.currentAmmo;\n                    if (currentWeapon.currentTotalAmmo >= ammoNeeded) {\n                        currentWeapon.currentAmmo += ammoNeeded;\n                        currentWeapon.currentTotalAmmo -= ammoNeeded;\n                    } else {\n                        currentWeapon.currentAmmo += currentWeapon.currentTotalAmmo;\n                        currentWeapon.currentTotalAmmo = 0;\n                    }\n                    \n                    currentWeapon.isReloading = false;\n                    currentWeapon.canShoot = true;\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n    }\n\n    public void updateGunPosition() {\n        if (currentWeapon != null) {\n            // Position the gun relative to player facing direction\n            double offsetX = 50;\n            \n            // Calculate gun position based on player rotation\n            double angle = Math.toRadians(rotation);\n            \n            // If player is facing left, adjust the gun position\n            if (facingLeft) {\n                // Mirror the gun position when player is facing left\n                angle = Math.PI - angle;\n            }\n            \n            double gunX = getCenterX() + Math.cos(angle) * offsetX - currentWeapon.width / 2;\n            double gunY = getCenterY() + Math.sin(angle) * offsetX - currentWeapon.height / 2;\n            \n            currentWeapon.x = gunX;\n            currentWeapon.y = gunY;\n            \n            // Set gun rotation to match player rotation\n            currentWeapon.rotation = rotation;\n        }\n    }\n\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        // Reload the image and walking frames after deserialization\n        loadImage();\n        String charNumString = selectedCharacter < 10 ? \"0\" + selectedCharacter : String.valueOf(selectedCharacter);\n        String walkingDirPath = \"assets/Player/char_\" + charNumString + \"/walking\";\n        loadWalkingFrames(walkingDirPath);\n    }\n}\n",
      "UIUtils.java": "import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.FontMetrics;\nimport java.awt.RenderingHints;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\nimport javax.swing.BorderFactory;\nimport javax.swing.ImageIcon;\nimport javax.swing.JButton;\nimport javax.swing.SwingConstants;\n\npublic class UIUtils {\n    public static JButton createTransparentButtonWithIcon(String text, String iconPath, int fontSize) {\n        JButton button = new JButton(text) {\n            private boolean isHovered = false;\n            private boolean isPressed = false;\n            \n            {\n                // Initialize mouse listeners\n                addMouseListener(new java.awt.event.MouseAdapter() {\n                    public void mouseEntered(java.awt.event.MouseEvent evt) {\n                        isHovered = true;\n                        repaint();\n                    }\n                    \n                    public void mouseExited(java.awt.event.MouseEvent evt) {\n                        isHovered = false;\n                        isPressed = false;\n                        repaint();\n                    }\n                    \n                    public void mousePressed(java.awt.event.MouseEvent evt) {\n                        isPressed = true;\n                        repaint();\n                    }\n                    \n                    public void mouseReleased(java.awt.event.MouseEvent evt) {\n                        isPressed = false;\n                        repaint();\n                    }\n                });\n            }\n            \n            @Override\n            protected void paintComponent(Graphics g) {\n                Graphics2D g2d = (Graphics2D) g.create();\n                g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n                \n                Color bgColor;\n                \n                if (!isEnabled()) {\n                    bgColor = new Color(50, 50, 50, 150);\n                } else if (isPressed) {\n                    bgColor = new Color(30, 30, 30, 240);\n                } else if (isHovered) {\n                    bgColor = new Color(60, 60, 60, 240);\n                } else {\n                    bgColor = new Color(40, 40, 40, 220);\n                }\n                g2d.setColor(bgColor);\n                g2d.fillRoundRect(0, 0, getWidth(), getHeight(), 15, 15);\n                \n                if (isEnabled() && isHovered && !isPressed) {\n                    g2d.setColor(new Color(100, 100, 255, 40));\n                    g2d.setStroke(new java.awt.BasicStroke(3f));\n                    g2d.drawRoundRect(2, 2, getWidth()-4, getHeight()-4, 15, 15);\n                } else if (!isEnabled()) {\n                    g2d.setColor(new Color(70, 70, 70, 80));\n                    g2d.setStroke(new java.awt.BasicStroke(1.5f));\n                    g2d.drawRoundRect(2, 2, getWidth()-4, getHeight()-4, 15, 15);\n                }\n                \n                ImageIcon icon = (ImageIcon) getIcon();\n                FontMetrics fm = g2d.getFontMetrics();\n                int iconTextGap = getIconTextGap();\n                int iconWidth = icon != null ? icon.getIconWidth() : 0;\n                \n                int offsetX = (isEnabled() && isPressed) ? 2 : 0;\n                int offsetY = (isEnabled() && isPressed) ? 2 : 0;\n                \n                int x = icon != null ? 20 + offsetX : 10 + offsetX;\n                int textY = ((getHeight() - fm.getHeight()) / 2) + fm.getAscent() + offsetY;\n                \n                if (icon != null) {\n                    int iconY = (getHeight() - icon.getIconHeight()) / 2 + offsetY;\n                    \n                    if (!isEnabled()) {\n                        java.awt.AlphaComposite alphaComposite = java.awt.AlphaComposite.getInstance(\n                            java.awt.AlphaComposite.SRC_OVER, 0.5f);\n                        g2d.setComposite(alphaComposite);\n                        icon.paintIcon(this, g2d, x, iconY);\n                        g2d.setComposite(java.awt.AlphaComposite.SrcOver);\n                    } else {\n                        icon.paintIcon(this, g2d, x, iconY);\n                    }\n                    \n                    x += iconWidth + iconTextGap;\n                }\n                \n                if (isEnabled()) {\n                    g2d.setColor(new Color(0, 0, 0, 180));\n                } else {\n                    g2d.setColor(new Color(0, 0, 0, 100));\n                }\n                g2d.drawString(getText(), x + 2, textY + 2);\n                \n                Color textColor;\n                if (!isEnabled()) {\n                    textColor = new Color(160, 160, 160);\n                } else if (isHovered) {\n                    textColor = isPressed ? new Color(200, 200, 200) : Color.YELLOW;\n                } else {\n                    textColor = Color.WHITE;\n                }\n                g2d.setColor(textColor);\n                g2d.drawString(getText(), x, textY);\n                \n                g2d.dispose();\n            }\n        };\n        \n        button.setFont(new Font(\"Courier New\", Font.BOLD, fontSize));\n        button.setForeground(Color.WHITE);\n        button.setContentAreaFilled(false);\n        button.setBorderPainted(false);\n        button.setFocusPainted(false);\n        button.setBorder(BorderFactory.createEmptyBorder(10, 15, 10, 15));\n        button.setOpaque(false);\n        button.setHorizontalAlignment(SwingConstants.LEFT);\n        \n\t\tif (iconPath == null) {\n\t\t\tbutton.setIconTextGap(20);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tImage img = ImageIO.read(new File(iconPath));\n\t\t\t\tImage resizedImg = img.getScaledInstance(36, 36, Image.SCALE_SMOOTH);\n\t\t\t\tbutton.setIcon(new ImageIcon(resizedImg));\n\t\t\t\t\n\t\t\t\tbutton.setHorizontalTextPosition(JButton.RIGHT);\n\t\t\t\tbutton.setIconTextGap(12);\n\t\t\t} catch (IOException e) {\n\t\t\t\tSystem.err.println(\"Could not load icon: \" + iconPath);\n\t\t\t}\n\t\t}\n        \n        return button;\n    }\n\n\tpublic static JButton createTransparentButtonWithIcon(String text, String iconPath) {\n\t\treturn createTransparentButtonWithIcon(text, iconPath, 28);\n\t}\n\n\tpublic static JButton createTransparentButton(String text, int fontSize) {\n\t\treturn createTransparentButtonWithIcon(text, null, fontSize);\n\t}\n\n\tpublic static JButton createTransparentButton(String text) {\n\t\treturn createTransparentButtonWithIcon(text, null);\n\t}\n}"
    },
    {
      "id": "4731282",
      "PauseMenu.java": "package main;\n\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport javax.swing.*;\n//durdurma menüsü\npublic class PauseMenu extends JPanel {\n     GamePanel gp;\n     JPanel container;\n\n    public PauseMenu(GamePanel gp, JPanel container) {\n        this.gp = gp;\n        this.container = container;\n        setLayout(new BorderLayout());\n        setBackground(new Color(0, 0, 0, 200)); \n\n        // Title Panel\n        JPanel titlePanel = new JPanel();\n        titlePanel.setOpaque(false);\n        JLabel titleLabel = new JLabel(\"PAUSED\");\n        titleLabel.setFont(new Font(\"Arial\", Font.BOLD, 48));\n        titleLabel.setForeground(Color.WHITE);\n        titlePanel.add(titleLabel);\n\n        // Button Panel\n        JPanel buttonPanel = new JPanel();\n        buttonPanel.setOpaque(false);\n        buttonPanel.setLayout(new GridLayout(4, 1, 10, 10));\n        buttonPanel.setBorder(BorderFactory.createEmptyBorder(20, 100, 20, 100));\n\n        JButton continueButton = createMenuButton(\"Continue\");\n        JButton saveButton = createMenuButton(\"Save Game\");\n        JButton loadButton = createMenuButton(\"Load Game\");\n        JButton exitButton = createMenuButton(\"Exit to Main Menu\");\n\n        buttonPanel.add(continueButton);\n        buttonPanel.add(saveButton);\n        buttonPanel.add(loadButton);\n        buttonPanel.add(exitButton);\n\n        \n        add(titlePanel, BorderLayout.NORTH);\n        add(buttonPanel, BorderLayout.CENTER);\n\n        \n        continueButton.addActionListener((ActionEvent e) -> {\n            gp.setGameState(GameState.PLAYING);\n            gp.requestFocusInWindow();\n        });\n\n        saveButton.addActionListener((ActionEvent e) -> {\n            gp.saveGame();\n            JOptionPane.showMessageDialog(this, \"Game saved successfully!\", \"Save Game\",\n                    JOptionPane.INFORMATION_MESSAGE);\n        });\n\n        loadButton.addActionListener((ActionEvent e) -> {\n            if (gp.loadGame()) {\n                gp.setGameState(GameState.PLAYING);\n                gp.requestFocusInWindow();\n            } else {\n                JOptionPane.showMessageDialog(this, \"Failed to load game\", \"Error\", JOptionPane.ERROR_MESSAGE);\n            }\n        });\n\n        exitButton.addActionListener((ActionEvent e) -> {\n            gp.setGameState(GameState.MAIN_MENU);\n            CardLayout cl = (CardLayout) container.getLayout();\n            cl.show(container, \"Menu\");\n        });\n    }\n\n    private JButton createMenuButton(String text) {\n        JButton button = new JButton(text);\n        button.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        button.setForeground(Color.WHITE);\n        button.setBackground(new Color(70, 90, 70));\n        button.setFocusPainted(false);\n        button.setBorderPainted(false);\n        button.setOpaque(true);\n        button.setContentAreaFilled(true);\n        button.setPreferredSize(new Dimension(200, 50));\n        return button;\n    }\n}\n",
      "ZombieData.java": "package main;\n\nimport java.io.Serializable;\nimport entities.Zombie;\nimport entities.NormalZombie;\nimport entities.TankZombie;\nimport entities.CrawlerZombie;\nimport entities.AcidSpitterZombie;\n\npublic class ZombieData implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    public String type;\n    public int worldX, worldY;\n    public int health;\n\n    public ZombieData(Zombie zombie) {\n        this.worldX = zombie.worldX;\n        this.worldY = zombie.worldY;\n        this.health = zombie.health;\n\n        if (zombie instanceof NormalZombie) {\n            this.type = \"NormalZombie\";\n        } else if (zombie instanceof TankZombie) {\n            this.type = \"TankZombie\";\n        } else if (zombie instanceof CrawlerZombie) {\n            this.type = \"CrawlerZombie\";\n        } else if (zombie instanceof AcidSpitterZombie) {\n            this.type = \"AcidSpitterZombie\";\n        }\n    }\n\n    public Zombie createZombie(GamePanel gp) {\n        Zombie zombie = null;\n        switch (type) {\n            case \"NormalZombie\":\n                zombie = new NormalZombie(gp, worldX, worldY);\n                break;\n            case \"TankZombie\":\n                zombie = new TankZombie(gp, worldX, worldY);\n                break;\n            case \"CrawlerZombie\":\n                zombie = new CrawlerZombie(gp, worldX, worldY);\n                break;\n            case \"AcidSpitterZombie\":\n                zombie = new AcidSpitterZombie(gp, worldX, worldY);\n                break;\n        }\n        if (zombie != null) {\n            zombie.health = this.health;\n        }\n        return zombie;\n    }\n}\n",
      "ProjectileData.java": "package main;\n\nimport java.io.Serializable;\nimport entities.Projectile;\nimport entities.PistolBullet;\nimport entities.RifleBullet;\nimport entities.Rocket;\nimport entities.ShotgunPellet;\nimport entities.SniperBullet;\nimport entities.AcidProjectile;\nimport entities.AcidSpitterZombie;\n\npublic class ProjectileData implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    public String type;\n    public double x, y, dx, dy;\n    public int damage;\n    public int creatorIndex; // asit için\n\n    public ProjectileData(Projectile projectile, GamePanel gp) {\n        this.x = projectile.x;\n        this.y = projectile.y;\n        this.dx = projectile.dx;\n        this.dy = projectile.dy;\n        this.damage = projectile.damage;\n\n        if (projectile instanceof PistolBullet) {\n            this.type = \"PistolBullet\";\n        } else if (projectile instanceof RifleBullet) {\n            this.type = \"RifleBullet\";\n        } else if (projectile instanceof ShotgunPellet) {\n            this.type = \"ShotgunPellet\";\n        } else if (projectile instanceof SniperBullet) {\n            this.type = \"SniperBullet\";\n        } else if (projectile instanceof Rocket) {\n            this.type = \"Rocket\";\n        } else if (projectile instanceof AcidProjectile) {\n            this.type = \"AcidProjectile\";\n            AcidSpitterZombie creator = ((AcidProjectile) projectile).creator;\n            this.creatorIndex = gp.zombieManager.getZombies().indexOf(creator); // asit için\n        }\n    }\n\n    public Projectile createProjectile(GamePanel gp) {\n        switch (type) {\n            case \"PistolBullet\":\n                return new PistolBullet(gp, x, y, x + dx, y + dy, damage, \"/res/projectiles/pistol_bullet.png\");\n            case \"RifleBullet\":\n                return new RifleBullet(gp, x, y, x + dx, y + dy, damage, \"/res/projectiles/rifle_bullet.png\");\n            case \"ShotgunPellet\":\n                return new ShotgunPellet(gp, x, y, x + dx, y + dy, damage, \"/res/projectiles/shotgun_pellet.png\");\n            case \"SniperBullet\":\n                return new SniperBullet(gp, x, y, x + dx, y + dy, damage, \"/res/projectiles/sniper_bullet.png\");\n            case \"Rocket\":\n                return new Rocket(gp, x, y, x + dx, y + dy, damage, \"/res/projectiles/rocket.png\");\n            case \"AcidProjectile\":\n                AcidSpitterZombie creator = null;\n                if (creatorIndex >= 0 && creatorIndex < gp.zombieManager.getZombies().size()) {\n                    creator = (AcidSpitterZombie) gp.zombieManager.getZombies().get(creatorIndex);\n                }\n                return new AcidProjectile(gp, x, y, x + dx, y + dy, damage, creator);\n            default:\n                return null;\n        }\n    }\n}\n",
      "MainMenu.java": "package main;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class MainMenu extends JPanel {\n    private GamePanel gp;\n    private JPanel container;\n\n    public MainMenu(GamePanel gp, JPanel container) {\n        this.gp = gp;\n        this.container = container;\n        setLayout(new BorderLayout());\n        setBackground(new Color(0, 0, 0, 200)); \n\n        // Title Panel\n        JPanel titlePanel = new JPanel();\n        titlePanel.setOpaque(false);\n        JLabel titleLabel = new JLabel(\"Top Down Shooter\");\n        titleLabel.setFont(new Font(\"Arial\", Font.BOLD, 48));\n        titleLabel.setForeground(Color.WHITE);\n        titlePanel.add(titleLabel);\n\n        // Button Panel\n        JPanel buttonPanel = new JPanel();\n        buttonPanel.setOpaque(false);\n        buttonPanel.setLayout(new GridLayout(3, 1, 10, 10));\n        buttonPanel.setBorder(BorderFactory.createEmptyBorder(20, 100, 20, 100));\n\n        JButton startButton = createMenuButton(\"Start New Game\");\n        JButton loadButton = createMenuButton(\"Load Game\");\n        JButton exitButton = createMenuButton(\"Exit\");\n\n        buttonPanel.add(startButton);\n        buttonPanel.add(loadButton);\n        buttonPanel.add(exitButton);\n\n       \n        add(titlePanel, BorderLayout.NORTH);\n        add(buttonPanel, BorderLayout.CENTER);\n\n        // listener ekle\n        startButton.addActionListener(e -> {\n            gp.startNewGame();\n            switchToGame();\n        });\n\n        loadButton.addActionListener(e -> {\n            if (gp.loadGame()) {\n                gp.setGameState(GameState.PLAYING); \n                gp.gameRunning = true; \n                switchToGame(); \n            } else {\n                JOptionPane.showMessageDialog(this, \"Failed to load game\", \"Error\", JOptionPane.ERROR_MESSAGE);\n            }\n        });\n\n        exitButton.addActionListener(e -> System.exit(0));\n    }\n\n    private JButton createMenuButton(String text) {\n        JButton button = new JButton(text);\n        button.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        button.setForeground(Color.WHITE);\n        button.setBackground(new Color(70, 90, 70));\n        button.setFocusPainted(false);\n        button.setBorderPainted(false);\n        button.setOpaque(true);\n        button.setContentAreaFilled(true);\n        button.setPreferredSize(new Dimension(200, 50));\n        return button;\n    }\n\n    private void switchToGame() {\n        CardLayout cl = (CardLayout) container.getLayout();\n        cl.show(container, \"Game\");\n        gp.requestFocusInWindow(); \n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        \n        g.setColor(new Color(0, 0, 123, 200));\n        g.fillRect(0, 0, getWidth(), getHeight());\n    }\n\n    public void handleInput(int keyCode) {\n        if (!isEnabled()) {\n            return; \n        }\n\n        switch (keyCode) {\n            case KeyEvent.VK_ENTER:\n                gp.setGameState(GameState.PLAYING);\n                gp.startNewGame();\n                break;\n            case KeyEvent.VK_L:\n                if (gp.loadGame()) {\n                    gp.setGameState(GameState.PLAYING);\n                    gp.gameRunning = true;\n                } else {\n                    JOptionPane.showMessageDialog(this, \"Failed to load game\", \"Error\", JOptionPane.ERROR_MESSAGE);\n                }\n                break;\n            case KeyEvent.VK_ESCAPE:\n                System.exit(0);\n                break;\n        }\n    }\n}",
      "GamePanel.java": "package main;\n\nimport java.awt.CardLayout;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.RenderingHints;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseMotionListener;\nimport java.awt.event.KeyEvent;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.awt.Component;\n\nimport javax.swing.JPanel;\n\nimport entities.Player;\nimport entities.ProjectileManager;\nimport entities.Zombie;\nimport entities.ZombieManager;\nimport tile.TileOperations;\n\npublic class GamePanel extends JPanel implements Runnable, MouseMotionListener {\n    final int defaultTileSize = 32; // default character 32x32 pixel olcak\n    final int scale = 2;\n\n    public final int tileSize = defaultTileSize * scale;\n    public final int maxScreenColumns = 16;\n    public final int maxScreenRows = 12; // 4:3 yani\n    public final int scrWidth = maxScreenColumns * tileSize; // 1024 px\n    public final int scrHeight = maxScreenRows * tileSize; // 768 px\n\n    GameState gameState = GameState.MAIN_MENU;\n\n    public int mouseX;\n    public int mouseY;\n\n    // map\n    public final int maxMapCol = 50;\n    public final int maxMapRow = 50;\n    public final int mapWidth = tileSize * maxMapCol;\n    public final int mapHeight = tileSize * maxMapRow;\n    public File saveFile = new File(\"/src/res/saveFile.dat\");\n\n    KeyHandler kH = new KeyHandler(this);\n\n    public CollisionCheck colCheck = new CollisionCheck(this);\n    int FPS = 60;\n    public Player player = new Player(this, kH);\n    public TileOperations to = new TileOperations(this);\n\n    Thread gameThread;\n    public ProjectileManager projectileManager;\n    public ZombieManager zombieManager;\n    boolean gameRunning = true;\n    public int score = 0;\n    int waveNumber = 0;\n\n    private JPanel container;\n\n    public GamePanel(JPanel container) {\n        this.container = container;\n        this.setPreferredSize(new Dimension(scrWidth, scrHeight));\n        this.setBackground(Color.BLACK);\n        this.setDoubleBuffered(true); // render optimizasyonu için\n        this.setLayout(null);\n\n        addMouseMotionListener(this);\n        this.addKeyListener(kH);\n        this.addMouseListener(kH);\n        this.setFocusable(true);\n        zombieManager = new ZombieManager(this);\n        projectileManager = new ProjectileManager(this);\n        zombieManager.startNewWave();\n\n        DeathMenu deathMenu = new DeathMenu(this, container);\n        container.add(deathMenu, \"DeathMenu\");\n\n        PauseMenu pauseMenu = new PauseMenu(this, container);\n        container.add(pauseMenu, \"PauseMenu\");\n\n        startGameThread();\n    }\n\n    public void startGameThread() {\n        if (gameThread == null || !gameThread.isAlive()) {\n            gameThread = new Thread(this);\n            gameThread.start();\n        }\n    }\n\n    public void setGameState(GameState state) {\n        this.gameState = state;\n\n        CardLayout cl = (CardLayout) container.getLayout();\n        if (state == GameState.GAME_OVER) {\n            \n            for (Component component : container.getComponents()) {\n                if (component instanceof DeathMenu) {\n                    DeathMenu deathMenu = (DeathMenu) component;\n                    deathMenu.updateStats(this); // ölüm menüsünü güncelle\n                    break;\n                }\n            }\n            cl.show(container, \"DeathMenu\");\n        } else if (state == GameState.MAIN_MENU) {\n            cl.show(container, \"Menu\");\n        } else if (state == GameState.PLAYING) {\n            cl.show(container, \"Game\");\n        } else if (state == GameState.PAUSED) {\n            cl.show(container, \"PauseMenu\");\n        }\n    }\n\n    @Override\n    public void run() {\n        double drawInterval = 1000000000 / FPS; // saniye bölü fps (0.1666 saniyede bir drawlıcak)\n        double nextDrawTime = drawInterval + System.nanoTime();\n\n        while (gameThread != null && gameRunning) {\n            \n\n            update();\n\n            repaint();\n\n            try {\n                double remainingDrawTime = nextDrawTime - System.nanoTime();\n                remainingDrawTime = remainingDrawTime / 1000000;\n                if (remainingDrawTime < 0) {\n                    remainingDrawTime = 0;\n                }\n                Thread.sleep((long) remainingDrawTime);\n\n                nextDrawTime += drawInterval;\n\n            } catch (InterruptedException e) {\n\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    public void update() {\n        if (gameRunning && gameState == GameState.PLAYING) { \n            player.update();\n            zombieManager.update();\n            projectileManager.update();\n\n            // collision mantığı\n            for (Zombie zombie : zombieManager.getZombies()) {\n                if (zombie.collisionOn) {\n                    zombie.stopMovement();\n                }\n            }\n\n            if (zombieManager.isWaveComplete()) {\n                zombieManager.startNewWave();\n            }\n        }\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        // double buffer\n        super.paintComponent(g);\n\n        Graphics2D g2d = (Graphics2D) g;\n\n        g2d.setColor(Color.BLACK);\n        g2d.fillRect(0, 0, scrWidth, scrHeight);\n\n        if (gameState == GameState.PLAYING) {\n\n            to.draw(g2d);\n            zombieManager.draw(g2d);\n            projectileManager.draw(g2d);\n            player.draw(g2d);\n        }\n\n        drawUI(g2d);\n    }\n\n    private void drawUI(Graphics2D g2d) {\n        // daha yumuşak bir yazı için\n        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n\n        g2d.setFont(new Font(\"Arial\", Font.PLAIN, 14));\n        g2d.setColor(Color.WHITE);\n\n        // silah ve mermi bilgisi\n        String weaponName = player.weapons[player.currentWeaponIndex].getName();\n        String ammoText = player.weapons[player.currentWeaponIndex].getCurrentAmmo() + \"/\" +\n                player.weapons[player.currentWeaponIndex].getAmmoReserve();\n        g2d.drawString(weaponName, 20, 30);\n        g2d.drawString(ammoText, 20, 50);\n\n        // can barı\n        drawPlayerHealthBar(g2d, scrWidth - 140, 20);\n\n        // skor\n        String scoreText = \"Score: \" + score;\n        g2d.drawString(scoreText, scrWidth - 140, 60);\n\n        // dalga sayısı ve dalga numarası\n        String waveText = \"Wave: \" + zombieManager.getWaveNumber();\n        String zombiesText = \"Zombies: \" + zombieManager.getAliveZombies();\n        g2d.drawString(waveText, 20, scrHeight - 40);\n        g2d.drawString(zombiesText, 20, scrHeight - 20);\n    }\n\n    private void drawPlayerHealthBar(Graphics2D g2d, int x, int y) {\n        int barWidth = 100;\n        int barHeight = 10;\n\n        g2d.setColor(Color.GRAY);\n        g2d.fillRect(x, y, barWidth, barHeight);\n\n        float healthPercentage = (float) player.getCurrentHealth() / player.getMaxHealth();\n        Color healthColor = healthPercentage > 0.6f ? Color.GREEN : healthPercentage > 0.3f ? Color.YELLOW : Color.RED;\n\n        g2d.setColor(healthColor);\n        g2d.fillRect(x, y, (int) (barWidth * healthPercentage), barHeight);\n\n        g2d.setColor(Color.BLACK);\n        g2d.drawRect(x, y, barWidth, barHeight);\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n\n    }\n\n    public void addScore(int i) {\n        score += i;\n    }\n\n    public void gameOver() {\n        setGameState(GameState.GAME_OVER);\n        gameRunning = false;\n    }\n\n    public void startNewGame() {\n\n        player = new Player(this, kH);\n        zombieManager = new ZombieManager(this);\n        projectileManager = new ProjectileManager(this);\n        score = 0;\n        waveNumber = 0;\n\n        // sadece pistol başta\n        player.weapons[0].unlock();\n        player.weapons[0].setAmmoReserve(9999);\n        player.currentWeaponIndex = 0;\n        for (int i = 1; i < player.weapons.length; i++) {\n            player.weapons[i].lock(); // diğer silahları kilitle\n        }\n\n        zombieManager.startNewWave();\n        gameRunning = true;\n        setGameState(GameState.PLAYING);\n        requestFocusInWindow();\n\n        startGameThread();\n    }\n\n    public void saveGame() {\n        try {\n            File saveFile = new File(System.getProperty(\"user.dir\") + \"/saveFile.dat\");\n            try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(saveFile))) {\n                GameData data = new GameData(player, zombieManager, projectileManager, this);\n                oos.writeObject(data);\n                System.out.println(\"Game quicksaved successfully!\");\n            }\n        } catch (IOException e) {\n            System.err.println(\"Failed to quicksave game: \" + e.getMessage());\n        }\n    }\n\n    public boolean loadGame() {\n        try {\n            File saveFile = new File(System.getProperty(\"user.dir\") + \"/saveFile.dat\");\n            if (!saveFile.exists()) {\n                System.out.println(\"No quicksave file found\");\n                return false;\n            }\n            try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(saveFile))) {\n                GameData data = (GameData) ois.readObject();\n                // oyuncu durumunu geri yükle\n                player = new Player(this, kH);\n                player.setDefaultValues();\n                player.worldX = data.playerX;\n                player.worldY = data.playerY;\n                player.currentHealth = data.playerHealth;\n                player.currentWeaponIndex = data.currentWeaponIndex;\n                for (int i = 0; i < player.weapons.length; i++) {\n                    player.weapons[i].setAmmoReserve(data.weaponReserve[i]);\n                    player.weapons[i].currentAmmo = data.weaponAmmo[i];\n                    if (data.weaponsUnlocked[i]) {\n                        player.weapons[i].unlock();\n                    }\n                }\n                // oyun durumunu geri yükle\n                score = data.score;\n                zombieManager.waveNumber = data.waveNumber;\n\n                zombieManager.setTotalZombiesKilled(data.totalZombiesKilled);\n\n                // zombie durumunu geri yükle\n                zombieManager.clearZombies();\n                for (ZombieData zombieData : data.zombies) {\n                    Zombie zombie = zombieData.createZombie(this);\n                    zombieManager.addZombie(zombie);\n                }\n\n                // projectile durumunu geri yükle\n                projectileManager.clear();\n                for (ProjectileData projectileData : data.projectiles) {\n                    projectileManager.addProjectile(projectileData.createProjectile(this));\n                }\n\n                System.out.println(\"Game quickloaded successfully!\");\n\n                kH.resetInputFlags();\n\n                // inputlar bozulmasın diye tekrar ekliyoruz\n                this.removeKeyListener(kH);\n                this.addKeyListener(kH);\n\n                // threadi başlat\n                gameRunning = true;\n                setGameState(GameState.PLAYING);\n                startGameThread();\n\n                return true;\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to quickload game: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    public void handleInput(int keyCode) {\n        if (gameState == GameState.PLAYING && keyCode == KeyEvent.VK_ESCAPE) {\n            setGameState(GameState.PAUSED);\n            CardLayout cl = (CardLayout) container.getLayout();\n            cl.show(container, \"PauseMenu\");\n        } else if (gameState == GameState.PAUSED && keyCode == KeyEvent.VK_ESCAPE) {\n            setGameState(GameState.PLAYING);\n            requestFocusInWindow();\n        }\n    }\n}\n",
      "KeyHandler.java": "package main;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.io.Serializable;\n\nimport javax.swing.SwingUtilities;\n\npublic class KeyHandler implements KeyListener, MouseListener, Serializable {\n    // klavye kontrolleri\n    public boolean upPressed, downPressed, leftPressed, rightPressed;\n    public boolean number1Pressed, number2Pressed, number3Pressed,\n            number4Pressed, number5Pressed, reloadPressed;\n    public GamePanel gp;\n\n    // mouse kontrolleri\n    public boolean shootPressed;\n    public boolean rightClickPressed; \n\n    public KeyHandler(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int keyCode = e.getKeyCode();\n\n        \n        gp.handleInput(keyCode);\n\n        \n        switch (keyCode) {\n            case KeyEvent.VK_1:\n                number1Pressed = true;\n                break;\n            case KeyEvent.VK_2:\n                number2Pressed = true;\n                break;\n            case KeyEvent.VK_3:\n                number3Pressed = true;\n                break;\n            case KeyEvent.VK_4:\n                number4Pressed = true;\n                break;\n            case KeyEvent.VK_5:\n                number5Pressed = true;\n                break;\n            case KeyEvent.VK_R:\n                reloadPressed = true;\n                break;\n            case KeyEvent.VK_W:\n                upPressed = true;\n                break;\n            case KeyEvent.VK_A:\n                leftPressed = true;\n                break;\n            case KeyEvent.VK_S:\n                downPressed = true;\n                break;\n            case KeyEvent.VK_D:\n                rightPressed = true;\n                break;\n            case KeyEvent.VK_9:\n                gp.saveGame(); // Quicksave\n                break;\n            case KeyEvent.VK_0:\n                gp.loadGame(); // Quickload\n                break;\n        }\n    }\n\n    public void keyReleased(KeyEvent e) {\n        int keyCode = e.getKeyCode();\n        switch (keyCode) {\n            case KeyEvent.VK_1:\n                number1Pressed = false;\n                break;\n            case KeyEvent.VK_2:\n                number2Pressed = false;\n                break;\n            case KeyEvent.VK_3:\n                number3Pressed = false;\n                break;\n            case KeyEvent.VK_4:\n                number4Pressed = false;\n                break;\n            case KeyEvent.VK_5:\n                number5Pressed = false;\n                break;\n            case KeyEvent.VK_R:\n                reloadPressed = false;\n                break;\n            case KeyEvent.VK_W:\n                upPressed = false;\n                break;\n            case KeyEvent.VK_A:\n                leftPressed = false;\n                break;\n            case KeyEvent.VK_S:\n                downPressed = false;\n                break;\n            case KeyEvent.VK_D:\n                rightPressed = false;\n                break;\n        }\n    }\n\n    \n    @Override\n    public void mousePressed(MouseEvent e) {\n        if (SwingUtilities.isLeftMouseButton(e)) {\n            shootPressed = true;\n        }\n        if (SwingUtilities.isRightMouseButton(e)) {\n            rightClickPressed = true; \n        }\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        if (SwingUtilities.isLeftMouseButton(e)) {\n            shootPressed = false;\n        }\n        if (SwingUtilities.isRightMouseButton(e)) {\n            rightClickPressed = false;\n        }\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e) {\n    }\n\n    public void resetInputFlags() {\n        upPressed = false;\n        downPressed = false;\n        leftPressed = false;\n        rightPressed = false;\n        number1Pressed = false;\n        number2Pressed = false;\n        number3Pressed = false;\n        number4Pressed = false;\n        number5Pressed = false;\n        reloadPressed = false;\n        shootPressed = false;\n        rightClickPressed = false;\n    }\n}",
      "CollisionCheck.java": "package main;\n\nimport java.io.Serializable;\n\nimport entities.Entity;\n\npublic class CollisionCheck implements Serializable {\n    GamePanel gp;\n\n    public CollisionCheck(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    public void checkTile(Entity entity) {\n        if (entity.collidableArea == null) {\n            System.err.println(\"Warning: collidableArea is null for entity: \" + entity);\n            return; \n        }\n\n        int entityLeftWorldX = entity.worldX + entity.collidableArea.x;\n        int entityRightWorldX = entity.worldX + entity.collidableArea.x + entity.collidableArea.width;\n        int entityTopWorldY = entity.worldY + entity.collidableArea.y;\n        int entityBottomWorldY = entity.worldY + entity.collidableArea.y + entity.collidableArea.height;\n\n        int entityLeftWorldCol = entityLeftWorldX / gp.tileSize;\n        int entityRightWorldCol = entityRightWorldX / gp.tileSize;\n        int entityTopWorldRow = entityTopWorldY / gp.tileSize;\n        int entityBottomWorldRow = entityBottomWorldY / gp.tileSize;\n\n        // map sınırları kontrolü\n        if (entityLeftWorldCol < 0 || entityRightWorldCol >= gp.maxMapCol ||\n                entityTopWorldRow < 0 || entityBottomWorldRow >= gp.maxMapRow) {\n            entity.collisionOn = true;\n            return;\n        }\n\n        int tileNum1, tileNum2;\n\n        // tüm yönler için kontrol\n        if (entity.direction.equals(\"up\")) {\n            entityTopWorldRow = (entityTopWorldY - entity.speed) / gp.tileSize;\n            tileNum1 = gp.to.mapTileNumber[entityLeftWorldCol][entityTopWorldRow];\n            tileNum2 = gp.to.mapTileNumber[entityRightWorldCol][entityTopWorldRow];\n        } else if (entity.direction.equals(\"down\")) {\n            entityBottomWorldRow = (entityBottomWorldY + entity.speed) / gp.tileSize;\n            tileNum1 = gp.to.mapTileNumber[entityLeftWorldCol][entityBottomWorldRow];\n            tileNum2 = gp.to.mapTileNumber[entityRightWorldCol][entityBottomWorldRow];\n        } else if (entity.direction.equals(\"left\")) {\n            entityLeftWorldCol = (entityLeftWorldX - entity.speed) / gp.tileSize;\n            tileNum1 = gp.to.mapTileNumber[entityLeftWorldCol][entityTopWorldRow];\n            tileNum2 = gp.to.mapTileNumber[entityLeftWorldCol][entityBottomWorldRow];\n        } else { // \"right\"\n            entityRightWorldCol = (entityRightWorldX + entity.speed) / gp.tileSize;\n            tileNum1 = gp.to.mapTileNumber[entityRightWorldCol][entityTopWorldRow];\n            tileNum2 = gp.to.mapTileNumber[entityRightWorldCol][entityBottomWorldRow];\n        }\n\n        // tile kontrolü\n        if (gp.to.tile.get(tileNum1).collision || gp.to.tile.get(tileNum2).collision) {\n            entity.collisionOn = true;\n            return;\n        }\n\n        \n        if (entity.collisionOn) {\n            if (entity.direction.equals(\"up\")) {\n                entity.worldY = entityTopWorldRow * gp.tileSize + gp.tileSize - entity.collidableArea.y;\n            } else if (entity.direction.equals(\"down\")) {\n                entity.worldY = entityBottomWorldRow * gp.tileSize - entity.collidableArea.y\n                        - entity.collidableArea.height;\n            } else if (entity.direction.equals(\"left\")) {\n                entity.worldX = entityLeftWorldCol * gp.tileSize + gp.tileSize - entity.collidableArea.x;\n            } else if (entity.direction.equals(\"right\")) {\n                entity.worldX = entityRightWorldCol * gp.tileSize - entity.collidableArea.x\n                        - entity.collidableArea.width;\n            }\n        }\n    }\n\n    public boolean checkCollisionAt(double worldX, int worldY) {\n        int leftCol = (int) (worldX / gp.tileSize);\n        int rightCol = (int) ((worldX + gp.tileSize - 1) / gp.tileSize);\n        int topRow = worldY / gp.tileSize;\n        int bottomRow = (worldY + gp.tileSize - 1) / gp.tileSize;\n\n        if (leftCol < 0 || rightCol >= gp.maxMapCol || topRow < 0 || bottomRow >= gp.maxMapRow) {\n            return true;\n        }\n\n        int tileNum1 = gp.to.mapTileNumber[leftCol][topRow];\n        int tileNum2 = gp.to.mapTileNumber[rightCol][topRow];\n        int tileNum3 = gp.to.mapTileNumber[leftCol][bottomRow];\n        int tileNum4 = gp.to.mapTileNumber[rightCol][bottomRow];\n\n        boolean collision = gp.to.tile.get(tileNum1).collision || gp.to.tile.get(tileNum2).collision ||\n                gp.to.tile.get(tileNum3).collision || gp.to.tile.get(tileNum4).collision;\n\n        if (collision) {\n            System.out.println(\"Collision detected at (\" + worldX + \", \" + worldY + \")\");\n        }\n\n        return collision;\n    }\n\n}\n",
      "DeathMenu.java": "package main;\n\nimport java.awt.*;\nimport javax.swing.*;\nimport java.awt.event.ActionEvent;\n\npublic class DeathMenu extends JPanel {\n    private JLabel waveLabel;\n    private JLabel zombiesKilledLabel;\n    private JLabel totalScoreLabel;\n    GamePanel gp;\n    JPanel container;\n\n    public DeathMenu(GamePanel gp, JPanel container) {\n        this.gp = gp;\n        this.container = container;\n        setLayout(new BorderLayout());\n        setBackground(new Color(0, 0, 0, 200));\n\n        // Title Panel\n        JPanel titlePanel = new JPanel();\n        titlePanel.setOpaque(false);\n        JLabel titleLabel = new JLabel(\"GAME OVER\");\n        titleLabel.setFont(new Font(\"Arial\", Font.BOLD, 48));\n        titleLabel.setForeground(Color.RED);\n        titlePanel.add(titleLabel);\n\n        // Stats Panel\n        JPanel statsPanel = new JPanel();\n        statsPanel.setOpaque(false);\n        statsPanel.setLayout(new GridLayout(3, 1, 10, 10));\n        statsPanel.setBorder(BorderFactory.createEmptyBorder(20, 100, 20, 100));\n\n        waveLabel = new JLabel();\n        waveLabel.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        waveLabel.setForeground(Color.WHITE);\n\n        zombiesKilledLabel = new JLabel();\n        zombiesKilledLabel.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        zombiesKilledLabel.setForeground(Color.WHITE);\n\n        totalScoreLabel = new JLabel();\n        totalScoreLabel.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        totalScoreLabel.setForeground(Color.WHITE);\n\n        statsPanel.add(waveLabel);\n        statsPanel.add(zombiesKilledLabel);\n        statsPanel.add(totalScoreLabel);\n\n        JPanel buttonPanel = new JPanel();\n        buttonPanel.setOpaque(false);\n        buttonPanel.setLayout(new GridLayout(1, 1, 10, 10));\n        buttonPanel.setBorder(BorderFactory.createEmptyBorder(20, 100, 20, 100));\n\n        JButton mainMenuButton = createMenuButton(\"Main Menu\");\n        buttonPanel.add(mainMenuButton);\n\n        add(titlePanel, BorderLayout.NORTH);\n        add(statsPanel, BorderLayout.CENTER);\n        add(buttonPanel, BorderLayout.SOUTH);\n\n        mainMenuButton.addActionListener((ActionEvent e) -> {\n            gp.setGameState(GameState.MAIN_MENU);\n            CardLayout cl = (CardLayout) container.getLayout();\n            cl.show(container, \"Menu\");\n        });\n    }\n\n    public void updateStats(GamePanel gp) {\n        waveLabel.setText(\"Wave Reached: \" + gp.zombieManager.getWaveNumber());\n        zombiesKilledLabel.setText(\"Zombies Killed: \" + gp.zombieManager.getTotalZombiesKilled());\n        totalScoreLabel.setText(\"Total Score: \" + gp.score);\n    }\n\n    private JButton createMenuButton(String text) {\n        JButton button = new JButton(text);\n        button.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        button.setForeground(Color.WHITE);\n        button.setBackground(new Color(Color.BLACK.getRGB()));\n        button.setFocusPainted(false);\n        button.setBorderPainted(false);\n        button.setOpaque(true);\n        button.setContentAreaFilled(true);\n        button.setPreferredSize(new Dimension(200, 50));\n        return button;\n    }\n}\n",
      "Game.java": "package main;\n\nimport java.awt.CardLayout;\nimport java.io.Serializable;\nimport javax.swing.*;\n\npublic class Game implements Serializable {\n\n    public static void main(String[] args) {\n        JFrame window = new JFrame();\n        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        window.setResizable(false);\n        window.setTitle(\"Top Down Shooter\");\n\n        JPanel container = new JPanel(new CardLayout());\n\n        // paneller\n        GamePanel gamePanel = new GamePanel(container);\n        MainMenu mainMenu = new MainMenu(gamePanel, container);\n\n        // containere ekle\n        container.add(mainMenu, \"Menu\");\n        container.add(gamePanel, \"Game\");\n        window.add(container);\n\n        window.pack(); \n        window.setLocationRelativeTo(null); \n        window.setVisible(true);\n\n        \n        CardLayout cl = (CardLayout) (container.getLayout());\n        cl.show(container, \"Menu\");\n    }\n}\n",
      "GameData.java": "package main;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\n\nimport entities.Player;\nimport entities.Zombie;\nimport entities.ZombieManager;\nimport entities.Projectile;\nimport entities.ProjectileManager;\n\npublic class GameData implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    // oyuncu verileri\n    public int playerHealth;\n    public int playerX, playerY;\n    public int currentWeaponIndex;\n\n    //silah verileri\n    public int[] weaponAmmo;\n    public int[] weaponReserve;\n    public boolean[] weaponsUnlocked;\n\n    // oyun durumu\n    public int score;\n    public int waveNumber;\n    public int totalZombiesKilled; \n    public int totalScore; \n\n    // zombiler\n    public ArrayList<ZombieData> zombies;\n\n    // projectile verileri\n    public ArrayList<ProjectileData> projectiles;\n\n    public GameData(Player player, ZombieManager zm, ProjectileManager pm, GamePanel gp) {\n        // oyuncu durumunu kaydet\n        this.playerHealth = player.getCurrentHealth();\n        this.playerX = player.worldX;\n        this.playerY = player.worldY;\n        this.currentWeaponIndex = player.currentWeaponIndex;\n\n        // silah durumunu kaydet\n        this.weaponAmmo = new int[player.weapons.length];\n        this.weaponReserve = new int[player.weapons.length];\n        this.weaponsUnlocked = new boolean[player.weapons.length];\n\n        for (int i = 0; i < player.weapons.length; i++) {\n            weaponAmmo[i] = player.weapons[i].getCurrentAmmo();\n            weaponReserve[i] = player.weapons[i].getAmmoReserve();\n            weaponsUnlocked[i] = player.weapons[i].isUnlocked();\n        }\n\n        // oyun durumunu kaydet\n        this.score = gp.score;\n        this.waveNumber = zm.getWaveNumber();\n        this.totalZombiesKilled = gp.zombieManager.getTotalZombiesKilled(); \n        this.totalScore = gp.score;\n\n        // zombileri kaydet\n        this.zombies = new ArrayList<>();\n        for (Zombie zombie : zm.getZombies()) {\n            if (zombie.isAlive()) {\n                zombies.add(new ZombieData(zombie));\n            }\n        }\n\n        // projectile'leri kaydet\n        this.projectiles = new ArrayList<>();\n        for (Projectile projectile : pm.getProjectiles()) {\n            projectiles.add(new ProjectileData(projectile, gp)); \n        }\n    }\n}",
      "GameState.java": "package main;\n\npublic enum GameState {\n    MAIN_MENU,\n    PLAYING,\n    PAUSED,\n    GAME_OVER\n}\n",
      "Projectile.java": "package entities;\n\nimport main.GamePanel;\nimport java.awt.Graphics2D;\nimport java.awt.Color;\n\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\n\npublic abstract class Projectile implements Serializable {\n    protected GamePanel gp;\n    public double x; // haritadaki koordinatları\n    public double y;\n    public double dx; //yön vektörü\n    public double dy;\n    protected int speed;\n    public int damage;\n    protected int maxDistance;\n    protected double distanceTraveled;\n    protected boolean alive = true;\n    protected Color color;\n    protected int size;\n\n    public Projectile(GamePanel gp, double startX, double startY,\n            double targetX, double targetY, int damage) {\n        this.gp = gp;\n        this.x = startX;\n        this.y = startY;\n        this.damage = damage;\n\n        // yön vektörünü hesapla\n        double angle = Math.atan2(targetY - startY, targetX - startX);\n        this.dx = Math.cos(angle);\n        this.dy = Math.sin(angle);\n\n        // default değerler\n        this.speed = 10;\n        this.maxDistance = 500;\n        this.size = 4;\n        this.color = Color.YELLOW;\n    }\n\n    public void update() {\n        // hareket\n        x += dx * speed;\n        y += dy * speed;\n        distanceTraveled += speed;\n\n        \n        if (distanceTraveled >= maxDistance) {\n            alive = false;\n            return;\n        }\n\n        \n        checkZombieCollisions();\n\n        \n        checkWallCollisions();\n    }\n\n    protected void checkZombieCollisions() {\n        for (Zombie zombie : gp.zombieManager.getZombies()) {\n            if (zombie.isAlive() && collidesWith(zombie)) {\n                onHit(zombie);\n                alive = false;\n                return;\n            }\n        }\n    }\n\n    protected boolean collidesWith(Zombie zombie) {\n        \n        double zombieCenterX = zombie.worldX + zombie.collidableArea.width / 2;\n        double zombieCenterY = zombie.worldY + zombie.collidableArea.height / 2;\n        double distance = Point2D.distance(x, y, zombieCenterX, zombieCenterY);\n        return distance < (size + zombie.collidableArea.width / 2);\n    }\n\n    protected void checkWallCollisions() {\n        \n        int tileX = (int) (x / gp.tileSize);\n        int tileY = (int) (y / gp.tileSize);\n\n        \n        if (tileX < 0 || tileX >= gp.maxMapCol || tileY < 0 || tileY >= gp.maxMapRow) {\n            alive = false;\n            return;\n        }\n\n        // collision kontrolü\n        int tileNum = gp.to.mapTileNumber[tileX][tileY];\n        if (gp.to.tile.get(tileNum).collision) {\n            onWallHit();\n            alive = false;\n        }\n    }\n\n    public void draw(Graphics2D g2d) {\n        int screenX = (int) (x - gp.player.worldX + gp.player.screenX);\n        int screenY = (int) (y - gp.player.worldY + gp.player.screenY);\n\n        // ekrandaysa çiz\n        if (screenX > -size && screenX < gp.scrWidth + size &&\n                screenY > -size && screenY < gp.scrHeight + size) {\n            double angle = Math.atan2(dy, dx); \n            drawProjectile(g2d, screenX, screenY, angle);\n        }\n    }\n\n    // subclass'lar için çizim metodu\n    protected abstract void drawProjectile(Graphics2D g2d, int screenX, int screenY, double angle);\n\n    \n    protected void onHit(Zombie zombie) {\n        zombie.takeDamage(damage);\n    }\n\n    protected void onWallHit() {\n        //duvara çarpınca bişey yapmıyor\n    }\n\n    public boolean isAlive() {\n        return alive;\n    }\n}",
      "Zombie.java": "package entities;\n\nimport java.awt.Graphics2D;\nimport java.awt.Color;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\n\nimport entities.weapons.Gun;\n\nimport java.util.ArrayList;\nimport java.io.IOException;\n\nimport main.GamePanel;\n\npublic abstract class Zombie extends Entity {\n    protected GamePanel gp;\n    public int health;\n    protected int maxHealth;\n    protected double speed;\n    protected int damage;\n    protected Color color;\n    protected boolean isAlive = true;\n    protected Rectangle collidableArea = new Rectangle();\n    protected String imagePath;\n    protected BufferedImage image;\n    public boolean collisionOn = true;\n    protected String direction;\n\n    public Zombie(GamePanel gp, int worldX, int worldY, String imagePath) {\n        this.gp = gp;\n        this.worldX = worldX;\n        this.worldY = worldY;\n\n        // zombi collision alanı\n        collidableArea = new Rectangle(8, 8, gp.tileSize - 16, gp.tileSize - 16);\n\n        loadImage(imagePath);\n    }\n\n    private void loadImage(String imagePath) {\n        try {\n            image = ImageIO.read(getClass().getResourceAsStream(imagePath));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void update() {\n        collisionOn = false;\n        gp.colCheck.checkTile(this);\n\n        if (!collisionOn) {\n            moveTowardsPlayer();\n        } else {\n            \n            return; // collision varsa hareket etmemeyi uygulamaya çalıştım\n        }\n    }\n\n    public void draw(Graphics2D g2d) {\n        int screenX = worldX - gp.player.worldX + gp.player.screenX;\n        int screenY = worldY - gp.player.worldY + gp.player.screenY;\n\n        // oyuncuya bakış açısını hesapla\n        double angle = calculateAngleToPlayer();\n\n        // döndür ve çiz\n        g2d.rotate(angle, screenX + gp.tileSize / 2, screenY + gp.tileSize / 2);\n        if (image != null) {\n            g2d.drawImage(image, screenX, screenY, gp.tileSize, gp.tileSize, null);\n        } else {\n            g2d.setColor(color);\n            g2d.fillRect(screenX, screenY, gp.tileSize, gp.tileSize);\n        }\n        g2d.rotate(-angle, screenX + gp.tileSize / 2, screenY + gp.tileSize / 2);\n\n        drawHealthBar(g2d, screenX, screenY);\n    }\n\n    protected double calculateAngleToPlayer() {\n        return Math.atan2(gp.player.worldY - worldY, gp.player.worldX - worldX);\n    }\n\n    protected void drawHealthBar(Graphics2D g2d, int screenX, int screenY) {\n        int barWidth = gp.tileSize;\n        int barHeight = 5;\n        int barX = screenX;\n        int barY = screenY - 10;\n\n        double healthPercentage = (double) health / maxHealth;\n\n        \n        g2d.setColor(Color.RED);\n        g2d.fillRect(barX, barY, barWidth, barHeight);\n\n        \n        g2d.setColor(Color.GREEN);\n        g2d.fillRect(barX, barY, (int) (barWidth * healthPercentage), barHeight);\n\n        \n        g2d.setColor(Color.BLACK);\n        g2d.drawRect(barX, barY, barWidth, barHeight);\n    }\n\n    public void takeDamage(int damage) {\n        health -= damage;\n        if (health <= 0) {\n            die();\n        }\n    }\n\n    public boolean collisionWithPlayer() {\n        Rectangle zombieRect = new Rectangle(worldX + collidableArea.x, worldY + collidableArea.y,\n                collidableArea.width, collidableArea.height);\n        Rectangle playerRect = new Rectangle(gp.player.worldX + gp.player.collidableArea.x,\n                gp.player.worldY + gp.player.collidableArea.y,\n                gp.player.collidableArea.width, gp.player.collidableArea.height);\n        return zombieRect.intersects(playerRect);\n    }\n\n    public void dropAmmo() {\n        // mermi alabilecek silahları kontrol et\n        ArrayList<Gun> possibleWeapons = new ArrayList<>();\n        for (Gun weapon : gp.player.weapons) {\n            if (weapon.isUnlocked()) {\n                possibleWeapons.add(weapon);\n            }\n        }\n\n        if (!possibleWeapons.isEmpty()) {\n            // rastgele bir silah seç\n            Gun selectedWeapon = possibleWeapons.get((int) (Math.random() * possibleWeapons.size()));\n\n            \n            int amount = selectedWeapon.maxAmmo;\n\n            // mermi ekle\n            selectedWeapon.setAmmoReserve(selectedWeapon.getAmmoReserve() + amount);\n\n        }\n    }\n\n    public void die() {\n        isAlive = false;\n        dropAmmo();\n       \n        \n    }\n\n    public boolean isAlive() {\n        return isAlive;\n    }\n\n    // hareket mantığı\n    protected void moveTowardsPlayer() {\n        double dx = gp.player.worldX - this.worldX;\n        double dy = gp.player.worldY - this.worldY;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance > 0) {\n            dx /= distance;\n            dy /= distance;\n\n            \n            double adjustedSpeed = speed * 1.5;\n\n            \n            int newWorldX = (int) (worldX + dx * adjustedSpeed);\n            int newWorldY = (int) (worldY + dy * adjustedSpeed);\n\n            \n            collisionOn = false;\n            gp.colCheck.checkTile(this);\n\n            if (!collisionOn) {\n                worldX = newWorldX;\n                worldY = newWorldY;\n            } else {\n                \n                if (!gp.colCheck.checkCollisionAt(newWorldX, worldY)) {\n                    worldX = newWorldX;\n                } else if (!gp.colCheck.checkCollisionAt(worldX, newWorldY)) {\n                    worldY = newWorldY;\n                }\n            }\n        }\n    }\n}",
      "Entity.java": "package entities;\n\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.Serializable;\n\npublic class Entity implements Serializable {\n    public int worldX, worldY;\n    public int speed = 4;\n    public BufferedImage standing;\n    public String direction = \"right\";\n    public Rectangle collidableArea;\n    public boolean collisionOn = true;\n\n    public Entity() {\n        \n        collidableArea = new Rectangle(0, 0, 32, 32); \n    }\n\n    public void stopMovement() {\n        // collision için durdurma\n        speed = 0;\n    }\n}\n",
      "SniperBullet.java": "package entities;\n\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport main.GamePanel;\n\npublic class SniperBullet extends Projectile {\n    private BufferedImage image;\n\n    public SniperBullet(GamePanel gp, double startX, double startY,\n            double targetX, double targetY, int damage, String projectileImagePath) {\n        super(gp, startX, startY, targetX, targetY, damage);\n        this.speed = 30;\n        this.maxDistance = 1000;\n        \n        this.size = 5;\n\n        try {\n            this.image = ImageIO.read(getClass().getResourceAsStream(projectileImagePath));\n        } catch (IOException e) {\n            e.printStackTrace();\n            this.image = null;\n        }\n    }\n\n    @Override\n    protected void onHit(Zombie zombie) {\n        zombie.takeDamage(damage);\n        \n    }\n\n    @Override\n    protected void checkZombieCollisions() {\n        for (Zombie zombie : gp.zombieManager.getZombies()) {\n            if (zombie.isAlive() && collidesWith(zombie)) {\n                onHit(zombie);\n                // içinden geçmesi için return yok\n            }\n        }\n    }\n\n    @Override\n    protected void drawProjectile(Graphics2D g2d, int screenX, int screenY, double angle) {\n        if (image != null) {\n            Graphics2D g2dRotated = (Graphics2D) g2d.create();\n            g2dRotated.rotate(angle, screenX, screenY);\n            g2dRotated.drawImage(image, screenX - image.getWidth() / 2,\n                    screenY - image.getHeight() / 2, null);\n            g2dRotated.dispose();\n        } else {\n            g2d.setColor(color);\n            g2d.fillOval(screenX - size / 2, screenY - size / 2, size, size);\n        }\n    }\n}\n",
      "NormalZombie.java": "package entities;\n\nimport main.GamePanel;\n\nimport java.awt.Graphics2D;\n\npublic class NormalZombie extends Zombie {\n    public NormalZombie(GamePanel gp, int worldX, int worldY) {\n        super(gp, worldX, worldY, \"/res/zombies/NormalZombie.png\");\n        this.maxHealth = 50;\n        this.health = maxHealth;\n        this.speed = 1;\n        this.damage = 10;\n        \n    }\n\n    @Override\n    public void update() {\n        moveTowardsPlayer();\n\n        \n        if (collisionWithPlayer()) {\n            gp.player.takeDamage(damage);\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        super.draw(g2d); \n    }\n}\n",
      "AcidProjectile.java": "package entities;\n\nimport main.GamePanel;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class AcidProjectile extends Projectile {\n    private static final int SPLASH_RADIUS = 60; \n    private static final int SPLASH_DAMAGE = 10; \n    private BufferedImage acidImage;\n    private double targetX; \n    private double targetY; \n    private double startX; \n    private double startY; \n    public AcidSpitterZombie creator; \n\n    public AcidProjectile(GamePanel gp, double startX, double startY, double targetX, double targetY, int damage,\n            AcidSpitterZombie creator) {\n        super(gp, startX, startY, targetX, targetY, damage);\n        this.creator = creator; \n\n        \n        try {\n            acidImage = ImageIO.read(getClass().getResourceAsStream(\"/res/projectiles/acid_blob.png\"));\n            if (acidImage != null) {\n                this.size = Math.max(acidImage.getWidth(), acidImage.getHeight());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            acidImage = null;\n        }\n\n        // aside özel değerler\n        this.speed = 5; \n        this.maxDistance = 400; \n        this.size = acidImage != null ? size : 8; \n    }\n\n    @Override\n    public void update() {\n        super.update();\n\n        \n        if (collidesWithPlayer()) {\n            onHitPlayer();\n            alive = false; \n            return;\n        }\n    }\n\n    private boolean collidesWithPlayer() {\n        double playerCenterX = gp.player.worldX + gp.player.collidableArea.width / 2.0;\n        double playerCenterY = gp.player.worldY + gp.player.collidableArea.height / 2.0;\n        double distance = Math.sqrt(Math.pow(x - playerCenterX, 2) + Math.pow(y - playerCenterY, 2));\n        return distance < (size + gp.player.collidableArea.width / 2.0);\n    }\n\n    private void onHitPlayer() {\n        gp.player.takeDamage(damage); \n    }\n\n    @Override\n    protected void onHit(Zombie zombie) {\n        if (zombie != creator) { \n            super.onHit(zombie);\n            splashDamage();\n        }\n    }\n\n    @Override\n    protected void onWallHit() {\n        splashDamage();\n    }\n\n    \n    protected void splashDamage() {\n        for (Zombie zombie : gp.zombieManager.getZombies()) {\n            if (zombie.isAlive() && zombie != creator) { \n                double distance = Math.sqrt(Math.pow(zombie.worldX - x, 2) +\n                        Math.pow(zombie.worldY - y, 2));\n\n                if (distance < SPLASH_RADIUS) {\n                    int scaledDamage = (int) (SPLASH_DAMAGE * (1 - (distance / SPLASH_RADIUS)));\n                    zombie.takeDamage(scaledDamage);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        int screenX = (int) (x - gp.player.worldX + gp.player.screenX);\n        int screenY = (int) (y - gp.player.worldY + gp.player.screenY);\n\n        if (isOnScreen(screenX, screenY)) {\n            double angle = Math.atan2(targetY - startY, targetX - startX);\n            drawProjectile(g2d, screenX, screenY, angle);\n        }\n    }\n\n    @Override //playere bakarak döndürme\n    protected void drawProjectile(Graphics2D g2d, int screenX, int screenY, double angle) {\n        if (acidImage != null) {\n            Graphics2D g2dRotated = (Graphics2D) g2d.create();\n            g2dRotated.rotate(angle, screenX, screenY);\n            g2dRotated.drawImage(acidImage, screenX - acidImage.getWidth() / 2,\n                    screenY - acidImage.getHeight() / 2, null);\n            g2dRotated.dispose();\n        } else {\n            g2d.setColor(color);\n            g2d.fillOval(screenX - size / 2, screenY - size / 2, size, size);\n        }\n    }\n\n    private boolean isOnScreen(int screenX, int screenY) {\n        return screenX > -size * 2 && screenX < gp.scrWidth + size * 2 &&\n                screenY > -size * 2 && screenY < gp.scrHeight + size * 2;\n    }\n}",
      "ShotgunPellet.java": "package entities;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\nimport main.GamePanel;\n\npublic class ShotgunPellet extends Projectile {\n    private BufferedImage image;\n\n    public ShotgunPellet(GamePanel gp, double startX, double startY,\n            double targetX, double targetY, int damage, String projectileImagePath) {\n        super(gp, startX, startY, targetX, targetY, damage);\n        this.speed = 18;\n        this.maxDistance = 400;\n        this.color = Color.RED;\n        this.size = 2;\n\n        \n        try {\n            this.image = ImageIO.read(getClass().getResourceAsStream(projectileImagePath));\n        } catch (IOException e) {\n            e.printStackTrace();\n            this.image = null;\n        }\n    }\n\n    @Override\n    protected void drawProjectile(Graphics2D g2d, int screenX, int screenY, double angle) {\n        if (image != null) {\n            Graphics2D g2dRotated = (Graphics2D) g2d.create();\n            g2dRotated.rotate(angle, screenX, screenY);\n            g2dRotated.drawImage(image, screenX - image.getWidth() / 2,\n                    screenY - image.getHeight() / 2, null);\n            g2dRotated.dispose();\n        } else {\n            g2d.setColor(color);\n            g2d.fillOval(screenX - size / 2, screenY - size / 2, size, size);\n        }\n    }\n}",
      "Rocket.java": "package entities;\n\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\nimport main.GamePanel;\n\npublic class Rocket extends Projectile {\n    private BufferedImage image;\n\n    public Rocket(GamePanel gp, double startX, double startY,\n            double targetX, double targetY, int damage, String projectileImagePath) {\n        super(gp, startX, startY, targetX, targetY, damage);\n        this.speed = 8;\n        this.maxDistance = 700;\n        \n        this.size = 8;\n\n        // Load the image\n        try {\n            this.image = ImageIO.read(getClass().getResourceAsStream(projectileImagePath));\n        } catch (IOException e) {\n            e.printStackTrace();\n            this.image = null;\n        }\n    }\n\n    @Override\n    protected void onHit(Zombie zombie) {\n        createExplosionEffect(); // patlama efekti oluştur\n        for (Zombie z : gp.zombieManager.getZombies()) {\n            if (z.isAlive()) {\n                double distance = Math.sqrt(Math.pow(z.worldX - x, 2) +\n                        Math.pow(z.worldY - y, 2));\n                if (distance < 100) { // patlama yarıçapı\n                    z.takeDamage((int) (damage * (1 - distance / 100))); //patlamaya uzaklığa göre hasar ver\n                }\n            }\n        }\n    }\n\n    @Override\n    protected void onWallHit() {\n        createExplosionEffect(); \n        onHit(null); \n    }\n\n    private void createExplosionEffect() {\n        gp.projectileManager.addProjectile(new ExplosionEffect(gp, x, y));\n    }\n\n    @Override\n    protected void drawProjectile(Graphics2D g2d, int screenX, int screenY, double angle) {\n        if (image != null) {\n            Graphics2D g2dRotated = (Graphics2D) g2d.create();\n            g2dRotated.rotate(angle, screenX, screenY);\n            g2dRotated.drawImage(image, screenX - image.getWidth() / 2,\n                    screenY - image.getHeight() / 2, null);\n            g2dRotated.dispose();\n        } else {\n            g2d.setColor(color);\n            g2d.fillOval(screenX - size / 2, screenY - size / 2, size, size);\n        }\n    }\n}\n",
      "PistolBullet.java": "package entities;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport main.GamePanel;\n\npublic class PistolBullet extends Projectile {\n    private BufferedImage image;\n\n    public PistolBullet(GamePanel gp, double startX, double startY,\n            double targetX, double targetY, int damage, String projectileImagePath) {\n        super(gp, startX, startY, targetX, targetY, damage);\n\n        try {\n            this.image = ImageIO.read(getClass().getResourceAsStream(projectileImagePath));\n        } catch (IOException e) {\n            e.printStackTrace();\n            this.image = null;\n        }\n    }\n\n    @Override\n    protected void drawProjectile(Graphics2D g2d, int screenX, int screenY, double angle) {\n        if (image != null) {\n            Graphics2D g2dRotated = (Graphics2D) g2d.create();\n            g2dRotated.rotate(angle, screenX, screenY);\n            g2dRotated.drawImage(image, screenX - image.getWidth() / 2,\n                    screenY - image.getHeight() / 2, null);\n            g2dRotated.dispose();\n        } else {\n            g2d.setColor(color);\n            g2d.fillOval(screenX - size / 2, screenY - size / 2, size, size);\n        }\n    }\n}",
      "AcidSpitterZombie.java": "package entities;\n\nimport java.awt.Graphics2D;\n\nimport main.GamePanel;\n\npublic class AcidSpitterZombie extends Zombie {\n    int spitCooldown = 60;\n\n    public AcidSpitterZombie(GamePanel gp, int worldX, int worldY) {\n        super(gp, worldX, worldY, \"/res/zombies/AcidSpitterZombie.png\");\n        this.maxHealth = 40;\n        this.health = maxHealth;\n        this.speed = 1;\n        this.damage = 15;\n\n    }\n\n    @Override\n    public void update() {\n        double distanceToPlayer = Math.sqrt(Math.pow(gp.player.worldX - worldX, 2) +\n                Math.pow(gp.player.worldY - worldY, 2));\n\n        if (distanceToPlayer > gp.tileSize * 5) {\n            \n            moveTowardsPlayer();\n        } else if (spitCooldown <= 0) {\n            // asit tükür\n            double targetX = gp.player.worldX + gp.player.collidableArea.width / 2.0;\n            double targetY = gp.player.worldY + gp.player.collidableArea.height / 2.0;\n\n            gp.projectileManager.addProjectile(\n                    new AcidProjectile(gp, worldX + gp.tileSize + 5, worldY + gp.tileSize + 5, targetX, targetY,\n                            damage, this));\n            spitCooldown = 90; // 1.5 saniye bekle\n        } else {\n            spitCooldown--;\n        }\n\n        if (collisionWithPlayer()) {\n            gp.player.takeDamage(damage);\n        }\n    }\n\n    @Override\n    public void die() {\n        super.die();\n        // ölünce patla\n        for (Zombie zombie : gp.zombieManager.getZombies()) {\n            if (zombie != this && distanceTo(zombie) < gp.tileSize * 2) {\n                zombie.takeDamage(20); // patlama hasarı\n            }\n        }\n        // patlama efekti\n        gp.projectileManager\n                .addProjectile(new ExplosionEffect(gp, worldX + gp.tileSize / 2.0, worldY + gp.tileSize / 2.0));\n    }\n\n    private double distanceTo(Zombie other) {\n        return Math.sqrt(Math.pow(worldX - other.worldX, 2) +\n                Math.pow(worldY - other.worldY, 2));\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        super.draw(g2d); \n    }\n}",
      "CrawlerZombie.java": "package entities;\n\nimport java.awt.Graphics2D;\n\nimport main.GamePanel;\n\n\n\npublic class CrawlerZombie extends Zombie {\n    public CrawlerZombie(GamePanel gp, int worldX, int worldY) {\n        super(gp, worldX, worldY, \"/res/zombies/CrawlerZombie.png\");\n        this.maxHealth = 30;\n        this.health = maxHealth;\n        this.speed = 2;\n        this.damage = 10;\n       \n    }\n\n    private boolean isJumping = false;\n    private int jumpCooldown = 0;\n\n    @Override\n    public void update() {\n        // zıplamak için yakınlık\n        double distanceToPlayer = Math.sqrt(Math.pow(gp.player.worldX - worldX, 2) +\n                Math.pow(gp.player.worldY - worldY, 2));\n\n        if (distanceToPlayer < gp.tileSize * 3 && jumpCooldown <= 0) {\n            isJumping = true;\n            jumpCooldown = 60; \n        }\n\n        if (isJumping) {\n            // zıplama mantığı\n            worldX += (gp.player.worldX - worldX) * 0.1;\n            worldY += (gp.player.worldY - worldY) * 0.1;\n\n            if (distanceToPlayer < gp.tileSize) {\n                isJumping = false;\n                if (collisionWithPlayer()) {\n                    gp.player.takeDamage(damage);\n                }\n            }\n        } else {\n            \n            moveTowardsPlayer();\n            if (jumpCooldown > 0)\n                jumpCooldown--;\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        super.draw(g2d); \n    }\n}\n",
      "TankZombie.java": "package entities;\n\nimport java.awt.Graphics2D;\n\nimport main.GamePanel;\n\npublic class TankZombie extends Zombie {\n    public TankZombie(GamePanel gp, int worldX, int worldY) {\n        super(gp, worldX, worldY, \"/res/zombies/TankZombie.png\");\n        this.maxHealth = 150; \n        this.health = maxHealth; \n        this.speed = 1; \n        this.damage = 20; \n\n    }\n\n    @Override\n    public void update() {\n        \n        moveTowardsPlayer();\n\n        if (collisionWithPlayer()) {\n            gp.player.takeDamage(damage);\n        }\n    }\n\n    @Override\n    protected void moveTowardsPlayer() {\n        \n        double dx = gp.player.worldX - this.worldX;\n        double dy = gp.player.worldY - this.worldY;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance > 0) {\n            dx /= distance;\n            dy /= distance;\n\n            \n            double adjustedSpeed = speed;\n\n            \n            double newWorldX = worldX + dx * adjustedSpeed;\n            double newWorldY = worldY + dy * adjustedSpeed;\n\n            \n            worldX = (int)newWorldX;\n            worldY = (int)newWorldY;\n            //movement bozuk, düzeltmeye uğraştım fakat olduğu yerde duruyor bazen\n\n            \n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        super.draw(g2d);\n    }\n}\n",
      "ProjectileManager.java": "package entities;\n\n\nimport main.GamePanel;\n\nimport java.awt.Graphics2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\n\npublic class ProjectileManager implements Serializable {\n     GamePanel gp;\n    private ArrayList<Projectile> projectiles = new ArrayList<>();\n\n    public ProjectileManager(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    public void addProjectile(Projectile projectile) {\n        projectiles.add(projectile);\n    }\n\n    public void update() {\n        for (int i = 0; i < projectiles.size(); i++) {\n            Projectile p = projectiles.get(i);\n            p.update();\n\n            if (!p.isAlive()) {\n                projectiles.remove(i);\n                i--;\n            }\n        }\n    }\n\n    public void draw(Graphics2D g2d) {\n        for (Projectile p : projectiles) {\n            p.draw(g2d);\n        }\n    }\n\n    public void clear() {\n        projectiles.clear();\n    }\n\n    public ArrayList<Projectile> getProjectiles() {\n        return projectiles;\n    }\n}",
      "ExplosionEffect.java": "package entities;\n\nimport main.GamePanel;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class ExplosionEffect extends Projectile {\n    private int lifeSpan = 60; // 1s sürüyor\n\n    public ExplosionEffect(GamePanel gp, double x, double y) {\n        super(gp, x, y, x, y, 90); \n        this.size = 100; \n        this.color = Color.ORANGE;\n    }\n\n    @Override\n    public void update() {\n        lifeSpan--;\n        if (lifeSpan <= 0) {\n            alive = false;\n        }\n    }\n\n    @Override\n    protected void drawProjectile(Graphics2D g2d, int screenX, int screenY, double angle) {\n        int alpha = (int) (255 * (lifeSpan / 30.0)); \n        g2d.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), alpha));\n        g2d.fillOval(screenX - size / 2, screenY - size / 2, size, size);\n    }\n\n    @Override\n    protected void onHit(Zombie zombie) {\n        zombie.takeDamage(20);\n    }\n\n    @Override\n    protected void onWallHit() {\n        \n    }\n}\n",
      "ZombieManager.java": "package entities;\n\nimport java.awt.Graphics2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\n\nimport main.GamePanel;\n\npublic class ZombieManager implements Serializable {\n    private GamePanel gp;\n    public ArrayList<Zombie> zombies = new ArrayList<>();\n    public int waveNumber = 0;\n    private int zombiesToSpawn;\n    private int zombiesAlive;\n    private boolean waveInProgress = false;\n    private int totalZombiesKilled = 0; // New field to track total zombies killed\n\n    // Wave configuration\n    private final int BASE_ZOMBIES = 5;\n    private final int ZOMBIES_PER_WAVE = 3;\n    private final int WAVE_COOLDOWN = 180; // 3 seconds at 60 FPS\n    private int waveCooldownTimer = 0;\n\n    public ZombieManager(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    public void startNewWave() {\n        waveNumber++;\n        zombies.clear();\n        zombiesToSpawn = BASE_ZOMBIES + (waveNumber * ZOMBIES_PER_WAVE);\n        zombiesAlive = 0;\n        waveInProgress = true;\n        waveCooldownTimer = 0;\n    }\n\n    public void update() {\n        // yavaş yavaş zombileri spawn et\n        if (waveInProgress && zombiesToSpawn > 0 && waveCooldownTimer <= 0) {\n            spawnZombie();\n            zombiesToSpawn--;\n            waveCooldownTimer = WAVE_COOLDOWN;\n        } else if (waveCooldownTimer > 0) {\n            waveCooldownTimer--;\n        }\n\n        for (int i = 0; i < zombies.size(); i++) {\n            Zombie zombie = zombies.get(i);\n            if (zombie.isAlive()) {\n                zombie.update(); \n            } else {\n                zombies.remove(i);\n                i--;\n                zombiesAlive--;\n                totalZombiesKilled++; \n                gp.player.addScore(zombie); // skor ekle\n            }\n        }\n\n        \n        if (waveInProgress && zombiesToSpawn == 0 && zombiesAlive == 0) {\n            waveInProgress = false;\n        }\n    }\n\n    private void spawnZombie() {\n        // zombi tipi belirle\n        String zombieType = \"normal\";\n        double rand = Math.random();\n\n        if (waveNumber > 2 && rand < 0.2) {\n            zombieType = \"tank\";\n        } else if (waveNumber > 1 && rand < 0.3) {\n            zombieType = \"crawler\";\n        } else if (waveNumber > 3 && rand < 0.4) {\n            zombieType = \"acid\";\n        }\n\n        // çitler içinde spawn et\n        int spawnX, spawnY;\n        int borderOffset = gp.tileSize * 10;\n        if (Math.random() < 0.5) {\n            spawnX = (Math.random() < 0.5) ? borderOffset : gp.mapWidth - borderOffset;\n            spawnY = (int) (Math.random() * (gp.mapHeight - 2 * borderOffset)) + borderOffset;\n        } else {\n            spawnX = (int) (Math.random() * (gp.mapWidth - 2 * borderOffset)) + borderOffset;\n            spawnY = (Math.random() < 0.5) ? borderOffset : gp.mapHeight - borderOffset;\n        }\n\n        // zombi oluştur\n        Zombie zombie;\n        switch (zombieType) {\n            case \"tank\":\n                zombie = new TankZombie(gp, spawnX, spawnY);\n                break;\n            case \"crawler\":\n                zombie = new CrawlerZombie(gp, spawnX, spawnY);\n                break;\n            case \"acid\":\n                zombie = new AcidSpitterZombie(gp, spawnX, spawnY);\n                break;\n            default:\n                zombie = new NormalZombie(gp, spawnX, spawnY);\n        }\n\n        zombies.add(zombie);\n        zombiesAlive++;\n    }\n\n    public void draw(Graphics2D g2d) {\n        for (Zombie zombie : zombies) {\n            if (zombie.isAlive()) {\n                zombie.draw(g2d);\n            }\n        }\n    }\n\n    \n    public boolean isWaveComplete() {\n        return !waveInProgress && zombiesToSpawn == 0 && zombiesAlive == 0;\n    }\n\n    public int getAliveZombies() {\n        return zombiesAlive;\n    }\n\n    public int getWaveNumber() {\n        return waveNumber;\n    }\n\n    public ArrayList<Zombie> getZombies() {\n        return zombies;\n    }\n\n    public void clearZombies() {\n        zombies.clear();\n    }\n\n    public void addZombie(Zombie zombie) {\n        zombies.add(zombie);\n    }\n\n    public Zombie getZombieThatCreated(Projectile projectile) {\n        for (Zombie zombie : zombies) {\n            if (zombie instanceof AcidSpitterZombie) {\n                \n                double zombieCenterX = zombie.worldX + gp.tileSize / 2.0;\n                double zombieCenterY = zombie.worldY + gp.tileSize / 2.0;\n\n                if (Math.abs(projectile.x - zombieCenterX) < gp.tileSize / 2.0 &&\n                        Math.abs(projectile.y - zombieCenterY) < gp.tileSize / 2.0) {\n                    return zombie;\n                }\n            }\n        }\n        return null;\n    }\n\n    public int getTotalZombiesKilled() {\n        return totalZombiesKilled;\n    }\n\n    public void setTotalZombiesKilled(int totalZombiesKilled) {\n        this.totalZombiesKilled = totalZombiesKilled;\n    }\n}\n",
      "RifleBullet.java": "package entities;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport main.GamePanel;\n\npublic class RifleBullet extends Projectile {\n    private BufferedImage image;\n\n    public RifleBullet(GamePanel gp, double startX, double startY,\n            double targetX, double targetY, int damage, String projectileImagePath) {\n        super(gp, startX, startY, targetX, targetY, damage);\n\n        try {\n            this.image = ImageIO.read(getClass().getResourceAsStream(projectileImagePath));\n        } catch (IOException e) {\n            e.printStackTrace();\n            this.image = null;\n        }\n    }\n\n    @Override\n    protected void drawProjectile(Graphics2D g2d, int screenX, int screenY, double angle) {\n        if (image != null) {\n            Graphics2D g2dRotated = (Graphics2D) g2d.create();\n            g2dRotated.rotate(angle, screenX, screenY);\n            g2dRotated.drawImage(image, screenX - image.getWidth() / 2,\n                    screenY - image.getHeight() / 2, null);\n            g2dRotated.dispose();\n        } else {\n            g2d.setColor(color);\n            g2d.fillOval(screenX - size / 2, screenY - size / 2, size, size);\n        }\n    }\n}\n",
      "Player.java": "package entities;\n\nimport main.KeyHandler;\nimport main.GamePanel;\nimport java.awt.*;\nimport java.awt.geom.AffineTransform;\n\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\nimport entities.weapons.*;\n\npublic class Player extends Entity {\n    \n    private GamePanel gp;\n    private KeyHandler kh;\n\n    // Ekran ortası\n    public final int screenX;\n    public final int screenY;\n    private boolean movingUp, movingDown, movingLeft, movingRight;\n\n    private final int WEAPON_OFFSET_X = 16; // silah çizimi için\n    private final int WEAPON_OFFSET_Y = 8; \n\n    // can sistemi\n    private int maxHealth = 100;\n    public int currentHealth;\n    private boolean isInvulnerable = false;\n    private int invulnerabilityTimer = 0;\n    private final int INVULNERABILITY_DURATION = 60; // hasar yedikten sonra bir daha hasar alınamayacak süre (1s)\n\n    // silah sistemi\n    public Gun[] weapons;\n    public int currentWeaponIndex = 0;\n    private boolean isReloading = false;\n    private long reloadStartTime = 0;\n\n    // can barı boyutu\n    private final int HEALTH_BAR_WIDTH = 100;\n    private final int HEALTH_BAR_HEIGHT = 10;\n     final int HEALTH_BAR_X = 20;\n     final int HEALTH_BAR_Y = 20;\n    private double angle;\n\n    public Player(GamePanel gp, KeyHandler kh) {\n        this.gp = gp;\n        this.kh = kh;\n\n        \n        screenX = gp.scrWidth / 2 - (gp.tileSize / 2);\n        screenY = gp.scrHeight / 2 - (gp.tileSize / 2);\n\n        // collision kutusu\n        collidableArea = new Rectangle(12, 9, 20, 20);\n\n        \n        currentHealth = maxHealth;\n\n        \n        weapons = new Gun[] {\n                new Pistol(gp), // 0 - Pistol\n                new Rifle(gp), // 1 - Rifle\n                new Shotgun(gp), // 2 - Shotgun\n                new SniperRifle(gp), // 3 - Sniper\n                new RocketLauncher(gp) // 4 - Rocket Launcher\n        };\n\n        // Ssadece pistol açık en başta\n        weapons[0].unlock(); \n        for (int i = 1; i < weapons.length; i++) {\n            weapons[i].lock(); \n        }\n\n        setDefaultValues();\n        getPlayerImage();\n    }\n\n    public void setDefaultValues() {\n        worldX = gp.tileSize * 25;\n        worldY = gp.tileSize * 24;\n        speed = 4;\n        direction = \"right\";\n        movingUp = movingDown = movingLeft = movingRight = false;\n    }\n\n    public void getPlayerImage() {\n        try {\n            standing = ImageIO.read(getClass().getResourceAsStream(\"/res/player/p_standing.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    \n    public void takeDamage(int damage) {\n        if (isInvulnerable)\n            return;\n\n        currentHealth -= damage;\n        if (currentHealth <= 0) {\n            currentHealth = 0;\n            die();\n        }\n\n        isInvulnerable = true;\n        invulnerabilityTimer = INVULNERABILITY_DURATION;\n    }\n\n    \n\n    public void die() {\n        if (!isAlive())\n            return; // ölü\n\n        currentHealth = 0;\n        gp.gameOver();\n    }\n\n    public boolean isAlive() {\n        return currentHealth > 0;\n    }\n\n    public int getCurrentHealth() {\n        return currentHealth;\n    }\n\n    public int getMaxHealth() {\n        return maxHealth;\n    }\n\n    public void update() {\n        if (!isAlive()) {\n            gp.gameOver(); \n            return;\n        }\n        checkWeaponUnlocks();\n        handleWeaponInput();\n        handleMovement();\n        updateInvulnerability();\n        updateReloading();\n\n        getCurrentWeapon().update();\n\n        updateFacingAngle();\n    }\n\n    private void updateFacingAngle() {\n        // ekran ortasından mouse tıklanan yere olan açı\n        int playerCenterX = screenX + gp.tileSize / 2;\n        int playerCenterY = screenY + gp.tileSize / 2;\n        this.angle = Math.atan2(gp.mouseY - playerCenterY, gp.mouseX - playerCenterX);\n    }\n\n    private void checkWeaponUnlocks() {\n        int wave = gp.zombieManager.getWaveNumber();\n\n        if (wave > 1 && !weapons[1].isUnlocked()) {\n            unlockWeapon(1); // wave 1'de Rifle açılır\n        }\n        if (wave > 3 && !weapons[2].isUnlocked()) {\n            unlockWeapon(2); // wave 3'te Shotgun açılır\n        }\n        if (wave > 5 && !weapons[3].isUnlocked()) {\n            unlockWeapon(3); // wave 5'te Sniper açılır\n        }\n        if (wave > 10 && !weapons[4].isUnlocked()) {\n            unlockWeapon(4); // wave 10'da Rocket Launcher açılır\n        }\n    }\n\n    private void unlockWeapon(int weaponIndex) {\n        weapons[weaponIndex].unlock();\n        System.out.println(\"Weapon unlocked: \" + weapons[weaponIndex].getName());\n    }\n\n    private void handleWeaponInput() {\n        // silah değiştirme\n        if (kh.number1Pressed)\n            switchWeapon(0); \n        if (kh.number2Pressed && weapons[1].isUnlocked())\n            switchWeapon(1);\n        if (kh.number3Pressed && weapons[2].isUnlocked())\n            switchWeapon(2);\n        if (kh.number4Pressed && weapons[3].isUnlocked())\n            switchWeapon(3);\n        if (kh.number5Pressed && weapons[4].isUnlocked())\n            switchWeapon(4);\n\n        \n        if (kh.shootPressed) {\n            shoot();\n        }\n\n        \n        if (kh.reloadPressed) {\n            reload();\n        }\n    }\n\n    public void switchWeapon(int weaponIndex) {\n        if (weaponIndex >= 0 && weaponIndex < weapons.length && weapons[weaponIndex].isUnlocked()) {\n            currentWeaponIndex = weaponIndex;\n        }\n    }\n\n    private void shoot() {\n        Gun currentWeapon = getCurrentWeapon();\n        if (currentWeapon.canShoot()) {\n            double targetX = gp.mouseX + worldX - screenX;\n            double targetY = gp.mouseY + worldY - screenY;\n            currentWeapon.shoot(targetX, targetY);\n            \n        } else {\n            \n        }\n    }\n\n    private void reload() {\n        if (!isReloading && getCurrentWeapon().canReload()) {\n            isReloading = true;\n            reloadStartTime = System.currentTimeMillis();\n            \n        }\n    }\n\n    private void updateReloading() {\n        if (isReloading && System.currentTimeMillis() - reloadStartTime > getCurrentWeapon().reloadTime) {\n            isReloading = false;\n            getCurrentWeapon().finishReload();\n        }\n    }\n\n    private void handleMovement() {\n        movingUp = kh.upPressed;\n        movingDown = kh.downPressed;\n        movingLeft = kh.leftPressed;\n        movingRight = kh.rightPressed;\n\n        if (movingUp || movingDown || movingLeft || movingRight) {\n            if (movingUp)\n                direction = \"up\";\n            if (movingDown)\n                direction = \"down\";\n            if (movingLeft)\n                direction = \"left\";\n            if (movingRight)\n                direction = \"right\";\n        }\n\n        collisionOn = false;\n        gp.colCheck.checkTile(this);\n\n        if (!collisionOn) {\n            if (movingUp)\n                worldY -= speed;\n            if (movingDown)\n                worldY += speed;\n            if (movingLeft)\n                worldX -= speed;\n            if (movingRight)\n                worldX += speed;\n        }\n    }\n\n    private void updateInvulnerability() {\n        if (isInvulnerable) {\n            invulnerabilityTimer--;\n            if (invulnerabilityTimer <= 0) {\n                isInvulnerable = false;\n            }\n        }\n    }\n\n    public Gun getCurrentWeapon() {\n        return weapons[currentWeaponIndex];\n    }\n\n    public void draw(Graphics2D g2d) {\n        drawWeapon(g2d);\n        drawPlayer(g2d);\n    }\n\n    private void drawPlayer(Graphics2D g2d) {\n        AffineTransform oldTransform = g2d.getTransform();\n\n        // oyuncuyu döndür\n        g2d.translate(screenX + gp.tileSize / 2, screenY + gp.tileSize / 2);\n        g2d.rotate(angle);\n        g2d.translate(-gp.tileSize / 2, -gp.tileSize / 2);\n\n        if (isInvulnerable && (invulnerabilityTimer / 5) % 2 == 0) {\n            g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.7f));\n            g2d.setColor(Color.RED);\n            g2d.fillRect(0, 0, gp.tileSize, gp.tileSize);\n            g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1f));\n        }\n\n        g2d.drawImage(standing, 0, 0, gp.tileSize, gp.tileSize, null);\n        g2d.setTransform(oldTransform);\n    }\n\n    private void drawWeapon(Graphics2D g2d) {\n        AffineTransform oldTransform = g2d.getTransform();\n\n        \n        int playerCenterX = screenX + gp.tileSize / 2;\n        int playerCenterY = screenY + gp.tileSize / 2;\n\n       \n        int weaponDrawX = playerCenterX + WEAPON_OFFSET_X;\n        int weaponDrawY = playerCenterY - WEAPON_OFFSET_Y;\n\n        \n        g2d.translate(playerCenterX, playerCenterY);\n        g2d.rotate(angle);\n        g2d.translate(-playerCenterX, -playerCenterY);\n\n        \n        getCurrentWeapon().draw(g2d, weaponDrawX, weaponDrawY);\n\n        g2d.setTransform(oldTransform);\n\n       \n        if (isReloading) {\n            float reloadProgress = (float) (System.currentTimeMillis() - reloadStartTime)\n                    / getCurrentWeapon().reloadTime;\n            g2d.setColor(Color.YELLOW);\n            g2d.fillRect(screenX, screenY - 15, (int) (gp.tileSize * reloadProgress), 5);\n        }\n    }\n\n    public void drawHealthBar(Graphics2D g2d, int x, int y) {\n        g2d.setColor(Color.GRAY);\n        g2d.fillRect(x, y, HEALTH_BAR_WIDTH, HEALTH_BAR_HEIGHT);\n\n        float healthPercentage = (float) currentHealth / maxHealth;\n        Color healthColor = healthPercentage > 0.6f ? Color.GREEN : healthPercentage > 0.3f ? Color.YELLOW : Color.RED;\n\n        g2d.setColor(healthColor);\n        g2d.fillRect(x, y, (int) (HEALTH_BAR_WIDTH * healthPercentage), HEALTH_BAR_HEIGHT);\n\n        g2d.setColor(Color.BLACK);\n        g2d.drawRect(x, y, HEALTH_BAR_WIDTH, HEALTH_BAR_HEIGHT);\n    }\n\n    public void addScore(Zombie zombie) {\n        //puan ekle\n        if (zombie instanceof NormalZombie) {\n            gp.score += 10; \n        } else if (zombie instanceof CrawlerZombie) {\n            gp.score += 15; \n        } else if (zombie instanceof TankZombie) {\n            gp.score += 20; \n        } else if (zombie instanceof AcidSpitterZombie) {\n           gp.score += 30; \n        }\n    }\n}",
      "Gun.java": "package entities.weapons;\n\nimport java.awt.Graphics2D;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.Serializable;\n\nimport javax.imageio.ImageIO;\nimport main.GamePanel;\nimport entities.Projectile;\nimport entities.PistolBullet;\n\nimport entities.RifleBullet;\nimport entities.Rocket;\nimport entities.ShotgunPellet;\nimport entities.SniperBullet;\n\npublic abstract class Gun implements Serializable {\n\n    protected GamePanel gp;\n\n    protected BufferedImage image;\n    protected String name;\n    protected int damage;\n    public int maxAmmo;\n    public int currentAmmo;\n    protected int ammoReserve;\n    protected int fireRate; // milisaniye\n    protected long lastShotTime;\n    public int reloadTime; //  milisaniye\n    protected boolean isReloading;\n    protected long reloadStartTime;\n    protected String projectileImagePath;\n    protected int projectileWidth, projectileHeight;\n    protected boolean unlocked;\n    protected double angle;\n\n    public Gun(GamePanel gp, String imagePath) {\n        this.gp = gp;\n        this.unlocked = false;\n        this.angle = 0;\n        try {\n            this.image = ImageIO.read(getClass().getResourceAsStream(imagePath));\n        } catch (IOException e) {\n            e.printStackTrace();\n            this.image = null;\n        }\n    }\n\n    public abstract void shoot(double targetX, double targetY);\n\n    protected void createProjectile(double startX, double startY,\n            double targetX, double targetY, int damage,\n            String projectileType, String projectileImagePath) {\n        Projectile projectile = null;\n\n        switch (projectileType) {\n            case \"pistol\":\n                projectile = new PistolBullet(gp, startX, startY, targetX, targetY, damage, projectileImagePath);\n                break;\n            case \"rifle\":\n                projectile = new RifleBullet(gp, startX, startY, targetX, targetY, damage, projectileImagePath);\n                break;\n            case \"shotgun\":\n                projectile = new ShotgunPellet(gp, startX, startY, targetX, targetY, damage, projectileImagePath);\n                break;\n            case \"sniper\":\n                projectile = new SniperBullet(gp, startX, startY, targetX, targetY, damage, projectileImagePath);\n                break;\n            case \"rocket\":\n                projectile = new Rocket(gp, startX, startY, targetX, targetY, damage, projectileImagePath);\n                break;\n        }\n\n        if (projectile != null) {\n            gp.projectileManager.addProjectile(projectile);\n        }\n    }\n\n    public void update() {\n        this.angle = Math.atan2(gp.mouseY - gp.player.worldY, gp.mouseX - gp.player.worldX);\n        if (isReloading && System.currentTimeMillis() - reloadStartTime >= reloadTime) {\n            finishReload();\n        }\n    }\n\n    public void startReload() {\n        if (!canReload())\n            return;\n\n        isReloading = true;\n        reloadStartTime = System.currentTimeMillis();\n    }\n\n    public void finishReload() {\n        int ammoNeeded = maxAmmo - currentAmmo;\n        int ammoToAdd = Math.min(ammoNeeded, ammoReserve);\n        currentAmmo += ammoToAdd;\n        ammoReserve -= ammoToAdd;\n        isReloading = false;\n    }\n\n    public boolean canReload() {\n        return !isReloading &&\n                currentAmmo < maxAmmo &&\n                ammoReserve > 0 &&\n                unlocked;\n    }\n\n    public boolean canShoot() {\n        return !isReloading && // silah reload ediyorsa ateş edemez\n                currentAmmo > 0 &&\n                System.currentTimeMillis() - lastShotTime >= fireRate &&\n                unlocked;\n    }\n\n    public void draw(Graphics2D g2d, int x, int y) {\n        if (image != null) {\n            // ortalayarak çiz\n            g2d.drawImage(image,\n                    x - image.getWidth() / 2, \n                    y - image.getHeight() / 2, \n                    null);\n        } else {\n            // image yoksa\n            g2d.fillRect(x - 16, y - 16, 32, 32);\n        }\n    }\n\n    public void unlock() {\n        this.unlocked = true;\n        if (ammoReserve == 0) {\n            \n            ammoReserve = maxAmmo * 3;\n            currentAmmo = maxAmmo;\n        }\n    }\n\n    public void lock() {\n        this.unlocked = false;\n    }\n\n    public boolean isUnlocked() {\n        return unlocked;\n    }\n\n    // Getters\n    public String getName() {\n        return name;\n    }\n\n    public int getCurrentAmmo() {\n        return currentAmmo;\n    }\n\n    public int getAmmoReserve() {\n        return ammoReserve;\n    }\n\n    public boolean isReloading() {\n        return isReloading;\n    }\n\n    public int getReloadTime() {\n        return reloadTime;\n    }\n\n    public void setAmmoReserve(int amount) {\n        this.ammoReserve = amount;\n    }\n}",
      "Shotgun.java": "package entities.weapons;\n\nimport main.GamePanel;\n\n\nimport java.util.Random;\n\npublic class Shotgun extends Gun {\n    Random random = new Random();\n    \n    public Shotgun(GamePanel gp) {\n        super(gp, \"/res/weapons/shotgun.png\");\n        this.name = \"Shotgun\";\n        this.damage = 4; \n        this.maxAmmo = 5;\n        this.currentAmmo = maxAmmo;\n        this.ammoReserve = 15; \n        this.fireRate = 1000; \n        this.reloadTime = 3000; // ms\n        this.projectileImagePath = \"/res/projectiles/shotgun_pellet.png\";\n        this.projectileWidth = 4;\n        this.projectileHeight = 4;\n    }\n\n    @Override\n    public void shoot(double targetX, double targetY) {\n        if (!canShoot()) return;\n        \n        currentAmmo--;\n        lastShotTime = System.currentTimeMillis();\n        \n        // ekran ortası\n        double startX = gp.player.worldX + gp.player.collidableArea.width/2;\n        double startY = gp.player.worldY + gp.player.collidableArea.height/2;\n        \n        // 45 dereceyle 9 mermi\n        for (int i = 0; i < 9; i++) {\n            double angle = Math.atan2(targetY - startY, targetX - startX);\n            angle += Math.toRadians((i * 5) - 20); // -20 to +20 degrees\n            \n            \n            double pelletTargetX = startX + Math.cos(angle) * 1000;\n            double pelletTargetY = startY + Math.sin(angle) * 1000;\n            \n            createProjectile(startX, startY, pelletTargetX, pelletTargetY, damage, \"shotgun\",this.projectileImagePath);\n        }\n        \n       \n    }\n}",
      "SniperRifle.java": "package entities.weapons;\n\n\n\nimport main.GamePanel;\n\npublic class SniperRifle extends Gun {\n    public SniperRifle(GamePanel gp) {\n        super(gp, \"/res/weapons/sniper.png\");\n        this.name = \"Sniper\";\n        this.damage = 50;\n        this.maxAmmo = 5;\n        this.currentAmmo = maxAmmo;\n        this.ammoReserve = 10; \n        this.fireRate = 1500; \n        this.reloadTime = 2500; \n        this.projectileImagePath = \"/res/projectiles/sniper_bullet.png\";\n        this.projectileWidth = 10;\n        this.projectileHeight = 4;\n    }\n\n    @Override\n    public void shoot(double targetX, double targetY) {\n        if (!canShoot()) return;\n        \n        currentAmmo--;\n        lastShotTime = System.currentTimeMillis();\n        \n        // ekran ortası\n        double startX = gp.player.worldX + gp.player.collidableArea.width/2;\n        double startY = gp.player.worldY + gp.player.collidableArea.height/2;\n        \n        createProjectile(startX, startY, targetX, targetY, damage, \"sniper\",this.projectileImagePath);\n       \n    }\n}\n",
      "Pistol.java": "package entities.weapons;\n\n\n\nimport main.GamePanel;\n\npublic class Pistol extends Gun {\n    public Pistol(GamePanel gp) {\n        super(gp, \"/res/weapons/pistol.png\");\n        this.name = \"Pistol\";\n        this.damage = 10;\n        this.maxAmmo = 12;\n        this.currentAmmo = maxAmmo;\n        this.ammoReserve = 999999; //sınırsız mermi\n        this.fireRate = 500; \n        this.reloadTime = 1500; // ms\n        this.projectileImagePath = \"/res/projectiles/pistol_bullet.png\";\n        this.projectileWidth = 8;\n        this.projectileHeight = 8;\n    }\n\n    @Override\n    public void shoot(double targetX, double targetY) {\n        if (!canShoot()) return;\n        \n        currentAmmo--;\n        lastShotTime = System.currentTimeMillis();\n        \n        // ekran ortası\n        double startX = gp.player.worldX + gp.player.collidableArea.width/2;\n        double startY = gp.player.worldY + gp.player.collidableArea.height/2;\n        \n        createProjectile(startX, startY, targetX, targetY, damage, \"pistol\", this.projectileImagePath);\n        \n    }\n}",
      "Rifle.java": "package entities.weapons;\n\nimport main.GamePanel;\n\n\nimport java.util.Random;\n\npublic class Rifle extends Gun {\n    private Random random = new Random();\n    \n    public Rifle(GamePanel gp) {\n        super(gp, \"/res/weapons/rifle.png\");\n        this.name = \"Rifle\";\n        this.damage = 8;\n        this.maxAmmo = 30;\n        this.currentAmmo = maxAmmo;\n        this.ammoReserve = 90; \n        this.fireRate = 100; \n        this.reloadTime = 2000; \n        this.projectileImagePath = \"/res/projectiles/rifle_bullet.png\";\n        this.projectileWidth = 6;\n        this.projectileHeight = 6;\n    }\n\n    @Override\n    public void shoot(double targetX, double targetY) {\n        if (!canShoot()) return;\n        \n        currentAmmo--;\n        lastShotTime = System.currentTimeMillis();\n        \n        // ekran ortası\n        double startX = gp.player.worldX + gp.player.collidableArea.width/2;\n        double startY = gp.player.worldY + gp.player.collidableArea.height/2;\n        \n        // 30 derece rastgele açı\n        double angle = Math.atan2(targetY - startY, targetX - startX);\n        angle += Math.toRadians((random.nextDouble() * 30) - 15);\n        \n        // yeni hedef\n        double newTargetX = startX + Math.cos(angle) * 1000;\n        double newTargetY = startY + Math.sin(angle) * 1000;\n        \n        createProjectile(startX, startY, newTargetX, newTargetY, damage, \"rifle\",this.projectileImagePath);\n        \n    }\n}\n",
      "RocketLauncher.java": "package entities.weapons;\n\n\n\nimport main.GamePanel;\n\npublic class RocketLauncher extends Gun {\n    public RocketLauncher(GamePanel gp) {\n        super(gp, \"/res/weapons/rocket_launcher.png\");\n        this.name = \"Rocket Launcher\";\n        this.damage = 75;\n        this.maxAmmo = 1;\n        this.currentAmmo = maxAmmo;\n        this.ammoReserve = 3; \n        this.fireRate = 2000; \n        this.reloadTime = 3000; // ms\n        this.projectileImagePath = \"/res/projectiles/rocket.png\";\n        this.projectileWidth = 16;\n        this.projectileHeight = 8;\n    }\n\n    @Override\n    public void shoot(double targetX, double targetY) {\n        if (!canShoot()) return;\n        \n        currentAmmo--;\n        lastShotTime = System.currentTimeMillis();\n        \n        // ekran ortası\n        double startX = gp.player.worldX + gp.player.collidableArea.width/2;\n        double startY = gp.player.worldY + gp.player.collidableArea.height/2;\n        \n        createProjectile(startX, startY, targetX, targetY, damage, \"rocket\",this.projectileImagePath);\n       \n    }\n}",
      "TileOperations.java": "package tile;\n\nimport java.awt.Graphics2D;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\nimport javax.imageio.ImageIO;\n\nimport main.GamePanel;\n\npublic class TileOperations {\n    GamePanel gp;\n    public ArrayList<Tile> tile;\n    public int mapTileNumber[][];\n\n    public TileOperations(GamePanel gp) {\n        this.gp = gp;\n        tile = new ArrayList<Tile>();\n        mapTileNumber = new int[gp.maxMapCol][gp.maxMapRow];\n        getTileImage();\n        loadMap(\"/res/maps/map01.txt\");\n    }\n\n    public void loadMap(String filePath) {\n        try {\n            InputStream stream = getClass().getResourceAsStream(filePath);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n            int col = 0;\n            int row = 0;\n\n            while (col < gp.maxMapCol && row < gp.maxMapRow) {\n                String line = reader.readLine();\n\n                while (col < gp.maxMapCol) {\n                    String[] nums = line.split(\" \");\n                    int num = Integer.parseInt(nums[col]);\n                    mapTileNumber[col][row] = num;\n                    col++;\n                }\n                if (col == gp.maxMapCol) {\n                    col = 0;\n                    row++;\n                }\n            }\n            reader.close();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n\n        }\n\n    }\n\n    public void getTileImage() {\n        try {\n            tile.add(new Tile());\n            tile.get(0).image = ImageIO.read(getClass().getResourceAsStream(\"/res/tiles/sand.png\"));\n\n            tile.add(new Tile());\n            tile.get(1).image = ImageIO.read(getClass().getResourceAsStream(\"/res/tiles/water.png\"));\n            tile.get(1).collision = true;\n\n            tile.add(new Tile());\n            tile.get(2).image = ImageIO.read(getClass().getResourceAsStream(\"/res/tiles/fence.png\"));\n            tile.get(2).collision = true; \n\n            tile.add(new Tile());\n            tile.get(3).image = ImageIO.read(getClass().getResourceAsStream(\"/res/tiles/tomb.png\"));\n            tile.get(3).collision = true;\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void draw(Graphics2D g2d) {\n        int row = 0;\n        int col = 0;\n\n        while (col < gp.maxMapCol && row < gp.maxMapRow) {\n            int tileNumber = mapTileNumber[col][row];\n            int worldX = gp.tileSize * col;\n            int worldY = gp.tileSize * row;\n            int screenX = worldX - gp.player.worldX + gp.player.screenX;\n            int screenY = worldY - gp.player.worldY + gp.player.screenY;\n            if (worldX + gp.tileSize > gp.player.worldX - gp.player.screenX &&\n                    worldX - gp.tileSize < gp.player.worldX + gp.player.screenX &&\n                    worldY + gp.tileSize > gp.player.worldY - gp.player.screenY &&\n                    worldY - gp.tileSize < gp.player.worldY + gp.player.screenY) {\n                if (tileNumber == 2 || tileNumber == 3) {\n                    g2d.drawImage(tile.get(0).image, screenX, screenY, gp.tileSize, gp.tileSize, null);\n                    g2d.drawImage(tile.get(tileNumber).image, screenX, screenY, gp.tileSize, gp.tileSize, null);\n                } else {\n                    g2d.drawImage(tile.get(tileNumber).image, screenX, screenY, gp.tileSize, gp.tileSize, null);\n                }\n            }\n\n            col++;\n\n            if (col == gp.maxMapCol) {\n                col = 0;\n\n                row++;\n\n            }\n\n        }\n\n    }\n}\n",
      "Tile.java": "package tile;\n\nimport java.awt.image.BufferedImage;\n\npublic class Tile {\n    public BufferedImage image;\n    public boolean collision = false;\n\n}"
    },
    {
      "id": "1764665",
      "Sniper.java": "import java.awt.Color;\n\npublic class Sniper extends Weapon {\n\tpublic Sniper(GamePanel gp) {\n\t\tsuper(gp);\n\t\tcoolDown = 2000;\n\t\tbulletColor = Color.orange;\n\t\tbulletSize = 8;\n\t\tmagazine = 5;\n\t\tdeviation = 0;\n\t\tbulletCount = magazine;\n\t\tcontinuousShoot = false;\n\t\tdamage = 150;\n\t\tname = \"Sniper\";\n\t}\n\n\t@Override\n\tpublic void shoot(double scX, double scY, double TargetX, double TargetY) {\n\t\tcurrentTime = System.currentTimeMillis();\n\t\tif (currentTime - lastShotTime >= coolDown && bulletCount > 0) {\n\t\t\tGameManager.Game.projectiles.add(new Projectile(scX, scY, TargetX, TargetY, deviation, bulletSize,\n\t\t\t\t\tbulletColor, 120, \"Sniper\", damage, 20));\n\t\t\tlastShotTime = currentTime;\n\t\t\tbulletCount--;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void reload() {\n\t\tif (magazinCount > 0 && bulletCount != magazine) {\n\t\t\tbulletCount = magazine;\n\t\t\tmagazinCount--;\n\t\t}\n\t}\n}",
      "WaveManager.java": "import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\n\npublic class WaveManager {\n\tList<String> enemyTypes = Arrays.asList(\"Z1\", \"Z2\", \"Z3\", \"Z4\");\n\tpublic int wave = 1;\n\tint enemyCount = 3;\n\tdouble[] spawnChances = { 0.6, 0.25, 0.1, 0.05 };\n\tRandom random = new Random();\n\tpublic static WaveManager instance;\n\n\tpublic void Wave(List<Zombie> spawnedEnemies) {\n\t\tif (instance == null) {\n\t\t\tinstance = this;\n\t\t}\n\n\t\tint enemyTypeCount = Math.min(1 + (wave / 3), enemyTypes.size());\n\n\t\tfor (int i = 0; i < enemyCount; i++) {\n\n\t\t\tString enemyType = enemyTypes.get((int) (Math.random() * enemyTypeCount));\n\t\t\tswitch (enemyType) {\n\t\t\t\tcase \"Z1\":\n\t\t\t\t\tspawnedEnemies.add(new NormalZombie());\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Z2\":\n\t\t\t\t\tspawnedEnemies.add(new SurungeZombie());\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Z3\":\n\t\t\t\t\tspawnedEnemies.add(new AsitliZombie());\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Z4\":\n\t\t\t\t\tspawnedEnemies.add(new TankZombie());\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tenemyCount += 2;\n\t\twave++;\n\t}\n\n\tpublic void Initliaze() {\n\t\twave = 1;\n\t\tenemyCount = 3;\n\t}\n\n\tprivate static String getRandomEnemy(ArrayList<String> enemyTypes, double[] spawnChances, int enemyTypeCount,\n\t\t\tRandom random) {\n\t\tdouble rand = random.nextDouble();\n\t\tdouble cumulativeProbability = 0.0;\n\n\t\tfor (int i = 0; i < enemyTypeCount; i++) {\n\t\t\tcumulativeProbability += spawnChances[i];\n\t\t\tif (rand < cumulativeProbability) {\n\t\t\t\treturn enemyTypes.get(i);\n\t\t\t}\n\t\t}\n\t\treturn enemyTypes.get(enemyTypeCount - 1);\n\t}\n\n\tpublic void draw(Graphics g) {\n\t\tg.setColor(Color.white);\n\t\tg.setFont(new Font(\"Arial\", Font.BOLD, 20));\n\t\tg.drawString(\"Wave: \" + (wave - 1), 20, 30);\n\t\tg.setColor(Color.black);\n\t}\n}",
      "Projectile.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.Random;\n\nclass Projectile extends Entity {\n\tprivate double dx, dy;\n\tprivate int size;\n\tprivate int lifeTime = 120;\n\tColor bulletColor;\n\tString bulletOf;\n\tpublic int damage;\n\n\tpublic Projectile(double startX, double startY, double newAngle, int size, Color color, int lifeTime,\n\t\t\tString BulletOf, int damage, int speed) {\n\t\tthis.worldX = startX;\n\t\tthis.worldY = startY;\n\t\tthis.speed = 10;\n\t\tthis.size = size;\n\t\tthis.lifeTime = lifeTime;\n\t\tthis.bulletColor = color;\n\t\tthis.bulletOf = BulletOf;\n\t\tradious = 1.5 * size;\n\t\tthis.damage = damage;\n\t\tthis.speed = speed;\n\t\tdx = Math.cos(newAngle) * speed;\n\t\tdy = Math.sin(newAngle) * speed;\n\t}\n\n\tpublic Projectile(double startX, double startY, double targetX, double targetY, int deviationAngle, int size,\n\t\t\tColor color, int lifeTime, String BulletOf, int damage, int speed) {\n\t\tthis.worldX = startX;\n\t\tthis.worldY = startY;\n\t\tthis.speed = 10;\n\t\tthis.size = size;\n\t\tthis.lifeTime = lifeTime;\n\t\tthis.bulletColor = color;\n\t\tthis.bulletOf = BulletOf;\n\t\tradious = 1.5 * size;\n\t\tthis.damage = damage;\n\t\tthis.speed = speed;\n\n\t\tscreenX = worldX - Player.player.worldX + Player.player.screenX;\n\t\tscreenY = worldY - Player.player.worldY + Player.player.screenY;\n\n\t\tdouble diffX = targetX - screenX;\n\t\tdouble diffY = targetY - screenY;\n\n\t\tdouble length = Math.sqrt(diffX * diffX + diffY * diffY);\n\t\tif (length != 0) {\n\t\t\tdiffX /= length;\n\t\t\tdiffY /= length;\n\t\t}\n\n\t\tdouble angle = Math.atan2(diffY, diffX);\n\n\t\tdouble deviation = Math.toRadians(new Random().nextDouble() * deviationAngle * 2 - deviationAngle);\n\t\tangle += deviation;\n\n\t\tdx = Math.cos(angle) * speed;\n\t\tdy = Math.sin(angle) * speed;\n\t}\n\n\tpublic void update() {\n\t\tworldX += dx;\n\t\tworldY += dy;\n\t\tlifeTime--;\n\t}\n\n\tpublic boolean isExpired() {\n\t\treturn lifeTime <= 0;\n\t}\n\n\tpublic void draw(Graphics g) {\n\n\t\tscreenX = worldX - Player.player.worldX + Player.player.screenX;\n\t\tscreenY = worldY - Player.player.worldY + Player.player.screenY;\n\n\t\tg.setColor(bulletColor);\n\t\tg.fillOval((int) screenX, (int) screenY, size, size);\n\t\tg.setColor(Color.black);\n\t}\n}",
      "Tabanca.java": "import java.awt.Color;\n\npublic class Tabanca extends Weapon {\n\n\tpublic Tabanca(GamePanel gp) {\n\t\tsuper(gp);\n\t\tcoolDown = 500;\n\t\tbulletColor = Color.BLUE;\n\t\tbulletSize = 10;\n\t\tmagazine = 12;\n\t\tdeviation = 0;\n\t\tbulletCount = magazine;\n\t\tcontinuousShoot = false;\n\t\tdamage = 50;\n\t\tname = \"Pistol\";\n\t}\n\n\t@Override\n\tpublic void shoot(double scX, double scY, double TargetX, double TargetY) {\n\t\tcurrentTime = System.currentTimeMillis();\n\t\tif (currentTime - lastShotTime >= coolDown && bulletCount > 0) {\n\n\t\t\tGameManager.Game.projectiles.add(new Projectile(scX, scY, TargetX, TargetY, deviation, bulletSize,\n\t\t\t\t\tbulletColor, 120, \"Tabanca\", damage, 10));\n\t\t\tlastShotTime = currentTime;\n\t\t\tbulletCount--;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void reload() {\n\t\tif (bulletCount != magazine) {\n\t\t\tbulletCount = magazine;\n\t\t\tmagazinCount--;\n\t\t}\n\t}\n\n}\n",
      "Zombie.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.ArrayList;\nimport java.util.Random;\n\npublic class Zombie extends Entity {\n\tpublic int damage;\n\tpublic double size;\n\tprivate Random rand;\n\tprivate ArrayList<Projectile> eaten = new ArrayList();\n\tpublic ZombieHealth health;\n\tpublic Color color;\n\tpublic int Health;\n\tAsit Asit;\n\tint point;\n\tdouble lastJump, jumpCoolDown;\n\tboolean jump;\n\tdouble dX, dY;\n\n\tpublic boolean canJump, Asitli;\n\tpublic double jumpingSpeed, normalSpeed, thresholdDistance, ShootCooldown;\n\n\tpublic Zombie(int Health) {\n\t\trand = new Random();\n\t\tthis.worldX = rand.nextInt(941) + 30;\n\t\tthis.worldY = rand.nextInt(691) + 30;\n\t\tShootCooldown = rand.nextInt(2000) + 8000;\n\t\tradious = 16;\n\t\tsize = 1;\n\t\tnormalSpeed = 2;\n\t\tspeed = normalSpeed;\n\t\tdamage = 20;\n\t\tcolor = Color.red;\n\t\tcanJump = false;\n\t\tcurrentTime = System.currentTimeMillis();\n\t\tlastShootTime = currentTime;\n\t\tthis.health = new ZombieHealth(Health, Health - 1, this);\n\t\tpoint = 10;\n\t}\n\n\tpublic void takeDamage(int amount) {\n\t\thealth.damage(amount);\n\t}\n\n\tlong lastShootTime = 0;\n\tlong currentTime = 0;\n\n\tpublic void calculateDir(double targetX, double targetY) {\n\t\tdouble diffX = targetX - worldX;\n\t\tdouble diffY = targetY - worldY;\n\n\t\tdouble length = Math.sqrt(diffX * diffX + diffY * diffY);\n\t\tif (length != 0) {\n\t\t\tdiffX /= length;\n\t\t\tdiffY /= length;\n\t\t}\n\n\t\tdouble angle = Math.atan2(diffY, diffX);\n\t\tdX = Math.cos(angle);\n\t\tdY = Math.sin(angle);\n\t}\n\n\tpublic void update() {\n\t\tcurrentTime = System.currentTimeMillis();\n\t\tif (jump == false) {\n\t\t\tcalculateDir(Player.player.worldX + 40, Player.player.worldY + 50);\n\t\t\tmoveTowards();\n\t\t} else {\n\t\t\tmoveTowards();\n\t\t}\n\t\tfor (Projectile z : GameManager.Game.projectiles) {\n\t\t\tif (Collision.checkCollision(worldX, worldY, z.worldX, z.worldY, radious, z.radious)\n\t\t\t\t\t&& !eaten.contains(z)) {\n\t\t\t\tif (!z.bulletOf.equals(\"Asit\")) {\n\t\t\t\t\tif (z.bulletOf.equals(\"Rocket\")) {\n\t\t\t\t\t\tfor (Zombie e : GameManager.Game.zombies) {\n\t\t\t\t\t\t\tif (e == this) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (Collision.checkCollision(z.worldX, z.worldY, e.worldX, e.worldY, 100, 40)) {\n\t\t\t\t\t\t\t\t\te.takeDamage(z.damage);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.takeDamage(z.damage);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttakeDamage(z.damage);\n\t\t\t\t\t\teaten.add(z);\n\t\t\t\t\t}\n\t\t\t\t\tif (!z.bulletOf.equals(\"Sniper\")) {\n\t\t\t\t\t\tGameManager.Game.DeleteProjectile(z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Zombie other : GameManager.Game.zombies) {\n\t\t\tif (other == this)\n\t\t\t\tcontinue;\n\t\t\tavoidCollisions(other);\n\t\t}\n\t\tif (canJump) {\n\n\t\t\tdouble distance = calculateDistance(Player.player);\n\t\t\tif (distance < thresholdDistance) {\n\t\t\t\tif (currentTime - lastJump >= jumpCoolDown) {\n\t\t\t\t\tjump = true;\n\t\t\t\t\tlastJump = currentTime;\n\t\t\t\t\tthis.speed = jumpingSpeed;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tjump = false;\n\t\t\t\tthis.speed = normalSpeed;\n\t\t\t}\n\n\t\t}\n\t\tif (Asitli) {\n\t\t\tif (currentTime - lastShootTime >= ShootCooldown) {\n\t\t\t\tlastShootTime = currentTime;\n\t\t\t\tShootCooldown = rand.nextInt(2000) + 8000;\n\t\t\t\tAsit.shoot(this.worldX, this.worldY, Player.player.worldX + 40, Player.player.worldY + 50);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic double calculateDistance(Player player) {\n\t\treturn Math.sqrt(Math.pow(player.worldX - this.worldX + 40, 2) + Math.pow(player.worldY - this.worldY + 50, 2));\n\t}\n\n\tpublic void moveTowards() {\n\t\tworldX += dX * speed;\n\t\tworldY += dY * speed;\n\t}\n\n\tpublic void draw(Graphics g) {\n\t\tdouble screenX = worldX - Player.player.worldX + Player.player.screenX;\n\t\tdouble screenY = worldY - Player.player.worldY + Player.player.screenY;\n\n\t\tg.setColor(color);\n\t\tg.fillOval((int) screenX, (int) screenY, (int) (GamePanel.GP.tileSize * size),\n\t\t\t\t(int) (GamePanel.GP.tileSize * size));\n\t\tg.setColor(Color.black);\n\t}\n\n\tprivate void avoidCollisions(Entity other) {\n\t\tdouble dx = other.worldX - worldX;\n\t\tdouble dy = other.worldY - worldY;\n\t\tdouble distance = (float) Math.sqrt(dx * dx + dy * dy);\n\t\tdouble minDistance = this.radious * 2;\n\n\t\tif (distance < minDistance && distance > 0) {\n\t\t\tdouble overlap = minDistance - distance;\n\t\t\tworldX -= (dx / distance) * (overlap / 2);\n\t\t\tworldY -= (dy / distance) * (overlap / 2);\n\t\t\tother.worldX += (dx / distance) * (overlap / 2);\n\t\t\tother.worldY += (dy / distance) * (overlap / 2);\n\n\t\t}\n\t}\n}\n",
      "Entity.java": "\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Entity {\n\tpublic double worldX, worldY;\n\tpublic double screenX, screenY;\n\tpublic double speed;\n\n\tpublic BufferedImage idle_down[], idle_up[], idle_rightUp[], idle_rightDown[], idle_leftUp[], idle_leftDown[];\n\tpublic BufferedImage walkNormal_down[], walkNormal_up[], walkNormal_rightUp[], walkNormal_rightDown[],\n\t\t\twalkNormal_leftUp[], walkNormal_leftDown[];\n\n\tpublic String directionAnim;\n\tpublic String direction;\n\tpublic boolean colUp, colDown, colRight, colLeft;\n\tpublic boolean isMoving;\n\tpublic int spriteCounter = 0, spriteNum = 0;\n\tpublic Rectangle solidArea;\n\tpublic boolean collisionOn = false;\n\tdouble radious = 15;\n}\n",
      "Weapon.java": "import java.awt.Color;\n\npublic abstract class Weapon {\n\tpublic double speed, coolDown, lastShotTime, currentTime;\n\tpublic int bulletSize, bulletCount, magazine, deviation, magazinCount, damage;\n\tpublic Color bulletColor;\n\tGamePanel gp;\n\tboolean continuousShoot;\n\tpublic String name;\n\n\tpublic Weapon(GamePanel gp) {\n\t\tthis.gp = gp;\n\t}\n\n\tpublic abstract void shoot(double scX, double scY, double TargetX, double TargetY);\n\n\tpublic abstract void reload();\n}\n",
      "Tile.java": "import java.awt. image.BufferedImage;\n \npublic class Tile\n                   {\n     public BufferedImage image;\n     public boolean collision = false;\n }\n",
      "Shotgun.java": "import java.awt.Color;\nimport java.util.Random;\n\npublic class Shotgun extends Weapon {\n\tpublic Shotgun(GamePanel gp) {\n\t\tsuper(gp);\n\t\tcoolDown = 1000;\n\t\tbulletColor = Color.black;\n\t\tbulletSize = 15;\n\t\tmagazine = 5;\n\t\tdeviation = 0;\n\t\tbulletCount = magazine;\n\t\tcontinuousShoot = false;\n\t\tmagazinCount = 0;\n\t\tdamage = 100;\n\t\tname = \"Shotgun\";\n\t}\n\n\t@Override\n\tpublic void shoot(double scX, double scY, double TargetX, double TargetY) {\n\t\tcurrentTime = System.currentTimeMillis();\n\t\tif (currentTime - lastShotTime >= coolDown && bulletCount > 0) {\n\n\t\t\tfor (int i = -4; i <= 4; i++) {\n\t\t\t\tdouble diffX = TargetX - scX;\n\t\t\t\tdouble diffY = TargetY - scY;\n\n\t\t\t\tdouble length = Math.sqrt(diffX * diffX + diffY * diffY);\n\t\t\t\tif (length != 0) {\n\t\t\t\t\tdiffX /= length;\n\t\t\t\t\tdiffY /= length;\n\t\t\t\t}\n\n\t\t\t\tdouble angle = Math.atan2(diffY, diffX);\n\n\t\t\t\tdouble deviationn = Math.toRadians(new Random().nextDouble() * deviation * 2 - deviation);\n\t\t\t\tangle += deviationn;\n\n\t\t\t\tdouble angleOffset = Math.toRadians(i * 5);\n\t\t\t\tdouble newAngle = angle + angleOffset;\n\n\t\t\t\tGameManager.Game.projectiles\n\t\t\t\t\t\t.add(new Projectile(scX, scY, newAngle, bulletSize, bulletColor, 120, \"Shotgun\", damage, 10));\n\t\t\t}\n\t\t\tlastShotTime = currentTime;\n\t\t\tbulletCount--;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void reload() {\n\t\tif (magazinCount > 0 && bulletCount != magazine) {\n\t\t\tbulletCount = magazine;\n\t\t\tmagazinCount--;\n\t\t}\n\t}\n}",
      "Item.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.Random;\n\npublic class Item extends Entity {\n\n\tRandom rand;\n\tColor color;\n\tdouble size;\n\n\tpublic String ItemType;\n\n\tpublic Item(String Item, Color color) {\n\t\trand = new Random();\n\t\tthis.worldX = rand.nextInt(941) + 30;\n\t\tthis.worldY = rand.nextInt(691) + 30;\n\t\tthis.color = color;\n\t\tthis.ItemType = Item;\n\t\tsize = 0.6;\n\t\tradious = 15;\n\t}\n\n\tpublic Item(double x, double y, String Item, Color color) {\n\t\trand = new Random();\n\t\tthis.worldX = x - 75;\n\t\tthis.worldY = y - 45;\n\t\tthis.color = color;\n\t\tthis.ItemType = Item;\n\t\tsize = 0.6;\n\t\tradious = 15;\n\t}\n\n\tpublic void draw(Graphics g) {\n\n\t\tdouble screenX = worldX - Player.player.worldX + Player.player.screenX;\n\t\tdouble screenY = worldY - Player.player.worldY + Player.player.screenY;\n\n\t\tg.setColor(color);\n\t\tg.fillRect((int) screenX, (int) screenY, (int) (GamePanel.GP.tileSize * size),\n\t\t\t\t(int) (GamePanel.GP.tileSize * size));\n\t\tg.setColor(Color.black);\n\t}\n}\n",
      "NormalZombie.java": "import java.awt.Color;\n\npublic class NormalZombie extends Zombie {\n\tpublic NormalZombie() {\n\t\tsuper(100);\n\t\tradious = 16;\n\t\tsize = 1;\n\t\tspeed = 2;\n\t\tdamage = 20;\n\t\tcolor = Color.red;\n\t\tpoint = 10;\n\t}\n}\n",
      "SurungeZombie.java": "import java.awt.Color;\n\npublic class SurungeZombie extends Zombie {\n\tpublic SurungeZombie() {\n\t\tsuper(50);\n\t\tradious = 13;\n\t\tsize = 0.8;\n\t\tnormalSpeed = 3;\n\t\tspeed = normalSpeed;\n\t\tjumpingSpeed = 15;\n\t\tdamage = 30;\n\t\tcolor = Color.yellow;\n\t\tcanJump = true;\n\t\tpoint = 20;\n\t\tthresholdDistance = 100;\n\t\tjumpCoolDown = 1500;\n\t\tlastJump = System.currentTimeMillis();\n\t}\n}\n",
      "AsitliZombie.java": "import java.awt.Color;\n\npublic class AsitliZombie extends Zombie {\n\tpublic AsitliZombie() {\n\t\tsuper(50);\n\t\tradious = 20;\n\t\tsize = 1.2;\n\t\tnormalSpeed = 0.6;\n\t\tspeed = normalSpeed;\n\t\tjumpingSpeed = 0;\n\t\tdamage = 20;\n\t\tcolor = Color.orange;\n\t\tcanJump = false;\n\t\tAsitli = true;\n\t\tAsit = new Asit(GamePanel.GP);\n\t\tpoint = 30;\n\t}\n}\n",
      "Collision.java": "\npublic class Collision {\n\tpublic static boolean checkCollision(double ObjectX, double ObjectY, double targetX, double TargetY,\n\t\t\tdouble objectRadius, double targetRadius) {\n\t\tdouble dx = (ObjectX + objectRadius) - (targetX + targetRadius);\n\t\tdouble dy = (ObjectY + objectRadius) - (TargetY + targetRadius);\n\t\tdouble distance = (dx * dx) + (dy * dy);\n\t\tdouble radiusSum = (objectRadius + targetRadius) * (objectRadius + targetRadius);\n\t\treturn distance < radiusSum;\n\t}\n}\n",
      "Rocket.java": "import java.awt.Color;\n\npublic class Rocket extends Weapon {\n\tpublic Rocket(GamePanel gp) {\n\t\tsuper(gp);\n\t\tcoolDown = 6000;\n\t\tbulletColor = Color.cyan;\n\t\tbulletSize = 30;\n\t\tmagazine = 1;\n\t\tdeviation = 0;\n\t\tbulletCount = magazine;\n\t\tcontinuousShoot = false;\n\t\tmagazinCount = 0;\n\t\tdamage = 300;\n\t\tname = \"Rocket\";\n\t}\n\n\t@Override\n\tpublic void shoot(double scX, double scY, double TargetX, double TargetY) {\n\t\tcurrentTime = System.currentTimeMillis();\n\t\tif (currentTime - lastShotTime >= coolDown && bulletCount > 0) {\n\t\t\tGameManager.Game.projectiles.add(new Projectile(scX, scY, TargetX, TargetY, deviation, bulletSize,\n\t\t\t\t\tbulletColor, 120, \"Rocket\", damage, 10));\n\t\t\tlastShotTime = currentTime;\n\t\t\tbulletCount--;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void reload() {\n\t\tif (magazinCount > 0 && bulletCount != magazine) {\n\t\t\tbulletCount = magazine;\n\t\t\tmagazinCount--;\n\t\t}\n\t}\n}",
      "MainMenu.java": "import java.awt.CardLayout;\nimport java.awt.Color;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class MainMenu extends JFrame {\n\tprivate CardLayout cardLayout;\n\tprivate JPanel mainPanel;\n\tprivate JPanel menuPanel;\n\tprivate GamePanel gamePanel;\n\tpublic SaveManager saveM;\n\tpublic static MainMenu i;\n\n\tpublic MainMenu() {\n\t\tif (i == null) {\n\t\t\ti = this;\n\t\t}\n\t\tsaveM = new SaveManager();\n\t\tsetTitle(\"Game Menu\");\n\t\tsetSize(1024, 768);\n\t\tsetResizable(false);\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetLocationRelativeTo(null);\n\n\t\tcardLayout = new CardLayout();\n\t\tmainPanel = new JPanel(cardLayout);\n\n\t\tsetupMenuPanel();\n\t\tgamePanel = new GamePanel();\n\n\t\tmainPanel.add(menuPanel, \"Menu\");\n\t\tmainPanel.add(gamePanel, \"Game\");\n\n\t\tadd(mainPanel);\n\t\tsetVisible(true);\n\t}\n\n\tprivate void setupMenuPanel() {\n\t\tmenuPanel = new JPanel(new GridBagLayout());\n\t\tmenuPanel.setBackground(new Color(0, 100, 0));\n\n\t\tGridBagConstraints gbc = new GridBagConstraints();\n\t\tgbc.gridx = 0;\n\t\tgbc.gridy = 0;\n\t\tgbc.insets = new Insets(20, 0, 20, 0);\n\n\t\tString[] menuItems = { \"Play\", \"Load\", \"Exit\" };\n\t\tfor (String item : menuItems) {\n\t\t\tJButton button = new JButton(item);\n\t\t\tbutton.setFocusPainted(false);\n\t\t\tbutton.setBackground(new Color(60, 63, 65));\n\t\t\tbutton.setForeground(Color.WHITE);\n\t\t\tbutton.setFont(new Font(\"Arial\", Font.BOLD, 24));\n\t\t\tbutton.setBorderPainted(false);\n\t\t\tbutton.setOpaque(true);\n\t\t\tbutton.setPreferredSize(new Dimension(200, 70));\n\n\t\t\tbutton.addActionListener(e -> {\n\t\t\t\tswitch (item) {\n\t\t\t\t\tcase \"Play\":\n\t\t\t\t\t\tStartGame();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"Load\":\n\t\t\t\t\t\tLoadGame();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"Exit\":\n\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmenuPanel.add(button, gbc);\n\t\t\tgbc.gridy++;\n\t\t}\n\t}\n\n\tpublic void LoadGame() {\n\t\tGameManager.save = SaveManager.Load();\n\t\tif (GameManager.save != null) {\n\t\t\tStartGame();\n\t\t}\n\t}\n\n\tpublic void StartGame() {\n\t\tGameManager Game = new GameManager();\n\t\tsetTitle(\"Top Down Shooter\");\n\t\tgamePanel.startGameThread();\n\t\tcardLayout.show(mainPanel, \"Game\");\n\t\tgamePanel.requestFocusInWindow();\n\t\tgamePanel.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));\n\n\t}\n}\n",
      "GamePanel.java": "import java.awt.AlphaComposite;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\n\nimport javax.swing.JPanel;\n\npublic class GamePanel extends JPanel implements Runnable {\n\tpublic static GamePanel GP;\n\tfinal int originalTileSize = 32;\n\tfinal int scale = 1;\n\n\tpublic final int tileSize = originalTileSize * scale;\n\tfinal int maxScreenCol = 32;\n\tfinal int maxScreenRow = 24;\n\n\tfinal int screenWidth = tileSize * maxScreenCol;\n\tfinal int screenHeight = tileSize * maxScreenRow;\n\n\tpublic final int maxWorldCol = 32;\n\tpublic final int maxWorldRow = 24;\n\tpublic final int worldWidth = maxWorldCol * tileSize;\n\tpublic final int worldHeight = maxWorldRow * tileSize;\n\n\tpublic static boolean gameOver;\n\n\tCollisionChecker cChecker = new CollisionChecker(this);\n\n\tKeyHandler keyH = new KeyHandler(this);\n\tThread gameThread;\n\tpublic Player player = new Player(this, keyH);\n\n\tint FPS = 60;\n\n\tTileManager tileM = new TileManager(this);\n\n\tpublic GamePanel() {\n\t\tif (GP == null) {\n\t\t\tGP = this;\n\t\t}\n\t\tthis.setPreferredSize(new Dimension(screenWidth, screenHeight));\n\t\tthis.setBackground(Color.black);\n\t\tthis.setDoubleBuffered(true);\n\t\tthis.addKeyListener(keyH);\n\t\tthis.setFocusable(true);\n\t}\n\n\tpublic void startGameThread() {\n\t\tgameThread = new Thread(this);\n\t\tgameThread.start();\n\t}\n\n\tpublic boolean running = true;\n\tpublic boolean paused = false;\n\n\tpublic synchronized void pauseGame() {\n\t\tpaused = true;\n\t}\n\n\tpublic synchronized void GameOver() {\n\t\tgameOver = true;\n\t}\n\n\tpublic synchronized void resumeGame() {\n\t\tpaused = false;\n\t\tnotify();\n\t}\n\n\tpublic synchronized void RestartGame() {\n\t\tgameOver = false;\n\t\tinitializedOnGameOver = false;\n\t\tnotify();\n\t}\n\n\tpublic void stopGame() {\n\t\trunning = false;\n\t}\n\n\t@Override\n\tpublic void run() {\n\n\t\tdouble drawInterval = 1000000000 / FPS;\n\t\tdouble delta = 0;\n\t\tlong lastTime = System.nanoTime();\n\t\tlong currentTime;\n\t\twhile (gameThread != null) {\n\t\t\tcurrentTime = System.nanoTime();\n\t\t\tdelta += (currentTime - lastTime) / drawInterval;\n\t\t\tlastTime = currentTime;\n\n\t\t\tif (delta >= 1) {\n\t\t\t\tUpdate();\n\t\t\t\trepaint();\n\t\t\t\tdelta--;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tboolean initializedOnGameOver = false;\n\n\tpublic void Update() {\n\t\tif (keyH.restartPressed) {\n\t\t\tif (gameOver) {\n\t\t\t\tRestartGame();\n\t\t\t}\n\t\t}\n\t\tif (keyH.pausePressed && !gameOver) {\n\t\t\tif (!paused) {\n\t\t\t\tSystem.out.println(\"pause\");\n\t\t\t\tpauseGame();\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"resume\");\n\t\t\t\tresumeGame();\n\t\t\t}\n\t\t}\n\t\tif (!gameOver) {\n\t\t\tif (!paused) {\n\t\t\t\tplayer.update();\n\t\t\t\tGameManager.Game.update();\n\n\t\t\t\tfor (Zombie z : GameManager.Game.zombies) {\n\t\t\t\t\tz.update();\n\t\t\t\t}\n\n\t\t\t\tfor (Projectile z : GameManager.Game.projectiles) {\n\t\t\t\t\tz.update();\n\t\t\t\t\tif (z.isExpired()) {\n\t\t\t\t\t\tGameManager.Game.zombies.remove(z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!initializedOnGameOver) {\n\t\t\t\tPlayer.player.Initialize(GamePanel.GP);\n\t\t\t\tGameManager.Game.Initialize();\n\t\t\t\tinitializedOnGameOver = true;\n\t\t\t}\n\t\t}\n\n\t\tkeyH.update();\n\t}\n\n\tprivate void drawPauseScreen(Graphics g, int width, int height) {\n\t\tGraphics2D g2d = (Graphics2D) g;\n\n\t\tComposite originalComposite = g2d.getComposite();\n\t\tg2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));\n\n\t\tg2d.setColor(Color.BLACK);\n\t\tg2d.fillRect(0, 0, width, height);\n\n\t\tg2d.setComposite(originalComposite);\n\n\t\tg2d.setFont(new Font(\"Arial\", Font.BOLD, 50));\n\t\tg2d.setColor(Color.WHITE);\n\t\tString text = \"PAUSED\";\n\t\tFontMetrics fm = g2d.getFontMetrics();\n\t\tint textWidth = fm.stringWidth(text);\n\t\tint textHeight = fm.getHeight();\n\t\tg2d.drawString(text, (width - textWidth) / 2, (height / 2) - (textHeight / 4));\n\t}\n\n\tprivate void drawGameOverScreen(Graphics gp, int width, int height) {\n\t\tgp.setColor(Color.RED);\n\t\tgp.setFont(new Font(\"Arial\", Font.BOLD, 40));\n\t\tgp.drawString(\"Game Over\", width / 2 - 100, height / 2 - 20);\n\n\t\tgp.setFont(new Font(\"Arial\", Font.PLAIN, 20));\n\t\tgp.setColor(Color.WHITE);\n\t\tgp.drawString(\"Press SPACE for Restart\", width / 2 - 105, height / 2 + 20);\n\t}\n\n\tpublic void paintComponent(Graphics g) {\n\t\tsuper.paintComponent(g);\n\t\tGraphics2D g2 = (Graphics2D) g;\n\n\t\tif (gameOver) {\n\t\t\tdrawGameOverScreen(g, 1024, 768);\n\t\t} else if (paused) {\n\t\t\tdrawPauseScreen(g, 1024, 768);\n\t\t} else {\n\t\t\ttileM.draw(g2);\n\n\t\t\tfor (Projectile p : GameManager.Game.projectiles) {\n\t\t\t\tp.draw(g);\n\t\t\t}\n\t\t\tfor (Item p : GameManager.Game.items) {\n\t\t\t\tp.draw(g);\n\t\t\t}\n\t\t\tfor (Zombie z : GameManager.Game.zombies) {\n\t\t\t\tz.draw(g);\n\t\t\t}\n\t\t\tfor (Zombie z : GameManager.Game.zombies) {\n\t\t\t\tz.health.render(g2, z.worldX, z.worldY);\n\t\t\t}\n\t\t\tplayer.health.draw(g, 800, 20);\n\t\t\tGameManager.Game.wave.draw(g);\n\t\t\tg2.setColor(Color.white);\n\t\t\tg2.setFont(new Font(\"Arial\", Font.ITALIC, 15));\n\t\t\tg2.drawString(\"Press F1 for save game\", 20, 720);\n\t\t\tplayer.draw(g2);\n\t\t}\n\n\t\tg2.dispose();\n\t}\n}\n",
      "GameManager.java": "import java.awt.Color;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic class GameManager {\n\tList<Zombie> zombies = new CopyOnWriteArrayList<Zombie>();\n\tList<Item> items = new CopyOnWriteArrayList<Item>();\n\tpublic List<Projectile> projectiles = new CopyOnWriteArrayList<>();\n\tpublic static GameManager Game;\n\tdouble currentTime, lastSpawn, coolDown;\n\tdouble itemCooldown, itemLast;\n\tRandom rand;\n\tpublic WaveManager wave = new WaveManager();\n\tpublic static Save save;\n\n\tpublic GameManager() {\n\t\tif (Game == null) {\n\t\t\tGame = this;\n\t\t}\n\t\tRuntime.getRuntime().addShutdownHook(new Thread(() -> {\n\t\t\t(new SaveManager()).SaveGame();\n\t\t}));\n\t\trand = new Random();\n\t\tcoolDown = 3000;\n\t\titemCooldown = 10000;\n\t\titemLast = System.currentTimeMillis();\n\n\t\tif (save != null) {\n\t\t\tPlayer p = Player.player;\n\n\t\t\tswitch (save.gunSize) {\n\t\t\t\tcase 2:\n\t\t\t\t\tp.weapons.add(new Rifle(GamePanel.GP));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tp.weapons.add(new Rifle(GamePanel.GP));\n\t\t\t\t\tp.weapons.add(new Shotgun(GamePanel.GP));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tp.weapons.add(new Rifle(GamePanel.GP));\n\t\t\t\t\tp.weapons.add(new Shotgun(GamePanel.GP));\n\t\t\t\t\tp.weapons.add(new Sniper(GamePanel.GP));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tp.weapons.add(new Rifle(GamePanel.GP));\n\t\t\t\t\tp.weapons.add(new Shotgun(GamePanel.GP));\n\t\t\t\t\tp.weapons.add(new Sniper(GamePanel.GP));\n\t\t\t\t\tp.weapons.add(new Rocket(GamePanel.GP));\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < save.gunSize; i++) {\n\t\t\t\tp.weapons.get(i).bulletCount = save.bulletCount[i];\n\t\t\t\tp.weapons.get(i).magazinCount = save.magazinCount[i];\n\t\t\t}\n\n\t\t\tp.point = save.point;\n\t\t\tp.currentGun = save.currentGun;\n\t\t\tp.worldX = save.x;\n\t\t\tp.worldY = save.y;\n\t\t\tGameManager.Game.wave.wave = save.wave;\n\t\t\tGameManager.Game.wave.enemyCount = save.enemyCount;\n\t\t\tp.health.currentHealth = save.currentHealth;\n\t\t}\n\n\t}\n\n\tpublic void Initialize() {\n\t\tprojectiles.removeAll(projectiles);\n\t\titems.removeAll(items);\n\t\tzombies.removeAll(zombies);\n\t\twave.Initliaze();\n\t\titemLast = System.currentTimeMillis();\n\t}\n\n\tpublic void update() {\n\n\t\tcurrentTime = System.currentTimeMillis();\n\t\tif (GamePanel.GP.keyH.savePressed) {\n\t\t\t(new SaveManager()).SaveGame();\n\t\t}\n\t\tif (zombies.isEmpty()) {\n\t\t\tif (wave.wave == 2 && Player.player.weapons.size() <= 1) {\n\t\t\t\tPlayer.player.weapons.add(new Rifle(GamePanel.GP));\n\t\t\t}\n\t\t\tif (wave.wave == 4 && Player.player.weapons.size() <= 2) {\n\t\t\t\tPlayer.player.weapons.add(new Shotgun(GamePanel.GP));\n\t\t\t}\n\t\t\tif (wave.wave == 6 && Player.player.weapons.size() <= 3) {\n\t\t\t\tPlayer.player.weapons.add(new Sniper(GamePanel.GP));\n\t\t\t}\n\t\t\tif (wave.wave == 11 && Player.player.weapons.size() <= 4) {\n\t\t\t\tPlayer.player.weapons.add(new Rocket(GamePanel.GP));\n\t\t\t}\n\t\t\tif (currentTime - lastSpawn >= coolDown) {\n\t\t\t\twave.Wave(zombies);\n\t\t\t}\n\t\t}\n\t\tif (currentTime - itemLast >= itemCooldown) {\n\t\t\tint a = rand.nextInt(11);\n\t\t\tswitch (a) {\n\t\t\t\tcase 1:\n\t\t\t\t\tif (Player.player.weapons.size() > 1) {\n\t\t\t\t\t\tGameManager.Game.items.add(new Item(\"Rifle\", Color.red));\n\t\t\t\t\t}\n\t\t\t\t\titemLast = currentTime;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif (Player.player.weapons.size() > 2) {\n\t\t\t\t\t\tGameManager.Game.items.add(new Item(\"Shotgun\", Color.black));\n\t\t\t\t\t}\n\t\t\t\t\titemLast = currentTime;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tif (Player.player.weapons.size() > 3) {\n\t\t\t\t\t\tGameManager.Game.items.add(new Item(\"Sniper\", Color.yellow));\n\t\t\t\t\t}\n\t\t\t\t\titemLast = currentTime;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tif (Player.player.weapons.size() > 4) {\n\t\t\t\t\t\tGameManager.Game.items.add(new Item(\"Rocket\", Color.cyan));\n\t\t\t\t\t}\n\t\t\t\t\titemLast = currentTime;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tGameManager.Game.items.add(new Item(\"Potion\", Color.green));\n\t\t\t\t\titemLast = currentTime;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void SpawnItem(double x, double y) {\n\t\tint a = rand.nextInt(11);\n\t\tswitch (a) {\n\t\t\tcase 1:\n\t\t\t\tif (Player.player.weapons.size() > 1) {\n\t\t\t\t\tGameManager.Game.items.add(new Item(x, y, \"Rifle\", Color.red));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (Player.player.weapons.size() > 2) {\n\t\t\t\t\tGameManager.Game.items.add(new Item(x, y, \"Shotgun\", Color.black));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (Player.player.weapons.size() > 3) {\n\t\t\t\t\tGameManager.Game.items.add(new Item(x, y, \"Sniper\", Color.yellow));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (Player.player.weapons.size() > 4) {\n\t\t\t\t\tGameManager.Game.items.add(new Item(x, y, \"Rocket\", Color.cyan));\n\t\t\t\t}\n\t\t\tcase 5:\n\t\t\t\tGameManager.Game.items.add(new Item(x, y, \"Potion\", Color.green));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic void DeleteZombie(Entity z) {\n\t\tzombies.remove(z);\n\t}\n\n\tpublic void DeleteProjectile(Projectile z) {\n\t\tprojectiles.remove(z);\n\t}\n}",
      "KeyHandler.java": "import java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseMotionAdapter;\n\npublic class KeyHandler implements KeyListener {\n\tpublic boolean upPressed, downPressed, rightPressed, leftPressed, reloadPressed, reloadReleased = true,\n\t\t\treloadPressing, mousePressed, mousePressing, NextGunPressed, NextGunPressing, NextGunReleased = true,\n\t\t\tPreviousGunPressed, PreviousGunPressing, PreviousGunReleased = true, pausePressed, pauseReleased = true,\n\t\t\tpausePressing, restartReleased = true, restartPressed, restartPressing, saveReleased = true, savePressed,\n\t\t\tsavePressing;\n\tpublic double MouseX, MouseY;\n\n\tpublic int number = 1;\n\n\tGamePanel gp;\n\n\tpublic KeyHandler(GamePanel gp) {\n\t\tthis.gp = gp;\n\t}\n\n\t@Override\n\tpublic void keyTyped(KeyEvent e) {\n\t}\n\n\tpublic void mousePressed(MouseEvent e) {\n\t\tmousePressed = true;\n\t\tMouseX = e.getX();\n\t\tMouseY = e.getY();\n\t}\n\n\tpublic void mouseMoved(MouseEvent e) {\n\t\tMouseX = e.getX();\n\t\tMouseY = e.getY();\n\t}\n\n\tpublic void update() {\n\t\tif (mousePressed) {\n\t\t\tmousePressing = true;\n\t\t\tmousePressed = false;\n\t\t}\n\t\tif (reloadPressed) {\n\t\t\treloadPressing = true;\n\t\t\treloadPressed = false;\n\t\t}\n\t\tif (NextGunPressed) {\n\t\t\tNextGunPressing = true;\n\t\t\tNextGunPressed = false;\n\t\t}\n\t\tif (PreviousGunPressed) {\n\t\t\tPreviousGunPressing = true;\n\t\t\tPreviousGunPressed = false;\n\t\t}\n\t\tif (pausePressed) {\n\t\t\tpausePressing = true;\n\t\t\tpausePressed = false;\n\t\t}\n\t\tif (restartPressed) {\n\t\t\trestartPressing = true;\n\t\t\trestartPressed = false;\n\t\t}\n\t\tif (savePressed) {\n\t\t\tsavePressing = true;\n\t\t\tsavePressed = false;\n\t\t}\n\t\tgp.addMouseMotionListener(new MouseMotionAdapter() {\n\t\t\t@Override\n\t\t\tpublic void mouseMoved(MouseEvent e) {\n\t\t\t\tMouseX = e.getX();\n\t\t\t\tMouseY = e.getY();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void mouseDragged(MouseEvent e) {\n\t\t\t\tMouseX = e.getX();\n\t\t\t\tMouseY = e.getY();\n\t\t\t}\n\t\t});\n\n\t\tgp.addMouseListener(new MouseAdapter() {\n\t\t\t@Override\n\t\t\tpublic void mousePressed(MouseEvent e) {\n\t\t\t\tmousePressed = true;\n\t\t\t}\n\n\t\t\tpublic void mouseReleased(MouseEvent e) {\n\t\t\t\tmousePressed = false;\n\t\t\t\tmousePressing = false;\n\t\t\t}\n\t\t});\n\n\t}\n\n\t@Override\n\tpublic void keyPressed(KeyEvent e) {\n\t\tint code = e.getKeyCode();\n\t\tif (code == KeyEvent.VK_W) {\n\t\t\tupPressed = true;\n\t\t}\n\t\tif (code == KeyEvent.VK_S) {\n\t\t\tdownPressed = true;\n\t\t}\n\t\tif (code == KeyEvent.VK_A) {\n\t\t\tleftPressed = true;\n\t\t}\n\t\tif (code == KeyEvent.VK_D) {\n\t\t\trightPressed = true;\n\t\t}\n\t\tif (code == KeyEvent.VK_R) {\n\t\t\tif (reloadReleased) {\n\t\t\t\treloadPressed = true;\n\t\t\t\treloadReleased = false;\n\t\t\t}\n\t\t}\n\t\tif (code == KeyEvent.VK_E) {\n\t\t\tif (NextGunReleased) {\n\t\t\t\tNextGunPressed = true;\n\t\t\t\tNextGunReleased = false;\n\t\t\t}\n\t\t}\n\t\tif (code == KeyEvent.VK_Q) {\n\t\t\tif (PreviousGunReleased) {\n\t\t\t\tPreviousGunPressed = true;\n\t\t\t\tPreviousGunReleased = false;\n\t\t\t}\n\t\t}\n\t\tif (code == KeyEvent.VK_ESCAPE) {\n\t\t\tif (pauseReleased) {\n\t\t\t\tpausePressed = true;\n\t\t\t\tpauseReleased = false;\n\t\t\t}\n\t\t}\n\t\tif (code == KeyEvent.VK_SPACE) {\n\t\t\tif (restartReleased) {\n\t\t\t\trestartPressed = true;\n\t\t\t\trestartReleased = false;\n\t\t\t}\n\t\t}\n\t\tif (code == KeyEvent.VK_F1) {\n\t\t\tif (saveReleased) {\n\t\t\t\tsavePressed = true;\n\t\t\t\tsaveReleased = false;\n\t\t\t}\n\t\t}\n\t\tswitch (code) {\n\t\tcase KeyEvent.VK_1:\n\t\t\tnumber = 1;\n\t\t\tbreak;\n\t\tcase KeyEvent.VK_2:\n\t\t\tnumber = 2;\n\t\t\tbreak;\n\t\tcase KeyEvent.VK_3:\n\t\t\tnumber = 3;\n\t\t\tbreak;\n\t\tcase KeyEvent.VK_4:\n\t\t\tnumber = 4;\n\t\t\tbreak;\n\t\tcase KeyEvent.VK_5:\n\t\t\tnumber = 5;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void keyReleased(KeyEvent e) {\n\t\tint code = e.getKeyCode();\n\t\tif (code == KeyEvent.VK_W) {\n\t\t\tupPressed = false;\n\t\t}\n\t\tif (code == KeyEvent.VK_S) {\n\t\t\tdownPressed = false;\n\t\t}\n\t\tif (code == KeyEvent.VK_A) {\n\t\t\tleftPressed = false;\n\t\t}\n\t\tif (code == KeyEvent.VK_D) {\n\t\t\trightPressed = false;\n\t\t}\n\t\tif (code == KeyEvent.VK_R) {\n\t\t\treloadPressed = false;\n\t\t\treloadReleased = true;\n\t\t}\n\t\tif (code == KeyEvent.VK_E) {\n\t\t\tNextGunPressed = false;\n\t\t\tNextGunReleased = true;\n\t\t}\n\t\tif (code == KeyEvent.VK_Q) {\n\t\t\tPreviousGunPressed = false;\n\t\t\tPreviousGunReleased = true;\n\t\t}\n\t\tif (code == KeyEvent.VK_ESCAPE) {\n\t\t\tpausePressed = false;\n\t\t\tpauseReleased = true;\n\t\t}\n\t\tif (code == KeyEvent.VK_SPACE) {\n\t\t\trestartPressed = false;\n\t\t\trestartReleased = true;\n\t\t}\n\t\tif (code == KeyEvent.VK_F1) {\n\t\t\tsavePressed = false;\n\t\t\tsaveReleased = true;\n\t\t}\n\t}\n\n}\n",
      "Rifle.java": "import java.awt.Color;\n\npublic class Rifle extends Weapon {\n\tpublic Rifle(GamePanel gp) {\n\t\tsuper(gp);\n\t\tcoolDown = 100;\n\t\tbulletColor = Color.red;\n\t\tbulletSize = 8;\n\t\tmagazine = 30;\n\t\tdeviation = 30;\n\t\tbulletCount = magazine;\n\t\tcontinuousShoot = true;\n\t\tmagazinCount = 0;\n\t\tdamage = 25;\n\t\tname = \"Rifle\";\n\t}\n\n\t@Override\n\tpublic void shoot(double scX, double scY, double TargetX, double TargetY) {\n\t\tcurrentTime = System.currentTimeMillis();\n\t\tif (currentTime - lastShotTime >= coolDown && bulletCount > 0) {\n\t\t\tGameManager.Game.projectiles.add(new Projectile(scX, scY, TargetX, TargetY, deviation, bulletSize,\n\t\t\t\t\tbulletColor, 120, \"Rifle\", damage, 15));\n\t\t\tlastShotTime = currentTime;\n\t\t\tbulletCount--;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void reload() {\n\t\tif (magazinCount > 0 && bulletCount != magazine) {\n\t\t\tbulletCount = magazine;\n\t\t\tmagazinCount--;\n\t\t}\n\t}\n}\n",
      "TankZombie.java": "import java.awt.Color;\n\npublic class TankZombie extends Zombie {\n\tpublic TankZombie() {\n\t\tsuper(450);\n\t\tradious = 30;\n\t\tsize = 2;\n\t\tnormalSpeed = 0.3;\n\t\tspeed = normalSpeed;\n\t\tjumpingSpeed = 0;\n\t\tdamage = 50;\n\t\tcolor = Color.gray;\n\t\tpoint = 50;\n\t}\n}\n",
      "SaveManager.java": "import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\nclass Save implements Serializable {\n\tdouble x, y;\n\tpublic int wave;\n\tpublic int point;\n\tpublic int[] bulletCount;\n\tpublic int[] magazinCount;\n\tint currentGun, gunSize, enemyCount;\n\tint currentHealth;\n}\n\npublic class SaveManager {\n\tprivate static final String SAVE_FILE = \"save.dat\";\n\n\tpublic static void Save(double x, double y, int wave, int point, int[] bulletCount, int[] magazinCount,\n\t\t\tint currentGun, int gunSize, int enemyCount, int currentHealth) {\n\t\tSave save = new Save();\n\t\tsave.x = x;\n\t\tsave.y = y;\n\t\tsave.wave = wave;\n\t\tsave.point = point;\n\t\tsave.bulletCount = bulletCount;\n\t\tsave.magazinCount = magazinCount;\n\t\tsave.currentGun = currentGun;\n\t\tsave.gunSize = gunSize;\n\t\tsave.enemyCount = enemyCount;\n\t\tsave.currentHealth = currentHealth;\n\n\t\ttry (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(SAVE_FILE))) {\n\t\t\toos.writeObject(save);\n\t\t\tSystem.out.println(\"Saved\");\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(\"Failed to save game: \" + e.getMessage());\n\t\t}\n\t}\n\n\tpublic static Save Load() {\n\t\ttry (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(SAVE_FILE))) {\n\t\t\tSave save = (Save) ois.readObject();\n\t\t\tSystem.out.println(\"Loaded\");\n\t\t\treturn save;\n\t\t} catch (IOException | ClassNotFoundException e) {\n\t\t\tSystem.err.println(\"Failed to load game: \" + e.getMessage());\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic void SaveGame() {\n\t\tPlayer p = Player.player;\n\t\tint[] bulletCount = new int[5];\n\t\tint[] magazinCount = new int[5];\n\n\t\tfor (int i = 0; i < p.weapons.size(); i++) {\n\t\t\tbulletCount[i] = p.weapons.get(i).bulletCount;\n\t\t\tmagazinCount[i] = p.weapons.get(i).magazinCount;\n\t\t}\n\n\t\tSaveManager.Save(Player.player.worldX, Player.player.worldY, WaveManager.instance.wave - 1, Player.player.point,\n\t\t\t\tbulletCount, magazinCount, p.currentGun, p.weapons.size(), WaveManager.instance.enemyCount,\n\t\t\t\tp.health.currentHealth);\n\t}\n\n\tpublic void LoadGame() {\n\t\tGameManager.save = SaveManager.Load();\n\t}\n}\n",
      "Game.java": "import javax.swing.SwingUtilities;\n\npublic class Game {\n\tpublic static void main(String[] args) throws Exception {\n\t\tSwingUtilities.invokeLater(() -> {\n\t\t\tnew MainMenu().setVisible(true);\n\t\t});\n\t}\n}\n",
      "CollisionChecker.java": "\npublic class CollisionChecker {\n\tGamePanel gp;\n\tpublic String WallDir;\n\n\tpublic CollisionChecker(GamePanel gp) {\n\t\tthis.gp = gp;\n\t}\n\n\tpublic void checkTile(Entity entity) {\n\t\tdouble entityLeftWorldX = entity.worldX + entity.solidArea.x;\n\t\tdouble entityRightWorldX = entity.worldX + entity.solidArea.x + entity.solidArea.width;\n\t\tdouble entityTopWorldY = entity.worldY + entity.solidArea.y;\n\t\tdouble entityBottomWorldY = entity.worldY + entity.solidArea.y + entity.solidArea.height;\n\n\t\tint entityLeftCol = (int) entityLeftWorldX / gp.tileSize;\n\t\tint entityRightCol = (int) entityRightWorldX / gp.tileSize;\n\t\tint entityTopRow = (int) entityTopWorldY / gp.tileSize;\n\t\tint entityBottomRow = (int) entityBottomWorldY / gp.tileSize;\n\n\t\tint tileNum1, tileNum2;\n\n\t\tif (entity.direction.equals(\"up\")) {\n\t\t\tentityTopRow = (int) ((entityTopWorldY - entity.speed) / gp.tileSize);\n\t\t\ttileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];\n\t\t\ttileNum2 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];\n\t\t\tif (gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true) {\n\t\t\t\tentity.collisionOn = true;\n\t\t\t\tentity.colUp = true;\n\t\t\t}\n\t\t} else if (entity.direction.equals(\"down\")) {\n\t\t\tentityBottomRow = (int) ((entityBottomWorldY + entity.speed) / gp.tileSize);\n\t\t\ttileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];\n\t\t\ttileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];\n\t\t\tif (gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true) {\n\t\t\t\tentity.collisionOn = true;\n\t\t\t\tentity.colDown = true;\n\t\t\t}\n\t\t} else if (entity.direction.contains(\"right\")) {\n\t\t\tentityRightCol = (int) ((entityRightWorldX + entity.speed) / gp.tileSize);\n\t\t\ttileNum1 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];\n\t\t\ttileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];\n\t\t\tif (gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true) {\n\t\t\t\tentity.collisionOn = true;\n\t\t\t\tentity.colRight = true;\n\t\t\t}\n\t\t} else if (entity.direction.contains(\"left\")) {\n\t\t\tentityLeftCol = (int) ((entityLeftWorldX - entity.speed) / gp.tileSize);\n\t\t\ttileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];\n\t\t\ttileNum2 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];\n\t\t\tif (gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true) {\n\t\t\t\tentity.collisionOn = true;\n\t\t\t\tentity.colLeft = true;\n\t\t\t}\n\t\t}\n\n\t}\n}\n",
      "HealthBar.java": "import java.awt.Color;\nimport java.awt.Graphics;\n\npublic class HealthBar {\n\tprivate GamePanel gamePanel;\n\tpublic int currentHealth;\n\tpublic int maxHealth = 200;\n\n\tpublic HealthBar(GamePanel gamePanel) {\n\t\tthis.gamePanel = gamePanel;\n\t\tthis.currentHealth = maxHealth;\n\t}\n\n\tpublic void update(int newHealth) {\n\t\tthis.currentHealth = Math.max(0, Math.min(newHealth, maxHealth)); // Clamp between 0 and maxHealth\n\t}\n\n\tpublic void draw(Graphics g, int x, int y) {\n\t\tint width = 200;\n\t\tint height = 32;\n\n\t\tg.setColor(Color.RED);\n\t\tg.fillRect(x, y, width, height);\n\n\t\tint healthWidth = (int) ((currentHealth / (double) maxHealth) * width);\n\t\tg.setColor(Color.GREEN);\n\t\tg.fillRect(x, y, healthWidth, height);\n\t}\n}\n",
      "TileManager.java": "import java.awt.Graphics2D;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\nimport javax.imageio.ImageIO;\n\npublic class TileManager {\n\tGamePanel gp;\n\tTile[] tile;\n\tint mapTileNum[][];\n\n\tpublic TileManager(GamePanel gp) {\n\t\tthis.gp = gp;\n\t\ttile = new Tile[2];\n\t\tmapTileNum = new int[gp.maxWorldCol][gp.maxWorldRow];\n\t\tgetTileImage();\n\t\tLoadMap();\n\t}\n\n\tpublic void LoadMap() {\n\t\ttry {\n\t\t\tInputStream is = getClass().getResourceAsStream(\"/maps/map001.txt\");\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(is));\n\n\t\t\tint col = 0;\n\t\t\tint row = 0;\n\n\t\t\twhile (col < gp.maxWorldCol && row < gp.maxWorldRow) {\n\t\t\t\tString line = br.readLine();\n\t\t\t\twhile (col < gp.maxWorldCol) {\n\t\t\t\t\tString numbers[] = line.split(\" \");\n\n\t\t\t\t\tint num = Integer.parseInt(numbers[col]);\n\n\t\t\t\t\tmapTileNum[col][row] = num;\n\t\t\t\t\tcol++;\n\t\t\t\t}\n\t\t\t\tif (col == gp.maxWorldCol) {\n\t\t\t\t\tcol = 0;\n\t\t\t\t\trow++;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} catch (Exception E) {\n\n\t\t}\n\t}\n\n\tpublic void getTileImage() {\n\t\ttry {\n\t\t\ttile[0] = new Tile();\n\t\t\ttile[0].image = ImageIO.read(getClass().getResourceAsStream(\"/tiles/grass.png\"));\n\t\t\ttile[1] = new Tile();\n\t\t\ttile[1].image = ImageIO.read(getClass().getResourceAsStream(\"/tiles/wall.png\"));\n\t\t\ttile[1].collision = true;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic void draw(Graphics2D g2) {\n\t\tint worldCol = 0;\n\t\tint worldRow = 0;\n\t\twhile (worldCol < gp.maxWorldCol && worldRow < gp.maxWorldRow) {\n\n\t\t\tint tileNum = mapTileNum[worldCol][worldRow];\n\n\t\t\tint worldX = worldCol * gp.tileSize;\n\t\t\tint worldY = worldRow * gp.tileSize;\n\t\t\tdouble screenX = worldX - gp.player.worldX + gp.player.screenX;\n\t\t\tdouble screenY = worldY - gp.player.worldY + gp.player.screenY;\n\n\t\t\tif (worldX + gp.tileSize > gp.player.worldX - gp.player.screenX\n\t\t\t\t\t&& worldX - gp.tileSize < gp.player.worldX + gp.player.screenX\n\t\t\t\t\t&& worldY + gp.tileSize > gp.player.worldY - gp.player.screenY\n\t\t\t\t\t&& worldY - gp.tileSize < gp.player.worldY + gp.player.screenY) {\n\t\t\t\tg2.drawImage(tile[tileNum].image, (int) screenX, (int) screenY, gp.tileSize, gp.tileSize, null);\n\t\t\t}\n\n\t\t\tg2.drawImage(tile[tileNum].image, (int) screenX, (int) screenY, gp.tileSize, gp.tileSize, null);\n\t\t\tworldCol++;\n\t\t\tif (worldCol == gp.maxWorldCol) {\n\t\t\t\tworldCol = 0;\n\t\t\t\tworldRow++;\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "Player.java": "import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport javax.imageio.ImageIO;\n\npublic class Player extends Entity {\n\tGamePanel gp;\n\tKeyHandler keyH;\n\tdouble speedT;\n\tpublic double ShootCoolDown = 2;\n\tpublic static Player player;\n\tpublic HealthBar health;\n\n\tfinal int RESIZE = 4;\n\n\tpublic ArrayList<Weapon> weapons;\n\tpublic int currentGun = 0;\n\n\tpublic boolean reloading = false;\n\tpublic int point;\n\n\tpublic Player(GamePanel gp, KeyHandler keyH) {\n\t\tif (player == null) {\n\t\t\tplayer = this;\n\t\t}\n\t\tthis.gp = gp;\n\t\tthis.keyH = keyH;\n\t\tthis.health = new HealthBar(gp);\n\n\t\tscreenX = gp.screenWidth / 2 - (gp.tileSize / 2 * RESIZE);\n\t\tscreenY = gp.screenHeight / 2 - (gp.tileSize / 2 * RESIZE);\n\n\t\tsolidArea = new Rectangle((gp.tileSize / 2 * RESIZE), (gp.tileSize / 2 * RESIZE), 16, 16);\n\n\t\tInitialize(gp);\n\t\tgetPlayerImage();\n\t\tradious = 20;\n\t}\n\n\tpublic void Initialize(GamePanel gp) {\n\t\thealth.currentHealth = health.maxHealth;\n\t\tworldX = 450;\n\t\tworldY = 340;\n\t\tspeed = 6;\n\t\tspeedT = speed;\n\t\tdirectionAnim = \"down\";\n\t\tdirection = \"down\";\n\t\tweapons = new ArrayList();\n\t\tweapons.add(new Tabanca(gp));\n\t\tlastDamageTime = 0;\n\t\tcurrentTime = 0;\n\t\tdamageCooldown = 0;\n\t\treloading = false;\n\t\tpoint = 0;\n\t\tcurrentGun = 0;\n\t}\n\n\tpublic void getPlayerImage() {\n\t\tidle_down = new BufferedImage[8];\n\t\tidle_up = new BufferedImage[8];\n\t\tidle_rightUp = new BufferedImage[8];\n\t\tidle_rightDown = new BufferedImage[8];\n\t\tidle_leftUp = new BufferedImage[8];\n\t\tidle_leftDown = new BufferedImage[8];\n\t\twalkNormal_down = new BufferedImage[8];\n\t\twalkNormal_up = new BufferedImage[8];\n\t\twalkNormal_rightUp = new BufferedImage[8];\n\t\twalkNormal_rightDown = new BufferedImage[8];\n\t\twalkNormal_leftUp = new BufferedImage[8];\n\t\twalkNormal_leftDown = new BufferedImage[8];\n\n\t\ttry {\n\t\t\tfor (int i = 0; i < 7; i++) {\n\t\t\t\tidle_down[i] = ImageIO.read(getClass().getResourceAsStream(\"/player_idle_down/tile00\" + i + \".png\"));\n\t\t\t\tidle_up[i] = ImageIO.read(getClass().getResourceAsStream(\"/player_idle_up/tile00\" + i + \".png\"));\n\t\t\t\tidle_rightUp[i] = ImageIO\n\t\t\t\t\t\t.read(getClass().getResourceAsStream(\"/player_idle_rightUp/tile00\" + i + \".png\"));\n\t\t\t\tidle_rightDown[i] = ImageIO\n\t\t\t\t\t\t.read(getClass().getResourceAsStream(\"/player_idle_rightDown/tile00\" + i + \".png\"));\n\t\t\t\tidle_leftUp[i] = ImageIO\n\t\t\t\t\t\t.read(getClass().getResourceAsStream(\"/player_idle_leftUp/tile00\" + i + \".png\"));\n\t\t\t\tidle_leftDown[i] = ImageIO\n\t\t\t\t\t\t.read(getClass().getResourceAsStream(\"/player_idle_leftDown/tile00\" + i + \".png\"));\n\t\t\t\twalkNormal_down[i] = ImageIO\n\t\t\t\t\t\t.read(getClass().getResourceAsStream(\"/player_walkNormal_down/tile00\" + i + \".png\"));\n\t\t\t\twalkNormal_up[i] = ImageIO\n\t\t\t\t\t\t.read(getClass().getResourceAsStream(\"/player_walkNormal_up/tile00\" + i + \".png\"));\n\t\t\t\twalkNormal_rightUp[i] = ImageIO\n\t\t\t\t\t\t.read(getClass().getResourceAsStream(\"/player_walkNormal_rightUp/tile00\" + i + \".png\"));\n\t\t\t\twalkNormal_rightDown[i] = ImageIO\n\t\t\t\t\t\t.read(getClass().getResourceAsStream(\"/player_walkNormal_rightDown/tile00\" + i + \".png\"));\n\t\t\t\twalkNormal_leftUp[i] = ImageIO\n\t\t\t\t\t\t.read(getClass().getResourceAsStream(\"/player_walkNormal_leftUp/tile00\" + i + \".png\"));\n\t\t\t\twalkNormal_leftDown[i] = ImageIO\n\t\t\t\t\t\t.read(getClass().getResourceAsStream(\"/player_walkNormal_leftDown/tile00\" + i + \".png\"));\n\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tlong lastDamageTime = 0;\n\tlong currentTime = 0;\n\tdouble damageCooldown = 0;\n\n\tpublic void decreaseHealth(int damage) {\n\t\thealth.update(health.currentHealth - damage);\n\t\tif (health.currentHealth <= 0) {\n\t\t\tgp.GameOver();\n\t\t}\n\t}\n\n\tpublic void update() {\n\n\t\tcurrentTime = System.currentTimeMillis();\n\t\tfor (Zombie z : GameManager.Game.zombies) {\n\t\t\tif (Collision.checkCollision(worldX + 40, worldY + 30, z.worldX, z.worldY, radious, z.radious)) {\n\t\t\t\tif (currentTime - lastDamageTime >= damageCooldown) {\n\t\t\t\t\tdamageCooldown = 700;\n\t\t\t\t\tdecreaseHealth(z.damage);\n\t\t\t\t\tlastDamageTime = currentTime;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Projectile z : GameManager.Game.projectiles) {\n\t\t\tif (Collision.checkCollision(worldX + 40, worldY + 30, z.worldX, z.worldY, radious, z.radious)) {\n\t\t\t\tif (currentTime - lastDamageTime >= damageCooldown && z.bulletOf.equals(\"Asit\")) {\n\t\t\t\t\tdamageCooldown = 500;\n\t\t\t\t\tdecreaseHealth(z.damage);\n\t\t\t\t\tlastDamageTime = currentTime;\n\t\t\t\t\tGameManager.Game.projectiles.remove(z);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Item i : GameManager.Game.items) {\n\t\t\tif (Collision.checkCollision(worldX + 40, worldY + 30, i.worldX, i.worldY, radious, i.radious)) {\n\t\t\t\tswitch (i.ItemType) {\n\t\t\t\t\tcase \"Rifle\":\n\t\t\t\t\t\tif (weapons.size() >= 2) {\n\t\t\t\t\t\t\tweapons.get(1).magazinCount++;\n\t\t\t\t\t\t\tGameManager.Game.items.remove(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"Shotgun\":\n\t\t\t\t\t\tif (weapons.size() >= 3) {\n\t\t\t\t\t\t\tweapons.get(2).magazinCount++;\n\t\t\t\t\t\t\tGameManager.Game.items.remove(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"Sniper\":\n\t\t\t\t\t\tif (weapons.size() >= 4) {\n\t\t\t\t\t\t\tweapons.get(3).magazinCount++;\n\t\t\t\t\t\t\tGameManager.Game.items.remove(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"Rocket\":\n\t\t\t\t\t\tif (weapons.size() >= 5) {\n\t\t\t\t\t\t\tweapons.get(4).magazinCount++;\n\t\t\t\t\t\t\tGameManager.Game.items.remove(i);\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"Potion\":\n\t\t\t\t\t\thealth.currentHealth += 50;\n\t\t\t\t\t\tGameManager.Game.items.remove(i);\n\t\t\t\t\t\tif (health.currentHealth > health.maxHealth) {\n\t\t\t\t\t\t\thealth.currentHealth = health.maxHealth;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (weapons.get(currentGun).continuousShoot) {\n\t\t\tif (keyH.mousePressing) {\n\t\t\t\tweapons.get(currentGun).shoot(worldX + 50, worldY + 40, keyH.MouseX, keyH.MouseY);\n\t\t\t}\n\t\t} else {\n\t\t\tif (keyH.mousePressed) {\n\t\t\t\tweapons.get(currentGun).shoot(worldX + 50, worldY + 40, keyH.MouseX, keyH.MouseY);\n\t\t\t}\n\t\t}\n\t\tif (keyH.reloadPressed) {\n\t\t\tweapons.get(currentGun).reload();\n\t\t}\n\t\tif (keyH.PreviousGunPressed) {\n\t\t\tkeyH.number--;\n\t\t\tif (keyH.number < 1) {\n\t\t\t\tkeyH.number = weapons.size();\n\t\t\t}\n\t\t}\n\t\tif (keyH.NextGunPressed) {\n\t\t\tkeyH.number++;\n\t\t\tif (keyH.number > weapons.size()) {\n\t\t\t\tkeyH.number = 1;\n\t\t\t}\n\t\t}\n\t\tif (keyH.number - 1 < weapons.size()) {\n\t\t\tcurrentGun = keyH.number - 1;\n\t\t}\n\n\t\tif (keyH.rightPressed == true && keyH.upPressed) {\n\t\t\tdirectionAnim = \"rightUp\";\n\t\t\tdirection = \"rightUp\";\n\t\t} else if (keyH.rightPressed == true && keyH.downPressed) {\n\t\t\tdirectionAnim = \"rightDown\";\n\t\t\tdirection = \"rightDown\";\n\t\t} else if (keyH.leftPressed == true && keyH.upPressed) {\n\t\t\tdirectionAnim = \"leftUp\";\n\t\t\tdirection = \"leftUp\";\n\t\t} else if (keyH.leftPressed == true && keyH.downPressed) {\n\t\t\tdirectionAnim = \"leftDown\";\n\t\t\tdirection = \"leftDown\";\n\t\t} else if (keyH.upPressed == true) {\n\t\t\tdirectionAnim = \"up\";\n\t\t\tdirection = \"up\";\n\t\t} else if (keyH.downPressed == true) {\n\t\t\tdirectionAnim = \"down\";\n\t\t\tdirection = \"down\";\n\t\t} else if (keyH.leftPressed == true) {\n\t\t\tdirection = \"left\";\n\t\t\tif (screenY + (gp.tileSize / 2 * RESIZE) >= keyH.MouseY\n\t\t\t\t\t&& screenX + (gp.tileSize / 2 * RESIZE) >= keyH.MouseX) {\n\t\t\t\tdirectionAnim = \"leftUp\";\n\t\t\t} else {\n\t\t\t\tdirectionAnim = \"leftDown\";\n\t\t\t}\n\t\t} else if (keyH.rightPressed == true) {\n\t\t\tdirection = \"right\";\n\t\t\tif (screenY + (gp.tileSize / 2 * RESIZE) >= keyH.MouseY\n\t\t\t\t\t&& screenX + (gp.tileSize / 2 * RESIZE) <= keyH.MouseX) {\n\t\t\t\tdirectionAnim = \"rightUp\";\n\t\t\t} else {\n\t\t\t\tdirectionAnim = \"rightDown\";\n\t\t\t}\n\t\t}\n\n\t\tcollisionOn = false;\n\t\tcolUp = false;\n\t\tcolRight = false;\n\t\tcolLeft = false;\n\t\tcolDown = false;\n\n\t\tgp.cChecker.checkTile(this);\n\n\t\tif (collisionOn == false && isMoving && !colRight && !colUp && direction.equals(\"rightUp\")) {\n\t\t\tworldX += speed;\n\t\t\tworldY -= speed;\n\t\t}\n\t\tif (collisionOn == false && isMoving && !colRight && !colDown && direction.equals(\"rightDown\")) {\n\t\t\tworldX += speed;\n\t\t\tworldY += speed;\n\t\t}\n\t\tif (collisionOn == false && isMoving && !colLeft && !colDown && direction.equals(\"leftDown\")) {\n\t\t\tworldX -= speed;\n\t\t\tworldY += speed;\n\t\t}\n\t\tif (collisionOn == false && isMoving && !colLeft && !colUp && direction.equals(\"leftUp\")) {\n\t\t\tworldX -= speed;\n\t\t\tworldY -= speed;\n\t\t}\n\t\tif (collisionOn == false && isMoving && !colLeft && direction.equals(\"left\")) {\n\t\t\tworldX -= speed;\n\t\t}\n\t\tif (collisionOn == false && isMoving && !colRight && direction.equals(\"right\")) {\n\t\t\tworldX += speed;\n\t\t}\n\t\tif (collisionOn == false && isMoving && !colUp && direction.equals(\"up\")) {\n\t\t\tworldY -= speed;\n\t\t}\n\t\tif (collisionOn == false && isMoving && !colDown && direction.equals(\"down\")) {\n\t\t\tworldY += speed;\n\t\t}\n\n\t\tif ((keyH.downPressed || keyH.upPressed) && (keyH.leftPressed || keyH.rightPressed)) {\n\t\t\tif (speed == speedT) {\n\t\t\t\tspeedT = speed;\n\t\t\t\tspeed *= Math.sqrt(0.5);\n\t\t\t}\n\t\t} else {\n\t\t\tspeed = speedT;\n\t\t}\n\n\t\tif (!keyH.downPressed && !keyH.upPressed && !keyH.leftPressed && !keyH.rightPressed) {\n\t\t\tisMoving = false;\n\t\t} else {\n\t\t\tisMoving = true;\n\t\t}\n\n\t\tspriteCounter++;\n\t\tif (spriteCounter > 9) {\n\t\t\tif (spriteNum == 6) {\n\t\t\t\tspriteNum = 0;\n\t\t\t} else {\n\t\t\t\tspriteNum++;\n\t\t\t}\n\t\t\tspriteCounter = 0;\n\t\t}\n\t}\n\n\tpublic void draw(Graphics2D g2) {\n\t\tBufferedImage image = null;\n\t\tif (isMoving) {\n\t\t\tswitch (directionAnim) {\n\t\t\t\tcase (\"up\"):\n\t\t\t\t\timage = walkNormal_up[spriteNum];\n\t\t\t\t\tbreak;\n\t\t\t\tcase (\"down\"):\n\t\t\t\t\timage = walkNormal_down[spriteNum];\n\t\t\t\t\tbreak;\n\t\t\t\tcase (\"rightUp\"):\n\t\t\t\t\timage = walkNormal_rightUp[spriteNum];\n\t\t\t\t\tbreak;\n\t\t\t\tcase (\"rightDown\"):\n\t\t\t\t\timage = walkNormal_rightDown[spriteNum];\n\t\t\t\t\tbreak;\n\t\t\t\tcase (\"leftUp\"):\n\t\t\t\t\timage = walkNormal_leftUp[spriteNum];\n\t\t\t\t\tbreak;\n\t\t\t\tcase (\"leftDown\"):\n\t\t\t\t\timage = walkNormal_leftDown[spriteNum];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (screenX + (gp.tileSize / 2 * RESIZE) - 50 <= keyH.MouseX\n\t\t\t\t\t&& screenX + (gp.tileSize / 2 * RESIZE) + 50 >= keyH.MouseX) {\n\t\t\t\tif (screenY + (gp.tileSize / 2 * RESIZE) >= keyH.MouseY) {\n\t\t\t\t\timage = idle_up[spriteNum];\n\t\t\t\t} else {\n\t\t\t\t\timage = idle_down[spriteNum];\n\t\t\t\t}\n\t\t\t} else if (screenX + (gp.tileSize / 2 * RESIZE) >= keyH.MouseX) {\n\t\t\t\tif (screenY + (gp.tileSize / 2 * RESIZE) >= keyH.MouseY) {\n\t\t\t\t\timage = idle_leftUp[spriteNum];\n\t\t\t\t} else {\n\t\t\t\t\timage = idle_leftDown[spriteNum];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (screenY + (gp.tileSize / 2 * RESIZE) >= keyH.MouseY) {\n\t\t\t\t\timage = idle_rightUp[spriteNum];\n\t\t\t\t} else {\n\t\t\t\t\timage = idle_rightDown[spriteNum];\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tg2.drawImage(image, (int) screenX, (int) screenY, gp.tileSize * RESIZE, gp.tileSize * RESIZE, null);\n\t\tg2.setColor(Color.white);\n\t\tg2.setFont(new Font(\"Arial\", Font.BOLD, 20));\n\t\tg2.drawString(\"Gun: \" + weapons.get(currentGun).name, 20, 60);\n\t\tg2.drawString(\"Bullet: \" + weapons.get(currentGun).bulletCount, 20, 90);\n\t\tif (weapons.get(currentGun).name.equals(\"Pistol\")) {\n\t\t\tg2.drawString(\"Magazine: Infinite\", 20, 120);\n\t\t} else {\n\t\t\tg2.drawString(\"Magazine: \" + weapons.get(currentGun).magazinCount, 20, 120);\n\t\t}\n\t\tg2.drawString(\"Points: \" + point, 800, 90);\n\n\t}\n}\n",
      "Asit.java": "import java.awt.Color;\n\npublic class Asit extends Weapon {\n\n\tpublic Asit(GamePanel gp) {\n\t\tsuper(gp);\n\t\tcoolDown = 4000;\n\t\tbulletColor = Color.GREEN;\n\t\tbulletSize = 10;\n\t\tdamage = 10;\n\t}\n\n\t@Override\n\tpublic void shoot(double scX, double scY, double TargetX, double TargetY) {\n\t\tGameManager.Game.projectiles.add(new Projectile(scX, scY, TargetX, TargetY, deviation, bulletSize, bulletColor,\n\t\t\t\t120, \"Asit\", damage, 10));\n\t}\n\n\t@Override\n\tpublic void reload() {\n\t}\n\n}\n",
      "ZombieHealth.java": "import java.awt.Color;\nimport java.awt.Graphics;\n\npublic class ZombieHealth {\n\tpublic int maxHealth;\n\tprivate int currentHealth;\n\tprivate int threshold;\n\tprivate int width = 40;\n\tprivate int height = 6;\n\tprivate int offsetY = -15, offsetX = 15;\n\tZombie zombie;\n\n\tpublic ZombieHealth(int maxHealth, int threshold, Zombie zombie) {\n\t\tthis.maxHealth = maxHealth;\n\t\tthis.currentHealth = maxHealth;\n\t\tthis.threshold = threshold;\n\t\tthis.zombie = zombie;\n\t}\n\n\tpublic void damage(int amount) {\n\t\tcurrentHealth -= amount;\n\t\tif (currentHealth <= 0) {\n\t\t\tGameManager.Game.DeleteZombie(zombie);\n\t\t\tPlayer.player.point += zombie.point;\n\t\t\tGameManager.Game.SpawnItem(zombie.worldX, zombie.worldY);\n\t\t\tfor (Projectile z : GameManager.Game.projectiles) {\n\t\t\t\tif (zombie.Asitli) {\n\t\t\t\t\tfor (Zombie e : GameManager.Game.zombies) {\n\t\t\t\t\t\tif (Collision.checkCollision(z.worldX, z.worldY, e.worldX, e.worldY, 60, 30)) {\n\t\t\t\t\t\t\te.takeDamage(15);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void render(Graphics g, double worldX, double worldY) {\n\t\tif (currentHealth < threshold) {\n\t\t\tdouble screenX = worldX - Player.player.worldX + Player.player.screenX;\n\t\t\tdouble screenY = worldY - Player.player.worldY + Player.player.screenY;\n\n\t\t\tdouble barX = screenX - width / 2 + offsetX;\n\t\t\tdouble barY = screenY + offsetY;\n\n\t\t\tg.setColor(Color.DARK_GRAY);\n\t\t\tg.fillRect((int) barX, (int) barY, width, height);\n\n\t\t\tg.setColor(Color.RED);\n\t\t\tint healthWidth = (int) ((currentHealth / (float) maxHealth) * width);\n\t\t\tg.fillRect((int) barX, (int) barY, healthWidth, height);\n\n\t\t\tg.setColor(Color.BLACK);\n\t\t\tg.drawRect((int) barX, (int) barY, width, height);\n\t\t}\n\t}\n\n\tpublic int getHealth() {\n\t\treturn currentHealth;\n\t}\n}\n"
    },
    {
      "id": "8783086",
      "Game.java": "\nimport GameFiles.GameScreen;\n\nimport javax.swing.JFrame;\n\npublic class Game {\n    public static void main(String[] args) {\n        JFrame window = new JFrame();\n        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        window.setResizable(false);\n        window.setTitle(\"Zombie Shootout!\");\n\n        GameScreen gameScreen = new GameScreen(window);\n        window.add(gameScreen);\n        window.pack();\n        window.setLocationRelativeTo(null);\n        window.setVisible(true);\n        gameScreen.setupGame();\n        gameScreen.startGameThread();\n    }\n\n}\n",
      "Zombie.java": "package Entities;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\n\nimport javax.imageio.ImageIO;\nimport javax.imageio.stream.FileImageInputStream;\n\nimport GameFiles.GameScreen;\n\npublic class Zombie extends Entities {\n    GameScreen gs;\n    public BufferedImage[] walk = new BufferedImage[9];\n    public BufferedImage blood;\n    double degree = 0;\n    public boolean alive = true;\n    public int damage;\n    public int damageCooldown = 0;\n    public static final int DAMAGE_COOLDOWN_FRAMES = 120;\n\n    public Zombie(GameScreen gs) {\n        this.gs = gs;\n        solidArea = new Rectangle();\n        solidArea.x = 0;\n        solidArea.y = 0;\n        solidArea.width = gs.tileSize;\n        solidArea.height = gs.tileSize;\n\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        defaultValues();\n        getImage();\n\n    }\n\n    public void defaultValues() {\n\n        speed = 3;\n        maxLife = 20;\n        life = maxLife;\n        damage = 1;\n    }\n\n    public void getImage() {\n        try {\n            for (int i = 0; i < walk.length; i++) {\n                walk[i] = ImageIO\n                        .read(new FileImageInputStream(\n                                new RandomAccessFile(\n                                        \"Entities\\\\Images\\\\Zombie\\\\skeleton-move_\" + String.valueOf(i) + \".png\",\n                                        \"rw\")));\n\n            }\n            blood = ImageIO\n                    .read(new FileImageInputStream(new RandomAccessFile(\"Entities\\\\Images\\\\Zombie\\\\blood\", \"rw\")));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public void takeDamage(int damage) {\n        life -= damage;\n        addPoints();\n\n        if (life <= 0) {\n            alive = false;\n\n        }\n    }\n\n    public void addPoints() {\n        gs.points += 100;\n    }\n\n    public void doDamage() {\n        double distance = Math.hypot(gs.p1.worldx - worldx, gs.p1.worldy - worldy);\n        if (distance < gs.tileSize && damageCooldown <= 0) {\n            gs.p1.life -= damage;\n            damageCooldown = DAMAGE_COOLDOWN_FRAMES * 5;\n        }\n        if (damageCooldown > 0) {\n            damageCooldown--;\n        }\n    }\n\n    public void update() {\n\n        doDamage();\n        double distance = Math.hypot(gs.p1.worldx - worldx, gs.p1.worldy - worldy);\n\n        walkSpriteCount++;\n        if (walkSpriteCount > 15) {\n            if (spriteNum == 0) {\n                spriteNum = 1;\n            } else if (spriteNum == 1) {\n                spriteNum = 2;\n            } else if (spriteNum == 2) {\n                spriteNum = 3;\n            } else if (spriteNum == 3) {\n                spriteNum = 4;\n            } else if (spriteNum == 4) {\n                spriteNum = 5;\n            } else if (spriteNum == 5) {\n                spriteNum = 6;\n            } else if (spriteNum == 6) {\n                spriteNum = 7;\n            } else if (spriteNum == 7) {\n                spriteNum = 8;\n            } else if (spriteNum == 8) {\n                spriteNum = 0;\n            }\n            walkSpriteCount = 0;\n        }\n        double targetX = gs.p1.worldx;\n        double targetY = gs.p1.worldy;\n\n        double angle = Math.atan2(targetY - worldy, targetX - worldx);\n        degree = Math.toDegrees(angle);\n\n        distance = Math.hypot(targetX - worldx, targetY - worldy);\n        if (distance > 5) {\n            worldx += speed * Math.cos(angle);\n            worldy += speed * Math.sin(angle);\n        }\n\n    }\n\n    public void draw(Graphics2D g2) {\n        BufferedImage image = null;\n        image = walk[spriteNum];\n\n        int screenX = worldx - gs.p1.worldx + gs.p1.screenX;\n        int screenY = worldy - gs.p1.worldy + gs.p1.screenY;\n\n        if (worldx + gs.tileSize > gs.p1.worldx - gs.p1.screenX\n                && worldx - gs.tileSize < gs.p1.worldx + gs.p1.screenX\n                && worldy + gs.tileSize > gs.p1.worldy - gs.p1.screenY\n                && worldy - gs.tileSize < gs.p1.worldy + gs.p1.screenY) {\n\n            g2.rotate(Math.toRadians(degree), screenX + gs.tileSize / 2, screenY +\n                    gs.tileSize / 2);\n            g2.drawImage(image, screenX, screenY, gs.tileSize, gs.tileSize, null);\n            g2.rotate(-Math.toRadians(degree), screenX + gs.tileSize / 2, screenY +\n                    gs.tileSize / 2);\n        }\n\n    }\n\n}\n",
      "CrawlingZombie.java": "package Entities;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport javax.imageio.ImageIO;\nimport javax.imageio.stream.FileImageInputStream;\nimport GameFiles.GameScreen;\n\npublic class CrawlingZombie extends Zombie {\n    private boolean isJumping = false;\n    private int jumpCooldown = 0;\n\n    public CrawlingZombie(GameScreen gs) {\n        super(gs);\n    }\n\n    @Override\n    public void defaultValues() {\n        speed = 5; // Fast\n        maxLife = 10; // Low health\n        life = maxLife;\n        damage = 2; // Medium damage\n    }\n\n    public void addPoints() {\n        gs.points += 200;\n    }\n\n    @Override\n    public void getImage() {\n        try {\n            for (int i = 0; i < walk.length; i++) {\n                walk[i] = ImageIO.read(new FileImageInputStream(\n                        new RandomAccessFile(\n                                \"Entities\\\\Images\\\\Zombie\\\\CrawlingZombie\\\\walk_00\" + String.valueOf(i) + \".png\",\n                                \"rw\")));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void update() {\n        super.update(); // Standard movement\n        double distance = Math.hypot(gs.p1.worldx - worldx, gs.p1.worldy - worldy);\n\n        // Jump when close to player\n        if (distance < gs.tileSize * 2 && jumpCooldown <= 0) {\n            worldx += Math.cos(degree) * gs.scale * 6;\n            worldy += Math.sin(degree) * gs.scale * 6;\n            isJumping = true;\n            jumpCooldown = 120 * 10;\n\n        }\n\n        if (jumpCooldown > 0)\n            jumpCooldown--;\n    }\n\n}",
      "AcidZombie.java": "package Entities;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport javax.imageio.ImageIO;\nimport javax.imageio.stream.FileImageInputStream;\nimport GameFiles.GameScreen;\n\npublic class AcidZombie extends Zombie {\n    private int spitCooldown = 0;\n\n    public AcidZombie(GameScreen gs) {\n        super(gs);\n    }\n\n    @Override\n    public void defaultValues() {\n        speed = 2;\n        maxLife = 15;\n        life = maxLife;\n        damage = 0;\n    }\n\n    public void addPoints() {\n        gs.points += 300;\n    }\n\n    @Override\n    public void getImage() {\n        try {\n            for (int i = 0; i < walk.length; i++) {\n                walk[i] = ImageIO.read(new FileImageInputStream(\n                        new RandomAccessFile(\n                                \"Entities\\\\Images\\\\Zombie\\\\AcidZombie\\\\walk_00\" + String.valueOf(i) + \".png\",\n                                \"rw\")));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void update() {\n        super.update();\n        double distance = Math.hypot(gs.p1.worldx - worldx, gs.p1.worldy - worldy);\n\n        if (distance < gs.tileSize * 2 && spitCooldown <= 0) {\n            spitAcid();\n            spitCooldown = 120 * 5;\n        }\n\n        if (spitCooldown > 0)\n            spitCooldown--;\n    }\n\n    private void spitAcid() {\n        gs.p1.life -= 2;\n\n    }\n\n    @Override\n    public void takeDamage(int damage) {\n        super.takeDamage(damage);\n        if (!alive) {\n            // Damage nearby entities on death\n            for (Zombie zombie : gs.zombies[gs.currentWave]) {\n                if (zombie.worldx - worldx > 0\n                        && Math.hypot(zombie.worldx - worldx, zombie.worldy - worldy) < gs.tileSize\n                                * 2) {\n                    zombie.takeDamage(10);\n                }\n            }\n            if (Math.hypot(gs.p1.worldx - worldx, gs.p1.worldy - worldy) < gs.tileSize) {\n                gs.p1.life -= 2;\n            }\n        }\n    }\n}",
      "Entities.java": "package Entities;\n\nimport java.awt.Rectangle;\n\npublic class Entities {\n    public int worldx, worldy, speed;\n\n    public String direction;\n    public int walkSpriteCount = 0;\n    public int reloadSpriteCount = 0;\n    public int reloadSpriteNum = 1;\n    public int spriteNum = 1;\n    public Rectangle solidArea;\n    public int solidAreaDefaultX, solidAreaDefaultY;\n    public boolean collisionOn = false;\n\n    public int maxLife;\n    public int life;\n}\n",
      "TankZombie.java": "package Entities;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport javax.imageio.ImageIO;\nimport javax.imageio.stream.FileImageInputStream;\nimport GameFiles.GameScreen;\n\npublic class TankZombie extends Zombie {\n    public TankZombie(GameScreen gs) {\n        super(gs);\n    }\n\n    @Override\n    public void defaultValues() {\n        speed = 2; // Very slow\n        maxLife = 200; // High health\n        life = maxLife;\n        damage = 10; // High damage\n    }\n\n    public void doDamage() {\n        double distance = Math.hypot(gs.p1.worldx - worldx, gs.p1.worldy - worldy);\n        if (distance < gs.tileSize && damageCooldown <= 0) {\n            gs.p1.life -= damage;\n            damageCooldown = DAMAGE_COOLDOWN_FRAMES * 10;\n\n        }\n        if (damageCooldown > 0) {\n            damageCooldown--;\n        }\n    }\n\n    public void addPoints() {\n        gs.points += 500;\n    }\n\n    @Override\n    public void getImage() {\n        try {\n            for (int i = 0; i < walk.length; i++) {\n                walk[i] = ImageIO.read(new FileImageInputStream(\n                        new RandomAccessFile(\n                                \"Entities\\\\Images\\\\Zombie\\\\TankZombie\\\\walk_00\" + String.valueOf(i) + \".png\",\n                                \"rw\")));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "Player.java": "package Entities;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport java.io.RandomAccessFile;\nimport java.util.ArrayList;\nimport java.awt.Rectangle;\n\nimport javax.imageio.ImageIO;\n\nimport javax.imageio.stream.FileImageInputStream;\n\nimport GameFiles.GameScreen;\nimport GameFiles.KeyBindings;\nimport GameFiles.Mouse;\nimport Objects.AssaultRifle;\nimport Objects.Bullet;\nimport Objects.Pistol;\nimport Objects.RocketLauncher;\nimport Objects.Shotgun;\nimport Objects.SniperRifle;\nimport Objects.Weapon;\n\npublic class Player extends Entities {\n    GameScreen gs;\n    KeyBindings keys;\n    Mouse mouse;\n\n    public final int screenX;\n    public final int screenY;\n    public int medKitNum = 0;\n\n    public int energyDrinkNum = 0;\n    public double degree;\n    public double mouseX;\n    public double mouseY;\n    public boolean walk = false;\n\n    private Weapon[] weapons = new Weapon[5];\n    public ArrayList<Bullet> bullets = new ArrayList<>();\n    public Weapon currentWeapon;\n    public int currentWeaponIndex = 0;\n\n    public BufferedImage[] walkWithPistol = new BufferedImage[19];\n    public BufferedImage[] walkWithRifle = new BufferedImage[19];\n    public BufferedImage[] walkWithShotgun = new BufferedImage[19];\n\n    public Player(GameScreen gs, KeyBindings keys, Mouse mouse) {\n        this.gs = gs;\n        this.keys = keys;\n        this.mouse = mouse;\n\n        screenX = gs.screenWidht / 2 - (gs.tileSize / 2);\n        screenY = gs.screenHeight / 2 - (gs.tileSize / 2);\n        solidArea = new Rectangle();\n        solidArea.x = 29;\n        solidArea.y = 40;\n        solidArea.width = 40;\n        solidArea.height = 40;\n\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        defaultValues();\n        getImage();\n\n        weapons[0] = new Pistol();\n        weapons[1] = new AssaultRifle();\n        weapons[2] = new Shotgun();\n        weapons[3] = new SniperRifle();\n        weapons[4] = new RocketLauncher();\n\n        currentWeapon = weapons[0]; // Start with pistol\n\n    }\n\n    public void defaultValues() {\n        worldx = gs.tileSize * 23;\n        worldy = gs.tileSize * 21;\n        speed = 10;\n        direction = \"down\";\n        maxLife = 20;\n        life = maxLife;\n    }\n\n    public void getImage() {\n        try {\n            for (int i = 0; i < walkWithPistol.length; i++) {\n                walkWithPistol[i] = ImageIO\n                        .read(new FileImageInputStream(\n                                new RandomAccessFile(\"Entities\\\\Images\\\\Character\\\\\" + String.valueOf(i) + \".png\",\n                                        \"rw\")));\n                walkWithRifle[i] = ImageIO.read(new FileImageInputStream(new RandomAccessFile(\n                        \"Entities\\\\Images\\\\Character\\\\rifle\\\\move\\\\survivor-move_rifle_\" + String.valueOf(i) + \".png\",\n                        \"rw\")));\n                walkWithShotgun[i] = ImageIO.read(new FileImageInputStream(new RandomAccessFile(\n                        \"Entities\\\\Images\\\\Character\\\\shotgun\\\\move\\\\survivor-move_shotgun_\" + String.valueOf(i)\n                                + \".png\",\n                        \"rw\")));\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public void update() {\n        if (life <= 0) {\n            gs.gameState = gs.gameoverState;\n        }\n        collisionOn = false;\n        gs.colCheck.checkTile(this);\n        int objIndex = gs.colCheck.checkObject(this, true);\n\n        currentWeapon = weapons[currentWeaponIndex];\n        pickUpObject(objIndex);\n        if (keys.up == true || keys.down == true || keys.left == true || keys.right == true) {\n            if (keys.up == true) {\n                direction = \"up\";\n                walk = true;\n                // worldy -= speed;\n            }\n            if (keys.left == true) {\n                direction = \"left\";\n                walk = true;\n                // worldx -= speed;\n            }\n            if (keys.right == true) {\n                direction = \"right\";\n                walk = true;\n                // worldx += speed;\n            }\n            if (keys.down == true) {\n                direction = \"down\";\n                walk = true;\n                // worldy += speed;\n            }\n            if (keys.up == true && keys.right == true) {\n                direction = \"topright\";\n                walk = true;\n            }\n            if (keys.up == true && keys.left == true) {\n                direction = \"topleft\";\n                walk = true;\n            }\n            if (keys.down == true && keys.right == true) {\n                direction = \"bottomright\";\n                walk = true;\n\n            }\n            if (keys.down == true && keys.left == true) {\n                direction = \"bottomleft\";\n                walk = true;\n            }\n\n            walkSpriteCount++;\n            if (walkSpriteCount > 4) {\n                if (spriteNum == 0) {\n                    spriteNum = 1;\n                } else if (spriteNum == 1) {\n                    spriteNum = 2;\n                } else if (spriteNum == 2) {\n                    spriteNum = 3;\n                } else if (spriteNum == 3) {\n                    spriteNum = 4;\n                } else if (spriteNum == 4) {\n                    spriteNum = 5;\n                } else if (spriteNum == 5) {\n                    spriteNum = 6;\n                } else if (spriteNum == 6) {\n                    spriteNum = 7;\n                } else if (spriteNum == 7) {\n                    spriteNum = 8;\n                } else if (spriteNum == 8) {\n                    spriteNum = 9;\n                } else if (spriteNum == 9) {\n                    spriteNum = 10;\n                } else if (spriteNum == 10) {\n                    spriteNum = 11;\n                } else if (spriteNum == 11) {\n                    spriteNum = 12;\n                } else if (spriteNum == 12) {\n                    spriteNum = 13;\n                } else if (spriteNum == 13) {\n                    spriteNum = 14;\n                } else if (spriteNum == 14) {\n                    spriteNum = 15;\n                } else if (spriteNum == 15) {\n                    spriteNum = 16;\n                } else if (spriteNum == 16) {\n                    spriteNum = 17;\n                } else if (spriteNum == 17) {\n                    spriteNum = 18;\n                } else if (spriteNum == 18) {\n                    spriteNum = 1;\n                }\n\n                walkSpriteCount = 0;\n            }\n\n            if (collisionOn == false) {\n                switch (direction) {\n                    case \"up\":\n                        worldy -= speed;\n                        break;\n                    case \"down\":\n                        worldy += speed;\n                        break;\n                    case \"left\":\n                        worldx -= speed;\n                        break;\n                    case \"right\":\n                        worldx += speed;\n                        break;\n                    case \"topright\":\n                        worldy -= speed;\n                        worldx += speed;\n                        break;\n                    case \"topleft\":\n                        worldy -= speed;\n                        worldx -= speed;\n                        break;\n                    case \"bottomright\":\n                        worldy += speed;\n                        worldx += speed;\n                        break;\n                    case \"bottomleft\":\n                        worldy += speed;\n                        worldx -= speed;\n                        break;\n                }\n            }\n        } else {\n            walk = false;\n        }\n        mouseX = mouse.mouseX;\n        mouseY = mouse.mouseY;\n        if (mouse.mouseEntered == true)\n\n        {\n            degree = Math.toDegrees(\n                    Math.atan2((mouseY - (screenY + (gs.tileSize - gs.originalTileSize * 3))),\n                            (mouseX - (screenX + (gs.tileSize - gs.originalTileSize * 3)))));\n        }\n\n        shoot();\n\n        System.out.println(keys.reload);\n    }\n\n    public void shoot() {\n        if (mouse.mousePressed == true) {\n\n            double radians = Math.toRadians(degree + gs.scale * 3);\n\n            // Calculate gun position offset\n            int offsetX = (int) (Math.cos(radians) * gs.scale * 10);\n            int offsetY = (int) (Math.sin(radians) * gs.scale * 10);\n\n            // Calculate actual bullet spawn position\n            int gunX = worldx + gs.tileSize / 2 + offsetX;\n            int gunY = worldy + gs.tileSize / 2 + offsetY;\n            double angle = Math.atan2(\n                    mouseY - (screenY + gs.tileSize / 2),\n                    mouseX - (screenX + gs.tileSize / 2));\n\n            Bullet[] bullets = currentWeapon.shoot(gs, gunX, gunY, angle);\n            for (Bullet bullet : bullets) {\n                this.bullets.add(bullet);\n            }\n        }\n    }\n\n    public void pickUpObject(int i) {\n        if (i != 999 && keys.key_e == true) {\n            String objectName = gs.obj[i].name;\n            switch (objectName) {\n                case \"MedKit\":\n                    medKitNum++;\n                    gs.obj[i] = null;\n                    break;\n                case \"EnergyDrink\":\n                    energyDrinkNum++;\n                    gs.obj[i] = null;\n                    break;\n\n            }\n\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        BufferedImage image = null;\n\n        switch (currentWeaponIndex) {\n            case 0:\n                image = walkWithPistol[0];\n                break;\n            case 1:\n                image = walkWithRifle[0];\n                break;\n            case 2:\n                image = walkWithShotgun[0];\n                break;\n            case 3:\n                image = walkWithShotgun[0];\n            case 4:\n                image = walkWithShotgun[0];\n        }\n\n        if (keys.up == true || keys.down == true || keys.left == true || keys.right == true) {\n\n            switch (currentWeaponIndex) {\n                case 0:\n                    image = walkWithPistol[spriteNum];\n                    break;\n                case 1:\n                    image = walkWithRifle[spriteNum];\n                    break;\n                case 2:\n                    image = walkWithShotgun[spriteNum];\n                    break;\n                case 3:\n                    image = walkWithShotgun[spriteNum];\n                    break;\n                case 4:\n                    image = walkWithShotgun[spriteNum];\n                    break;\n            }\n\n        }\n\n        g2.rotate(Math.toRadians(degree), screenX + gs.tileSize / 2, screenY + gs.tileSize / 2);\n        g2.drawImage(image, screenX, screenY, gs.tileSize, gs.tileSize, null);\n        g2.rotate(-Math.toRadians(degree), screenX + gs.tileSize / 2, screenY +\n                gs.tileSize / 2);\n\n    }\n\n}\n",
      "DataStorage.java": "package Data;\n\nimport java.io.Serializable;\n\npublic class DataStorage implements Serializable {\n\n    int points;\n    int maxLife;\n    int life;\n    int currentWave;\n    int medKitNum;\n    int energyDrinkNum;\n\n}",
      "SaveLoad.java": "package Data;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport GameFiles.GameScreen;\n\npublic class SaveLoad {\n\n    GameScreen gs;\n\n    public SaveLoad(GameScreen gs) {\n        this.gs = gs;\n    }\n\n    public void save() {\n        try {\n            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(\"Data\\\\save.dat\")));\n            DataStorage ds = new DataStorage();\n            ds.life = gs.p1.life;\n            ds.maxLife = gs.p1.maxLife;\n            ds.currentWave = gs.currentWave;\n            ds.energyDrinkNum = gs.p1.energyDrinkNum;\n            ds.medKitNum = gs.p1.medKitNum;\n            ds.points = gs.points;\n            oos.writeObject(ds);\n\n            oos.close();\n\n        } catch (Exception e) {\n            System.out.println(\"\");\n\n        }\n\n    }\n\n    public void load() {\n        try {\n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\"Data\\\\save.dat\")));\n\n            DataStorage ds = (DataStorage) ois.readObject();\n            gs.p1.life = ds.life;\n            gs.p1.maxLife = ds.maxLife;\n            gs.currentWave = ds.currentWave;\n            gs.points = ds.points;\n            gs.p1.medKitNum = ds.medKitNum;\n            gs.p1.energyDrinkNum = ds.energyDrinkNum;\n\n            ois.close();\n        } catch (Exception e) {\n\n        }\n    }\n}\n",
      "Weapon.java": "package Objects;\n\nimport GameFiles.GameScreen;\n\npublic abstract class Weapon {\n    protected int magazineSize;\n    protected int currentAmmo;\n    protected int fireRate;\n    protected int spreadAngle;\n    protected int projectilesPerShot;\n    protected int unlockWave;\n    protected long lastShotTime;\n    protected String name;\n\n    public Weapon(int magazineSize, int fireRate, int spreadAngle,\n            int projectilesPerShot, int unlockWave, String name) {\n        this.magazineSize = magazineSize;\n        this.currentAmmo = magazineSize;\n        this.fireRate = fireRate;\n        this.spreadAngle = spreadAngle;\n        this.projectilesPerShot = projectilesPerShot;\n        this.unlockWave = unlockWave;\n        this.name = name;\n    }\n\n    public abstract Bullet[] shoot(GameScreen gs, int x, int y, double angle);\n\n    public boolean canShoot() {\n        long currentTime = System.currentTimeMillis();\n        return currentAmmo > 0 &&\n                (currentTime - lastShotTime) >= (60000 / fireRate);\n    }\n\n    public void reload() {\n        currentAmmo = magazineSize;\n    }\n\n    public int getCurrentAmmo() {\n        return currentAmmo;\n    }\n\n    public int getMagazineSize() {\n        return magazineSize;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getUnlockWave() {\n        return unlockWave;\n    }\n}",
      "Bullet.java": "package Objects;\n\nimport java.awt.Graphics2D;\nimport java.awt.Color;\nimport GameFiles.GameScreen;\n\npublic class Bullet {\n    public int x, y;\n    public double dx, dy;\n    public int speed;\n    public boolean active;\n    public int damage;\n    public int penetration;\n    public boolean explosive;\n    public int explosionRadius;\n    public GameScreen gs;\n\n    public Bullet(GameScreen gs, int startX, int startY, double angle,\n            int speed, int damage, int penetration, boolean explosive) {\n        this.gs = gs;\n        this.x = startX;\n        this.y = startY;\n        this.speed = speed;\n        this.damage = damage;\n        this.penetration = penetration;\n        this.explosive = explosive;\n        this.explosionRadius = explosive ? gs.tileSize * 4 : 0;\n        this.dx = Math.cos(angle);\n        this.dy = Math.sin(angle);\n        this.active = true;\n    }\n\n    public void update() {\n        x += dx * speed;\n        y += dy * speed;\n\n        if (x < 0 || x > gs.worldWidht || y < 0 || y > gs.worldHeight) {\n            active = false;\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        if (explosive) {\n            g2.setColor(Color.ORANGE);\n            g2.fillOval(\n                    gs.p1.screenX + x - gs.p1.worldx - 6,\n                    gs.p1.screenY + y - gs.p1.worldy - 6,\n                    12,\n                    12);\n        } else {\n            g2.setColor(Color.YELLOW);\n            g2.fillOval(\n                    gs.p1.screenX + x - gs.p1.worldx - 3,\n                    gs.p1.screenY + y - gs.p1.worldy - 3,\n                    6,\n                    6);\n        }\n    }\n}",
      "Shotgun.java": "package Objects;\n\nimport GameFiles.GameScreen;\n\npublic class Shotgun extends Weapon {\n    public Shotgun() {\n        super(5, 60, 45, 9, 3, \"Shotgun\");\n    }\n\n    @Override\n    public Bullet[] shoot(GameScreen gs, int x, int y, double angle) {\n        if (!canShoot())\n            return new Bullet[0];\n\n        lastShotTime = System.currentTimeMillis();\n        currentAmmo--;\n\n        Bullet[] pellets = new Bullet[projectilesPerShot];\n        double angleStep = Math.toRadians(spreadAngle) / (projectilesPerShot - 1);\n        double startAngle = angle - Math.toRadians(spreadAngle) / 2;\n\n        for (int i = 0; i < projectilesPerShot; i++) {\n            double pelletAngle = startAngle + (i * angleStep);\n            pellets[i] = new Bullet(gs, x, y, pelletAngle, 12, 5, 0, false);\n        }\n\n        return pellets;\n    }\n}\n",
      "SuperObject.java": "package Objects;\n\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\nimport GameFiles.GameScreen;\n\npublic class SuperObject {\n    public boolean collision = false;\n    public String name;\n    public int worldX, worldY;\n    public BufferedImage image, image1, image2;\n    public Rectangle solidArea;\n\n    public int solidAreaDefaultX = 0;\n    public int solidAreaDefaultY = 0;\n\n    public void draw(Graphics2D g2, GameScreen gs) {\n        int screenX = worldX - gs.p1.worldx + gs.p1.screenX;\n        int screenY = worldY - gs.p1.worldy + gs.p1.screenY;\n\n        if (worldX + gs.tileSize > gs.p1.worldx - gs.p1.screenX\n                && worldX - gs.tileSize < gs.p1.worldx + gs.p1.screenX\n                && worldY + gs.tileSize > gs.p1.worldy - gs.p1.screenY\n                && worldY - gs.tileSize < gs.p1.worldy + gs.p1.screenY) {\n            g2.drawImage(image, screenX, screenY, gs.tileSize, gs.tileSize, null);\n        }\n    }\n}\n",
      "Obj_MedKit.java": "package Objects;\n\nimport java.awt.Rectangle;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\n\nimport javax.imageio.ImageIO;\nimport javax.imageio.stream.FileImageInputStream;\n\npublic class Obj_MedKit extends SuperObject {\n\n    public Obj_MedKit() {\n        name = \"MedKit\";\n\n        solidArea = new Rectangle(0, 0, 112, 112);\n\n        try {\n            image = ImageIO\n                    .read(new FileImageInputStream(\n                            new RandomAccessFile(\"Objects\\\\Images\\\\Medkit.png\",\n                                    \"rw\")));\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n}",
      "SniperRifle.java": "package Objects;\n\nimport GameFiles.GameScreen;\n\npublic class SniperRifle extends Weapon {\n    public SniperRifle() {\n        super(5, 30, 0, 1, 5, \"Sniper Rifle\");\n    }\n\n    @Override\n    public Bullet[] shoot(GameScreen gs, int x, int y, double angle) {\n        if (!canShoot())\n            return new Bullet[0];\n\n        lastShotTime = System.currentTimeMillis();\n        currentAmmo--;\n\n        return new Bullet[] {\n                new Bullet(gs, x, y, angle, 30, 25, 3, false) // Penetrates 3 zombies\n        };\n    }\n}\n",
      "Pistol.java": "package Objects;\n\nimport GameFiles.GameScreen;\n\npublic class Pistol extends Weapon {\n    public Pistol() {\n        super(12, 120, 0, 1, 0, \"Pistol\");\n    }\n\n    @Override\n    public Bullet[] shoot(GameScreen gs, int x, int y, double angle) {\n        if (!canShoot())\n            return new Bullet[0];\n\n        lastShotTime = System.currentTimeMillis();\n        currentAmmo--;\n\n        return new Bullet[] {\n                new Bullet(gs, x, y, angle, 15, 10, 0, false)\n        };\n    }\n}",
      "Obj_Heart.java": "package Objects;\n\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.awt.Rectangle;\n\nimport javax.imageio.ImageIO;\nimport javax.imageio.stream.FileImageInputStream;\n\nimport GameFiles.GameScreen;\n\npublic class Obj_Heart extends SuperObject {\n    public Obj_Heart(GameScreen gs) {\n        name = \"Heart\";\n\n        solidArea = new Rectangle(0, 0, 112, 112);\n\n        try {\n            image = ImageIO\n                    .read(new FileImageInputStream(new RandomAccessFile(\"Objects\\\\Images\\\\heart_full.png\", \"rw\")));\n            image1 = ImageIO\n                    .read(new FileImageInputStream(new RandomAccessFile(\"Objects\\\\Images\\\\heart_half.png\", \"rw\")));\n            image2 = ImageIO\n                    .read(new FileImageInputStream(new RandomAccessFile(\"Objects\\\\Images\\\\heart_blank.png\", \"rw\")));\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n}",
      "AssaultRifle.java": "package Objects;\n\nimport GameFiles.GameScreen;\n\npublic class AssaultRifle extends Weapon {\n    public AssaultRifle() {\n        super(30, 600, 30, 1, 1, \"Assault Rifle\");\n    }\n\n    @Override\n    public Bullet[] shoot(GameScreen gs, int x, int y, double angle) {\n        if (!canShoot())\n            return new Bullet[0];\n\n        lastShotTime = System.currentTimeMillis();\n        currentAmmo--;\n\n        double spread = Math.toRadians((Math.random() * spreadAngle) - (spreadAngle / 2.0));\n        double spreadAngle = angle + spread;\n\n        return new Bullet[] {\n                new Bullet(gs, x, y, spreadAngle, 20, 8, 0, false)\n        };\n    }\n}\n",
      "Obj_EnergyDrink.java": "package Objects;\n\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.awt.Rectangle;\n\nimport javax.imageio.ImageIO;\nimport javax.imageio.stream.FileImageInputStream;\n\npublic class Obj_EnergyDrink extends SuperObject {\n    public Obj_EnergyDrink() {\n        name = \"EnergyDrink\";\n\n        solidArea = new Rectangle(0, 0, 112, 112);\n\n        try {\n            image = ImageIO\n                    .read(new FileImageInputStream(\n                            new RandomAccessFile(\"Objects\\\\Images\\\\EnergyDrink.png\",\n                                    \"rw\")));\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n",
      "RocketLauncher.java": "package Objects;\n\nimport GameFiles.GameScreen;\n\npublic class RocketLauncher extends Weapon {\n    public RocketLauncher() {\n        super(1, 10, 0, 1, 10, \"Rocket Launcher\");\n    }\n\n    @Override\n    public Bullet[] shoot(GameScreen gs, int x, int y, double angle) {\n        if (!canShoot())\n            return new Bullet[0];\n\n        lastShotTime = System.currentTimeMillis();\n        currentAmmo--;\n\n        return new Bullet[] {\n                new Bullet(gs, x, y, angle, 8, 50, 0, true) // Explosive rocket\n        };\n    }\n}\n",
      "GameScreen.java": "package GameFiles;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport Entities.Player;\nimport Entities.Zombie;\nimport Map.TileManager;\nimport Objects.Bullet;\nimport Objects.SuperObject;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.plaf.DimensionUIResource;\n\nimport Data.SaveLoad;\n\npublic class GameScreen extends JPanel implements Runnable {\n    final public int originalTileSize = 16;\n    public final int scale = 7;\n\n    public int screenLocX;\n    public int screenLocY;\n\n    final public int tileSize = originalTileSize * scale;\n    final public int screenColumn = 17;\n    final public int screenRow = 10;\n    final public int screenWidht = tileSize * screenColumn;\n    final public int screenHeight = tileSize * screenRow;\n\n    public final int maxWorldCol = 64;\n    public final int maxWorldRow = 64;\n    public final int worldWidht = tileSize * maxWorldCol;\n    public final int worldHeight = tileSize * maxWorldRow;\n    int FPS = 120;\n    public TileManager Tm = new TileManager(this);\n    KeyBindings keys = new KeyBindings(this);\n    public UI ui = new UI(this);\n    Mouse mouse = new Mouse();\n    public CollisionChecher colCheck = new CollisionChecher(this);\n    public Player p1 = new Player(this, keys, mouse);\n    public Zombie[][] zombies = new Zombie[5][15];\n    public SuperObject obj[] = new SuperObject[10];\n    public ItemSetter IS = new ItemSetter(this);\n    public SaveLoad saveLoad = new SaveLoad(this);\n    public int points = 0;\n\n    public int gameState;\n    public int titleState = 2;\n    public int playState = 1;\n    public int pauseState = 0;\n    public int gameoverState = 4;\n    public int endGameState = 5;\n    public int waveState = 3;\n    public int currentWave = 0;\n    public boolean stillalive = false;\n\n    Thread gameThread;\n\n    public GameScreen(JFrame window) {\n        this.setPreferredSize(new DimensionUIResource(screenWidht, screenHeight));\n        this.setBackground(Color.black);\n        this.addKeyListener(keys);\n        this.addMouseListener(mouse);\n        this.addMouseMotionListener(mouse);\n        this.setFocusable(true);\n        screenLocX = (int) window.getLocation().getX();\n        screenLocY = (int) window.getLocation().getY();\n\n    }\n\n    public void setupGame() {\n        IS.setObject();\n        IS.setZombies();\n        gameState = titleState;\n    }\n\n    public void startGameThread() {\n        gameThread = new Thread(this);\n        gameThread.start();\n    }\n\n    public void run() {\n        double drawInterval = 1000000000 / FPS;\n        double delta = 0;\n        long lastTime = System.nanoTime();\n        long currentTime;\n        while (gameThread != null) {\n            currentTime = System.nanoTime();\n            delta += (currentTime - lastTime) / drawInterval;\n            lastTime = currentTime;\n            if (delta >= 1) {\n                update();\n                repaint();\n                delta--;\n            }\n        }\n    }\n\n    public void update() {\n\n        if (gameState == playState) {\n            p1.update();\n            for (int i = 0; i < zombies[currentWave].length; i++) {\n                if (zombies[currentWave][i].alive == true) {\n                    zombies[currentWave][i].update();\n                }\n\n            }\n            for (int i = p1.bullets.size() - 1; i >= 0; i--) {\n                Bullet bullet = p1.bullets.get(i);\n                bullet.update();\n                if (!bullet.active) {\n                    p1.bullets.remove(i);\n                }\n            }\n            stillalive = false;\n            for (int i = 0; i < zombies[currentWave].length; i++) {\n                if (zombies[currentWave][i] != null && zombies[currentWave][i].alive) {\n                    stillalive = true;\n                }\n            }\n            if (stillalive == false) {\n                if (currentWave < 4) {\n                    gameState = waveState;\n                }\n                if (currentWave == 4) {\n                    gameState = endGameState;\n                }\n\n            }\n\n            for (int i = p1.bullets.size() - 1; i >= 0; i--) {\n                Bullet bullet = p1.bullets.get(i);\n                if (bullet.active) {\n                    for (int j = 0; j < zombies[currentWave].length; j++) {\n\n                        if (zombies[currentWave][j] != null && zombies[currentWave][j].alive) {\n\n                            Rectangle bulletRect = new Rectangle(bullet.x, bullet.y, 6, 6);\n                            Rectangle zombieRect = new Rectangle(\n                                    zombies[currentWave][j].worldx + zombies[currentWave][j].solidArea.x,\n                                    zombies[currentWave][j].worldy + zombies[currentWave][j].solidArea.y,\n                                    zombies[currentWave][j].solidArea.width,\n                                    zombies[currentWave][j].solidArea.height);\n\n                            if (bulletRect.intersects(zombieRect)) {\n                                if (bullet.explosive == true) {\n                                    for (int k = 0; k < zombies[currentWave].length; k++) {\n                                        double distance = Math.hypot(\n                                                zombies[currentWave][j].worldx + zombies[currentWave][j].solidArea.x -\n                                                        zombies[currentWave][k].worldx\n                                                        + zombies[currentWave][k].solidArea.x,\n                                                zombies[currentWave][j].worldy + zombies[currentWave][j].solidArea.y -\n                                                        zombies[currentWave][k].worldy\n                                                        + zombies[currentWave][k].solidArea.y);\n                                        if (distance <= bullet.explosionRadius) {\n                                            zombies[currentWave][k].takeDamage(bullet.damage);\n                                        }\n                                    }\n                                }\n                                zombies[currentWave][j].takeDamage(bullet.damage);\n\n                                bullet.penetration--;\n                                if (bullet.penetration <= 0) {\n                                    bullet.active = false;\n                                }\n\n                                if (!bullet.active) {\n                                    p1.bullets.remove(i);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n\n            }\n\n        } else if (gameState == pauseState) {\n\n        }\n\n    }\n\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2 = (Graphics2D) g;\n\n        if (gameState == titleState) {\n            ui.draw(g2);\n        } else {\n            Tm.draw(g2);\n\n            for (int i = 0; i < obj.length; i++) {\n                if (obj[i] != null) {\n                    obj[i].draw(g2, this);\n                }\n            }\n\n            p1.draw(g2);\n            for (int i = 0; i < zombies[currentWave].length; i++) {\n                if (zombies[currentWave][i].alive) {\n                    zombies[currentWave][i].draw(g2);\n                }\n\n            }\n            ui.draw(g2);\n\n            // In GameScreen.java paintComponent()\n            // Draw bullets\n            for (Bullet bullet : p1.bullets) {\n                bullet.draw(g2);\n            }\n        }\n\n        g2.dispose();\n\n    }\n}\n",
      "ItemSetter.java": "package GameFiles;\n\nimport java.util.Random;\n\nimport Entities.AcidZombie;\nimport Entities.CrawlingZombie;\nimport Entities.TankZombie;\nimport Entities.Zombie;\nimport Objects.Obj_EnergyDrink;\nimport Objects.Obj_MedKit;\n\npublic class ItemSetter {\n\n    GameScreen gs;\n\n    public ItemSetter(GameScreen gs) {\n        this.gs = gs;\n    }\n\n    public void setObject() {\n        Random random = new Random();\n        gs.obj[0] = new Obj_MedKit();\n        gs.obj[0].worldX = random.nextInt(50) * gs.tileSize;\n        gs.obj[0].worldY = random.nextInt(50) * gs.tileSize;\n        gs.obj[1] = new Obj_MedKit();\n        gs.obj[1].worldX = random.nextInt(50) * gs.tileSize;\n        gs.obj[1].worldY = random.nextInt(50) * gs.tileSize;\n        gs.obj[2] = new Obj_MedKit();\n        gs.obj[2].worldX = random.nextInt(50) * gs.tileSize;\n        gs.obj[2].worldY = random.nextInt(50) * gs.tileSize;\n        gs.obj[3] = new Obj_MedKit();\n        gs.obj[3].worldX = random.nextInt(50) * gs.tileSize;\n        gs.obj[3].worldY = random.nextInt(50) * gs.tileSize;\n        gs.obj[4] = new Obj_EnergyDrink();\n        gs.obj[4].worldX = random.nextInt(50) * gs.tileSize;\n        gs.obj[4].worldY = random.nextInt(50) * gs.tileSize;\n        gs.obj[5] = new Obj_EnergyDrink();\n        gs.obj[5].worldX = random.nextInt(50) * gs.tileSize;\n        gs.obj[5].worldY = random.nextInt(50) * gs.tileSize;\n\n    }\n\n    public void setZombies() {\n        Random random = new Random();\n        random.nextInt(13);\n\n        // gs.zombies[0][1] = new CrawlingZombie(gs);\n        // gs.zombies[0][1].worldx = gs.tileSize * (random.nextInt(50));\n        // gs.zombies[0][1].worldy = gs.tileSize * (random.nextInt(50));\n        // gs.zombies[0][2] = new CrawlingZombie(gs);\n        // gs.zombies[0][2].worldx = gs.tileSize * (random.nextInt(50));\n        // gs.zombies[0][2].worldy = gs.tileSize * (random.nextInt(50));\n        // gs.zombies[0][0] = new TankZombie(gs);\n        // gs.zombies[0][0].worldx = gs.tileSize * (random.nextInt(50));\n        // gs.zombies[0][0].worldy = gs.tileSize * (random.nextInt(50));\n\n        for (int i = 0; i < gs.zombies[0].length; i++) {\n            gs.zombies[0][i] = new Zombie(gs);\n            gs.zombies[0][i].worldx = gs.tileSize * (random.nextInt(50));\n            gs.zombies[0][i].worldy = gs.tileSize * (random.nextInt(50));\n        }\n        for (int i = 0; i < 10; i++) {\n            gs.zombies[1][i] = new Zombie(gs);\n            gs.zombies[1][i].worldx = gs.tileSize * (random.nextInt(50));\n            gs.zombies[1][i].worldy = gs.tileSize * (random.nextInt(50));\n        }\n        for (int i = 10; i < gs.zombies[1].length; i++) {\n            gs.zombies[1][i] = new CrawlingZombie(gs);\n            gs.zombies[1][i].worldx = gs.tileSize * (random.nextInt(50));\n            gs.zombies[1][i].worldy = gs.tileSize * (random.nextInt(50));\n        }\n\n        for (int i = 0; i < 5; i++) {\n            gs.zombies[2][i] = new Zombie(gs);\n            gs.zombies[2][i].worldx = gs.tileSize * (random.nextInt(50));\n            gs.zombies[2][i].worldy = gs.tileSize * (random.nextInt(50));\n        }\n        for (int i = 5; i < 10; i++) {\n            gs.zombies[2][i] = new CrawlingZombie(gs);\n            gs.zombies[2][i].worldx = gs.tileSize * (random.nextInt(50));\n            gs.zombies[2][i].worldy = gs.tileSize * (random.nextInt(50));\n        }\n        for (int i = 10; i < 15; i++) {\n            gs.zombies[2][i] = new AcidZombie(gs);\n            gs.zombies[2][i].worldx = gs.tileSize * (random.nextInt(50));\n            gs.zombies[2][i].worldy = gs.tileSize * (random.nextInt(50));\n        }\n        for (int i = 0; i < 10; i++) {\n            gs.zombies[3][i] = new CrawlingZombie(gs);\n            gs.zombies[3][i].worldx = gs.tileSize * (random.nextInt(50));\n            gs.zombies[3][i].worldy = gs.tileSize * (random.nextInt(50));\n        }\n        for (int i = 10; i < 15; i++) {\n            gs.zombies[3][i] = new AcidZombie(gs);\n            gs.zombies[3][i].worldx = gs.tileSize * (random.nextInt(50));\n            gs.zombies[3][i].worldy = gs.tileSize * (random.nextInt(50));\n        }\n\n        for (int i = 0; i < 10; i++) {\n            gs.zombies[4][i] = new Zombie(gs);\n            gs.zombies[4][i].worldx = gs.tileSize * (random.nextInt(50));\n            gs.zombies[4][i].worldy = gs.tileSize * (random.nextInt(50));\n        }\n        for (int i = 10; i < 15; i++) {\n            gs.zombies[4][i] = new TankZombie(gs);\n            gs.zombies[4][i].worldx = gs.tileSize * (random.nextInt(50));\n            gs.zombies[4][i].worldy = gs.tileSize * (random.nextInt(50));\n        }\n\n        // for (int i = 0; i < gs.zombies[2].length; i++) {\n        // gs.zombies[2][i] = new Zombie(gs);\n        // gs.zombies[2][i].worldx = gs.tileSize * (random.nextInt(50));\n        // gs.zombies[2][i].worldy = gs.tileSize * (random.nextInt(50));\n        // }\n\n        // for (int i = 0; i < gs.zombies[3].length; i++) {\n        // gs.zombies[3][i] = new Zombie(gs);\n        // gs.zombies[3][i].worldx = gs.tileSize * (random.nextInt(50));\n        // gs.zombies[3][i].worldy = gs.tileSize * (random.nextInt(50));\n        // }\n\n        // for (int i = 0; i < gs.zombies[4].length; i++) {\n        // gs.zombies[4][i] = new Zombie(gs);\n        // gs.zombies[4][i].worldx = gs.tileSize * (random.nextInt(50));\n        // gs.zombies[4][i].worldy = gs.tileSize * (random.nextInt(50));\n        // }\n\n    }\n}\n",
      "CollisionChecher.java": "package GameFiles;\n\nimport Entities.Entities;\n\npublic class CollisionChecher {\n\n    GameScreen gs;\n\n    public CollisionChecher(GameScreen gs) {\n        this.gs = gs;\n    }\n\n    public void checkTile(Entities entity) {\n        int entityLeftX = entity.worldx + entity.solidArea.x;\n        int entityRightX = entity.worldx + entity.solidArea.x + entity.solidArea.width;\n        int entityTopY = entity.worldy + entity.solidArea.y;\n        int entityBottomY = entity.worldy + entity.solidArea.y + entity.solidArea.height;\n\n        int entityLeftCol = entityLeftX / gs.tileSize;\n        int entityRightCol = entityRightX / gs.tileSize;\n        int entityTopRow = entityTopY / gs.tileSize;\n        int entityBottomRow = entityBottomY / gs.tileSize;\n\n        int tileNum1, tileNum2, tileNum3;\n\n        switch (entity.direction) {\n            case \"up\":\n                entityTopRow = (entityTopY - entity.speed) / gs.tileSize;\n                tileNum1 = gs.Tm.mapTileNum[entityLeftCol][entityTopRow];\n                tileNum2 = gs.Tm.mapTileNum[entityRightCol][entityTopRow];\n                if (gs.Tm.tiles[tileNum1].collision == true || gs.Tm.tiles[tileNum2].collision == true) {\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"down\":\n                entityBottomRow = (entityBottomY + entity.speed) / gs.tileSize;\n                tileNum1 = gs.Tm.mapTileNum[entityLeftCol][entityBottomRow];\n                tileNum2 = gs.Tm.mapTileNum[entityRightCol][entityBottomRow];\n                if (gs.Tm.tiles[tileNum1].collision == true || gs.Tm.tiles[tileNum2].collision == true) {\n                    entity.collisionOn = true;\n                }\n\n                break;\n            case \"left\":\n                entityLeftCol = (entityLeftX - entity.speed) / gs.tileSize;\n                tileNum1 = gs.Tm.mapTileNum[entityLeftCol][entityTopRow];\n                tileNum2 = gs.Tm.mapTileNum[entityLeftCol][entityBottomRow];\n                if (gs.Tm.tiles[tileNum1].collision == true || gs.Tm.tiles[tileNum2].collision == true) {\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"right\":\n                entityRightCol = (entityRightX + entity.speed) / gs.tileSize;\n                tileNum1 = gs.Tm.mapTileNum[entityRightCol][entityTopRow];\n                tileNum2 = gs.Tm.mapTileNum[entityRightCol][entityBottomRow];\n                if (gs.Tm.tiles[tileNum1].collision == true || gs.Tm.tiles[tileNum2].collision == true) {\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"topright\":\n                entityRightCol = (entityRightX + entity.speed) / gs.tileSize;\n                entityTopRow = (entityTopY - entity.speed) / gs.tileSize;\n                tileNum1 = gs.Tm.mapTileNum[entityRightCol][entityTopRow];\n                tileNum2 = gs.Tm.mapTileNum[entityRightCol][entityBottomRow];\n                tileNum3 = gs.Tm.mapTileNum[entityLeftCol][entityTopRow];\n                if (gs.Tm.tiles[tileNum1].collision == true ||\n                        gs.Tm.tiles[tileNum2].collision == true\n                        || gs.Tm.tiles[tileNum3].collision == true) {\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"topleft\":\n                entityLeftCol = (entityLeftX - entity.speed) / gs.tileSize;\n                entityTopRow = (entityTopY - entity.speed) / gs.tileSize;\n                tileNum1 = gs.Tm.mapTileNum[entityLeftCol][entityTopRow];\n                tileNum2 = gs.Tm.mapTileNum[entityRightCol][entityTopRow];\n                tileNum3 = gs.Tm.mapTileNum[entityLeftCol][entityBottomRow];\n                if (gs.Tm.tiles[tileNum1].collision == true ||\n                        gs.Tm.tiles[tileNum2].collision == true\n                        || gs.Tm.tiles[tileNum3].collision == true) {\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"bottomright\":\n                entityRightCol = (entityRightX + entity.speed) / gs.tileSize;\n                entityBottomRow = (entityBottomY + entity.speed) / gs.tileSize;\n                tileNum1 = gs.Tm.mapTileNum[entityLeftCol][entityBottomRow];\n                tileNum2 = gs.Tm.mapTileNum[entityRightCol][entityBottomRow];\n                tileNum3 = gs.Tm.mapTileNum[entityRightCol][entityTopRow];\n                if (gs.Tm.tiles[tileNum1].collision == true ||\n                        gs.Tm.tiles[tileNum2].collision == true\n                        || gs.Tm.tiles[tileNum3].collision == true) {\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"bottomleft\":\n                entityLeftCol = (entityLeftX - entity.speed) / gs.tileSize;\n                entityBottomRow = (entityBottomY + entity.speed) / gs.tileSize;\n                tileNum1 = gs.Tm.mapTileNum[entityLeftCol][entityTopRow];\n                tileNum2 = gs.Tm.mapTileNum[entityLeftCol][entityBottomRow];\n                tileNum3 = gs.Tm.mapTileNum[entityRightCol][entityBottomRow];\n                if (gs.Tm.tiles[tileNum1].collision == true ||\n                        gs.Tm.tiles[tileNum2].collision == true\n                        || gs.Tm.tiles[tileNum3].collision == true) {\n                    entity.collisionOn = true;\n                }\n                break;\n\n        }\n    }\n\n    public int checkObject(Entities entity, boolean player) {\n        int index = 999;\n\n        for (int i = 0; i < gs.obj.length; i++) {\n            if (gs.obj[i] != null) {\n                entity.solidArea.x = entity.worldx + entity.solidArea.x;\n                entity.solidArea.y = entity.worldy + entity.solidArea.y;\n\n                gs.obj[i].solidArea.x = gs.obj[i].worldX + gs.obj[i].solidArea.x;\n                gs.obj[i].solidArea.y = gs.obj[i].worldY + gs.obj[i].solidArea.y;\n                switch (entity.direction) {\n                    case \"up\":\n                        entity.solidArea.y -= entity.speed;\n                        if (entity.solidArea.intersects(gs.obj[i].solidArea)) {\n                            if (gs.obj[i].collision == true) {\n                                entity.collisionOn = true;\n                            }\n                            if (player == true) {\n                                index = i;\n                            }\n\n                            break;\n                        }\n\n                    case \"down\":\n                        entity.solidArea.y += entity.speed;\n                        if (entity.solidArea.intersects(gs.obj[i].solidArea)) {\n                            if (gs.obj[i].collision == true) {\n                                entity.collisionOn = true;\n                            }\n                            if (player == true) {\n                                index = i;\n                            }\n                            break;\n                        }\n\n                    case \"left\":\n                        entity.solidArea.x -= entity.speed;\n                        if (entity.solidArea.intersects(gs.obj[i].solidArea)) {\n                            if (gs.obj[i].collision == true) {\n                                entity.collisionOn = true;\n                            }\n                            if (player == true) {\n                                index = i;\n                            }\n                            break;\n                        }\n\n                    case \"right\":\n                        entity.solidArea.x += entity.speed;\n                        if (entity.solidArea.intersects(gs.obj[i].solidArea)) {\n                            if (gs.obj[i].collision == true) {\n                                entity.collisionOn = true;\n                            }\n                            if (player == true) {\n                                index = i;\n                            }\n                            break;\n                        }\n\n                }\n                entity.solidArea.x = entity.solidAreaDefaultX;\n                entity.solidArea.y = entity.solidAreaDefaultY;\n                gs.obj[i].solidArea.x = gs.obj[i].solidAreaDefaultX;\n                gs.obj[i].solidArea.y = gs.obj[i].solidAreaDefaultY;\n            }\n        }\n        return index;\n\n    }\n}\n",
      "KeyBindings.java": "package GameFiles;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\npublic class KeyBindings implements KeyListener {\n\n    GameScreen gs;\n    public boolean up, down, left, right, key_e, esc, reload, save;\n    int reloadCooldown = 0;\n    int fps = 120;\n\n    public KeyBindings(GameScreen gs) {\n        this.gs = gs;\n    }\n\n    public void keyPressed(KeyEvent e) {\n        int code = e.getKeyCode();\n\n        if (gs.gameState == gs.waveState) {\n            if (code == KeyEvent.VK_ENTER) {\n                gs.currentWave++;\n                gs.gameState = gs.playState;\n            }\n\n        }\n        if (gs.gameState == gs.gameoverState) {\n            if (code == KeyEvent.VK_ENTER) {\n                System.exit(0);\n            }\n        }\n        if (gs.gameState == gs.pauseState) {\n            if (code == KeyEvent.VK_M) {\n                gs.saveLoad.save();\n                save = true;\n            }\n        }\n        if (gs.gameState == gs.endGameState) {\n            if (code == KeyEvent.VK_ENTER) {\n                System.exit(0);\n            }\n        }\n\n        if (gs.gameState == gs.titleState) {\n            if (code == KeyEvent.VK_W) {\n                if (gs.ui.commandNum == 0) {\n                    gs.ui.commandNum = 3;\n                } else {\n                    gs.ui.commandNum--;\n                }\n            }\n\n            if (code == KeyEvent.VK_S) {\n                if (gs.ui.commandNum == 3) {\n                    gs.ui.commandNum = 0;\n                } else {\n                    gs.ui.commandNum++;\n                }\n\n            }\n            if (code == KeyEvent.VK_ENTER) {\n                if (gs.ui.commandNum == 0) {\n                    gs.gameState = gs.playState;\n                }\n                if (gs.ui.commandNum == 2) {\n                    System.exit(0);\n                }\n                if (gs.ui.commandNum == 1) {\n                    gs.saveLoad.load();\n                    gs.gameState = gs.playState;\n                }\n            }\n\n        }\n\n        if (code == KeyEvent.VK_W) {\n            up = true;\n        }\n\n        if (code == KeyEvent.VK_A) {\n            left = true;\n        }\n\n        if (code == KeyEvent.VK_S) {\n            down = true;\n        }\n\n        if (code == KeyEvent.VK_D) {\n            right = true;\n        }\n        if (code == KeyEvent.VK_E) {\n            key_e = true;\n        }\n        if (code == KeyEvent.VK_X) {\n            if (gs.p1.medKitNum > 0) {\n                int temp = gs.p1.maxLife - gs.p1.life;\n                gs.p1.life += temp;\n\n                gs.p1.medKitNum--;\n\n            }\n\n        }\n        if (code == KeyEvent.VK_C)\n\n        {\n            if (gs.p1.energyDrinkNum > 0) {\n                if (gs.p1.life <= 10) {\n                    gs.p1.life += 10;\n                } else {\n                    int temp = gs.p1.maxLife - gs.p1.life;\n                    gs.p1.life += temp;\n                }\n                gs.p1.energyDrinkNum--;\n            }\n        }\n\n        if (code == KeyEvent.VK_1) {\n            gs.p1.currentWeaponIndex = 0;\n        }\n        if (code == KeyEvent.VK_2) {\n            if (gs.currentWave >= 1) {\n                gs.p1.currentWeaponIndex = 1;\n            }\n\n        }\n        if (code == KeyEvent.VK_3) {\n            if (gs.currentWave >= 2) {\n                gs.p1.currentWeaponIndex = 2;\n            }\n\n        }\n        if (code == KeyEvent.VK_4) {\n            if (gs.currentWave >= 3) {\n                gs.p1.currentWeaponIndex = 3;\n            }\n\n        }\n        if (code == KeyEvent.VK_5) {\n            if (gs.currentWave >= 4) {\n                gs.p1.currentWeaponIndex = 4;\n            }\n\n        }\n\n        if (code == KeyEvent.VK_R) {\n            gs.p1.currentWeapon.reload();\n\n        }\n\n        if (code == KeyEvent.VK_ESCAPE) {\n            if (gs.gameState == gs.playState) {\n                gs.gameState = gs.pauseState;\n            } else if (gs.gameState == gs.pauseState) {\n                gs.gameState = gs.playState;\n            }\n            esc = true;\n        }\n\n    }\n\n    public void keyReleased(KeyEvent e) {\n\n        int code = e.getKeyCode();\n\n        if (code == KeyEvent.VK_W) {\n            up = false;\n        }\n\n        if (code == KeyEvent.VK_A) {\n            left = false;\n        }\n\n        if (code == KeyEvent.VK_S) {\n            down = false;\n        }\n\n        if (code == KeyEvent.VK_D) {\n            right = false;\n        }\n        if (code == KeyEvent.VK_E) {\n            key_e = false;\n        }\n        if (code == KeyEvent.VK_ESCAPE) {\n            esc = false;\n        }\n        if (gs.gameState == gs.pauseState) {\n            if (code == KeyEvent.VK_M) {\n                save = false;\n            }\n        }\n\n    }\n\n    public void keyTyped(KeyEvent e) {\n        System.out.println();\n    }\n\n}\n",
      "UI.java": "package GameFiles;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\n\nimport javax.imageio.ImageIO;\nimport javax.imageio.stream.FileImageInputStream;\n\nimport Objects.Obj_Heart;\nimport Objects.SuperObject;\n\npublic class UI {\n        GameScreen gs;\n        Graphics2D g2;\n        Font arial_40, arial_80B;\n        BufferedImage Background;\n        BufferedImage newGameButton, loadGameButton, settingsButton, quitButton, menuSelect;\n        BufferedImage heartFull, heartHalf, heartBlank, pistol, rifle, shotgun, sniper, rpg, energyDrink, medkit;\n        public int commandNum = 0;\n        KeyBindings keys;\n\n        public UI(GameScreen gs) {\n                this.gs = gs;\n                keys = new KeyBindings(gs);\n\n                arial_40 = new Font(\"Arial\", Font.PLAIN, 40);\n                arial_80B = new Font(\"Arial\", Font.BOLD, 80);\n\n                SuperObject heart = new Obj_Heart(gs);\n                heartFull = heart.image;\n                heartHalf = heart.image1;\n                heartBlank = heart.image2;\n\n                try {\n                        Background = ImageIO\n                                        .read(new FileImageInputStream(\n                                                        new RandomAccessFile(\"GameFiles\\\\Images\\\\Background.jpg\",\n                                                                        \"rw\")));\n                        newGameButton = ImageIO\n                                        .read(new FileImageInputStream(\n                                                        new RandomAccessFile(\"GameFiles\\\\Images\\\\newGameIcon.png\",\n                                                                        \"rw\")));\n                        loadGameButton = ImageIO\n                                        .read(new FileImageInputStream(\n                                                        new RandomAccessFile(\"GameFiles\\\\Images\\\\loadGameIcon.png\",\n                                                                        \"rw\")));\n                        settingsButton = ImageIO\n                                        .read(new FileImageInputStream(\n                                                        new RandomAccessFile(\"GameFiles\\\\Images\\\\settingsIcon.png\",\n                                                                        \"rw\")));\n                        quitButton = ImageIO\n                                        .read(new FileImageInputStream(\n                                                        new RandomAccessFile(\"GameFiles\\\\Images\\\\quitIcon.png\",\n                                                                        \"rw\")));\n                        menuSelect = ImageIO\n                                        .read(new FileImageInputStream(\n                                                        new RandomAccessFile(\"GameFiles\\\\Images\\\\menuSelect.png\",\n                                                                        \"rw\")));\n\n                        pistol = ImageIO\n                                        .read(new FileImageInputStream(\n                                                        new RandomAccessFile(\"GameFiles\\\\Images\\\\pistol.png\",\n                                                                        \"rw\")));\n                        rifle = ImageIO\n                                        .read(new FileImageInputStream(\n                                                        new RandomAccessFile(\"GameFiles\\\\Images\\\\rifle.png\",\n                                                                        \"rw\")));\n                        shotgun = ImageIO\n                                        .read(new FileImageInputStream(\n                                                        new RandomAccessFile(\"GameFiles\\\\Images\\\\shotgun.png\",\n                                                                        \"rw\")));\n                        sniper = ImageIO\n                                        .read(new FileImageInputStream(\n                                                        new RandomAccessFile(\"GameFiles\\\\Images\\\\sniper.png\",\n                                                                        \"rw\")));\n                        rpg = ImageIO\n                                        .read(new FileImageInputStream(\n                                                        new RandomAccessFile(\"GameFiles\\\\Images\\\\rocketLauncher.png\",\n                                                                        \"rw\")));\n\n                        energyDrink = ImageIO\n                                        .read(new FileImageInputStream(\n                                                        new RandomAccessFile(\"GameFiles\\\\Images\\\\energyDrink.png\",\n                                                                        \"rw\")));\n                        medkit = ImageIO\n                                        .read(new FileImageInputStream(\n                                                        new RandomAccessFile(\"GameFiles\\\\Images\\\\medkit.png\",\n                                                                        \"rw\")));\n\n                } catch (IOException e) {\n                        e.printStackTrace();\n                }\n        }\n\n        public void draw(Graphics2D g2) {\n                this.g2 = g2;\n\n                g2.setFont(arial_40);\n                g2.setColor(Color.white);\n\n                if (gs.gameState == gs.titleState) {\n                        drawTitleScreen();\n                }\n\n                if (gs.gameState == gs.playState) {\n                        drawPlayerLife();\n                }\n                if (gs.gameState == gs.pauseState) {\n                        g2.create(gs.p1.screenX, gs.p1.screenY, gs.tileSize, gs.tileSize);\n                        drawPlayerLife();\n                        drawPauseScreen();\n\n                }\n                if (gs.gameState == gs.waveState) {\n                        g2.create(gs.p1.screenX, gs.p1.screenY, gs.tileSize, gs.tileSize);\n                        drawPlayerLife();\n                        drawWaveScreen();\n                }\n                if (gs.gameState == gs.gameoverState) {\n                        g2.create(gs.p1.screenX, gs.p1.screenY, gs.tileSize, gs.tileSize);\n                        drawGameoverScreen();\n                }\n                if (gs.gameState == gs.endGameState) {\n                        g2.create(gs.p1.screenX, gs.p1.screenY, gs.tileSize, gs.tileSize);\n                        drawEndGameScreen();\n                }\n\n        }\n\n        public void drawPlayerLife() {\n                int x = gs.screenWidht - gs.tileSize * 4;\n                int y = gs.tileSize / 2;\n                int i = 0;\n\n                g2.drawString(\"POINTS: \" + String.valueOf(gs.points), x, y + gs.tileSize);\n\n                while (i < gs.p1.maxLife / 2) {\n                        g2.drawImage(heartBlank, x, y, gs.tileSize / 3, gs.tileSize / 3, null);\n                        i++;\n                        x += gs.tileSize / 3;\n\n                }\n                x = gs.screenWidht - gs.tileSize * 4;\n                y = gs.tileSize / 2;\n                i = 0;\n\n                while (i < gs.p1.life) {\n                        g2.drawImage(heartHalf, x, y, gs.tileSize / 3, gs.tileSize / 3, null);\n                        i++;\n                        if (i < gs.p1.life) {\n                                g2.drawImage(heartFull, x, y, gs.tileSize / 3, gs.tileSize / 3, null);\n                        }\n                        i++;\n                        x += gs.tileSize / 3;\n                }\n\n                int xm = gs.screenWidht - gs.tileSize * 3;\n                int ym = gs.screenHeight - gs.tileSize * 2;\n                g2.drawImage(medkit, xm, ym, gs.tileSize, gs.tileSize,\n                                null);\n                g2.drawString(\" : \" + String.valueOf(gs.p1.medKitNum), xm + gs.tileSize, ym + gs.scale * 11);\n                g2.drawImage(energyDrink, xm, ym - gs.tileSize, gs.tileSize, gs.tileSize,\n                                null);\n                g2.drawString(\" : \" + String.valueOf(gs.p1.energyDrinkNum), xm + gs.tileSize,\n                                ym + gs.scale * 11 - gs.tileSize);\n\n                int xg = gs.tileSize / 2;\n                int yg = gs.tileSize / 2;\n\n                switch (gs.p1.currentWeaponIndex) {\n                        case 0:\n                                g2.drawImage(pistol, xg + gs.scale * 4, yg, gs.tileSize + gs.scale * 5, gs.tileSize,\n                                                null);\n                                String text = String.valueOf(\"Ammo: \" + gs.p1.currentWeapon.getCurrentAmmo()) + \"/\"\n                                                + String.valueOf(gs.p1.currentWeapon.getMagazineSize());\n                                g2.drawString(text, xg + gs.scale * 4, yg + gs.tileSize + gs.scale * 6);\n                                break;\n\n                        case 1:\n                                g2.drawImage(rifle, xg - gs.scale * 3, yg - gs.scale * 7,\n                                                gs.tileSize * 3 + gs.scale * 6,\n                                                gs.tileSize * 2, null);\n                                text = String.valueOf(\"Ammo: \" + gs.p1.currentWeapon.getCurrentAmmo()) + \"/\"\n                                                + String.valueOf(gs.p1.currentWeapon.getMagazineSize());\n                                g2.drawString(text, xg + gs.scale * 4, yg + gs.tileSize + gs.scale * 6);\n\n                                break;\n                        case 2:\n                                g2.drawImage(shotgun, xg, yg, gs.tileSize * 3, gs.tileSize, null);\n                                text = String.valueOf(\"Ammo: \" + gs.p1.currentWeapon.getCurrentAmmo()) + \"/\"\n                                                + String.valueOf(gs.p1.currentWeapon.getMagazineSize());\n                                g2.drawString(text, xg + gs.scale * 4, yg + gs.tileSize + gs.scale * 6);\n                                break;\n                        case 3:\n                                g2.drawImage(sniper, xg, yg - gs.scale * 7, gs.tileSize * 3, gs.tileSize * 2, null);\n                                text = String.valueOf(\"Ammo: \" + gs.p1.currentWeapon.getCurrentAmmo()) + \"/\"\n                                                + String.valueOf(gs.p1.currentWeapon.getMagazineSize());\n                                g2.drawString(text, xg + gs.scale * 4, yg + gs.tileSize + gs.scale * 6);\n                                break;\n                        case 4:\n                                g2.drawImage(rpg, xg, yg - gs.scale * 7, gs.tileSize * 3, gs.tileSize * 2, null);\n                                text = String.valueOf(\"Ammo: \" + gs.p1.currentWeapon.getCurrentAmmo()) + \"/\"\n                                                + String.valueOf(gs.p1.currentWeapon.getMagazineSize());\n                                g2.drawString(text, xg + gs.scale * 4, yg + gs.tileSize + gs.scale * 6);\n                                break;\n\n                }\n\n        }\n\n        public void drawWaveScreen() {\n                String text = \"Wave \" + String.valueOf(gs.currentWave + 1)\n                                + \" Completed press enter to start next wave\";\n                int x = getXforCenteredText(text);\n                int y = gs.screenHeight / 2;\n                g2.drawString(text, x, y);\n        }\n\n        public void drawTitleScreen() {\n                g2.setFont(arial_80B);\n\n                String text = \"Zombie Shootout!\";\n                int x = getXforCenteredText(text);\n                int y = gs.tileSize;\n                g2.drawImage(Background, 0, 0, gs.screenWidht, gs.screenHeight, null);\n                g2.setColor(Color.gray);\n                g2.drawString(text, x + 5, y + 5);\n                g2.setColor(Color.white);\n                g2.drawString(text, x, y);\n                g2.drawImage(newGameButton, x + gs.tileSize, y + gs.tileSize, gs.tileSize * 4,\n                                gs.tileSize + 8 * gs.scale,\n                                null);\n                if (commandNum == 0) {\n                        g2.drawImage(menuSelect, x - gs.tileSize, y + gs.tileSize - gs.scale * 4,\n                                        gs.tileSize * 3,\n                                        gs.tileSize * 2,\n                                        null);\n                }\n\n                g2.drawImage(loadGameButton, x + gs.tileSize + gs.scale * 2, y + gs.tileSize * 2 + gs.scale * 10,\n                                gs.tileSize * 3 + gs.scale * 13, gs.tileSize + 7 * gs.scale, null);\n                if (commandNum == 1) {\n                        g2.drawImage(menuSelect, x - gs.tileSize, y + gs.tileSize * 3 - gs.scale * 11,\n                                        gs.tileSize * 3,\n                                        gs.tileSize * 2,\n                                        null);\n                }\n\n                g2.drawImage(quitButton, x + gs.tileSize, y + gs.tileSize * 3 + gs.scale * 7 + gs.scale * 10,\n                                gs.tileSize * 4,\n                                gs.tileSize + 8 * gs.scale,\n                                null);\n                if (commandNum == 2) {\n                        g2.drawImage(menuSelect, x - gs.tileSize, y + gs.tileSize * 4 - gs.scale * 3,\n                                        gs.tileSize * 3,\n                                        gs.tileSize * 2,\n                                        null);\n                }\n\n        }\n\n        public void drawGameoverScreen() {\n                int x = getXforCenteredText(\"GAME OVER\");\n                int y = gs.screenHeight / 2 - gs.tileSize;\n                g2.drawString(\"GAME OVER\", x, y);\n                x = getXforCenteredText(\"Total points earned: \" + String.valueOf(gs.points));\n                g2.drawString(\"Total points earned: \" + String.valueOf(gs.points), x, y + gs.tileSize);\n                x = getXforCenteredText(\"Press Enter to exit\");\n                y = gs.screenHeight / 2 + gs.tileSize * 2;\n                g2.drawString(\"Press Enter to exit\", x, y);\n\n        }\n\n        public void drawEndGameScreen() {\n                int x = getXforCenteredText(\"Congratulations\");\n                int y = gs.screenHeight / 2 - gs.tileSize;\n                g2.drawString(\"Congratulations\", x, y);\n                x = getXforCenteredText(\"Total points earned: \" + String.valueOf(gs.points));\n                g2.drawString(\"Total points earned: \" + String.valueOf(gs.points), x, y + gs.tileSize);\n                x = getXforCenteredText(\"Press Enter to exit\");\n                y = gs.screenHeight / 2 + gs.tileSize * 2;\n                g2.drawString(\"Press Enter to exit\", x, y);\n        }\n\n        public void drawPauseScreen() {\n                String text = \"PAUSED\";\n                int x = getXforCenteredText(text);\n                int y = gs.screenHeight / 2;\n                g2.drawString(text, x, y);\n                text = \"Press M to save game\";\n                x = getXforCenteredText(text);\n                y = gs.tileSize / 2;\n                g2.drawString(text, x, y);\n                if (keys.save == true) {\n                        x = getXforCenteredText(\"Game Saved Successfully\");\n                        y = gs.screenHeight / 2 + gs.tileSize;\n                        g2.drawString(\"Game Saved Successfully\", x, y);\n                }\n        }\n\n        public int getXforCenteredText(String text) {\n                int length = (int) g2.getFontMetrics().getStringBounds(text, g2).getWidth() / 2;\n                int x = (gs.screenWidht / 2 - length);\n                return x;\n        }\n}\n",
      "Mouse.java": "package GameFiles;\n\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\n\npublic class Mouse implements MouseListener, MouseMotionListener {\n    public boolean mouseEntered, mousePressed;\n    public int mouseX, mouseY;\n\n    public void mousePressed(MouseEvent e) {\n        mousePressed = true;\n    }\n\n    public void mouseReleased(MouseEvent e) {\n        mousePressed = false;\n    }\n\n    public void mouseClicked(MouseEvent e) {\n\n    }\n\n    public void mouseEntered(MouseEvent e) {\n        mouseEntered = true;\n        mouseX = e.getX();\n    }\n\n    public void mouseExited(MouseEvent e) {\n        mouseEntered = false;\n    }\n\n    public void mouseMoved(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n\n    public void mouseDragged(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n}",
      "Tiles.java": "package Map;\n\nimport java.awt.image.BufferedImage;\n\npublic class Tiles {\n    public BufferedImage image;\n    public boolean collision = false;\n}",
      "TileManager.java": "package Map;\n\nimport java.awt.Graphics2D;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.util.Scanner;\n\nimport javax.imageio.ImageIO;\nimport javax.imageio.stream.FileImageInputStream;\n\nimport GameFiles.GameScreen;\n\npublic class TileManager {\n    GameScreen gs;\n    public Tiles[] tiles;\n    public int mapTileNum[][];\n\n    public TileManager(GameScreen gs) {\n        this.gs = gs;\n\n        tiles = new Tiles[37];\n        getTileImage();\n        mapTileNum = new int[gs.maxWorldCol][gs.maxWorldRow];\n        loadMap();\n    }\n\n    public void getTileImage() {\n        try {\n            tiles[0] = new Tiles();\n            tiles[0].image = ImageIO\n                    .read(new FileImageInputStream(\n                            new RandomAccessFile(\"Map\\\\TileTextures\\\\038.png\",\n                                    \"rw\")));\n            tiles[1] = new Tiles();\n            tiles[1].image = ImageIO\n                    .read(new FileImageInputStream(\n                            new RandomAccessFile(\"Map\\\\TileTextures\\\\042.png\",\n                                    \"rw\")));\n            tiles[1].collision = true;\n            tiles[2] = new Tiles();\n            tiles[2].image = ImageIO\n                    .read(new FileImageInputStream(\n                            new RandomAccessFile(\"Map\\\\TileTextures\\\\044.png\",\n                                    \"rw\")));\n            tiles[2].collision = true;\n            tiles[3] = new Tiles();\n            tiles[3].image = ImageIO\n                    .read(new FileImageInputStream(\n                            new RandomAccessFile(\"Map\\\\TileTextures\\\\039.png\",\n                                    \"rw\")));\n            tiles[4] = new Tiles();\n            tiles[4].image = ImageIO\n                    .read(new FileImageInputStream(\n                            new RandomAccessFile(\"Map\\\\TileTextures\\\\043.png\",\n                                    \"rw\")));\n            tiles[4].collision = true;\n            tiles[5] = new Tiles();\n            tiles[5].image = ImageIO\n                    .read(new FileImageInputStream(\n                            new RandomAccessFile(\"Map\\\\TileTextures\\\\040.png\",\n                                    \"rw\")));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void loadMap() {\n        try {\n            FileInputStream Is = new FileInputStream(\"Map\\\\maps\\\\map2.txt\");\n            Scanner scan = new Scanner(Is);\n            int col = 0;\n            int row = 0;\n\n            while (col < gs.maxWorldCol && row < gs.maxWorldRow) {\n                String line = scan.nextLine();\n\n                while (col < gs.maxWorldCol) {\n                    String numbers[] = line.split(\" \");\n                    int num = Integer.parseInt(numbers[col]);\n                    mapTileNum[col][row] = num;\n                    col++;\n                }\n                if (col == gs.maxWorldCol) {\n                    col = 0;\n                    row++;\n\n                }\n            }\n            scan.close();\n\n        } catch (Exception e) {\n            System.out.println(\"err\");\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        int worldCol = 0;\n        int worldRow = 0;\n\n        while (worldCol < gs.maxWorldCol && worldRow < gs.maxWorldRow) {\n            int tileNum = mapTileNum[worldCol][worldRow];\n\n            int worldX = worldCol * gs.tileSize;\n            int worldY = worldRow * gs.tileSize;\n            int screenX = worldX - gs.p1.worldx + gs.p1.screenX;\n            int screenY = worldY - gs.p1.worldy + gs.p1.screenY;\n\n            if (worldX + gs.tileSize > gs.p1.worldx - gs.p1.screenX\n                    && worldX - gs.tileSize < gs.p1.worldx + gs.p1.screenX\n                    && worldY + gs.tileSize > gs.p1.worldy - gs.p1.screenY\n                    && worldY - gs.tileSize < gs.p1.worldy + gs.p1.screenY) {\n                g2.drawImage(tiles[tileNum].image, screenX, screenY, gs.tileSize, gs.tileSize, null);\n            }\n            worldCol++;\n\n            if (worldCol == gs.maxWorldCol) {\n\n                worldCol = 0;\n                worldRow++;\n\n            }\n\n        }\n    }\n}\n"
    },
    {
      "id": "9830856",
      "Sniper.java": "import java.awt.Color;\nimport java.awt.geom.Point2D;\n\npublic class Sniper extends Weapon {\n    public Sniper() {\n        super(5, 30); \n    }\n    \n    @Override\n    public String getName() {\n        return \"Keskin Nişancı Tüfeği\";\n    }\n    \n    @Override\n    protected void createBullet(Point2D.Double position, double angle) {\n        \n        bullets.add(new Bullet(position, angle, 50, 30, Color.BLUE));\n    }\n} ",
      "Zombie.java": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.Serializable;\n\npublic abstract class Zombie implements Serializable {\n    protected Point2D.Double position;\n    protected double angle;\n    protected int health;\n    protected double speed;\n    protected int damage;\n    protected int zombieSize; \n    protected boolean isDead = false;\n    \n    public Zombie(Point2D.Double position, int health, double speed, int damage) {\n        this.position = position;\n        this.health = health;\n        this.speed = speed;\n        this.damage = damage;\n    }\n    \n    public void update(Point2D.Double playerPosition) {\n        \n        double dx = playerPosition.x - position.x;\n        double dy = playerPosition.y - position.y;\n        angle = Math.atan2(dy, dx);\n        \n        position.x += Math.cos(angle) * speed;\n        position.y += Math.sin(angle) * speed;\n    }\n    \n    public void draw(Graphics2D g2d) {\n        \n        g2d.setColor(Color.RED);\n        g2d.setFont(new Font(\"Arial\", Font.PLAIN, 12));\n        g2d.drawString(String.valueOf(health), \n            (int)(position.x - 10), \n            (int)(position.y - zombieSize/2 - 5));\n    }\n    \n    public boolean isAlive() {\n        return health > 0;\n    }\n    \n    public void takeDamage(int damage) {\n        health -= damage;\n        if (health <= 0 && !this.isDead) {\n            this.isDead = true;\n            dropAmmo();\n        }\n    }\n    \n    private void dropAmmo() {\n        WeaponManager wm = WeaponManager.getInstance();\n        \n        for (int i = 1; i < wm.getWeaponCount(); i++) { \n            Weapon weapon = wm.getWeapon(i);\n            if (weapon != null) {\n                Point2D.Double dropPos = new Point2D.Double(\n                    position.x + (Math.random() * 40 - 20),\n                    position.y + (Math.random() * 40 - 20)\n                );\n                GamePanel.addAmmoPickup(new AmmoPickup(dropPos, weapon.getName()));\n            }\n        }\n    }\n    \n    public Rectangle2D.Double getBounds() {\n        return new Rectangle2D.Double(\n            position.x - zombieSize/2,\n            position.y - zombieSize/2,\n            zombieSize,\n            zombieSize\n        );\n    }\n    \n    \n    public Point2D.Double getPosition() { \n        return new Point2D.Double(position.x, position.y);\n    }\n    public int getDamage() { return damage; }\n} ",
      "Weapon.java": "import java.awt.Graphics2D;\nimport java.awt.RenderingHints;\nimport java.awt.geom.Point2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\n\npublic abstract class Weapon implements Serializable {\n    protected ArrayList<Bullet> bullets;\n    protected int maxAmmo;\n    protected int currentAmmo;\n    protected int magazines;  \n    protected int fireRate; \n    protected long lastShotTime;\n    protected int shotDelay; \n    protected boolean canShoot;\n    \n    public Weapon(int maxAmmo, int fireRate) {\n        this.maxAmmo = maxAmmo;\n        this.currentAmmo = maxAmmo;\n        this.magazines = 0;  \n        this.fireRate = fireRate;\n        this.bullets = new ArrayList<>();\n        this.shotDelay = 60000 / fireRate; \n        this.canShoot = true;\n    }\n    \n    public abstract String getName();\n    \n    public void shoot(Point2D.Double position, double angle) {\n        long currentTime = System.currentTimeMillis();\n        if (currentAmmo > 0 && currentTime - lastShotTime >= shotDelay) {\n            \n            Point2D.Double bulletStart = new Point2D.Double(\n                position.x + Math.cos(angle) * 20,  \n                position.y + Math.sin(angle) * 20\n            );\n            createBullet(bulletStart, angle);\n            currentAmmo--;\n            lastShotTime = currentTime;\n        }\n    }\n    \n    protected abstract void createBullet(Point2D.Double position, double angle);\n    \n    public void reload() {\n        if (magazines > 0 && currentAmmo < maxAmmo) {\n            currentAmmo = maxAmmo;\n            magazines--;\n        }\n    }\n    \n    public void addMagazine() {\n        magazines++;\n    }\n    \n    public void update() {\n        for (int i = bullets.size() - 1; i >= 0; i--) {\n            Bullet bullet = bullets.get(i);\n            bullet.update();\n            if (!bullet.isActive()) {\n                bullets.remove(i);\n            }\n        }\n    }\n    \n    public void draw(Graphics2D g2d) {\n        \n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        for (Bullet bullet : bullets) {\n            bullet.draw(g2d);\n        }\n    }\n    \n    \n    public int getCurrentAmmo() { return currentAmmo; }\n    public int getMaxAmmo() { return maxAmmo; }\n    public int getMagazines() {\n        return magazines;\n    }\n} ",
      "Bullet.java": "import java.awt.*;\nimport java.awt.geom.*;\n\npublic class Bullet {\n    protected Point2D.Double position;\n    private double angle;\n    private double speed;\n    private int damage;\n    private boolean active;\n    private Color bulletColor;\n    private static final int BULLET_SIZE = 6;\n    \n    public Bullet(Point2D.Double start, double angle, int damage, double speed, Color color) {\n        this.position = new Point2D.Double(start.x, start.y);\n        this.angle = angle;\n        this.damage = damage;\n        this.speed = speed * 1.5;\n        this.active = true;\n        this.bulletColor = color;\n    }\n    \n    public void update() {\n        position.x += Math.cos(angle) * (speed * 2);\n        position.y += Math.sin(angle) * (speed * 2);\n        \n        \n        if (position.x < 0 || position.x > 800 || position.y < 0 || position.y > 600) {\n            active = false;\n        }\n    }\n    \n    public void draw(Graphics2D g2d) {\n        if (!active) return;  \n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        \n        int drawSize = BULLET_SIZE;\n        \n        \n        g2d.setColor(new Color(bulletColor.getRed(), bulletColor.getGreen(), bulletColor.getBlue(), 150));\n        g2d.fillOval(\n            (int)(position.x - drawSize),\n            (int)(position.y - drawSize),\n            drawSize * 2,\n            drawSize * 2\n        );\n        \n        \n        g2d.setColor(bulletColor);\n        g2d.fillOval(\n            (int)(position.x - drawSize/2),\n            (int)(position.y - drawSize/2),\n            drawSize,\n            drawSize\n        );\n        \n       \n        g2d.setColor(Color.WHITE);\n        g2d.fillOval(\n            (int)(position.x - BULLET_SIZE/4),\n            (int)(position.y - BULLET_SIZE/4),\n            BULLET_SIZE/2,\n            BULLET_SIZE/2\n        );\n    }\n    \n    public boolean isActive() { return active; }\n    public void deactivate() { active = false; }\n    public int getDamage() { return damage; }\n    public Point2D.Double getPosition() { \n        return new Point2D.Double(position.x, position.y); \n    }\n} ",
      "Shotgun.java": "import java.awt.Color;\nimport java.awt.geom.Point2D;\n\npublic class Shotgun extends Weapon {\n    public Shotgun() {\n        super(5, 60); \n    }\n    \n    @Override\n    public String getName() {\n        return \"Pompalı Tüfek\";\n    }\n    \n    @Override\n    protected void createBullet(Point2D.Double position, double angle) {\n        \n        double spreadTotal = Math.toRadians(45);\n        double spreadBetween = spreadTotal / 8; \n        \n        for (int i = 0; i < 9; i++) {\n            double finalAngle = angle - (spreadTotal/2) + (i * spreadBetween);\n            bullets.add(new Bullet(position, finalAngle, 8, 18, Color.ORANGE)); \n        }\n    }\n} ",
      "Main.java": "//import javax.swing.SwingUtilities;\n\npublic class Main {\n   /*  public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            new MainMenu();\n        });\n    }\n        ödev gönderim formatında main metodunun Game sınıfı içerisinde yer alması gerektiği için Game sınıfına taşınmıştır.\n        */\n} ",
      "ExplodingZombie.java": "import java.awt.*;\nimport java.awt.geom.*;\n\npublic class ExplodingZombie extends Zombie {\n    private boolean hasExploded = false;\n    private static final double EXPLOSION_RADIUS = 100;\n    \n    public ExplodingZombie(Point2D.Double position) {\n        super(position, 75, 1.5, 15); \n        this.zombieSize = 30; \n    }\n    \n    @Override\n    public void draw(Graphics2D g2d) {\n        g2d.setColor(Color.ORANGE);\n        g2d.fillOval(\n            (int)(position.x - zombieSize/2),\n            (int)(position.y - zombieSize/2),\n            zombieSize,\n            zombieSize\n        );\n    }\n    \n    public void explode() {\n        if (!hasExploded) {\n            hasExploded = true;\n            \n        }\n    }\n    \n    public boolean hasExploded() {\n        return hasExploded;\n    }\n    \n    public double getExplosionRadius() {\n        return EXPLOSION_RADIUS;\n    }\n} ",
      "NormalZombie.java": "import java.awt.*;\nimport java.awt.geom.*;\n\npublic class NormalZombie extends Zombie {\n    public NormalZombie(Point2D.Double position) {\n        super(position, 100, 2, 5); \n        this.zombieSize = 50; \n    }\n    \n    @Override\n    public void draw(Graphics2D g2d) {\n        g2d.setColor(Color.GREEN);\n        g2d.fillOval(\n            (int)(position.x - zombieSize/2),\n            (int)(position.y - zombieSize/2),\n            zombieSize,\n            zombieSize\n        );\n    }\n} ",
      "MainMenu.java": "import java.awt.*;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport javax.swing.*;\n\npublic class MainMenu extends JFrame {\n    public MainMenu() {\n        setTitle(\"Zombie Shooter - Ana Menü\");\n        setSize(800, 600);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setLocationRelativeTo(null);\n        \n        \n        JPanel panel = new JPanel() {\n            @Override\n            protected void paintComponent(Graphics g) {\n                super.paintComponent(g);\n                setBackground(new Color(135, 206, 235)); \n            }\n        };\n        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));\n        panel.setBorder(BorderFactory.createEmptyBorder(50, 50, 50, 50));\n        \n        JLabel gameTitle = new JLabel(\"Top-Down-Shooter\");\n        gameTitle.setFont(new Font(\"Arial\", Font.BOLD, 56));\n        gameTitle.setAlignmentX(Component.CENTER_ALIGNMENT);\n        \n        JLabel title = new JLabel(\"Zombie Shooter\");\n        title.setFont(new Font(\"Arial\", Font.BOLD, 48));\n        title.setAlignmentX(Component.CENTER_ALIGNMENT);\n        \n        \n        JButton startButton = createMenuButton(\"Yeni Oyun\");\n        JButton continueButton = createMenuButton(\"Oyuna Devam Et\");\n        JButton leaderboardButton = createMenuButton(\"Sıralama Tablosu\");\n        JButton helpButton = createMenuButton(\"Nasıl Oynanır?\");\n        JButton exitButton = createMenuButton(\"Çıkış\");\n        \n        panel.add(Box.createRigidArea(new Dimension(0, 30)));\n        panel.add(gameTitle);\n        panel.add(Box.createRigidArea(new Dimension(0, 30)));\n        panel.add(title);\n        panel.add(Box.createRigidArea(new Dimension(0, 50)));\n        panel.add(startButton);\n        panel.add(Box.createRigidArea(new Dimension(0, 15)));\n        panel.add(continueButton);\n        panel.add(Box.createRigidArea(new Dimension(0, 15)));\n        panel.add(leaderboardButton);\n        panel.add(Box.createRigidArea(new Dimension(0, 15)));\n        panel.add(helpButton);\n        panel.add(Box.createRigidArea(new Dimension(0, 15)));\n        panel.add(exitButton);\n        \n        add(panel);\n        \n        setFocusable(true);\n        setVisible(true);\n    }\n    \n    private JButton createMenuButton(String text) {\n        JButton button = new JButton(text);\n        button.setFont(new Font(\"Arial\", Font.BOLD, 24));\n        button.setAlignmentX(Component.CENTER_ALIGNMENT);\n        button.setMaximumSize(new Dimension(300, 50));\n        \n        button.addActionListener(e -> {\n            switch(text) {\n                case \"Yeni Oyun\":\n                    Game.startNewGame();\n                    dispose();\n                    break;\n                case \"Oyuna Devam Et\":\n                    Game.loadSavedGame();\n                    dispose();\n                    break;\n                case \"Sıralama Tablosu\":\n                    showLeaderboard();\n                    break;\n                case \"Nasıl Oynanır?\":\n                    showHowToPlay();\n                    break;\n                case \"Çıkış\":\n                    System.exit(0);\n                    break;\n            }\n        });\n        \n        return button;\n    }\n    \n    private void showSaveDialog() {\n        String playerName = JOptionPane.showInputDialog(this, \n            \"İsminizi girin:\",\n            \"Oyunu Kaydet\",\n            JOptionPane.PLAIN_MESSAGE);\n            \n        if (playerName != null && !playerName.trim().isEmpty()) {\n            saveScore(playerName.trim(), 0); \n        }\n    }\n    \n    private void saveScore(String playerName, int score) {\n        try (FileWriter fw = new FileWriter(\"leaderboard.txt\", true)) {\n            fw.write(playerName + \",\" + score + \"\\n\");\n        } catch (IOException e) {\n            JOptionPane.showMessageDialog(this, \"Kayıt hatası: \" + e.getMessage());\n        }\n    }\n    \n    private void showLeaderboard() {\n        try {\n            String content = new String(Files.readAllBytes(Paths.get(\"leaderboard.txt\")));\n            JOptionPane.showMessageDialog(this,\n                content.isEmpty() ? \"Henüz kayıt yok\" : content,\n                \"Sıralama Tablosu\",\n                JOptionPane.PLAIN_MESSAGE);\n        } catch (IOException e) {\n            JOptionPane.showMessageDialog(this, \"Sıralama tablosu yüklenemedi.\");\n        }\n    }\n    \n    private void showHowToPlay() {\n        JOptionPane.showMessageDialog(this,\n            \"Kontroller:\\n\" +\n            \"W,A,S,D - Hareket\\n\" +\n            \"Mouse - Nişan Al\\n\" +\n            \"Sol Tık - Ateş Et\\n\" +\n            \"R - Mermi Doldur\\n\" +\n            \"1-5 - Silah Değiştir\\n\" +\n            \"P - Ara Menü\",\n            \"Nasıl Oynanır?\",\n            JOptionPane.PLAIN_MESSAGE);\n    }\n    \n    private void loadGame() {\n        dispose();\n        Game.loadSavedGame();\n    }\n} ",
      "Pistol.java": "import java.awt.Color;\nimport java.awt.geom.Point2D;\n\npublic class Pistol extends Weapon {\n    public Pistol() {\n        super(12, 120); \n        this.magazines = Integer.MAX_VALUE; \n    }\n    \n    @Override\n    public String getName() {\n        return \"Tabanca\";\n    }\n    \n    @Override\n    protected void createBullet(Point2D.Double position, double angle) {\n        bullets.add(new Bullet(position, angle, 10, 15, new Color(255, 255, 0))); \n    }\n} ",
      "GamePanel.java": "import java.awt.*;\nimport java.awt.event.*;\nimport java.awt.geom.Rectangle2D;\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport javax.swing.*;\n\npublic class GamePanel extends JPanel implements ActionListener, KeyListener, MouseListener, MouseMotionListener {\n    private Game game;\n    private Player player;\n    private WeaponManager weaponManager;\n    private ZombieManager zombieManager;\n    private Timer gameTimer;\n    private boolean isRunning = false;\n    private static ArrayList<AmmoPickup> ammoPickups = new ArrayList<>();\n    \n    public GamePanel(Game game, Player player, WeaponManager weaponManager, ZombieManager zombieManager) {\n        this.game = game;\n        this.player = player;\n        this.weaponManager = weaponManager;\n        this.zombieManager = zombieManager;\n        \n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.BLACK);\n        setFocusable(true);\n        \n        addKeyListener(this);\n        addMouseListener(this);\n        addMouseMotionListener(this);\n        \n        gameTimer = new Timer(16, this); \n        requestFocus(); \n    }\n    \n    public void startGameLoop() {\n        isRunning = true;\n        gameTimer.start();\n    }\n    \n    public void resetGame(Player player) {\n        this.player = player;\n        zombieManager.reset();\n        repaint();\n    }\n    \n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2d = (Graphics2D) g;\n        \n        \n        player.draw(g2d);\n        player.getCurrentWeapon().draw(g2d);\n        zombieManager.draw(g2d);\n        \n        for (AmmoPickup pickup : ammoPickups) {\n            pickup.draw(g2d);\n        }\n        \n        \n        drawUI(g2d);\n    }\n    \n    private void drawUI(Graphics2D g2d) {\n        g2d.setFont(new Font(\"Arial\", Font.BOLD, 14));\n        \n        \n        Weapon currentWeapon = player.getCurrentWeapon();\n        g2d.setColor(Color.WHITE);\n        g2d.drawString(\"Silah: \" + currentWeapon.getName(), 10, 20);\n        if (currentWeapon instanceof Pistol) {\n            g2d.drawString(\"Mermi: \" + currentWeapon.getCurrentAmmo() + \"/∞\", 10, 40);\n        } else {\n            g2d.drawString(\"Mermi: \" + currentWeapon.getCurrentAmmo() + \"/\" + currentWeapon.getMaxAmmo() \n                + \" (Şarjör: \" + currentWeapon.getMagazines() + \")\", 10, 40);\n        }\n        \n        \n        g2d.drawString(\"Can: \" + player.getHealth(), getWidth() - 100, 20);\n        g2d.drawString(\"Puan: \" + player.getScore(), getWidth() - 100, 40);\n        \n        \n        g2d.setColor(Color.RED);\n        g2d.drawString(\"Kalan Zombi: \" + zombieManager.getZombies().size(), getWidth()/2 - 50, 20);\n        g2d.drawString(\"Dalga: \" + zombieManager.getCurrentWave(), getWidth()/2 - 30, 40);\n        \n        \n        g2d.setColor(Color.YELLOW);\n        WeaponManager wm = WeaponManager.getInstance();\n        int currentIndex = wm.getCurrentWeaponIndex();\n        \n        int nextWeapon;\n        if (wm.isLastUnlockedWeapon(currentIndex)) {\n            nextWeapon = 1;\n        } else {\n            nextWeapon = wm.getNextWeaponIndex(currentIndex) + 1;\n        }\n        \n        g2d.drawString(\"Sonraki silaha geç (\" + nextWeapon + \")\", 10, getHeight() - 20);\n    }\n    \n    @Override\n    public void actionPerformed(ActionEvent e) {\n        if (isRunning) {\n            update();\n            repaint();\n        }\n    }\n    \n    private void update() {\n        player.update();\n        \n        player.getCurrentWeapon().update();\n        zombieManager.update(player.getPosition());\n        checkCollisions();\n    }\n    \n    private void checkCollisions() {\n        \n        Rectangle2D.Double playerBounds = new Rectangle2D.Double(\n            player.getPosition().x - Player.PLAYER_SIZE/2,\n            player.getPosition().y - Player.PLAYER_SIZE/2,\n            Player.PLAYER_SIZE,\n            Player.PLAYER_SIZE\n        );\n        \n        for (int i = ammoPickups.size() - 1; i >= 0; i--) {\n            AmmoPickup pickup = ammoPickups.get(i);\n            if (pickup.isActive() && pickup.getBounds().intersects(playerBounds)) {\n                WeaponManager.getInstance().addMagazineToWeapon(pickup.getWeaponType());\n                pickup.deactivate();\n                ammoPickups.remove(i);\n            }\n        }\n        \n        \n        for (Bullet bullet : player.getCurrentWeapon().bullets) {\n            if (!bullet.isActive()) continue;\n            \n            \n            for (Zombie zombie : zombieManager.getZombies()) {\n                if (zombie.getBounds().contains(bullet.getPosition())) {\n                    zombie.takeDamage(bullet.getDamage());\n                    bullet.deactivate();\n                    if (!zombie.isAlive()) {\n                        player.addScore(10);\n                    }\n                    break;\n                }\n            }\n        }\n        \n        \n        Rectangle2D.Double playerBounds2 = new Rectangle2D.Double(\n            player.getPosition().x - Player.PLAYER_SIZE/2,\n            player.getPosition().y - Player.PLAYER_SIZE/2,\n            Player.PLAYER_SIZE,\n            Player.PLAYER_SIZE\n        );\n        \n        for (Zombie zombie : zombieManager.getZombies()) {\n            if (playerBounds2.intersects(zombie.getBounds())) {\n                player.setHealth(player.getHealth() - zombie.getDamage());\n                if (player.getHealth() <= 0) {\n                    isRunning = false;\n                    showGameOverMenu();\n                }\n            }\n        }\n    }\n    \n    \n    @Override\n    public void keyPressed(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_P) {\n            isRunning = !isRunning;\n            if (!isRunning) {\n                showPauseMenu();\n            }\n        }\n        player.handleKeyPress(e.getKeyCode());\n    }\n    \n    @Override\n    public void keyReleased(KeyEvent e) {\n        player.handleKeyRelease(e.getKeyCode());\n    }\n    \n    @Override\n    public void keyTyped(KeyEvent e) {}\n    \n    \n    @Override\n    public void mousePressed(MouseEvent e) {\n        if (e.getButton() == MouseEvent.BUTTON1) {\n            Point mousePoint = e.getPoint();\n            player.shoot(mousePoint);\n            player.updateCurrentWeapon();\n            requestFocus();\n        }\n    }\n    \n    @Override\n    public void mouseReleased(MouseEvent e) {}\n    \n    @Override\n    public void mouseClicked(MouseEvent e) {}\n    \n    @Override\n    public void mouseEntered(MouseEvent e) {}\n    \n    @Override\n    public void mouseExited(MouseEvent e) {}\n    \n    \n    @Override\n    public void mouseMoved(MouseEvent e) {\n        player.aim(e.getPoint());\n    }\n    \n    @Override\n    public void mouseDragged(MouseEvent e) {\n        player.aim(e.getPoint());\n    }\n    \n    private void showPauseMenu() {\n        JDialog pauseDialog = new JDialog(game, \"Ara Menü\", true);\n        pauseDialog.setSize(600, 500);\n        pauseDialog.setLocationRelativeTo(this);\n        \n        JPanel panel = new JPanel();\n        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));\n        panel.setBackground(new Color(210, 180, 140)); \n        panel.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));\n        \n        JLabel scoreLabel = new JLabel(\"Mevcut Skor: \" + player.getScore());\n        scoreLabel.setFont(new Font(\"Arial\", Font.BOLD, 24));\n        scoreLabel.setAlignmentX(Component.CENTER_ALIGNMENT);\n        \n        String[] buttonTexts = {\n            \"Devam Et\", \"Kaydet\", \"Yükle\", \"Sıralama\",\n            \"Nasıl Oynanır?\", \"Ana Menüye Dön\", \"Çıkış\"\n        };\n        \n        panel.add(scoreLabel);\n        panel.add(Box.createRigidArea(new Dimension(0, 30)));\n        \n        for (String text : buttonTexts) {\n            JButton button = createPauseButton(text, pauseDialog);\n            panel.add(button);\n            panel.add(Box.createRigidArea(new Dimension(0, 15)));\n        }\n        \n        pauseDialog.add(panel);\n        pauseDialog.setVisible(true);\n    }\n    \n    private JButton createPauseButton(String text, JDialog dialog) {\n        JButton button = new JButton(text);\n        button.setFont(new Font(\"Arial\", Font.BOLD, 20));\n        button.setAlignmentX(Component.CENTER_ALIGNMENT);\n        button.setMaximumSize(new Dimension(250, 40));\n        \n        button.addActionListener(e -> {\n            switch(text) {\n                case \"Devam Et\":\n                    isRunning = true;\n                    player.resetMovement();\n                    dialog.dispose();\n                    break;\n                case \"Kaydet\":\n                    saveGame();\n                    break;\n                case \"Yükle\":\n                    dialog.dispose();\n                    loadGame();\n                    break;\n                case \"Sıralama\":\n                    showLeaderboard();\n                    break;\n                case \"Nasıl Oynanır?\":\n                    showHowToPlay();\n                    break;\n                case \"Ana Menüye Dön\":\n                    int confirm = JOptionPane.showConfirmDialog(this,\n                        \"Ana menüye dönerseniz oyununuz silinecektir. Onaylıyor musunuz?\",\n                        \"Uyarı\",\n                        JOptionPane.YES_NO_OPTION,\n                        JOptionPane.WARNING_MESSAGE);\n                    if (confirm == JOptionPane.YES_OPTION) {\n                        game.dispose();\n                        new MainMenu();\n                    } else {\n                        showPauseMenu();\n                    }\n                    break;\n                case \"Çıkış\":\n                    System.exit(0);\n                    break;\n            }\n        });\n        \n        return button;\n    }\n    \n    private void saveGame() {\n        SwingUtilities.invokeLater(() -> {\n            try {\n                GameState state = new GameState(player, zombieManager.getCurrentWave(), player.getScore());\n                try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"game_save.dat\"))) {\n                    oos.writeObject(state);\n                    JOptionPane.showMessageDialog(this, \"Oyun kaydedildi!\");\n                    game.dispose();\n                    new MainMenu();\n                }\n            } catch (IOException e) {\n                JOptionPane.showMessageDialog(this, \"Kayıt hatası: \" + e.getMessage());\n            }\n        });\n    }\n    \n    private void loadGame() {\n        SwingUtilities.invokeLater(() -> {\n            try {\n                // Önce mevcut skoru kaydet\n                String playerName = JOptionPane.showInputDialog(this, \n                    \"İsminizi girin:\",\n                    \"Skor Kaydetme\",\n                    JOptionPane.PLAIN_MESSAGE);\n                \n                if (playerName != null && !playerName.trim().isEmpty()) {\n                    LeaderboardManager.saveScore(playerName.trim(), player.getScore());\n                }\n                \n                // Sonra kayıtlı oyunu yükle\n                try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"game_save.dat\"))) {\n                    GameState state = (GameState) ois.readObject();\n                    \n                    player = state.getPlayer();\n                    zombieManager.setCurrentWave(state.getCurrentWave());\n                    player.setScore(state.getScore());\n                    WeaponManager.getInstance().setWeapons(state.getWeapons());\n                    ZombieManager.getInstance().setZombies(state.getZombies());\n                    resetGame(player);\n                    int response = JOptionPane.showConfirmDialog(this,\n                        \"Oyun başarıyla yüklendi!\",\n                        \"Yükleme Başarılı\",\n                        JOptionPane.DEFAULT_OPTION);\n                    \n                    game.dispose();\n                    new MainMenu();\n                }\n            } catch (FileNotFoundException e) {\n                JOptionPane.showMessageDialog(this, \"Kayıtlı oyun bulunamadı!\");\n                game.dispose();\n                new MainMenu();\n            } catch (IOException | ClassNotFoundException e) {\n                JOptionPane.showMessageDialog(this, \"Yükleme hatası!\");\n                game.dispose();\n                new MainMenu();\n            }\n        });\n    }\n    \n    private void showLeaderboard() {\n        try {\n            String content = new String(Files.readAllBytes(Paths.get(\"leaderboard.txt\")));\n            JOptionPane.showMessageDialog(this,\n                content.isEmpty() ? \"Henüz kayıt yok\" : content,\n                \"Sıralama Tablosu\",\n                JOptionPane.PLAIN_MESSAGE);\n        } catch (IOException e) {\n            JOptionPane.showMessageDialog(this, \"Sıralama tablosu yüklenemedi.\");\n        }\n    }\n    \n    private void showHowToPlay() {\n        JOptionPane.showMessageDialog(this,\n            \"Kontroller:\\n\" +\n            \"W,A,S,D - Hareket\\n\" +\n            \"Mouse - Nişan Al\\n\" +\n            \"Sol Tık - Ateş Et\\n\" +\n            \"R - Mermi Doldur\\n\" +\n            \"1-5 - Silah Değiştir\\n\" +\n            \"P - Ara Menü\",\n            \"Nasıl Oynanır?\",\n            JOptionPane.PLAIN_MESSAGE);\n    }\n    \n    private void showGameOverMenu() {\n        JDialog gameOverDialog = new JDialog(game, \"Oyun Bitti!\", true);\n        gameOverDialog.setSize(400, 300);\n        gameOverDialog.setLocationRelativeTo(this);\n        \n        JPanel panel = new JPanel();\n        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));\n        panel.setBackground(new Color(50, 0, 0)); \n        panel.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));\n        \n        JLabel gameOverLabel = new JLabel(\"Oyunu Kaybettiniz!\");\n        gameOverLabel.setFont(new Font(\"Arial\", Font.BOLD, 36));\n        gameOverLabel.setForeground(Color.RED);\n        gameOverLabel.setAlignmentX(Component.CENTER_ALIGNMENT);\n        \n        JLabel scoreLabel = new JLabel(\"Puan: \" + player.getScore());\n        scoreLabel.setFont(new Font(\"Arial\", Font.BOLD, 32));\n        scoreLabel.setForeground(Color.WHITE);\n        scoreLabel.setAlignmentX(Component.CENTER_ALIGNMENT);\n        \n        String[] buttonTexts = {\"Oyunu Yükle\", \"Ana Menüye Dön\", \"Çıkış\"};\n        \n        panel.add(gameOverLabel);\n        panel.add(Box.createRigidArea(new Dimension(0, 20)));\n        panel.add(scoreLabel);\n        panel.add(Box.createRigidArea(new Dimension(0, 30)));\n        \n        for (String text : buttonTexts) {\n            JButton button = new JButton(text);\n            button.setFont(new Font(\"Arial\", Font.BOLD, 20));\n            button.setAlignmentX(Component.CENTER_ALIGNMENT);\n            button.setMaximumSize(new Dimension(200, 40));\n            \n            button.addActionListener(e -> {\n                switch(text) {\n                    case \"Oyunu Yükle\":\n                        gameOverDialog.dispose();\n                        loadGame();\n                        break;\n                    case \"Ana Menüye Dön\":\n                        int confirmMenu = JOptionPane.showConfirmDialog(this,\n                            \"Ana menüye dönerseniz oyununuz kaydedilmeyecektir. Onaylıyor musunuz?\",\n                            \"Uyarı\",\n                            JOptionPane.YES_NO_OPTION,\n                            JOptionPane.WARNING_MESSAGE);\n                        if (confirmMenu == JOptionPane.YES_OPTION) {\n                            game.dispose();\n                            new MainMenu();\n                            gameOverDialog.dispose();\n                        }\n                        break;\n                    case \"Çıkış\":\n                        int confirmExit = JOptionPane.showConfirmDialog(this,\n                            \"Çıkış yaparsanız oyununuz kaydedilmeyecektir. Onaylıyor musunuz?\",\n                            \"Uyarı\",\n                            JOptionPane.YES_NO_OPTION,\n                            JOptionPane.WARNING_MESSAGE);\n                        if (confirmExit == JOptionPane.YES_OPTION) {\n                            gameOverDialog.dispose();\n                            System.exit(0);\n                        }\n                        break;\n                }\n            });\n            \n            panel.add(button);\n            panel.add(Box.createRigidArea(new Dimension(0, 15)));\n        }\n        \n        gameOverDialog.add(panel);\n        gameOverDialog.setVisible(true);\n    }\n    \n    public static void addAmmoPickup(AmmoPickup pickup) {\n        ammoPickups.add(pickup);\n    }\n} ",
      "FastZombie.java": "import java.awt.*;\nimport java.awt.geom.*;\n\npublic class FastZombie extends Zombie {\n    public FastZombie(Point2D.Double position) {\n        super(position, 50, 4, 3); \n        this.zombieSize = 40; \n    }\n    \n    @Override\n    public void draw(Graphics2D g2d) {\n        g2d.setColor(Color.RED);\n        g2d.fillOval(\n            (int)(position.x - zombieSize/2),\n            (int)(position.y - zombieSize/2),\n            zombieSize,\n            zombieSize\n        );\n    }\n} ",
      "LeaderboardManager.java": "import java.io.*;\nimport java.nio.file.*;\nimport java.util.*;\n\npublic class LeaderboardManager {\n    private static final String LEADERBOARD_FILE = \"leaderboard.txt\";\n    \n    public static void saveScore(String playerName, int score) {\n        try {\n            \n            List<ScoreEntry> scores = readScores();\n            \n            \n            scores.add(new ScoreEntry(playerName, score));\n            \n            \n            Collections.sort(scores, Collections.reverseOrder());\n            \n            \n            try (PrintWriter writer = new PrintWriter(new FileWriter(LEADERBOARD_FILE))) {\n                for (ScoreEntry entry : scores) {\n                    writer.println(entry.playerName + \",\" + entry.score);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static String getLeaderboard() {\n        try {\n            List<ScoreEntry> scores = readScores();\n            if (scores.isEmpty()) {\n                return \"Henüz kayıt yok\";\n            }\n            \n            StringBuilder sb = new StringBuilder();\n            sb.append(\"En Yüksek Skorlar:\\n\\n\");\n            for (int i = 0; i < Math.min(10, scores.size()); i++) {\n                ScoreEntry entry = scores.get(i);\n                sb.append(String.format(\"%d. %s: %d\\n\", i + 1, entry.playerName, entry.score));\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            return \"Sıralama tablosu yüklenemedi.\";\n        }\n    }\n    \n    private static List<ScoreEntry> readScores() throws IOException {\n        List<ScoreEntry> scores = new ArrayList<>();\n        if (Files.exists(Paths.get(LEADERBOARD_FILE))) {\n            List<String> lines = Files.readAllLines(Paths.get(LEADERBOARD_FILE));\n            for (String line : lines) {\n                String[] parts = line.split(\",\");\n                if (parts.length == 2) {\n                    scores.add(new ScoreEntry(parts[0], Integer.parseInt(parts[1])));\n                }\n            }\n        }\n        return scores;\n    }\n    \n    private static class ScoreEntry implements Comparable<ScoreEntry> {\n        String playerName;\n        int score;\n        \n        ScoreEntry(String playerName, int score) {\n            this.playerName = playerName;\n            this.score = score;\n        }\n        \n        @Override\n        public int compareTo(ScoreEntry other) {\n            return Integer.compare(this.score, other.score);\n        }\n    }\n} ",
      "Rifle.java": "import java.awt.Color;\nimport java.awt.geom.Point2D;\n\npublic class Rifle extends Weapon {\n    public Rifle() {\n        super(30, 600); \n    }\n    \n    @Override\n    public String getName() {\n        return \"Piyade Tüfeği\";\n    }\n    \n    @Override\n    protected void createBullet(Point2D.Double position, double angle) {\n        double spread = Math.toRadians(30); \n        double randomSpread = (Math.random() - 0.5) * spread; \n        double finalAngle = angle + randomSpread;\n        bullets.add(new Bullet(position, finalAngle, 15, 20, Color.RED)); \n    }\n} ",
      "WeaponManager.java": "import java.awt.Graphics2D;\nimport java.util.ArrayList;\n\npublic class WeaponManager {\n    private static WeaponManager instance;\n    private ArrayList<Weapon> weapons;\n    private int currentWeaponIndex = 0;\n    private boolean[] unlockedWeapons;\n    \n    public static WeaponManager getInstance() {\n        if (instance == null) {\n            instance = new WeaponManager();\n        }\n        return instance;\n    }\n    \n    private WeaponManager() {\n        weapons = new ArrayList<>();\n        initializeWeapons();\n        unlockedWeapons = new boolean[5]; // 5 silah için\n        unlockedWeapons[0] = true; // İlk silah başlangıçta açık\n    }\n    \n    private void initializeWeapons() {\n        // Sadece pistol ile başla\n        weapons.add(new Pistol());\n    }\n    \n    public void update() {\n        for (Weapon weapon : weapons) {\n            weapon.update();\n        }\n    }\n    \n    public void draw(Graphics2D g2d) {\n        for (Weapon weapon : weapons) {\n            weapon.draw(g2d);\n        }\n    }\n    \n    public void unlockWeaponForWave(int wave) {\n        // Dalga numarasına göre yeni silahları aç\n        switch(wave) {\n            case 2: \n                if (!hasWeapon(\"Rifle\")) {\n                    weapons.add(new Rifle());\n                }\n                break;\n            case 4: \n                if (!hasWeapon(\"Shotgun\")) {\n                    weapons.add(new Shotgun());\n                }\n                break;\n            case 6: \n                if (!hasWeapon(\"Sniper\")) {\n                    weapons.add(new Sniper());\n                }\n                break;\n            case 11: \n                if (!hasWeapon(\"RocketLauncher\")) {\n                    weapons.add(new RocketLauncher());\n                }\n                break;\n        }\n        \n        if (Game.getInstance() != null) {\n            Game.getInstance().getPlayer().updateCurrentWeapon();\n        }\n    }\n    \n    private boolean hasWeapon(String weaponName) {\n        for (Weapon weapon : weapons) {\n            if (weapon.getName().equals(weaponName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    public Weapon getCurrentWeapon() {\n        return weapons.get(currentWeaponIndex);\n    }\n    \n    public void nextWeapon() {\n        currentWeaponIndex = (currentWeaponIndex + 1) % weapons.size();\n        updatePlayerWeapon();\n    }\n    \n    public void previousWeapon() {\n        currentWeaponIndex--;\n        if (currentWeaponIndex < 0) currentWeaponIndex = weapons.size() - 1;\n        updatePlayerWeapon();\n    }\n    \n    private void updatePlayerWeapon() {\n        \n        if (Game.getInstance() != null) {\n            Game.getInstance().getPlayer().updateCurrentWeapon();\n        }\n    }\n    \n    public void switchToWeapon(int index) {\n        if (index >= 0 && index < weapons.size()) {\n            currentWeaponIndex = index;\n            updatePlayerWeapon();\n        }\n    }\n    \n    public int getCurrentWeaponIndex() {\n        return currentWeaponIndex;\n    }\n    \n    public int getWeaponCount() {\n        return weapons.size();\n    }\n    \n    public int getUnlockedWeaponCount() {\n        return weapons.size();\n    }\n    \n    public Weapon getWeapon(int index) {\n        return index < weapons.size() ? weapons.get(index) : null;\n    }\n    \n    public void addMagazineToWeapon(String weaponName) {\n        for (Weapon weapon : weapons) {\n            if (weapon.getName().equals(weaponName)) {\n                weapon.addMagazine();\n                break;\n            }\n        }\n    }\n    \n    public ArrayList<Weapon> getWeapons() {\n        return weapons;\n    }\n    \n    public void setWeapons(ArrayList<Weapon> weapons) {\n        this.weapons = weapons;\n    }\n    \n    public void reset() {\n        weapons.clear();\n        initializeWeapons();\n        currentWeaponIndex = 0;\n        unlockedWeapons = new boolean[5];\n        unlockedWeapons[0] = true; // Sadece ilk silah açık\n    }\n    \n    public boolean isLastUnlockedWeapon(int index) {\n        return index == weapons.size() - 1;\n    }\n    \n    public int getNextWeaponIndex(int currentIndex) {\n        if (currentIndex >= weapons.size() - 1) {\n            return 0;\n        }\n        return currentIndex + 1;\n    }\n} ",
      "TankZombie.java": "import java.awt.*;\nimport java.awt.geom.*;\n\npublic class TankZombie extends Zombie {\n    public TankZombie(Point2D.Double position) {\n        super(position, 200, 1, 10); \n        this.zombieSize = 35; \n    }\n    \n    @Override\n    public void draw(Graphics2D g2d) {\n        g2d.setColor(Color.GRAY);\n        g2d.fillOval(\n            (int)(position.x - zombieSize/2),\n            (int)(position.y - zombieSize/2),\n            zombieSize,\n            zombieSize\n        );\n    }\n} ",
      "Game.java": "import java.io.*;\nimport javax.swing.*;\n\npublic class Game extends JFrame {\n    private static Game instance;\n    private GamePanel gamePanel;\n    private Player player;\n    private WeaponManager weaponManager;\n    private ZombieManager zombieManager;\n    private int currentWave = 1;\n    private int score = 0;\n    private JMenuBar menuBar;\n    \n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            new MainMenu();\n        });\n    }\n\n    public static Game getInstance() {\n        return instance;\n    }\n    \n    public Game() {\n        instance = this;\n        setTitle(\"Zombie Shooter\");\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setResizable(false);\n        \n        initializeComponents();\n        createMenuBar();\n        \n        pack();\n        setLocationRelativeTo(null);\n        setVisible(true);\n    }\n    \n    private void initializeComponents() {\n        player = new Player();\n        player.setHealth(200);  // Başlangıç canı 200\n        weaponManager = WeaponManager.getInstance();\n        zombieManager = ZombieManager.getInstance();\n        gamePanel = new GamePanel(this, player, weaponManager, zombieManager);\n        add(gamePanel);\n    }\n    \n    private void createMenuBar() {\n        menuBar = new JMenuBar();\n        JMenu gameMenu = new JMenu(\"Oyun\");\n        \n        JMenuItem saveItem = new JMenuItem(\"Kaydet\");\n        JMenuItem loadItem = new JMenuItem(\"Yükle\");\n        JMenuItem exitItem = new JMenuItem(\"Çıkış\");\n        \n        saveItem.addActionListener(e -> saveGame());\n        loadItem.addActionListener(e -> loadGame());\n        exitItem.addActionListener(e -> System.exit(0));\n        \n        gameMenu.add(saveItem);\n        gameMenu.add(loadItem);\n        gameMenu.addSeparator();\n        gameMenu.add(exitItem);\n        \n        menuBar.add(gameMenu);\n        setJMenuBar(menuBar);\n    }\n    \n    public void start() {\n        gamePanel.startGameLoop();\n    }\n    \n    private void saveGame() {\n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"game_save.dat\"))) {\n            GameState state = new GameState(player, currentWave, score);\n            oos.writeObject(state);\n            JOptionPane.showMessageDialog(this, \"Oyun kaydedildi!\");\n        } catch (IOException e) {\n            JOptionPane.showMessageDialog(this, \"Kayıt hatası: \" + e.getMessage());\n        }\n    }\n    \n    private void loadGame() {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"game_save.dat\"))) {\n            GameState state = (GameState) ois.readObject();\n            this.player = state.getPlayer();\n            this.currentWave = state.getCurrentWave();\n            this.score = state.getScore();\n            gamePanel.resetGame(player);\n            JOptionPane.showMessageDialog(this, \"Oyun yüklendi!\");\n        } catch (IOException | ClassNotFoundException e) {\n            JOptionPane.showMessageDialog(this, \"Yükleme hatası: \" + e.getMessage());\n        }\n    }\n    \n    public Player getPlayer() {\n        return player;\n    }\n    \n    public GamePanel getGamePanel() {\n        return gamePanel;\n    }\n    \n    public static void loadSavedGame() {\n        SwingUtilities.invokeLater(() -> {\n            try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"game_save.dat\"))) {\n                GameState state = (GameState) ois.readObject();\n                Game game = new Game();\n                game.player = state.getPlayer();\n                game.player.resetMovement();\n                game.currentWave = state.getCurrentWave();\n                game.score = state.getScore();\n                ZombieManager.getInstance().setZombies(state.getZombies());\n                ZombieManager.getInstance().setLoadedGame(true);\n                WeaponManager.getInstance().setWeapons(state.getWeapons());\n                game.gamePanel.resetGame(game.player);\n                game.start();\n            } catch (FileNotFoundException e) {\n                JOptionPane.showMessageDialog(null, \"Kayıtlı oyun bulunamadı!\");\n                new MainMenu();\n            } catch (IOException | ClassNotFoundException e) {\n                JOptionPane.showMessageDialog(null, \"Yükleme hatası!\");\n                new MainMenu();\n            }\n        });\n    }\n\n    public static void startNewGame() {\n        SwingUtilities.invokeLater(() -> {\n            Game game = new Game();\n            game.currentWave = 1;\n            game.score = 0;\n            game.player.setHealth(200);\n            ZombieManager.getInstance().reset();\n            ZombieManager.getInstance().setLoadedGame(false);\n            WeaponManager.getInstance().reset();\n            game.start();\n        });\n    }\n} ",
      "ZombieManager.java": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.util.ArrayList;\nimport java.util.Random;\n\npublic class ZombieManager {\n    private static ZombieManager instance;\n    private ArrayList<Zombie> zombies;\n    private final Random random;\n    private int currentWave;\n    private int zombiesPerWave;\n    private int spawnTimer;\n    private int zombiesSpawned;\n    private int zombiesKilled;\n    private boolean waveInProgress;\n    private boolean isLoadedGame = false;\n    \n    public static ZombieManager getInstance() {\n        if (instance == null) {\n            instance = new ZombieManager();\n        }\n        return instance;\n    }\n    \n    private ZombieManager() {\n        zombies = new ArrayList<>();\n        random = new Random();\n        currentWave = 0;\n        zombiesPerWave = 4;\n    }\n    \n    public void update(Point2D.Double playerPosition) {\n        for (int i = zombies.size() - 1; i >= 0; i--) {\n            Zombie zombie = zombies.get(i);\n            if (!zombie.isAlive()) {\n                zombies.remove(i);\n            } else {\n                zombie.update(playerPosition);\n            }\n        }\n        \n        if (zombies.isEmpty()) {\n            startNextWave();\n            WeaponManager.getInstance().unlockWeaponForWave(currentWave);\n        }\n    }\n    \n    public void draw(Graphics2D g2d) {\n        for (Zombie zombie : zombies) {\n            zombie.draw(g2d);\n        }\n    }\n    \n    private void startNextWave() {\n        currentWave++;\n        if (!isLoadedGame) {\n            zombiesPerWave += 1;\n        }\n        spawnZombies();\n        WeaponManager.getInstance().unlockWeaponForWave(currentWave);\n    }\n    \n    private void spawnZombies() {\n        for (int i = 0; i < zombiesPerWave; i++) {\n            spawnZombie();\n        }\n    }\n    \n    private void spawnZombie() {\n        \n        Point2D.Double spawnPoint = getRandomSpawnPoint();\n        Zombie zombie;\n        \n        \n        if (currentWave <= 3) {\n            zombie = new NormalZombie(spawnPoint);\n        } else {\n            \n            int maxZombieTypes = (currentWave - 1) / 3 + 1;\n            int zombieType = random.nextInt(maxZombieTypes);\n            \n            switch(zombieType) {\n                case 0:\n                    zombie = new NormalZombie(spawnPoint);\n                    break;\n                case 1:\n                    zombie = new FastZombie(spawnPoint);\n                    break;\n                case 2:\n                    zombie = new TankZombie(spawnPoint);\n                    break;\n                case 3:\n                    zombie = new ExplodingZombie(spawnPoint);\n                    break;\n                default:\n                    zombie = new NormalZombie(spawnPoint);\n            }\n        }\n        \n        zombies.add(zombie);\n    }\n    \n    private Point2D.Double getRandomSpawnPoint() {\n        \n        int side = random.nextInt(4);\n        double x, y;\n        \n        switch (side) {\n            case 0: \n                x = random.nextDouble() * 800;\n                y = -50;\n                break;\n            case 1: \n                x = 850;\n                y = random.nextDouble() * 600;\n                break;\n            case 2: \n                x = random.nextDouble() * 800;\n                y = 650;\n                break;\n            default: \n                x = -50;\n                y = random.nextDouble() * 600;\n                break;\n        }\n        \n        return new Point2D.Double(x, y);\n    }\n    \n    public void reset() {\n        zombies.clear();\n        currentWave = 0;\n        spawnTimer = 0;\n        zombiesSpawned = 0;\n        zombiesKilled = 0;\n        waveInProgress = false;\n        zombiesPerWave = 4;\n    }\n    \n    public ArrayList<Zombie> getZombies() {\n        return new ArrayList<>(zombies);\n    }\n    \n    public int getCurrentWave() {\n        return currentWave;\n    }\n    \n    public void setCurrentWave(int wave) {\n        this.currentWave = wave;\n    }\n    \n    public void setZombies(ArrayList<Zombie> zombies) {\n        this.zombies = zombies;\n        isLoadedGame = true;\n    }\n    \n    public void setLoadedGame(boolean loaded) {\n        isLoadedGame = loaded;\n    }\n} ",
      "AmmoPickup.java": "import java.awt.*;\nimport java.awt.geom.*;\n\npublic class AmmoPickup {\n    private Point2D.Double position;\n    private String weaponType;\n    private boolean isActive = true;\n    private static final int SIZE = 15;\n    \n    public AmmoPickup(Point2D.Double position, String weaponType) {\n        this.position = position;\n        this.weaponType = weaponType;\n    }\n    \n    public void draw(Graphics2D g2d) {\n        if (!isActive) return;\n        \n        g2d.setColor(getColorForWeapon());\n        g2d.fillRect((int)(position.x - SIZE/2), (int)(position.y - SIZE/2), SIZE, SIZE);\n    }\n    \n    private Color getColorForWeapon() {\n        switch(weaponType) {\n            case \"Rifle\": return Color.RED;\n            case \"Shotgun\": return Color.ORANGE;\n            case \"Sniper\": return Color.BLUE;\n            default: return Color.WHITE;\n        }\n    }\n    \n    public Rectangle2D.Double getBounds() {\n        return new Rectangle2D.Double(\n            position.x - SIZE/2,\n            position.y - SIZE/2,\n            SIZE,\n            SIZE\n        );\n    }\n    \n    public String getWeaponType() { return weaponType; }\n    public boolean isActive() { return isActive; }\n    public void deactivate() { isActive = false; }\n} ",
      "RocketLauncher.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.geom.Point2D;\n\npublic class RocketLauncher extends Weapon {\n    private static final int EXPLOSION_RADIUS = 30;\n    private static final int EXPLOSION_DAMAGE = 50;\n    \n    public RocketLauncher() {\n        super(1, 10); // 1 mermi, dakikada 10 atış\n    }\n    \n    @Override\n    public String getName() {\n        return \"Roketatar\";\n    }\n    \n    @Override\n    protected void createBullet(Point2D.Double position, double angle) {\n        Bullet rocket = new Bullet(position, angle, EXPLOSION_DAMAGE, 8, Color.RED) {\n            @Override\n            public void draw(Graphics2D g2d) {\n                super.draw(g2d);\n                // Roket efekti\n                g2d.setColor(new Color(255, 140, 0, 150));\n                g2d.fillOval(\n                    (int)(position.x - 5),\n                    (int)(position.y - 5),\n                    10,\n                    10\n                );\n            }\n            \n            @Override\n            public void update() {\n                super.update();\n                // Her güncelleme sırasında etraftaki zombileri kontrol et\n                if (isActive()) {\n                    for (Zombie zombie : ZombieManager.getInstance().getZombies()) {\n                        if (zombie != null && zombie.isAlive()) {\n                            Point2D.Double zombiePos = zombie.getPosition();\n                            if (zombiePos != null) {\n                                double dx = zombiePos.x - position.x;\n                                double dy = zombiePos.y - position.y;\n                                double distance = Math.sqrt(dx * dx + dy * dy);\n                                if (distance <= EXPLOSION_RADIUS) {\n                                    zombie.takeDamage(EXPLOSION_DAMAGE);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        bullets.add(rocket);\n    }\n} ",
      "Player.java": "import java.awt.*;\nimport java.awt.event.KeyEvent;\nimport java.awt.geom.*;\nimport java.io.Serializable;\n\npublic class Player implements Serializable {\n    private Point2D.Double position;\n    private double angle;\n    private int health;\n    private int score;\n    private Weapon currentWeapon;\n    public static final int PLAYER_SIZE = 30;\n    private static final double MOVE_SPEED = 5.0;\n    private boolean movingUp, movingDown, movingLeft, movingRight;\n    \n    public Player() {\n        position = new Point2D.Double(400, 300);\n        angle = 0;\n        health = 200;\n        score = 0;\n        currentWeapon = WeaponManager.getInstance().getCurrentWeapon(); \n        movingUp = movingDown = movingLeft = movingRight = false;\n    }\n    \n    public void update() {\n        \n        if (movingUp) position.y -= MOVE_SPEED;\n        if (movingDown) position.y += MOVE_SPEED;\n        if (movingLeft) position.x -= MOVE_SPEED;\n        if (movingRight) position.x += MOVE_SPEED;\n        \n        \n        position.x = Math.max(PLAYER_SIZE/2, Math.min(800 - PLAYER_SIZE/2, position.x));\n        position.y = Math.max(PLAYER_SIZE/2, Math.min(600 - PLAYER_SIZE/2, position.y));\n    }\n    \n    public void draw(Graphics2D g2d) {\n        AffineTransform old = g2d.getTransform();\n        g2d.translate(position.x, position.y);\n        g2d.rotate(angle);\n        \n        \n        g2d.setColor(Color.BLUE);\n        g2d.fillOval(-PLAYER_SIZE/2, -PLAYER_SIZE/2, PLAYER_SIZE, PLAYER_SIZE);\n        \n        g2d.setTransform(old);\n    }\n    \n    public void handleKeyPress(int keyCode) {\n        switch (keyCode) {\n            case KeyEvent.VK_W: movingUp = true; break;\n            case KeyEvent.VK_S: movingDown = true; break;\n            case KeyEvent.VK_A: movingLeft = true; break;\n            case KeyEvent.VK_D: movingRight = true; break;\n            case KeyEvent.VK_R: if (currentWeapon != null) currentWeapon.reload(); break;\n            case KeyEvent.VK_Q: WeaponManager.getInstance().previousWeapon(); break;\n            case KeyEvent.VK_E: WeaponManager.getInstance().nextWeapon(); break;\n            case KeyEvent.VK_1: WeaponManager.getInstance().switchToWeapon(0); break;\n            case KeyEvent.VK_2: WeaponManager.getInstance().switchToWeapon(1); break;\n            case KeyEvent.VK_3: WeaponManager.getInstance().switchToWeapon(2); break;\n            case KeyEvent.VK_4: WeaponManager.getInstance().switchToWeapon(3); break;\n            case KeyEvent.VK_5: WeaponManager.getInstance().switchToWeapon(4); break;\n        }\n    }\n    \n    public void handleKeyRelease(int keyCode) {\n        switch (keyCode) {\n            case KeyEvent.VK_W: movingUp = false; break;\n            case KeyEvent.VK_S: movingDown = false; break;\n            case KeyEvent.VK_A: movingLeft = false; break;\n            case KeyEvent.VK_D: movingRight = false; break;\n        }\n    }\n    \n    public void aim(Point target) {\n        double dx = target.x - position.x;\n        double dy = target.y - position.y;\n        angle = Math.atan2(dy, dx);\n    }\n    \n    public void shoot(Point target) {\n        if (currentWeapon != null) {\n            currentWeapon.shoot(position, angle);\n        }\n    }\n    \n    public void updateCurrentWeapon() {\n        currentWeapon = WeaponManager.getInstance().getCurrentWeapon();\n    }\n    \n    public void resetMovement() {\n        movingUp = false;\n        movingDown = false;\n        movingLeft = false;\n        movingRight = false;\n    }\n    \n    // Getter ve Setter metodları\n    public Point2D.Double getPosition() { return position; }\n    public Weapon getCurrentWeapon() { return currentWeapon; }\n    public int getHealth() { return health; }\n    public void setHealth(int health) { this.health = health; }\n    public int getScore() { return score; }\n    public void addScore(int points) { this.score += points; }\n    public void setScore(int score) { this.score = score; }\n} ",
      "GameState.java": "import java.io.Serializable;\nimport java.util.ArrayList;\n\npublic class GameState implements Serializable {\n    private Player player;\n    private int currentWave;\n    private int score;\n    private ArrayList<Zombie> zombies;\n    private ArrayList<Weapon> weapons;\n    private int remainingZombies;\n    \n    public GameState(Player player, int currentWave, int score) {\n        this.player = player;\n        this.currentWave = currentWave;\n        this.score = score;\n        this.zombies = ZombieManager.getInstance().getZombies();\n        this.weapons = WeaponManager.getInstance().getWeapons();\n        this.remainingZombies = zombies.size();\n    }\n    \n    public Player getPlayer() { return player; }\n    public int getCurrentWave() { return currentWave; }\n    public int getScore() { return score; }\n    public ArrayList<Zombie> getZombies() { return zombies; }\n    public ArrayList<Weapon> getWeapons() { return weapons; }\n    public int getRemainingZombies() { return remainingZombies; }\n} "
    },
    {
      "id": "4380745",
      "Sound.java": "package Bil211Game2.Game.Main;\n\nimport java.net.URL;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport javax.sound.sampled.FloatControl;\nimport javax.sound.sampled.LineEvent;\n\npublic class Sound implements Runnable {\n    // Sound Thread ve durumu\n    private Thread soundThread;\n    private boolean running = false;\n    \n    // Komut kuyrukları\n    private BlockingQueue<SoundCommand> commandQueue = new LinkedBlockingQueue<>();\n    \n    // Ses URL'leri\n    private URL[] soundURL = new URL[30];\n    \n    // Müzik için Clip\n    private Clip musicClip;\n    \n    // Ses ayarları\n    private float volume = 0.5f;\n    \n    // Ses sabitleri\n    public static final int TITLE_SCREEN_MUSIC = 0;\n    public static final int PHASE1_MUSIC = 1;\n    public static final int PHASE3_MUSIC = 2;\n    public static final int PHASE5_MUSIC = 3;\n    public static final int PHASE7_MUSIC = 4;\n    public static final int PHASE10_MUSIC = 5;\n    \n    // Ses efektleri\n    public static final int ACID_ZOMBIE_ACID_SOUND = 13;\n    public static final int PISTOL_SOUND = 14;\n    public static final int RIFLE_SOUND = 15;\n    public static final int SHOTGUN_SOUND = 16;\n    public static final int SNIPER_SOUND = 17;\n    public static final int ROCKET_SOUND = 18;\n    public static final int ROCKET_BANG_SOUND = 19;\n    public static final int ZOMBIE_HURT = 20;\n    public static final int PLAYER_HURT = 21;\n    public static final int FANFARE_SOUND = 22;\n\n    public Sound() {\n        // Ses dosyalarını yükle\n        loadSounds();\n        \n        // Sound thread'i başlat\n        startSoundThread();\n    }\n    \n    private void loadSounds() {\n        soundURL[TITLE_SCREEN_MUSIC] = getClass().getResource(\"/Bil211Game2/Resources/Sound/Music/Halls of the Undead - Kevin MacLeod.wav\");\n        soundURL[PHASE1_MUSIC] = getClass().getResource(\"/Bil211Game2/Resources/Sound/Music/TheWasteland.wav\");\n        soundURL[PHASE3_MUSIC] = getClass().getResource(\"/Bil211Game2/Resources/Sound/Music/TheWasteland.wav\");\n        soundURL[PHASE5_MUSIC] = getClass().getResource(\"/Bil211Game2/Resources/Sound/Music/TheWasteland.wav\");\n        soundURL[PHASE7_MUSIC] = getClass().getResource(\"/Bil211Game2/Resources/Sound/Music/TheWasteland.wav\");\n        soundURL[PHASE10_MUSIC] = getClass().getResource(\"/Bil211Game2/Resources/Sound/Music/TheWasteland.wav\");\n\n        soundURL[ACID_ZOMBIE_ACID_SOUND] = getClass().getResource(\"/Bil211Game2/Resources/Sound/SE/315846__gneube__zombie-roar.wav\");\n        soundURL[PISTOL_SOUND] = getClass().getResource(\"/Bil211Game2/Resources/Sound/SE/627087clutvhsilenced-pistol-shot.wav\");\n        soundURL[RIFLE_SOUND] = getClass().getResource(\"/Bil211Game2/Resources/Sound/SE/404561__superphat__assaultrifle2.wav\");\n        soundURL[SHOTGUN_SOUND] = getClass().getResource(\"/Bil211Game2/Resources/Sound/SE/564480__lumikon__shotgun-shot-sfx.wav\");\n        soundURL[SNIPER_SOUND] = getClass().getResource(\"/Bil211Game2/Resources/Sound/SE/182051qubodupsniper-rifle-shot-sound-effect.wav\");\n        soundURL[ROCKET_SOUND] = getClass().getResource(\"/Bil211Game2/Resources/Sound/SE/517169__mrthenoronha__rocket-launcher-1-8-bit.wav\");\n        soundURL[ROCKET_BANG_SOUND] = getClass().getResource(\"/Bil211Game2/Resources/Sound/SE/268557cydonexplosion001.wav\");\n        soundURL[ZOMBIE_HURT] = getClass().getResource(\"/Bil211Game2/Resources/Sound/SE/396797__scorpion67890__mutant-scream.wav\");\n        soundURL[PLAYER_HURT] = getClass().getResource(\"/Bil211Game2/Resources/Sound/SE/262279__dirtjm__grunts-male.wav\");\n        soundURL[FANFARE_SOUND] = getClass().getResource(\"/Bil211Game2/Resources/Sound/SE/401144fullmetaljedipiece-of-shred.wav\");\n    }\n    \n    // Thread'i başlat\n    private void startSoundThread() {\n        if (soundThread == null || !soundThread.isAlive()) {\n            running = true;\n            soundThread = new Thread(this);\n            soundThread.setDaemon(true);\n            soundThread.start();\n        }\n    }\n    \n    // Sound thread'inin çalışacağı metot\n    @Override\n    public void run() {\n        try {\n            while (running) {\n                try {\n                    // Kuyruktan bir komut al ve işle\n                    SoundCommand command = commandQueue.take();\n                    processCommand(command);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    // Komut işleme\n    private void processCommand(SoundCommand command) {\n        try {\n            switch (command.type) {\n                case LOAD_MUSIC:\n                    loadMusic(command.soundIndex);\n                    break;\n                case PLAY_EFFECT:\n                    playEffect(command.soundIndex);\n                    break;\n                case PLAY_MUSIC:\n                    playMusic();\n                    break;\n                case LOOP_MUSIC:\n                    loopMusic();\n                    break;\n                case STOP_MUSIC:\n                    stopMusic();\n                    break;\n                case SET_VOLUME:\n                    setVolumeInternal(command.volumeLevel);\n                    break;\n                case CLEANUP:\n                    cleanupResources();\n                    running = false; // Thread'i durdur\n                    break;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    // Müzik yükleme\n    private void loadMusic(int soundIndex) {\n        try {\n            if (musicClip != null) {\n                musicClip.stop();\n                musicClip.close();\n                musicClip = null;\n            }\n            \n            AudioInputStream ain = AudioSystem.getAudioInputStream(soundURL[soundIndex]);\n            musicClip = AudioSystem.getClip();\n            musicClip.open(ain);\n            \n            // Ses seviyesini ayarla\n            applyVolumeToClip(musicClip);\n            \n            // Stream'i kapat\n            ain.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    // Efekt çalma\n    private void playEffect(int soundIndex) {\n        try {\n            Clip effectClip = AudioSystem.getClip();\n            AudioInputStream ain = AudioSystem.getAudioInputStream(soundURL[soundIndex]);\n            effectClip.open(ain);\n            \n            // Ses seviyesini ayarla\n            applyVolumeToClip(effectClip);\n            \n            // Tamamlandığında kaynakları serbest bırak\n            effectClip.addLineListener(event -> {\n                if (event.getType() == LineEvent.Type.STOP) {\n                    effectClip.close();\n                }\n            });\n            \n            // Efekti çal\n            effectClip.start();\n            \n            // Stream'i kapat\n            ain.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    // Ses seviyesini Clip'e uygula\n    private void applyVolumeToClip(Clip clip) {\n        try {\n            if (clip.isControlSupported(FloatControl.Type.MASTER_GAIN)) {\n                FloatControl gainControl = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);\n                float dB = (float) (Math.log(volume) / Math.log(10.0) * 20.0);\n                gainControl.setValue(dB);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    // Müziği çal\n    private void playMusic() {\n        if (musicClip != null) {\n            musicClip.setFramePosition(0);\n            musicClip.start();\n        }\n    }\n    \n    // Müziği döngüye al\n    private void loopMusic() {\n        if (musicClip != null) {\n            musicClip.loop(Clip.LOOP_CONTINUOUSLY);\n        }\n    }\n    \n    // Müziği durdur\n    private void stopMusic() {\n        if (musicClip != null) {\n            musicClip.stop();\n        }\n    }\n    \n    // Ses seviyesini ayarla\n    private void setVolumeInternal(float level) {\n        volume = level;\n        if (musicClip != null) {\n            applyVolumeToClip(musicClip);\n        }\n    }\n    \n    // Kaynakları temizle\n    private void cleanupResources() {\n        if (musicClip != null) {\n            musicClip.stop();\n            musicClip.close();\n            musicClip = null;\n        }\n    }\n    \n    // -- PUBLIC API METHODS --\n    \n    // Müzik yükle (GamePanel'ın çağıracağı public metot)\n    public void setFile(int i) {\n        try {\n            commandQueue.put(new SoundCommand(CommandType.LOAD_MUSIC, i));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    // Ses efekti çal\n    public void playSE(int i) {\n        try {\n            commandQueue.put(new SoundCommand(CommandType.PLAY_EFFECT, i));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    // Müziği çal\n    public void play() {\n        try {\n            commandQueue.put(new SoundCommand(CommandType.PLAY_MUSIC));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    // Müziği döngüye al\n    public void loop() {\n        try {\n            commandQueue.put(new SoundCommand(CommandType.LOOP_MUSIC));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    // Müziği durdur\n    public void stop() {\n        try {\n            commandQueue.put(new SoundCommand(CommandType.STOP_MUSIC));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    // Ses seviyesini ayarla\n    public void setVolume(float volume) {\n        try {\n            commandQueue.put(new SoundCommand(CommandType.SET_VOLUME, volume));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    // Tüm kaynakları temizle ve thread'i durdur\n    public void cleanup() {\n        try {\n            commandQueue.put(new SoundCommand(CommandType.CLEANUP));\n            // Thread'in kapanmasını bekle\n            if (soundThread != null) {\n                soundThread.join(1000); // En fazla 1 saniye bekle\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    // -- HELPER CLASSES --\n    \n    // Komut tipleri\n    private enum CommandType {\n        LOAD_MUSIC, PLAY_EFFECT, PLAY_MUSIC, LOOP_MUSIC, STOP_MUSIC, SET_VOLUME, CLEANUP\n    }\n    \n    // Komut sınıfı\n    private class SoundCommand {\n        CommandType type;\n        int soundIndex;\n        float volumeLevel;\n        \n        // Standart komut constructor\n        SoundCommand(CommandType type) {\n            this.type = type;\n        }\n        \n        // Ses indeksi ile komut constructor\n        SoundCommand(CommandType type, int soundIndex) {\n            this.type = type;\n            this.soundIndex = soundIndex;\n        }\n        \n        // Ses seviyesi ile komut constructor\n        SoundCommand(CommandType type, float volumeLevel) {\n            this.type = type;\n            this.volumeLevel = volumeLevel;\n        }\n    }\n}",
      "UtilityTool.java": "package Bil211Game2.Game.Main;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\n\npublic class UtilityTool {\n    public static BufferedImage scaleImage(BufferedImage original, int width, int height){\n        BufferedImage  scaledImage = new BufferedImage(width, height, original.getType());\n        Graphics2D g2 = scaledImage.createGraphics();\n        g2.drawImage(original, 0, 0, width, height, null);\n        g2.dispose();\n        \n        return scaledImage;\n    }\n\n    public static double distanceCalculator(int p1X, int p1Y, int p2X, int p2Y){\n        return Math.sqrt((p2X - p1X)*(p2X - p1X)+(p2Y - p1Y)*(p2Y - p1Y));\n    }\n}\n",
      "GamePanel.java": "package Bil211Game2.Game.Main;\n\nimport java.awt.Canvas;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.GraphicsConfiguration;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.RenderingHints;\nimport java.awt.Toolkit;\nimport java.awt.Transparency;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferStrategy;\nimport java.awt.image.BufferedImage;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Random;\n\nimport Bil211Game2.Game.Entity.AcidZombie;\nimport Bil211Game2.Game.Entity.Entity;\nimport Bil211Game2.Game.Entity.Monster;\nimport Bil211Game2.Game.Entity.NormalZombie;\nimport Bil211Game2.Game.Main.Tile.TileManager;\nimport Bil211Game2.Game.Objects.Ammos.Ammo;\nimport Bil211Game2.Game.Objects.Ammos.PistolAmmo;\nimport Bil211Game2.Game.Objects.Ammos.RifleAmmo;\nimport Bil211Game2.Game.Objects.Ammos.RocketAmmo;\nimport Bil211Game2.Game.Objects.Ammos.ShotgunAmmo;\nimport Bil211Game2.Game.Objects.Ammos.SniperAmmo;\nimport Bil211Game2.Game.Objects.Animations.AnimationManager;\nimport Bil211Game2.Game.Entity.Player;\nimport Bil211Game2.Game.Entity.ReptileZombie;\nimport Bil211Game2.Game.Entity.TankZombie;\n\npublic class GamePanel extends Canvas implements Runnable{\n\n    final int originalTileSize = 16;\n    final int scale = 3;\n\n    public final int tileSize = originalTileSize * scale;\n    public final int maxScreenCol = 16;\n    public final int maxScreenRow = 12;\n    public final int screenWidth = tileSize*maxScreenCol;\n    public final int screenHeight = tileSize*maxScreenRow;\n\n    public final int maxWorldCol = 116;\n    public final int maxWorldRow = 112;\n\n    int FPS = 60;\n\n    // DOUBLE BUFFER VARIABLES\n    private BufferStrategy bufferStrategy;\n    private GraphicsConfiguration graphicsConfig;\n    private BufferedImage offscreenBuffer;\n\n    // SYSTEM\n    public Thread gameThread;\n    public KeyHandler keyH = new KeyHandler(this);\n    public MouseHandler mouseH = new MouseHandler(this);\n    public CollisionChecker cChecker = new CollisionChecker(this);\n    public UI ui = new UI(this);\n    public AssetSetter aSetter = new AssetSetter(this);\n    public EventHandler eHandler = new EventHandler(this);\n    public Sound music = new Sound();\n    public Sound se = new Sound();\n    public Sound seAmmo = new Sound();\n    public Sound seMonster = new Sound();\n    TileManager tileM = new TileManager(this);\n    private int frameCount = 0;\n    private long fpsTimer = 0;\n    public int fps = 0;\n    public boolean drawFPS = false;\n    public AnimationManager animationManager;\n\n    // ENTITY\n    public Player player = new Player(this, keyH, mouseH);\n    ArrayList<Entity> entityList = new ArrayList<>();\n    public ArrayList<Monster> monsters = new ArrayList<>();\n    public ArrayList<Ammo> ammos = new ArrayList<>();\n\n    // GAME STATE\n    public int gameState;\n    public final int titleState = 0;\n    public final int playState = 1;\n    public final int pauseState = 2;\n    public final int dialogState = 3;\n    public final int finishState = 4;\n    public boolean phaseFinished = false;\n    public boolean phaseFinishDraw = false;\n\n    private int phaseTransitionCounter = 0;\n    private final int PHASE_TRANSITION_DURATION = 90; \n\n    // PHASES\n    public final int phase1 = 0;\n    public final int phase2 = 1;\n    public final int phase3 = 2;\n    public final int phase4 = 3;\n    public final int phase5 = 4;\n    public final int phase6 = 5;\n    public final int phase7 = 6;\n    public final int phase8 = 7;\n    public final int phase9 = 8;\n    public final int phase10 = 9;\n    public int currentPhase;\n\n    // GamePanel sınıfına eklenecek yeni değişkenler\n    private boolean screenShakeActive = false;\n    private int screenShakeIntensity = 0;\n    private int screenShakeDuration = 0;\n    private int screenShakeTimer = 0;\n    private int shakeOffsetX = 0;\n    private int shakeOffsetY = 0;\n    private Random shakeRandom = new Random();\n\n    public GamePanel(){\n        this.setPreferredSize(new Dimension(screenWidth, screenHeight));\n        this.setBackground(Color.black);\n        this.setIgnoreRepaint(true);\n        this.addKeyListener(keyH);\n        this.addMouseListener(mouseH);\n        this.addMouseMotionListener(mouseH);\n        this.setFocusable(true);\n        animationManager = new AnimationManager(this);\n\n        GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();\n        graphicsConfig = env.getDefaultScreenDevice().getDefaultConfiguration();\n    }\n\n    public void setupAfterVisible() {\n        createBufferStrategy(3);\n        bufferStrategy = getBufferStrategy();\n        \n        offscreenBuffer = graphicsConfig.createCompatibleImage(\n                screenWidth, screenHeight, Transparency.OPAQUE);\n    }\n\n    public void setUpGame(){\n        gameState = titleState;\n        currentPhase = phase1 - 1;\n\n        playMusic(Sound.TITLE_SCREEN_MUSIC);\n    }\n\n    public void startGameThread(){\n        gameThread = new Thread(this);\n        gameThread.start();\n    }\n\n    @Override\n    public void run() {\n        double drawInternal = 1000000000/FPS;\n        double delta = 0;\n        long lastTime = System.nanoTime();\n        long currentTime;\n\n        fpsTimer = System.currentTimeMillis();\n\n        while(gameThread != null){\n            currentTime = System.nanoTime();\n            delta += (currentTime - lastTime)/drawInternal;\n            lastTime = currentTime;\n            \n            if(delta >= 1){\n                update();\n\n                // Çizim yap\n                render();\n\n                delta--;\n                frameCount++;\n\n                // Her saniye FPS'i güncelle\n                if(System.currentTimeMillis() - fpsTimer >= 1000) {\n                    fps = frameCount;\n                    frameCount = 0;\n                    fpsTimer = System.currentTimeMillis();\n                }\n            }\n        }\n    }\n\n    private void render() {\n        // BufferStrategy kontrol et\n        if (bufferStrategy == null) {\n            return;\n        }\n        \n        try {\n            Graphics2D g2 = offscreenBuffer.createGraphics();\n            try {\n                configureGraphicsQuality(g2);\n                \n                g2.setColor(Color.BLACK);\n                g2.fillRect(0, 0, screenWidth, screenHeight);\n                \n                if (gameState == titleState) {\n                    ui.draw(g2);\n                } else {\n\n                    // Oyun öğeleri için ekran sallama uygula\n                    AffineTransform originalTransform = g2.getTransform();\n                    \n                    if (screenShakeActive) {\n                        g2.translate(shakeOffsetX, shakeOffsetY);\n                    }\n\n                    // TILES\n                    tileM.draw(g2);\n\n                    // ADD TO ELEMENTS TO ARRAYLIST\n                    entityList.add(player);\n\n                    // MONSTERS ADDING\n                    for (int i = 0; i < monsters.size(); i++) {\n                        if (monsters.get(i) != null) {\n                            entityList.add(monsters.get(i));\n                        }\n                    }\n\n                    // SORT\n                    Collections.sort(entityList, new Comparator<Entity>() {\n                        @Override\n                        public int compare(Entity e1, Entity e2) {\n                            int result = Integer.compare(e1.worldY, e2.worldY);\n                            return result;\n                        }\n                    });\n\n                    // DRAW LIST\n                    for (int i = 0; i < entityList.size(); i++) {\n                        if (UtilityTool.distanceCalculator(entityList.get(i).worldX, entityList.get(i).worldY, player.worldX, player.worldY) < 10 * tileSize) {\n                            entityList.get(i).draw(g2);\n                        }\n                    }\n\n                    // EMPTY LIST\n                    entityList.clear();\n\n                    // AMMO'S DRAW\n                    for (Ammo ammo : ammos) {\n                        if (UtilityTool.distanceCalculator(ammo.worldX, ammo.worldY, player.worldX, player.worldY) < 8 * tileSize) {\n                            ammo.draw(g2);\n                        }\n                    }\n\n                    // UI çizmeden önce dönüşümü sıfırla (UI sallanmasın)\n                    g2.setTransform(originalTransform);\n\n                    animationManager.draw(g2);\n\n                    // UI\n                    ui.draw(g2);\n                }\n            } \n            finally {\n                g2.dispose();\n            }\n            \n            Graphics2D g = (Graphics2D) bufferStrategy.getDrawGraphics();\n            try {\n                g.drawImage(offscreenBuffer, 0, 0, null);\n            } \n            finally {\n                g.dispose();\n            }\n            \n            if (!bufferStrategy.contentsLost()) {\n                bufferStrategy.show();\n            }\n            \n            Toolkit.getDefaultToolkit().sync();\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void configureGraphicsQuality(Graphics2D g2) {\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n        g2.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);\n        g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);\n    }\n\n    public void update(){\n\n        if(gameState == playState){\n            updateScreenShake();\n            player.update();\n\n            // Handle phase transitions\n            if(phaseFinishDraw) {\n                phaseTransitionCounter++;\n                if(phaseTransitionCounter >= PHASE_TRANSITION_DURATION) {\n                    phaseFinishDraw = false;\n                    phaseTransitionCounter = 0;\n                }\n            }\n            else if(phaseChecker()){\n                phaseFinished = true;\n                phaseFinishDraw = true;\n                currentPhase++;\n                aSetter.setMonsterByPhase();\n\n                playSE(Sound.FANFARE_SOUND);\n            }\n\n            for(int i = 0; i < monsters.size(); i++){\n                if(monsters.get(i) != null){\n                    Monster monsterTemp = monsters.get(i);\n                    if(monsterTemp.alive && !monsterTemp.dying){\n                        monsterTemp.update();\n                    }\n                    else if(monsterTemp.dying){\n                        monsterTemp.updateDying();\n                    }\n                    if(!monsterTemp.alive){\n                        monsters.set(i, null);\n                    }\n                }\n            }\n\n            for(Ammo ammo : ammos) {\n                ammo.update();\n            }\n\n            animationManager.update();\n        }\n\n        if(gameState == pauseState){\n\n        }\n        \n    }\n\n    public void playMusic(int i){\n        music.setFile(i);\n        music.play();\n        music.loop();\n    }\n\n    public void stopMusic(){\n        music.stop();\n    }\n\n    public void playSE(int i){\n        se.setFile(i);\n        se.setVolume(0.5f);\n        se.play();\n    }\n\n    public void cleanupResources() {\n        // Ses kaynaklarını temizle\n        if (music != null) {\n            music.cleanup();\n        }\n        if (se != null) {\n            se.cleanup();\n        }\n    }\n\n    public boolean phaseChecker(){\n        boolean flag = true;\n\n        for(int i = 0; i < monsters.size(); i++){\n            if(monsters.get(i) != null){\n                flag = false;\n                break;\n            }\n        }\n\n        return flag;\n    }\n\n    public void resetGame(){\n        currentPhase = phase1 - 1;\n        player = new Player(this, keyH, mouseH);\n        monsters = new ArrayList<>();\n        ammos = new ArrayList<>();\n        aSetter.resetChances();\n\n        stopMusic();\n        playMusic(Sound.PHASE1_MUSIC);\n    }\n\n    public void saveGame(){\n        GameSaveData data = new GameSaveData();\n        data.playerX = player.worldX;\n        data.playerY = player.worldY;\n        data.playerLife = player.life;\n        data.playerScore = player.score;\n\n        for(Monster monster:monsters){\n            if(monster != null){\n                data.monstersX.add(monster.worldX);\n                data.monstersY.add(monster.worldY);\n                data.monstersLife.add(monster.life);\n\n                if(monster instanceof NormalZombie){\n                    data.monstersType.add(\"normal\");\n                }\n                else if(monster instanceof ReptileZombie){\n                    data.monstersType.add(\"reptile\");\n                }\n                else if(monster instanceof TankZombie){\n                    data.monstersType.add(\"tank\");\n                }\n                else{\n                    data.monstersType.add(\"acid\");\n                }\n            }\n        }\n\n        for(Ammo ammo:ammos){\n            if(ammo != null){\n                data.ammosX.add(ammo.worldX);\n                data.ammosY.add(ammo.worldY);\n                data.ammosXSpeed.add(ammo.speedX);\n                data.ammosYSpeed.add(ammo.speedY);\n\n                if(ammo instanceof PistolAmmo){\n                    data.ammosTypes.add(\"pistol\");\n                }\n                else if(ammo instanceof RifleAmmo){\n                    data.monstersType.add(\"rifle\");\n                }\n                else if(ammo instanceof ShotgunAmmo){\n                    data.ammosTypes.add(\"shotgun\");\n                }\n                else if(ammo instanceof SniperAmmo){\n                    data.ammosTypes.add(\"sniper\");\n                }\n                else{\n                    data.ammosTypes.add(\"rocket\");\n                }\n            }\n        }\n\n        for(int i = 0; i < 5; i++){\n            data.weaponsAmmo[i] = player.weapons[i].ammo;\n            data.weaponsMagazineAmmo[i] = player.weapons[i].magazineAmmo;\n        }\n\n        data.gamePhase = currentPhase;\n\n        data.normalZombieChance = aSetter.normalZombieChance;\n        data.reptileZombieChance = aSetter.reptileZombieChance;\n        data.tankZombieChance = aSetter.tankZombieChance;\n        data.acidZombieChance = aSetter.acidZombieChance;\n\n        try(ObjectOutputStream objOut = new ObjectOutputStream(new FileOutputStream(\"Bil211Game2/Resources/Save/lastGameSave.bin\"))){\n            objOut.writeObject(data);\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n\n    public void loadGame(){\n        resetGame();\n        try(ObjectInputStream objOut = new ObjectInputStream(new FileInputStream(\"Bil211Game2/Resources/Save/lastGameSave.bin\"))){\n            GameSaveData data = (GameSaveData)objOut.readObject();\n            player = new Player(this, keyH, mouseH);\n            player.worldX = data.playerX;\n            player.worldY = data.playerY;\n            player.life = data.playerLife;\n            player.score = data.playerScore;\n\n            monsters = new ArrayList<>();\n\n            for(int i = 0; i < data.monstersType.size(); i++){\n                if(data.monstersLife != null && data.monstersX != null\n                && data.monstersY != null && data.monstersType != null){\n                    switch(data.monstersType.get(i)){\n                        case \"normal\":\n                            monsters.add(new NormalZombie(this));\n                            break;\n                        case \"reptile\":\n                            monsters.add(new ReptileZombie(this));\n                            break;\n                        case \"tank\":\n                            monsters.add(new TankZombie(this));\n                            break;\n                        case \"acid\":\n                            monsters.add(new AcidZombie(this));\n                            break;\n                    }\n                    if(monsters.size() > i){\n                        monsters.get(i).worldX = data.monstersX.get(i);\n                        monsters.get(i).worldY = data.monstersY.get(i);\n                        monsters.get(i).life = data.monstersLife.get(i);\n                    }\n                }\n            }\n\n            ammos = new ArrayList<>();\n\n            for(int i = 0; i < data.ammosTypes.size(); i++){\n                if(data.ammosTypes != null && data.ammosX != null\n                && data.ammosXSpeed != null && data.ammosY != null\n                && data.ammosYSpeed != null){\n                    switch(data.ammosTypes.get(i)){\n                        case \"pistol\":\n                            ammos.add(new PistolAmmo(this));\n                            break;\n                        case \"rifle\":\n                            ammos.add(new RifleAmmo(this));\n                            break;\n                        case \"ahotgun\":\n                            ammos.add(new ShotgunAmmo(this));\n                            break;\n                        case \"sniper\":\n                            ammos.add(new SniperAmmo(this));\n                            break;\n                        case \"rocket\":\n                            ammos.add(new RocketAmmo(this));\n                            break;\n                    }\n                    ammos.get(i).worldX = data.ammosX.get(i);\n                    ammos.get(i).worldY = data.ammosY.get(i);\n                    ammos.get(i).speedX = data.ammosXSpeed.get(i);\n                    ammos.get(i).speedY = data.ammosYSpeed.get(i);\n                }\n            }\n\n            for(int i = 0; i < 5; i++){\n                player.weapons[i].ammo = data.weaponsAmmo[i];\n                player.weapons[i].magazineAmmo = data.weaponsMagazineAmmo[i];\n            }\n\n            currentPhase = data.gamePhase;\n\n            aSetter.loadChances(data.normalZombieChance, data.reptileZombieChance,\n            data.tankZombieChance, data.acidZombieChance);\n\n            gameState = playState;\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        } \n        catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        stopMusic();\n        playMusic(Sound.PHASE1_MUSIC);\n    }\n\n    public void testMode(){\n        resetGame();\n        player.worldX = 40*tileSize;\n        player.worldY = 40*tileSize;\n        for(int i = 0; i < 30; i++){\n            for(int j = 0; j < 30; j++){\n                NormalZombie zombie = new NormalZombie(this);\n                monsters.add(zombie);\n                zombie.worldX = (j+9)*tileSize;\n                zombie.worldY = (i+7)*tileSize;\n            }\n        }\n        currentPhase = phase10 + 1;\n        gameState = playState;\n    }\n\n    public void startScreenShake(int intensity, int duration) {\n        screenShakeActive = true;\n        screenShakeIntensity = intensity;\n        screenShakeDuration = duration;\n        screenShakeTimer = 0;\n    }\n\n    private void updateScreenShake() {\n        if (screenShakeActive) {\n            // Zamanla azalan bir yoğunluk hesapla\n            float currentIntensity = screenShakeIntensity * (1.0f - (float)screenShakeTimer / screenShakeDuration);\n            \n            // Rastgele ofsetler oluştur\n            shakeOffsetX = (int)(shakeRandom.nextInt((int)currentIntensity * 2 + 1) - currentIntensity);\n            shakeOffsetY = (int)(shakeRandom.nextInt((int)currentIntensity * 2 + 1) - currentIntensity);\n            \n            screenShakeTimer++;\n            if (screenShakeTimer >= screenShakeDuration) {\n                screenShakeActive = false;\n                screenShakeTimer = 0;\n                shakeOffsetX = 0;\n                shakeOffsetY = 0;\n            }\n        }\n    }\n}",
      "UI.java": "package Bil211Game2.Game.Main;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.GradientPaint;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\n\nimport Bil211Game2.Game.Entity.Entity;\nimport Bil211Game2.Game.Objects.Others.OBJ_Hearth;\n\npublic class UI {\n    GamePanel gp;\n    Font arial_40, arial_80B;\n    BufferedImage heartFull, heartHalf, heartBlank;\n    public boolean messageOn = false;\n    public String message = \"\";\n    int messageCounter = 0;\n    public boolean gameFinished = false;\n    Graphics2D g2;\n    public String currentDialog = \"\";\n    public int commandNum = 0;\n    public int pauseCommandNum = 0;\n\n    int phaseTransitionCounter = 0;\n    boolean transitionFlag = false;\n\n    public UI(GamePanel gp){\n        this.gp = gp;\n        arial_40 = new Font(\"Arial\",Font.PLAIN,40);\n        arial_80B = new Font(\"Arial\",Font.BOLD,80);\n\n        // Create Hud Object\n        Entity heart = new OBJ_Hearth(gp);\n        heartFull = heart.image;\n        heartHalf = heart.image2;\n        heartBlank = heart.image3;\n    }\n\n    public void showMessage(String text){\n        message = text;\n        messageOn = true;\n    }\n\n    public void draw(Graphics2D g2){\n        this.g2 = g2;\n\n        g2.setFont(arial_40);\n        g2.setColor(Color.white);\n\n        if(gp.gameState == gp.playState){\n            drawPlayerLife();\n            drawPlayerAmmo();\n            drawPlayerScore();\n            drawZombieCounter();\n            if(gp.phaseFinishDraw){\n                transitionFlag = true;\n                if(gp.currentPhase == gp.phase1){\n                    drawPhaseTransition(\"Please Ready For The Game\");\n                }\n                else{\n                    drawPhaseTransition((gp.currentPhase) + \". Phase Finished.\\n Please Ready For Next\");\n                }\n                \n            }\n            if(gp.drawFPS){\n                drawFPS();\n            }\n        }\n        if(gp.gameState == gp.pauseState){\n            drawPlayerLife();\n            drawPlayerAmmo();\n            drawPlayerScore();\n            drawPauseScreen();\n        }\n        if(gp.gameState == gp.dialogState){\n            drawDialogScreen();\n        }\n        if(gp.gameState == gp.titleState){\n            drawTitleScreen();\n        }\n        if(gp.gameState == gp.finishState){\n            drawFinishScreen();\n        }\n        \n    }\n\n    public void drawPauseScreen(){\n        // Tüm ekranı kaplayan yarı-saydam siyah arka plan\n        g2.setColor(new Color(0, 0, 0, 150));\n        g2.fillRect(0, 0, gp.screenWidth, gp.screenHeight);\n        \n        // Pause menü paneli\n        int panelWidth = gp.tileSize*10;\n        int panelHeight = gp.tileSize*8;\n        int panelX = gp.screenWidth/2 - panelWidth/2;\n        int panelY = gp.screenHeight/2 - panelHeight/2;\n        \n        // Panel arka planı (mavi-mor gradyan)\n        GradientPaint gradient = new GradientPaint(\n            panelX, panelY, new Color(50, 50, 80),\n            panelX, panelY + panelHeight, new Color(20, 20, 40)\n        );\n        g2.setPaint(gradient);\n        g2.fillRoundRect(panelX, panelY, panelWidth, panelHeight, 25, 25);\n        \n        // Panel kenarı\n        g2.setStroke(new BasicStroke(3));\n        g2.setColor(new Color(100, 100, 180, 200));\n        g2.drawRoundRect(panelX, panelY, panelWidth, panelHeight, 25, 25);\n        \n        // \"GAME PAUSED\" başlığı\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 36));\n        g2.setColor(new Color(220, 220, 255));\n        String pausedText = \"GAME PAUSED\";\n        int pausedX = gp.screenWidth/2 - g2.getFontMetrics().stringWidth(pausedText)/2;\n        g2.drawString(pausedText, pausedX, (int) (panelY + gp.tileSize*1.5));\n        \n        // Alt çizgi\n        g2.setStroke(new BasicStroke(2));\n        g2.drawLine(panelX + gp.tileSize, panelY + gp.tileSize*2, \n                   panelX + panelWidth - gp.tileSize, panelY + gp.tileSize*2);\n        \n        // Karakter resmi (daha küçük)\n        int characterSize = gp.tileSize*3/2;\n        int characterX = gp.screenWidth/2 - characterSize/2;\n        int characterY = (int) (panelY + gp.tileSize*2.5);\n        g2.drawImage(gp.player.down1, characterX, characterY, characterSize, characterSize, null);\n        \n        // Menü seçenekleri\n        g2.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        \n        // Menü arkaplanları ve metinleri\n        drawMenuItem(\"CONTINUE\", panelX, (int) (panelY + gp.tileSize*4.5), panelWidth, pauseCommandNum == 0);\n        drawMenuItem(\"SAVE GAME\", panelX, (int) (panelY + gp.tileSize*5.5), panelWidth, pauseCommandNum == 1);\n        drawMenuItem(\"QUIT\", panelX, (int) (panelY + gp.tileSize*6.5), panelWidth, pauseCommandNum == 2);\n        \n        // Oyuncu istatistikleri\n        drawPauseStats(panelX + gp.tileSize/2, (int) (panelY + panelHeight - gp.tileSize*0.5 - gp.tileSize/4), panelWidth - gp.tileSize);\n    }\n\n    public void drawSubWindow(int x, int y, int width, int height){\n        Color c = new Color(0,0,0, 175);\n        g2.setColor(c);\n        g2.fillRoundRect(x, y, width, height, 35, 35);;\n    \n        c = new Color(255,255,255);\n        g2.setColor(c);\n        // Set The Outlines What Was Created By Graphics2 \n        g2.setStroke(new BasicStroke(5));\n        g2.drawRoundRect(x+5, y+5, width-10, height-10, 25, 25);\n    }\n\n    public void drawDialogScreen(){\n        // WINDOW\n        int x = gp.tileSize*2;\n        int y = gp.tileSize/2;\n        int width = gp.screenWidth - (gp.tileSize*4);\n        int height = gp.tileSize*4;\n\n        drawSubWindow(x, y, width, height);\n\n        g2.setFont(g2.getFont().deriveFont(Font.PLAIN, 32F));\n        x += gp.tileSize/2;\n        y += gp.tileSize;\n\n        for(String line:currentDialog.split(\"\\n\")){\n            g2.drawString(line, x, y);\n            y += 40;\n        }\n    }\n\n    public int getXForCenteredText(String text){\n        int length = (int)g2.getFontMetrics().getStringBounds(text, g2).getWidth();\n        return gp.screenWidth/2 - length/2;\n    }\n\n    public void drawTitleScreen(){\n        // Gradyan arka plan\n        GradientPaint gradient = new GradientPaint(0, 0, new Color(40, 40, 60), \n                0, gp.screenHeight, new Color(80, 20, 80));\n        g2.setPaint(gradient);\n        g2.fillRect(0, 0, gp.screenWidth, gp.screenHeight);\n    \n        // Doku ekleme (küçük kareler şeklinde)\n        g2.setColor(new Color(0, 0, 0, 50));\n        for(int i = 0; i < gp.screenWidth; i += 20) {\n            for(int j = 0; j < gp.screenHeight; j += 20) {\n                g2.fillRect(i, j, 10, 10);\n            }\n        }\n        \n        // Kırmızı yarı saydam kaplama (zombi temasını vurgulamak için)\n        g2.setColor(new Color(142, 22, 22, 70));\n        g2.fillRect(0, 0, gp.screenWidth, gp.screenHeight);\n    \n        // Oyun başlığı\n        String gameTitle = \"ZOMBIE APOCALYPSE\";\n        g2.setFont(new Font(\"Impact\", Font.BOLD, 60));\n        \n        // Başlığa gölge efekti ekleme\n        g2.setColor(new Color(120, 0, 0));\n        int x = getXForCenteredText(gameTitle);\n        int y = gp.tileSize*3;\n        g2.drawString(gameTitle, x+3, y+3);\n        \n        // Başlık ana rengi\n        g2.setColor(new Color(220, 20, 20));\n        g2.drawString(gameTitle, x, y);\n        \n        // Karakter gösterimi\n        int characterSize = gp.tileSize*3;\n        int characterX = gp.screenWidth/2 - characterSize/2;\n        int characterY = y + gp.tileSize;\n        g2.drawImage(gp.player.down1, characterX, characterY - gp.tileSize + gp.tileSize/2, characterSize, characterSize, null);\n        \n        // Menü paneli\n        int menuWidth = gp.tileSize*8;\n        int menuHeight = gp.tileSize*4 + gp.tileSize/2 + gp.tileSize/8;\n        int menuX = gp.screenWidth/2 - menuWidth/2;\n        int menuY = characterY + characterSize - gp.tileSize/6;\n        \n        // Menü arka planı\n        g2.setColor(new Color(0, 0, 0, 150));\n        g2.fillRoundRect(menuX, menuY, menuWidth, menuHeight, 25, 25);\n        \n        // Menü kenarı\n        g2.setStroke(new BasicStroke(3));\n        g2.setColor(new Color(100, 20, 20, 200));\n        g2.drawRoundRect(menuX, menuY, menuWidth, menuHeight, 25, 25);\n        \n        // Menü başlığı\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 24));\n        g2.setColor(new Color(220, 220, 220));\n        String menuTitle = \"MAIN MENU\";\n        int menuTitleX = getXForCenteredText(menuTitle);\n        g2.drawString(menuTitle, menuTitleX, menuY + gp.tileSize/2 + 10);\n        \n        // Alt çizgi\n        g2.setStroke(new BasicStroke(2));\n        g2.drawLine(menuX + gp.tileSize, menuY + gp.tileSize/2 + 20, \n                    menuX + menuWidth - gp.tileSize, menuY + gp.tileSize/2 + 20);\n        \n        // Menü seçenekleri\n        g2.setFont(new Font(\"Arial\", Font.PLAIN, 20));\n        \n        // Menü öğeleri\n        String[] options = {\"NEW GAME\", \"TEST MODE\", \"LOAD GAME\", \"QUIT\"};\n        for(int i = 0; i < options.length; i++) {\n            drawMenuOption(options[i], menuX, (int) (menuY + gp.tileSize*1.5 + (i * gp.tileSize*0.9)), \n                          menuWidth, i == commandNum);\n        }\n        \n        // Ekranın alt kısmında kontrol bilgileri\n        g2.setFont(new Font(\"Arial\", Font.PLAIN, 12));\n        g2.setColor(new Color(180, 180, 180));\n        String controlsText = \"CONTROLS: W,A,S,D to move | MOUSE to aim and shoot | R to reload | P to pause\";\n        int controlsX = gp.screenWidth/2 - g2.getFontMetrics().stringWidth(controlsText)/2;\n        g2.drawString(controlsText, controlsX, gp.screenHeight - gp.tileSize/8);\n    }\n\n    public void menuSelect(){\n        if(commandNum == 0){\n            gp.gameState = gp.playState;\n            gp.aSetter.setMonsterByPhase();\n            \n            gp.stopMusic();\n            gp.playMusic(Sound.PHASE1_MUSIC);\n        }\n        else if(commandNum == 1){\n            gp.testMode();\n\n            gp.stopMusic();\n            gp.playMusic(Sound.PHASE1_MUSIC);\n        }\n        else if(commandNum == 2){\n            gp.loadGame();\n        }\n        else{\n            System.exit(0);\n        }\n    }\n\n    public void drawPlayerLife(){\n        int x = gp.screenWidth - gp.tileSize*4;\n        int y = gp.tileSize/2;\n\n        int i = 0;\n\n        // DRAW MAX LIFE\n        while(i < gp.player.maxLife / 2){\n            g2.drawImage(heartBlank, x, y, null);\n            i++;\n            x += gp.tileSize + gp.tileSize/6;\n        }\n\n        // RESET\n        x = gp.screenWidth - gp.tileSize*4;\n        y = gp.tileSize/2;\n\n        i = 0;\n\n        // DRAW CURRENT LIFE\n        while(i < gp.player.life){\n            g2.drawImage(heartHalf, x, y, null);\n            i++;\n            if(i < gp.player.life){\n                g2.drawImage(heartFull, x, y, null);\n            }\n            i++;\n            x += gp.tileSize + gp.tileSize/6;\n        }\n    }\n\n    public void drawPlayerAmmo(){\n        int x = gp.tileSize/2;\n        int y = gp.tileSize/2;\n        int width = gp.tileSize*4;\n        int height = gp.tileSize;\n        \n        // Arka plan paneli\n        g2.setColor(new Color(40, 40, 40, 200));\n        g2.fillRoundRect(x, y, width, height, 15, 15);\n        \n        // Silah adı\n        String weaponName = \"\";\n        switch(gp.player.currentWeaponIndex) {\n            case 0: weaponName = \"Pistol\"; break;\n            case 1: weaponName = \"Rifle\"; break;\n            case 2: weaponName = \"Shotgun\"; break;\n            case 3: weaponName = \"Sniper\"; break;\n            case 4: weaponName = \"Rocket\"; break;\n        }\n        \n        g2.setFont(new Font(\"Arial\", Font.BOLD, 16));\n        g2.setColor(Color.white);\n        g2.drawString(weaponName, x + 10, y + 20);\n        \n        // Mevcut mermi / Toplam mermi\n        String ammoText = gp.player.weapons[gp.player.currentWeaponIndex].magazineAmmo + \n                         \" / \" + \n                         gp.player.weapons[gp.player.currentWeaponIndex].ammo;\n        \n        g2.drawString(ammoText, x + 10, y + height - 4);\n        \n        // Sarjor Doluluk Seviyesi\n        int magazineSize = gp.player.weapons[gp.player.currentWeaponIndex].magazineSize;\n        int currentAmmo = gp.player.weapons[gp.player.currentWeaponIndex].magazineAmmo;\n        int barWidth = width - 20;\n        int barHeight = 5;\n        int barX = x + 10;\n        int barY = y + height - 25;\n        \n        // Boş şarjör\n        g2.setColor(new Color(100, 100, 100));\n        g2.fillRect(barX, barY, barWidth, barHeight);\n        \n        // Dolu şarjör\n        float ammoRatio = (float)currentAmmo / magazineSize;\n        int filledWidth = (int)(barWidth * ammoRatio);\n        g2.setColor(new Color(230, 230, 30));\n        g2.fillRect(barX, barY, filledWidth, barHeight);\n    }\n\n    public void drawPhaseTransition(String text){\n        // Yarı saydam siyah arka plan\n        g2.setColor(new Color(0, 0, 0, 150));\n        g2.fillRect(0, 0, gp.screenWidth, gp.screenHeight);\n        \n        // Dalgalı animasyon efekti\n        float alpha = 0.7f + 0.3f * (float)Math.sin(System.currentTimeMillis() / 200.0);\n        g2.setColor(new Color(255, 165, 0, (int)(alpha * 255)));\n        \n        // Ana metin\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 40));\n        int y = gp.screenHeight/2 - 50;\n        \n        for(String line : text.split(\"\\n\")){\n            int x = getXForCenteredText(line);\n            g2.drawString(line, x, y);\n            y += 50;\n        }\n        \n        // Alt bilgi metni\n        g2.setFont(new Font(\"Arial\", Font.PLAIN, 20));\n        g2.setColor(new Color(255, 255, 255, 200));\n        String readyText = \"Zombie Amount: \" + ((gp.currentPhase + 1)*3);\n        int readyX = getXForCenteredText(readyText);\n        g2.drawString(readyText, readyX, gp.screenHeight/2 + 100);\n    }\n\n    public void drawPlayerScore(){\n        // Skor paneli konumu ve boyutu\n        int x = gp.screenWidth - gp.tileSize*4 - gp.tileSize/2;\n        int y = gp.tileSize/2 + gp.tileSize + 10;\n        int width = gp.tileSize*4;\n        int height = gp.tileSize;\n        \n        // Arka plan paneli\n        g2.setColor(new Color(40, 40, 40, 200));\n        g2.fillRoundRect(x, y, width, height, 15, 15);\n        \n        // Panel kenarı\n        g2.setColor(new Color(150, 150, 150, 150));\n        g2.setStroke(new BasicStroke(2));\n        g2.drawRoundRect(x, y, width, height, 15, 15);\n        \n        // Skor etiketi\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 18));\n        g2.setColor(new Color(220, 220, 220));\n        g2.drawString(\"SCORE:\", x + 10, y + height/2 + 6);\n        \n        // Skor değeri\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 22));\n        g2.setColor(new Color(255, 215, 0)); // Altın sarısı\n        String scoreValue = String.valueOf(gp.player.score);\n        int valueX = x + width - g2.getFontMetrics().stringWidth(scoreValue) - 10;\n        g2.drawString(scoreValue, valueX, y + height/2 + 6);\n    }\n\n    public void drawFinishScreen(){\n        // Tüm ekranı kaplayan yarı-saydam siyah arka plan\n        g2.setColor(new Color(0, 0, 0, 180));\n        g2.fillRect(0, 0, gp.screenWidth, gp.screenHeight);\n        \n        // Oyun sonu paneli\n        int panelWidth = gp.tileSize*10;\n        int panelHeight = gp.tileSize*8;\n        int panelX = gp.screenWidth/2 - panelWidth/2;\n        int panelY = gp.screenHeight/2 - panelHeight/2;\n        \n        // Panel arka planı\n        GradientPaint gradient = new GradientPaint(\n            panelX, panelY, new Color(80, 0, 0),\n            panelX, panelY + panelHeight, new Color(30, 0, 0)\n        );\n        g2.setPaint(gradient);\n        g2.fillRoundRect(panelX, panelY, panelWidth, panelHeight, 30, 30);\n        \n        // Panel kenarı\n        g2.setStroke(new BasicStroke(4));\n        g2.setColor(new Color(150, 0, 0));\n        g2.drawRoundRect(panelX, panelY, panelWidth, panelHeight, 30, 30);\n        \n        // \"GAME OVER\" başlığı\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 48));\n        g2.setColor(new Color(200, 0, 0));\n        String gameOverText = \"GAME OVER\";\n        int gameOverX = gp.screenWidth/2 - g2.getFontMetrics().stringWidth(gameOverText)/2;\n        g2.drawString(gameOverText, gameOverX, panelY + gp.tileSize*2);\n        \n        // Alt gölge efekti\n        g2.setColor(new Color(50, 0, 0));\n        g2.drawString(gameOverText, gameOverX + 3, panelY + gp.tileSize*2 + 3);\n        \n        // Skor\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 36));\n        g2.setColor(new Color(255, 215, 0)); // Altın rengi\n        String scoreText = \"SCORE: \" + gp.player.score;\n        int scoreX = gp.screenWidth/2 - g2.getFontMetrics().stringWidth(scoreText)/2;\n        g2.drawString(scoreText, scoreX, panelY + gp.tileSize*4);\n        \n        // Faz bilgisi\n        g2.setFont(new Font(\"Arial\", Font.PLAIN, 22));\n        g2.setColor(new Color(220, 220, 220));\n        String phaseText = \"PHASE REACHED: \" + (gp.currentPhase + 1);\n        int phaseX = gp.screenWidth/2 - g2.getFontMetrics().stringWidth(phaseText)/2;\n        g2.drawString(phaseText, phaseX, panelY + gp.tileSize*5);\n        \n        // Yeniden başlatma talimatı\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 20));\n        g2.setColor(new Color(200, 200, 200));\n        String restartText = \"Press ENTER to return to main menu\";\n        int restartX = gp.screenWidth/2 - g2.getFontMetrics().stringWidth(restartText)/2;\n        \n        // Yanıp sönen metin için basit efekt\n        if(System.currentTimeMillis() / 500 % 2 == 0) {\n            g2.drawString(restartText, restartX, panelY + gp.tileSize*7);\n        }\n    }\n\n    public void drawFPS() {\n        // FPS göstergesi için konum ve boyut\n        int x = gp.tileSize/2;\n        int y = gp.screenHeight - gp.tileSize;\n        int width = gp.tileSize*2;\n        int height = gp.tileSize/2;\n        \n        // Arka plan paneli\n        g2.setColor(new Color(0, 0, 0, 180));\n        g2.fillRoundRect(x, y, width, height, 10, 10);\n        \n        // Panel kenarı\n        g2.setColor(new Color(150, 150, 150, 120));\n        g2.setStroke(new BasicStroke(1));\n        g2.drawRoundRect(x, y, width, height, 10, 10);\n        \n        // FPS değeri\n        g2.setFont(new Font(\"Consolas\", Font.BOLD, 14));\n        \n        // FPS durumuna göre renk değişimi\n        if (gp.fps >= 55) {\n            g2.setColor(new Color(30, 180, 30)); // Yeşil - iyi\n        } else if (gp.fps >= 30) {\n            g2.setColor(new Color(180, 180, 30)); // Sarı - orta\n        } else {\n            g2.setColor(new Color(180, 30, 30)); // Kırmızı - düşük\n        }\n        \n        String fpsText = \"FPS: \" + gp.fps;\n        int textX = x + 10;\n        int textY = y + height - gp.tileSize/8 - 1;\n        g2.drawString(fpsText, textX, textY);\n    }\n\n    private void drawMenuItem(String text, int x, int y, int width, boolean selected) {\n        int itemHeight = gp.tileSize/2 + 10;\n        int textX = gp.screenWidth/2 - g2.getFontMetrics().stringWidth(text)/2;\n        \n        // Seçili öğe için arka plan\n        if(selected) {\n            g2.setColor(new Color(100, 100, 180, 180));\n            g2.fillRoundRect(x + gp.tileSize, y - itemHeight/2, width - gp.tileSize*2, itemHeight, 15, 15);\n            g2.setColor(new Color(220, 220, 255));\n            // Seçim işaretçisi\n            g2.fillPolygon(\n                new int[]{x + gp.tileSize - 10, x + gp.tileSize - 20, x + gp.tileSize - 10},\n                new int[]{y - 8, y, y + 8},\n                3\n            );\n        } else {\n            g2.setColor(new Color(180, 180, 180));\n        }\n        \n        // Menü metni\n        g2.drawString(text, textX, y + 10);\n    }\n\n    private void drawPauseStats(int x, int y, int width) {\n        g2.setFont(new Font(\"Arial\", Font.PLAIN, 16));\n        g2.setColor(new Color(180, 180, 180));\n        \n        // Skor\n        String scoreText = \"Score: \" + gp.player.score;\n        g2.drawString(scoreText, x, y);\n        \n        // Can\n        String healthText = \"Health: \" + gp.player.life + \"/\" + gp.player.maxLife;\n        int healthX = x + width - g2.getFontMetrics().stringWidth(healthText);\n        g2.drawString(healthText, healthX, y);\n        \n        // Silah\n        String weaponText = \"Weapon: \";\n        switch(gp.player.currentWeaponIndex) {\n            case 0: weaponText += \"Pistol\"; break;\n            case 1: weaponText += \"Rifle\"; break;\n            case 2: weaponText += \"Shotgun\"; break;\n            case 3: weaponText += \"Sniper\"; break;\n            case 4: weaponText += \"Rocket\"; break;\n        }\n        g2.drawString(weaponText, x, y + 25);\n        \n        // Mevcut faz\n        String phaseText = \"Phase: \" + (gp.currentPhase + 1);\n        int phaseX = x + width - g2.getFontMetrics().stringWidth(phaseText);\n        g2.drawString(phaseText, phaseX, y + 25);\n    }\n\n    private void drawMenuOption(String text, int x, int y, int width, boolean selected) {\n        int itemHeight = gp.tileSize/2;\n        int textX = gp.screenWidth/2 - g2.getFontMetrics().stringWidth(text)/2;\n        \n        // Seçili öğe için arka plan\n        if(selected) {\n            // Kırmızı gradyan arka plan\n            GradientPaint optionGradient = new GradientPaint(\n                x + gp.tileSize, y - itemHeight/2, \n                new Color(120, 20, 20, 200),\n                x + gp.tileSize, y + itemHeight/2, \n                new Color(180, 30, 30, 200)\n            );\n            g2.setPaint(optionGradient);\n            g2.fillRoundRect(x + gp.tileSize/2, y - itemHeight/2, \n                            width - gp.tileSize, itemHeight, 15, 15);\n            \n            // Seçim işaretçisi (üçgen)\n            g2.setColor(new Color(255, 255, 255));\n            g2.fillPolygon(\n                new int[]{x + gp.tileSize/2 - 5, x + gp.tileSize/2 - 15, x + gp.tileSize/2 - 5},\n                new int[]{y - 8, y, y + 8},\n                3\n            );\n            \n            g2.setColor(new Color(255, 255, 255));\n        } else {\n            g2.setColor(new Color(200, 200, 200));\n        }\n        \n        // Menü metni\n        g2.drawString(text, textX, y + gp.tileSize/6 - 1);\n    }\n\n    public void drawZombieCounter() {\n        // Zombi sayacı için konum ve boyut\n        int x = gp.tileSize/2;\n        int y = gp.tileSize*2 - gp.tileSize/4;\n        int width = gp.tileSize*4;\n        int height = (int)(gp.tileSize*0.8);\n        \n        // Arka plan paneli\n        g2.setColor(new Color(40, 0, 0, 180));\n        g2.fillRoundRect(x, y, width, height, 15, 15);\n        \n        // Panel kenarı\n        g2.setColor(new Color(120, 20, 20, 150));\n        g2.setStroke(new BasicStroke(2));\n        g2.drawRoundRect(x, y, width, height, 15, 15);\n        \n        // Zombi ikonu (basit bir zombi kafa silüeti)\n        g2.setColor(new Color(50, 150, 50)); // Zombi yeşili\n        int iconSize = (int)(height * 0.6);\n        int iconX = x + 10;\n        \n        // Hayatta kalan zombi sayısı\n        int remainingZombies = 0;\n        for(int i = 0; i < gp.monsters.size(); i++) {\n            if(gp.monsters.get(i) != null) {\n                remainingZombies++;\n            }\n        }\n        \n        // Zombi sayısı metni\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 18));\n        g2.setColor(Color.WHITE);\n        String zombieText = \"Zombies: \" + remainingZombies;\n        g2.drawString(zombieText, iconX + iconSize + 15, y + height/2 + 6);\n        \n        // Eğer faz bitmiş ve yeni zombiler gelecekse uyarı işareti ekle\n        if(gp.phaseFinished && !gp.phaseFinishDraw) {\n            g2.setFont(new Font(\"Arial\", Font.BOLD, 14));\n            g2.setColor(new Color(255, 200, 0));\n            String warningText = \"Next Wave Coming!\";\n            g2.drawString(warningText, x + 10, y + height + 20);\n        }\n    }\n}\n",
      "EventRect.java": "package Bil211Game2.Game.Main;\n\nimport java.awt.Rectangle;\n\npublic class EventRect extends Rectangle{\n    int eventRectDefaultX, eventRectDefaultY;\n    boolean eventDone = false;\n}\n",
      "GameSaveData.java": "package Bil211Game2.Game.Main;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\n\npublic class GameSaveData implements Serializable{\n    public int playerX;\n    public int playerY;\n    public int playerLife;\n    public int playerScore;\n    public ArrayList<Integer> monstersX = new ArrayList<>();\n    public ArrayList<Integer> monstersY = new ArrayList<>();\n    public ArrayList<Integer> monstersLife = new ArrayList<>();\n    public ArrayList<String> monstersType = new ArrayList<>();\n    public ArrayList<Integer> ammosX = new ArrayList<>();\n    public ArrayList<Integer> ammosY = new ArrayList<>();\n    public ArrayList<Integer> ammosXSpeed = new ArrayList<>();\n    public ArrayList<Integer> ammosYSpeed = new ArrayList<>();\n    public ArrayList<String> ammosTypes = new ArrayList<>();\n    public int[] weaponsAmmo = new int[5];\n    public int[] weaponsMagazineAmmo = new int[5];\n    public int gamePhase;\n    public int normalZombieChance, reptileZombieChance, tankZombieChance, acidZombieChance;\n}\n",
      "AssetSetter.java": "package Bil211Game2.Game.Main;\n\nimport java.util.Random;\n\nimport Bil211Game2.Game.Entity.AcidZombie;\nimport Bil211Game2.Game.Entity.Monster;\nimport Bil211Game2.Game.Entity.NormalZombie;\nimport Bil211Game2.Game.Entity.ReptileZombie;\nimport Bil211Game2.Game.Entity.TankZombie;\n\npublic class AssetSetter{\n\n    GamePanel gp;\n    int normalZombieChance = 100;\n    int reptileZombieChance = 0;\n    int tankZombieChance = 0;\n    int acidZombieChance = 0;\n\n    public AssetSetter(GamePanel gp){\n        this.gp = gp;\n    }\n\n    public void setMonster(){\n        \n        gp.monsters.add(0, new NormalZombie(gp));\n        gp.monsters.get(0).worldX = gp.tileSize*23;\n        gp.monsters.get(0).worldY = gp.tileSize*36;\n\n        gp.monsters.add(1, new NormalZombie(gp));\n        gp.monsters.get(1).worldX = gp.tileSize*27;\n        gp.monsters.get(1).worldY = gp.tileSize*20;\n\n        gp.monsters.add(2, new NormalZombie(gp));\n        gp.monsters.get(2).worldX = gp.tileSize*29;\n        gp.monsters.get(2).worldY = gp.tileSize*20;\n\n        gp.monsters.add(3, new NormalZombie(gp));\n        gp.monsters.get(3).worldX = gp.tileSize*25;\n        gp.monsters.get(3).worldY = gp.tileSize*20;\n\n        gp.monsters.add(4, new ReptileZombie(gp));\n        gp.monsters.get(4).worldX = gp.tileSize*27;\n        gp.monsters.get(4).worldY = gp.tileSize*23;\n\n        gp.monsters.add(5, new ReptileZombie(gp));\n        gp.monsters.get(5).worldX = gp.tileSize*27;\n        gp.monsters.get(5).worldY = gp.tileSize*26;\n        \n        gp.monsters.add(6, new TankZombie(gp));\n        gp.monsters.get(6).worldX = gp.tileSize*27;\n        gp.monsters.get(6).worldY = gp.tileSize*17;\n\n        gp.monsters.add(7, new TankZombie(gp));\n        gp.monsters.get(7).worldX = gp.tileSize*15;\n        gp.monsters.get(7).worldY = gp.tileSize*14;\n\n        gp.monsters.add(8, new TankZombie(gp));\n        gp.monsters.get(8).worldX = gp.tileSize*18;\n        gp.monsters.get(8).worldY = gp.tileSize*18;\n\n        gp.monsters.add(9, new TankZombie(gp));\n        gp.monsters.get(9).worldX = gp.tileSize*30;\n        gp.monsters.get(9).worldY = gp.tileSize*30;\n\n        gp.monsters.add(10, new AcidZombie(gp));\n        gp.monsters.get(10).worldX = gp.tileSize*31;\n        gp.monsters.get(10).worldY = gp.tileSize*31;\n\n        gp.monsters.add(11, new AcidZombie(gp));\n        gp.monsters.get(11).worldX = gp.tileSize*40;\n        gp.monsters.get(11).worldY = gp.tileSize*40;\n    }\n\n    public void setMonsterByPhase(){ \n        if(gp.gameState == gp.playState){\n            Random random = new Random();\n\n            if(gp.currentPhase == gp.phase1 || gp.currentPhase == gp.phase2){\n                normalZombieChance -= 10;\n                reptileZombieChance += 10;\n            }\n            else if(gp.currentPhase == gp.phase3 || gp.currentPhase == gp.phase4){\n                normalZombieChance -= 10;\n                tankZombieChance += 10;\n            }\n            else if(gp.currentPhase == gp.phase5 || gp.currentPhase == gp.phase6){\n                normalZombieChance -= 5;\n                acidZombieChance += 5;\n            }\n            else if(gp.currentPhase == gp.phase7 || gp.currentPhase == gp.phase8){\n                normalZombieChance -= 10;\n                reptileZombieChance += 3;\n                tankZombieChance += 3;\n                acidZombieChance += 4;\n            }\n\n            for(int i = 0; i < (gp.currentPhase+1)*3; i++){\n                int chance = random.nextInt(101);\n                if(chance < normalZombieChance){\n                    NormalZombie normalZombie = new NormalZombie(gp);\n                    MonsterCreator(normalZombie);\n                }\n                else if(chance < normalZombieChance + reptileZombieChance){\n                    ReptileZombie reptileZombie = new ReptileZombie(gp);\n                    MonsterCreator(reptileZombie);\n                }\n                else if(chance < normalZombieChance + reptileZombieChance + tankZombieChance){\n                    TankZombie tankZombie = new TankZombie(gp);\n                    MonsterCreator(tankZombie);\n                }\n                else{\n                    AcidZombie acidZombie = new AcidZombie(gp);\n                    MonsterCreator(acidZombie);\n                }\n            }\n            gp.phaseFinished = false;\n        }\n    }\n\n    public void MonsterCreator(Monster monster){\n        if(gp.gameState == gp.playState){\n            int x = 0; \n            int y = 0;\n            Random random = new Random();\n\n            boolean validPosition = false;\n        \n            while(!validPosition){\n                x = random.nextInt(gp.maxWorldCol);\n                y = random.nextInt(gp.maxWorldRow);\n                \n                // Harita sınırları içinde mi kontrolü\n                // Çarpışma OLMAYAN bir karo mu?\n                if(!gp.tileM.tiles[gp.tileM.mapTileNum[x][y]].collision){\n                        \n                    double distance = UtilityTool.distanceCalculator(x*gp.tileSize, y*gp.tileSize, gp.player.worldX, gp.player.worldY);\n                    if(distance > 3*gp.tileSize){  // Oyuncudan en az 3 karo uzakta olsun\n                        boolean positionFree = true;\n                            \n                        // Mevcut monster listesi üzerinde güvenli yineleme\n                        for(int i = 0; i < gp.monsters.size(); i++){\n                            Monster monsterTemp = gp.monsters.get(i);\n                            if(monsterTemp != null && monsterTemp.worldX/gp.tileSize == x && monsterTemp.worldY/gp.tileSize == y){\n                                positionFree = false;\n                                break;\n                            }\n                        }\n                            \n                        if(positionFree){\n                            validPosition = true;\n                        }\n                    }\n                }\n                \n            }\n\n            monster.worldX = x*gp.tileSize;\n            monster.worldY = y*gp.tileSize;\n            gp.monsters.add(monster);\n        }\n    }\n\n    public void resetChances(){\n        normalZombieChance = 100;\n        reptileZombieChance = 0;\n        tankZombieChance = 0;\n        acidZombieChance = 0;\n    }\n\n    public void loadChances(int normalZombieChance, int reptileZombieChance, int tankZombieChance, int acidZombieChance){\n        this.normalZombieChance = normalZombieChance;\n        this.reptileZombieChance = reptileZombieChance;\n        this.tankZombieChance = tankZombieChance;\n        this.acidZombieChance = acidZombieChance;\n    }\n}\n",
      "KeyHandler.java": "package Bil211Game2.Game.Main;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\npublic class KeyHandler implements KeyListener{\n\n    public boolean upPressed, downPressed, leftPressed, rightPressed, RPressed, escPressed, HPressed;\n\n    GamePanel gp;\n\n    public KeyHandler(GamePanel gp){\n        this.gp = gp;\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e){\n        int code = e.getKeyCode();\n\n        if(gp.gameState == gp.playState){\n            if(code == KeyEvent.VK_W){\n                upPressed = true;\n            }\n            if(code == KeyEvent.VK_S){\n                downPressed = true;\n            }\n            if(code == KeyEvent.VK_A){\n                leftPressed = true;\n            }\n            if(code == KeyEvent.VK_D){\n                rightPressed = true;\n            }\n            if(code == KeyEvent.VK_P){\n                gp.gameState = gp.pauseState;\n            }\n            if(code == KeyEvent.VK_R){\n                RPressed = true;\n            }\n            if(code == KeyEvent.VK_ESCAPE){\n                escPressed = true;\n            }\n            if(code == KeyEvent.VK_1){\n                gp.player.changeWeapon(0);\n            }\n            \n            if(code == KeyEvent.VK_2){\n                gp.player.changeWeapon(1);\n            }\n            \n            if(code == KeyEvent.VK_3){\n                gp.player.changeWeapon(2);\n            }\n            \n            if(code == KeyEvent.VK_4){\n                gp.player.changeWeapon(3);\n            }\n            \n            if(code == KeyEvent.VK_5){\n                gp.player.changeWeapon(4);\n            }\n\n            if(code == KeyEvent.VK_R){\n                gp.player.weapons[gp.player.currentWeaponIndex].reload();\n            }\n\n            if(code == KeyEvent.VK_T){\n                gp.drawFPS = !gp.drawFPS;\n            }\n\n            if(code == KeyEvent.VK_H){\n                HPressed = true;\n            }\n\n            if(code == KeyEvent.VK_L){\n                gp.tileM.loadMap(\"/Bil211Game2/Resources/Maps/ApocalypseWorld_1.txt\");\n            }\n        }\n        else if(gp.gameState == gp.pauseState){\n            if(code == KeyEvent.VK_P){\n                gp.gameState = gp.playState;\n            }\n            if(code == KeyEvent.VK_W){\n                gp.ui.pauseCommandNum--;\n                if(gp.ui.pauseCommandNum < 0){\n                    gp.ui.pauseCommandNum = 2;\n                }\n            }\n            if(code == KeyEvent.VK_S){\n                gp.ui.pauseCommandNum++;\n                if(gp.ui.pauseCommandNum > 2){\n                    gp.ui.pauseCommandNum = 0;\n                }\n            }\n            if(code == KeyEvent.VK_ENTER){\n                if(gp.ui.pauseCommandNum == 0){\n                    gp.gameState = gp.playState;\n                }\n                else if(gp.ui.pauseCommandNum == 1){\n                    gp.saveGame();\n                }\n                else{\n                    gp.resetGame();\n                    gp.gameState = gp.titleState;\n\n                    gp.stopMusic();\n                    gp.playMusic(Sound.TITLE_SCREEN_MUSIC);\n                }\n            }\n        }\n        else if(gp.gameState == gp.titleState){\n            if(code == KeyEvent.VK_W){\n                gp.ui.commandNum--;\n                if(gp.ui.commandNum < 0){\n                    gp.ui.commandNum = 3;\n                }\n            }\n            if(code == KeyEvent.VK_S){\n                gp.ui.commandNum++;\n                if(gp.ui.commandNum > 3){\n                    gp.ui.commandNum = 0;\n                }\n            }\n            if(code == KeyEvent.VK_ENTER){\n                gp.ui.menuSelect();\n                \n            }\n        }\n        else if(gp.gameState == gp.finishState){\n            if(code == KeyEvent.VK_ENTER){\n                gp.resetGame();\n                gp.gameState = gp.titleState;\n\n                gp.stopMusic();\n                gp.playMusic(Sound.TITLE_SCREEN_MUSIC);\n            }\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int code = e.getKeyCode();\n\n        if(code == KeyEvent.VK_W){\n            upPressed = false;\n        }\n        if(code == KeyEvent.VK_S){\n            downPressed = false;\n        }\n        if(code == KeyEvent.VK_A){\n            leftPressed = false;\n        }\n        if(code == KeyEvent.VK_D){\n            rightPressed = false;\n        }\n        if(code == KeyEvent.VK_P){}\n        if(code == KeyEvent.VK_R){\n            RPressed = false;\n        }\n        if(code == KeyEvent.VK_ESCAPE){\n            escPressed = false;\n        }\n        if(code == KeyEvent.VK_H){\n            HPressed = false;\n        }\n    }\n    \n}\n",
      "Game.java": "package Bil211Game2.Game.Main;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JFrame;\n\npublic class Game {\n    public static void main(String[] args) {\n        JFrame window = new JFrame();\n        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        window.setResizable(false);\n        window.setTitle(\"Zombie Apocalypse\");\n\n        try {\n            BufferedImage icon = ImageIO.read(\n                Game.class.getResourceAsStream\n                (\"/Bil211Game2/Resources/Images/Other/Zombie Poster/Zombie-Tileset---_0296_Capa-297.png\"));\n            window.setIconImage(icon);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        GamePanel gamePanel = new GamePanel();\n        window.add(gamePanel);\n        window.pack();\n        window.setLocationRelativeTo(null);\n        window.setVisible(true);\n\n        window.addWindowListener(new java.awt.event.WindowAdapter() {\n            @Override\n            public void windowClosing(java.awt.event.WindowEvent windowEvent) {\n                gamePanel.cleanupResources();\n            }\n        });\n\n        gamePanel.setupAfterVisible();\n        \n        gamePanel.setUpGame();\n        gamePanel.startGameThread();\n    }\n}\n\n/*\n * 4500 SATIR KOD\n */",
      "CollisionChecker.java": "package Bil211Game2.Game.Main;\n\nimport java.util.ArrayList;\n\nimport Bil211Game2.Game.Entity.Entity;\nimport Bil211Game2.Game.Objects.Ammos.Ammo;\n\npublic class CollisionChecker {\n    GamePanel gp;\n\n    public CollisionChecker(GamePanel gp){\n        this.gp = gp;\n    }\n\n    public void checkTile(Entity entity){\n        int entityLeftWorldX = entity.worldX + entity.solidArea.x;\n        int entityRightWorldX = entity.worldX + entity.solidArea.x + entity.solidArea.width;\n        int entityTopWorldY = entity.worldY + entity.solidArea.y;\n        int entityBottomWorldY = entity.worldY + entity.solidArea.y + entity.solidArea.height;\n\n        int entityLeftCol = entityLeftWorldX/gp.tileSize;\n        int entityRightCol = entityRightWorldX/gp.tileSize;\n        int entityTopRow = entityTopWorldY/gp.tileSize;\n        int entityBottomRow = entityBottomWorldY/gp.tileSize;\n    \n        int tileNum1, tileNum2, tileNum3, tileNum4;\n\n        switch(entity.direction){\n            case \"up\":\n                entityTopRow = (entityTopWorldY - entity.speed)/gp.tileSize;\n                tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];\n                tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];\n                tileNum3 = gp.tileM.mapTileSecondStage[entityLeftCol][entityTopRow];\n                tileNum4 = gp.tileM.mapTileSecondStage[entityRightCol][entityTopRow];\n                if(gp.tileM.tiles[tileNum1].collision||gp.tileM.tiles[tileNum2].collision\n                ||gp.tileM.tiles[tileNum3 != 0 ? tileNum3 : 0].collision\n                ||gp.tileM.tiles[tileNum4 != 0 ? tileNum3 : 0].collision){\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"down\":\n                entityBottomRow = (entityBottomWorldY + entity.speed)/gp.tileSize;\n                tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];\n                tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];\n                tileNum3 = gp.tileM.mapTileSecondStage[entityLeftCol][entityBottomRow];\n                tileNum4 = gp.tileM.mapTileSecondStage[entityRightCol][entityBottomRow];\n                if(gp.tileM.tiles[tileNum1].collision||gp.tileM.tiles[tileNum2].collision\n                ||gp.tileM.tiles[tileNum3 != 0 ? tileNum3 : 0].collision\n                ||gp.tileM.tiles[tileNum4 != 0 ? tileNum3 : 0].collision){\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"left\":\n                entityLeftCol = (entityLeftWorldX - entity.speed)/gp.tileSize;\n                tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];\n                tileNum2 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];\n                tileNum3 = gp.tileM.mapTileSecondStage[entityLeftCol][entityTopRow];\n                tileNum4 = gp.tileM.mapTileSecondStage[entityLeftCol][entityBottomRow];\n                if(gp.tileM.tiles[tileNum1].collision||gp.tileM.tiles[tileNum2].collision\n                ||gp.tileM.tiles[tileNum3 != 0 ? tileNum3 : 0].collision\n                ||gp.tileM.tiles[tileNum4 != 0 ? tileNum3 : 0].collision){\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"right\":\n                entityRightCol = (entityRightWorldX + entity.speed)/gp.tileSize;\n                tileNum1 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];\n                tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];\n                tileNum3 = gp.tileM.mapTileSecondStage[entityRightCol][entityTopRow];\n                tileNum4 = gp.tileM.mapTileSecondStage[entityRightCol][entityBottomRow];\n                if(gp.tileM.tiles[tileNum1].collision||gp.tileM.tiles[tileNum2].collision\n                ||gp.tileM.tiles[tileNum3 != 0 ? tileNum3 : 0].collision\n                ||gp.tileM.tiles[tileNum4 != 0 ? tileNum3 : 0].collision){\n                    entity.collisionOn = true;\n                }\n                break;\n        }\n    }\n\n    public int checkEntity(Entity entity, ArrayList<? extends Entity> target){\n        int index = 999;\n\n        for(int i = 0; i < target.size(); i++){\n            if(target.get(i) != null){\n                Entity trgt = target.get(i);\n                // Get Entity's Solid Area Position\n                entity.solidArea.x = entity.worldX + entity.solidArea.x;\n                entity.solidArea.y = entity.worldY + entity.solidArea.y;\n                // Get The Object's Solid Area Position\n                trgt.solidArea.x = trgt.worldX + trgt.solidArea.x;\n                trgt.solidArea.y = trgt.worldY + trgt.solidArea.y;\n            \n                switch(entity.direction){\n                    case \"up\":\n                        entity.solidArea.y -= entity.speed;\n                        break;\n                    case \"down\":\n                        entity.solidArea.y += entity.speed;\n                        break;\n                    case \"left\":\n                        entity.solidArea.x -= entity.speed;\n                        break;\n                    case \"right\":\n                        entity.solidArea.x += entity.speed;\n                        break;\n                }\n                if(entity.solidArea.intersects(trgt.solidArea)){\n                    if(trgt != entity){\n                        entity.collisionOn = true;\n                        index = i;\n                    }\n                }\n\n                entity.solidArea.x = entity.solidAreaDefaultX;\n                entity.solidArea.y = entity.solidAreaDefaultY;\n                trgt.solidArea.x = trgt.solidAreaDefaultX;\n                trgt.solidArea.y = trgt.solidAreaDefaultY;\n            }\n        }\n\n        return index;\n    }\n\n    public boolean checkPlayer(Entity entity){\n        boolean contactPlayer = false;\n\n        if(gp.player != null){\n            // Get Entity's Solid Area Position\n            entity.solidArea.x = entity.worldX + entity.solidArea.x;\n            entity.solidArea.y = entity.worldY + entity.solidArea.y;\n            // Get The Object's Solid Area Position\n            gp.player.solidArea.x = gp.player.worldX + gp.player.solidArea.x;\n            gp.player.solidArea.y = gp.player.worldY + gp.player.solidArea.y;\n        \n            switch(entity.direction){\n                case \"up\":\n                    entity.solidArea.y -= entity.speed;\n                    break;\n                case \"down\":\n                    entity.solidArea.y += entity.speed;\n                    break;\n                case \"left\":\n                    entity.solidArea.x -= entity.speed;\n                    break;\n                case \"right\":\n                    entity.solidArea.x += entity.speed;\n                    break;\n            }\n\n            if(entity.solidArea.intersects(gp.player.solidArea)){\n                entity.collisionOn = true;\n                contactPlayer = true;\n            }\n\n            entity.solidArea.x = entity.solidAreaDefaultX;\n            entity.solidArea.y = entity.solidAreaDefaultY;\n            gp.player.solidArea.x = gp.player.solidAreaDefaultX;\n            gp.player.solidArea.y = gp.player.solidAreaDefaultY;\n        }\n\n        return contactPlayer;\n    }\n\n    public boolean checkAmmo(Ammo ammo, Entity entity){\n        boolean collision = false;\n\n        if(ammo == null || entity == null || entity.dying || !entity.alive || ammo.contact){\n            return false;\n        }\n\n        if(solidAreaCheck(ammo.worldX, ammo.worldY, ammo.solidAreaDefaultX, ammo.solidAreaDefaultY,\n        entity.worldX+ entity.solidAreaDefaultX, entity.worldY + entity.solidAreaDefaultY, \n        entity.solidArea.width, entity.solidArea.height, entity.direction, entity.speed)){\n            collision = true;\n        }        \n\n        return collision;\n    }\n\n    public boolean solidAreaCheck(int o1X,int  o1Y,int  o1Width,int  o1Height,int  o2X,\n    int  o2Y,int  o2Width,int  o2Height, String direction, int speed){\n        boolean inside = false;\n\n        int xIncr = 0;\n        int yIncr = 0;\n\n        switch(direction){\n            case \"up\":\n                yIncr = -speed;\n                break;\n            case \"down\":\n                yIncr = +speed;\n                break;\n            case \"left\":\n                xIncr = -speed;\n                break;\n            case \"right\":\n                xIncr = +speed;\n                break;\n        }\n\n        int centerX = o1X + o1Width/2;\n        int centerY = o1Y + o1Height/2;\n        \n        if(centerX > o2X + xIncr && centerX < o2X + o2Width + xIncr \n        && centerY > o2Y + yIncr && centerY < o2Y + o2Height + yIncr){\n            inside = true;\n        }\n\n        return inside;\n    }\n}\n",
      "EventHandler.java": "package Bil211Game2.Game.Main;\n\npublic class EventHandler {\n    GamePanel gp;\n    EventRect[][] eventRects;\n\n    int previousEventX, previousEventY;\n    boolean canTouchEvent = true; \n    \n    public EventHandler(GamePanel gp){\n        this.gp = gp;\n\n        eventRects = new EventRect[gp.maxWorldCol][gp.maxWorldRow];\n\n        int col = 0;\n        int row = 0;\n        while(col < gp.maxWorldCol && row < gp.maxWorldRow){\n            eventRects[col][row] = new EventRect();\n            eventRects[col][row].x = 27;\n            eventRects[col][row].y = 22;\n            eventRects[col][row].width = 2;\n            eventRects[col][row].height = 2;\n            eventRects[col][row].eventRectDefaultX = eventRects[col][row].x;\n            eventRects[col][row].eventRectDefaultY = eventRects[col][row].y;\n\n            col++;\n            if(col == gp.maxWorldCol){\n                row++;\n                col = 0;\n            }\n        }\n    }\n\n    public void checkEvent(){\n\n        int xDistance = Math.abs(gp.player.worldX - previousEventX);\n        int yDistance = Math.abs(gp.player.worldY - previousEventY);\n        int distance = (int)Math.sqrt(yDistance*yDistance + xDistance*xDistance);\n\n        if(distance > gp.tileSize){\n            canTouchEvent = true;\n        }\n\n        if(canTouchEvent){\n            if(hit(28, 22,\"any\")){\n                damagePit(28,22);\n            }\n            else if(hit(26, 20,\"any\")){\n                teleport(9,7);\n            }\n        }\n    }\n\n    public boolean hit(int col, int row, String reqDirection){\n        boolean hit = false;\n\n        gp.player.solidArea.x = gp.player.worldX + gp.player.solidArea.x;\n        gp.player.solidArea.y = gp.player.worldY + gp.player.solidArea.y;\n        eventRects[col][row].x = col*gp.tileSize + eventRects[col][row].x;\n        eventRects[col][row].y = row*gp.tileSize + eventRects[col][row].y;\n\n        if(gp.player.solidArea.intersects(eventRects[col][row]) &&\n        !eventRects[col][row].eventDone){\n            if(gp.player.direction.contentEquals(reqDirection) || \n            reqDirection.contentEquals(\"any\")){\n                hit = true;\n\n                previousEventX = gp.player.worldX;\n                previousEventY = gp.player.worldY;\n            }\n        }\n\n        gp.player.solidArea.x = gp.player.solidAreaDefaultX;\n        gp.player.solidArea.y = gp.player.solidAreaDefaultY;\n        eventRects[col][row].x = eventRects[col][row].eventRectDefaultX;\n        eventRects[col][row].y = eventRects[col][row].eventRectDefaultY;\n\n        return hit;\n    }\n\n    public void damagePit(int col, int row){\n        gp.player.life--;\n        //eventRects[col][row].eventDone = true;\n        canTouchEvent = false;\n    }\n\n    public void teleport(int col, int row){\n        gp.player.worldX = col*gp.tileSize;\n        gp.player.worldY = row*gp.tileSize;\n        canTouchEvent = false;\n    }\n}\n",
      "MouseHandler.java": "package Bil211Game2.Game.Main;\n\nimport java.awt.Cursor;\nimport java.awt.Point;\nimport java.awt.Toolkit;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\nimport java.awt.image.BufferedImage;\n\nimport javax.imageio.ImageIO;\n\npublic class MouseHandler implements MouseListener, MouseMotionListener{\n\n    GamePanel gp;\n    public MouseEvent event;\n\n    public boolean mouseLeftPressed;\n    public int mouseX, mouseY;\n\n    private Cursor customNormalCursor;\n    private Cursor customTargetCursor;\n\n    public MouseHandler(GamePanel gp){\n        this.gp = gp;\n\n        try{\n            BufferedImage cursorTargetImg = ImageIO.read(getClass().getResourceAsStream(\"/Bil211Game2/Resources/Images/UI/Mouse/Target.png\"));\n            BufferedImage cursorNormalImg = ImageIO.read(getClass().getResourceAsStream(\"/Bil211Game2/Resources/Images/UI/Mouse/Normal.png\"));\n        \n            Point hotspotTarget = new Point(cursorTargetImg.getWidth() / 2, cursorTargetImg.getHeight() / 2);\n            Point hotspotNormal = new Point(cursorNormalImg.getWidth() / 2, cursorNormalImg.getHeight() / 2);\n        \n            customTargetCursor = Toolkit.getDefaultToolkit().createCustomCursor(\n                    cursorTargetImg, hotspotTarget, \"Target Cursor\");\n\n            customNormalCursor = Toolkit.getDefaultToolkit().createCustomCursor(\n                cursorNormalImg, hotspotNormal, \"Game Cursor\");\n        }\n        catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        \n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        int code = e.getButton();\n        if(code == MouseEvent.BUTTON1){\n            mouseLeftPressed = true;\n            event = e;\n        }\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        mouseLeftPressed = false;\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e) {\n        if(customNormalCursor == null || customTargetCursor == null){\n            gp.setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));\n        }\n        else if(gp.gameState == gp.playState){\n            gp.setCursor(customTargetCursor);\n        }\n        else{\n            gp.setCursor(customNormalCursor);\n        }\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e) {\n        gp.setCursor(new Cursor(Cursor.DEFAULT_CURSOR)); // Varsayılana dön\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        // Update current mouse position while dragging\n        if(mouseLeftPressed) {\n            mouseX = e.getX();\n            mouseY = e.getY();\n            event = e; // Also update the event object\n        }\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        // Update current mouse position while moving\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n}\n",
      "Tile.java": "package Bil211Game2.Game.Main.Tile;\n\nimport java.awt.image.BufferedImage;\n\npublic class Tile {\n    public BufferedImage image;\n    public boolean collision = false;\n}\n",
      "TileManager.java": "package Bil211Game2.Game.Main.Tile;\n\nimport java.awt.Graphics2D;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Random;\n\nimport javax.imageio.ImageIO;\n\nimport Bil211Game2.Game.Main.GamePanel;\nimport Bil211Game2.Game.Main.UtilityTool;\n\npublic class TileManager {\n    GamePanel gp;\n    public Tile[] tiles;\n    public int[][] mapTileNum;\n    public int[][] mapTileSecondStage;\n\n    public TileManager(GamePanel gp){\n        this.gp = gp;\n        tiles = new Tile[160];\n        mapTileNum = new int[gp.maxWorldCol][gp.maxWorldRow];\n        mapTileSecondStage = new int[gp.maxWorldCol][gp.maxWorldRow];\n\n        getTileImage();\n        //loadMap(\"/Bil211Game2/Resources/Maps/Grassland1.txt\");\n        loadMap(\"/Bil211Game2/Resources/Maps/ApocalypseWorld_1.txt\");\n    }\n\n    public void loadMap(String filePath){\n        try(InputStream in = getClass().getResourceAsStream(filePath);\n        BufferedReader br = new BufferedReader(new InputStreamReader(in))){\n            Random random = new Random();\n\n            int col = 0;\n            int row = 0;\n            \n            while(col < gp.maxScreenCol && row < gp.maxWorldRow){\n                String line = br.readLine();\n                while(col < gp.maxWorldCol){\n                    String[] numbers = line.split(\" \");\n                    int num = 0;\n                    if(Integer.parseInt(numbers[col]) == 0){\n                        boolean flag = random.nextBoolean();\n                        if(flag){\n                            int type = random.nextInt(3);\n                            num = type + 1;\n                        }\n                        else{\n                            num = Integer.parseInt(numbers[col]);\n                        }\n                        mapTileSecondStage[col][row] = 0;\n                    }\n                    else if(Integer.parseInt(numbers[col]) == 148){\n                        int type = random.nextInt(3);\n                        num = type + 148;\n                        mapTileSecondStage[col][row] = 0;\n                    }\n                    else{\n                        boolean flag = random.nextBoolean();\n                        if(flag){\n                            int type = random.nextInt(3);\n                            num = type + 1;\n                        }\n                        else{\n                            num = Integer.parseInt(numbers[col]);\n                        }\n                        mapTileSecondStage[col][row] = Integer.parseInt(numbers[col]);\n                    }\n                    mapTileNum[col][row] = num;\n                    col++;\n                }\n                if(col == gp.maxWorldCol){\n                    col =0;\n                    row++;\n                }\n            }\n        }\n        catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n\n    public void getTileImage(){\n        // Terrains\n        setUpNew(0, \"Terrain Variations/Zombie-Tileset---_0077_Capa-78\", false);\n        setUpNew(1, \"Terrain Variations/Zombie-Tileset---_0078_Capa-79\", false);\n        setUpNew(2, \"Terrain Variations/Zombie-Tileset---_0079_Capa-80\", false);\n        setUpNew(3, \"Terrain Variations/Zombie-Tileset---_0080_Capa-81\", false);\n        // Terrain Roads\n        for(int i = 0; i < 12; i++){\n            setUpNew(i+4, \"Modular Terrain Path/Zombie-Tileset---_00\"+(i+65)+\"_Capa-\"+(i+66), false);\n        }\n        // Terrain Wall - Vertical\n        setUpNew(16, \"Terrain wall/Zombie-Tileset---_0064_Capa-65\", true);\n        // Modular Road\n        for(int i = 0; i < 26; i++){\n            setUpNew(i+17, \"Modular Road/Zombie-Tileset---_00\"+(i+29)+\"_Capa-\"+(i+30), false);\n        }\n        // Small Building\n        for(int i = 0; i < 8; i++){\n            setUpNew(i+43, \"Modular Small Building/Zombie-Tileset---_00\"+(i+91)+\"_Capa-\"+(i+92), true);\n        }\n        setUpNew(52, \"Modular Small Building/Zombie-Tileset---_0099_Capa-100\", true);\n        for(int i = 0; i < 6; i++){\n            setUpNew(i+53, \"Modular Small Building/Zombie-Tileset---_0\"+(i+100)+\"_Capa-\"+(i+101), true);\n        }\n        // Modular Fences\n        for(int i = 0; i < 8; i++){\n            setUpNew(i+59, \"Modular Fences/Zombie-Tileset---_0\"+(i+126)+\"_Capa-\"+(i+127), true);\n        }\n        for(int i = 0; i < 23; i++){\n            setUpNew(i+67, \"Modular Fences/Zombie-Tileset---_0\"+(i+194)+\"_Capa-\"+(i+195), true);\n        }\n        // Modular Barns\n        for(int i = 0; i < 58; i++){\n            setUpNew(i+90, \"Modular Barns/Zombie-Tileset---_0\"+(i+226)+\"_Capa-\"+(i+227), true);\n        }\n        // Water Animation Frames\n        setUpNew(148, \"Water animation frames/Zombie-Tileset---_0061_Capa-62\", true);\n        setUpNew(149, \"Water animation frames/Zombie-Tileset---_0062_Capa-63\", true);\n        setUpNew(150, \"Water animation frames/Zombie-Tileset---_0063_Capa-64\", true);\n        // Tractor\n        setUpNew(151, \"Tractor/Zombie-Tileset---_0172_Capa-173\", true);\n        setUpNew(152, \"Tractor/Zombie-Tileset---_0173_Capa-174\", true);\n        setUpNew(153, \"Tractor/Zombie-Tileset---_0174_Capa-175\", true);\n        setUpNew(154, \"Tractor/Zombie-Tileset---_0175_Capa-176\", true);\n    }\n\n    public void setUp(int index, String imageName, boolean collision){\n        try{\n            tiles[index] = new Tile();\n            tiles[index].image = ImageIO.read(getClass().getResourceAsStream(\"/Bil211Game/Resources/Tiles/\"+ imageName +\".png\"));\n            tiles[index].image = UtilityTool.scaleImage(tiles[index].image, gp.tileSize, gp.tileSize);\n            tiles[index].collision = collision;\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n\n    public void setUpNew(int index, String imageName, boolean collision){\n        try{\n            tiles[index] = new Tile();\n            tiles[index].image = ImageIO.read(getClass().getResourceAsStream(\"/Bil211Game2/Resources/Images/Tiles/\"+ imageName +\".png\"));\n            tiles[index].image = UtilityTool.scaleImage(tiles[index].image, gp.tileSize, gp.tileSize);\n            tiles[index].collision = collision;\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n\n    public void draw(Graphics2D g2){\n        int worldCol = 0;\n        int worldRow = 0;\n\n        while(worldCol < gp.maxWorldCol && worldRow < gp.maxWorldRow){\n            int tileNum = mapTileNum[worldCol][worldRow];\n\n            int worldX = worldCol * gp.tileSize;\n            int worldY = worldRow * gp.tileSize;\n            int screenX = worldX - gp.player.worldX + gp.player.screenX;\n            int screenY = worldY - gp.player.worldY + gp.player.screenY;\n            \n            if(worldX + gp.tileSize > gp.player.worldX - gp.player.screenX \n            && worldX - gp.tileSize < gp.player.worldX + gp.player.screenX\n            && worldY + gp.tileSize > gp.player.worldY - gp.player.screenY \n            && worldY - gp.tileSize < gp.player.worldY + gp.player.screenY){\n                g2.drawImage(tiles[tileNum].image, screenX, screenY, null);\n            }\n            \n            worldCol++;\n\n            if(worldCol == gp.maxWorldCol){\n                worldCol = 0;\n                worldRow++;\n            }\n        }\n\n        worldCol = 0; \n        worldRow = 0;\n        \n        while(worldCol < gp.maxWorldCol && worldRow < gp.maxWorldRow){\n            int tileNum = mapTileSecondStage[worldCol][worldRow];\n\n            int worldX = worldCol * gp.tileSize;\n            int worldY = worldRow * gp.tileSize;\n            int screenX = worldX - gp.player.worldX + gp.player.screenX;\n            int screenY = worldY - gp.player.worldY + gp.player.screenY;\n            \n            if(tileNum != 0 && worldX + gp.tileSize > gp.player.worldX - gp.player.screenX \n            && worldX - gp.tileSize < gp.player.worldX + gp.player.screenX\n            && worldY + gp.tileSize > gp.player.worldY - gp.player.screenY \n            && worldY - gp.tileSize < gp.player.worldY + gp.player.screenY){\n                g2.drawImage(tiles[0].image, screenX, screenY, null);\n                g2.drawImage(tiles[tileNum].image, screenX, screenY, null);\n            }\n            \n            worldCol++;\n\n            if(worldCol == gp.maxWorldCol){\n                worldCol = 0;\n                worldRow++;\n            }\n        }\n    }\n}\n",
      "OBJ_Hearth.java": "package Bil211Game2.Game.Objects.Others;\n\nimport Bil211Game2.Game.Entity.Entity;\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic class OBJ_Hearth extends Entity{\n    public OBJ_Hearth(GamePanel gp){\n        super(gp);\n        name = \"Heart\";\n        image = setUpNew(\"Other/Hearts/heart_full\", gp.tileSize, gp.tileSize);\n        image2 = setUpNew(\"Other/Hearts/heart_half\", gp.tileSize, gp.tileSize);\n        image3 = setUpNew(\"Other/Hearts/heart_blank\", gp.tileSize, gp.tileSize);\n    }\n}\n",
      "Sniper.java": "package Bil211Game2.Game.Objects.Weapons;\n\nimport Bil211Game2.Game.Main.GamePanel;\nimport Bil211Game2.Game.Main.Sound;\nimport Bil211Game2.Game.Objects.Ammos.SniperAmmo;\n\npublic class Sniper extends Weapon{\n\n    public Sniper(GamePanel gp) {\n        super(gp);\n        attack = 5;\n        magazineSize = 5;\n        magazineAmmo = magazineSize;\n        fireRate = 30;\n        ammo = 2*magazineSize;\n    }\n\n    @Override\n    public void fire(int x, int y) {\n        if(magazineAmmo <= 0) return;\n\n        SniperAmmo pistolAmmo = new SniperAmmo(gp);\n        int playerX = gp.player.worldX;\n        int playerY = gp.player.worldY;\n    \n        // Mermi başlangıç pozisyonunu hesapla\n        int ammoX, ammoY;\n    \n        // Yöne bağlı olarak mermi çıkış noktasını ayarla\n        switch(gp.player.direction) {\n            case \"up\":\n                ammoX = playerX + gp.tileSize/2;\n                ammoY = playerY - gp.tileSize/2;\n                break;\n            case \"down\":\n                ammoX = playerX + gp.tileSize/2;\n                ammoY = playerY + gp.tileSize + gp.tileSize/2;\n                break;\n            case \"left\":\n                ammoX = playerX - gp.tileSize/2;\n                ammoY = playerY + gp.tileSize/2;\n                break;\n            case \"right\":\n                ammoX = playerX + gp.tileSize;\n                ammoY = playerY + gp.tileSize/2;\n                break;\n            default:\n                ammoX = playerX + gp.tileSize/2;\n                ammoY = playerY + gp.tileSize/2;\n                break;\n        }\n    \n        pistolAmmo.worldX = ammoX;\n        pistolAmmo.worldY = ammoY;\n    \n        // Hasarı ayarla\n        pistolAmmo.attack = attack;\n    \n        // Oyuncuya doğru açıyı hesapla\n        pistolAmmo.rad = Math.atan2(y - ammoY, x - ammoX);\n    \n        // Açıya göre hızı hesapla\n        pistolAmmo.speedY = (int)(SniperAmmo.defaultSpeed*Math.sin(pistolAmmo.rad));\n        pistolAmmo.speedX = (int)(SniperAmmo.defaultSpeed*Math.cos(pistolAmmo.rad));\n        \n        // Çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan\n        pistolAmmo.setupSolidArea(gp.tileSize/2, gp.tileSize/2);\n        pistolAmmo.speedHandler();\n\n        // Shoot\n        gp.ammos.add(pistolAmmo);\n\n        magazineAmmo--;\n\n        gp.playSE(Sound.SNIPER_SOUND);\n    }\n\n    @Override\n    public void reload() {\n        if(ammo >= magazineSize - magazineAmmo){\n            ammo -= magazineSize - magazineAmmo;\n            magazineAmmo = magazineSize;\n        }\n        else{\n            magazineAmmo += ammo;\n            ammo = 0;\n        }\n    }\n}\n",
      "Weapon.java": "package Bil211Game2.Game.Objects.Weapons;\n\nimport java.io.Serializable;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic abstract class Weapon implements Serializable{\n\n    public int ammo = 0;\n    int attack = 0;\n    public int magazineSize = 0;\n    public int magazineAmmo = 0;\n    public int fireRate = 0;\n    GamePanel gp;\n\n    public Weapon(GamePanel gp){\n        this.gp = gp;\n    }\n\n    public abstract void fire(int x, int y);\n\n    public abstract void reload();\n}\n",
      "Shotgun.java": "package Bil211Game2.Game.Objects.Weapons;\n\nimport Bil211Game2.Game.Main.GamePanel;\nimport Bil211Game2.Game.Main.Sound;\nimport Bil211Game2.Game.Objects.Ammos.ShotgunAmmo;\n\npublic class Shotgun  extends Weapon{\n\n    public Shotgun(GamePanel gp) {\n        super(gp);\n        attack = 2;\n        magazineSize = 5;\n        magazineAmmo = magazineSize;\n        fireRate = 60;\n        ammo = 2*magazineSize;\n    }\n\n    @Override\n    public void fire(int x, int y) {\n        if(magazineAmmo <= 0) return;\n\n        for(int i = 0; i <= 4; i++){\n            ShotgunAmmo pistolAmmo = new ShotgunAmmo(gp);\n            int playerX = gp.player.worldX;\n            int playerY = gp.player.worldY;\n        \n            // Mermi başlangıç pozisyonunu hesapla\n            int ammoX, ammoY;\n        \n            // Yöne bağlı olarak mermi çıkış noktasını ayarla\n            switch(gp.player.direction) {\n                case \"up\":\n                    ammoX = playerX + gp.tileSize/2;\n                    ammoY = playerY - gp.tileSize/2;\n                    break;\n                case \"down\":\n                    ammoX = playerX + gp.tileSize/2;\n                    ammoY = playerY + gp.tileSize + gp.tileSize/2;\n                    break;\n                case \"left\":\n                    ammoX = playerX - gp.tileSize/2;\n                    ammoY = playerY + gp.tileSize/2;\n                    break;\n                case \"right\":\n                    ammoX = playerX + gp.tileSize;\n                    ammoY = playerY + gp.tileSize/2;\n                    break;\n                default:\n                    ammoX = playerX + gp.tileSize/2;\n                    ammoY = playerY + gp.tileSize/2;\n                    break;\n            }\n        \n            pistolAmmo.worldX = ammoX;\n            pistolAmmo.worldY = ammoY;\n        \n            // Hasarı ayarla\n            pistolAmmo.attack = attack;\n        \n            // Oyuncuya doğru açıyı hesapla\n            pistolAmmo.rad = Math.atan2(y - ammoY, x - ammoX);\n        \n            // Açıya göre hızı hesapla\n            pistolAmmo.speedY = (int)(ShotgunAmmo.defaultSpeed*Math.sin(pistolAmmo.rad - Math.toRadians(5*i)));\n            pistolAmmo.speedX = (int)(ShotgunAmmo.defaultSpeed*Math.cos(pistolAmmo.rad - Math.toRadians(5*i)));\n            \n            // Çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan\n            pistolAmmo.setupSolidArea(gp.tileSize/2, gp.tileSize/2);\n            pistolAmmo.speedHandler();\n\n            // Shoot\n            gp.ammos.add(pistolAmmo);\n        }\n\n        for(int i = 1; i <= 4; i++){\n            ShotgunAmmo pistolAmmo = new ShotgunAmmo(gp);\n            int playerX = gp.player.worldX;\n            int playerY = gp.player.worldY;\n        \n            // Mermi başlangıç pozisyonunu hesapla\n            int ammoX, ammoY;\n        \n            // Yöne bağlı olarak mermi çıkış noktasını ayarla\n            switch(gp.player.direction) {\n                case \"up\":\n                    ammoX = playerX + gp.tileSize/2;\n                    ammoY = playerY - gp.tileSize/2;\n                    break;\n                case \"down\":\n                    ammoX = playerX + gp.tileSize/2;\n                    ammoY = playerY + gp.tileSize + gp.tileSize/2;\n                    break;\n                case \"left\":\n                    ammoX = playerX - gp.tileSize/2;\n                    ammoY = playerY + gp.tileSize/2;\n                    break;\n                case \"right\":\n                    ammoX = playerX + gp.tileSize;\n                    ammoY = playerY + gp.tileSize/2;\n                    break;\n                default:\n                    ammoX = playerX + gp.tileSize/2;\n                    ammoY = playerY + gp.tileSize/2;\n                    break;\n            }\n        \n            pistolAmmo.worldX = ammoX;\n            pistolAmmo.worldY = ammoY;\n        \n            // Hasarı ayarla\n            pistolAmmo.attack = attack;\n        \n            // Oyuncuya doğru açıyı hesapla\n            pistolAmmo.rad = Math.atan2(y - ammoY, x - ammoX);\n        \n            // Açıya göre hızı hesapla\n            pistolAmmo.speedY = (int)(ShotgunAmmo.defaultSpeed*Math.sin(pistolAmmo.rad + Math.toRadians(5*i)));\n            pistolAmmo.speedX = (int)(ShotgunAmmo.defaultSpeed*Math.cos(pistolAmmo.rad + Math.toRadians(5*i)));\n            \n            // Çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan\n            pistolAmmo.setupSolidArea(gp.tileSize/2, gp.tileSize/2);\n            pistolAmmo.speedHandler();\n\n            // Shoot\n            gp.ammos.add(pistolAmmo);\n        }\n\n        magazineAmmo--;\n\n        gp.playSE(Sound.SHOTGUN_SOUND);\n    }\n\n    @Override\n    public void reload() {\n        if(ammo >= magazineSize - magazineAmmo){\n            ammo -= magazineSize - magazineAmmo;\n            magazineAmmo = magazineSize;\n        }\n        else{\n            magazineAmmo += ammo;\n            ammo = 0;\n        }\n    }   \n}\n",
      "Pistol.java": "package Bil211Game2.Game.Objects.Weapons;\n\nimport Bil211Game2.Game.Main.GamePanel;\nimport Bil211Game2.Game.Main.Sound;\nimport Bil211Game2.Game.Objects.Ammos.PistolAmmo;\n\npublic class Pistol extends Weapon{\n\n    public Pistol(GamePanel gp) {\n        super(gp);\n        attack = 1;\n        magazineSize = 12;\n        magazineAmmo = magazineSize;\n        fireRate = 120;\n    }\n\n    @Override\n    public void fire(int x, int y) {\n        if(magazineAmmo <= 0) return;\n        \n        PistolAmmo pistolAmmo = new PistolAmmo(gp);\n        int playerX = gp.player.worldX;\n        int playerY = gp.player.worldY;\n    \n        // Mermi başlangıç pozisyonunu hesapla\n        int ammoX, ammoY;\n    \n        // Yöne bağlı olarak mermi çıkış noktasını ayarla\n        switch(gp.player.direction) {\n            case \"up\":\n                ammoX = playerX + gp.tileSize/2;\n                ammoY = playerY - gp.tileSize/2;\n                break;\n            case \"down\":\n                ammoX = playerX + gp.tileSize/2;\n                ammoY = playerY + gp.tileSize + gp.tileSize/2;\n                break;\n            case \"left\":\n                ammoX = playerX - gp.tileSize/2;\n                ammoY = playerY + gp.tileSize/2;\n                break;\n            case \"right\":\n                ammoX = playerX + gp.tileSize;\n                ammoY = playerY + gp.tileSize/2;\n                break;\n            default:\n                ammoX = playerX + gp.tileSize/2;\n                ammoY = playerY + gp.tileSize/2;\n                break;\n        }\n    \n        pistolAmmo.worldX = ammoX;\n        pistolAmmo.worldY = ammoY;\n    \n        // Hasarı ayarla\n        pistolAmmo.attack = attack;\n    \n        // Oyuncuya doğru açıyı hesapla\n        pistolAmmo.rad = Math.atan2(y - ammoY, x - ammoX);\n    \n        // Açıya göre hızı hesapla\n        pistolAmmo.speedY = (int)(PistolAmmo.defaultSpeed*Math.sin(pistolAmmo.rad));\n        pistolAmmo.speedX = (int)(PistolAmmo.defaultSpeed*Math.cos(pistolAmmo.rad));\n        \n        // Çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan\n        pistolAmmo.setupSolidArea(gp.tileSize/2, gp.tileSize/2);\n        pistolAmmo.speedHandler();\n\n        // Shoot\n        gp.ammos.add(pistolAmmo);\n\n        magazineAmmo--;\n\n        gp.playSE(Sound.PISTOL_SOUND);\n    }\n\n    @Override\n    public void reload() {\n        magazineAmmo = magazineSize;\n    }   \n}\n",
      "Rifle.java": "package Bil211Game2.Game.Objects.Weapons;\n\nimport java.util.Random;\n\nimport Bil211Game2.Game.Main.GamePanel;\nimport Bil211Game2.Game.Main.Sound;\nimport Bil211Game2.Game.Objects.Ammos.RifleAmmo;\n\npublic class Rifle extends Weapon{\n\n    Random random;\n\n    public Rifle(GamePanel gp) {\n        super(gp);\n        attack = 2;\n        random = new Random();\n        magazineSize = 30;\n        magazineAmmo = magazineSize;\n        fireRate = 600;\n        ammo = 2*magazineSize;\n    }\n\n    @Override\n    public void fire(int x, int y) {\n        if(magazineAmmo <= 0) return;\n\n        RifleAmmo pistolAmmo = new RifleAmmo(gp);\n        int playerX = gp.player.worldX;\n        int playerY = gp.player.worldY;\n\n        int sapma = random.nextInt(15);\n        boolean flag = random.nextBoolean();\n\n        if(flag){\n            sapma = (-1)*sapma;\n        }\n    \n        // Mermi başlangıç pozisyonunu hesapla\n        int ammoX, ammoY;\n    \n        // Yöne bağlı olarak mermi çıkış noktasını ayarla\n        switch(gp.player.direction) {\n            case \"up\":\n                ammoX = playerX + gp.tileSize/2;\n                ammoY = playerY - gp.tileSize/2;\n                break;\n            case \"down\":\n                ammoX = playerX + gp.tileSize/2;\n                ammoY = playerY + gp.tileSize + gp.tileSize/2;\n                break;\n            case \"left\":\n                ammoX = playerX - gp.tileSize/2;\n                ammoY = playerY + gp.tileSize/2;\n                break;\n            case \"right\":\n                ammoX = playerX + gp.tileSize;\n                ammoY = playerY + gp.tileSize/2;\n                break;\n            default:\n                ammoX = playerX + gp.tileSize/2;\n                ammoY = playerY + gp.tileSize/2;\n                break;\n        }\n    \n        pistolAmmo.worldX = ammoX;\n        pistolAmmo.worldY = ammoY;\n    \n        // Hasarı ayarla\n        pistolAmmo.attack = attack;\n    \n        // Oyuncuya doğru açıyı hesapla\n        pistolAmmo.rad = Math.atan2(y - ammoY, x - ammoX);\n    \n        // Açıya göre hızı hesapla\n        pistolAmmo.speedY = (int)(RifleAmmo.defaultSpeed*Math.sin(pistolAmmo.rad + Math.toRadians(sapma)));\n        pistolAmmo.speedX = (int)(RifleAmmo.defaultSpeed*Math.cos(pistolAmmo.rad + Math.toRadians(sapma)));\n        \n        // Çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan\n        pistolAmmo.setupSolidArea(gp.tileSize/2, gp.tileSize/2);\n        pistolAmmo.speedHandler();\n\n        // Shoot\n        gp.ammos.add(pistolAmmo);\n\n        magazineAmmo--;\n\n        gp.playSE(Sound.RIFLE_SOUND);\n    }\n\n    @Override\n    public void reload() {\n        if(ammo >= magazineSize - magazineAmmo){\n            ammo -= magazineSize - magazineAmmo;\n            magazineAmmo = magazineSize;\n        }\n        else{\n            magazineAmmo += ammo;\n            ammo = 0;\n        }\n    } \n}\n",
      "RocketLauncher.java": "package Bil211Game2.Game.Objects.Weapons;\n\nimport Bil211Game2.Game.Main.GamePanel;\nimport Bil211Game2.Game.Main.Sound;\nimport Bil211Game2.Game.Objects.Ammos.RocketAmmo;\n\npublic class RocketLauncher extends Weapon{\n\n    public RocketLauncher(GamePanel gp) {\n        super(gp);\n        attack = 10;\n        magazineSize = 1;\n        magazineAmmo = magazineSize;\n        fireRate = 10;\n        ammo = 2*magazineSize;\n    }\n\n    @Override\n    public void fire(int x, int y) {\n        if(magazineAmmo <= 0) return;\n\n        RocketAmmo pistolAmmo = new RocketAmmo(gp);\n        int playerX = gp.player.worldX;\n        int playerY = gp.player.worldY;\n    \n        // Mermi başlangıç pozisyonunu hesapla\n        int ammoX, ammoY;\n    \n        // Yöne bağlı olarak mermi çıkış noktasını ayarla\n        switch(gp.player.direction) {\n            case \"up\":\n                ammoX = playerX + gp.tileSize/2;\n                ammoY = playerY - gp.tileSize/2;\n                break;\n            case \"down\":\n                ammoX = playerX + gp.tileSize/2;\n                ammoY = playerY + gp.tileSize + gp.tileSize/2;\n                break;\n            case \"left\":\n                ammoX = playerX - gp.tileSize/2;\n                ammoY = playerY + gp.tileSize/2;\n                break;\n            case \"right\":\n                ammoX = playerX + gp.tileSize;\n                ammoY = playerY + gp.tileSize/2;\n                break;\n            default:\n                ammoX = playerX + gp.tileSize/2;\n                ammoY = playerY + gp.tileSize/2;\n                break;\n        }\n    \n        pistolAmmo.worldX = ammoX;\n        pistolAmmo.worldY = ammoY;\n    \n        // Hasarı ayarla\n        pistolAmmo.attack = attack;\n    \n        // Oyuncuya doğru açıyı hesapla\n        pistolAmmo.rad = Math.atan2(y - ammoY, x - ammoX);\n    \n        // Açıya göre hızı hesapla\n        pistolAmmo.speedY = (int)(RocketAmmo.defaultSpeed*Math.sin(pistolAmmo.rad));\n        pistolAmmo.speedX = (int)(RocketAmmo.defaultSpeed*Math.cos(pistolAmmo.rad));\n        \n        // Çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan\n        pistolAmmo.setupSolidArea(gp.tileSize/2, gp.tileSize/2);\n        pistolAmmo.speedHandler();\n\n        // Shoot\n        gp.ammos.add(pistolAmmo);\n\n        magazineAmmo--;\n        gp.playSE(Sound.ROCKET_SOUND);\n    }\n\n    @Override\n    public void reload() {\n        if(ammo >= magazineSize - magazineAmmo){\n            ammo -= magazineSize - magazineAmmo;\n            magazineAmmo = magazineSize;\n        }\n        else{\n            magazineAmmo += ammo;\n            ammo = 0;\n        }\n    } \n}\n",
      "BloodSplashAnimation.java": "package Bil211Game2.Game.Objects.Animations;\n\nimport java.awt.AlphaComposite;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport Bil211Game2.Game.Main.GamePanel;\nimport Bil211Game2.Game.Main.UtilityTool;\n\npublic class BloodSplashAnimation extends Animation {\n    \n    public BloodSplashAnimation(GamePanel gp, int worldX, int worldY) {\n        super(gp, worldX, worldY, gp.tileSize); // Kan sıçraması boyutu\n        \n        lifespan = 5; // 5 karelik animasyon\n        delay = 3; // Her 3 update döngüsünde bir kare değişecek\n        frames = new BufferedImage[lifespan];\n        \n        // Kan sıçrama karelerini yükle\n        loadAnimationFrames();\n    }\n    \n    private void loadAnimationFrames() {\n        // Mevcut explosion animasyonunu kan efekti için kullanabiliriz \n        // Daha sonra özel kan görselleri eklenebilir\n        frames[0] = setUpImage(\"Zombie-Tileset---_0379_Capa-380\");\n        frames[1] = setUpImage(\"Zombie-Tileset---_0380_Capa-381\");\n        frames[2] = setUpImage(\"Zombie-Tileset---_0381_Capa-382\");\n        frames[3] = setUpImage(\"Zombie-Tileset---_0382_Capa-383\");\n        frames[4] = setUpImage(\"Zombie-Tileset---_0383_Capa-384\");\n    }\n    \n    @Override\n    public void draw(Graphics2D g2) {\n        // Kan efekti için kırmızı renk tonu ayarla\n        if (!finished && currentFrame < frames.length) {\n            float alpha = 0.8f;\n            \n            // Son frame'lerde soluklaştır\n            if (currentFrame >= lifespan - 2) {\n                alpha = (float) (lifespan - currentFrame) / 2 * 0.8f;\n            }\n            \n            // Orijinal alpha değerini kaydet\n            AlphaComposite originalComposite = (AlphaComposite) g2.getComposite();\n            \n            // Kırmızı renk tonu eklemek için\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));\n            \n            // Kırmızı overlay\n            Color originalColor = g2.getColor();\n            g2.setColor(new Color(180, 0, 0, 100));\n            \n            // Önce orijinal frame'i çiz\n            int screenX = worldX - gp.player.worldX + gp.player.screenX - size/2 + gp.tileSize/2;\n            int screenY = worldY - gp.player.worldY + gp.player.screenY - size/2 + gp.tileSize/2;\n            g2.drawImage(frames[currentFrame], screenX, screenY, size, size, null);\n            \n            // Kırmızı overlay ekle\n            g2.fillOval(screenX, screenY, size, size);\n            \n            // Renk ve alpha değerlerini sıfırla\n            g2.setColor(originalColor);\n            g2.setComposite(originalComposite);\n        }\n    }\n\n    protected BufferedImage setUpImage(String imagePath) {\n        BufferedImage image = null;\n        try {\n            image = ImageIO.read(getClass().getResourceAsStream(\"/Bil211Game2/Resources/Images/Items/Blood Animation Frames/\" + imagePath + \".png\"));\n            image = UtilityTool.scaleImage(image, size, size);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return image;\n    }\n}",
      "AcidSplashAnimation.java": "// Asit sıçrama animasyonu\npackage Bil211Game2.Game.Objects.Animations;\n\nimport java.awt.AlphaComposite;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic class AcidSplashAnimation extends Animation {\n    \n    public AcidSplashAnimation(GamePanel gp, int worldX, int worldY) {\n        super(gp, worldX, worldY, gp.tileSize * 5); // Asit sıçraması daha geniş alana etki eder\n        \n        lifespan = 8; // 8 karelik animasyon\n        delay = 2; // Her 2 update döngüsünde bir kare değişecek\n        frames = new BufferedImage[lifespan];\n        \n        // Asit sıçrama karelerini yükle\n        loadAnimationFrames();\n    }\n    \n    private void loadAnimationFrames() {\n        frames[0] = setUpImage(\"Zombie-Tileset---_0358_Capa-359\");\n        frames[1] = setUpImage(\"Zombie-Tileset---_0359_Capa-360\");\n        frames[2] = setUpImage(\"Zombie-Tileset---_0360_Capa-361\");\n        frames[3] = setUpImage(\"Zombie-Tileset---_0361_Capa-362\");\n        frames[4] = setUpImage(\"Zombie-Tileset---_0362_Capa-363\");\n        frames[5] = setUpImage(\"Zombie-Tileset---_0363_Capa-364\");\n    }\n    \n    @Override\n    public void draw(Graphics2D g2) {\n        // Asit sıçrama efekti için renk ve alpha değerini ayarla\n        if (!finished && currentFrame < frames.length) {\n            float alpha = 0.8f;\n            \n            // Son üç karede saydamlaştır\n            if (currentFrame >= lifespan - 3) {\n                alpha = (float) (lifespan - currentFrame) / 3 * 0.8f;\n            }\n            \n            // Yeşil renk tonu eklemek için\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));\n            \n            // Orijinal görüntüyü çiz\n            super.draw(g2);\n            \n            // Alpha değerini sıfırla\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));\n        }\n    }\n}",
      "ExplosionAnimation.java": "package Bil211Game2.Game.Objects.Animations;\n\nimport java.awt.AlphaComposite;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic class ExplosionAnimation extends Animation {\n    \n    public ExplosionAnimation(GamePanel gp, int worldX, int worldY) {\n        super(gp, worldX, worldY, gp.tileSize * 3); // Patlama boyutu normal tile'ın 3 katı\n        \n        lifespan = 6; // 6 karelik animasyon\n        delay = 3; // Her 3 update döngüsünde bir kare değişecek\n        frames = new BufferedImage[lifespan];\n        \n        // Patlama karelerini yükle\n        loadAnimationFrames();\n    }\n    \n    private void loadAnimationFrames() {\n        frames[0] = setUpImage(\"Zombie-Tileset---_0358_Capa-359\");\n        frames[1] = setUpImage(\"Zombie-Tileset---_0359_Capa-360\");\n        frames[2] = setUpImage(\"Zombie-Tileset---_0360_Capa-361\");\n        frames[3] = setUpImage(\"Zombie-Tileset---_0361_Capa-362\");\n        frames[4] = setUpImage(\"Zombie-Tileset---_0362_Capa-363\");\n        frames[5] = setUpImage(\"Zombie-Tileset---_0363_Capa-364\");\n    }\n    \n    @Override\n    public void draw(Graphics2D g2) {\n        // Patlama efekti için alpha değerini ayarla (sona doğru saydamlaşsın)\n        if (!finished && currentFrame < frames.length) {\n            float alpha = 1.0f;\n            \n            // Son iki karede saydamlaştır\n            if (currentFrame >= lifespan - 2) {\n                alpha = (float) (lifespan - currentFrame) / 2;\n            }\n            \n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));\n            super.draw(g2);\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));\n        }\n    }\n}",
      "AnimationManager.java": "package Bil211Game2.Game.Objects.Animations;\n\nimport java.awt.Graphics2D;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic class AnimationManager {\n    private GamePanel gp;\n    private List<Animation> animations;\n    \n    public AnimationManager(GamePanel gp) {\n        this.gp = gp;\n        animations = new ArrayList<>();\n    }\n    \n    public void addExplosion(int worldX, int worldY) {\n        animations.add(new ExplosionAnimation(gp, worldX, worldY));\n    }\n    \n    public void addAcidSplash(int worldX, int worldY) {\n        animations.add(new AcidSplashAnimation(gp, worldX, worldY));\n    }\n\n    public void addBloodSplash(int worldX, int worldY) {\n        animations.add(new BloodSplashAnimation(gp, worldX, worldY));\n    }\n    \n    public void update() {\n        Iterator<Animation> iterator = animations.iterator();\n        while (iterator.hasNext()) {\n            Animation animation = iterator.next();\n            animation.update();\n            \n            if (animation.isFinished()) {\n                iterator.remove();\n            }\n        }\n    }\n    \n    public void draw(Graphics2D g2) {\n        for (Animation animation : animations) {\n            animation.draw(g2);\n        }\n    }\n}",
      "Animation.java": "package Bil211Game2.Game.Objects.Animations;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport Bil211Game2.Game.Main.GamePanel;\nimport Bil211Game2.Game.Main.UtilityTool;\n\npublic class Animation {\n    protected GamePanel gp;\n    protected int worldX, worldY;\n    protected int lifespan; // Animasyonun toplam kareleri\n    protected int currentFrame;\n    protected boolean finished;\n    protected BufferedImage[] frames;\n    protected int delay; // Her kare arasındaki gecikme (kaç update döngüsü)\n    protected int delayCounter;\n    protected int size; // Animasyon boyutu\n    \n    public Animation(GamePanel gp, int worldX, int worldY, int size) {\n        this.gp = gp;\n        this.worldX = worldX;\n        this.worldY = worldY;\n        this.size = size;\n        currentFrame = 0;\n        delayCounter = 0;\n        finished = false;\n    }\n    \n    public void update() {\n        delayCounter++;\n        \n        if (delayCounter >= delay) {\n            currentFrame++;\n            delayCounter = 0;\n            \n            if (currentFrame >= lifespan) {\n                finished = true;\n            }\n        }\n    }\n    \n    public void draw(Graphics2D g2) {\n        if (!finished && currentFrame < frames.length) {\n            int screenX = worldX - gp.player.worldX + gp.player.screenX;\n            int screenY = worldY - gp.player.worldY + gp.player.screenY;\n            \n            // Eğer ekranda görünüyorsa çiz\n            if (worldX + size > gp.player.worldX - gp.player.screenX \n                && worldX - size < gp.player.worldX + gp.player.screenX\n                && worldY + size > gp.player.worldY - gp.player.screenY \n                && worldY - size < gp.player.worldY + gp.player.screenY) {\n                \n                // Animasyonun ortada olması için pozisyonu ayarla\n                screenX -= size / 2;\n                screenY -= size / 2;\n                \n                g2.drawImage(frames[currentFrame], screenX, screenY, size, size, null);\n            }\n        }\n    }\n    \n    public boolean isFinished() {\n        return finished;\n    }\n    \n    // Yardımcı metot: Görüntüleri ayarlamak için\n    protected BufferedImage setUpImage(String imagePath) {\n        BufferedImage image = null;\n        try {\n            image = ImageIO.read(getClass().getResourceAsStream(\"/Bil211Game2/Resources/Images/Items/Explosion Animation Frames/\" + imagePath + \".png\"));\n            image = UtilityTool.scaleImage(image, size, size);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return image;\n    }\n}",
      "Acid.java": "package Bil211Game2.Game.Objects.Ammos;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic class Acid extends Ammo{\n\n    public static int defaultSpeed = 10;\n\n    public Acid(GamePanel gp) {\n        super(gp);\n\n        solidArea.x = speedX > 0 ? -gp.tileSize/4 : gp.tileSize/4;  \n        solidArea.y = speedY > 0 ? -gp.tileSize/4 : gp.tileSize/4;  \n        solidArea.width = gp.tileSize/2;\n        solidArea.height = gp.tileSize/2;\n\n        // Set default values explicitly\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        getImages();\n        setupSolidArea(solidArea.width, solidArea.height);\n    }\n\n    public void getImages(){\n        image = setUpNew(\"Turret Zombie Vomit Shooting Animation Frames/Zombie-Tileset---_0470_Capa-471\", gp.tileSize/2, gp.tileSize/2);\n    }\n}\n",
      "SniperAmmo.java": "package Bil211Game2.Game.Objects.Ammos;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic class SniperAmmo extends Ammo{\n\n    public static int defaultSpeed = 20;\n\n    public SniperAmmo(GamePanel gp) {\n        super(gp);\n\n        solidArea.x = speedX > 0 ? -gp.tileSize/4 : gp.tileSize/4;  \n        solidArea.y = speedY > 0 ? -gp.tileSize/4 : gp.tileSize/4;  \n        solidArea.width = gp.tileSize/2;\n        solidArea.height = gp.tileSize/2;\n\n        // Set default values explicitly\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        // Set a longer lifespan for the acid projectile\n        lifespan = 180;\n\n        getImages();\n        setupSolidArea(solidArea.width, solidArea.height);\n    }\n\n    public void getImages(){\n        image = setUpNew(\"sniper\", gp.tileSize/4, gp.tileSize/2);\n    }\n}\n",
      "RocketAmmo.java": "package Bil211Game2.Game.Objects.Ammos;\n\nimport Bil211Game2.Game.Entity.Entity;\nimport Bil211Game2.Game.Main.GamePanel;\nimport Bil211Game2.Game.Main.Sound;\nimport Bil211Game2.Game.Main.UtilityTool;\n\npublic class RocketAmmo extends Ammo{\n\n    public static int defaultSpeed = 10;\n\n    public RocketAmmo(GamePanel gp) {\n        super(gp);\n\n        solidArea.x = speedX > 0 ? -gp.tileSize/4 : gp.tileSize/4;  \n        solidArea.y = speedY > 0 ? -gp.tileSize/4 : gp.tileSize/4;  \n        solidArea.width = gp.tileSize/2;\n        solidArea.height = gp.tileSize/2;\n\n        // Set default values explicitly\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        // Set a longer lifespan for the acid projectile\n        lifespan = 180;\n\n        getImages();\n        setupSolidArea(solidArea.width, solidArea.height);\n    }\n\n    public void getImages(){\n        image = setUpNew(\"Rocket\", gp.tileSize, gp.tileSize);\n    }\n\n    @Override\n    public void additionalFeature(Entity entity) {\n        gp.animationManager.addExplosion(worldX, worldY);\n\n        for(int i = 0; i < gp.monsters.size(); i++){\n            if(gp.monsters.get(i) != null \n            && UtilityTool.distanceCalculator(gp.monsters.get(i).worldX, gp.monsters.get(i).worldY, worldX, worldY) < 3 * gp.tileSize){\n                gp.monsters.get(i).shooted(attack);\n            }\n        }    \n\n        gp.startScreenShake(25, 30);\n        gp.playSE(Sound.ROCKET_BANG_SOUND);\n    }\n}\n",
      "RifleAmmo.java": "package Bil211Game2.Game.Objects.Ammos;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic class RifleAmmo extends Ammo{\n\n    public static int defaultSpeed = 20;\n\n    public RifleAmmo(GamePanel gp) {\n        super(gp);\n\n        solidArea.x = speedX > 0 ? -gp.tileSize/4 : gp.tileSize/4;  \n        solidArea.y = speedY > 0 ? -gp.tileSize/4 : gp.tileSize/4;  \n        solidArea.width = gp.tileSize/2;\n        solidArea.height = gp.tileSize/2;\n\n        // Set default values explicitly\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        // Set a longer lifespan for the acid projectile\n        lifespan = 180;\n\n        getImages();\n        setupSolidArea(solidArea.width, solidArea.height);\n    }\n\n    public void getImages(){\n        image = setUpNew(\"rifle\", gp.tileSize/3, gp.tileSize/3);\n    }\n}\n",
      "ShotgunAmmo.java": "package Bil211Game2.Game.Objects.Ammos;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic class ShotgunAmmo extends Ammo{\n\n    public static int defaultSpeed = 12;\n\n    public ShotgunAmmo(GamePanel gp) {\n        \n        super(gp);\n\n        solidArea.x = speedX > 0 ? -gp.tileSize/4 : gp.tileSize/4;  \n        solidArea.y = speedY > 0 ? -gp.tileSize/4 : gp.tileSize/4;  \n        solidArea.width = gp.tileSize/2;\n        solidArea.height = gp.tileSize/2;\n\n        // Set default values explicitly\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        // Set a longer lifespan for the acid projectile\n        lifespan = 100;\n\n        getImages();\n        setupSolidArea(solidArea.width, solidArea.height);\n    }\n\n    public void getImages(){\n        image = setUpNew(\"shotgun\", gp.tileSize/3, gp.tileSize/3);\n    }\n}\n",
      "PistolAmmo.java": "package Bil211Game2.Game.Objects.Ammos;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic class PistolAmmo extends Ammo{\n\n    public static int defaultSpeed = 15;\n\n    public PistolAmmo(GamePanel gp) {\n        super(gp);\n\n        solidArea.x = speedX > 0 ? -gp.tileSize/4 : gp.tileSize/4;  \n        solidArea.y = speedY > 0 ? -gp.tileSize/4 : gp.tileSize/4;  \n        solidArea.width = gp.tileSize/2;\n        solidArea.height = gp.tileSize/2;\n\n        // Set default values explicitly\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        // Set a longer lifespan for the acid projectile\n        lifespan = 180;\n\n        getImages();\n        setupSolidArea(solidArea.width, solidArea.height);\n    }\n\n    public void getImages(){\n        image = setUpNew(\"pistol\", gp.tileSize/3, gp.tileSize/3);\n    }\n}\n",
      "Ammo.java": "package Bil211Game2.Game.Objects.Ammos;\n\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.Serializable;\n\nimport javax.imageio.ImageIO;\n\nimport Bil211Game2.Game.Entity.Entity;\nimport Bil211Game2.Game.Main.GamePanel;\nimport Bil211Game2.Game.Main.UtilityTool;\n\npublic abstract class Ammo implements Serializable{\n    public int speedX = 1;\n    public int speedY = 1;\n    public int worldX;\n    public int worldY;\n    public BufferedImage image;\n    public int attack = 0;\n    public double rad = 0;\n    public boolean collisionOn = true;\n    public boolean contact = false;\n    public int lifespan = 120; \n    public int lifetime = 0; \n    public Rectangle solidArea = new Rectangle(0, 0, 48, 48);\n    public int solidAreaDefaultX, solidAreaDefaultY;\n    \n    GamePanel gp;\n\n    public Ammo(GamePanel gp){\n        this.gp = gp;\n        \n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n    }\n\n    public BufferedImage setUp(String imagePath, int width, int height){\n        BufferedImage image = null;\n\n        try{\n            image = ImageIO.read(getClass().getResourceAsStream(\"/Bil211Game/Resources/\" + imagePath + \".png\"));\n            image = UtilityTool.scaleImage(image, width, height);\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n\n        return image;\n    }\n\n    public BufferedImage setUpNew(String imagePath, int width, int height){\n        BufferedImage image = null;\n\n        try{\n            image = ImageIO.read(getClass().getResourceAsStream(\"/Bil211Game2/Resources/Images/Items/Ammos/\" + imagePath + \".png\"));\n            image = UtilityTool.scaleImage(image, width, height);\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n\n        return image;\n    }\n\n    // Mermiyi çizmek için genel metot\n    public void draw(Graphics2D g2) {\n        if(image != null) {\n        // Ekran konumunu hesapla\n        int screenX = worldX - gp.player.worldX + gp.player.screenX;\n        int screenY = worldY - gp.player.worldY + gp.player.screenY;\n            \n        // Ekranda görünüyor mu kontrol et\n        if(worldX + gp.tileSize/2 > gp.player.worldX - gp.player.screenX \n        && worldX - gp.tileSize/2 < gp.player.worldX + gp.player.screenX\n        && worldY + gp.tileSize/2 > gp.player.worldY - gp.player.screenY \n        && worldY - gp.tileSize/2 < gp.player.worldY + gp.player.screenY) {\n                \n            // Görüntüyü döndürmek için AffineTransform kullan\n            AffineTransform at = new AffineTransform();\n                \n            // Çizim merkezini hesapla\n            int imageWidth = image.getWidth();\n            int imageHeight = image.getHeight();\n            screenX -= imageWidth / 2;\n            screenY -= imageHeight / 2;\n                \n            // Dönüş için bileşenleri ayarla\n            at.translate(screenX + imageWidth/2, screenY + imageHeight/2);\n            at.rotate(rad);\n            at.translate(-imageWidth/2, -imageHeight/2);\n                \n            // Döndürülmüş görüntüyü çiz\n            g2.drawImage(image, at, null);\n                \n            // Debug mod - Çarpışma alanını görselleştirme (isteğe bağlı)\n            //g2.setColor(Color.RED);\n            //g2.drawRect(screenX + solidArea.x, screenY + solidArea.y, solidArea.width, solidArea.height);\n            }\n        }\n    }\n\n    public void update() {\n        // Mermiyi hızına göre hareket ettir\n        worldX += speedX;\n        worldY += speedY;\n        \n        // Ömür sayacını artır\n        lifetime++;\n        \n        // Ömür süresini kontrol et\n        if(lifetime >= lifespan) {\n            contact = true;\n        }\n    }\n\n    // Çarpışma alanını hareket yönüne göre ayarla\n    public void setupSolidArea(int width, int height) {\n        // Çarpışma alanı boyutlarını ayarla\n        solidArea.width = width;\n        solidArea.height = height;\n\n        // Varsayılan değerleri kaydet\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n    }\n\n    public void speedHandler(){\n        solidArea.x = (image.getWidth() - solidArea.width) / 2;\n        solidArea.y = (image.getHeight() - solidArea.height) / 2;\n\n        // Güncellenen değerleri solidAreaDefault değişkenlerine ata!\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n    }\n\n    public void additionalFeature(Entity entity){\n    }\n}\n",
      "Zombie.java": "package Bil211Game2.Game.Entity;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic abstract class Zombie extends Monster{\n\n    public Zombie(GamePanel gp) {\n        super(gp);\n    }\n    \n}\n",
      "Entity.java": "package Bil211Game2.Game.Entity;\n\nimport java.awt.AlphaComposite;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.Serializable;\n\nimport javax.imageio.ImageIO;\n\nimport Bil211Game2.Game.Main.UtilityTool;\nimport Bil211Game2.Game.Objects.Ammos.Acid;\nimport Bil211Game2.Game.Objects.Ammos.SniperAmmo;\nimport Bil211Game2.Game.Main.GamePanel;\nimport Bil211Game2.Game.Main.Sound;\n\npublic abstract class Entity implements Serializable{\n    GamePanel gp;\n\n    public int worldX, worldY;\n    public int speed;\n    public int attackEntity = 1;\n\n    public BufferedImage up1, up2, down1, down2, \n    left1, left2, right1, right2,\n    attackUp1, attackUp2, attackDown1, attackDown2,\n    attackLeft1, attackLeft2, attackRight1, attackRight2;\n\n    public String direction = \"down\";\n\n    public int spriteCounter = 0;\n    public int spriteNum = 1;\n\n    public Rectangle solidArea = new Rectangle(0,0,48,48);\n    public Rectangle attackArea = new Rectangle(0,0,0,0);\n    public int solidAreaDefaultX, solidAreaDefaultY;\n    public boolean collisionOn = false;\n    public int actionLockCounter = 0;\n    public int invicibleCounter = 0;\n    public boolean invicible = false;\n    public int type;\n    public boolean attacking = false;\n    public boolean alive = true;\n    public boolean dying = false;\n    int dyingCounter = 0;\n    public boolean hpBarOn = false;\n    int hpBarCounter = 0;\n\n    public BufferedImage image, image2, image3;\n    public String name;\n    public boolean collision = false;\n\n    // CHARACTER STATUS\n    public int maxLife;\n    public int life;\n\n    public Entity(Bil211Game2.Game.Main.GamePanel gp2){\n        this.gp = gp2;\n    }\n\n    public void draw(Graphics2D g2){\n        int screenX = worldX - gp.player.worldX + gp.player.screenX;\n        int screenY = worldY - gp.player.worldY + gp.player.screenY;\n        \n        if(worldX + gp.tileSize > gp.player.worldX - gp.player.screenX \n        && worldX - gp.tileSize < gp.player.worldX + gp.player.screenX\n        && worldY + gp.tileSize > gp.player.worldY - gp.player.screenY \n        && worldY - gp.tileSize < gp.player.worldY + gp.player.screenY){\n            \n            BufferedImage image = null;\n\n            switch(direction){\n                case \"up\":\n                    if(spriteNum == 1){\n                        image = up1;\n                    }\n                    if(spriteNum == 2){\n                        image = up2;\n                    }\n                    break;\n                case \"down\":\n                    if(spriteNum == 1){\n                        image = down1;\n                    }\n                    if(spriteNum == 2){\n                        image = down2;\n                    }\n                    break;\n                case \"left\":\n                    if(spriteNum == 1){\n                        image = left1;\n                    }\n                    if(spriteNum == 2){\n                        image = left2;\n                    }\n                    break;\n                case \"right\":\n                    if(spriteNum == 1){\n                        image = right1;\n                    }\n                    if(spriteNum == 2){\n                        image = right2;\n                    }\n                    break;\n            }\n\n            if(type == 2 && hpBarOn){\n                hpBarCounter++;\n                if(hpBarCounter < 120){\n                    g2.setColor(new Color(35,35,35));\n                    g2.fillRect(screenX - 1, screenY-17, gp.tileSize + 2, 13);\n                    g2.setColor(new Color(255,0,30));\n                    g2.fillRect(screenX, screenY - 15, (int)(gp.tileSize *((double)life/maxLife)), 10);\n                }\n                else{\n                    hpBarOn = false;\n                    hpBarCounter = 0;\n                }\n            }\n\n            if(invicible){\n                hpBarOn = true;\n                changeAlphe(g2, 0.5f);\n            }\n            if(dying){\n                dyingAnimation(g2);\n            }\n\n            g2.drawImage(image, screenX, screenY, gp.tileSize, gp.tileSize, null);\n\n            changeAlphe(g2, 1f);\n        }\n    }\n\n    public void setAction(){};\n\n    public void dyingAnimation(Graphics2D g2){\n        int i = 5;\n\n        if(dyingCounter <= i){\n            changeAlphe(g2, 0f);\n        }\n        else if(dyingCounter <= i*2){\n            changeAlphe(g2, 1f);\n        }\n        else if(dyingCounter <= i*3){\n            changeAlphe(g2, 0f);\n        }\n        else if(dyingCounter <= i*4){\n            changeAlphe(g2, 1f);\n        }\n        else if(dyingCounter <= i*5){\n            changeAlphe(g2, 0f);\n        }\n        else if(dyingCounter <= i*6){\n            changeAlphe(g2, 1f);\n        }\n        else if(dyingCounter <= i*7){\n            changeAlphe(g2, 0f);\n        }\n        else if(dyingCounter <= i*8){\n            changeAlphe(g2, 1f);\n        }\n    }\n\n    public void changeAlphe(Graphics2D g2, float alphaValue){\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alphaValue));\n    }\n\n    public  void update(){\n        setAction();\n\n        collisionOn = false;\n        gp.cChecker.checkTile(this);\n        boolean contactPlayer = gp.cChecker.checkPlayer(this);\n        gp.cChecker.checkEntity(this, gp.monsters);\n\n        for(int i = 0; i < gp.ammos.size(); i++){\n            if(!(gp.ammos.get(i) instanceof Acid) && gp.cChecker.checkAmmo(gp.ammos.get(i), this)){\n                gp.ammos.get(i).additionalFeature(this);\n                shooted(gp.ammos.get(i).attack);\n                if(!(gp.ammos.get(i) instanceof SniperAmmo)){\n                    gp.ammos.set(i, null);\n                    gp.ammos.remove(i);\n                }\n                gp.playSE(Sound.ZOMBIE_HURT);\n            }\n        }\n\n        if(this.type == 2 && contactPlayer){\n            if(!gp.player.invicible){\n                gp.player.life -= attackEntity;\n                gp.player.invicible = true;\n                gp.startScreenShake(8, 15);\n                gp.playSE(Sound.PLAYER_HURT);\n            }\n        }\n\n        if(!collisionOn){\n            switch(direction){\n                case \"up\":\n                    worldY -= speed;\n                    break;\n                case \"down\":\n                    worldY += speed;\n                    break;\n                case \"left\":\n                    worldX -= speed;\n                    break;\n                case \"right\":\n                    worldX += speed;\n                    break;\n            }\n        }\n\n        spriteCounter++;\n        if(spriteCounter > 12){\n            if(spriteNum == 1){\n                spriteNum = 2;\n            }\n            else if(spriteNum == 2){\n                spriteNum = 1;\n            }\n            spriteCounter = 0;\n        }\n\n        if(invicible){\n            invicibleCounter++;\n            if(invicibleCounter > 40){\n                invicible = false;\n                invicibleCounter = 0;\n            }\n        }\n    }\n\n    public BufferedImage setUp(String imagePath, int width, int height){\n        BufferedImage image = null;\n\n        try{\n            image = ImageIO.read(getClass().getResourceAsStream(\"/Bil211Game/Resources/\" + imagePath + \".png\"));\n            image = UtilityTool.scaleImage(image, width, height);\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n\n        return image;\n    }\n\n    public BufferedImage setUpNew(String imagePath, int width, int height){\n        BufferedImage image = null;\n\n        try{\n            image = ImageIO.read(getClass().getResourceAsStream(\"/Bil211Game2/Resources/Images/\" + imagePath + \".png\"));\n            image = UtilityTool.scaleImage(image, width, height);\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n\n        return image;\n    }\n\n    public void damageReaction(){}\n\n    public void shooted(int damage){\n        invicible = true;\n        life -= damage;\n        damageReaction();\n    }\n\n    public void updateDying() {\n        dyingCounter++;\n        int i = 5;\n        \n        if(dyingCounter > i*8) {\n            dying = false;\n            alive = false;\n        }\n    }\n}\n",
      "AcidZombie.java": "package Bil211Game2.Game.Entity;\n\nimport Bil211Game2.Game.Main.GamePanel;\nimport Bil211Game2.Game.Main.Sound;\nimport Bil211Game2.Game.Objects.Ammos.Acid;\n\npublic class AcidZombie extends Zombie implements Acidity{\n\n    boolean canShoot = true;\n    int shootCounter = 0;\n    int defaultSpeed;\n    int shootCooldown = 120;\n\n    public AcidZombie(GamePanel gp) {\n        super(gp);\n\n        type = 2;\n        name = \"Acid Zombie\";\n        speed = 2;\n        maxLife = 2;\n        life = maxLife;\n        baseScore = 7;\n        attack = 1;\n    \n        solidArea.x = 3;\n        solidArea.y = 10;\n        solidArea.width = 42;\n        solidArea.height = 30;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        defaultSpeed = speed;\n\n        lootChance = 60;\n        rifleAmmoChance = 40;\n        shotgunAmmoChance = 40;\n        sniperAmmoChance = 10;\n        rocketAmmoChance = 10;\n\n        getImage();\n    }\n\n    public void getImage(){\n        up1 = setUpNew(\"Zombies/Turret Zombie Animation Frames/Up2\", gp.tileSize, gp.tileSize);\n        up2 = setUpNew(\"Zombies/Turret Zombie Animation Frames/Up3\", gp.tileSize, gp.tileSize);\n        down1 = setUpNew(\"Zombies/Turret Zombie Animation Frames/Down2\", gp.tileSize, gp.tileSize);\n        down2 = setUpNew(\"Zombies/Turret Zombie Animation Frames/Down3\", gp.tileSize, gp.tileSize);\n        left1 = setUpNew(\"Zombies/Turret Zombie Animation Frames/Left2\", gp.tileSize, gp.tileSize);\n        left2 = setUpNew(\"Zombies/Turret Zombie Animation Frames/Left3\", gp.tileSize, gp.tileSize);\n        right1 = setUpNew(\"Zombies/Turret Zombie Animation Frames/Right2\", gp.tileSize, gp.tileSize);\n        right2 = setUpNew(\"Zombies/Turret Zombie Animation Frames/Right3\", gp.tileSize, gp.tileSize);\n    }\n\n    public void setAction(){\n        actionLockCounter++;\n        \n        if(actionLockCounter > 60){\n            boolean flag = false; // TRUE : HORIZONTAL, FALSE : VERTICAL \n            if(Math.abs(gp.player.worldX - worldX) > Math.abs(gp.player.worldY - worldY)){\n                flag = true;\n            }\n\n            if(flag){\n                if(gp.player.worldX - worldX > 0){\n                    direction = \"right\";\n                }\n                else{\n                    direction = \"left\";\n                }\n            }\n            else{\n                if(gp.player.worldY - worldY > 0){\n                    direction = \"down\";\n                }\n                else{\n                    direction = \"up\";\n                }\n            }\n            actionLockCounter = 0;\n        }\n\n        if(!canShoot) {\n            shootCounter++;\n            if(shootCounter >= shootCooldown) {\n                canShoot = true;\n                shootCounter = 0;\n            }\n        }\n        else{\n            int xDistance = Math.abs(gp.player.worldX - worldX);\n            int yDistance = Math.abs(gp.player.worldY - worldY);\n            int totalDistance = (int) Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n            \n            // 8 tile menzil içindeyse ateş et\n            if(totalDistance < 8 * gp.tileSize) {\n                rangeAttack();\n                canShoot = false;\n                shootCounter = 0;\n            }\n        }\n    }\n\n    public void rangeAttack(){\n        Acid acid = shootAmmo();\n        if(acid != null) {\n            gp.ammos.add(acid);\n        }\n    }\n\n    @Override\n    public void damageReaction() {\n        actionLockCounter = 0;\n        direction = gp.player.direction;\n    }\n\n    public Acid shootAmmo(){\n        Acid acid = new Acid(gp);\n        int playerX = gp.player.worldX;\n        int playerY = gp.player.worldY;\n    \n        // Mermi başlangıç pozisyonunu hesapla\n        int ammoX, ammoY;\n    \n        // Yöne bağlı olarak mermi çıkış noktasını ayarla\n        switch(direction) {\n            case \"up\":\n                ammoX = worldX + gp.tileSize/2;\n                ammoY = worldY - gp.tileSize/2;\n                break;\n            case \"down\":\n                ammoX = worldX + gp.tileSize/2;\n                ammoY = worldY + gp.tileSize;\n                break;\n            case \"left\":\n                ammoX = worldX - gp.tileSize/2;\n                ammoY = worldY + gp.tileSize/2;\n                break;\n            case \"right\":\n                ammoX = worldX + gp.tileSize;\n                ammoY = worldY + gp.tileSize/2;\n                break;\n            default:\n                ammoX = worldX + gp.tileSize/2;\n                ammoY = worldY + gp.tileSize/2;\n                break;\n        }\n    \n        acid.worldX = ammoX;\n        acid.worldY = ammoY;\n    \n        // Hasarı ayarla\n        acid.attack = attack;\n    \n        // Oyuncuya doğru açıyı hesapla\n        acid.rad = Math.atan2(playerY - ammoY, playerX - ammoX);\n    \n        // Açıya göre hızı hesapla\n        acid.speedY = (int)(Acid.defaultSpeed*Math.sin(acid.rad));\n        acid.speedX = (int)(Acid.defaultSpeed*Math.cos(acid.rad));\n        \n        // Çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan\n        acid.setupSolidArea(gp.tileSize/2, gp.tileSize/2);\n        acid.speedHandler();\n\n        gp.playSE(Sound.ACID_ZOMBIE_ACID_SOUND);\n    \n        return acid;\n    }\n\n    @Override\n    public void splash() {\n        gp.animationManager.addAcidSplash(worldX, worldY);\n\n        for(int i = 0; i < gp.monsters.size(); i++){\n            if(gp.monsters.get(i) != null && !gp.monsters.get(i).invicible){\n                Monster monster = gp.monsters.get(i);\n                int monsterX = monster.worldX;\n                int monsterY = monster.worldY;\n                double distances = Math.sqrt((monsterX - worldX) * (monsterX - worldX) + (monsterY - worldY) * (monsterY - worldY));\n                if(distances < 3 * gp.tileSize){\n                    monster.damageReaction();\n                    monster.invicible = true;\n                    monster.life -= attack;\n                }\n            }\n        }\n\n        if(gp.player != null && !gp.player.invicible){\n            int playerX = gp.player.worldX;\n            int playerY = gp.player.worldY;\n            double distances = Math.sqrt((playerX - worldX) * (playerX - worldX) + (playerY - worldY) * (playerY - worldY));\n            if(distances < 3 * gp.tileSize){\n                gp.player.invicible = true;\n                gp.player.life -= attack;\n            }\n        }\n    }\n\n    @Override\n    public void kill() {\n        gp.player.score += (gp.currentPhase+1)*baseScore;\n        splash();\n        gp.animationManager.addBloodSplash(worldX, worldY);\n        gp.startScreenShake(20, 20);\n        looting();\n    }    \n}\n",
      "Acidity.java": "package Bil211Game2.Game.Entity;\n\npublic interface Acidity {\n    public void splash();\n}\n",
      "ReptileZombie.java": "package Bil211Game2.Game.Entity;\n\nimport java.util.Random;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic class ReptileZombie extends Zombie implements Jumpable{\n\n    boolean canJump = true;\n    int jumpCounter = 0;\n    int defaultSpeed;\n    boolean isJumping = false;\n    boolean jumpFlag = false;  // Sınıf üyesi olarak tanımlandı\n    Random random = new Random();\n\n    public ReptileZombie(GamePanel gp) {\n        super(gp);\n\n        type = 2;\n        name = \"Reptile Zombie\";\n        speed = 4;\n        maxLife = 2;\n        life = maxLife;\n        baseScore = 3;\n        attack = 1;\n    \n        solidArea.x = 3;\n        solidArea.y = 10;\n        solidArea.width = 42;\n        solidArea.height = 30;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        defaultSpeed = speed;\n\n        lootChance = 40;\n        rifleAmmoChance = 80;\n        shotgunAmmoChance = 20;\n\n        getImage();\n    }\n\n    public void getImage(){\n        up1 = setUpNew(\"Zombies/Kid Zombie Animation Frames/Up2\", gp.tileSize, gp.tileSize);\n        up2 = setUpNew(\"Zombies/Kid Zombie Animation Frames/Up3\", gp.tileSize, gp.tileSize);\n        down1 = setUpNew(\"Zombies/Kid Zombie Animation Frames/Down2\", gp.tileSize, gp.tileSize);\n        down2 = setUpNew(\"Zombies/Kid Zombie Animation Frames/Down3\", gp.tileSize, gp.tileSize);\n        left1 = setUpNew(\"Zombies/Kid Zombie Animation Frames/Left2\", gp.tileSize, gp.tileSize);\n        left2 = setUpNew(\"Zombies/Kid Zombie Animation Frames/Left3\", gp.tileSize, gp.tileSize);\n        right1 = setUpNew(\"Zombies/Kid Zombie Animation Frames/Right2\", gp.tileSize, gp.tileSize);\n        right2 = setUpNew(\"Zombies/Kid Zombie Animation Frames/Right3\", gp.tileSize, gp.tileSize);\n    }\n\n    public void setAction(){\n        actionLockCounter++;\n        \n        if(actionLockCounter > 60){\n            jumpFlag = random.nextBoolean();\n            \n            boolean flag = false; // TRUE : HORIZONTAL, FALSE : VERTICAL \n            if(Math.abs(gp.player.worldX - worldX) > Math.abs(gp.player.worldY - worldY)){\n                flag = true;\n            }\n\n            if(flag){\n                if(gp.player.worldX - worldX > 0){\n                    direction = \"right\";\n                }\n                else{\n                    direction = \"left\";\n                }\n            }\n            else{\n                if(gp.player.worldY - worldY > 0){\n                    direction = \"down\";\n                }\n                else{\n                    direction = \"up\";\n                }\n            }\n            actionLockCounter = 0;\n        }\n        \n        int xDistance = Math.abs(gp.player.worldX - worldX);\n        int yDistance = Math.abs(gp.player.worldY - worldY);\n        int totalDistance = (int) Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n\n        if(isJumping) {\n            jumpCounter++;\n            \n            if(jumpCounter > 5) {\n                speed = defaultSpeed;\n                isJumping = false;\n            }\n        }\n        else {\n            if(!canJump) {\n                jumpCounter++;\n                if(jumpCounter > 300) {\n                    canJump = true;\n                    jumpCounter = 0;\n                }\n            }\n            else if(totalDistance < gp.tileSize * 5 && canJump && jumpFlag) {\n                speed = defaultSpeed * 5;\n                isJumping = true;\n                canJump = false;\n                jumpCounter = 0;\n                jumpFlag = false;\n            }\n        }\n    }\n\n    @Override\n    public void damageReaction() {\n        actionLockCounter = 0;\n        direction = gp.player.direction;\n    }\n\n    @Override\n    public void jump() {\n        // Jumpable arayüzünden gelen metot, gerekirse içeriği doldurulabilir\n    }\n\n    @Override\n    public void kill() {\n        gp.player.score += (gp.currentPhase+1)*baseScore;\n        gp.animationManager.addBloodSplash(worldX, worldY);\n        looting();\n    }\n}",
      "NormalZombie.java": "package Bil211Game2.Game.Entity;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic class NormalZombie extends Zombie{\n\n    public NormalZombie(GamePanel gp) {\n        super(gp);\n\n        type = 2;\n        name = \"Normal Zombie\";\n        speed = 2;\n        maxLife = 4;\n        life = maxLife;\n        baseScore = 1;\n        attack = 1;\n    \n        solidArea.x = 3;\n        solidArea.y = 10;\n        solidArea.width = 42;\n        solidArea.height = 30;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        lootChance = 20;\n        rifleAmmoChance = 100;\n\n        getImage();\n    }\n\n    public void getImage(){\n        up1 = setUpNew(\"Zombies/Skinny Walking Zombie Animation/Up2\", gp.tileSize, gp.tileSize);\n        up2 = setUpNew(\"Zombies/Skinny Walking Zombie Animation/Up3\", gp.tileSize, gp.tileSize);\n        down1 = setUpNew(\"Zombies/Skinny Walking Zombie Animation/Down2\", gp.tileSize, gp.tileSize);\n        down2 = setUpNew(\"Zombies/Skinny Walking Zombie Animation/Down3\", gp.tileSize, gp.tileSize);\n        left1 = setUpNew(\"Zombies/Skinny Walking Zombie Animation/Left2\", gp.tileSize, gp.tileSize);\n        left2 = setUpNew(\"Zombies/Skinny Walking Zombie Animation/Left3\", gp.tileSize, gp.tileSize);\n        right1 = setUpNew(\"Zombies/Skinny Walking Zombie Animation/Right2\", gp.tileSize, gp.tileSize);\n        right2 = setUpNew(\"Zombies/Skinny Walking Zombie Animation/Right3\", gp.tileSize, gp.tileSize);\n    }\n\n    public void setAction(){\n        actionLockCounter++;\n        if(actionLockCounter > 60){\n            boolean flag = false; // TRUE : HORIZONTAL, FALSE : VERTICAL \n            if(Math.abs(gp.player.worldX - worldX) > Math.abs(gp.player.worldY - worldY)){\n                flag = true;\n            }\n\n            if(flag){\n                if(gp.player.worldX - worldX > 0){\n                    direction = \"right\";\n                }\n                else{\n                    direction = \"left\";\n                }\n            }\n            else{\n                if(gp.player.worldY - worldY > 0){\n                    direction = \"down\";\n                }\n                else{\n                    direction = \"up\";\n                }\n            }\n            actionLockCounter = 0;\n        }\n    }\n\n    @Override\n    public void damageReaction() {\n        actionLockCounter = 0;\n        direction = gp.player.direction;\n    }\n\n    @Override\n    public void kill() {\n        gp.player.score += (gp.currentPhase+1)*baseScore;\n        gp.animationManager.addBloodSplash(worldX, worldY);\n        looting();\n    }\n}\n",
      "Monster.java": "package Bil211Game2.Game.Entity;\n\nimport java.util.Random;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic abstract class Monster extends Entity{\n\n    public int baseScore = 1;\n    public int attack = 0;\n\n    public int lootChance = 0;\n    public int rifleAmmoChance = 0;\n    public int shotgunAmmoChance = 0;\n    public int sniperAmmoChance = 0;\n    public int rocketAmmoChance = 0;\n\n    public Monster(GamePanel gp2) {\n        super(gp2);\n    }\n\n    public abstract void kill();\n\n    @Override\n    public void update() {\n        if(life <= 0){\n            kill();\n            dying = true;\n            return;\n        }\n        super.update();\n    }\n    \n    public String lootAmmoType(){\n        Random random = new Random();\n        int lootFalled = random.nextInt(101);\n        boolean falled = false;\n        if(100 - lootFalled > lootChance){\n            falled = true;\n        }\n\n        if(falled){\n            int ammoType = random.nextInt(101);\n            if(ammoType < rifleAmmoChance){\n                return \"rifle\";\n            }\n            else if(ammoType < rifleAmmoChance + shotgunAmmoChance){\n                return \"shotgun\";\n            }\n            else if(ammoType < rifleAmmoChance + shotgunAmmoChance + sniperAmmoChance){\n                return \"sniper\";\n            }\n            else{\n                return \"rocket\";\n            }\n        }\n\n        return \"null\";\n    }\n\n    public void looting(){\n        String loot = lootAmmoType();\n        \n        switch(loot){\n            case \"rifle\":\n                gp.player.weapons[1].ammo += 5;\n                break;\n            case \"shotgun\":\n                gp.player.weapons[2].ammo += 5;\n                break;\n            case \"sniper\":\n                gp.player.weapons[3].ammo += 5;\n                break;\n            case \"rocket\":\n                gp.player.weapons[4].ammo += 5;\n                break;\n            default:\n                break;\n        }\n    }\n}\n",
      "TankZombie.java": "package Bil211Game2.Game.Entity;\n\nimport Bil211Game2.Game.Main.GamePanel;\n\npublic class TankZombie extends Zombie{\n\n    public TankZombie(GamePanel gp) {\n        super(gp);\n\n        type = 2;\n        name = \"Tank Zombie\";\n        speed = 1;\n        maxLife = 4;\n        life = maxLife;\n        baseScore = 5;\n        attack = 2;\n        attackEntity = 2;\n    \n        solidArea.x = 3;\n        solidArea.y = 10;\n        solidArea.width = 42;\n        solidArea.height = 30;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        lootChance = 50;\n        rifleAmmoChance = 60;\n        shotgunAmmoChance = 30;\n        sniperAmmoChance = 10;\n\n        getImage();\n    }\n\n    public void getImage(){\n        up1 = setUpNew(\"Zombies/Big Zombie Walking Animation Frames/Up2\", gp.tileSize, gp.tileSize);\n        up2 = setUpNew(\"Zombies/Big Zombie Walking Animation Frames/Up3\", gp.tileSize, gp.tileSize);\n        down1 = setUpNew(\"Zombies/Big Zombie Walking Animation Frames/Down2\", gp.tileSize, gp.tileSize);\n        down2 = setUpNew(\"Zombies/Big Zombie Walking Animation Frames/Down3\", gp.tileSize, gp.tileSize);\n        left1 = setUpNew(\"Zombies/Big Zombie Walking Animation Frames/Left2\", gp.tileSize, gp.tileSize);\n        left2 = setUpNew(\"Zombies/Big Zombie Walking Animation Frames/Left3\", gp.tileSize, gp.tileSize);\n        right1 = setUpNew(\"Zombies/Big Zombie Walking Animation Frames/Right2\", gp.tileSize, gp.tileSize);\n        right2 = setUpNew(\"Zombies/Big Zombie Walking Animation Frames/Right3\", gp.tileSize, gp.tileSize);\n    }\n\n    public void setAction(){\n        actionLockCounter++;\n        if(actionLockCounter > 60){\n            boolean flag = false; // TRUE : HORIZONTAL, FALSE : VERTICAL \n            if(Math.abs(gp.player.worldX - worldX) > Math.abs(gp.player.worldY - worldY)){\n                flag = true;\n            }\n\n            if(flag){\n                if(gp.player.worldX - worldX > 0){\n                    direction = \"right\";\n                }\n                else{\n                    direction = \"left\";\n                }\n            }\n            else{\n                if(gp.player.worldY - worldY > 0){\n                    direction = \"down\";\n                }\n                else{\n                    direction = \"up\";\n                }\n            }\n            actionLockCounter = 0;\n        }\n    }\n\n    @Override\n    public void damageReaction() {\n        actionLockCounter = 0;\n        direction = gp.player.direction;\n    }\n\n    @Override\n    public void kill() {\n        gp.player.score += (gp.currentPhase+1)*baseScore;\n        gp.animationManager.addBloodSplash(worldX, worldY);\n        looting();\n    }\n    \n}\n",
      "Player.java": "package Bil211Game2.Game.Entity;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\nimport Bil211Game2.Game.Main.KeyHandler;\nimport Bil211Game2.Game.Main.GamePanel;\nimport Bil211Game2.Game.Main.MouseHandler;\nimport Bil211Game2.Game.Main.Sound;\nimport Bil211Game2.Game.Main.UtilityTool;\nimport Bil211Game2.Game.Objects.Ammos.Acid;\nimport Bil211Game2.Game.Objects.Ammos.SniperAmmo;\nimport Bil211Game2.Game.Objects.Weapons.Pistol;\nimport Bil211Game2.Game.Objects.Weapons.Rifle;\nimport Bil211Game2.Game.Objects.Weapons.RocketLauncher;\nimport Bil211Game2.Game.Objects.Weapons.Shotgun;\nimport Bil211Game2.Game.Objects.Weapons.Sniper;\nimport Bil211Game2.Game.Objects.Weapons.Weapon;\n\npublic class Player extends Entity{\n    KeyHandler keyH;\n    MouseHandler mouseH;\n    int standCounter = 0;\n    public boolean standing = false;\n    int attackCounter = 0;\n    boolean canAttact = false;\n    public int score = 0;\n\n    public final int screenX, screenY;\n\n    public int currentWeaponIndex;\n    public Weapon[] weapons = new Weapon[5];\n\n    private Monster closestZombie = null;\n    private int zombieDetectionTimer = 0;\n    private final int ZOMBIE_DETECTION_DURATION = 180;\n    private boolean zombieDetectionActive = false;\n\n    public Player(GamePanel gp, KeyHandler keyH, MouseHandler mouseH) {\n        super(gp);\n        this.keyH = keyH;\n        this.mouseH = mouseH;\n        screenX = gp.screenWidth/2 - (gp.tileSize/2);\n        screenY = gp.screenHeight/2 - (gp.tileSize/2);\n\n        // OVERRIDE SOLID AREA\n        solidArea = new Rectangle();\n        solidArea.x = 8;\n        solidArea.y = 16;\n        solidArea.width = 32;\n        solidArea.height = 32;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        attackArea.width = 36;\n        attackArea.height = 36;\n\n        currentWeaponIndex = 0;\n        weapons[0] = new Pistol(gp);\n        weapons[1] = new Rifle(gp);\n        weapons[2] = new Shotgun(gp);\n        weapons[3] = new Sniper(gp);\n        weapons[4] = new RocketLauncher(gp);\n\n        setDefaultValues();\n        getPlayerImage();\n        //getPlayerAttackImage();\n    }\n\n    public void setDefaultValues(){\n        worldX = gp.tileSize * 23;\n        worldY = gp.tileSize * 21;\n        speed = 4;\n        direction = \"down\";\n\n        // Player Status\n        maxLife = 6;\n        life = maxLife;\n    }\n\n    public void getPlayerImage(){\n        up1 = setUpNew(\"Player/Player Character Walking Animation Frames/Up2\", gp.tileSize, gp.tileSize);\n        up2 = setUpNew(\"Player/Player Character Walking Animation Frames/Up3\", gp.tileSize, gp.tileSize);\n        down1 = setUpNew(\"Player/Player Character Walking Animation Frames/Down2\", gp.tileSize, gp.tileSize);\n        down2 = setUpNew(\"Player/Player Character Walking Animation Frames/Down3\", gp.tileSize, gp.tileSize);\n        left1 = setUpNew(\"Player/Player Character Walking Animation Frames/Left2\", gp.tileSize, gp.tileSize);\n        left2 = setUpNew(\"Player/Player Character Walking Animation Frames/Left3\", gp.tileSize, gp.tileSize);\n        right1 = setUpNew(\"Player/Player Character Walking Animation Frames/Right2\", gp.tileSize, gp.tileSize);\n        right2 = setUpNew(\"Player/Player Character Walking Animation Frames/Right3\", gp.tileSize, gp.tileSize);\n    }\n\n    public void getPlayerAttackImage(){\n        attackUp1 = setUpNew(\"Player/Player Character Walking Animation Frames/Up2\", gp.tileSize, gp.tileSize);\n        attackUp2 = setUpNew(\"Player/Player Character Walking Animation Frames/Up3\", gp.tileSize, gp.tileSize);\n        attackDown1 = setUpNew(\"Player/Player Character Walking Animation Frames/Up3\", gp.tileSize, gp.tileSize);\n        attackDown2 = setUpNew(\"Player/Player Character Walking Animation Frames/Up3\", gp.tileSize, gp.tileSize);\n        attackLeft1 = setUpNew(\"Player/Player Character Walking Animation Frames/Up3\", gp.tileSize, gp.tileSize);\n        attackLeft2 = setUpNew(\"Player/Player Character Walking Animation Frames/Up3\", gp.tileSize, gp.tileSize);\n        attackRight1 = setUpNew(\"Player/Player Character Walking Animation Frames/Up3\", gp.tileSize, gp.tileSize);\n        attackRight2 = setUpNew(\"Player/Player Character Walking Animation Frames/Up3\", gp.tileSize, gp.tileSize);\n    }\n    \n    @Override\n    public void update(){\n\n        if(life <= 0){\n            gp.gameState = gp.finishState;\n            return;\n        }\n\n        if(keyH.HPressed && !zombieDetectionActive) {\n            findClosestZombie();\n            zombieDetectionTimer = 0;\n            zombieDetectionActive = true;\n        }\n\n        if(zombieDetectionActive) {\n            zombieDetectionTimer++;\n            if(zombieDetectionTimer > ZOMBIE_DETECTION_DURATION) {\n                zombieDetectionActive = false;\n                closestZombie = null;\n            }\n        }\n\n        attackCounter++;\n        if(mouseH.mouseLeftPressed){\n            if(attackCounter > 60/((double)weapons[currentWeaponIndex].fireRate/60)){\n                canAttact = true;\n                attackCounter = 0;\n            }\n            else{\n                canAttact = false;\n            }\n        }\n        else{\n            canAttact = false;\n        }\n\n        if(canAttact){\n            attacking(mouseH.event.getX(), mouseH.event.getY());\n        }\n\n\n        if(keyH.upPressed||keyH.downPressed||keyH.leftPressed||keyH.rightPressed){\n            if(keyH.upPressed){\n                direction = \"up\";\n            }\n            else if(keyH.downPressed){\n                direction = \"down\";\n            }\n            else if(keyH.rightPressed){\n                direction = \"right\";\n            }\n            else if(keyH.leftPressed){\n                direction = \"left\";\n            }\n            standing = true;\n\n            collisionOn = false;\n            gp.cChecker.checkTile(this);\n\n            int monsterIndex = gp.cChecker.checkEntity(this, gp.monsters);\n            contactMonster(monsterIndex);\n\n            gp.eHandler.checkEvent();\n\n            for(int i = 0; i < gp.ammos.size(); i++){\n                if(gp.ammos.get(i) instanceof Acid && gp.cChecker.checkAmmo(gp.ammos.get(i), this)){\n                    life -= gp.ammos.get(i).attack;\n                    invicible = true;\n                    gp.ammos.set(i, null);\n                    gp.ammos.remove(i);\n                    gp.startScreenShake(12, 15);\n                    gp.playSE(Sound.PLAYER_HURT);\n                }\n            }\n\n            if(!collisionOn){\n                switch(direction){\n                    case \"up\":\n                        worldY -= speed;\n                        break;\n                    case \"down\":\n                        worldY += speed;\n                        break;\n                    case \"left\":\n                        worldX -= speed;\n                        break;\n                    case \"right\":\n                        worldX += speed;\n                        break;\n                }\n            }\n    \n            spriteCounter++;\n            if(spriteCounter > 12){\n                if(spriteNum == 1){\n                    spriteNum = 2;\n                }\n                else if(spriteNum == 2){\n                    spriteNum = 1;\n                }\n                spriteCounter = 0;\n            }\n        }\n        else{\n            for(int i = 0; i < gp.ammos.size(); i++){\n                if(gp.ammos.get(i) instanceof Acid && gp.cChecker.checkAmmo(gp.ammos.get(i), this)){\n                    life -= gp.ammos.get(i).attack;\n                    invicible = true;\n                    if(!(gp.ammos.get(i) instanceof SniperAmmo)){\n                        gp.ammos.set(i, null);\n                        gp.ammos.remove(i);\n                    }\n                    gp.playSE(Sound.PLAYER_HURT);\n                }\n            }\n            standing = false;\n            standCounter++;\n\n            if(standCounter == 20){\n                spriteNum = 1;\n                standCounter = 0;\n            }\n            \n        }\n\n        if(invicible){\n            invicibleCounter++;\n            if(invicibleCounter > 60){\n                invicible = false;\n                invicibleCounter = 0;\n            }\n        }\n    }\n\n    public void draw(Graphics2D g2){\n        BufferedImage image = null;\n        int tempScreenX = screenX;\n        int tempScreenY = screenY;\n\n        switch(direction){\n            case \"up\":\n                if(attacking){\n                    tempScreenY = tempScreenY - gp.tileSize;\n                    if(spriteNum == 1){\n                        image = attackUp1;\n                    }\n                    if(spriteNum == 2){\n                        image = attackUp2;\n                    }\n                }\n                else{\n                    if(spriteNum == 1){\n                        image = up1;\n                    }\n                    if(spriteNum == 2){\n                        image = up2;\n                    }\n                }\n                break;\n            case \"down\":\n                if(attacking){\n                    if(spriteNum == 1){\n                        image = attackDown1;\n                    }\n                    if(spriteNum == 2){\n                        image = attackDown2;\n                    }\n                }\n                else{\n                    if(spriteNum == 1){\n                        image = down1;\n                    }\n                    if(spriteNum == 2){\n                        image = down2;\n                    }\n                }\n                break;\n            case \"left\":\n                if(attacking){\n                    tempScreenX = tempScreenX - gp.tileSize;\n                    if(spriteNum == 1){\n                        image = attackLeft1;\n                    }\n                    if(spriteNum == 2){\n                        image = attackLeft2;\n                    }\n                }\n                else{\n                    if(spriteNum == 1){\n                        image = left1;\n                    }\n                    if(spriteNum == 2){\n                        image = left2;\n                    }\n                }\n                break;\n            case \"right\":\n                if(attacking){\n                    if(spriteNum == 1){\n                        image = attackRight1;\n                    }\n                    if(spriteNum == 2){\n                        image = attackRight2;\n                    }\n                }\n                else{\n                    if(spriteNum == 1){\n                        image = right1;\n                    }\n                    if(spriteNum == 2){\n                        image = right2;\n                    }\n                }\n                break;\n        }\n\n        if(invicible){\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));\n        }\n\n        g2.drawImage(image, tempScreenX, tempScreenY, null);\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1f));\n\n        if(zombieDetectionActive && closestZombie != null) {\n            drawDirectionArrow(g2);\n        }\n    }\n\n    public void contactMonster(int index){\n        if(index != 999){\n            if(!invicible){\n                life--;\n                invicible = true;\n                gp.startScreenShake(8, 15);\n            }\n        }\n    }\n\n    public void attacking(int x, int y){\n        weapons[currentWeaponIndex].fire(worldX + x - gp.screenWidth/2, worldY + y - gp.screenHeight/2);\n    }\n\n    public void changeWeapon(int i){\n        if(gp.gameState == gp.playState){\n            if(i == 0){\n                currentWeaponIndex = 0;\n            }\n            else if(i == 1 && gp.currentPhase > gp.phase1){\n                currentWeaponIndex = 1;\n            }\n            else if(i == 2 && gp.currentPhase > gp.phase4){\n                currentWeaponIndex = 2;\n            }\n            else if(i == 3 && gp.currentPhase > gp.phase6){\n                currentWeaponIndex = 3;\n            }\n            else if(i == 4 && gp.currentPhase > gp.phase10){\n                currentWeaponIndex = 4;\n            }\n        }\n    }\n\n    public void damage(int i){\n        if(i != 999){\n            if(!gp.monsters.get(i).invicible){\n                gp.monsters.get(i).life--;\n                gp.monsters.get(i).invicible = true;\n                gp.monsters.get(i).damageReaction();\n\n                if(gp.monsters.get(i).life <= 0){\n                    gp.monsters.get(i).kill();\n                    gp.monsters.get(i).dying = true;\n                }\n            }   \n        }\n        \n    }\n\n    private void findClosestZombie() {\n        double closestDistance = Double.MAX_VALUE;\n        closestZombie = null;\n        \n        for(int i = 0; i < gp.monsters.size(); i++) {\n            Monster monster = gp.monsters.get(i);\n            if(monster != null && monster.alive && !monster.dying) {\n                double distance = UtilityTool.distanceCalculator(\n                    worldX, worldY, monster.worldX, monster.worldY);\n                \n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestZombie = monster;\n                }\n            }\n        }\n    }\n\n    public Monster getClosestZombie() {\n        return zombieDetectionActive ? closestZombie : null;\n    }\n\n    private void drawDirectionArrow(Graphics2D g2) {\n        if(closestZombie == null) return;\n        \n        // Zombi ile oyuncu arasındaki açıyı hesapla\n        int zombieX = closestZombie.worldX - gp.player.worldX;\n        int zombieY = closestZombie.worldY - gp.player.worldY;\n        double angle = Math.atan2(zombieY, zombieX);\n        \n        // Ok için parametreler\n        int arrowLength = gp.tileSize;\n        int arrowHeadSize = gp.tileSize / 3;\n        \n        // Okun başlangıç noktasını hesapla (oyuncunun merkezi)\n        int startX = screenX + gp.tileSize / 2;\n        int startY = screenY + gp.tileSize / 2;\n        \n        // Okun bitiş noktasını hesapla\n        int endX = startX + (int)(Math.cos(angle) * arrowLength);\n        int endY = startY + (int)(Math.sin(angle) * arrowLength);\n        \n        // Ok çiz\n        g2.setColor(new Color(255, 0, 0, 180));\n        \n        // Ok başı çiz\n        int[] xPoints = new int[3];\n        int[] yPoints = new int[3];\n        \n        xPoints[0] = endX;\n        yPoints[0] = endY;\n        \n        xPoints[1] = endX - (int)(Math.cos(angle + Math.PI/6) * arrowHeadSize);\n        yPoints[1] = endY - (int)(Math.sin(angle + Math.PI/6) * arrowHeadSize);\n        \n        xPoints[2] = endX - (int)(Math.cos(angle - Math.PI/6) * arrowHeadSize);\n        yPoints[2] = endY - (int)(Math.sin(angle - Math.PI/6) * arrowHeadSize);\n        \n        g2.fillPolygon(xPoints, yPoints, 3);\n        \n        // Etrafında parlayan bir halka çiz (radar efekti)\n        float pulseSize = 1.0f + 0.2f * (float)Math.sin(System.currentTimeMillis() * 0.005);\n        int ringSize = (int)((gp.tileSize + gp.tileSize/3) * pulseSize);\n        \n        g2.setColor(new Color(255, 0, 0, 50)); // Çok hafif kırmızı\n        g2.setStroke(new BasicStroke(2));\n        g2.drawOval(startX - ringSize/2, startY - ringSize/2, ringSize, ringSize);\n    }\n}\n",
      "Jumpable.java": "package Bil211Game2.Game.Entity;\n\npublic interface Jumpable {\n    public void jump();\n}\n"
    },
    {
      "id": "7214465",
      "Obstacle.java": "import java.awt.*;\n\npublic class Obstacle {\n    private Rectangle bounds;\n\n    public Obstacle(int x, int y, int width, int height) {\n        bounds = new Rectangle(x, y, width, height);\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.DARK_GRAY);\n        g.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);\n    }\n\n    public Rectangle getBounds() {\n        return bounds;\n    }\n}\n",
      "Weapon.java": "\npublic class Weapon {\n    private String name;\n    private int fireRate;\n    private int magazineSize;\n    private int totalAmmo;\n    private int ammoInMagazine;\n    private int damagePerShot;\n\n    public Weapon(String name, int fireRate, int magazineSize, int totalAmmo, int damagePerShot) {\n        this.name = name;\n        this.fireRate = fireRate;\n        this.magazineSize = magazineSize;\n        this.totalAmmo = totalAmmo;\n        this.ammoInMagazine = magazineSize;\n        this.damagePerShot = damagePerShot;\n    }\n\n    public boolean canShoot() { return ammoInMagazine > 0; }\n\n    public void shoot() {\n        if (ammoInMagazine > 0) ammoInMagazine--;\n    }\n\n    public void reload() {\n        int missing = magazineSize - ammoInMagazine;\n        if (totalAmmo >= missing) {\n            totalAmmo -= missing;\n            ammoInMagazine = magazineSize;\n        } \n        else {\n            ammoInMagazine += totalAmmo;\n            totalAmmo = 0;\n        }\n    }\n\n    public String getName() {\n        return name; \n    }\n    public int getMagazineSize() {\n        return magazineSize; \n    }\n    public int getAmmoInMagazine() {\n        return ammoInMagazine; \n    }\n    public int getTotalAmmo() {\n         return totalAmmo; \n    }\n    public int getDamagePerShot() {\n        return damagePerShot;\n    }\n}\n",
      "Bullet.java": "import java.awt.Rectangle;\n\npublic class Bullet {\n    private double x, y;\n    private double dirX, dirY;\n    private int speed = 10;\n    private boolean active = true;\n    private int damage;\n\n\n    public Bullet(int startX, int startY, int targetX, int targetY, int damage) {\n        this.x = startX;\n        this.y = startY;\n        this.damage = damage;\n        double angle = Math.atan2(targetY - startY, targetX - startX);\n        dirX = speed * Math.cos(angle);\n        dirY = speed * Math.sin(angle);\n    }\n\n    public void move() {\n        double newX = x + dirX;\n        double newY = y + dirY;\n        \n        if (newX < 0 || newX > 800 || newY < 0 || newY > 600) {\n            active = false;\n            return;\n        }\n\n        Rectangle futureBullet = new Rectangle((int)newX, (int)newY, 5, 5);\n        for (Obstacle o : GamePanel.obstacles) {    \n            if (o.getBounds().intersects(futureBullet)) {\n                active = false;\n                return;\n            }\n        }\n\n        x = newX;\n        y = newY;\n    }\n\n    public void draw(java.awt.Graphics g) {\n        g.setColor(java.awt.Color.YELLOW);\n        g.fillOval((int)x, (int)y, 5, 5);\n    }\n\n    public java.awt.Rectangle getBounds() {\n        return new java.awt.Rectangle((int)x, (int)y, 5, 5);\n    }\n\n    public boolean isActive() {\n        return active; \n    }\n\n    public void deactivate() {\n        active = false;\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n}\n",
      "BloodStain.java": "\nimport java.awt.*;\n\npublic class BloodStain {\n    private int x, y;\n    private int size;\n\n    public BloodStain(int x, int y) {\n        this.x = x;\n        this.y = y;\n        this.size = (int)(30 + Math.random() * 20);\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(new Color(139, 0, 0, 150));\n        g.fillOval(x, y, size, size);\n    }\n}\n",
      "GamePanel.java": "import java.awt.*;\nimport java.awt.event.*;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport java.util.*;\nimport javax.imageio.ImageIO;\nimport javax.sound.sampled.*;\nimport javax.swing.*;\nimport javax.swing.Timer;\nimport zombies.*;\n\n\npublic class GamePanel extends JPanel implements ActionListener, MouseMotionListener {\n\n    private boolean inMainMenu = true;\n    private boolean inHelpMenu = false;\n    private String playerName = \"Oyuncu\";\n\n    public static ArrayList<Obstacle> obstacles = new ArrayList<>();\n    private String mapTheme = \"Grassland\";\n    private Random rand = new Random();\n    private ArrayList<Shape> grassPatches = new ArrayList<>();\n    private ArrayList<Shape> dirtPaths = new ArrayList<>();\n    private ArrayList<Shape> darkForestBushes = new ArrayList<>();\n    private ArrayList<Shape> desertCracks = new ArrayList<>();\n    private ArrayList<Shape> desertRocks = new ArrayList<>();\n\n    private Timer timer;\n    private ArrayList<Zombie> zombies;\n    private ArrayList<Bullet> bullets;\n    private ArrayList<BloodStain> bloodStains;\n\n    public static int playerX = 300, playerY = 300;\n    private int playerSpeed = 5;\n\n    private Weapon[] weapons;\n    private int currentWeaponIndex = 0;\n\n    private int playerHealth = 100;\n    private boolean gameOver = false;\n    private boolean paused = false;\n\n    private int currentWave = 1;\n    private boolean waveInProgress = false;\n    private int zombiesPerWave = 5;\n\n    private int score = 0;\n\n    private float timeOfDay = 0.0f;\n    private float daySpeed = 0.0005f;\n\n    private String weather = \"Clear\";\n    private int weatherTimer = 0;\n    private int weatherDuration = 1000;\n\n    private ArrayList<Particle> rainParticles = new ArrayList<>();\n    private ArrayList<Particle> snowParticles = new ArrayList<>();\n\n    private int flashTimer = 0;\n\n    private BufferedImage playerImg;\n    private Point mousePosition = new Point(400, 300);\n\n    private Clip menuMusic;\n    private boolean menuMusicPlaying = false;\n    private float glowAlpha = 0.5f;\n    private boolean glowIncreasing = true;\n    private int haloOffset = 0;\n\n    private static final int MAX_WAVE = 13;\n    private boolean gameWon = false;\n\n    private ArrayList<ExplosionEffect> explosions = new ArrayList<>();\n\n    public GamePanel() {\n        setFocusable(true);\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.BLACK);\n        loadPlayerImage();\n        addMouseMotionListener(this);\n\n        zombies = new ArrayList<>();\n        bullets = new ArrayList<>();\n        bloodStains = new ArrayList<>();\n\n        obstacles.add(new Obstacle(200, 150, 400, 20));\n        obstacles.add(new Obstacle(200, 250, 20, 300));\n        obstacles.add(new Obstacle(580, 250, 20, 300));\n\n        mapTheme = \"Grassland\";\n        generateMapDetails();\n\n        weapons = new Weapon[] {\n            new Weapon(\"Pistol\", 120, 12, Integer.MAX_VALUE, 30),\n            new Weapon(\"Rifle\", 600, 30, 120, 20),\n            new Weapon(\"Shotgun\", 60, 5, 25, 50),\n            new Weapon(\"Sniper\", 30, 5, 15, 100),\n            new Weapon(\"Rocket Launcher\", 10, 1, 5, 200)\n        };\n\n        timer = new Timer(30, this);\n        timer.start();\n\n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                int key = e.getKeyCode();\n                if (gameOver && key == KeyEvent.VK_ENTER) {\n                    restartGame();\n                    return;\n                }\n                if (gameOver && key == KeyEvent.VK_Q) {\n                    System.exit(0);\n                    return;\n                }\n                if (gameOver && key == KeyEvent.VK_M) {\n                    inMainMenu = true;\n                    gameOver = false;\n                    return;\n                }\n                if (inMainMenu) {\n                    if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n                        inMainMenu = false;\n                        restartGame();\n                    }\n                    if (key == KeyEvent.VK_H) {\n                        inMainMenu = false;\n                        inHelpMenu = true;\n                        repaint();\n                    }\n                    if (e.getKeyCode() == KeyEvent.VK_Q) {\n                        System.exit(0);\n                    }\n                    repaint();\n                    return;\n                }\n                if (inHelpMenu) {\n                    if (key == KeyEvent.VK_B) { \n                        inHelpMenu = false;\n                        inMainMenu = true;\n                    }\n                    repaint();\n                    return;\n                }\n                if (e.getKeyCode() == KeyEvent.VK_P) {\n                    paused = !paused;\n                    repaint();\n                }\n                if (paused) {\n                    if (e.getKeyCode() == KeyEvent.VK_K) {\n                        saveGame();\n                    }\n                    if (e.getKeyCode() == KeyEvent.VK_L) {\n                        loadGame();\n                    }\n                    if (e.getKeyCode() == KeyEvent.VK_Q) {\n                        System.exit(0);\n                    }\n                }\n        \n                if (gameOver) return;\n\n                if (key == KeyEvent.VK_W) {\n                    playerY -= playerSpeed;\n                }    \n                if (key == KeyEvent.VK_S) {\n                    playerY += playerSpeed;\n                }\n                if (key == KeyEvent.VK_A){ \n                    playerX -= playerSpeed;\n                }    \n                if (key == KeyEvent.VK_D){ \n                    playerX += playerSpeed;\n                }    \n                if (key >= KeyEvent.VK_1 && key <= KeyEvent.VK_5) {\n                    checkWeaponAvailability(key);\n                }\n                if (key == KeyEvent.VK_R){ \n                    weapons[currentWeaponIndex].reload();\n                }    \n                if (key == KeyEvent.VK_M){\n                    changeMap();\n                }\n\n                if (!collidesWithObstacle(playerX, playerY - playerSpeed)) { \n                    playerY -= playerSpeed;\n                }\n                if (!collidesWithObstacle(playerX, playerY + playerSpeed)) { \n                    playerY += playerSpeed;\n                }\n                if (!collidesWithObstacle(playerX - playerSpeed, playerY)) {\n                    playerX -= playerSpeed;\n                }\n                if (!collidesWithObstacle(playerX + playerSpeed, playerY)){ \n                    playerX += playerSpeed;\n                }\n            }\n        });\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (paused || gameOver) {\n                    return;\n                }\n                Weapon currentWeapon = weapons[currentWeaponIndex];\n                \n                if (currentWeapon.getName().equals(\"Rocket Launcher\")) {\n                    int targetX = e.getX();\n                    int targetY = e.getY();\n                \n                    explosions.add(new ExplosionEffect(targetX, targetY));\n                    playSound(\"sounds/explosion.wav\");\n\n                    for (Zombie z : new ArrayList<>(zombies)) {\n                        if (new ExplosionEffect(targetX, targetY).getBounds().intersects(z.getBounds())) {\n                            z.takeDamage(currentWeapon.getDamagePerShot());\n                            if (z.isDead()) {\n                                zombies.remove(z);\n                                score += getZombieScore(z);\n                                bloodStains.add(new BloodStain(z.getBounds().x, z.getBounds().y));\n                                playSound(\"sounds/zombie_growl.wav\");\n                            }\n                        }\n                    }\n                \n                    return;\n                }\n\n                if (currentWeapon.canShoot()) {\n                    int targetX = e.getX();\n                    int targetY = e.getY();\n                    bullets.add(new Bullet(playerX + 20, playerY + 20, targetX, targetY, currentWeapon.getDamagePerShot()));\n                    currentWeapon.shoot();\n                    createMuzzleFlash();\n                    playSound(\"sounds/gunshot.wav\");\n                }\n            }\n        });\n    }\n\n    private void changeMap() {\n        if (mapTheme.equals(\"Grassland\")) {\n            mapTheme = \"DarkForest\";\n        }\n        else if (mapTheme.equals(\"DarkForest\")){ \n            mapTheme = \"Desert\";\n        }\n        else{ \n            mapTheme = \"Grassland\";\n        }\n        generateMapDetails();\n        repaint();\n    }\n\n    private void drawMap(Graphics2D g2d) {\n        switch (mapTheme) {\n            case \"Grassland\":\n                \n                g2d.setColor(new Color(180, 255, 180));\n                g2d.fillRect(0, 0, getWidth(), getHeight());\n\n                for (Shape s : grassPatches) {\n                    int greenVariation = rand.nextInt(30);\n                    g2d.setColor(new Color(34 + greenVariation, 139 + greenVariation, 34));\n                    g2d.fill(s);\n                    \n                    g2d.setColor(new Color(0, 100, 0, 100));\n                    g2d.draw(s);\n                }\n                for (Shape s : dirtPaths) {\n                    g2d.setColor(new Color(194, 178, 128));\n                    g2d.fill(s);\n                    \n                    g2d.setColor(new Color(160, 140, 90));\n                    g2d.draw(s);\n                }\n                break;\n\n            case \"DarkForest\":\n                g2d.setColor(new Color(20, 40, 20));\n                g2d.fillRect(0, 0, getWidth(), getHeight());\n\n                for (Shape s : darkForestBushes) {\n                    g2d.setColor(new Color(0, 30, 0));\n                    g2d.fill(s);\n                    \n                    g2d.setColor(new Color(0, 50, 0));\n                    g2d.draw(s);\n                    \n                    Ellipse2D.Double bush = (Ellipse2D.Double) s;\n                    int centerX = (int)(bush.x + bush.width/2);\n                    int centerY = (int)(bush.y + bush.height/2);\n                    int radius = (int)(bush.width/2);\n\n                    for (int i = 0; i < 3; i++) {\n                        int angle = rand.nextInt(360);\n                        int length = radius - rand.nextInt(radius/2);\n                        int endX = centerX + (int)(length * Math.cos(Math.toRadians(angle)));\n                        int endY = centerY + (int)(length * Math.sin(Math.toRadians(angle)));\n                        g2d.setColor(new Color(0, 40 + rand.nextInt(20), 0));\n                        g2d.drawLine(centerX, centerY, endX, endY);\n                    }\n                }\n                break;\n\n            case \"Desert\":\n                g2d.setColor(new Color(255, 240, 180));\n                g2d.fillRect(0, 0, getWidth(), getHeight());\n\n                for (Shape s : desertCracks) {\n                    g2d.setColor(new Color(220, 200, 160));\n                    g2d.fill(s);\n                    \n                    g2d.setColor(new Color(200, 180, 140));\n                    g2d.draw(s);\n                }\n                for (Shape s : desertRocks) {\n                    g2d.setColor(new Color(180, 160, 120));\n                    g2d.fill(s);\n\n                    g2d.setColor(new Color(210, 190, 140));\n                    g2d.draw(s);\n                    \n                    Rectangle2D.Double rock = (Rectangle2D.Double) s;\n                    g2d.setColor(new Color(200, 180, 130));\n                    g2d.drawLine((int)rock.x, (int)rock.y, \n                               (int)(rock.x + rock.width), (int)(rock.y + rock.height));\n                }\n                break;\n        }\n    }\n\n    private void generateMapDetails() {\n        grassPatches.clear();\n        dirtPaths.clear();\n        darkForestBushes.clear();\n        desertCracks.clear();\n        desertRocks.clear();\n\n        switch (mapTheme) {\n            case \"Grassland\":\n                for (int i = 0; i < 200; i++) {\n                    int x = rand.nextInt(800);\n                    int y = rand.nextInt(600);\n                    int size = rand.nextInt(8) + 4;\n                    grassPatches.add(new Ellipse2D.Double(x, y, size, size));\n                }\n                for (int i = 0; i < 12; i++) {\n                    int x = rand.nextInt(800);\n                    int y = rand.nextInt(600);\n                    int w = 80 + rand.nextInt(60);\n                    int h = 10 + rand.nextInt(6);\n                    dirtPaths.add(new Rectangle2D.Double(x, y, w, h));\n                }\n                break;\n\n            case \"DarkForest\":\n                for (int i = 0; i < 200; i++) {\n                    int x = rand.nextInt(800);\n                    int y = rand.nextInt(600);\n\n                    int size = 8 + rand.nextInt(15);\n                    darkForestBushes.add(new Ellipse2D.Double(x, y, size, size));\n                }\n                break;\n\n            case \"Desert\":\n                for (int i = 0; i < 150; i++) {\n                    int x = rand.nextInt(800);\n                    int y = rand.nextInt(600);\n                    int w = 6 + rand.nextInt(6);\n                    int h = 3 + rand.nextInt(3);\n                    desertCracks.add(new Ellipse2D.Double(x, y, w, h));\n                }\n                for (int i = 0; i < 30; i++) {\n                    int x = rand.nextInt(800);\n                    int y = rand.nextInt(600);\n                    int w = 15 + rand.nextInt(15);\n                    int h = 15 + rand.nextInt(15);\n                    desertRocks.add(new Rectangle2D.Double(x, y, w, h));\n                }\n                break;\n        }\n    }\n\n    private void startWave() {\n        waveInProgress = true;\n        spawnZombies(zombiesPerWave);\n    }\n    private void drawPauseMenu(Graphics g) {\n        \n        g.setColor(new Color(40, 40, 40, 220));\n        g.fillRoundRect(0, 0, 800, 600, 20, 20);\n        \n        g.setColor(new Color(255, 215, 0));\n        g.setFont(new Font(\"Arial\", Font.BOLD, 40));\n        g.drawString(\"OYUN DURAKLATILDI\", 200, 200);\n        \n        g.setColor(new Color(255, 215, 0, 150));\n        g.fillRect(200, 210, 420, 2);\n        \n        g.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        int y = 260;\n        \n        g.setColor(new Color(200, 200, 200));\n        g.fillRoundRect(250, y, 300, 40, 10, 10);\n        g.setColor(new Color(50, 50, 50));\n        g.drawRoundRect(250, y, 300, 40, 10, 10);\n        g.setColor(new Color(0, 0, 0));\n        g.drawString(\"Devam Et (P)\", 320, y + 28);\n        \n        y += 60;\n        g.setColor(new Color(200, 200, 200));\n        g.fillRoundRect(250, y, 300, 40, 10, 10);\n        g.setColor(new Color(50, 50, 50));\n        g.drawRoundRect(250, y, 300, 40, 10, 10);\n        g.setColor(new Color(0, 0, 0));\n        g.drawString(\"Oyunu Kaydet (K)\", 320, y + 28);\n        \n        y += 60;\n        g.setColor(new Color(200, 200, 200));\n        g.fillRoundRect(250, y, 300, 40, 10, 10);\n        g.setColor(new Color(50, 50, 50));\n        g.drawRoundRect(250, y, 300, 40, 10, 10);\n        g.setColor(new Color(0, 0, 0));\n        g.drawString(\"Kaydı Yükle (L)\", 320, y + 28);\n        \n        y += 60;\n        g.setColor(new Color(200, 100, 100));\n        g.fillRoundRect(250, y, 300, 40, 10, 10);\n        g.setColor(new Color(150, 50, 50));\n        g.drawRoundRect(250, y, 300, 40, 10, 10);\n        g.setColor(new Color(0, 0, 0));\n        g.drawString(\"Oyundan Çık (Q)\", 320, y + 28);\n    }\n    \n\n    private void spawnZombies(int count) {\n        Random rand = new Random();\n\n        int normalCount = 5 + (currentWave - 1);\n        int crawlerCount = currentWave >= 3 ? 3 + ((currentWave - 3) * 2) : 0;\n        int tankCount = currentWave >= 5 ? 5 + (currentWave - 5) : 0;\n        int spitterCount = currentWave >= 7 ? 3 + ((currentWave - 7) * 2) : 0;\n\n        for (int i = 0; i < normalCount; i++) {\n            int x = rand.nextInt(800);\n            int y = rand.nextInt(600);\n            zombies.add(generateZombieAtSafeDistance(new NormalZombie(x, y) , 150));\n        }\n        if (currentWave >= 3) {\n            for (int i = 0; i < crawlerCount; i++) {\n                int x = rand.nextInt(800);\n                int y = rand.nextInt(600);\n                zombies.add(generateZombieAtSafeDistance(new CrawlerZombie(x, y), 150));\n            }\n        }\n        if (currentWave >= 5) {\n            for (int i = 0; i < tankCount; i++) {\n                int x = rand.nextInt(800);\n                int y = rand.nextInt(600);\n                zombies.add(generateZombieAtSafeDistance(new TankZombie(x, y), 150));\n            }\n        }\n        if (currentWave >= 7) {\n            for (int i = 0; i < spitterCount; i++) {\n                int x = rand.nextInt(800);\n                int y = rand.nextInt(600);\n                zombies.add(generateZombieAtSafeDistance(new SpitterZombie(x, y) , 150));\n            }\n        }\n\n        zombiesPerWave = normalCount + crawlerCount + tankCount + spitterCount;\n    }\n    private Zombie generateZombieAtSafeDistance(Zombie zombie, int minDistance) {\n        Random rand = new Random();\n        int x, y;\n        do {\n            x = rand.nextInt(800);\n            y = rand.nextInt(600);\n        } while (Math.hypot(playerX - x, playerY - y) < minDistance);\n    \n        zombie.setX(x);\n        zombie.setY(y);\n        return zombie;\n    }\n    \n    private void nextWave() {\n        if (currentWave >= MAX_WAVE) {\n            gameWon = true;\n            timer.stop();\n            return;\n        }\n        currentWave++;\n        waveInProgress = true;\n\n        if (playerHealth < 60) {\n            playerHealth += 30;\n            if (playerHealth > 100) {\n                playerHealth = 100;\n            }\n        }\n        startWave();\n    }\n\n    private void restartGame() {\n        playerX = 300;\n        playerY = 300;\n        playerHealth = 100;\n        currentWave = 1;\n        zombiesPerWave = 3;\n        zombies.clear();\n        bullets.clear();\n        bloodStains.clear();\n        score = 0;\n        gameOver = false;\n        \n        weapons = new Weapon[] {\n            new Weapon(\"Pistol\", 120, 12, Integer.MAX_VALUE, 30),\n            new Weapon(\"Rifle\", 600, 30, 120, 20),\n            new Weapon(\"Shotgun\", 60, 5, 25, 50),\n            new Weapon(\"Sniper\", 30, 5, 15, 100),\n            new Weapon(\"Rocket Launcher\", 10, 1, 5, 200)\n        };\n        currentWeaponIndex = 0;\n        \n        startWave();\n        timer.start();\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        if (paused || gameOver) {\n            return;\n        }    \n        if (inMainMenu || inHelpMenu) {\n            playMenuMusic();\n        } else {\n            stopMenuMusic();\n        }\n        \n        timeOfDay += daySpeed;\n        if (timeOfDay > 1.0f) { \n            timeOfDay = 0.0f;\n        }\n\n        weatherTimer++;\n        if (weatherTimer >= weatherDuration) {\n            changeWeather();\n            weatherTimer = 0;\n        }\n\n        updateWeatherEffects();\n\n        for (Zombie z : zombies) {\n            z.moveTowards(playerX, playerY);\n            if (z.getBounds().intersects(new Rectangle(playerX, playerY, 40, 40))) {\n                playerHealth -= 1;\n                if (playerHealth <= 0) {\n                    gameOver = true;\n                    timer.stop();\n                }\n            }\n\n            if (z instanceof SpitterZombie) {\n                SpitterZombie spitter = (SpitterZombie) z;\n                for (SpitterBullet sb : spitter.getBullets()) {\n                    if (sb.getBounds().intersects(new Rectangle(playerX, playerY, 40, 40))) {\n                        playerHealth -= 1;\n                    }\n                }\n            }\n        }\n\n        Iterator<Bullet> bulletIterator = bullets.iterator();\n        while (bulletIterator.hasNext()) {\n            Bullet b = bulletIterator.next();\n            b.move();\n            if (!b.isActive()) {\n                bulletIterator.remove();\n                continue;\n            }\n\n            handleBulletCollision(b, bulletIterator);\n        }\n\n        if (zombies.isEmpty() && waveInProgress) {\n            waveInProgress = false;\n            nextWave();\n        }\n\n        repaint();\n        \n        if (glowIncreasing) {\n            glowAlpha += 0.01f;\n        } else {\n            glowAlpha -= 0.01f;\n        }\n        if (glowAlpha > 1.0f) {\n            glowAlpha = 1.0f;\n            glowIncreasing = false;\n        }\n        if (glowAlpha < 0.4f) {\n            glowAlpha = 0.4f;\n            glowIncreasing = true;\n        }\n\n        haloOffset = (haloOffset + 1) % 360;\n\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2d = (Graphics2D) g;\n        drawMap(g2d);\n        for (ExplosionEffect explosion : explosions) {\n            explosion.draw(g2d);\n        }\n        \n        drawPlayer(g2d);\n        for (BloodStain blood : bloodStains) {\n            blood.draw(g);\n        }    \n        for (Zombie z : zombies ) { \n            z.draw(g, playerX, playerY);\n        }\n        for (Bullet b : bullets) {\n            b.draw(g);\n        }    \n        for (Obstacle o : obstacles) {\n            o.draw(g);\n        }\n        \n        explosions.removeIf(explosion -> !explosion.isActive());\n\n        drawMuzzleFlash(g);\n        drawWeatherEffects(g);\n        drawDayNightOverlay(g);\n        drawStatusBars(g);\n\n        g.setColor(Color.WHITE);\n        g.drawString(\"Wave: \" + currentWave, 700, 35);\n        g.drawString(\"Score: \" + score, 700, 55);\n        g.drawString(\"Weapon: \" + weapons[currentWeaponIndex].getName(), 700, 75);\n        g.drawString(\"Map: \" + mapTheme, 700, 95);\n\n        \n        if (inMainMenu) {\n            drawMainMenu(g);\n            return;\n        }\n\n        if (inHelpMenu) {\n            drawHelpMenu(g);\n            return;\n        }\n        \n        if (paused) {\n            drawPauseMenu(g); \n        }\n\n        if (gameOver) {\n            g.setColor(new Color(40, 40, 40, 220));\n            g.fillRoundRect(0, 0, 800, 600, 20, 20);\n            \n            g.setColor(new Color(255, 0, 0));\n            g.setFont(new Font(\"Arial\", Font.BOLD, 50));\n            g.drawString(\"OYUN BİTTİ\", 250, 200);\n            \n            g.setColor(new Color(255, 0, 0, 150));\n            g.fillRect(250, 210, 300, 2);\n            \n            g.setColor(Color.WHITE);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 30));\n            g.drawString(\"Final Skoru: \" + score, 140, 285);\n            g.drawString(\"Ulaştığın Dalga: \" + currentWave, 440, 285);\n\n            \n            g.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n            int y = 320;\n            \n            g.setColor(new Color(200, 200, 200));\n            g.fillRoundRect(250, y, 300, 40, 10, 10);\n            g.setColor(new Color(50, 50, 50));\n            g.drawRoundRect(250, y, 300, 40, 10, 10);\n            g.setColor(new Color(0, 0, 0));\n            g.drawString(\"Yeniden Başla (ENTER)\", 280, y + 28);\n            \n            y += 60;\n            g.setColor(new Color(200, 200, 200));\n            g.fillRoundRect(250, y, 300, 40, 10, 10);\n            g.setColor(new Color(50, 50, 50));\n            g.drawRoundRect(250, y, 300, 40, 10, 10);\n            g.setColor(new Color(0, 0, 0));\n            g.drawString(\"Ana Menü (M)\", 330, y + 28);\n            \n            y += 60;\n            g.setColor(new Color(200, 100, 100));\n            g.fillRoundRect(250, y, 300, 40, 10, 10);\n            g.setColor(new Color(150, 50, 50));\n            g.drawRoundRect(250, y, 300, 40, 10, 10);\n            g.setColor(new Color(0, 0, 0));\n            g.drawString(\"Çıkış (Q)\", 350, y + 28);\n        }\n        if (gameWon) {\n            drawVictoryScreen((Graphics2D) g);\n            return;\n        }\n}\n    private void drawMainMenu(Graphics g) {\n        Graphics2D g2d = (Graphics2D) g;\n    \n        GradientPaint gradient = new GradientPaint(0, 0, new Color(10, 10, 10), 0, getHeight(), new Color(30, 30, 30));\n        g2d.setPaint(gradient);\n        g2d.fillRect(0, 0, getWidth(), getHeight());\n    \n        RadialGradientPaint vignette = new RadialGradientPaint(\n            new Point(getWidth() / 2, getHeight() / 2),\n            getWidth(),\n            new float[]{0.7f, 1.0f},\n            new Color[]{new Color(0, 0, 0, 0), new Color(0, 0, 0, 180)}\n        );\n        g2d.setPaint(vignette);\n        g2d.fillRect(0, 0, getWidth(), getHeight());\n    \n        int radius = 240;\n        int cx = getWidth() / 2;\n        int cy = 180;\n        g2d.setColor(new Color(255, 255, 255, 10));\n        g2d.fillOval(cx - radius + (int)(5 * Math.sin(Math.toRadians(haloOffset))), \n                     cy - radius + (int)(5 * Math.cos(Math.toRadians(haloOffset))),\n                     radius * 2, radius * 2);\n\n        g2d.setColor(new Color(40, 40, 40, 240));\n        g2d.fillRoundRect(240, 320, 320, 320, 30, 30);\n    \n        g2d.setFont(new Font(\"Arial\", Font.BOLD, 40));\n        g2d.setColor(new Color(255, 255, 100, (int)(glowAlpha * 255)));\n        g2d.drawString(\"TOP-DOWN SHOOTER\", 180, 200);\n    \n        g2d.setFont(new Font(\"Arial\", Font.PLAIN, 20));\n        Rectangle startBtn = new Rectangle(280, 330, 240, 35);\n        Rectangle helpBtn = new Rectangle(280, 375, 240, 35);\n        drawButton(g2d, startBtn, \"ENTER - Oyuna Başla\");\n        drawButton(g2d, helpBtn, \"H - Nasıl Oynanır\");\n        \n        g2d.setFont(new Font(\"Arial\", Font.PLAIN, 20));\n        Rectangle quitBtn = new Rectangle(280, 420, 240, 35);\n        drawButton(g2d, quitBtn, \"Q - Oyundan Çık\");\n    }\n\n    private void drawButton(Graphics2D g2d, Rectangle rect, String text) {\n        if (rect.contains(mousePosition)) {\n            g2d.setColor(new Color(80, 120, 255));\n            g2d.fillRoundRect(rect.x - 5, rect.y - 3, rect.width + 10, rect.height + 6, 15, 15);\n            g2d.setColor(Color.WHITE);\n        } else {\n            g2d.setColor(new Color(100, 100, 100, 200));\n            g2d.fillRoundRect(rect.x, rect.y, rect.width, rect.height, 10, 10);\n            g2d.setColor(Color.LIGHT_GRAY);\n        }\n        g2d.setFont(new Font(\"Arial\", Font.BOLD, 18));\n        FontMetrics fm = g2d.getFontMetrics();\n        int textX = rect.x + (rect.width - fm.stringWidth(text)) / 2;\n        int textY = rect.y + ((rect.height - fm.getHeight()) / 2) + fm.getAscent();\n        g2d.drawString(text, textX, textY);\n    }\n\n    private void drawHelpMenu(Graphics g) {\n        Graphics2D g2d = (Graphics2D) g;\n        \n        GradientPaint gradient = new GradientPaint(0, 0, new Color(10, 10, 10), 0, getHeight(), new Color(30, 30, 30));\n        g2d.setPaint(gradient);\n        g2d.fillRect(0, 0, getWidth(), getHeight());\n\n        g2d.setColor(new Color(0, 0, 0, 200));\n        g2d.fillRect(0, 0, getWidth(), getHeight());\n\n        g2d.setColor(new Color(30, 30, 30, 230));\n        g2d.fillRoundRect(80, 50, 640, 500, 30, 30);\n\n        g2d.setColor(new Color(255, 215, 0));\n        g2d.setFont(new Font(\"Arial\", Font.BOLD, 36));\n        g2d.drawString(\"NASIL OYNANIR?\", 250, 100);\n        g2d.fillRect(240, 110, 320, 2);\n\n        g2d.setColor(new Color(255, 51, 51));\n        g2d.setFont(new Font(\"Arial\", Font.PLAIN, 18));\n        g2d.drawString(\"Amaç: \", 100, 160);\n\n        g2d.setColor(new Color(204, 204, 204));\n        g2d.setFont(new Font(\"Arial\", Font.PLAIN, 18));\n        g2d.drawString(\"Dalga dalga gelen çeşitli zombileri farklı silahlar kullanıp öldürmektir.\", 160, 160);\n        g2d.drawString(\"Oyun 13.Dalga sonunda bitmektedir.\", 160, 180);\n\n        g2d.setFont(new Font(\"Arial\", Font.PLAIN, 20));\n        g2d.setColor(Color.LIGHT_GRAY);\n        int y = 240;\n        g2d.drawString(\" W-A-S-D → Hareket\", 100, y); y += 30;\n        g2d.drawString(\" Mouse Sol Tık → Ateş\", 100, y); y += 30;\n        g2d.drawString(\" R → Mermi Doldur\", 100, y); y += 30;\n        g2d.drawString(\" M → Harita Değiştir\", 100, y); y += 30;\n        g2d.drawString(\" P → Oyunu Duraklat\", 100, y); y += 30;\n        g2d.drawString(\" K → Kaydet (Duraklatmada)\", 100, y); y += 30;\n        g2d.drawString(\" L → Yükle (Duraklatmada)\", 100, y); y += 40;\n    \n        g2d.setColor(new Color(50, 50, 70));\n        g2d.fillRoundRect(450, 220, 240, 160, 20, 20);\n        g2d.setColor(new Color(255, 255, 255));\n        g2d.setFont(new Font(\"Arial\", Font.BOLD, 22));\n        g2d.drawString(\" Silahlar\", 520, 250);\n    \n        g2d.setFont(new Font(\"Arial\", Font.PLAIN, 18));\n        int sy = 275;\n        g2d.drawString(\"1 - Pistol\", 480, sy); sy += 24;\n        g2d.drawString(\"2 - Rifle\", 480, sy); sy += 24;\n        g2d.drawString(\"3 - Shotgun\", 480, sy); sy += 24;\n        g2d.drawString(\"4 - Sniper\", 480, sy); sy += 24;\n        g2d.drawString(\"5 - Rocket Launcher\", 480, sy);\n\n        g2d.setColor(new Color(100, 255, 100));\n        g2d.setFont(new Font(\"Arial\", Font.ITALIC, 18));\n        g2d.drawString(\"⬅ Geri dönmek için 'B' tuşuna basın\", 250, 480);\n    }\n    \n    private void drawStatusBars(Graphics g) {\n        int barWidth = 200;\n        int barHeight = 20;\n\n        g.setColor(Color.GRAY);\n        g.fillRect(20, 20, barWidth, barHeight);\n        g.setColor(Color.RED);\n        int healthWidth = (int) ((playerHealth / 100.0) * barWidth);\n        g.fillRect(20, 20, healthWidth, barHeight);\n        g.setColor(Color.WHITE);\n        g.drawRect(20, 20, barWidth, barHeight);\n        g.drawString(\"HEALTH\", 230, 35);\n\n        int ammoBarMax = weapons[currentWeaponIndex].getMagazineSize();\n        int ammoInMag = weapons[currentWeaponIndex].getAmmoInMagazine();\n\n        g.setColor(Color.GRAY);\n        g.fillRect(20, 50, barWidth, barHeight);\n        g.setColor(Color.BLUE);\n        int ammoWidth = (int) ((ammoInMag / (double) ammoBarMax) * barWidth);\n        g.fillRect(20, 50, ammoWidth, barHeight);\n        g.setColor(Color.WHITE);\n        g.drawRect(20, 50, barWidth, barHeight);\n        g.drawString(\"AMMO\", 230, 65);\n    }\n\n    private void drawDayNightOverlay(Graphics g) {\n        Graphics2D g2d = (Graphics2D) g;\n        float alpha = 0f;\n\n        if (timeOfDay <= 0.5f) {\n            alpha = timeOfDay * 2;\n        } else {\n            alpha = (1.0f - timeOfDay) * 2;\n        }\n\n        Color overlay = new Color(0, 0, 0, (int)(alpha * 150));\n        g2d.setColor(overlay);\n        g2d.fillRect(0, 0, 800, 600);\n    }\n\n    private void drawWeatherEffects(Graphics g) {\n        if (!mapTheme.equals(\"Desert\")) {\n            if (weather.equals(\"Rain\") || weather.equals(\"Storm\")) {\n                for (Particle p : rainParticles) {\n                    p.drawRain(g);\n                }\n            }\n\n            if (weather.equals(\"Snow\")) {\n                for (Particle p : snowParticles) {\n                    p.drawSnow(g);\n                }\n            }\n        }\n        if (weather.equals(\"Fog\")) {\n            g.setColor(new Color(200, 200, 200, 80));\n            g.fillRect(0, 0, 800, 600);\n        }\n        if (weather.equals(\"Storm\")) {\n            Random rand = new Random();\n            if (rand.nextInt(100) < 2) {\n                g.setColor(new Color(255, 255, 255, 150));\n                g.fillRect(0, 0, 800, 600);\n                playSound(\"sounds/thunder.wav\");\n            }\n        }\n    }\n\n    private void createMuzzleFlash() {\n        flashTimer = 5;\n    }\n\n    private void drawMuzzleFlash(Graphics g) {\n        if (flashTimer > 0) {\n            g.setColor(Color.YELLOW);\n            g.fillOval(playerX + 30, playerY + 10, 10, 10);\n            flashTimer--;\n        }\n    }\n    private void playMenuMusic() {\n        try {\n            if (menuMusicPlaying) {\n                return;\n            }    \n            File file = new File(\"sounds/menu_music.wav\");\n            AudioInputStream audioStream = AudioSystem.getAudioInputStream(file);\n            menuMusic = AudioSystem.getClip();\n            menuMusic.open(audioStream);\n            menuMusic.loop(Clip.LOOP_CONTINUOUSLY);\n            menuMusic.start();\n            menuMusicPlaying = true;\n        } \n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void stopMenuMusic() {\n        if (menuMusic != null && menuMusic.isRunning()) {\n            menuMusic.stop();\n            menuMusic.close();\n        }\n        menuMusicPlaying = false;\n    }\n\n    private void changeWeather() {\n        String[] types;\n        if (mapTheme.equals(\"Desert\")) {\n            types = new String[]{\"Clear\", \"Fog\", \"Storm\"};\n        } else {\n            types = new String[]{\"Clear\", \"Rain\", \"Snow\", \"Fog\", \"Storm\"};\n        }\n        \n        Random rand = new Random();\n        weather = types[rand.nextInt(types.length)];\n\n        rainParticles.clear();\n        snowParticles.clear();\n\n        if ((weather.equals(\"Rain\") || weather.equals(\"Storm\")) && !mapTheme.equals(\"Desert\")) {\n            for (int i = 0; i < 200; i++) {\n                rainParticles.add(new Particle(rand.nextInt(800), rand.nextInt(600), 2 + rand.nextInt(3), 10 + rand.nextInt(10)));\n            }\n        }\n\n        if (weather.equals(\"Snow\") && !mapTheme.equals(\"Desert\")) {\n            for (int i = 0; i < 150; i++) {\n                snowParticles.add(new Particle(rand.nextInt(800), rand.nextInt(600), 1, 2 + rand.nextInt(2)));\n            }\n        }\n    }\n\n    private void updateWeatherEffects() {\n        for (Particle p : rainParticles) {\n            p.fall();\n        }\n        for (Particle p : snowParticles) {\n            p.fall();\n        }    \n    }\n\n    private void playSound(String path) {\n        try {\n            File file = new File(path);\n            AudioInputStream audioStream = AudioSystem.getAudioInputStream(file);\n            Clip clip = AudioSystem.getClip();\n            clip.open(audioStream);\n            clip.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private int getZombieScore(Zombie z) {\n        if (z instanceof NormalZombie) return 10;\n        if (z instanceof CrawlerZombie) return 15;\n        if (z instanceof TankZombie) return 25;\n        if (z instanceof SpitterZombie) return 20;\n        return 0;\n    }\n\n    private void saveGame() {\n        String inputName = JOptionPane.showInputDialog(this, \n            \"Kayıt için isminizi giriniz:\\nMevcut Skor: \" + score,\n            \"Oyunu Kaydet\",\n            JOptionPane.QUESTION_MESSAGE);\n\n        if (inputName != null && !inputName.trim().isEmpty()) {\n            try {\n                ArrayList<String> saves = new ArrayList<>();\n                File saveFile = new File(\"saves.txt\");\n                if (saveFile.exists()) {\n                    try (BufferedReader br = new BufferedReader(new FileReader(saveFile))) {\n                        String line;\n                        while ((line = br.readLine()) != null) {\n                            saves.add(line);\n                        }\n                    }\n                }\n                String newSave = inputName + \",\" + score + \",\" + currentWave + \",\" + \n                               playerHealth + \",\" + playerX + \",\" + playerY;\n                saves.add(newSave);\n                saves.sort((a, b) -> {\n                    int scoreA = Integer.parseInt(a.split(\",\")[1]);\n                    int scoreB = Integer.parseInt(b.split(\",\")[1]);\n                    return scoreB - scoreA;\n                });\n\n                if (saves.size() > 10) {\n                    saves = new ArrayList<>(saves.subList(0, 10));\n                }\n\n                try (FileWriter fw = new FileWriter(saveFile)) {\n                    for (String save : saves) {\n                        fw.write(save + \"\\n\");\n                    }\n                }\n\n                JOptionPane.showMessageDialog(this,\n                    \"Oyun başarıyla kaydedildi!\\nSkor: \" + score,\n                    \"Kayıt Başarılı\",\n                    JOptionPane.INFORMATION_MESSAGE);\n            } \n            catch (IOException e) {\n                JOptionPane.showMessageDialog(this,\n                    \"Kaydetme hatası: \" + e.getMessage(),\n                    \"Hata\",\n                    JOptionPane.ERROR_MESSAGE);\n            }\n        }\n    }\n\n    private void loadGame() {\n        try {\n            File saveFile = new File(\"saves.txt\");\n            if (!saveFile.exists()) {\n                JOptionPane.showMessageDialog(this,\n                    \"Henüz kayıtlı oyun bulunmuyor!\",\n                    \"Kayıt Bulunamadı\",\n                    JOptionPane.INFORMATION_MESSAGE);\n                return;\n            }\n\n            ArrayList<String> saves = new ArrayList<>();\n            try (BufferedReader br = new BufferedReader(new FileReader(saveFile))) {\n                String line;\n                while ((line = br.readLine()) != null) {\n                    saves.add(line);\n                }\n            }\n\n            StringBuilder message = new StringBuilder(\"Kayıtlı Oyunlar:\\n\\n\");\n            for (int i = 0; i < saves.size(); i++) {\n                String[] data = saves.get(i).split(\",\");\n                message.append((i + 1)).append(\". \")\n                      .append(data[0]).append(\" - Skor: \").append(data[1])\n                      .append(\" - Dalga: \").append(data[2]).append(\"\\n\");\n            }\n            message.append(\"\\nYüklemek istediğiniz kaydın numarasını girin:\");\n\n            String input = JOptionPane.showInputDialog(this,\n                message.toString(),\n                \"Kayıt Yükle\",\n                JOptionPane.QUESTION_MESSAGE);\n\n            if (input != null && !input.trim().isEmpty()) {\n                try {\n                    int selection = Integer.parseInt(input) - 1;\n                    if (selection >= 0 && selection < saves.size()) {\n                        String[] data = saves.get(selection).split(\",\");\n                        playerName = data[0];\n                        score = Integer.parseInt(data[1]);\n                        currentWave = Integer.parseInt(data[2]);\n                        playerHealth = Integer.parseInt(data[3]);\n                        playerX = Integer.parseInt(data[4]);\n                        playerY = Integer.parseInt(data[5]);\n\n                        zombies.clear();\n                        bullets.clear();\n                        bloodStains.clear();\n                        waveInProgress = false;\n                        startWave();\n\n                        JOptionPane.showMessageDialog(this,\n                            \"Oyun başarıyla yüklendi!\\nOyuncu: \" + playerName + \"\\nSkor: \" + score,\n                            \"Yükleme Başarılı\",\n                            JOptionPane.INFORMATION_MESSAGE);\n                    } else {\n                        JOptionPane.showMessageDialog(this,\n                            \"Geçersiz seçim!\",\n                            \"Hata\",\n                            JOptionPane.ERROR_MESSAGE);\n                    }\n                } \n                catch (NumberFormatException e) {\n                    JOptionPane.showMessageDialog(this,\n                        \"Geçersiz seçim! Lütfen bir sayı girin.\",\n                        \"Hata\",\n                        JOptionPane.ERROR_MESSAGE);\n                }\n            }\n        } \n        catch (IOException e) {\n            JOptionPane.showMessageDialog(this,\n                \"Yükleme hatası: \" + e.getMessage(),\n                \"Hata\",\n                JOptionPane.ERROR_MESSAGE);\n        }\n    }\n\n    private class Particle {\n        int x, y, speed, size;\n\n        public Particle(int x, int y, int speed, int size) {\n            this.x = x;\n            this.y = y;\n            this.speed = speed;\n            this.size = size;\n        }\n\n        public void fall() {\n            y += speed;\n            if (y > 600) {\n                y = 0;\n                x = new Random().nextInt(800);\n            }\n        }\n\n        public void drawRain(Graphics g) {\n            g.setColor(Color.CYAN);\n            g.fillRect(x, y, 2, size);\n        }\n\n        public void drawSnow(Graphics g) {\n            g.setColor(Color.WHITE);\n            g.fillOval(x, y, size, size);\n        }\n    }\n    private void loadPlayerImage() {\n        try {\n            playerImg = ImageIO.read(new File(\"resources/player/player_sprite.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    private void drawPlayer(Graphics2D g2d) {\n        double angle = Math.atan2(mousePosition.y - playerY, mousePosition.x - playerX);\n        int width = playerImg.getWidth();\n        int height = playerImg.getHeight();\n\n        g2d.translate(playerX, playerY);\n        g2d.rotate(angle);\n        g2d.drawImage(playerImg, -width / 2, -height / 2, null);\n        g2d.rotate(-angle);\n        g2d.translate(-playerX, -playerY);\n    }\n    \n    @Override\n    public void mouseMoved(MouseEvent e) {\n        mousePosition = e.getPoint();\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        mousePosition = e.getPoint();\n    }\n    private boolean collidesWithObstacle(int newX, int newY) {\n        Rectangle futurePlayer = new Rectangle(newX, newY, 40, 40);\n        for (Obstacle o : obstacles) {\n            if (o.getBounds().intersects(futurePlayer)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void checkWeaponAvailability(int key) {\n        int weaponIndex = key - KeyEvent.VK_1;\n        boolean canSwitch = false;\n        \n        switch (weaponIndex) {\n            case 0:\n                canSwitch = true;\n                break;\n            case 1:\n                canSwitch = currentWave > 1;\n                break;\n            case 2:\n                canSwitch = currentWave > 3;\n                break;\n            case 3:\n                canSwitch = currentWave > 5;\n                break;\n            case 4:\n                canSwitch = currentWave > 7;\n                break;\n        }\n        \n        if (canSwitch) {\n            currentWeaponIndex = weaponIndex;\n        }\n    }\n\n    private class ExplosionEffect {\n        private int x, y;\n        private int radius;\n        private int duration;\n        private final int maxDuration = 10;\n\n        public ExplosionEffect(int x, int y) {\n            this.x = x;\n            this.y = y;\n            this.radius = 80;\n            this.duration = maxDuration;\n        }\n\n        public void draw(Graphics2D g2d) {\n            if (duration > 0) {\n                int alpha = (int)((duration / (float)maxDuration) * 255);\n\n                g2d.setColor(new Color(255, 140, 0, alpha));\n                g2d.fillOval(x - radius, y - radius, radius * 2, radius * 2);\n\n                g2d.setColor(new Color(255, 200, 0, alpha));\n                g2d.fillOval(x - radius/2, y - radius/2, radius, radius);\n                duration--;\n            }\n        }\n\n        public boolean isActive() {\n            return duration > 0;\n        }\n\n        public Rectangle getBounds() {\n            return new Rectangle(x - radius, y - radius, radius * 2, radius * 2);\n        }\n    }\n\n    private void handleBulletCollision(Bullet b, Iterator<Bullet> bulletIterator) {\n        Rectangle bulletBounds = b.getBounds();\n        int bulletX = bulletBounds.x + bulletBounds.width/2;\n        int bulletY = bulletBounds.y + bulletBounds.height/2;\n\n        if (currentWeaponIndex == 4) {\n            ExplosionEffect explosion = new ExplosionEffect(bulletX, bulletY);\n            explosions.add(explosion);\n            playSound(\"sounds/explosion.wav\");\n            \n            for (Zombie z : new ArrayList<>(zombies)) {\n                if (explosion.getBounds().intersects(z.getBounds())) {\n                    z.takeDamage(b.getDamage());\n                    if (z.isDead()) {\n                        zombies.remove(z);\n                        score += getZombieScore(z);\n                        bloodStains.add(new BloodStain(z.getBounds().x, z.getBounds().y));\n                        playSound(\"sounds/zombie_growl.wav\");\n                    }\n                }\n            }\n            bulletIterator.remove();\n        } \n        else {\n            for (Zombie z : new ArrayList<>(zombies)) {\n                if (bulletBounds.intersects(z.getBounds())) {\n                    z.takeDamage(b.getDamage());\n                    bulletIterator.remove();\n                    if (z.isDead()) {\n                        zombies.remove(z);\n                        score += getZombieScore(z);\n                        bloodStains.add(new BloodStain(z.getBounds().x, z.getBounds().y));\n                        playSound(\"sounds/zombie_growl.wav\");\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    private void drawVictoryScreen(Graphics2D g2d) {\n        int btnWidth = 320;\n        int btnHeight = 40;\n\n        GradientPaint gp = new GradientPaint(0, 0, new Color(0, 50, 0), 0, getHeight(), new Color(0, 20, 0));\n        g2d.setPaint(gp);\n        g2d.fillRect(0, 0, getWidth(), getHeight());\n    \n        g2d.setFont(new Font(\"Arial\", Font.BOLD, 60));\n        g2d.setColor(new Color(144, 238, 144, (int)(glowAlpha * 255)));\n        g2d.drawString(\"TEBRİKLER!\", 220, 150);\n    \n        g2d.setColor(new Color(173, 255, 47, 100));\n        g2d.fillOval(220 - (int)(Math.sin(Math.toRadians(haloOffset)) * 10), 100, 360, 80);\n    \n        g2d.setFont(new Font(\"Arial\", Font.PLAIN, 30));\n        g2d.setColor(Color.WHITE);\n        g2d.drawString(\"Tüm dalgaları başarıyla tamamladınız.\", 160, 230);\n        g2d.drawString(\"Skorunuz: \" + score, 290, 280);\n    \n        int x1 = (getWidth() - btnWidth) / 2;\n        int y1 = 360;\n        g2d.setColor(new Color(200, 255, 200));\n        g2d.fillRoundRect(x1, y1, btnWidth, btnHeight, 15, 15);\n        g2d.setColor(new Color(100, 200, 100));\n        g2d.drawRoundRect(x1, y1, btnWidth, btnHeight, 15, 15);\n        g2d.setColor(Color.BLACK); \n        g2d.setFont(new Font(\"Arial\", Font.PLAIN, 22));\n        g2d.drawString(\"Ana menüye dönmek için (M)\", x1 + 40, y1 + 27);\n\n        int y2 = y1 + 60;\n        g2d.setColor(new Color(255, 200, 200));\n        g2d.fillRoundRect(x1, y2, btnWidth, btnHeight, 15, 15);\n        g2d.setColor(new Color(200, 100, 100));\n        g2d.drawRoundRect(x1, y2, btnWidth, btnHeight, 15, 15);\n        g2d.setColor(Color.BLACK);\n        g2d.drawString(\"Oyundan çıkmak için (Q)\", x1 + 55, y2 + 27);\n    }    \n}",
      "Game.java": "import javax.swing.JFrame;\n\npublic class Game {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Top-Down Shooter\");\n        GamePanel gamePanel = new GamePanel();\n        frame.add(gamePanel);\n        frame.pack();\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n    }\n}\n",
      "Zombie.java": "package zombies;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\n\npublic abstract class Zombie {\n    protected double x, y;\n    protected int health;\n    protected double speed;\n    protected int width = 40; \n    protected int height = 40;\n    protected BufferedImage sprite;\n\n    public Zombie(int x, int y, int health, double speed) {\n        this.x = x;\n        this.y = y;\n        this.health = health;\n        this.speed = speed;\n    }\n    \n    public abstract void draw(Graphics g, int playerX, int playerY);\n\n    public void moveTowards(int playerX, int playerY) {\n        double angle = Math.atan2(playerY - y, playerX - x);\n        double dx = speed * Math.cos(angle);\n        double dy = speed * Math.sin(angle);\n    \n        if (Math.hypot(playerX - x, playerY - y) < 2.0) {\n            return;\n        }\n    \n        x += dx;\n        y += dy;\n    }\n\n    public void takeDamage(int dmg) {\n        health -= dmg;\n    }\n\n    public boolean isDead() {\n        return health <= 0;\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle((int)x - 20, (int)y - 20, 40, 40);\n    }\n    \n    public void setSprite(BufferedImage img) {\n        this.sprite = img;\n    }\n\n    public double getX() {\n        return x;\n    }\n    public double getY() {\n        return y;\n    }\n    public void setX(int x) {\n        this.x = x;\n    }\n    public void setY(int y) {\n        this.y = y;\n    }\n}",
      "NormalZombie.java": "package zombies;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class NormalZombie extends Zombie {\n    private BufferedImage sprite;\n\n    public NormalZombie(int x, int y) {\n        super(x, y, 100, 1.0);\n        try {\n            BufferedImage img = ImageIO.read(new File(\"resources/zombies/normal_zombie.png\"));\n            setSprite(img);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void draw(Graphics g, int playerX, int playerY) {\n        if (sprite == null) return;\n    \n        Graphics2D g2d = (Graphics2D) g;\n\n        double angle = Math.atan2(playerY - y, playerX - x);\n        int w = sprite.getWidth();\n        int h = sprite.getHeight();\n    \n        g2d.translate(x, y);\n        g2d.rotate(angle);\n        g2d.drawImage(sprite, -w / 2, -h / 2, null);\n        g2d.rotate(-angle);\n        g2d.translate(-x, -y);\n\n    }  \n    public void setSprite(BufferedImage img) {\n        this.sprite = img;\n    }    \n    @Override\n    public void moveTowards(int targetX, int targetY) {\n        double angle = Math.atan2(targetY - y, targetX - x);\n        x += speed * Math.cos(angle);\n        y += speed * Math.sin(angle);\n    }\n}",
      "SpitterBullet.java": "package zombies;\n\nimport java.awt.*;\n\npublic class SpitterBullet {\n    private double x, y;\n    private double dirX, dirY;\n    private int speed = 5;\n    private boolean active = true;\n\n    public SpitterBullet(int x, int y, int targetX, int targetY) {\n        this.x = x;\n        this.y = y;\n        double angle = Math.atan2(targetY - y, targetX - x);\n        dirX = Math.cos(angle) * speed;\n        dirY = Math.sin(angle) * speed;\n    }\n\n    public void move() {\n        x += dirX;\n        y += dirY;\n        if (x < 0 || x > 800 || y < 0 || y > 600) active = false;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.BLACK);\n        g.fillOval((int)x,(int) y, 10, 10);\n    }\n\n    public boolean isActive() { \n        return active; \n    }\n    public Rectangle getBounds() {\n        return new Rectangle((int)x, (int)y, 10, 10); \n    }\n}\n",
      "SpitterZombie.java": "package zombies;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Random;\nimport javax.imageio.ImageIO;\n\npublic class SpitterZombie extends Zombie {\n    private List<SpitterBullet> bullets = new ArrayList<>();\n    private int attackCooldown = 120;\n    private BufferedImage sprite;\n    private int shootCooldown = 0;\n    private Random rand;\n\n    public SpitterZombie(int x, int y) {\n        super(x, y, 150, 0.8);\n        \n        bullets = new ArrayList<>();\n        rand = new Random();\n\n        try {\n            BufferedImage img = ImageIO.read(new File(\"resources/zombies/spitter_zombie.png\"));\n            setSprite(img);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void moveTowards(int playerX, int playerY) {\n        int distance = (int) Math.hypot(playerX - x, playerY - y);\n        if (distance > 200) super.moveTowards(playerX, playerY);\n\n        if (attackCooldown <= 0) {\n            bullets.add(new SpitterBullet((int)x + 20, (int)y + 20, playerX, playerY));\n            attackCooldown = 120;\n        } else {\n            attackCooldown--;\n        }\n\n        Iterator<SpitterBullet> iterator = bullets.iterator();\n        while (iterator.hasNext()) {\n            SpitterBullet bullet = iterator.next();\n            bullet.move();\n            if (!bullet.isActive()) iterator.remove();\n        }\n    }\n\n    @Override\n    public void draw(Graphics g, int playerX, int playerY) {\n        if (sprite == null) return;\n\n        Graphics2D g2d = (Graphics2D) g;\n        double angle = Math.atan2(playerY - y, playerX - x);\n        int w = sprite.getWidth();\n        int h = sprite.getHeight();\n\n        g2d.translate(x, y);\n        g2d.rotate(angle);\n        g2d.drawImage(sprite, -20, -20, 40, 40, null);\n        g2d.rotate(-angle);\n        g2d.translate(-x, -y);\n\n        for (SpitterBullet b : bullets) b.draw(g);\n    }\n    \n    public void setSprite(BufferedImage img) {\n        this.sprite = img;\n    }\n    \n    public List<SpitterBullet> getBullets() { \n        return bullets; \n    }\n}\n",
      "CrawlerZombie.java": "package zombies;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class CrawlerZombie extends Zombie {\n    private BufferedImage sprite;\n\n    public CrawlerZombie(int x, int y) {\n        super(x, y, 50, 1.5);\n        try {\n            BufferedImage img = ImageIO.read(new File(\"resources/zombies/crawler_zombie.png\"));\n            setSprite(img);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void draw(Graphics g, int playerX, int playerY) {\n        if (sprite == null) return;\n\n        Graphics2D g2d = (Graphics2D) g;\n        double angle = Math.atan2(playerY - y, playerX - x);\n        int w = sprite.getWidth();\n        int h = sprite.getHeight();\n\n        g2d.translate(x, y);\n        g2d.rotate(angle);\n        g2d.drawImage(sprite, -20, -20, 40, 40, null);\n        g2d.rotate(-angle);\n        g2d.translate(-x, -y);\n    }\n    @Override\n    public void moveTowards(int targetX, int targetY) {\n        double angle = Math.atan2(targetY - y, targetX - x);\n        x += speed * Math.cos(angle);\n        y += speed * Math.sin(angle);\n    }\n    public void setSprite(BufferedImage img) {\n        this.sprite = img;\n    }\n}\n",
      "TankZombie.java": "package zombies;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class TankZombie extends Zombie {\n    private BufferedImage sprite;\n\n    public TankZombie(int x, int y) {\n        super(x, y, 200, 0.5);\n        try {\n            BufferedImage img = ImageIO.read(new File(\"resources/zombies/tank_zombie.png\"));\n            setSprite(img);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void draw(Graphics g, int playerX, int playerY) {\n        if (sprite == null) return;\n\n        Graphics2D g2d = (Graphics2D) g;\n        double angle = Math.atan2(playerY - y, playerX - x);\n        int w = sprite.getWidth();\n        int h = sprite.getHeight();\n\n        g2d.translate(x, y);\n        g2d.rotate(angle);\n        g2d.drawImage(sprite, -25, -25, 50, 50, null);\n        g2d.rotate(-angle);\n        g2d.translate(-x, -y);\n    }\n    @Override\n    public void moveTowards(int targetX, int targetY) {\n        double angle = Math.atan2(targetY - y, targetX - x);\n        x += speed * Math.cos(angle);\n        y += speed * Math.sin(angle);\n    }\n    public void setSprite(BufferedImage img) {\n        this.sprite = img;\n    }\n}"
    },
    {
      "id": "8190737",
      "Zombie.java": "//import javax.swing.*;\nimport java.awt.*;\n//import java.awt.event.*;\nimport java.util.ArrayList;\n//import java.util.List;\nimport java.time.LocalTime;\n\nclass Zombie extends Circle{\n    double health, speed, damage, point;\n    public Zombie(double x, double y, double radius, Color color, double health, double speed, double damage) {\n        super(x, y, radius, color);\n        this.health = health;\n        this.speed = speed;\n        this.damage = damage;\n    }\n}\n\nclass NormalZombie extends Zombie{\n    public NormalZombie(double x, double y){\n        super(x, y, 20, new Color(0x076208), 100, 2, 0.5);\n        point = 10;\n    }\n}\n\nclass CrawlerZombie extends Zombie{\n    boolean isJumping = false;\n    double jumpTargetX, jumpTargetY;\n    int lastJump = 0;\n\n    public CrawlerZombie(double x, double y){\n        super(x, y, 17, new Color(0x6b9c10), 30, 1.5, 0.5);\n        point = 15;\n    }\n\n    public void jump(Player player){\n        if(LocalTime.now().toSecondOfDay() - lastJump < 10) return;\n        isJumping = true;\n        \n        jumpTargetX = player.x;\n        jumpTargetY = player.y;\n\n        color = Color.black;\n\n        lastJump = LocalTime.now().toSecondOfDay();\n    }\n}\n\nclass TankZombie extends Zombie{\n    public TankZombie(double x, double y){\n        super(x, y, 30, new Color(0x172300), 500, 1, 3);\n        point = 30;\n    }\n}\n\nclass SpitterZombie extends Zombie{\n    double spittingDistance = 50;\n    int lastSpit = 0;\n\n    public SpitterZombie(double x, double y){\n        super(x, y, 17, Color.BLUE, 30, 1, 0.5);\n        point = 25;\n    }\n\n    //public AcidSpit(double x, double y, double radius, Color color, double damage, double speedX, double speedY, double maxDistance, int duration) {\n    public void spit(ArrayList<AcidSpit> spits, Player player){\n        if(LocalTime.now().toSecondOfDay() - lastSpit < 5) return;\n        \n        double vx = player.x - this.x;\n        double vy = player.y - this.y;\n\n        double distance = Math.sqrt(vx * vx + vy * vy);\n        double spitSpeed = 1;\n        \n        vx *= spitSpeed / distance;\n        vy *= spitSpeed / distance;\n\n        AcidSpit spit = new AcidSpit(this.x, this.y, 5, new Color(0x37f313), 0.2, vx, vy, distance, 10);\n        spits.add(spit);\n\n        lastSpit = LocalTime.now().toSecondOfDay();\n    }\n}",
      "Gun.java": "//import javax.swing.*;\nimport java.awt.*;\n//import java.lang.reflect.Array;\n//import java.awt.event.*;\n//import java.util.ArrayList;\n//import java.util.List;\nimport java.util.ArrayList;\nimport java.time.LocalTime;\n\npublic abstract class Gun extends Line{\n    double damage, fireRate, spreadAngle, length;\n    int magazineCap, totalBulletCount, bulletsInMag;\n    long lastFired = 0;\n    String name;\n\n    public Gun(double damage, double fireRate, double spreadAngle, int magazineCap, int totalBulletCount){\n        super(0, 0, 0, 0, 0, Color.black);\n        this.damage = damage;\n        this.fireRate = fireRate;\n        this.spreadAngle = spreadAngle;\n        this.magazineCap = magazineCap;\n        this.totalBulletCount = totalBulletCount;\n        this.bulletsInMag = magazineCap;\n    }\n\n    public void rotate(double degree){\n        double radian = degree * Math.PI / 180;\n        double dx = length * Math.cos(radian);\n        double dy = length * Math.sin(radian);\n\n        x2 = x1 + dx;\n        y2 = y1 + dy;\n    }\n\n    public void rotate(double mouseX, double mouseY){\n        double dx = mouseX - x1;\n        double dy = mouseY - y1;\n        double dist = Math.sqrt(dx * dx + dy * dy);\n\n        dx *= length / dist;\n        dy *= length / dist;\n\n        x2 = x1 + dx;\n        y2 = y1 + dy;\n    }\n\n    public void reload(){\n        int required = magazineCap - bulletsInMag;\n        int available = Math.min(required, totalBulletCount);\n        bulletsInMag += available;\n        totalBulletCount -= available;    \n    }\n\n    public abstract void fire(ArrayList<Bullet> bullets);\n}\n\nclass Pistol extends Gun{\n    public Pistol(double playerX, double playerY){\n        super(30, 2, 0, 12, -1);\n        x1 = playerX;\n        y1 = playerY;\n\n        thickness = 5;\n        length = 25;\n\n        x2 = x1 + length;\n        y2 = y1;\n\n        color = Color.black;\n\n        name = \"Pistol\";\n    }\n\n    public void reload(){\n        bulletsInMag = magazineCap;\n    }\n\n    public void fire(ArrayList<Bullet> bullets){\n        if(bulletsInMag == 0) return;\n        if(LocalTime.now().toNanoOfDay() - lastFired < 1e9/fireRate) return;\n\n        double vx = x2 - x1;\n        double vy = y2 - y1;\n\n        double bulletSpeed = 5;\n        vx *= bulletSpeed / length;\n        vy *= bulletSpeed / length;\n\n        Bullet bullet = new Bullet(x1, y1, 2, Color.black, damage, vx, vy, false, false);\n        bullets.add(bullet);\n\n        lastFired = LocalTime.now().toNanoOfDay();\n        bulletsInMag--;\n    }\n}\n\nclass Rifle extends Gun{\n    public Rifle(double playerX, double playerY){\n        super(45, 10, 30, 30, 60);\n        x1 = playerX;\n        y1 = playerY;\n\n        thickness = 6;\n        length = 30;\n\n        x2 = x1 + length;\n        y2 = y1;\n\n        name = \"Rifle\";\n    }\n\n    public void fire(ArrayList<Bullet> bullets){\n        if(bulletsInMag == 0) return;\n        if(LocalTime.now().toNanoOfDay() - lastFired < 1e9/fireRate) return;\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n\n        double radius = Math.atan2(dy, dx);\n        radius += (Math.random() - 0.5) * Math.toRadians(spreadAngle);\n\n        double bulletSpeed = 10;\n        double speedX = bulletSpeed * Math.cos(radius);\n        double speedY = bulletSpeed * Math.sin(radius);\n\n        Bullet bullet = new Bullet(x1, y1, 2.2, Color.black, damage, speedX, speedY, false, false);\n        bullets.add(bullet);\n\n        lastFired = LocalTime.now().toNanoOfDay();\n        bulletsInMag--;\n    }\n}\n\nclass Shotgun extends Gun{\n    public Shotgun(double playerX, double playerY){\n        super(35, 1, 45, 5, 15);\n        x1 = playerX;\n        y1 = playerY;\n\n        thickness = 8;\n        length = 28;\n\n        x2 = x1 + length;\n        y2 = y1;\n\n        name = \"Shotgun\";\n    }\n\n    public void fire(ArrayList<Bullet> bullets){\n        if(bulletsInMag == 0) return;\n        if(LocalTime.now().toNanoOfDay() - lastFired < 1e9/fireRate) return;\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        double baseAngle = Math.atan2(dy, dx);\n\n        int numberOfPellets = 9;\n        double totalSpreadAngleDegrees = 45;\n        double angleStepDegrees = totalSpreadAngleDegrees / (numberOfPellets - 1);\n\n        double bulletSpeed = 7;\n\n        for (int i = 0; i < numberOfPellets; i++) {\n            double pelletAngle = baseAngle - Math.toRadians(totalSpreadAngleDegrees / 2) + Math.toRadians(i * angleStepDegrees);\n\n            double speedX = bulletSpeed * Math.cos(pelletAngle);\n            double speedY = bulletSpeed * Math.sin(pelletAngle);\n\n            Bullet bullet = new Bullet(x1, y1, 2.5, Color.black, damage, speedX, speedY, false, false);\n            bullets.add(bullet);\n        }\n\n        lastFired = LocalTime.now().toNanoOfDay();\n        bulletsInMag--;\n    }\n}\n\nclass Sniper extends Gun{\n    public Sniper(double playerX, double playerY){\n        super(80, 0.5, 0, 5, 10);\n        x1 = playerX;\n        y1 = playerY;\n\n        thickness = 6;\n        length = 35;\n\n        x2 = x1 + length;\n        y2 = y1;\n\n        name = \"Sniper\";\n    }\n\n    public void fire(ArrayList<Bullet> bullets){\n        if(bulletsInMag == 0) return;\n        if(LocalTime.now().toNanoOfDay() - lastFired < 1e9/fireRate) return;\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n\n        double radius = Math.atan2(dy, (dx + 1e-9));\n        radius += (Math.random() - 0.5) * spreadAngle;\n\n        double bulletSpeed = 12;\n        double speedX = bulletSpeed * Math.cos(radius);\n        double speedY = bulletSpeed * Math.sin(radius);\n\n        Bullet bullet = new SniperBullet(x1, y1, 2.3, Color.black, damage, speedX, speedY, false, true);\n        bullets.add(bullet);\n\n        lastFired = LocalTime.now().toNanoOfDay();\n        bulletsInMag--;\n    }\n}\n\nclass RocketLauncher extends Gun{\n    public RocketLauncher(double playerX, double playerY){\n        super(120, 1.0/6, 0, 1, 3);\n        x1 = playerX;\n        y1 = playerY;\n\n        thickness = 10;\n        length = 30;\n\n        x2 = x1 + length;\n        y2 = y1;\n\n        name = \"Rocket Launcher\";\n    }\n\n    public void fire(ArrayList<Bullet> bullets){\n        if(bulletsInMag == 0) return;\n        if(LocalTime.now().toNanoOfDay() - lastFired < 1e9/fireRate) return;\n\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n\n        double radius = Math.atan2(dy, dx);\n        radius += (Math.random() - 0.5) * spreadAngle;\n\n        double bulletSpeed = 4;\n        double speedX = bulletSpeed * Math.cos(radius);\n        double speedY = bulletSpeed * Math.sin(radius);\n\n        Bullet bullet = new Bullet(x1, y1, 4, Color.red, damage, speedX, speedY, true, false);\n        bullets.add(bullet);\n\n        lastFired = LocalTime.now().toNanoOfDay();\n        bulletsInMag--;\n    }\n}",
      "Bullet.java": "//import javax.swing.*;\nimport java.awt.*;\n//import java.awt.event.*;\n//import java.util.ArrayList;\n//import java.util.List;\n//import java.lang.reflect.Array;\nimport java.util.ArrayList;\n\n\npublic class Bullet extends Circle{\n    double damage, speedX, speedY;\n    boolean isHit = false, isExplosive, canPenetrate;\n    public Bullet(double x, double y, double radius, Color color, double damage, double speedX, double speedY, boolean isExplosive, boolean canPenetrate) {\n        super(x, y, radius, color);\n        this.damage = damage;\n        this.speedX = speedX;\n        this.speedY = speedY;\n        this.isExplosive = isExplosive;\n        this.canPenetrate = canPenetrate;\n    }\n}\n\nclass AcidSpit extends Bullet{\n    double maxDistance;\n    boolean hasHitGround = false;\n    long timeOfImpact = -1, duration;\n    public AcidSpit(double x, double y, double radius, Color color, double damage, double speedX, double speedY, double maxDistance, long duration) {\n        super(x, y, radius, color, damage, speedX, speedY, false, false);\n        this.damage = damage;\n        this.speedX = speedX;\n        this.speedY = speedY;\n        this.duration = duration;\n        this.maxDistance = maxDistance;\n    }\n}\n\nclass SniperBullet extends Bullet{\n    ArrayList<Zombie> hits;\n    public SniperBullet(double x, double y, double radius, Color color, double damage, double speedX, double speedY, boolean isExplosive, boolean canPenetrate) {\n        super(x, y, radius, color, damage, speedX, speedY, isExplosive, canPenetrate);\n        hits = new ArrayList<>();\n    }\n}",
      "Circle.java": "//import javax.swing.*;\nimport java.awt.*;\n//import java.awt.event.*;\n//import java.util.ArrayList;\n//import java.util.List;\n\n\npublic class Circle{\n    double x, y, vx, vy, radius;\n    Color color;\n\n    public Circle(double x, double y){ this(x, y, 1e-8, Color.black); }\n    public Circle(double x, double y, double radius, Color color) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.color = color;\n    }\n\n    public void draw(Graphics2D g2d){\n        g2d.setColor(color);\n        g2d.fillOval((int)Math.round(x-radius), (int)Math.round(y-radius), (int)(radius*2), (int)(radius*2));\n    }\n\n    public double distance(Circle otherCircle){\n        double dx = this.x - otherCircle.x;\n        double dy = this.y - otherCircle.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    boolean intersects(Circle otherCircle){\n        double dx = this.x - otherCircle.x;\n        double dy = this.y - otherCircle.y;\n        double distance = Math.sqrt(dx*dx + dy*dy);\n        return distance < this.radius + otherCircle.radius;\n    }\n\n    void handleCollision(Circle otherCircle){\n        double vx = this.x - otherCircle.x;\n        double vy = this.y - otherCircle.y;\n        double distance = Math.sqrt(vx*vx + vy*vy);\n        double collisionAmount = (this.radius + otherCircle.radius) - distance;\n\n        vx *= collisionAmount / distance;\n        vy *= collisionAmount / distance;\n\n        if(this instanceof Player){\n            otherCircle.x -= 2 * vx;\n            otherCircle.y -= 2 * vy;\n        }\n        else if(otherCircle instanceof Player){\n            this.x += 2 * vx;\n            this.y += 2 * vy;\n        }\n        else{\n            this.x += vx;\n            this.y += vy;\n    \n            otherCircle.x -= vx;\n            otherCircle.y -= vy;\n        }\n    }\n}",
      "Game.java": "import javax.swing.*;\nimport java.awt.*;\n//import java.awt.RenderingHints.Key;\nimport java.awt.event.*;\nimport java.util.ArrayList;\nimport java.time.LocalTime;\nimport java.awt.geom.RoundRectangle2D;\n//import java.util.List;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class Game extends JPanel implements MouseListener, KeyListener, MouseMotionListener{\n    \n    final static private int width = 1200;\n    final static private int height = 1000;\n\n    private int wave = -1;\n    private int[][] waves = {\n        {10, 0, 0, 0},\n        {20, 0, 0, 0},\n        {15, 10, 0, 0},\n        {15, 15, 0, 0},\n        {20, 20, 5, 0},\n        {20, 15, 10, 0},\n        {20, 20, 15, 0},\n        {20, 15, 15, 5},\n        {20, 20, 10, 10},\n        {25, 20, 15, 10},\n        {25, 25, 15, 15},\n        {30, 25, 20, 20},\n        {35, 30, 25, 20},\n        {40, 30, 30, 25}\n    };\n\n    private int point = 0;\n    private boolean isPaused = false;\n    private boolean isWon = false;\n    private boolean isLoading = false;\n    private Timer timer;\n    private ArrayList<Zombie> zombies = new ArrayList<>();\n    private ArrayList<Bullet> bullets = new ArrayList<>();\n    private ArrayList<AcidSpit> spits = new ArrayList<>();\n    private ArrayList<Gun> guns = new ArrayList<>();\n    private Gun currentGun;\n    private Player player = new Player(width/2, height/2, 20, Color.black, 100, 3);\n\n    public Game(){ \n        super(); \n\n        //public Gun(double damage, double fireRate, double spreadAngle, int magazineCap, int totalBulletCount, int bulletsInMag)\n        //guns.add(new Gun());\n\n        setBackground(Color.white);\n\n        this.setFocusable(true);\n        this.addKeyListener(this);\n        this.addMouseListener(this);\n        this.addMouseMotionListener(this);\n\n        guns.add(new Pistol(player.x, player.y));\n        currentGun = guns.get(0);\n\n        timer = new Timer(10, _ -> {\n            if(!isPaused && !isWon && !isLoading){\n                if(zombies.size() == 0){\n                    wave++;\n\n                    if(wave == 1)  guns.add(new Rifle(player.x, player.y));\n                    if(wave == 3)  guns.add(new Shotgun(player.x, player.y));\n                    if(wave == 5)  guns.add(new Sniper(player.x, player.y));\n                    if(wave == 10) guns.add(new RocketLauncher(player.x, player.y));\n                    \n                    if(wave == waves.length) isWon = true;\n                    else createZombieWave(waves[wave]);\n                }\n                updatePlayerMovement();\n                updateSpits();\n                updateBullets();\n                updateZombies();\n                centerPlayer();\n            }\n            repaint();\n        });\n        timer.start();\n\n    }\n\n    // --- MouseListener methods ---\n    @Override public void mouseClicked(MouseEvent e) { }\n    @Override public void mousePressed(MouseEvent e) {\n        currentGun.fire(bullets);\n    }\n    @Override public void mouseReleased(MouseEvent e) { }\n    @Override public void mouseEntered(MouseEvent e) { }\n    @Override public void mouseExited(MouseEvent e) { }\n    \n    // --- MouseMotionListener methods ---\n    @Override public void mouseMoved(MouseEvent e) {\n        for(Gun gun:guns){\n            gun.rotate(e.getX(), e.getY());\n        }\n    }\n    @Override public void mouseDragged(MouseEvent e) { }\n\n    // --- KeyListener methods ---\n    @Override public void keyPressed(KeyEvent e){ \n        if(e.getKeyCode() == KeyEvent.VK_W) player.moveUp = true;\n        if(e.getKeyCode() == KeyEvent.VK_S) player.moveDown = true;\n        if(e.getKeyCode() == KeyEvent.VK_A) player.moveLeft = true;\n        if(e.getKeyCode() == KeyEvent.VK_D) player.moveRight = true;\n\n        switch (e.getKeyCode()){\n            case KeyEvent.VK_R:\n                currentGun.reload();\n                break;\n\n            case KeyEvent.VK_1:\n                if(guns.size() >= 1) currentGun = guns.get(0);\n                break;\n\n            case KeyEvent.VK_2:\n                if(guns.size() >= 2) currentGun = guns.get(1);\n                break;\n\n            case KeyEvent.VK_3:\n                if(guns.size() >= 3) currentGun = guns.get(2);\n                break;\n\n            case KeyEvent.VK_4:\n                if(guns.size() >= 4) currentGun = guns.get(3);\n                break;\n\n            case KeyEvent.VK_5:\n                if(guns.size() >= 5) currentGun = guns.get(4);\n                break;\n        }\n    }\n    @Override public void keyReleased(KeyEvent e) { \n        if(e.getKeyCode() == KeyEvent.VK_W) player.moveUp = false;\n        if(e.getKeyCode() == KeyEvent.VK_S) player.moveDown = false;\n        if(e.getKeyCode() == KeyEvent.VK_A) player.moveLeft = false;\n        if(e.getKeyCode() == KeyEvent.VK_D) player.moveRight = false;\n        if(e.getKeyCode() == KeyEvent.VK_ESCAPE){\n            if(isPaused) isPaused = false;\n            else isPaused = true;\n        }\n        if(e.getKeyCode() == KeyEvent.VK_S && isPaused) saveGame();\n        if(e.getKeyCode() == KeyEvent.VK_L && isPaused) loadGame();\n    }\n    @Override public void keyTyped(KeyEvent e) { }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2d = (Graphics2D) g;\n\n        if(isWon){\n            g2d.setColor(Color.GREEN);\n            g2d.fillRect(0, 0, width, height);\n\n            g2d.setColor(Color.WHITE);\n            g2d.drawString(\"YOU WON\", width / 2, height / 2);\n            g2d.drawString(\"Point: \" + point, width / 2, height / 2 + 20);\n            return;\n        }\n\n        if(player.health <= 0){\n            g2d.setColor(Color.BLACK);\n            g2d.fillRect(0, 0, width, height);\n\n            g2d.setColor(Color.WHITE);\n            g2d.drawString(\"YOU DIED\", width / 2, height / 2);\n            g2d.drawString(\"POINTS: \" + point, width / 2, height / 2 + 20);\n            return;\n        }\n\n        if(isPaused){\n            g2d.setColor(Color.BLACK);\n            g2d.fillRect(0, 0, width, height);\n\n            g2d.setColor(Color.WHITE);\n            g2d.drawString(\"PAUSED\", width / 2, height / 2);\n            g2d.drawString(\"SAVE (S)\", width / 2, height / 2 + 20);\n            g2d.drawString(\"LOAD (L)\", width / 2, height / 2 + 40);\n            return;\n        }\n\n        for(AcidSpit spit:spits) spit.draw(g2d);\n        for(Bullet bullet:bullets) bullet.draw(g2d);\n        for(Zombie zombie:zombies) zombie.draw(g2d);\n        player.draw(g2d);\n        currentGun.draw(g2d);\n\n        drawBeveledRectangle(g2d, -10, -10, 290, 90, 20, 20, Color.WHITE, Color.BLACK, 3);\n        drawBeveledRectangle(g2d, 10, 10, (int)Math.round(260 * (player.health / 100)), 20, 5, 5, new Color(0x0fba2f), new Color(0x0fba2f), 3);\n\n        g2d.setColor(Color.BLACK);\n        g2d.drawString(\"\" + currentGun.name, 10, 50);\n        if(currentGun instanceof Pistol) g2d.drawString(\"\" + currentGun.bulletsInMag + \"/INF\", 10, 70);\n        else g2d.drawString(\"\" + currentGun.bulletsInMag + \"/\" + currentGun.totalBulletCount, 10, 70);\n        \n        g2d.drawString(\"Wave\", 145, 50);\n        g2d.drawString(\"\" + (wave + 1), 145, 70);\n\n        g2d.drawString(\"Points\", 220, 50);\n        g2d.drawString(\"\" + point, 220, 70);\n\n    }\n\n    void createZombieWave(int[] zombieCount){\n        double zombieX, zombieY;\n        Zombie zombie;\n\n        zombieX = (Math.random() - 0.5) * (2 * width);\n        zombieY = (Math.random() - 0.5) * (2 * height);\n        zombie = new NormalZombie(zombieX, zombieY);\n        while(zombieCount[0] > 0){\n            if(zombie.distance(player) > 500){\n                zombies.add(zombie);\n                zombieCount[0]--;\n            }\n            zombieX = (Math.random() - 0.5) * (2 * width);\n            zombieY = (Math.random() - 0.5) * (2 * height);\n            zombie = new NormalZombie(zombieX, zombieY);\n        }\n\n        zombieX = (Math.random() - 0.5) * (2 * width);\n        zombieY = (Math.random() - 0.5) * (2 * height);\n        zombie = new CrawlerZombie(zombieX, zombieY);\n        while(zombieCount[1] > 0){\n            if(zombie.distance(player) > 500){\n                zombies.add(zombie);\n                zombieCount[1]--;\n            }\n            zombieX = (Math.random() - 0.5) * (2 * width);\n            zombieY = (Math.random() - 0.5) * (2 * height);\n            zombie = new CrawlerZombie(zombieX, zombieY);\n        }\n\n        zombieX = (Math.random() - 0.5) * (2 * width);\n        zombieY = (Math.random() - 0.5) * (2 * height);\n        zombie = new TankZombie(zombieX, zombieY);\n        while(zombieCount[2] > 0){\n            if(zombie.distance(player) > 500){\n                zombies.add(zombie);\n                zombieCount[2]--;\n            }\n            zombieX = (Math.random() - 0.5) * (2 * width);\n            zombieY = (Math.random() - 0.5) * (2 * height);\n            zombie = new TankZombie(zombieX, zombieY);\n        }\n\n        zombieX = (Math.random() - 0.5) * (2 * width);\n        zombieY = (Math.random() - 0.5) * (2 * height);\n        zombie = new SpitterZombie(zombieX, zombieY);\n        while(zombieCount[3] > 0){\n            if(zombie.distance(player) > 500){\n                zombies.add(zombie);\n                zombieCount[3]--;\n            }\n            zombieX = (Math.random() - 0.5) * (2 * width);\n            zombieY = (Math.random() - 0.5) * (2 * height);\n            zombie = new SpitterZombie(zombieX, zombieY);\n        }\n    }\n\n    void updatePlayerMovement(){\n        for(Zombie zombie:zombies){\n            if(player.moveUp) zombie.y += player.speed;\n            if(player.moveDown) zombie.y -= player.speed;\n            if(player.moveLeft) zombie.x += player.speed;\n            if(player.moveRight) zombie.x -= player.speed;\n\n            if(zombie instanceof CrawlerZombie){\n                CrawlerZombie crawler = (CrawlerZombie) zombie;\n                if(player.moveUp) crawler.jumpTargetY += player.speed;\n                if(player.moveDown) crawler.jumpTargetY -= player.speed;\n                if(player.moveLeft) crawler.jumpTargetX += player.speed;\n                if(player.moveRight) crawler.jumpTargetX -= player.speed;\n            }\n        }\n\n        for(Bullet bullet:bullets){\n            if(player.moveUp) bullet.y += player.speed;\n            if(player.moveDown) bullet.y -= player.speed;\n            if(player.moveLeft) bullet.x += player.speed;\n            if(player.moveRight) bullet.x -= player.speed;\n        }\n\n        for(AcidSpit spit:spits){\n            if(player.moveUp) spit.y += player.speed;\n            if(player.moveDown) spit.y -= player.speed;\n            if(player.moveLeft) spit.x += player.speed;\n            if(player.moveRight) spit.x -= player.speed;\n        }\n    }\n\n    void updateZombies(){\n        // Removing dead zombies\n        for(int i = 0;i < zombies.size();i++){\n            if(zombies.get(i).health <= 0){\n                point += zombies.get(i).point;\n                zombies.remove(i);\n                i--;\n\n                // Randomly acquiring bullets from dead zombies\n                if(guns.size() > 1 && Math.random() < 0.2){\n                    int gunCount = guns.size() - 1;\n                    int gunIndex = (int)Math.floor(Math.max(Math.random() - 1e-9, 0) * gunCount) + 1;\n                    Gun gun = guns.get(gunIndex);\n                    gun.totalBulletCount += 2 * gun.magazineCap;\n                }\n            }\n        }\n\n        \n        for(Zombie zombie:zombies) {\n            if(zombie instanceof CrawlerZombie && ((CrawlerZombie)zombie).isJumping){ // Handling jumping crawlers\n                CrawlerZombie crawler = (CrawlerZombie) zombie;\n                double vx = crawler.jumpTargetX - crawler.x;\n                double vy = crawler.jumpTargetY - crawler.y;\n                double distance = Math.sqrt(vx*vx + vy*vy);\n    \n                if(distance < 2 * crawler.speed){\n                    crawler.x = crawler.jumpTargetX;\n                    crawler.y = crawler.jumpTargetY;\n                    crawler.isJumping = false;\n                    crawler.color = new Color(0x6b9c10);\n                    continue;\n                }\n    \n                vx *= 2 * crawler.speed / distance;\n                vy *= 2 * crawler.speed / distance;\n    \n                crawler.x += vx;\n                crawler.y += vy;\n            }\n            else if(zombie instanceof SpitterZombie && player.distance(zombie) < 200){ // Handling spitters that are close to player\n                ((SpitterZombie)zombie).spit(spits, player);\n            }\n            else{ // Moving zombies towards the character\n                double vx = player.x - zombie.x;\n                double vy = player.y - zombie.y;\n                double distance = Math.sqrt(vx*vx + vy*vy);\n    \n                vx /= distance;\n                vy /= distance;\n    \n                zombie.x += vx * zombie.speed;\n                zombie.y += vy * zombie.speed;\n    \n                if(zombie instanceof CrawlerZombie && player.distance(zombie) < 200){\n                    ((CrawlerZombie)zombie).jump(player);\n                }\n            }\n            \n        }\n        // Handling collisions\n        for(Zombie zombie1:zombies){\n            for(Zombie zombie2:zombies) if(zombie1 != zombie2 && zombie1.intersects(zombie2)){\n                zombie1.handleCollision(zombie2);\n            } \n        }\n\n        // Damage dealt to player\n        for(Zombie zombie:zombies){\n            if(player.intersects(zombie)){\n                player.health -= zombie.damage;\n                zombie.handleCollision(player);\n            }\n\n            if(zombie instanceof CrawlerZombie && player.distance(zombie) < 20){\n                ((CrawlerZombie)zombie).jump(player);\n            }\n\n        }\n    }\n\n    void updateBullets(){\n        // Updating bullet coordinates\n        for(Bullet bullet:bullets){\n            bullet.x += bullet.speedX;\n            bullet.y += bullet.speedY;\n        }\n\n        // Removing bullets that are too far away from player\n        for(int i = 0;i < bullets.size();i++){\n            Bullet bullet = bullets.get(i);\n            double dx = player.x - bullet.x;\n            double dy = player.y - bullet.y;\n            double dist = Math.sqrt(dx*dx + dy*dy);\n            if(dist > 5000)\n                bullets.remove(bullet);\n        }\n\n        // For each bullet, checking whether that bullet hits a zombie\n        for(Bullet bullet:bullets){\n            for(Zombie zombie:zombies) if(bullet.isHit == false && bullet.intersects(zombie) && zombie.health > 0){\n                if(bullet instanceof SniperBullet && ((SniperBullet)bullet).hits.contains(zombie)) break;\n\n                if(bullet.isExplosive){\n                    Circle blast = new Circle(bullet.x, bullet.y, 70, Color.red);\n                    blast.draw((Graphics2D)this.getGraphics());\n                    for(Zombie zombie2:zombies){\n                        if(blast.intersects(zombie2) && zombie2.health > 0){\n                            zombie2.health -= bullet.damage;\n                        }\n                    }\n                }\n                else{\n                    zombie.health -= bullet.damage;\n                }\n                \n                if(!bullet.canPenetrate){\n                    bullet.isHit = true;\n                }\n\n                if(bullet instanceof SniperBullet){\n                    ((SniperBullet)bullet).hits.add(zombie);\n                }\n\n                break;\n            }\n        }\n\n        // Removing bullet that hit a zombie\n        for(int i = 0;i < bullets.size();i++){\n            if(bullets.get(i).isHit){\n                bullets.remove(i);\n                i--;\n            }\n        }\n    }\n\n    void updateSpits(){\n        // Removing expired spits\n        for(int i = 0;i < spits.size();i++) if(spits.get(i).hasHitGround){\n            AcidSpit spit = spits.get(i);\n            if(LocalTime.now().toSecondOfDay() - spit.timeOfImpact >= spit.duration){\n                spits.remove(i);\n            }\n        }\n\n        // Updating bullet coordinates\n        for(AcidSpit spit:spits) if(!spit.hasHitGround) {\n            spit.x += spit.speedX;\n            spit.y += spit.speedY;\n            spit.maxDistance -= Math.sqrt(spit.speedX * spit.speedX + spit.speedY * spit.speedY);\n            \n            if(spit.maxDistance < 0){\n                spit.radius = 30;\n                spit.hasHitGround = true;\n                spit.timeOfImpact = LocalTime.now().toSecondOfDay();\n            }\n        }\n\n        // Spits on the ground\n        for(AcidSpit spit:spits) if(spit.hasHitGround) {\n            if(player.intersects(spit)){\n                spit.hasHitGround = true;\n                player.health -= spit.damage;\n            }\n        }\n\n        // Spits hitting player\n        for(AcidSpit spit:spits) if(!spit.hasHitGround) {\n            if(player.intersects(spit)){\n                spit.hasHitGround = true;\n                player.health -= spit.damage;\n                spit.timeOfImpact = LocalTime.now().toSecondOfDay();\n                spit.radius = 30;\n            }\n        }\n\n    }\n\n    public void centerPlayer(){\n        double dx = (width / 2) - player.x;\n        double dy = (height/ 2) - player.y;\n\n        player.x += dx;\n        player.y += dy;\n\n        for(Zombie zombie:zombies) zombie.x += dx;\n        for(Zombie zombie:zombies) zombie.y += dy;\n        \n        for(Bullet bullet:bullets) bullet.y += dy;\n        for(Bullet bullet:bullets) bullet.x += dx;\n\n        for(AcidSpit spit:spits) spit.y += dy;\n        for(AcidSpit spit:spits) spit.x += dx;\n    }\n\n    public static void drawBeveledRectangle(Graphics2D g2d, int x, int y, int width, int height, int arcWidth, int arcHeight, Color fillColor, Color outlineColor, int outlineThickness) {\n        RoundRectangle2D.Double roundedRectangle = new RoundRectangle2D.Double(x, y, width, height, arcWidth, arcHeight);\n\n        g2d.setColor(fillColor);\n        g2d.fill(roundedRectangle);\n\n        g2d.setColor(outlineColor);\n        g2d.setStroke(new BasicStroke(outlineThickness));\n        g2d.draw(roundedRectangle);\n    }\n\n    public void saveGame() {\n        try (PrintWriter writer = new PrintWriter(new FileWriter(\"savegame.txt\"))) {\n            writer.println(\"Wave: \" + wave);  \n            writer.println(\"Point: \" + point);  \n            writer.println(\"IsPaused: \" + isPaused);  \n            writer.println(\"IsWon: \" + isWon);  \n            writer.println(\"PlayerHealth: \" + player.health);  \n            writer.println(\"CurrentGunIndex: \" + guns.indexOf(currentGun));  \n            writer.println(\"PlayerX: \" + player.x);  \n            writer.println(\"PlayerY: \" + player.y);  \n\n            writer.println(\"GunCount: \" + guns.size());  \n            for (Gun gun : guns) {\n                writer.println(\"GunType: \" + getGunTypeName(gun));  \n                writer.println(\"MagazineCap: \" + gun.magazineCap);  \n                writer.println(\"TotalBulletCount: \" + gun.totalBulletCount);  \n                writer.println(\"BulletsInMag: \" + gun.bulletsInMag);  \n                writer.println(\"GunX1: \" + gun.x1);  \n                writer.println(\"GunY1: \" + gun.y1);  \n                writer.println(\"GunX2: \" + gun.x2);  \n                writer.println(\"GunY2: \" + gun.y2);  \n                writer.println(\"GunThickness: \" + gun.thickness);  \n                writer.println(\"GunColorRGB: \" + gun.color.getRGB());  \n                writer.println(\"GunDamage: \" + gun.damage);  \n                writer.println(\"GunFireRate: \" + gun.fireRate);  \n                writer.println(\"GunSpreadAngle: \" + gun.spreadAngle);  \n                writer.println(\"GunLength: \" + gun.length);  \n                writer.println(\"GunLastFired: \" + gun.lastFired);  \n                writer.println(\"GunName: \" + gun.name);  \n            }\n\n            writer.println(\"ZombieCount: \" + zombies.size());  \n            for (Zombie zombie : zombies) {\n                writer.println(\"ZombieType: \" + getZombieTypeName(zombie));  \n                writer.println(\"ZombieX: \" + zombie.x);  \n                writer.println(\"ZombieY: \" + zombie.y);  \n                writer.println(\"ZombieHealth: \" + zombie.health);  \n                writer.println(\"ZombieRadius: \" + zombie.radius);  \n                writer.println(\"ZombieColorRGB: \" + zombie.color.getRGB());  \n                writer.println(\"ZombieSpeed: \" + zombie.speed);  \n                writer.println(\"ZombieDamage: \" + zombie.damage);  \n                writer.println(\"ZombiePoint: \" + zombie.point);  \n                if (zombie instanceof CrawlerZombie) {\n                    CrawlerZombie crawler = (CrawlerZombie) zombie;\n                    writer.println(\"CrawlerIsJumping: \" + crawler.isJumping);  \n                    writer.println(\"CrawlerJumpTargetX: \" + crawler.jumpTargetX);  \n                    writer.println(\"CrawlerJumpTargetY: \" + crawler.jumpTargetY);  \n                    writer.println(\"CrawlerLastJump: \" + crawler.lastJump);  \n                } else if (zombie instanceof SpitterZombie) {\n                    SpitterZombie spitter = (SpitterZombie) zombie;\n                    writer.println(\"SpitterSpittingDistance: \" + spitter.spittingDistance);  \n                    writer.println(\"SpitterLastSpit: \" + spitter.lastSpit);  \n                }\n            }\n\n            writer.println(\"BulletCount: \" + bullets.size());  \n            for (Bullet bullet : bullets) {\n                writer.println(\"BulletType: \" + getBulletTypeName(bullet));  \n                writer.println(\"BulletX: \" + bullet.x);  \n                writer.println(\"BulletY: \" + bullet.y);  \n                writer.println(\"BulletRadius: \" + bullet.radius);  \n                writer.println(\"BulletColorRGB: \" + bullet.color.getRGB());  \n                writer.println(\"BulletSpeedX: \" + bullet.speedX);  \n                writer.println(\"BulletSpeedY: \" + bullet.speedY);  \n                writer.println(\"BulletDamage: \" + bullet.damage);  \n                writer.println(\"BulletIsHit: \" + bullet.isHit);  \n                writer.println(\"BulletIsExplosive: \" + bullet.isExplosive);  \n                writer.println(\"BulletCanPenetrate: \" + bullet.canPenetrate);  \n                if (bullet instanceof AcidSpit) {\n                    AcidSpit spit = (AcidSpit) bullet;\n                    writer.println(\"SpitMaxDistance: \" + spit.maxDistance);  \n                    writer.println(\"SpitHasHitGround: \" + spit.hasHitGround);  \n                    writer.println(\"SpitTimeOfImpact: \" + spit.timeOfImpact);  \n                    writer.println(\"SpitDuration: \" + spit.duration);  \n                } else if (bullet instanceof SniperBullet) {\n\n                }\n            }\n\n            writer.println(\"SpitCount: \" + spits.size());  \n            for (AcidSpit spit : spits) {\n                writer.println(\"SpitX: \" + spit.x);  \n                writer.println(\"SpitY: \" + spit.y);  \n                writer.println(\"SpitRadius: \" + spit.radius);  \n                writer.println(\"SpitColorRGB: \" + spit.color.getRGB());  \n                writer.println(\"SpitSpeedX: \" + spit.speedX);  \n                writer.println(\"SpitSpeedY: \" + spit.speedY);  \n                writer.println(\"SpitDamage: \" + spit.damage);  \n                writer.println(\"SpitDuration: \" + spit.duration);  \n                writer.println(\"SpitTimeOfImpact: \" + spit.timeOfImpact);  \n                writer.println(\"SpitHasHitGround: \" + spit.hasHitGround);  \n                writer.println(\"SpitMaxDistance: \" + spit.maxDistance);  \n            }\n\n            System.out.println(\"Game saved successfully!\");\n\n        } catch (IOException e) {\n            System.err.println(\"Error saving game: \" + e.getMessage());\n        }\n    }\n\n    public void loadGame() {\n        isLoading = true;\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"savegame.txt\"))) {\n            String line;\n            guns.clear();\n            zombies.clear();\n            bullets.clear();\n            spits.clear();\n            int loadedCurrentGunIndex = -1;\n\n            while ((line = reader.readLine()) != null) {\n                String[] parts = line.split(\"\\\\s+\");\n                if (parts.length < 2) continue;\n\n                String label = parts[0];\n                String valueStr = parts[1];\n\n                if (label.equals(\"Wave:\")) {\n                    wave = Integer.parseInt(valueStr);\n                } else if (label.equals(\"Point:\")) {\n                    point = Integer.parseInt(valueStr);\n                }\n                else if (label.equals(\"IsPaused:\")) {\n                    isPaused = Boolean.parseBoolean(valueStr);\n                } else if (label.equals(\"IsWon:\")) {\n                    isWon = Boolean.parseBoolean(valueStr);\n                } else if (label.equals(\"PlayerHealth:\")) {\n                    player.health = Double.parseDouble(valueStr);\n                } else if (label.equals(\"CurrentGunIndex:\")) {\n                    loadedCurrentGunIndex = Integer.parseInt(valueStr);\n                } else if (label.equals(\"PlayerX:\")) {\n                    player.x = Double.parseDouble(valueStr);\n                } else if (label.equals(\"PlayerY:\")) {\n                    player.y = Double.parseDouble(valueStr);\n                } else if (label.equals(\"GunCount:\")) {\n                    int gunCount = Integer.parseInt(valueStr);\n                    for (int i = 0; i < gunCount; i++) {\n                        Gun gun = null;\n                        String gunType = reader.readLine().split(\"\\\\s+\")[1];\n                        int magazineCap = Integer.parseInt(reader.readLine().split(\"\\\\s+\")[1]);\n                        int totalBulletCount = Integer.parseInt(reader.readLine().split(\"\\\\s+\")[1]);\n                        int bulletsInMag = Integer.parseInt(reader.readLine().split(\"\\\\s+\")[1]);\n                        double gunX1 = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double gunY1 = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double gunX2 = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double gunY2 = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        int gunThickness = Integer.parseInt(reader.readLine().split(\"\\\\s+\")[1]);\n                        Color gunColor = new Color(Integer.parseInt(reader.readLine().split(\"\\\\s+\")[1]));\n                        double gunDamage = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double gunFireRate = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double gunSpreadAngle = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double gunLength = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        long gunLastFired = Long.parseLong(reader.readLine().split(\"\\\\s+\")[1]);\n                        String gunName = reader.readLine().split(\"\\\\s+\")[1];\n\n\n                        if (gunType.equals(\"Pistol\")) {\n                            gun = new Pistol(player.x, player.y);\n                        } else if (gunType.equals(\"Rifle\")) {\n                            gun = new Rifle(player.x, player.y);\n                        } else if (gunType.equals(\"Shotgun\")) {\n                            gun = new Shotgun(player.x, player.y);\n                        } else if (gunType.equals(\"Sniper\")) {\n                            gun = new Sniper(player.x, player.y);\n                        } else if (gunType.equals(\"RocketLauncher\")) {\n                            gun = new RocketLauncher(player.x, player.y);\n                        }\n\n                        if (gun != null) {\n                            gun.magazineCap = magazineCap;\n                            gun.totalBulletCount = totalBulletCount;\n                            gun.bulletsInMag = bulletsInMag;\n                            gun.x1 = gunX1;\n                            gun.y1 = gunY1;\n                            gun.x2 = gunX2;\n                            gun.y2 = gunY2;\n                            gun.thickness = gunThickness;\n                            gun.color = gunColor;\n                            gun.damage = gunDamage;\n                            gun.fireRate = gunFireRate;\n                            gun.spreadAngle = gunSpreadAngle;\n                            gun.length = gunLength;\n                            gun.lastFired = gunLastFired;\n                            gun.name = gunName;\n                            guns.add(gun);\n                        }\n                    }\n                    if (loadedCurrentGunIndex >= 0 && loadedCurrentGunIndex < guns.size()) {\n                        currentGun = guns.get(loadedCurrentGunIndex);\n                    } else if (!guns.isEmpty()) {\n                        currentGun = guns.get(0);\n                    } else {\n                        currentGun = null;\n                    }\n                } else if (label.equals(\"ZombieCount:\")) {\n                    int zombieCount = Integer.parseInt(valueStr);\n                    for (int i = 0; i < zombieCount; i++) {\n                        Zombie zombie = null;\n                        String zombieType = reader.readLine().split(\"\\\\s+\")[1];\n                        double zombieX = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double zombieY = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double zombieHealth = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double zombieRadius = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        Color zombieColor = new Color(Integer.parseInt(reader.readLine().split(\"\\\\s+\")[1]));\n                        double zombieSpeed = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double zombieDamage = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double zombiePoint = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n\n                        if (zombieType.equals(\"NormalZombie\")) {\n                            zombie = new NormalZombie(0, 0);\n                        } else if (zombieType.equals(\"CrawlerZombie\")) {\n                            zombie = new CrawlerZombie(0, 0);\n                        } else if (zombieType.equals(\"TankZombie\")) {\n                            zombie = new TankZombie(0, 0);\n                        } else if (zombieType.equals(\"SpitterZombie\")) {\n                            zombie = new SpitterZombie(0, 0);\n                        }\n\n                        if (zombie != null) {\n                            zombie.x = zombieX;\n                            zombie.y = zombieY;\n                            zombie.health = zombieHealth;\n                            zombie.radius = zombieRadius;\n                            zombie.color = zombieColor;\n                            zombie.speed = zombieSpeed;\n                            zombie.damage = zombieDamage;\n                            zombie.point = zombiePoint;\n                            if (zombie instanceof CrawlerZombie) {\n                                CrawlerZombie crawler = (CrawlerZombie) zombie;\n                                crawler.isJumping = Boolean.parseBoolean(reader.readLine().split(\"\\\\s+\")[1]);\n                                crawler.jumpTargetX = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                                crawler.jumpTargetY = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                                crawler.lastJump = Integer.parseInt(reader.readLine().split(\"\\\\s+\")[1]);\n                            } else if (zombie instanceof SpitterZombie) {\n                                SpitterZombie spitter = (SpitterZombie) zombie;\n                                spitter.spittingDistance = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                                spitter.lastSpit = Integer.parseInt(reader.readLine().split(\"\\\\s+\")[1]);\n                            }\n                            zombies.add(zombie);\n                        }\n                    }\n                } else if (label.startsWith(\"BulletCount:\")) {\n                    int bulletCount = Integer.parseInt(valueStr);\n                    for (int i = 0; i < bulletCount; i++) {\n                         Bullet bullet = null;\n                        String bulletType = reader.readLine().split(\"\\\\s+\")[1];\n                        double bulletX = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double bulletY = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double bulletRadius = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        Color bulletColor = new Color(Integer.parseInt(reader.readLine().split(\"\\\\s+\")[1]));\n                        double bulletSpeedX = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double bulletSpeedY = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double bulletDamage = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        boolean bulletIsHit = Boolean.parseBoolean(reader.readLine().split(\"\\\\s+\")[1]);\n                        boolean bulletIsExplosive = Boolean.parseBoolean(reader.readLine().split(\"\\\\s+\")[1]);\n                        boolean bulletCanPenetrate = Boolean.parseBoolean(reader.readLine().split(\"\\\\s+\")[1]);\n\n                         if (bulletType.equals(\"Bullet\")) {\n                            bullet = new Bullet(0, 0, 0, Color.black, 0, 0, 0, false, false);\n                        } else if (bulletType.equals(\"AcidSpit\")) {\n                            bullet = new AcidSpit(0, 0, 0, Color.black, 0, 0, 0, 0, 0);\n                        } else if (bulletType.equals(\"SniperBullet\")) {\n                            bullet = new SniperBullet(0, 0, 0, Color.black, 0, 0, 0, false, true);\n                        }\n\n\n                        if (bullet != null) {\n                            bullet.x = bulletX;\n                            bullet.y = bulletY;\n                            bullet.radius = bulletRadius;\n                            bullet.color = bulletColor;\n                            bullet.speedX = bulletSpeedX;\n                            bullet.speedY = bulletSpeedY;\n                            bullet.damage = bulletDamage;\n                            bullet.isHit = bulletIsHit;\n                            bullet.isExplosive = bulletIsExplosive;\n                            bullet.canPenetrate = bulletCanPenetrate;\n                            if (bullet instanceof AcidSpit) {\n                                AcidSpit spit = (AcidSpit) bullet;\n                                spit.maxDistance = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                                spit.hasHitGround = Boolean.parseBoolean(reader.readLine().split(\"\\\\s+\")[1]);\n                                spit.timeOfImpact = Long.parseLong(reader.readLine().split(\"\\\\s+\")[1]);\n                                spit.duration = Integer.parseInt(reader.readLine().split(\"\\\\s+\")[1]);\n                            } else if (bullet instanceof SniperBullet) {\n                            }\n                            bullets.add(bullet);\n                        }\n                    }\n                } else if (label.startsWith(\"SpitCount:\")) {\n                    int spitCount = Integer.parseInt(valueStr);\n                    for (int i = 0; i < spitCount; i++) {\n                        double spitX = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double spitY = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double spitRadius = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        Color spitColor = new Color(Integer.parseInt(reader.readLine().split(\"\\\\s+\")[1]));\n                        double spitDamage = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double spitSpeedX = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        double spitSpeedY = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        long spitDuration = Long.parseLong(reader.readLine().split(\"\\\\s+\")[1]);\n                        long spitTimeOfImpact = Long.parseLong(reader.readLine().split(\"\\\\s+\")[1]);\n                        boolean spitHasHitGround = Boolean.parseBoolean(reader.readLine().split(\"\\\\s+\")[1]);\n                        double spitMaxDistance = Double.parseDouble(reader.readLine().split(\"\\\\s+\")[1]);\n                        AcidSpit spit = new AcidSpit(spitX, spitY, spitRadius, spitColor, spitDamage, spitSpeedX, spitSpeedY, spitMaxDistance, (int)spitDuration); // Dummy AcidSpit to overwrite values\n\n                        spit.timeOfImpact = spitTimeOfImpact;\n                        spit.hasHitGround = spitHasHitGround;\n                        spits.add(spit);\n                    }\n                }\n            }\n\n            centerPlayer();\n            requestFocusInWindow();\n            isLoading = false;\n            System.out.println(\"Game loaded successfully!\");\n\n        } catch (IOException e) {\n            System.err.println(\"Error loading game: \" + e.getMessage());\n        }\n    }\n\n    private String getGunTypeName(Gun gun) {\n        if (gun instanceof Pistol) return \"Pistol\";\n        if (gun instanceof Rifle) return \"Rifle\";\n        if (gun instanceof Shotgun) return \"Shotgun\";\n        if (gun instanceof Sniper) return \"Sniper\";\n        if (gun instanceof RocketLauncher) return \"RocketLauncher\";\n        return \"UnknownGun\";\n    }\n\n    private String getZombieTypeName(Zombie zombie) {\n        if (zombie instanceof NormalZombie) return \"NormalZombie\";\n        if (zombie instanceof CrawlerZombie) return \"CrawlerZombie\";\n        if (zombie instanceof TankZombie) return \"TankZombie\";\n        if (zombie instanceof SpitterZombie) return \"SpitterZombie\";\n        return \"UnknownZombie\";\n    }\n\n    private String getBulletTypeName(Bullet bullet) {\n        if (bullet instanceof AcidSpit) return \"AcidSpit\";\n        if (bullet instanceof SniperBullet) return \"SniperBullet\";\n        return \"Bullet\";\n    }\n\n    public static void main(String[] args) {\n\n        JFrame frame = new JFrame(\"Zombie Game\");\n        Game game = new Game();\n        frame.add(game);\n        frame.setSize(width, height);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n        frame.setResizable(false);\n        \n    }\n}\n\n\n",
      "Line.java": "//import javax.swing.*;\nimport java.awt.*;\n//import java.awt.event.*;\n//import java.util.ArrayList;\n//import java.util.List;\n\npublic class Line{\n    double x1, y1, x2, y2;\n    int thickness;\n    Color color;\n\n    public Line(double x1, double y1, double x2, double y2, int thickness, Color color){\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.thickness = thickness;\n        this.color = color;\n    }\n\n    public void draw(Graphics2D g2d){\n        g2d.setColor(color);\n        g2d.setStroke(new BasicStroke(thickness));\n        g2d.drawLine((int)Math.round(x1), (int)Math.round(y1), (int)Math.round(x2), (int)Math.round(y2));\n    }\n}",
      "Player.java": "//import javax.swing.*;\nimport java.awt.*;\n//import java.awt.event.*;\n//import java.util.ArrayList;\n//import java.util.List;\n\n\npublic class Player extends Circle{\n    double health, speed;\n    double moveX, moveY;\n    boolean moveUp = false, moveDown = false, moveLeft = false, moveRight = false;\n    Gun gun;\n\n\n    public Player(double x, double y, double radius, Color color, double health, double speed) {\n        super(x, y, radius, color);\n        this.health = health;\n        this.speed = speed;\n    }\n}"
    },
    {
      "id": "3659398",
      "SurungenZombie.java": "public class SurungenZombie extends Entity {\n    public SurungenZombie(Panel gp) {\n        super(gp);\n        speed = 4;\n        name = \"SurungeZombie\";\n        maxLife = 2;\n        life = maxLife;\n        solidArea.x = 3;\n        solidArea.y = 10;\n        solidArea.width = 42;\n        solidArea.height = 32;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        getImage();\n    }\n\n    public void getImage() {\n        up = setUp(\"SurungeZombie.png\");\n        up1 = setUp(\"SurungeZombie.png\");\n        down = setUp(\"SurungeZombie.png\");\n        down1 = setUp(\"SurungeZombie.png\");\n        right = setUp(\"SurungeZombie.png\");\n        right1 = setUp(\"SurungeZombie.png\");\n        left = setUp(\"SurungeZombie.png\");\n        left1 = setUp(\"SurungeZombie.png\");\n\n    }\n\n    public void setAction() {\n        // Oyuncunun konumunu al\n        int playerX = gp.player.worldx;\n        int playerY = gp.player.worldy;\n\n        // Zombinin oyuncuya olan konumunu hesapla\n        int deltaX = playerX - worldx;\n        int deltaY = playerY - worldy;\n\n        // Oyuncuya en yakın yönü belirle\n        if (Math.abs(deltaX) > Math.abs(deltaY)) {\n            // X ekseninde daha fazla mesafe var\n            if (deltaX > 0) {\n                direction = \"right\"; // Oyuncu sağda\n            } else {\n                direction = \"left\"; // Oyuncu solda\n            }\n        } else {\n            // Y ekseninde daha fazla mesafe var\n            if (deltaY > 0) {\n                direction = \"down\"; // Oyuncu aşağıda\n            } else {\n                direction = \"up\"; // Oyuncu yukarıda\n            }\n        }\n    }\n\n}\n",
      "Map.java": "import java.awt.*;\nimport javax.swing.*;\nimport javax.swing.border.Border;\n\nimport java.awt.event.*;\n\npublic class Map extends JFrame  {\n    private static final int WIDTH = 1200;\n    private static final int HEIGHT = 2400;\n\n    \n\n    Thread gameThread;\n    Panel gamepanel;\n    JPanel bars;\n    JLabel health;\n    JLabel bullets;\n    JLabel episode;\n\n    public Map() {\n        super(\"OYUN\");\n       gamepanel = new Panel();\n        setSize(WIDTH, HEIGHT);\n       \n        setLayout(new BorderLayout());\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        setResizable(false);\n        setLocationRelativeTo(null);\n        setVisible(true);\n        add(gamepanel, BorderLayout.CENTER);\n        pack();\n        gamepanel.setUpGame();\n        gamepanel.startGameThread();\n    }\n\n    \n    \n\n}\n",
      "Zombie.java": "public class Zombie extends Entity {\n    public Zombie(Panel gp) {\n        super(gp);\n        speed = 2;\n        name = \"Zombie\";\n        maxLife = 2;\n        life = maxLife;\n        solidArea.x = 3;\n        solidArea.y = 10;\n        solidArea.width = 42;\n        solidArea.height = 32;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        damage = 1;\n        getImage();\n    }\n\n    public void getImage() {\n        up = setUp(\"zombie.png\");\n        up1 = setUp(\"zombie.png\");\n        down = setUp(\"zombie.png\");\n        down1 = setUp(\"zombie.png\");\n        right = setUp(\"zombie.png\");\n        right1 = setUp(\"zombie.png\");\n        left = setUp(\"zombie.png\");\n        left1 = setUp(\"zombie.png\");\n\n    }\n    public void setAction() {\n        // Oyuncunun konumunu al\n        int playerX = gp.player.worldx;\n        int playerY = gp.player.worldy;\n    \n        // Zombinin oyuncuya olan konumunu hesapla\n        int deltaX = playerX - worldx;\n        int deltaY = playerY - worldy;\n    \n        // Oyuncuya en yakın yönü belirle\n        if (Math.abs(deltaX) > Math.abs(deltaY)) {\n            // X ekseninde daha fazla mesafe var\n            if (deltaX > 0) {\n                direction = \"right\"; // Oyuncu sağda\n            } else {\n                direction = \"left\"; // Oyuncu solda\n            }\n        } else {\n            // Y ekseninde daha fazla mesafe var\n            if (deltaY > 0) {\n                direction = \"down\"; // Oyuncu aşağıda\n            } else {\n                direction = \"up\"; // Oyuncu yukarıda\n            }\n        }\n    }\n    public void attack(Player player) {\n        if (isAlive()) {\n            int damage = 1; // Verilecek hasar\n            player.hit(); // Oyuncuya hasar ver\n            System.out.println(\"Zombiden oyuncuya \" + damage + \" hasar verildi.\");\n        }\n    }\n\n}\n",
      "Entity.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class Entity {\n    BufferedImage image, image2, image3;\n\n    public int damage = 0;\n    \n    public String name;\n    public boolean collision = false;\n\n    int worldx, worldy;\n    int speed;\n    // Images\n    public BufferedImage up, down, right, left, up1, down1, right1, left1;\n    public String direction = \"down\";\n    // Sprite settings\n    public int spriteCounter = 0;\n    public int spriteNumber = 1;\n    // Collision settings\n    public Rectangle solidArea = new Rectangle(0, 0, 48, 48);\n\n    public int solidAreaDefaultX, solidAreaDefaultY;\n    public boolean collisionOn = false;\n\n    public Panel gp;\n    public int actionLocker;\n    //Life settings\n    public int maxLife;\n    public int life;\n\n    public Entity(Panel gp) {\n        this.gp = gp;\n    }\n\n    public BufferedImage setUp(String imageName) {\n        BufferedImage scaledImage = null;\n        try {\n            UtilityTool tool = new UtilityTool();\n\n            scaledImage = ImageIO.read(getClass().getResourceAsStream(imageName));\n            scaledImage = tool.scaleImage(scaledImage, gp.tileSize, gp.tileSize);\n\n        } catch (IOException e) {\n\n            e.printStackTrace();\n        }\n        return scaledImage;\n\n    }\n\n    public void draw(Graphics2D g2) {\n        int screenX = worldx - gp.player.worldx + gp.player.screenX;\n        int screenY = worldy - gp.player.worldy + gp.player.screenY;\n\n        if (worldx < gp.player.screenX + gp.player.worldx + gp.tileSize\n                && worldx > gp.player.worldx - gp.player.screenX - gp.tileSize\n                && worldy < gp.player.screenY + gp.player.worldy + gp.tileSize\n                && worldy > gp.player.worldy - gp.player.screenY - gp.tileSize) {\n            BufferedImage image = null;\n            if (direction.equals(\"up\")) {\n                if (spriteNumber == 1)\n                    image = up;\n                else\n                    image = up1;\n            }\n            if (direction.equals(\"down\")) {\n                if (spriteNumber == 1)\n                    image = down;\n                else\n                    image = down1;\n            }\n            if (direction.equals(\"right\")) {\n                if (spriteNumber == 1)\n                    image = right;\n                else\n                    image = right1;\n            }\n            if (direction.equals(\"left\")) {\n                if (spriteNumber == 1)\n                    image = left;\n                else\n                    image = left1;\n            }\n            g2.drawImage(image, screenX, screenY, gp.tileSize, gp.tileSize, null);\n        }\n    }\n\n    public void setAction() {\n        \n\n    }\n\n    public void update() {\n        setAction();\n        collisionOn = false;\n        gp.cChecker.checkTile(this);\n        gp.cChecker.checkObject(this, false);\n        gp.cChecker.checkPlayer(this);\n        if (!collisionOn) {\n            if (direction.equals(\"up\")) {\n\n                worldy = worldy - speed;\n            }\n            if (direction.equals(\"down\")) {\n\n                worldy = worldy + speed;\n            }\n            if (direction.equals(\"right\")) {\n\n                worldx = worldx + speed;\n            }\n            if (direction.equals(\"left\")) {\n\n                worldx = worldx - speed;\n            }\n\n        }\n\n        spriteCounter++;\n        if (spriteCounter > 15) {\n            if (spriteNumber == 1) {\n                spriteNumber = 2;\n            } else if (spriteNumber == 2) {\n                spriteNumber = 1;\n            }\n            spriteCounter = 0;\n        }\n    }\n    public void hit() {\n        life -= damage; // Hasarı uygula\n        if (life < 0) {\n            life = 0; // Hayat sıfırın altına düşemez\n        }\n    }\n\n    public boolean isAlive() {\n        return life > 0; // Zombi hayatta mı?\n    }\n    public void hit(int damage) {\n        life -= damage; // Hasarı uygula\n        if (life < 0) {\n            life = 0; // Hayat sıfırın altına düşemez\n        }\n        System.out.println(\"Zombiye \" + damage + \" hasar verildi. Kalan yaşam: \" + life);\n    }\n}\n",
      "Bullet.java": "public class Bullet {\n    public int worldx, worldy; // Merminin konumu\n    public double speed; // Merminin hızı\n    public int damage; // Merminin vereceği hasar\n    public boolean isAlive; // Merminin hayatta olup olmadığını kontrol etmek için\n    public double directionX, directionY; // Merminin yönü\n\n    public Bullet(int startX, int startY, double angle, int speed, int damage) {\n        this.worldx = startX;\n        this.worldy = startY;\n        this.speed = speed;\n        this.damage = damage;\n        this.isAlive = true;\n\n        // Yönü belirle\n        this.directionX = Math.cos(angle);\n        this.directionY = Math.sin(angle);\n    }\n\n    public void update() {\n        // Mermiyi ileri doğru hareket ettir\n        worldx += directionX * speed;\n        worldy += directionY * speed;\n\n        // Eğer mermi ekranın dışına çıkarsa, onu öldür\n        if (worldx < 0 || worldx > 800 || worldy < 0 || worldy > 600) { // Ekran boyutuna göre ayarlayın\n            isAlive = false;\n        }\n    }\n}",
      "FileIO.java": "import java.io.*;\n\npublic class FileIO {\n    public static void saveGame(Panel gp) {\n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"savegame.dat\"))) {\n            oos.writeObject(gp.player); \n            oos.writeInt(gp.gameState); \n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void loadGame(Panel gp) {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"savegame.dat\"))) {\n            gp.player = (Player) ois.readObject(); \n            gp.gameState = ois.readInt();\n            \n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "Tile.java": "import java.awt.image.*;\npublic class Tile {\n    public BufferedImage image;\n    boolean collision = false;\n    \n}\n",
      "Shotgun.java": "import java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class Shotgun extends Entity{\n    public Shotgun(Panel gp)\n    {\n        super(gp);\n        name = \"Shotgun\";\n        down = setUp(\"shotgun.png\");\n       \n    }\n\n}\n",
      "Main.java": "public class Main {\n    public static void main(String[] args)\n    {\n        Map map = new Map();\n        map.setVisible(true);\n       \n\n    }\n    \n}\n",
      "Panel.java": "import javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\npublic class Panel extends JPanel implements Runnable {\n    final int originalTilesize = 16;\n    final int scale = 3;\n    public final int tileSize = scale * originalTilesize;\n    public final int maxCol = 16;\n    public final int maxRow = 16;\n    public final int screenwidth = tileSize * maxCol;\n    public final int screenheight = tileSize * maxRow;\n    double FPS = 60;\n\n    // World map setting\n    public final int maxWorldMapCol = 50;\n    public final int maxWorldMapRow = 50;\n    public final int worldwidth = tileSize * maxWorldMapCol;\n    public final int worldHeight = tileSize * maxWorldMapRow;\n\n    TileManager tileM = new TileManager(this);\n\n    KeyHandler keyH = new KeyHandler(this);\n    Thread gameThread;\n\n    Player player;\n    public UI ui = new UI(this);\n    public EventHandler eHandler = new EventHandler(this);\n\n    Entity obj[] = new Entity[10];\n    Entity npc[] = new Entity[10];\n    Entity zombie[] = new Entity[20];\n    Entity tankZombie[] = new Entity[20];\n    Entity aticiZombie[] = new Entity[20];\n    Entity surungeZombie[] = new Entity[20];\n\n\n    ArrayList<Entity> entityList = new ArrayList<>();\n    public AssetSetter aSetter = new AssetSetter(this);\n\n    CollisionChecker cChecker;\n    public final int titleState = 0;\n    public int gameState;\n    public final int gamePlay = 1;\n    public final int gamePause = 2;\n    public final int gameMode = 3;\n\n    public Panel() {\n        player = new Player(keyH, this);\n        this.setPreferredSize(new Dimension(screenwidth, screenheight));\n        this.setBackground(Color.BLACK);\n        this.setDoubleBuffered(true);\n        this.addKeyListener(keyH);\n        this.setFocusable(true);\n        this.requestFocusInWindow();\n        cChecker = new CollisionChecker(this);\n\n    }\n\n    public void setUpGame() {\n        aSetter.setObject();\n        aSetter.setNpc();\n        aSetter.setZombie();\n        aSetter.setAticiZombie();\n        aSetter.setSurungenZombie();\n        aSetter.setTankZombie();\n        gameState = titleState;\n    }\n\n    public void run() {\n        double drawInterval = 1000 / FPS;\n        double nextDrawTime = System.currentTimeMillis() + drawInterval;\n        while (gameThread != null) {\n\n            update();\n            repaint();\n\n            try {\n                double remainingTime = nextDrawTime - System.currentTimeMillis();\n\n                if (remainingTime < 0) {\n                    remainingTime = 0;\n                }\n                Thread.sleep((long) remainingTime);\n                nextDrawTime = nextDrawTime + drawInterval;\n            } catch (InterruptedException e) {\n\n                e.printStackTrace();\n            }\n\n        }\n\n    }\n\n    public void startGameThread() {\n        gameThread = new Thread(this);\n        gameThread.start();\n    }\n\n    public void update() {\n        if (gameState == gamePlay) {\n            // Player\n            player.update();\n            for (int i = 0; i < zombie.length; i++) {\n                if (zombie[i] != null && zombie[i].isAlive()) {\n                    for (int j = 0; j < player.bullets.size(); j++) {\n                        Bullet bullet = player.bullets.get(j);\n                        // Merminin zombi ile çarpışıp çarpmadığını kontrol et\n                        if (bullet.isAlive && bullet.worldx >= zombie[i].worldx && bullet.worldx <= zombie[i].worldx + 32 &&\n                            bullet.worldy >= zombie[i].worldy && bullet.worldy <= zombie[i].worldy + 32) {\n                            // Mermi zombi ile çarpıştı\n                            zombie[i].hit(bullet.damage); // Zombiye hasar ver\n                            bullet.isAlive = false; // Mermiyi öldür\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < zombie.length; i++) {\n                if (zombie[i] != null) {\n                    zombie[i].update();\n                }\n            }\n    \n            // Diğer NPC ve zombi türlerinin güncellenmesi\n            for (int i = 0; i < npc.length; i++) {\n                if (npc[i] != null) {\n                    npc[i].update();\n                }\n            }\n            for (int i = 0; i < tankZombie.length; i++) {\n                if (tankZombie[i] != null) {\n                    tankZombie[i].update();\n                }\n            }\n            for (int i = 0; i < aticiZombie.length; i++) {\n                if (aticiZombie[i] != null) {\n                    aticiZombie[i].update();\n                }\n            }\n            for (int i = 0; i < surungeZombie.length; i++) {\n                if (surungeZombie[i] != null) {\n                    surungeZombie[i].update();\n                }\n            }\n            for (int i = 0; i < zombie.length; i++) {\n                if (zombie[i] != null && zombie[i].isAlive()) {\n                    // Oyuncu ile zombi arasındaki mesafeyi kontrol et\n                    if (Math.abs(zombie[i].worldx - player.worldx) < 50 && Math.abs(zombie[i].worldy - player.worldy) < 50) {\n                       ((Zombie) zombie[i]).attack(player); // Zombi oyuncuya saldır\n                    }\n                }\n            }\n            // Npc\n            for (int i = 0; i < npc.length; i++) {\n                if (npc[i] != null) {\n                    npc[i].update();\n                }\n            }\n            for (int i = 0; i < zombie.length; i++) {\n                if (zombie[i] != null) {\n                    zombie[i].update();\n                }\n            }\n            for (int i = 0; i < tankZombie.length; i++) {\n                if (tankZombie[i] != null) {\n                    tankZombie[i].update();\n                }\n            }\n            for (int i = 0; i < aticiZombie.length; i++) {\n                if (aticiZombie[i] != null) {\n                    aticiZombie[i].update();\n                }\n            }\n            for (int i = 0; i < surungeZombie.length; i++) {\n                if (surungeZombie[i] != null) {\n                    surungeZombie[i].update();\n                }\n            }\n\n        }\n        if (gameState == gamePause) {\n\n        }\n\n    }\n\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2 = (Graphics2D) g;\n        long drawStart = 0;\n        if (keyH.checkDrawTime) {\n            drawStart = System.currentTimeMillis();\n        }\n        if (gameState == titleState) {\n            ui.draw(g2);\n\n        } else {\n\n            tileM.draw(g2);\n            entityList.add(player);\n            for (int i = 0; i < obj.length; i++) {\n                if (obj[i] != null)\n                    entityList.add(obj[i]);\n            }\n            for (int i = 0; i < zombie.length; i++) {\n                if (zombie[i] != null)\n                    entityList.add(zombie[i]);\n            }\n            for (int i = 0; i < zombie.length; i++) {\n                if (zombie[i] != null)\n                    entityList.add(tankZombie[i]);\n            }\n            for (int i = 0; i < zombie.length; i++) {\n                if (zombie[i] != null)\n                    entityList.add(surungeZombie[i]);\n            }\n            for (int i = 0; i < zombie.length; i++) {\n                if (zombie[i] != null)\n                    entityList.add(aticiZombie[i]);\n            }\n            for (int i = 0; i < npc.length; i++) {\n                if (npc[i] != null)\n                    entityList.add(npc[i]);\n            }\n            Collections.sort(entityList, new Comparator<Entity>() {\n                public int compare(Entity o1, Entity o2) {\n                    int res = Integer.compare(o1.worldy, o2.worldy);\n                    return res;\n\n                }\n            });\n            for (int i = 0; i < entityList.size(); i++) {\n                entityList.get(i).draw(g2);\n            }\n            entityList.clear();\n            ui.draw(g2);\n        }\n\n        if (keyH.checkDrawTime) {\n            long drawEnd = System.currentTimeMillis();\n\n            long passed = drawEnd - drawStart;\n\n            int fps = 1000 / (int) passed;\n            g2.setColor(Color.white);\n\n            g2.drawString(\"FPS:\" + fps, 10, 400);\n        }\n\n        g2.dispose();\n\n    }\n    public int getMouseX() {\n        return MouseInfo.getPointerInfo().getLocation().x - this.getLocationOnScreen().x; // Fare X konumu\n    }\n\n    public int getMouseY() {\n        return MouseInfo.getPointerInfo().getLocation().y - this.getLocationOnScreen().y; // Fare Y konumu\n    }\n\n}\n\n       \n\n        \n   \n",
      "Hearth.java": "import java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class Hearth extends Entity {\n  \n\n    public Hearth(Panel gp) {\n        super(gp);\n       \n        name = \"Hearth\";\n        image = setUp(\"Kalp.png\");\n        image2 = setUp(\"YarımKalp.png\");\n        image3 = setUp(\"BosKalp.png\");\n       \n    }\n\n}\n",
      "UtilityTool.java": "import java.awt.*;\nimport java.awt.image.*;\npublic class UtilityTool {\n    public BufferedImage scaleImage(BufferedImage original, int width, int height )\n    {\n        BufferedImage scaledImage = new BufferedImage(width, height, original.getType());\n        Graphics2D g2 = scaledImage.createGraphics();\n        g2.drawImage(original, 0, 0, width, height,null);\n        g2.dispose();\n        return scaledImage;\n    }\n}\n",
      "UI.java": "import java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class UI {\n    Panel gp;\n    Font ariel_40;\n    Graphics2D g2;\n    // BufferedImage image;\n    BufferedImage fullHeart, halfHeart, emptyHeart;\n    public boolean messageOn = false;\n    public String msg = \"\";\n    int messageCounter = 0;\n    double playTime = 0;\n    public int commandNum = 0;\n\n    public UI(Panel gp) {\n        this.gp = gp;\n        // image = new RocketLauncher(gp).image;\n        ariel_40 = new Font(\"Arial\", Font.PLAIN, 40);\n        Entity heart = new Hearth(gp);\n        fullHeart = heart.image;\n        halfHeart = heart.image2;\n        emptyHeart = heart.image3;\n    }\n\n    public void showMessage(String msg) {\n        this.msg = msg;\n        messageOn = true;\n\n    }\n\n    public void draw(Graphics2D g2) {\n       \n    g2.setFont(ariel_40);\n    g2.setColor(Color.white);\n    if (gp.gameState == gp.gamePlay) {\n        drawPlayerLife();\n        if (messageOn) {\n            g2.drawString(msg, gp.screenwidth / 2, gp.screenheight / 2);\n            messageCounter++;\n            if (messageCounter > 100) { \n                messageOn = false;\n                messageCounter = 0;\n            }\n        }\n    }\n        this.g2 = g2;\n        g2.setFont(ariel_40);\n        g2.setColor(Color.white);\n        if (gp.gameState == gp.gamePlay) {\n            drawPlayerLife();\n        }\n        if (gp.gameState == gp.gamePause) {\n            drawPauseScreen();\n        }\n        if (gp.gameState == gp.titleState) {\n            drawTitleScreen();\n        }\n\n    }\n\n    public void drawPlayerLife() {\n        \n        int x = gp.tileSize / 2;\n        int y = gp.tileSize / 2;\n        int i = 0;\n        while (i < gp.player.maxLife / 2) {\n            g2.drawImage(emptyHeart, x, y, null);\n            i++;\n            x = x + gp.tileSize;\n        }\n        // Reset\n        x = gp.tileSize / 2;\n        y = gp.tileSize / 2;\n        i = 0;\n        while (i < gp.player.life ) {\n            g2.drawImage(halfHeart, x, y, null);\n            i++;\n\n            if (i < gp.player.life) {\n                g2.drawImage(fullHeart, x, y, null);\n            }\n            i++;\n            x = x + gp.tileSize;\n        }\n    }\n\n    public void drawPauseScreen() {\n        String text = \"PAUSED\";\n        int x, y;\n        int lenght = getXForCentered(text);\n        x = gp.screenwidth / 2 - lenght / 2;\n        y = gp.screenheight / 2;\n        g2.drawString(text, x, y);\n\n    }\n\n    public int getXForCentered(String text) {\n        return (int) g2.getFontMetrics().getStringBounds(text, g2).getWidth();\n    }\n\n    public void drawTitleScreen() {\n        g2.setColor(new Color(70, 120, 80));\n        g2.fillRect(0, 0, gp.screenwidth, gp.screenheight);\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD, 48F));\n        String text = \"ZOMBIE SHOOTER\";\n        int x = gp.tileSize * 3;\n        int y = gp.tileSize * 3;\n\n        // title\n        g2.setColor(Color.gray);\n        g2.drawString(text, x + 5, y + 5);\n        g2.setColor(Color.WHITE);\n        g2.drawString(text, x, y);\n        // menu\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD, 24F));\n        text = \"New Game\";\n        x = gp.tileSize * 3;\n        y = y + gp.tileSize * 4;\n        g2.drawString(text, x, y);\n        if (commandNum == 0) {\n            g2.drawString(\">\", x - gp.tileSize, y);\n        }\n\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD, 24F));\n        text = \"Load Game\";\n        x = gp.tileSize * 3;\n        y = y + gp.tileSize * 1;\n        g2.drawString(text, x, y);\n        if (commandNum == 1) {\n            g2.drawString(\">\", x - gp.tileSize, y);\n        }\n\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD, 24F));\n        text = \"Fast Mode\";\n        x = gp.tileSize * 3;\n        y = y + gp.tileSize * 1;\n        g2.drawString(text, x, y);\n        if (commandNum == 2) {\n            g2.drawString(\">\", x - gp.tileSize, y);\n        }\n\n    }\n\n}\n",
      "AssetSetter.java": "public class AssetSetter {\n    Panel gp;\n\n    public AssetSetter(Panel gp) {\n        this.gp = gp;\n    }\n\n    public void setObject() {\n\n    }\n    public void setNpc()\n    {\n        gp.npc[0] = new Cat(gp);\n        gp.npc[0].worldx = gp.tileSize * 21;\n        gp.npc[0].worldy = gp.tileSize * 21;\n    }\n    public void setZombie() {\n        int numberOfZombies = 5; // Oluşturulacak zombi sayısı\n        for (int i = 0; i < numberOfZombies; i++) {\n            Zombie zombie = new Zombie(gp);\n            \n            // Rastgele bir konum belirle\n            int randomCol = (int) (Math.random() * (gp.maxWorldMapCol - 1));\n            int randomRow = (int) (Math.random() * (gp.maxWorldMapRow - 1));\n            \n            // Zombiyi rastgele konuma yerleştir\n            zombie.worldx = randomCol * gp.tileSize;\n            zombie.worldy = randomRow * gp.tileSize;\n    \n            // Zombiyi npc dizisine ekle\n            gp.zombie[i] = zombie;\n            \n        }\n    }\n    public void setTankZombie() {\n        int numberOfZombies = 5; // Oluşturulacak zombi sayısı\n        for (int i = 0; i < numberOfZombies; i++) {\n            TankZombie zombie = new TankZombie(gp);\n            \n            // Rastgele bir konum belirle\n            int randomCol = (int) (Math.random() * (gp.maxWorldMapCol - 1));\n            int randomRow = (int) (Math.random() * (gp.maxWorldMapRow - 1));\n            \n            // Zombiyi rastgele konuma yerleştir\n            zombie.worldx = randomCol * gp.tileSize;\n            zombie.worldy = randomRow * gp.tileSize;\n    \n            // Zombiyi npc dizisine ekle\n            gp.tankZombie[i] = zombie;\n            \n        }\n    }\n    public void setSurungenZombie() {\n        int numberOfZombies = 5; // Oluşturulacak zombi sayısı\n        for (int i = 0; i < numberOfZombies; i++) {\n            SurungenZombie zombie = new SurungenZombie(gp);\n            \n            // Rastgele bir konum belirle\n            int randomCol = (int) (Math.random() * (gp.maxWorldMapCol - 1));\n            int randomRow = (int) (Math.random() * (gp.maxWorldMapRow - 1));\n            \n            // Zombiyi rastgele konuma yerleştir\n            zombie.worldx = randomCol * gp.tileSize;\n            zombie.worldy = randomRow * gp.tileSize;\n    \n            // Zombiyi npc dizisine ekle\n            gp.surungeZombie[i] = zombie;\n            \n        }\n    }\n    public void setAticiZombie() {\n        int numberOfZombies = 5; // Oluşturulacak zombi sayısı\n        for (int i = 0; i < numberOfZombies; i++) {\n            AticiZombie zombie = new AticiZombie(gp);\n            \n            // Rastgele bir konum belirle\n            int randomCol = (int) (Math.random() * (gp.maxWorldMapCol - 1));\n            int randomRow = (int) (Math.random() * (gp.maxWorldMapRow - 1));\n            \n            // Zombiyi rastgele konuma yerleştir\n            zombie.worldx = randomCol * gp.tileSize;\n            zombie.worldy = randomRow * gp.tileSize;\n    \n            // Zombiyi npc dizisine ekle\n            gp.aticiZombie[i] = zombie;\n            \n        }\n    }\n    \n\n}\n",
      "KeyHandler.java": "import java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.security.Key;\n\nimport org.w3c.dom.events.MouseEvent;\n\npublic class KeyHandler implements KeyListener {\n    public boolean uppressed, downpressed, rightpressed, leftpressed;\n    boolean checkDrawTime = false;\n    public Panel gp;\n\n    public KeyHandler(Panel gp) {\n        this.gp = gp;\n         \n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int code = e.getKeyCode();\n        if (gp.gameState == gp.titleState) {\n            if (code == KeyEvent.VK_W) {\n                if (gp.ui.commandNum != 0) {\n                    gp.ui.commandNum--;\n                }\n            }\n            if (code == KeyEvent.VK_S) {\n                if (gp.ui.commandNum != 2) {\n                    gp.ui.commandNum++;\n                }\n            }\n            if(code == KeyEvent.VK_ENTER)\n            {\n                if(gp.ui.commandNum == 0)\n                {\n                    gp.gameState = gp.gamePlay;\n                }\n                if(gp.ui.commandNum == 1)\n                {\n                    \n                }\n                if(gp.ui.commandNum == 2)\n                {\n                    gp.gameState = gp.gamePlay;\n                }\n            }\n\n        }\n        if (code == KeyEvent.VK_W) {\n            uppressed = true;\n        }\n        if (code == KeyEvent.VK_S) {\n            downpressed = true;\n        }\n        if (code == KeyEvent.VK_D) {\n            rightpressed = true;\n        }\n        if (code == KeyEvent.VK_A) {\n            leftpressed = true;\n        }\n        if (code == KeyEvent.VK_P) {\n            if (gp.gameState == gp.gamePause) {\n                gp.gameState = gp.gamePlay;\n            } else if (gp.gameState == gp.gamePlay) {\n                gp.gameState = gp.gamePause;\n            }\n        }\n        if (code == KeyEvent.VK_T)\n\n        {\n            if (checkDrawTime)\n                checkDrawTime = false;\n            else\n                checkDrawTime = true;\n        }\n       \n            // Diğer tuş kontrolleri...\n            if (e.getKeyCode() == KeyEvent.VK_S) { // S tuşuna basıldığında\n                FileIO.saveGame(gp);\n            }\n            if (e.getKeyCode() == KeyEvent.VK_L) { // L tuşuna basıldığında\n                FileIO.loadGame(gp);\n            }\n        \n\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int code = e.getKeyCode();\n        if (code == KeyEvent.VK_W) {\n            uppressed = false;\n        }\n        if (code == KeyEvent.VK_S) {\n            downpressed = false;\n        }\n        if (code == KeyEvent.VK_D) {\n            rightpressed = false;\n        }\n        if (code == KeyEvent.VK_A) {\n            leftpressed = false;\n        }\n    }\n\n}\n",
      "Cat.java": "import java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.Random;\n\nimport javax.imageio.ImageIO;\n\nclass Cat extends Entity {\n    public Cat(Panel gp) {\n        super(gp);\n        direction = \"down\";\n        speed = 3;\n        getImage();\n    }\n\n    public void getImage() {\n\n        up = setUp(\"Cat.png\");\n        down = setUp(\"Cat.png\");\n        right = setUp(\"Cat.png\");\n        left = setUp(\"Cat.png\");\n        up1 = setUp(\"Cat.png\");\n        down1 = setUp(\"Cat.png\");\n        right1 = setUp(\"Cat.png\");\n        left1 = setUp(\"Cat.png\");\n\n    }\n\n    public void setAction() {\n        actionLocker++;\n\n        if (actionLocker == 90) {\n            Random random = new Random();\n            int i = random.nextInt(125) + 1;\n            if (i < 25)\n                direction = \"up\";\n            else if (i < 50)\n                direction = \"down\";\n            else if (i < 75)\n                direction = \"right\";\n            else if (i < 100)\n                direction = \"left\";\n            actionLocker = 0;\n        }\n\n    }\n\n}",
      "TankZombie.java": "public class TankZombie extends Entity {\n    public TankZombie(Panel gp) {\n        super(gp);\n        speed = 2;\n        name = \"TankZombie\";\n        maxLife = 2;\n        life = maxLife;\n        solidArea.x = 3;\n        solidArea.y = 10;\n        solidArea.width = 42;\n        solidArea.height = 32;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        getImage();\n    }\n\n    public void getImage() {\n        up = setUp(\"TankZombie.png\");\n        up1 = setUp(\"TankZombie.png\");\n        down = setUp(\"TankZombie.png\");\n        down1 = setUp(\"TankZombie.png\");\n        right = setUp(\"TankZombie.png\");\n        right1 = setUp(\"TankZombie.png\");\n        left = setUp(\"TankZombie.png\");\n        left1 = setUp(\"TankZombie.png\");\n\n    }\n    public void setAction() {\n        // Oyuncunun konumunu al\n        int playerX = gp.player.worldx;\n        int playerY = gp.player.worldy;\n    \n        // Zombinin oyuncuya olan konumunu hesapla\n        int deltaX = playerX - worldx;\n        int deltaY = playerY - worldy;\n    \n        // Oyuncuya en yakın yönü belirle\n        if (Math.abs(deltaX) > Math.abs(deltaY)) {\n            // X ekseninde daha fazla mesafe var\n            if (deltaX > 0) {\n                direction = \"right\"; // Oyuncu sağda\n            } else {\n                direction = \"left\"; // Oyuncu solda\n            }\n        } else {\n            // Y ekseninde daha fazla mesafe var\n            if (deltaY > 0) {\n                direction = \"down\"; // Oyuncu aşağıda\n            } else {\n                direction = \"up\"; // Oyuncu yukarıda\n            }\n        }\n    }\n\n}\n",
      "AticiZombie.java": "public class AticiZombie extends Entity {\n    public AticiZombie(Panel gp) {\n        super(gp);\n        speed = 2;\n        name = \"AticiZombie\";\n        maxLife = 2;\n        life = maxLife;\n        solidArea.x = 3;\n        solidArea.y = 10;\n        solidArea.width = 42;\n        solidArea.height = 32;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        getImage();\n    }\n\n    public void getImage() {\n        up = setUp(\"AticiZombie.png\");\n        up1 = setUp(\"AticiZombie.png\");\n        down = setUp(\"AticiZombie.png\");\n        down1 = setUp(\"AticiZombie.png\");\n        right = setUp(\"AticiZombie.png\");\n        right1 = setUp(\"AticiZombie.png\");\n        left = setUp(\"AticiZombie.png\");\n        left1 = setUp(\"AticiZombie.png\");\n\n    }\n    public void setAction() {\n        // Oyuncunun konumunu al\n        int playerX = gp.player.worldx;\n        int playerY = gp.player.worldy;\n    \n        // Zombinin oyuncuya olan konumunu hesapla\n        int deltaX = playerX - worldx;\n        int deltaY = playerY - worldy;\n    \n        // Oyuncuya en yakın yönü belirle\n        if (Math.abs(deltaX) > Math.abs(deltaY)) {\n            // X ekseninde daha fazla mesafe var\n            if (deltaX > 0) {\n                direction = \"right\"; // Oyuncu sağda\n            } else {\n                direction = \"left\"; // Oyuncu solda\n            }\n        } else {\n            // Y ekseninde daha fazla mesafe var\n            if (deltaY > 0) {\n                direction = \"down\"; // Oyuncu aşağıda\n            } else {\n                direction = \"up\"; // Oyuncu yukarıda\n            }\n        }\n    }\n\n}\n",
      "CollisionChecker.java": "public class CollisionChecker {\n    Panel gp;\n\n    public CollisionChecker(Panel gp) {\n        this.gp = gp;\n    }\n\n    public void checkTile(Entity entity) {\n        int entityLeftWorldX = entity.worldx - entity.solidArea.x;\n        int entityRigthWorldX = entity.worldx + entity.solidArea.x;\n        int entityUpWorldY = entity.worldy - entity.solidArea.y;\n        int entityBottomWorldY = entity.worldy + entity.solidArea.y;\n\n        int entityLeftCol = entityLeftWorldX / gp.tileSize;\n        int entityRightCol = entityRigthWorldX / gp.tileSize;\n        int entityUpRow = entityUpWorldY / gp.tileSize;\n        int entityBottomRow = entityBottomWorldY / gp.tileSize;\n        int tileNum1, tileNum2;\n        if (entity.direction.equals(\"up\")) {\n            entityUpRow = (entityUpWorldY - entity.speed) / gp.tileSize;\n            tileNum1 = gp.tileM.tileNumber[entityLeftCol][entityUpRow];\n            tileNum2 = gp.tileM.tileNumber[entityRightCol][entityUpRow];\n            if (gp.tileM.tile[tileNum1].collision || gp.tileM.tile[tileNum2].collision) {\n                entity.collisionOn = true;\n            }\n        } else if (entity.direction.equals(\"down\")) {\n            entityBottomRow = (entityUpWorldY + entity.speed) / gp.tileSize;\n            tileNum1 = gp.tileM.tileNumber[entityLeftCol][entityBottomRow];\n            tileNum2 = gp.tileM.tileNumber[entityRightCol][entityBottomRow];\n            if (gp.tileM.tile[tileNum1].collision || gp.tileM.tile[tileNum2].collision) {\n                entity.collisionOn = true;\n            }\n        } else if (entity.direction.equals(\"right\")) {\n            entityRightCol = (entityRigthWorldX + entity.speed) / gp.tileSize;\n            tileNum1 = gp.tileM.tileNumber[entityRightCol][entityUpRow];\n            tileNum2 = gp.tileM.tileNumber[entityRightCol][entityBottomRow];\n            if (gp.tileM.tile[tileNum1].collision || gp.tileM.tile[tileNum2].collision) {\n                entity.collisionOn = true;\n            }\n        } else if (entity.direction.equals(\"left\")) {\n            entityLeftCol = (entityLeftWorldX - entity.speed) / gp.tileSize;\n            tileNum1 = gp.tileM.tileNumber[entityLeftCol][entityUpRow];\n            tileNum2 = gp.tileM.tileNumber[entityLeftCol][entityBottomRow];\n            if (gp.tileM.tile[tileNum1].collision || gp.tileM.tile[tileNum2].collision) {\n                entity.collisionOn = true;\n            }\n        }\n\n    }\n\n    public int checkObject(Entity entity, boolean player) {\n        int index = 999;\n\n        for (int i = 0; i < gp.obj.length; i++) {\n            if (gp.obj[i] != null) {\n                entity.solidArea.x = entity.worldx + entity.solidArea.x;\n                entity.solidArea.y = entity.worldy + entity.solidArea.y;\n\n                gp.obj[i].solidArea.x = gp.obj[i].worldx + gp.obj[i].solidArea.x;\n                gp.obj[i].solidArea.y = gp.obj[i].worldy + gp.obj[i].solidArea.y;\n\n                if (entity.direction.equals(\"up\")) {\n                    entity.solidArea.y -= entity.speed;\n                    if (entity.solidArea.intersects(gp.obj[i].solidArea)) {\n                        if (gp.obj[i].collision) {\n                            entity.collisionOn = true;\n                        }\n                        if (player) {\n                            index = i;\n                        }\n                    }\n\n                }\n                if (entity.direction.equals(\"down\")) {\n                    entity.solidArea.y += entity.speed;\n                    if (entity.solidArea.intersects(gp.obj[i].solidArea)) {\n                        if (gp.obj[i].collision) {\n                            entity.collisionOn = true;\n                        }\n                        if (player) {\n                            index = i;\n                        }\n                    }\n                }\n                if (entity.direction.equals(\"right\")) {\n                    entity.solidArea.x += entity.speed;\n                    if (entity.solidArea.intersects(gp.obj[i].solidArea)) {\n                        if (gp.obj[i].collision) {\n                            entity.collisionOn = true;\n                        }\n                        if (player) {\n                            index = i;\n                        }\n                    }\n                }\n                if (entity.direction.equals(\"left\")) {\n                    entity.solidArea.x -= entity.speed;\n                    if (entity.solidArea.intersects(gp.obj[i].solidArea)) {\n                        if (gp.obj[i].collision) {\n                            entity.collisionOn = true;\n                        }\n                        if (player) {\n                            index = i;\n                        }\n                    }\n                }\n                entity.solidArea.x = entity.solidAreaDefaultX;\n                entity.solidArea.y = entity.solidAreaDefaultY;\n                gp.obj[i].solidArea.x = gp.obj[i].solidAreaDefaultX;\n                gp.obj[i].solidArea.y = gp.obj[i].solidAreaDefaultY;\n\n            }\n        }\n\n        return index;\n    }\n\n    public int entityChecker(Entity entity, Entity[] target) {\n        int index = 999;\n\n        for (int i = 0; i < target.length; i++) {\n            if (target[i] != null) {\n                entity.solidArea.x = entity.worldx + entity.solidArea.x;\n                entity.solidArea.y = entity.worldy + entity.solidArea.y;\n\n                target[i].solidArea.x = target[i].worldx + target[i].solidArea.x;\n                target[i].solidArea.y = target[i].worldy + target[i].solidArea.y;\n\n                if (entity.direction.equals(\"up\")) {\n                    entity.solidArea.y -= entity.speed;\n                    if (entity.solidArea.intersects(target[i].solidArea)) {\n\n                        entity.collisionOn = true;\n\n                        index = i;\n\n                    }\n\n                }\n                if (entity.direction.equals(\"down\")) {\n                    if (entity.solidArea.intersects(target[i].solidArea)) {\n                        entity.solidArea.y += entity.speed;\n\n                        entity.collisionOn = true;\n\n                        index = i;\n                    }\n                }\n                if (entity.direction.equals(\"right\")) {\n                    if (entity.solidArea.intersects(target[i].solidArea)) {\n                        entity.solidArea.x += entity.speed;\n\n                        entity.collisionOn = true;\n\n                        index = i;\n                    }\n                }\n                if (entity.direction.equals(\"left\")) {\n                    if (entity.solidArea.intersects(target[i].solidArea)) {\n                        entity.solidArea.x -= entity.speed;\n\n                        entity.collisionOn = true;\n\n                        index = i;\n                    }\n\n                }\n                entity.solidArea.x = entity.solidAreaDefaultX;\n                entity.solidArea.y = entity.solidAreaDefaultY;\n                target[i].solidArea.x = target[i].solidAreaDefaultX;\n                target[i].solidArea.y = target[i].solidAreaDefaultY;\n\n            }\n        }\n\n        return index;\n    }\n\n    public void checkPlayer(Entity entity) {\n\n        entity.solidArea.x = entity.worldx + entity.solidArea.x;\n        entity.solidArea.y = entity.worldy + entity.solidArea.y;\n\n        gp.player.solidArea.x = gp.player.worldx + gp.player.solidArea.x;\n        gp.player.solidArea.y = gp.player.worldy + gp.player.solidArea.y;\n\n        if (entity.direction.equals(\"up\")) {\n            entity.solidArea.y -= entity.speed;\n            if (entity.solidArea.intersects(gp.player.solidArea)) {\n\n                entity.collisionOn = true;\n\n            }\n\n        }\n        if (entity.direction.equals(\"down\")) {\n            if (entity.solidArea.intersects(gp.player.solidArea)) {\n                entity.solidArea.y += entity.speed;\n\n                entity.collisionOn = true;\n\n            }\n        }\n        if (entity.direction.equals(\"right\")) {\n            if (entity.solidArea.intersects(gp.player.solidArea)) {\n                entity.solidArea.x += entity.speed;\n\n                entity.collisionOn = true;\n\n            }\n        }\n        if (entity.direction.equals(\"left\")) {\n            if (entity.solidArea.intersects(gp.player.solidArea)) {\n                entity.solidArea.x -= entity.speed;\n\n                entity.collisionOn = true;\n\n            }\n\n        }\n        entity.solidArea.x = entity.solidAreaDefaultX;\n        entity.solidArea.y = entity.solidAreaDefaultY;\n        gp.player.solidArea.x = gp.player.solidAreaDefaultX;\n        gp.player.solidArea.y = gp.player.solidAreaDefaultY;\n\n    }\n}\n",
      "RocketLauncher.java": "import java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class RocketLauncher extends Entity {\n    \n    \n    public RocketLauncher(Panel gp)\n    {\n        super(gp);\n        \n        collision = true;\n        name = \"Rocket\";\n        down = setUp(\"rocket_launcher.png\"); \n        \n    }\n    \n\n}\n",
      "TileManager.java": "import java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\nimport javax.imageio.*;\n\npublic class TileManager {\n  Panel panel;\n  Tile[] tile;\n  int tileNumber[][];\n\n  public TileManager(Panel panel) {\n    this.panel = panel;\n    tile = new Tile[15];\n    tileNumber = new int[panel.maxWorldMapCol][panel.maxWorldMapRow];\n    loadMap(\"worldMap1.txt\");\n    getTileImage();\n  }\n\n  public void getTileImage() {\n    try {\n     \n      setUp(0, false, \"arazi.png\");\n     \n      setUp(1, true, \"tree.png\");\n    }  catch (NullPointerException e) {\n      e.getStackTrace();\n    }\n\n  }\n\n  public void draw(Graphics2D g2) {\n\n    int worldRow = 0;\n    int worldCol = 0;\n\n    while (worldRow < panel.maxWorldMapRow && worldCol < panel.maxWorldMapCol) {\n      int tileNum = tileNumber[worldCol][worldRow];\n\n      int worldX = worldCol * panel.tileSize;\n      int worldY = worldRow * panel.tileSize;\n      int screenX = worldX - panel.player.worldx + panel.player.screenX;\n      int screenY = worldY - panel.player.worldy + panel.player.screenY;\n\n      if (worldX < panel.player.screenX + panel.player.worldx + panel.tileSize\n          && worldX > panel.player.worldx - panel.player.screenX - panel.tileSize\n          && worldY < panel.player.screenY + panel.player.worldy + panel.tileSize\n          && worldY > panel.player.worldy - panel.player.screenY - panel.tileSize) {\n        g2.drawImage(tile[tileNum].image, screenX, screenY, panel.tileSize, panel.tileSize, null);\n      }\n      worldCol++;\n\n      if (worldCol == panel.maxWorldMapCol) {\n        worldCol = 0;\n\n        worldRow++;\n\n      }\n    }\n  }\n\n  public void setUp(int index, boolean collison, String pathName)\n\n  {\n\n    try {\n      UtilityTool tool = new UtilityTool();\n      tile[index] = new Tile();\n      tile[index].image = ImageIO.read(getClass().getResourceAsStream(pathName));\n      tile[index].image = tool.scaleImage(tile[index].image, panel.tileSize, panel.tileSize);\n      tile[index].collision = collison;\n    } catch (IOException e) {\n\n      e.printStackTrace();\n    }\n\n  }\n\n  public void loadMap(String file) {\n    InputStream is = getClass().getResourceAsStream(file);\n    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n\n    for (int i = 0; i < panel.maxWorldMapRow; i++) {\n      try {\n        String line = br.readLine();\n        if (line == null) {\n          break;\n        }\n        String arr[] = line.split(\" \");\n\n        for (int j = 0; j < panel.maxWorldMapCol; j++) {\n          int num = Integer.parseInt(arr[j]);\n          tileNumber[j][i] = num;\n        }\n      } catch (IOException e) {\n\n        e.printStackTrace();\n      }\n    }\n  }\n}\n",
      "Player.java": "import java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JComponent;\n\npublic class Player extends Entity implements Serializable{\n    \n    KeyHandler keyH;\n public int hasRocketLauncher;\n private boolean isShooting = false;\n\n    public final int screenX;\n    public final int screenY;\n\n    ArrayList<Bullet> bullets = new ArrayList<>();\n\n    public Player(KeyHandler keyH, Panel gp) {\n        super(gp);\n        this.keyH = keyH;\n        \n        screenX = gp.screenwidth / 2 - gp.tileSize / 2;\n        screenY = gp.screenheight / 2 - gp.tileSize / 2;\n        setDefaultValues();\n        getPlayerImage();\n         \n        solidArea = new Rectangle();\n        solidArea.x = 8;\n        solidArea.y = 16;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        solidArea.width = 32;\n        solidArea.height = 32;\n\n        gp.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                isShooting = true; // Fare basıldığında ateş etmeye başla\n            }\n        \n            @Override\n            public void mouseReleased(MouseEvent e) {\n                isShooting = false; // Fare bırakıldığında ateşi durdur\n            }\n        });\n    }\n\n    public void setDefaultValues() {\n        worldx = gp.tileSize * 23;\n        worldy = gp.tileSize * 25;\n        speed = 15;\n        direction = \"up\";\n        maxLife = 6;\n        life = maxLife;\n        damage = 3;\n    }\n\n    public void getPlayerImage() {\n\n        \n            up = setUp(\"up.png\");\n            down = setUp(\"down.png\");\n            right = setUp(\"right.png\");\n            left = setUp(\"left.png\");\n            up1 = setUp(\"up1.png\");\n            down1 = setUp(\"down1.png\");\n            right1 = setUp(\"right1.png\");\n            left1 = setUp(\"left1.png\");\n        \n    }\n    \n\n    public void update() {\n        if (keyH.uppressed == true) {\n            direction = \"up\";\n\n        }\n        if (keyH.downpressed == true) {\n            direction = \"down\";\n\n        }\n        if (keyH.rightpressed == true) {\n            direction = \"right\";\n\n        }\n        if (keyH.leftpressed == true) {\n            direction = \"left\";\n\n        }\n\n        collisionOn = false;\n        gp.cChecker.checkTile(this);\n        int objIndex = gp.cChecker.checkObject(this, true);\n        pickUpObject(objIndex);\n\n        int npcIndex = gp.cChecker.entityChecker(this, gp.npc);\n       interactNPC(npcIndex);\n\n        if (!collisionOn) {\n            if (keyH.uppressed == true) {\n\n                worldy = worldy - speed;\n            }\n            if (keyH.downpressed == true) {\n\n                worldy = worldy + speed;\n            }\n            if (keyH.rightpressed == true) {\n\n                worldx = worldx + speed;\n            }\n            if (keyH.leftpressed == true) {\n\n                worldx = worldx - speed;\n            }\n\n        }\n\n        spriteCounter++;\n        if (spriteCounter > 15) {\n            if (spriteNumber == 1) {\n                spriteNumber = 2;\n            } else if (spriteNumber == 2) {\n                spriteNumber = 1;\n            }\n            spriteCounter = 0;\n        }\n        if (isShooting) {\n            shoot(gp.getMouseX(), gp.getMouseY()); // Fare konumunu kullanarak mermi oluştur\n        }\n\n        // Mermileri güncelle\n        for (int i = 0; i < bullets.size(); i++) {\n            Bullet bullet = bullets.get(i);\n            bullet.update();\n            if (!bullet.isAlive) {\n                bullets.remove(i);\n                i--; // Listeyi güncellerken indeks kaymasını önlemek için\n            }\n        }\n\n    }\n\n    public void pickUpObject(int index) {\n        if (index != 999) {\n            gp.obj[index] = null;\n            hasRocketLauncher++;\n            gp.ui.showMessage(\"merhaba\");\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n\n        BufferedImage image = null;\n        for (Bullet bullet : bullets) {\n            g2.fillRect(bullet.worldx, bullet.worldy, 5, 5); // Mermiyi basit bir dikdörtgen olarak çiz\n        }\n        if (direction.equals(\"up\")) {\n            if (spriteNumber == 1)\n                image = up;\n            else\n                image = up1;\n        }\n        if (direction.equals(\"down\")) {\n            if (spriteNumber == 1)\n                image = down;\n            else\n                image = down1;\n        }\n        if (direction.equals(\"right\")) {\n            if (spriteNumber == 1)\n                image = right;\n            else\n                image = right1;\n        }\n        if (direction.equals(\"left\")) {\n            if (spriteNumber == 1)\n                image = left;\n            else\n                image = left1;\n        }\n       \n        g2.drawImage(image, screenX, screenY, gp.tileSize, gp.tileSize, null);\n        \n\n    }\n    public void interactNPC(int index)\n    {\n        if(index != 999)\n        {\n                    \n        }\n\n    }\n    public void attack(Zombie zombie) {\n        if (zombie.isAlive()) {\n            int damage = 1; // Verilecek hasar\n            zombie.hit(); // Zombiye hasar ver\n            System.out.println(\"Zombiye \" + damage + \" hasar verildi. Kalan yaşam: \" + zombie.life);\n        }\n    }\n    public void shoot(int mouseX, int mouseY) {\n        // Oyuncunun konumunu ve fare konumunu kullanarak açı hesapla\n        double angle = Math.atan2(mouseY - worldy, mouseX - worldx);\n        Bullet bullet = new Bullet(worldx, worldy, angle, 10, 5); // Hız ve hasar ayarları\n        bullets.add(bullet);\n    }\n\n    \n}\n",
      "EventHandler.java": "public class EventHandler {\n    Panel gp;\n\n    public EventHandler(Panel gp) {\n        this.gp = gp;\n    }\n}\n"
    },
    {
      "id": "6897869",
      "Claire.java": "package entity.characters;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport main.GamePanel;\nimport main.MyKeyListener;\nimport main.MyMouseListener;\nimport weapons.Ammunation;\nimport weapons.Rifle;\nimport weapons.Sniper;\nimport weapons.Weapon;\n\npublic class Claire extends MainCharacter {\n\n    Leon leon;\n    double distancetoleon = 40;\n\n    BufferedImage[][][] walkCycle;\n    BufferedImage[][][] walkCycleSniper;\n\n    public boolean isDashActive = true;\n\n    public Weapon[] weapons = new Weapon[2];\n\n    public Claire(GamePanel gamePanel, MyKeyListener input, MyMouseListener mouse) {\n        this.gp = gamePanel;\n        this.input = input;\n        this.mouse = mouse;\n\n        active = false;\n        health = 100;\n\n        input.setClaire(this);\n\n        WIDTH = 200;\n        HEIGHT = 200;\n\n        rawSpeed = 4.5;\n        speed = rawSpeed * 60 / gp.getFPS();\n\n        rawDashSpeed = 24.0;\n        dashSpeed = rawDashSpeed * 60 / gp.getFPS();\n        dashDuration = 200000000;// nanos\n\n        x = (gp.map.mapWidth - WIDTH) / 2;\n        y = (gp.map.mapHeight - HEIGHT) / 2;\n\n        weapons[0] = new Rifle(gp);\n        weapons[0].setCharacter(this);\n        weapons[1] = new Sniper(gp);\n        weapons[0].isActive = true;\n        weapons[1].isActive = true;\n\n        weapon = weapons[0];\n\n        walkCycle = new BufferedImage[8][16][24];\n        walkCycleSniper = new BufferedImage[8][16][24];\n\n        getSprites();\n\n    }\n\n    void getSprites() {\n        try {\n            for (int i = 0; i < 8; i++) {\n                // i yürüme yönü\n                for (int j = 0; j < 16; j++) {\n                    // j baktığı yön\n                    if (!checkDirection(i, j)) {\n                        continue;\n                    }\n                    String path = \"/res/claire/\";\n\n                    for (int k = 1; k < 25; k++) {\n                        String path2 = path + \"walk/\";\n                        String path3 = path + \"walkSniper/\";\n\n                        path2 = decidePathWalkCycle(i, j, path2);\n                        path3 = decidePathWalkCycle(i, j, path3);\n\n                        if (k < 10) {\n                            path2 = path2 + \"000\" + k + \".png\";\n                            path3 = path3 + \"000\" + k + \".png\";\n                        } else {\n                            path2 = path2 + \"00\" + k + \".png\";\n                            path3 = path3 + \"00\" + k + \".png\";\n                        }\n\n                        walkCycle[i][j][k - 1] = ImageIO.read(getClass().getResourceAsStream(path2));\n                        walkCycleSniper[i][j][k - 1] = ImageIO.read(getClass().getResourceAsStream(path3));\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void setLeon(Leon leon) {\n        this.leon = leon;\n    }\n\n    public void update() {\n        if (health <= 0) {\n            return;\n        }\n        if (active) {\n            yonuAyarla();\n            konumuAyarla();\n            if (weapon.reloading) {\n                reload();\n            }\n            if (mouse.shooting && weapon.bulletsInMagazine > 0)\n                shoot();\n        } else {\n            claireYapayZeka();\n        }\n        checkAmmunation();\n    }\n\n    public void draw(Graphics2D g2) {\n        // g2.setColor(Color.pink);\n        // g2.fillRect((int) (x - WIDTH / 2), (int) (y - HEIGHT / 2), WIDTH, HEIGHT);\n        if (active) {\n            g2.setColor(Color.gray);\n            g2.setStroke(new BasicStroke(1));\n            g2.drawLine((int) (x + weapon.relativeweaponx - GamePanel.kamera.x + GamePanel.screenWidth / 2),\n                    (int) (y + weapon.relativeweapony - GamePanel.kamera.y + GamePanel.screenHeight / 2), mouse.mouseX,\n                    mouse.mouseY);\n        }\n\n        int walkdirection2 = walkdirection;\n        if (!checkDirection(walkdirection2, facing)) {\n            walkdirection2 += 4;\n            if (walkdirection2 > 7) {\n                walkdirection2 -= 8;\n            }\n        }\n\n        BufferedImage cizilecek;\n\n        if (weaponIndex == 0) {\n            cizilecek = walkCycle[walkdirection2][facing][walkSpritecounter];\n        } else {\n            cizilecek = walkCycleSniper[walkdirection2][facing][walkSpritecounter];\n        }\n\n        g2.drawImage(cizilecek, (int) (x - GamePanel.kamera.x + (GamePanel.screenWidth / 2) - (WIDTH / 2)),\n                (int) (y - GamePanel.kamera.y + (GamePanel.screenHeight / 2) - HEIGHT / 2), WIDTH, HEIGHT, null);\n    }\n\n    void konumuAyarla() {\n        speedX = 0;\n        speedY = 0;\n\n        if (dash) {\n            switch (walkdirection) {\n                case 4:\n                    speedY = -1;\n                    break;\n                case 0:\n                    speedY = 1;\n                    break;\n                case 6:\n                    speedX = -1;\n                    break;\n                case 2:\n                    speedX = 1;\n                    break;\n            }\n\n            speedX *= dashSpeed;\n            speedY *= dashSpeed;\n\n            if (x + speedX < gp.map.mapWidth && x + speedX > 0 && y + speedY < gp.map.mapHeight && y + speedY > 0) {\n                x += speedX;\n                y += speedY;\n            }\n\n            currentTime = System.nanoTime();\n            dashTimer += currentTime - lastTime;\n            lastTime = currentTime;\n\n            if (dashTimer > dashDuration) {\n                dash = false;\n            }\n\n            return;\n        }\n\n        yonuAyarla();\n\n        if (input.upPressed || input.downPressed || input.leftPressed || input.rightPressed) {\n            if (!isWalking) {\n                lastTime = System.nanoTime();\n                isWalking = true;\n            }\n            // sol üst\n            if (input.upPressed && input.leftPressed && !input.rightPressed) {\n                speedX = -1 / Math.sqrt(2);\n                speedY = -1 / Math.sqrt(2);\n                walkdirection = 5;\n            } // sağ üst\n            else if (input.upPressed && input.rightPressed && !input.leftPressed) {\n                speedX = +1 / Math.sqrt(2);\n                speedY = -1 / Math.sqrt(2);\n                walkdirection = 3;\n            } // sol alt\n            else if (input.downPressed && input.leftPressed && !input.rightPressed) {\n                speedX = -1 / Math.sqrt(2);\n                speedY = +1 / Math.sqrt(2);\n                walkdirection = 7;\n            } // sağ alt\n            else if (input.downPressed && input.rightPressed && !input.leftPressed) {\n                speedX = +1 / Math.sqrt(2);\n                speedY = +1 / Math.sqrt(2);\n                walkdirection = 1;\n            } // üst\n            else if (input.upPressed && !input.downPressed) {\n                speedY = -1;\n                walkdirection = 4;\n            } // alt\n            else if (input.downPressed && !input.upPressed) {\n                speedY = 1;\n                walkdirection = 0;\n            } // sol\n            else if (input.leftPressed && !input.rightPressed) {\n                speedX = -1;\n                walkdirection = 6;\n            } // sağ\n            else if (input.rightPressed && !input.leftPressed) {\n                speedX = 1;\n                walkdirection = 2;\n            }\n\n            speedX *= speed;\n            speedY *= speed;\n\n            if (x + speedX < gp.map.mapWidth && x + speedX > 0 && y + speedY < gp.map.mapHeight && y + speedY > 0) {\n                x += speedX;\n                y += speedY;\n            }\n\n            updateSprites();\n\n        } else {\n            isWalking = false;\n            walkSpritecounter = 10;\n            timeWalked = (1000000000 / walkFPS) * 10 + 100;\n        }\n\n    }\n\n    void claireYapayZeka() {\n        if (leon.isWalking) {\n            if (!isWalking) {\n                lastTime = System.nanoTime();\n                isWalking = true;\n            }\n            updateSprites();\n        } else {\n            isWalking = false;\n            walkSpritecounter = 10;\n            timeWalked = (1000000000 / walkFPS) * 10 + 100;\n        }\n\n        chooseDestination();\n        setFacingDirection();\n        goToDestination();\n    }\n\n    void chooseDestination() {\n        targetx = (mouse.mouseX + GamePanel.kamera.x - GamePanel.screenWidth / 2) - leon.x;\n        targety = (mouse.mouseY + GamePanel.kamera.y - GamePanel.screenHeight / 2) - leon.y;\n\n        double distance = Math.sqrt(targetx * targetx + targety * targety);\n\n        targetx = leon.x - targetx / distance * distancetoleon;\n        targety = leon.y - targety / distance * distancetoleon;\n    }\n\n    void setFacingDirection() {\n        facing = leon.facing - 8;\n        if (facing < 0)\n            facing += 16;\n    }\n\n    public void dash() {\n        if (!isDashActive) {\n            return;\n        }\n\n        dash = true;\n        dashTimer = 0;\n        lastTime = System.nanoTime();\n\n        if (input.upPressed) {\n            walkdirection = 4;\n        } else if (input.downPressed) {\n            walkdirection = 0;\n        } else if (input.rightPressed) {\n            walkdirection = 2;\n        } else if (input.leftPressed) {\n            walkdirection = 6;\n        } else {\n            walkdirection = 2;\n        }\n    }\n\n    @Override\n    public void changeWeapon() {\n        if (weapon.reloading) {\n            reload();\n            return;\n        }\n        if (weaponIndex == 0) {\n            if (weapons[1].isActive) {\n                weaponIndex = 1;\n                weapon = weapons[1];\n                WIDTH = 280;\n                HEIGHT = 280;\n            }\n        } else {\n            weaponIndex = 0;\n            weapon = weapons[0];\n            WIDTH = 200;\n            HEIGHT = 200;\n        }\n    }\n\n    void checkAmmunation() {\n        for (int i = gp.ammunation.size() - 1; i >= 0; i--) {\n            Ammunation a = gp.ammunation.get(i);\n            if (Math.abs(a.x - x) < 45 && Math.abs(a.y - y) < 105) {\n                if (a.type.equals(\"Sniper\")) {\n                    weapons[1].bullets += a.quantity;\n                    a.remove = true;\n                } else if (a.type.equals(\"Rifle\")) {\n                    weapons[0].bullets += a.quantity;\n                    a.remove = true;\n                }\n            }\n        }\n    }\n}\n",
      "Leon.java": "package entity.characters;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport main.GamePanel;\nimport main.MyKeyListener;\nimport main.MyMouseListener;\nimport weapons.Ammunation;\nimport weapons.Gun;\nimport weapons.RPG;\nimport weapons.Shotgun;\nimport weapons.Weapon;\n\npublic class Leon extends MainCharacter {\n\n    Claire claire;\n    double distanceToClaire = 60;\n\n    BufferedImage[][][] walkCycle;\n    BufferedImage[][][] walkCycleShotgun;\n\n    public Weapon[] weapons = new Weapon[3];\n\n    public Leon(GamePanel gamePanel, MyKeyListener input, MyMouseListener mouse) {\n        this.gp = gamePanel;\n        this.input = input;\n        this.mouse = mouse;\n\n        active = true;\n        health = 100;\n\n        input.setLeon(this);\n\n        WIDTH = 200;\n        HEIGHT = 200;\n\n        rawSpeed = 4.0;\n        speed = rawSpeed * 60 / gp.getFPS();\n\n        rawDashSpeed = 8.0;\n        dashSpeed = rawDashSpeed * 60 / gp.getFPS();\n        dashDuration = 150000000;// nanos\n\n        x = (gp.map.mapWidth - WIDTH) / 2;\n        y = (gp.map.mapHeight - HEIGHT) / 2;\n\n        weapons[0] = new Gun(gp);\n        weapons[1] = new Shotgun(gp);\n        weapons[1].setCharacter(this);\n        weapons[2] = new RPG(gamePanel);\n        weapons[1].isActive = true;\n        weapons[2].isActive = true;\n\n        weapon = weapons[0];\n\n        walkCycle = new BufferedImage[8][16][24];\n        walkCycleShotgun = new BufferedImage[8][16][24];\n\n        getSprites();\n    }\n\n    public void setClaire(Claire claire) {\n        this.claire = claire;\n    }\n\n    void getSprites() {\n        try {\n            for (int i = 0; i < 8; i++) {\n                // i yürüme yönü\n                for (int j = 0; j < 16; j++) {\n                    // j baktığı yön\n                    if (!checkDirection(i, j)) {\n                        continue;\n                    }\n                    String path = \"/res/leon/\";\n\n                    for (int k = 1; k < 25; k++) {\n                        String path2 = path + \"walk/\";\n                        String path3 = path + \"walkShotgun/\";\n\n                        path2 = decidePathWalkCycle(i, j, path2);\n                        path3 = decidePathWalkCycle(i, j, path3);\n\n                        if (k < 10) {\n                            path2 = path2 + \"000\" + k + \".png\";\n                            path3 = path3 + \"000\" + k + \".png\";\n                        } else {\n                            path2 = path2 + \"00\" + k + \".png\";\n                            path3 = path3 + \"00\" + k + \".png\";\n                        }\n                        walkCycle[i][j][k - 1] = ImageIO.read(getClass().getResourceAsStream(path2));\n                        walkCycleShotgun[i][j][k - 1] = ImageIO.read(getClass().getResourceAsStream(path3));\n                    }\n                }\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public void update() {\n        if (health <= 0) {\n            return;\n        }\n        if (active) {\n            yonuAyarla();\n            konumuAyarla();\n            if (weapon.reloading) {\n                reload();\n                return;\n            }\n            if (mouse.shooting && weapon.bulletsInMagazine > 0)\n                shoot();\n        } else {\n            leonYapayZeka();\n        }\n        checkAmmunation();\n    }\n\n    public void draw(Graphics2D g2) {\n        // BEYAZ KARE\n        // g2.setColor(Color.white);\n        // g2.fillRect((int) (x - WIDTH / 2), (int) (y - HEIGHT / 2), WIDTH, HEIGHT);\n        if (active) {\n            g2.setColor(Color.gray);\n            g2.setStroke(new BasicStroke(1));\n            g2.drawLine((int) (x + weapon.relativeweaponx - GamePanel.kamera.x + GamePanel.screenWidth / 2),\n                    (int) (y + weapon.relativeweapony - GamePanel.kamera.y + GamePanel.screenHeight / 2), mouse.mouseX,\n                    mouse.mouseY);\n        }\n\n        int walkdirection2 = walkdirection;\n        if (!checkDirection(walkdirection2, facing)) {\n            walkdirection2 += 4;\n            if (walkdirection2 > 7) {\n                walkdirection2 -= 8;\n            }\n        }\n\n        BufferedImage cizilecek;\n\n        if (weaponIndex == 0) {\n            cizilecek = walkCycle[walkdirection2][facing][walkSpritecounter];\n        } else {\n            cizilecek = walkCycleShotgun[walkdirection2][facing][walkSpritecounter];\n        }\n\n        g2.drawImage(cizilecek, (int) (x - GamePanel.kamera.x + (GamePanel.screenWidth / 2) - (WIDTH / 2)),\n                (int) (y - GamePanel.kamera.y + (GamePanel.screenHeight / 2) - HEIGHT / 2), WIDTH, HEIGHT, null);\n    }\n\n    void konumuAyarla() {\n        speedX = 0;\n        speedY = 0;\n\n        yonuAyarla();\n\n        if (dash) {\n            switch (walkdirection) {\n                case 5:\n                    speedX = -1 / Math.sqrt(2);\n                    speedY = -1 / Math.sqrt(2);\n                    break;\n                case 3:\n                    speedX = 1 / Math.sqrt(2);\n                    speedY = -1 / Math.sqrt(2);\n                    break;\n                case 7:\n                    speedX = -1 / Math.sqrt(2);\n                    speedY = 1 / Math.sqrt(2);\n                    break;\n                case 1:\n                    speedX = 1 / Math.sqrt(2);\n                    speedY = 1 / Math.sqrt(2);\n                    break;\n                case 4:\n                    speedY = -1;\n                    break;\n                case 0:\n                    speedY = 1;\n                    break;\n                case 6:\n                    speedX = -1;\n                    break;\n                case 2:\n                    speedX = 1;\n                    break;\n            }\n\n            speedX *= dashSpeed;\n            speedY *= dashSpeed;\n\n            if (x + speedX < gp.map.mapWidth && x + speedX > 0 && y + speedY < gp.map.mapHeight && y + speedY > 0) {\n                x += speedX;\n                y += speedY;\n            }\n\n            currentTime = System.nanoTime();\n            dashTimer += currentTime - lastTime;\n            lastTime = currentTime;\n\n            if (dashTimer > dashDuration) {\n                dash = false;\n            }\n\n            return;\n        }\n\n        if (input.upPressed || input.downPressed || input.leftPressed || input.rightPressed) {\n            if (!isWalking) {\n                lastTime = System.nanoTime();\n                isWalking = true;\n            }\n            // sol üst\n            if (input.upPressed && input.leftPressed && !input.rightPressed) {\n                speedX = -1 / Math.sqrt(2);\n                speedY = -1 / Math.sqrt(2);\n                walkdirection = 5;\n            } // sağ üst\n            else if (input.upPressed && input.rightPressed && !input.leftPressed) {\n                speedX = +1 / Math.sqrt(2);\n                speedY = -1 / Math.sqrt(2);\n                walkdirection = 3;\n            } // sol alt\n            else if (input.downPressed && input.leftPressed && !input.rightPressed) {\n                speedX = -1 / Math.sqrt(2);\n                speedY = +1 / Math.sqrt(2);\n                walkdirection = 7;\n            } // sağ alt\n            else if (input.downPressed && input.rightPressed && !input.leftPressed) {\n                speedX = +1 / Math.sqrt(2);\n                speedY = +1 / Math.sqrt(2);\n                walkdirection = 1;\n            } // üst\n            else if (input.upPressed && !input.downPressed) {\n                speedY = -1;\n                walkdirection = 4;\n            } // alt\n            else if (input.downPressed && !input.upPressed) {\n                speedY = 1;\n                walkdirection = 0;\n            } // sol\n            else if (input.leftPressed && !input.rightPressed) {\n                speedX = -1;\n                walkdirection = 6;\n            } // sağ\n            else if (input.rightPressed && !input.leftPressed) {\n                speedX = 1;\n                walkdirection = 2;\n            }\n\n            speedX *= speed;\n            speedY *= speed;\n\n            if (x + speedX < gp.map.mapWidth && x + speedX > 0 && y + speedY < gp.map.mapHeight && y + speedY > 0) {\n                x += speedX;\n                y += speedY;\n            } else {\n                if (x < 0) {\n                    x += speed;\n                } else if (x > gp.map.mapWidth) {\n                    x -= speed;\n                }\n                if (y < 0) {\n                    y += speed;\n                } else if (y > gp.map.mapWidth) {\n                    y -= speed;\n                }\n            }\n\n            updateSprites();\n        } else {\n            isWalking = false;\n            walkSpritecounter = 10;\n            timeWalked = (1000000000 / walkFPS) * 10 + 100;\n        }\n    }\n\n    void leonYapayZeka() {\n        if (claire.isWalking) {\n            if (!isWalking) {\n                lastTime = System.nanoTime();\n                isWalking = true;\n            }\n            updateSprites();\n        } else {\n            isWalking = false;\n            walkSpritecounter = 10;\n            timeWalked = (1000000000 / walkFPS) * 10 + 100;\n        }\n\n        chooseDestination();\n        double distanceToTarget = Math.sqrt((x - targetx) * (x - targetx) + (y - targety) * (y - targety));\n        if (distanceToTarget < 40) {\n            setFacingDirection();\n        } else {\n            yonuAyarlaYapayZeka();\n        }\n        goToDestination();\n    }\n\n    void chooseDestination() {\n        targetx = (mouse.mouseX + GamePanel.kamera.x - GamePanel.screenWidth / 2) - claire.x;\n        targety = (mouse.mouseY + GamePanel.kamera.y - GamePanel.screenHeight / 2) - claire.y;\n\n        double distance = Math.sqrt(targetx * targetx + targety * targety);\n\n        targetx = claire.x - targetx / distance * distanceToClaire;\n        targety = claire.y - targety / distance * distanceToClaire;\n    }\n\n    void setFacingDirection() {\n        facing = claire.facing - 8;\n        if (facing < 0)\n            facing += 16;\n    }\n\n    public void dash() {\n        dash = true;\n        dashTimer = 0;\n        lastTime = System.nanoTime();\n\n        if (!input.upPressed && !input.downPressed && !input.leftPressed && !input.rightPressed) {\n            walkdirection = 2;\n            return;\n        }\n\n        if (input.upPressed && input.leftPressed) {\n            walkdirection = 5;\n        } else if (input.upPressed && input.rightPressed) {\n            walkdirection = 3;\n        } else if (input.downPressed && input.leftPressed) {\n            walkdirection = 7;\n        } else if (input.downPressed && input.rightPressed) {\n            walkdirection = 1;\n        } else if (input.downPressed && !input.downPressed) {\n            walkdirection = 0;\n        } else if (input.upPressed && !input.downPressed) {\n            walkdirection = 4;\n        } else if (input.leftPressed && !input.rightPressed) {\n            walkdirection = 6;\n        } else if (input.rightPressed && !input.leftPressed) {\n            walkdirection = 2;\n        }\n    }\n\n    public void changeWeapon() {\n        if (weapon.reloading) {\n            return;\n        }\n        if (weaponIndex == 0) {\n            if (weapons[1].isActive) {\n                weaponIndex = 1;\n                weapon = weapons[1];\n                WIDTH = 260;\n                HEIGHT = 260;\n            }\n        } else if (weaponIndex == 1) {\n            if (weapons[2].isActive) {\n                weaponIndex = 2;\n                weapon = weapons[2];\n                WIDTH = 260;\n                HEIGHT = 260;\n            } else {\n                weaponIndex = 0;\n                weapon = weapons[0];\n                WIDTH = 200;\n                HEIGHT = 200;\n            }\n        } else {\n            weaponIndex = 0;\n            weapon = weapons[0];\n            WIDTH = 200;\n            HEIGHT = 200;\n        }\n    }\n\n    void checkAmmunation() {\n        for (int i = gp.ammunation.size() - 1; i >= 0; i--) {\n            Ammunation a = gp.ammunation.get(i);\n            if (Math.abs(a.x - x) < 50 && Math.abs(a.y - y) < 100) {\n                if (a.type.equals(\"Shotgun\")) {\n                    weapons[1].bullets += a.quantity;\n                    a.remove = true;\n                } else if (a.type.equals(\"RPG\")) {\n                    weapons[2].bullets += a.quantity;\n                    a.remove = true;\n                }\n            }\n        }\n    }\n}\n",
      "MainCharacter.java": "package entity.characters;\n\nimport main.GamePanel;\nimport main.MyKeyListener;\nimport main.MyMouseListener;\nimport weapons.Gun;\nimport weapons.Weapon;\n\npublic class MainCharacter {\n\n    protected GamePanel gp;\n    MyKeyListener input;\n    MyMouseListener mouse;\n    public Weapon weapon;\n\n    public boolean active;\n    public int health;\n\n    protected int WIDTH;\n    protected int HEIGHT;\n\n    protected double rawSpeed;\n    protected double speed;\n\n    protected double speedX;\n    protected double speedY;\n\n    public double x;\n    public double y;\n    double targetx;\n    double targety;\n\n    int walkdirection = 0;\n    boolean isWalking = false;\n    long timeWalked = 0;\n    int walkFPS = 24;\n    int walkSpritecounter = 0;\n\n    public int facing = 0;\n    int facingX;\n    int facingY;\n    double aci;\n\n    boolean dash = false;\n    double rawDashSpeed;\n    double dashSpeed;\n    long dashDuration;\n    long dashTimer;\n    long lastTime;\n    long currentTime;\n\n    int weaponIndex = 0;\n\n    double x1, x2, y1, y2;\n\n    public void shoot() {\n        if (weapon.bulletsInMagazine <= 0) {\n            return;\n        }\n        x1 = x + weapon.relativeweaponx;\n        y1 = y + weapon.relativeweapony;\n        x2 = (mouse.mouseX + GamePanel.kamera.x - GamePanel.screenWidth / 2);\n        y2 = (mouse.mouseY + GamePanel.kamera.y - GamePanel.screenHeight / 2);\n\n        weapon.shoot(gp.zombiler, x1, y1, x2, y2);\n    }\n\n    void yonuAyarla() {\n        facingX = mouse.mouseX - (int) (x - GamePanel.kamera.x + GamePanel.screenWidth / 2);\n        facingY = (int) (y - GamePanel.kamera.y + GamePanel.screenHeight / 2) - mouse.mouseY;\n\n        if (facingX == 0) {\n            if (facingY > 0) {\n                facing = 8;\n            } else {\n                facing = 0;\n            }\n            return;\n        }\n        double aci = Math.atan(((double) facingY / facingX));\n\n        // System.out.println(aci);\n        // System.out.println((double) facingY / facingX);\n\n        if (facingX > 0) {\n            facing = (int) Math.ceil((aci + 7 * Math.PI / 16) / (Math.PI / 8));\n\n        } else {\n            facing = (int) Math.ceil((aci + 7 * Math.PI / 16) / (Math.PI / 8)) + 8;\n            if (facing == 16) {\n                facing = 0;\n            }\n        }\n    }\n\n    void yonuAyarlaYapayZeka() {\n        facingX = (int) targetx - (int) x;\n        facingY = (int) y - (int) targety;\n\n        if (facingX == 0) {\n            if (facingY > 0) {\n                facing = 8;\n            } else {\n                facing = 0;\n            }\n            return;\n        }\n        double aci = Math.atan(((double) facingY / facingX));\n\n        if (facingX > 0) {\n            facing = (int) Math.ceil((aci + 7 * Math.PI / 16) / (Math.PI / 8));\n\n        } else {\n            facing = (int) Math.ceil((aci + 7 * Math.PI / 16) / (Math.PI / 8)) + 8;\n            if (facing == 16) {\n                facing = 0;\n            }\n        }\n    }\n\n    void goToDestination() {\n        speedX = targetx - x;\n        speedY = targety - y;\n\n        double distance = Math.sqrt(speedX * speedX + speedY * speedY);\n\n        if (distance < speed * 3) {\n            speedX = 0;\n            speedY = 0;\n        } else {\n            speedX = speedX / distance * speed * 3 / 2;\n            speedY = speedY / distance * speed * 3 / 2;\n\n            if (speedX > 0) {\n                if (speedY > 0) {\n                    walkdirection = 1;\n                } else {\n                    walkdirection = 3;\n                }\n            } else {\n                if (speedY > 0) {\n                    walkdirection = 7;\n                } else {\n                    walkdirection = 5;\n                }\n            }\n        }\n\n        x += speedX;\n        y += speedY;\n    }\n\n    protected boolean checkDirection(int i, int j) {\n        i *= 2;\n        int altSinir = i - 5;\n        if (altSinir < 0) {\n            altSinir += 16;\n        }\n        int ustSinir = i + 2;\n        if (ustSinir > 15) {\n            ustSinir -= 16;\n        }\n\n        if (altSinir > ustSinir) {\n            if (j >= altSinir || j <= ustSinir) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            if (j >= altSinir && j <= ustSinir) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n    }\n\n    protected String decidePathWalkCycle(int i, int j, String path) {\n        switch (i) {\n            case 0:\n                path += \"down\";\n                break;\n            case 1:\n                path += \"downRight\";\n                break;\n            case 2:\n                path += \"right\";\n                break;\n            case 3:\n                path += \"upRight\";\n                break;\n            case 4:\n                path += \"up\";\n                break;\n            case 5:\n                path += \"upLeft\";\n                break;\n            case 6:\n                path += \"left\";\n                break;\n            case 7:\n                path += \"downLeft\";\n                break;\n        }\n        path += j + \"/\";\n\n        return path;\n    }\n\n    protected void updateSprites() {\n        currentTime = System.nanoTime();\n        if (checkDirection(walkdirection, facing)) {\n            timeWalked += currentTime - lastTime;\n        } else {\n            timeWalked -= currentTime - lastTime;\n            if (timeWalked < 0) {\n                timeWalked += 1000000000;\n            }\n        }\n\n        lastTime = currentTime;\n\n        walkSpritecounter = (int) (timeWalked % 1000000000) / (1000000000 / walkFPS);\n    }\n\n    public void hasarAl(int damage) {\n        if (!dash && gp.stage != 7) {\n            health -= damage;\n        }\n    }\n\n    public void reload() {\n        if (System.currentTimeMillis() - weapon.reloadStartTime > weapon.reloadDuration) {\n            if (weapon.bullets >= weapon.magazineCapacity) {\n                if (!(weapon instanceof Gun))\n                    weapon.bullets -= weapon.magazineCapacity;\n                weapon.bulletsInMagazine = weapon.magazineCapacity;\n            } else {\n                weapon.bulletsInMagazine = weapon.bullets;\n                weapon.bullets = 0;\n            }\n            weapon.reloading = false;\n        }\n    }\n\n    public void changeWeapon() {\n    }\n}\n",
      "Zombi.java": "package entity.zombi;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.util.Random;\n\nimport entity.characters.MainCharacter;\nimport main.GamePanel;\n\npublic abstract class Zombi {\n    protected GamePanel gp;\n    public HitBox hitbox;\n\n    Random random = new Random();\n\n    protected int WIDTH;\n    protected int HEIGHT;\n\n    protected double rawSpeed;\n    protected double speed;\n\n    protected double speedX;\n    protected double speedY;\n\n    public double x;\n    public double y;\n\n    public MainCharacter target;\n    protected double targetx;\n    protected double targety;\n\n    public double distanceToTarget = 10000;\n\n    public int damage;\n    public int healt;\n\n    public int facing;// 0sağ 1sol\n    public boolean isAlive;\n    public boolean walking;\n\n    public class HitBox {\n        int headx1, headx2, heady1, heady2;\n        int x1, x2, y1, y2;\n        // y=ax+b\n        double egimKafa;\n        double egimGovde;\n\n        double sabitKafa;// =heady1 - headx1*(egimKafa)\n        double sabitGovde;// =y1-x1*(egimGovde)\n\n        HitBox(int headx1, int headx2, int heady1, int heady2, int x1, int x2, int y1, int y2) {\n            this.headx1 = headx1;\n            this.headx2 = headx2;\n            this.heady1 = heady1;\n            this.heady2 = heady2;\n            this.x1 = x1;\n            this.x2 = x2;\n            this.y1 = y1;\n            this.y2 = y2;\n\n            egimKafa = (heady2 - heady1) / (headx2 - headx1);\n            egimGovde = (y2 - y1) / (x2 - x1);\n        }\n\n        // y=cx+d\n        // y=ax+b\n        public int[] checkCollision(double c, double d) {\n            // KAFA\n            double a = egimKafa;\n            double b = (y + heady1) - (x + headx1) * egimKafa;\n\n            double kesisimX;\n\n            if (a != c) {\n                kesisimX = (d - b) / (a - c);\n                if (kesisimX < (x + headx2) && kesisimX > (x + headx1)) {\n                    int[] kordinatlar = new int[3];\n                    kordinatlar[0] = (int) kesisimX;\n                    kordinatlar[1] = (int) (c * kesisimX + d);\n                    kordinatlar[2] = 0;\n                    return kordinatlar;\n                }\n            }\n\n            a = -egimKafa;\n            b = (y + heady2) - (x + headx1) * a;\n\n            if (a != c) {\n                kesisimX = (d - b) / (a - c);\n                if (kesisimX < (x + headx2) && kesisimX > (x + headx1)) {\n                    int[] kordinatlar = new int[3];\n                    kordinatlar[0] = (int) kesisimX;\n                    kordinatlar[1] = (int) (c * kesisimX + d);\n                    kordinatlar[2] = 0;\n                    return kordinatlar;\n                }\n            }\n\n            // GÖVDE\n\n            a = egimGovde;\n            b = (y + y1) - (x + x1) * egimGovde;\n\n            if (a != c) {\n                kesisimX = (d - b) / (a - c);\n                if (kesisimX < (x + x2) && kesisimX > (x + x1)) {\n                    int[] kordinatlar = new int[3];\n                    kordinatlar[0] = (int) kesisimX;\n                    kordinatlar[1] = (int) (c * kesisimX + d);\n                    kordinatlar[2] = 1;\n                    return kordinatlar;\n                }\n            }\n\n            a = -egimGovde;\n            b = (y + y2) - (x + x1) * a;\n\n            if (a != c) {\n                kesisimX = (d - b) / (a - c);\n                if (kesisimX < (x + x2) && kesisimX > (x + x1)) {\n                    int[] kordinatlar = new int[3];\n                    kordinatlar[0] = (int) kesisimX;\n                    kordinatlar[1] = (int) (c * kesisimX + d);\n                    kordinatlar[2] = 1;\n                    return kordinatlar;\n                }\n            }\n\n            return null;\n        }\n\n        public void drawHitbox(Graphics2D g2) {\n            int screenx = (int) (x - GamePanel.kamera.x + (GamePanel.screenWidth / 2));\n            int screeny = (int) (y - GamePanel.kamera.y + (GamePanel.screenHeight / 2));\n\n            g2.setColor(Color.white);\n            g2.drawRect((int) (screenx + headx1), (int) (screeny + heady1), (headx2 - headx1), (heady2 - heady1));\n            g2.drawRect((int) (screenx + x1), (int) (screeny + y1), (x2 - x1), (y2 - y1));\n        }\n    }\n\n    public Zombi(GamePanel gp, double x, double y) {\n        this.gp = gp;\n\n        this.x = x;\n        this.y = y;\n        rawSpeed = 1.0;\n\n        speed = rawSpeed * 60 / gp.getFPS();\n    }\n\n    public void setSpeed(double speed) {\n        this.speed = speed;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    public abstract void update();\n\n    public abstract void draw(Graphics2D g2);\n\n    public void hasarAl(int damage) {\n        healt -= damage;\n    }\n\n    public void checkCollision(double a, double b) {\n        hitbox.checkCollision(a, b);\n    }\n}\n",
      "DuzZombi.java": "package entity.zombi;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\n\nimport main.GamePanel;\nimport weapons.Ammunation;\n\npublic class DuzZombi extends Zombi {\n\n    public static BufferedImage[][] walkCycle;\n    public static BufferedImage[][] attackAnimation;\n    public static BufferedImage[][] death;\n\n    static {\n        walkCycle = new BufferedImage[2][2];\n        attackAnimation = new BufferedImage[2][2];\n        death = new BufferedImage[2][4];\n    }\n\n    boolean walking = false;\n\n    int spriteCounter = 0;\n    byte spriteNum = 0;\n    int deathSpriteCounter = 0;\n    int deathSpriteNum;\n\n    int attackCooldown;\n    int attackCounter = 0;\n\n    public DuzZombi(GamePanel gp, double x, double y) {\n        super(gp, x, y);\n        WIDTH = 130;\n        HEIGHT = 130;\n        rawSpeed = 1.0;\n        speed = rawSpeed * 60 / gp.getFPS();\n        damage = 19;\n        healt = 100;\n        isAlive = true;\n\n        hitbox = new HitBox(-13, 13, -60, -30, -20, 20, -30, 50);\n\n        attackCooldown = (int) 60 * gp.getFPS() / 60;\n        attackCounter = attackCooldown;\n    }\n\n    @Override\n    public void update() {\n        if (healt > 0) {\n            hedefBelirle();\n            hedefeGit();\n        } else {\n            die();\n        }\n    }\n\n    void hedefBelirle() {\n        target = gp.activeCharacter;\n        targetx = gp.activeCharacter.x;\n        targety = gp.activeCharacter.y;\n    }\n\n    void hedefeGit() {\n        double distance = Math.sqrt((targetx - x) * (targetx - x) + (targety - y) * (targety - y));\n        distanceToTarget = distance;\n        if (distance > speed + 20) {\n            speedX = (targetx - x) / distance * speed;\n            speedY = (targety - y) / distance * speed;\n            x += speedX;\n            y += speedY;\n\n            if (speedX > 0) {\n                facing = 0;\n            } else {\n                facing = 1;\n            }\n\n            walking = true;\n        } else {\n            walking = false;\n            if (attackCounter > attackCooldown) {\n                saldir();\n                attackCounter = 0;\n            } else {\n                attackCounter++;\n            }\n        }\n\n        spriteCounter++;\n        if (spriteCounter > 20 * gp.getFPS() / 60) {\n            if (spriteNum == 1) {\n                spriteNum = 0;\n            } else {\n                spriteNum = 1;\n            }\n            spriteCounter = 0;\n        }\n    }\n\n    void saldir() {\n        target.hasarAl(damage);\n    }\n\n    void die() {\n        deathSpriteCounter++;\n        if (deathSpriteCounter > 10 * gp.getFPS() / 60 && deathSpriteNum < 3) {\n            deathSpriteNum++;\n        }\n        if (deathSpriteCounter > gp.getFPS()) {\n            int quantity = random.nextInt(8, 20);\n            gp.ammunation.add(0, new Ammunation(x, y, quantity, \"Rifle\"));\n            if (gp.ammunation.size() > gp.maxAmmunation) {\n                gp.ammunation.remove(gp.maxAmmunation - 1);\n            }\n            gp.ammunation.add(0, new Ammunation(x, y, 3, \"Shotgun\"));\n            if (gp.ammunation.size() > gp.maxAmmunation) {\n                gp.ammunation.remove(gp.maxAmmunation - 1);\n            }\n            isAlive = false;\n        }\n        deathSpriteNum = Math.min(deathSpriteNum, 3);\n    }\n\n    @Override\n    public void draw(Graphics2D g2) {\n        // g2.setColor(Color.white);\n        // g2.fillRect((int) (x - WIDTH / 2), (int) (y - HEIGHT / 2), WIDTH, HEIGHT);\n        int screenx = (int) (x - GamePanel.kamera.x + (GamePanel.screenWidth / 2) - (WIDTH / 2));\n        int screeny = (int) (y - GamePanel.kamera.y + (GamePanel.screenHeight / 2) - (HEIGHT / 2));\n\n        if (healt <= 0) {\n            g2.drawImage(death[facing][deathSpriteNum], screenx, screeny, WIDTH, HEIGHT,\n                    null);\n            return;\n        }\n        if (walking) {\n            g2.drawImage(walkCycle[facing][spriteNum], screenx, screeny, WIDTH, HEIGHT,\n                    null);\n        } else {\n            g2.drawImage(attackAnimation[facing][spriteNum], screenx,\n                    screeny, WIDTH,\n                    HEIGHT, null);\n        }\n\n        // hitbox.drawHitbox(g2);\n    }\n\n}\n",
      "TukurenZombi.java": "package entity.zombi;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.Serializable;\nimport java.util.Vector;\n\nimport main.GamePanel;\nimport main.Sound;\nimport weapons.Ammunation;\nimport weapons.RPG;\n\npublic class TukurenZombi extends Zombi {\n    public static BufferedImage[][] walkCycle = new BufferedImage[2][2];\n\n    int spriteCounter = 0;\n    byte spriteNum = 0;\n    int deathSpriteCounter = 0;\n\n    int attackCooldown;\n    int attackCounter = 0;\n\n    double distance;\n    Sound sound = new Sound();\n\n    private boolean isExploded;\n\n    public static BufferedImage[] image = new BufferedImage[2];\n\n    public TukurenZombi(GamePanel gp, double x, double y) {\n        super(gp, x, y);\n        WIDTH = 130;\n        HEIGHT = 130;\n        rawSpeed = 2.0;\n        speed = rawSpeed * 60 / gp.getFPS();\n        damage = 22;\n        healt = 300;\n        isAlive = true;\n\n        hitbox = new HitBox(-23, 23, -62, -10, -20, 20, -10, 57);\n\n        attackCooldown = (int) 90 * (gp.getFPS() / 60);\n        attackCounter = attackCooldown / 2;\n    }\n\n    public void update() {\n        if (healt > 0) {\n            hedefBelirle();\n            hedefeGit();\n        } else {\n            die();\n        }\n    }\n\n    void hedefBelirle() {\n        target = gp.activeCharacter;\n        targetx = gp.activeCharacter.x;\n        targety = gp.activeCharacter.y;\n\n        distance = Math.sqrt((targetx - x) * (targetx - x) + (targety - y) * (targety - y));\n        distanceToTarget = distance;\n    }\n\n    void hedefeGit() {\n        if (distance < 420) {\n            walking = false;\n            if (attackCounter > attackCooldown) {\n                saldir();\n                attackCounter = 0;\n            } else {\n                attackCounter++;\n            }\n        } else {\n            speedX = (targetx - x) / distance * speed;\n            speedY = (targety - y) / distance * speed;\n            x += speedX;\n            y += speedY;\n\n            if (speedX > 0) {\n                facing = 0;\n            } else {\n                facing = 1;\n            }\n\n            walking = true;\n        }\n    }\n\n    void saldir() {\n        gp.tukurukler.add(new Tukuruk(gp, x, y, targetx, targety));\n    }\n\n    void die() {\n        deathSpriteCounter++;\n\n        if (deathSpriteCounter > gp.getFPS() / 3 && !isExploded) {\n            isExploded = true;\n            explode();\n            playSound(7);\n        }\n    }\n\n    void explode() {\n        Vector<Zombi> zombiler2 = gp.zombiler;\n\n        for (int i = zombiler2.size() - 1; i >= 0; i--) {\n            double dx = zombiler2.get(i).x - x;\n            double dy = zombiler2.get(i).y - y;\n\n            double distance2 = Math.sqrt(dy * dy + dx * dx);\n\n            if (distance2 < 200) {\n                zombiler2.get(i).hasarAl(damage * 3);\n            }\n        }\n\n        if (random.nextDouble() < 0.2) {\n            int quantity = random.nextInt(30, 60);\n            gp.ammunation.add(new Ammunation(x, y, quantity, \"Rifle\"));\n        } else {\n            int quantity = random.nextInt(20, 25);\n            gp.ammunation.add(new Ammunation(x, y, quantity, \"Shotgun\"));\n        }\n        if (gp.ammunation.size() > gp.maxAmmunation) {\n            gp.ammunation.remove(gp.maxAmmunation - 1);\n        }\n\n        spriteCounter = 0;\n\n    }\n\n    public class Tukuruk implements Serializable {\n        double x, y, targetx, targety;\n        double speed, rawSpeed, speedx, speedy;\n\n        public boolean remove = false;\n        Color color = new Color(5, 150, 30);\n\n        public Tukuruk(GamePanel gp, double x, double y, double targetx, double targety) {\n            this.x = x;\n            this.y = y;\n            speedx = targetx - x;\n            speedy = targety - y;\n            distance = Math.sqrt((x - targetx) * (x - targetx) + (y - targety) * (y - targety));\n\n            rawSpeed = 10;\n            speed = rawSpeed * 60 / gp.getFPS();\n\n            speedx = speedx / distance * speed;\n            speedy = speedy / distance * speed;\n        }\n\n        public void update() {\n            if (x > GamePanel.kamera.x + GamePanel.screenWidth / 2\n                    || y > GamePanel.kamera.y + GamePanel.screenHeight / 2\n                    || x < GamePanel.kamera.x - GamePanel.screenWidth / 2\n                    || y < GamePanel.kamera.y - GamePanel.screenHeight / 2) {\n                remove = true;\n                return;\n            }\n\n            if (Math.abs(x - gp.activeCharacter.x) < 20 && Math.abs(y - gp.activeCharacter.y) < 65) {\n                target.hasarAl(damage);\n                remove = true;\n            }\n\n            x += speedx;\n            y += speedy;\n        }\n\n        public void draw(Graphics2D g2) {\n            int screenx = (int) (x - GamePanel.kamera.x + GamePanel.screenWidth / 2);\n            int screeny = (int) (y - GamePanel.kamera.y + GamePanel.screenHeight / 2);\n\n            g2.setColor(color);\n            g2.fillOval((int) (screenx - 5), (int) (screeny - 5), 10, 10);\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2) {\n\n        int screenx = (int) (x - GamePanel.kamera.x + (GamePanel.screenWidth / 2) - (WIDTH / 2));\n        int screeny = (int) (y - GamePanel.kamera.y + (GamePanel.screenHeight / 2) - (HEIGHT / 2));\n\n        if (isExploded) {\n            if (spriteCounter >= RPG.Roket.patlama.length * gp.getFPS() / 30) {\n                isAlive = false;\n                return;\n            } else {\n                g2.drawImage(RPG.Roket.patlama[spriteCounter / (gp.getFPS() / 30)], (int) (screenx - 200),\n                        (int) (screeny - 200), 400,\n                        400, null);\n                spriteCounter++;\n            }\n        }\n\n        // g2.setColor(Color.green);\n        // g2.fillRect(screenx, screeny, WIDTH, HEIGHT);\n\n        g2.drawImage(image[facing], screenx, screeny, WIDTH, HEIGHT, null);\n\n        // hitbox.drawHitbox(g2);\n    }\n\n    void playSound(int i) {\n        sound.setFile(i);\n        sound.play();\n    }\n}\n",
      "SurungenZombi.java": "package entity.zombi;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\n\nimport main.GamePanel;\nimport weapons.Ammunation;\n\npublic class SurungenZombi extends Zombi {\n\n    public static BufferedImage[][] walkCycle = new BufferedImage[2][24];\n    public static BufferedImage[] attackAnimation = new BufferedImage[2];\n\n    int FPS;\n    double distance;\n\n    int spriteCounter;\n    int spriteNum;\n    int deathSpriteCounter = 0;\n    int deathSpriteNum;\n\n    int attackCounter = 0;\n    int attackCooldown;\n\n    boolean dash = false;\n    boolean flag = true;\n    long dashTimer = 0;\n    long lastTime;\n    long currentTime;\n    long dashDuration;\n    double dashSpeed;\n\n    double dashDirectionX, dashDirectionY;\n\n    public SurungenZombi(GamePanel gp, double x, double y) {\n        super(gp, x, y);\n        WIDTH = 130;\n        HEIGHT = 130;\n        rawSpeed = 3.5;\n        speed = rawSpeed * 60 / gp.getFPS();\n        damage = 70;\n        healt = 200;\n        isAlive = true;\n\n        FPS = gp.getFPS();\n        dashSpeed = 16 * 60 / FPS;\n\n        attackCooldown = (int) 30 * gp.getFPS() / 60;\n        attackCounter = attackCooldown;\n\n        hitbox = new HitBox(-11, 11, -55, -30, -20, 20, -30, 50);\n    }\n\n    @Override\n    public void update() {\n        if (healt > 0) {\n            hedefBelirle();\n            hedefeGit();\n\n        } else {\n            die();\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2) {\n        int screenx = (int) (x - GamePanel.kamera.x + (GamePanel.screenWidth / 2) - WIDTH / 2);\n        int screeny = (int) (y - GamePanel.kamera.y + (GamePanel.screenHeight / 2) - HEIGHT / 2);\n\n        // g2.setColor(Color.cyan);\n        // g2.fillRect(screenx - WIDTH / 2, screeny - HEIGHT / 2, WIDTH, HEIGHT);\n\n        if (dash) {\n            g2.drawImage(attackAnimation[facing], screenx, screeny, WIDTH, HEIGHT, null);\n        } else {\n            g2.drawImage(walkCycle[facing][spriteNum], screenx, screeny, WIDTH, HEIGHT, null);\n        }\n\n        if (flag && distance > 300 && distance < 400) {\n            g2.setColor(Color.red);\n            g2.setStroke(new BasicStroke(2));\n            int a = 75;\n            int r = (int) ((400 - distance) * a / 100);\n            int upperLeftx = (int) (screenx + a - r);\n            int upperLefty = (int) (screeny + a - r);\n            g2.drawOval(upperLeftx, upperLefty, 2 * r, 2 * r);\n        }\n        // hitbox.drawHitbox(g2);\n    }\n\n    void hedefBelirle() {\n        target = gp.activeCharacter;\n        targetx = gp.activeCharacter.x;\n        targety = gp.activeCharacter.y;\n\n        distance = Math.sqrt((targetx - x) * (targetx - x) + (targety - y) * (targety - y));\n        distanceToTarget = distance;\n\n        if (distance < 300 && flag == true) {\n            dash();\n        }\n    }\n\n    void hedefeGit() {\n        if (dash) {\n            x += dashDirectionX;\n            y += dashDirectionY;\n\n            currentTime = System.nanoTime();\n            dashTimer += currentTime - lastTime;\n            lastTime = currentTime;\n\n            if (distance < 40) {\n                if (attackCounter > attackCooldown) {\n                    saldir();\n                    attackCounter = 0;\n                } else {\n                    attackCounter++;\n                }\n            }\n\n            if (dashTimer > dashDuration) {\n                dash = false;\n            }\n\n            return;\n        }\n\n        if (distance > speed + 40) {\n\n            speedX = (targetx - x) / distance * speed;\n            speedY = (targety - y) / distance * speed;\n\n            if (flag && distance > 300 && distance < 400) {\n                x += speedX * 4 / 5;\n                y += speedY * 4 / 5;\n            } else if (!flag) {\n                x += speedX * 2;\n                y += speedY * 2;\n            } else {\n                x += speedX;\n                y += speedY * 3 / 2;\n            }\n\n            if (speedX > 0) {\n                facing = 0;\n            } else {\n                facing = 1;\n            }\n\n            walking = true;\n        } else {\n            walking = false;\n            if (attackCounter > attackCooldown) {\n                saldir();\n                attackCounter = 0;\n            } else {\n                attackCounter++;\n            }\n        }\n\n        spriteCounter++;\n        if (spriteCounter > (4 * gp.getFPS() / 60)) {\n            spriteNum++;\n            if (spriteNum > 23) {\n                spriteNum = 0;\n            }\n            spriteCounter = 0;\n        }\n    }\n\n    void saldir() {\n        target.hasarAl(damage);\n    }\n\n    void dash() {\n        dashDirectionX = targetx - x;\n        dashDirectionY = targety - y;\n\n        dashDirectionX = dashDirectionX / distance * dashSpeed;\n        dashDirectionY = dashDirectionY / distance * dashSpeed;\n\n        dashDuration = (long) (((distance + 100) / dashSpeed) * (1000000000 / FPS));\n\n        dash = true;\n        flag = false;\n        lastTime = System.nanoTime();\n        dashTimer = 0;\n    }\n\n    void die() {\n        deathSpriteCounter++;\n        if (deathSpriteCounter > gp.getFPS()) {\n            isAlive = false;\n\n            if (dash) {\n                int quantity = random.nextInt(4, 8);\n                gp.ammunation.add(new Ammunation(x, y, quantity, \"RPG\"));\n            } else {\n                int quantity = random.nextInt(5, 15);\n                gp.ammunation.add(new Ammunation(x, y, quantity, \"Sniper\"));\n            }\n            if (gp.ammunation.size() > gp.maxAmmunation) {\n                gp.ammunation.remove(gp.maxAmmunation - 1);\n            }\n        }\n    }\n\n}\n",
      "TankZombi.java": "package entity.zombi;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\n\nimport main.GamePanel;\nimport weapons.Ammunation;\n\npublic class TankZombi extends Zombi {\n    public static BufferedImage[][] walkCycle = new BufferedImage[2][4];\n\n    boolean walking = false;\n\n    int spriteCounter = 0;\n    byte spriteNum = 0;\n    int deathSpriteCounter = 0;\n\n    int attackCooldown;\n    int attackCounter = 0;\n\n    public TankZombi(GamePanel gp, double x, double y) {\n        super(gp, x, y);\n        WIDTH = 200;\n        HEIGHT = 200;\n        rawSpeed = 1.0;\n        speed = rawSpeed * 60 / gp.getFPS();\n        damage = 48;\n        healt = 1000;\n        isAlive = true;\n\n        hitbox = new HitBox(-30, 30, -80, -20, -55, 55, -50, 80);\n\n        attackCooldown = (int) 60 * gp.getFPS() / 60;\n        attackCounter = attackCooldown;\n    }\n\n    @Override\n    public void update() {\n        if (healt > 0) {\n            hedefBelirle();\n            hedefeGit();\n        } else {\n            die();\n        }\n    }\n\n    void hedefBelirle() {\n        target = gp.activeCharacter;\n        targetx = gp.activeCharacter.x;\n        targety = gp.activeCharacter.y;\n    }\n\n    void hedefeGit() {\n        double distance = Math.sqrt((targetx - x) * (targetx - x) + (targety - y) * (targety - y));\n        distanceToTarget = distance;\n        if (distance > speed + 50) {\n            speedX = (targetx - x) / distance * speed;\n            speedY = (targety - y) / distance * speed;\n            x += speedX;\n            y += speedY;\n\n            if (speedX > 0) {\n                facing = 0;\n            } else {\n                facing = 1;\n            }\n\n            walking = true;\n        } else {\n            walking = false;\n            if (attackCounter > attackCooldown) {\n                saldir();\n                attackCounter = 0;\n            } else {\n                attackCounter++;\n            }\n        }\n\n        spriteCounter++;\n        if (spriteCounter > 30 * gp.getFPS() / 60) {\n            spriteNum++;\n            if (spriteNum > 3) {\n                spriteNum -= 4;\n            }\n            spriteCounter = 0;\n        }\n    }\n\n    void saldir() {\n        target.hasarAl(damage);\n    }\n\n    void die() {\n        deathSpriteCounter++;\n\n        if (deathSpriteCounter > gp.getFPS()) {\n            if (random.nextDouble() < 0.7) {\n                int quantity = random.nextInt(10, 28);\n                gp.ammunation.add(new Ammunation(x, y, quantity, \"Rifle\"));\n            } else {\n                int quantity = random.nextInt(5, 10);\n                gp.ammunation.add(new Ammunation(x, y, quantity, \"Sniper\"));\n            }\n            if (gp.ammunation.size() > gp.maxAmmunation) {\n                gp.ammunation.remove(gp.maxAmmunation - 1);\n            }\n\n            isAlive = false;\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2) {\n\n        int screenx = (int) (x - GamePanel.kamera.x + (GamePanel.screenWidth / 2) - (WIDTH / 2));\n        int screeny = (int) (y - GamePanel.kamera.y + (GamePanel.screenHeight / 2) - (HEIGHT / 2));\n\n        // g2.setColor(Color.BLUE);\n        // g2.fillRect(screenx, screeny, WIDTH, HEIGHT);\n\n        if (healt <= 0) {\n            g2.drawImage(walkCycle[facing][0], screenx, screeny, WIDTH, HEIGHT, null);\n            return;\n        } else {\n            g2.drawImage(walkCycle[facing][spriteNum], screenx, screeny, WIDTH, HEIGHT,\n                    null);\n        }\n\n        // hitbox.drawHitbox(g2);\n    }\n\n}\n",
      "ZombiSpawner.java": "package main;\n\nimport java.util.Random;\n\nimport entity.zombi.DuzZombi;\nimport entity.zombi.SurungenZombi;\nimport entity.zombi.TankZombi;\nimport entity.zombi.TukurenZombi;\n\npublic class ZombiSpawner {\n\n    Random random = new Random();\n    GamePanel gp;\n\n    int counter = 0;\n    int interval;\n\n    int zombiSpawned = 0;\n\n    public boolean flag = true;\n\n    public ZombiSpawner(GamePanel gp) {\n        this.gp = gp;\n        interval = gp.getFPS();\n    }\n\n    public void spawnZombi(int i) {\n        counter++;\n        switch (i) {\n            case 1:\n                if (flag) {\n                    for (int j = 0; j < 6; j++) {\n                        spawnDuzZombi();\n                    }\n                    flag = false;\n                }\n                stage1();\n                break;\n            case 2:\n                if (flag) {\n                    for (int j = -1; j < 2; j++) {\n                        gp.zombiler.add(new TukurenZombi(gp, 100, 1000 + 200 * j));\n                        gp.zombiler.add(new TukurenZombi(gp, gp.map.mapWidth - 100, 1000 + 200 * j));\n                    }\n                    zombiSpawned += 6;\n                    flag = false;\n                }\n                stage2();\n                break;\n            case 3:\n                stage3();\n                break;\n            case 4:\n                if (flag) {\n                    gp.zombiler.add(new SurungenZombi(gp, 1000, 500));\n                    zombiSpawned++;\n                    flag = false;\n                }\n                stage4();\n                break;\n            case 5:\n                stage5();\n                break;\n            case 6:\n                if (flag) {\n                    gp.zombiler.add(new SurungenZombi(gp, 1000, 250));\n                    zombiSpawned += 1;\n                    flag = false;\n                }\n                stage6();\n                break;\n            case 7:\n                if (flag) {\n                    for (int j = 0; j < 400; j++) {\n                        spawnDuzZombi();\n                    }\n                    for (int j = 0; j < 100; j++) {\n                        spawnTankZombi();\n                    }\n                    flag = false;\n                }\n                stage7();\n                break;\n        }\n    }\n\n    void stage1() {\n        if (counter < gp.getFPS() * 3 || zombiSpawned > 29) {\n            return;\n        }\n        spawnDuzZombi();\n\n        counter = 0;\n    }\n\n    void stage2() {\n        if (counter < gp.getFPS() || zombiSpawned > 119) {\n            return;\n        }\n        int r = random.nextInt(1, 100);\n        if (r < 18) {\n            spawnTukurenZombi();\n        } else {\n            spawnDuzZombi();\n        }\n\n        counter = 0;\n    }\n\n    void stage3() {\n        if (counter < gp.getFPS() * 3 || zombiSpawned > 59) {\n            return;\n        }\n        int r = random.nextInt(1, 100);\n        if (r < 70) {\n            spawnTankZombi();\n        }\n        if (r > 50) {\n            spawnTukurenZombi();\n        }\n\n        counter = 0;\n    }\n\n    void stage4() {\n        if (counter < gp.getFPS() || zombiSpawned > 149) {\n            return;\n        }\n        int r = random.nextInt(1, 100);\n        if (r < 10) {\n            spawnSurungenZombi();\n        }\n        if (r > 80) {\n            spawnTankZombi();\n        }\n        if (r > 60 && r < 80) {\n            spawnTukurenZombi();\n        }\n        if (r > 10 && r < 60) {\n            spawnDuzZombi();\n        }\n\n        counter = 0;\n    }\n\n    void stage5() {\n        if (counter < gp.getFPS() * 2.5 || zombiSpawned > 149) {\n            return;\n        }\n        int r = random.nextInt(1, 100);\n        if (r < 20) {\n            spawnSurungenZombi();\n        }\n        if (r > 20 && r < 57) {\n            spawnDuzZombi();\n        }\n        if (r > 60) {\n            spawnTankZombi();\n        }\n\n        counter = 0;\n    }\n\n    void stage6() {\n        if (counter < gp.getFPS() * 3 / 2 || zombiSpawned > 249) {\n            return;\n        }\n        int r = random.nextInt(1, 100);\n        if (r < 10) {\n            spawnSurungenZombi();\n        }\n        if (r > 20 && r < 65) {\n            spawnDuzZombi();\n        }\n        if (r > 65 && r < 80) {\n            spawnTankZombi();\n        }\n        if (r > 83) {\n            spawnTukurenZombi();\n        }\n\n        counter = 0;\n    }\n\n    void stage7() {\n        if (counter < gp.getFPS() / 3 || zombiSpawned > 999) {\n            return;\n        }\n\n        int a = random.nextInt(0, 100);\n        if (a < 10) {\n            spawnSurungenZombi();\n        }\n        if (a < 40 && a > 10) {\n            spawnTankZombi();\n        }\n        if (a > 80) {\n            spawnTukurenZombi();\n        }\n        if (a > 40 && a < 80) {\n            spawnDuzZombi();\n        }\n\n        counter = 0;\n    }\n\n    void spawnDuzZombi() {\n        int x, y;\n        double distance;\n        do {\n            x = random.nextInt(10, gp.map.mapWidth - 10);\n            y = random.nextInt(10, gp.map.mapHeight - 10);\n            distance = Math.sqrt((x - gp.activeCharacter.x) * (x - gp.activeCharacter.x)\n                    + (y - gp.activeCharacter.y) * (y - gp.activeCharacter.y));\n        } while (distance < 300 && Math.abs(y - gp.activeCharacter.y) > 300);\n\n        gp.syncZombi.add(new DuzZombi(gp, x, y));\n        zombiSpawned++;\n    }\n\n    void spawnSurungenZombi() {\n        int x, y;\n        double distance;\n        do {\n            x = random.nextInt(10, gp.map.mapWidth - 10);\n            y = random.nextInt(10, gp.map.mapHeight - 10);\n            distance = Math.sqrt((x - gp.activeCharacter.x) * (x - gp.activeCharacter.x)\n                    + (y - gp.activeCharacter.y) * (y - gp.activeCharacter.y));\n        } while (distance < 550 && Math.abs(y - gp.activeCharacter.y) > 200);\n\n        gp.syncZombi.add(new SurungenZombi(gp, x, y));\n        zombiSpawned++;\n    }\n\n    void spawnTukurenZombi() {\n        int x, y;\n        double distance;\n        do {\n            x = random.nextInt(10, gp.map.mapWidth - 10);\n            y = random.nextInt(10, gp.map.mapHeight - 10);\n            distance = Math.sqrt((x - gp.activeCharacter.x) * (x - gp.activeCharacter.x)\n                    + (y - gp.activeCharacter.y) * (y - gp.activeCharacter.y));\n        } while (distance < 500);\n\n        gp.syncZombi.add(new TukurenZombi(gp, x, y));\n        zombiSpawned++;\n    }\n\n    void spawnTankZombi() {\n        int x, y;\n        double distance;\n        do {\n            x = random.nextInt(10, gp.map.mapWidth - 10);\n            y = random.nextInt(10, gp.map.mapHeight - 10);\n            distance = Math.sqrt((x - gp.activeCharacter.x) * (x - gp.activeCharacter.x)\n                    + (y - gp.activeCharacter.y) * (y - gp.activeCharacter.y));\n        } while (distance < 300);\n\n        gp.syncZombi.add(new TankZombi(gp, x, y));\n        zombiSpawned++;\n    }\n}\n",
      "Map.java": "package main;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class Map {\n    BufferedImage map;\n    public int mapWidth = 2000;\n    public int mapHeight = 2000;\n    GamePanel gp;\n\n    public Map(GamePanel gp) {\n        this.gp = gp;\n        try {\n            map = ImageIO.read(getClass().getResourceAsStream(\"/res/map/harita2.jpg\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        int x = (int) ((GamePanel.screenWidth / 2) - GamePanel.kamera.x);\n        int y = (int) ((GamePanel.screenHeight / 2) - GamePanel.kamera.y);\n\n        g2.drawImage(map, x, y, mapWidth, mapHeight, null);\n    }\n}\n",
      "Mermi.java": "package main;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.Vector;\n\nimport javax.imageio.ImageIO;\n\npublic class Mermi {\n\n    Vector<int[]> mermiler = new Vector<>();\n\n    GamePanel gp;\n\n    BufferedImage resim1, resim2;\n\n    public Mermi(GamePanel gp) {\n        this.gp = gp;\n\n        try {\n            resim1 = ImageIO.read(getClass().getResourceAsStream(\"/res/bullethit/bullethit1.png\"));\n            resim2 = ImageIO.read(getClass().getResourceAsStream(\"/res/bullethit/bullethit2.png\"));\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void add(int[] a) {\n        mermiler.add(a);\n    }\n\n    public void draw(Graphics2D g2) {\n        for (int i = mermiler.size() - 1; i >= 0; i--) {\n            int[] m = mermiler.get(i);\n            int screenx = (int) (m[0] - GamePanel.kamera.x + GamePanel.screenWidth / 2);\n            int screeny = (int) (m[1] - GamePanel.kamera.y + GamePanel.screenHeight / 2);\n\n            g2.drawImage(resim1, screenx - 25, screeny - 25, 50, 50, null);\n            g2.drawImage(resim2, screenx - 25, screeny - 25, 50, 50, null);\n\n            mermiler.get(i)[2]++;\n            if (mermiler.get(i)[2] > 60) {\n                mermiler.remove(i);\n            }\n        }\n    }\n}\n",
      "MyMouseListener.java": "package main;\n\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\npublic class MyMouseListener implements MouseMotionListener, MouseListener {\n\n    public int mouseX;\n    public int mouseY;\n\n    public boolean shooting;\n\n    GamePanel gp;\n\n    public void setGp(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        // System.out.println(\"mouse moved \" + e.getX() + \" \" + e.getY());\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        // System.out.println(\"mouse clicked \" + e.getX() + \" \" + e.getY());\n        if (GamePanel.gameState == GamePanel.gamePause) {\n            int upperLefty = (GamePanel.screenHeight - 600) / 2;\n            if (e.getX() > 60 && e.getX() < 800) {\n                if (e.getY() > upperLefty && e.getY() < upperLefty + 120) {\n                    GamePanel.gameState = GamePanel.gamePlay;\n                } else if (e.getY() > upperLefty + 120 && e.getY() < upperLefty + 240) {\n                    // System.out.println(\"Kayıt\");\n                    // Kaydet\n                    try {\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"src\\\\save\\\\save1.bin\"));\n\n                        oos.writeObject(gp.stageUnlocked);\n                        oos.writeInt(gp.stage);\n\n                        oos.writeDouble(gp.leon.x);\n                        oos.writeDouble(gp.leon.y);\n                        oos.writeDouble(gp.claire.x);\n                        oos.writeDouble(gp.claire.y);\n\n                        oos.writeInt(gp.leon.health);\n                        oos.writeInt(gp.claire.health);\n\n                        oos.writeInt(gp.leon.weapons[0].bullets);\n                        oos.writeInt(gp.leon.weapons[0].bulletsInMagazine);\n                        oos.writeInt(gp.leon.weapons[1].bullets);\n                        oos.writeInt(gp.leon.weapons[1].bulletsInMagazine);\n                        oos.writeInt(gp.leon.weapons[2].bullets);\n                        oos.writeInt(gp.leon.weapons[2].bulletsInMagazine);\n\n                        oos.writeInt(gp.claire.weapons[0].bullets);\n                        oos.writeInt(gp.claire.weapons[0].bulletsInMagazine);\n                        oos.writeInt(gp.claire.weapons[1].bullets);\n                        oos.writeInt(gp.claire.weapons[1].bulletsInMagazine);\n\n                        oos.close();\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                        System.err.println(\"Oyun kaydedilemedi\");\n                    }\n                } else if (e.getY() > upperLefty + 240 && e.getY() < upperLefty + 360) {\n                    System.out.println(\"Yükleme\");\n                    // YÜKLE\n                    try {\n                        ObjectInputStream oos = new ObjectInputStream(new FileInputStream(\"src\\\\save\\\\save1.bin\"));\n\n                        gp.stageUnlocked = (boolean[]) oos.readObject();\n                        gp.stage = oos.readInt();\n\n                        oos.readDouble();\n                        oos.readDouble();\n                        oos.readDouble();\n                        oos.readDouble();\n\n                        oos.readInt();\n                        oos.readInt();\n\n                        gp.leon.weapons[0].bullets = oos.readInt();\n                        gp.leon.weapons[0].bulletsInMagazine = oos.readInt();\n                        gp.leon.weapons[1].bullets = oos.readInt();\n                        gp.leon.weapons[1].bulletsInMagazine = oos.readInt();\n                        gp.leon.weapons[2].bullets = oos.readInt();\n                        gp.leon.weapons[2].bulletsInMagazine = oos.readInt();\n\n                        gp.claire.weapons[0].bullets = oos.readInt();\n                        gp.claire.weapons[0].bulletsInMagazine = oos.readInt();\n                        gp.claire.weapons[1].bullets = oos.readInt();\n                        gp.claire.weapons[1].bulletsInMagazine = oos.readInt();\n\n                        oos.close();\n                    } catch (IOException ex) {\n                        ex.printStackTrace();\n                        System.err.println(\"Oyun yüklenemedi\");\n                    } catch (ClassNotFoundException ex) {\n                        System.err.println(\"Class bulunamamış\");\n                    }\n                } else if (e.getY() > upperLefty + 360 && e.getY() < upperLefty + 480) {\n                    GamePanel.gameState = GamePanel.stageSelect;\n                } else if (e.getY() > upperLefty + 480 && e.getY() < upperLefty + 600) {\n                    System.exit(0);\n                }\n            }\n        } else if (GamePanel.gameState == GamePanel.stageSelect) {\n            int upperLefty = (GamePanel.screenHeight - 560) / 2;\n            if (e.getX() > 60 && e.getX() < 160) {\n                if (e.getY() > upperLefty - 80 && e.getY() < upperLefty) {\n                    System.out.println(\"stage1 pressed\");\n                    if (gp.stageUnlocked[0]) {\n                        gp.ss.setStage(1);\n                        gp.stage = 1;\n                        GamePanel.gameState = GamePanel.gamePlay;\n                    }\n                } else if (e.getY() > upperLefty && e.getY() < upperLefty + 80) {\n                    System.out.println(\"stage2 pressed\");\n                    if (gp.stageUnlocked[1]) {\n                        gp.ss.setStage(2);\n                        gp.stage = 2;\n                        GamePanel.gameState = GamePanel.gamePlay;\n                    }\n                } else if (e.getY() > upperLefty + 80 && e.getY() < upperLefty + 160) {\n                    if (gp.stageUnlocked[2]) {\n                        gp.ss.setStage(3);\n                        gp.stage = 3;\n                        GamePanel.gameState = GamePanel.gamePlay;\n                    }\n                } else if (e.getY() > upperLefty + 160 && e.getY() < upperLefty + 240) {\n                    if (gp.stageUnlocked[3]) {\n                        gp.ss.setStage(4);\n                        gp.stage = 4;\n                        GamePanel.gameState = GamePanel.gamePlay;\n                    }\n                } else if (e.getY() > upperLefty + 240 && e.getY() < upperLefty + 320) {\n                    if (gp.stageUnlocked[4]) {\n                        gp.ss.setStage(5);\n                        gp.stage = 5;\n                        GamePanel.gameState = GamePanel.gamePlay;\n                    }\n                } else if (e.getY() > upperLefty + 360 && e.getY() < upperLefty + 400) {\n                    if (gp.stageUnlocked[5]) {\n                        gp.ss.setStage(6);\n                        gp.stage = 6;\n                        GamePanel.gameState = GamePanel.gamePlay;\n                    }\n                } else if (e.getY() > upperLefty + 400 && e.getY() < upperLefty + 480) {\n                    if (gp.stageUnlocked[6]) {\n                        gp.ss.setStage(7);\n                        gp.stage = 7;\n                        GamePanel.gameState = GamePanel.gamePlay;\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        if (e.getButton() == MouseEvent.BUTTON1) {\n            shooting = true;\n        }\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        if (e.getButton() == MouseEvent.BUTTON1) {\n            shooting = false;\n        }\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e) {\n    }\n\n}\n",
      "PauseScreen.java": "package main;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\n\npublic class PauseScreen {\n    GamePanel gp;\n    int upperLeftx = 60;\n    int upperLefty = (GamePanel.screenHeight - 600) / 2;\n    Font f = new Font(\"Arial\", Font.BOLD, 100);\n    String[] menuItems = { \"DEVAM ET\", \"OYUNU KAYDET\", \"OYUN YÜKLE\", \"BÖLÜM SEÇ\", \"OYUNDAN ÇIK\" };\n\n    public PauseScreen(GamePanel gp) {\n        this.gp = gp;\n\n    }\n\n    public void update() {\n\n    }\n\n    public void drawPauseScreen(Graphics2D g2) {\n\n        g2.setColor(new Color(255, 255, 255, 200));\n        g2.setStroke(new BasicStroke(1));\n        g2.setFont(f);\n        for (int i = 1; i < 6; i++) {\n            int y = upperLefty + i * 120;\n            g2.drawRect(upperLeftx, y - 120, 800, 120);\n            g2.drawString(menuItems[i - 1], upperLeftx + 10, y - 10);\n        }\n    }\n}\n",
      "Sound.java": "package main;\n\nimport java.net.URL;\n\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\n\npublic class Sound {\n\n    Clip clip;\n    URL[] soundURL = new URL[20];\n\n    public Sound() {\n        soundURL[0] = getClass().getResource(\"/res/sound/music/Fark Var.wav\");\n        soundURL[1] = getClass().getResource(\"/res/sound/music/Nine Thou Superstars Remix (Explict).wav\");\n        soundURL[2] = getClass().getResource(\"/res/sound/weapon/buckyTap.wav\");\n        soundURL[3] = getClass().getResource(\"/res/sound/weapon/operatorTap.wav\");\n        soundURL[4] = getClass().getResource(\"/res/sound/weapon/vandalTap.wav\");\n        soundURL[5] = getClass().getResource(\"/res/sound/weapon/sheriffTap.wav\");\n        soundURL[6] = getClass().getResource(\"/res/sound/weapon/jett.wav\");\n        soundURL[7] = getClass().getResource(\"/res/sound/weapon/tnt.wav\");\n        soundURL[8] = getClass().getResource(\"/res/sound/music/jw.wav\");\n        soundURL[9] = getClass().getResource(\"/res/sound/music/doom.wav\");\n        soundURL[10] = getClass().getResource(\"/res/sound/weapon/buckyReload.wav\");\n        soundURL[11] = getClass().getResource(\"/res/sound/weapon/operatorReload.wav\");\n        soundURL[12] = getClass().getResource(\"/res/sound/weapon/sheriffReload.wav\");\n        soundURL[13] = getClass().getResource(\"/res/sound/weapon/vandalReload.wav\");\n    }\n\n    public void setFile(int i) {\n        try {\n            AudioInputStream ais = AudioSystem.getAudioInputStream(soundURL[i]);\n            clip = AudioSystem.getClip();\n            clip.open(ais);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public void play() {\n        clip.start();\n    }\n\n    public void loop() {\n        clip.loop(Clip.LOOP_CONTINUOUSLY);\n    }\n\n    public void stop() {\n        clip.stop();\n    }\n}\n",
      "LoadingPage.java": "package main;\n\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JPanel;\n\npublic class LoadingPage extends JPanel implements Runnable {\n    public int screenWidth;\n    public int screenHeight;\n\n    int frameCounter = 0;\n\n    BufferedImage[] openingFrames = new BufferedImage[30];\n    public Thread loadingThread;\n    Font font = new Font(\"Arial\", Font.BOLD, 50);\n\n    Sound music = new Sound();\n\n    public LoadingPage(int screenWidth, int screenHeight) {\n        setVisible(false);\n\n        this.screenWidth = screenWidth;\n        this.screenHeight = screenHeight;\n        setPreferredSize(new Dimension(screenWidth, screenHeight));\n        getOpeningFrames();\n\n        // playMusic(1);\n    }\n\n    @Override\n    public void run() {\n        double drawInterval = 1000000000 / 5;\n        double delta = 0;\n        long lastTime = System.nanoTime();\n        long currentTime;\n\n        while (!loadingThread.isInterrupted()) {\n            currentTime = System.nanoTime();\n            delta += (currentTime - lastTime) / drawInterval;\n            lastTime = currentTime;\n\n            if (delta > 0) {\n                frameCounter++;\n                if (frameCounter > 29) {\n                    frameCounter = 0;\n                }\n\n                repaint();\n                delta--;\n            }\n        }\n\n    }\n\n    public void startLoadingPage() {\n        loadingThread = new Thread(this);\n        loadingThread.setName(\"Loading Thread\");\n        loadingThread.start();\n    }\n\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n        Graphics2D g2 = (Graphics2D) g;\n        g2.drawImage(openingFrames[frameCounter], 0, 0, screenWidth, screenHeight, null);\n        g2.setFont(font);\n        g2.drawString(\"Dosyalar yükleniyor...\", 10, screenHeight - 10);\n    }\n\n    void getOpeningFrames() {\n        String path = \"/res/opening/ezgif-frame-\";\n        try {\n            for (int i = 1; i < 31; i++) {\n                String path2;\n                if (i < 10) {\n                    path2 = path + \"00\" + i;\n                } else {\n                    path2 = path + \"0\" + i;\n                }\n                path2 += \".jpg\";\n                openingFrames[i - 1] = ImageIO.read(getClass().getResourceAsStream(path2));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void playMusic(int i) {\n        music.setFile(i);\n        music.play();\n        music.loop();\n    }\n\n    public void stopMusic() {\n        music.stop();\n    }\n\n}\n",
      "Kamera.java": "package main;\n\npublic class Kamera {\n    public double x;\n    public double y;\n    GamePanel gp;\n\n    Kamera(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    public void setCoordinates() {\n        x = gp.activeCharacter.x;\n        y = gp.activeCharacter.y;\n\n        if (x < GamePanel.screenWidth / 2) {\n            x = GamePanel.screenWidth / 2;\n        }\n        if (y < GamePanel.screenHeight / 2) {\n            y = GamePanel.screenHeight / 2;\n        }\n        if (x > gp.map.mapWidth - GamePanel.screenWidth / 2) {\n            x = gp.map.mapWidth - GamePanel.screenWidth / 2;\n        }\n        if (y > gp.map.mapHeight - GamePanel.screenHeight / 2) {\n            y = gp.map.mapHeight - GamePanel.screenHeight / 2;\n        }\n    }\n}\n",
      "StageSetter.java": "package main;\n\npublic class StageSetter {\n\n    GamePanel gp;\n\n    public StageSetter(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    public void setStage(int i) {\n        gp.ammunation.removeAll(gp.ammunation);\n        gp.zombiler.removeAll(gp.zombiler);\n        gp.leon.health = 100;\n        gp.claire.health = 100;\n        gp.leon.x = gp.map.mapWidth / 2;\n        gp.leon.y = gp.map.mapHeight / 2;\n        gp.claire.x = gp.map.mapWidth / 2;\n        gp.claire.y = gp.map.mapHeight / 2;\n\n        gp.zs.flag = true;\n        gp.zs.zombiSpawned = 0;\n\n        switch (i) {\n            case 1:\n                stage1();\n                break;\n            case 2:\n                stage2();\n                break;\n            case 3:\n                stage3();\n                break;\n            case 4:\n                stage4();\n                break;\n            case 5:\n                stage5();\n                break;\n            case 6:\n                stage6();\n                break;\n            case 7:\n                stage7();\n                break;\n\n        }\n    }\n\n    void stage1() {\n        gp.claire.active = false;\n        gp.claire.isDashActive = false;\n        gp.claire.weapons[0].isActive = false;\n        gp.claire.weapons[1].isActive = false;\n        gp.leon.active = true;\n        gp.activeCharacter = gp.leon;\n        gp.leon.weapons[0].isActive = true;\n        gp.leon.weapons[1].isActive = false;\n        gp.leon.weapons[2].isActive = false;\n        gp.killTarget = 30;\n        gp.killCounter = 0;\n\n        gp.stopMusic();\n        gp.playMusic(1);\n    }\n\n    void stage2() {\n        gp.claire.active = false;\n        gp.claire.isDashActive = false;\n        gp.claire.weapons[0].isActive = true;\n        gp.claire.weapons[1].isActive = false;\n        gp.leon.active = true;\n        gp.activeCharacter = gp.leon;\n        gp.leon.weapons[0].isActive = true;\n        gp.leon.weapons[1].isActive = false;\n        gp.leon.weapons[2].isActive = false;\n        gp.killTarget = 120;\n        gp.killCounter = 0;\n\n        gp.stopMusic();\n        gp.playMusic(0);\n    }\n\n    void stage3() {\n        gp.claire.active = false;\n        gp.claire.isDashActive = false;\n        gp.claire.weapons[0].isActive = true;\n        gp.claire.weapons[1].isActive = false;\n        gp.leon.active = true;\n        gp.activeCharacter = gp.leon;\n        gp.leon.weapons[0].isActive = true;\n        gp.leon.weapons[1].isActive = false;\n        gp.leon.weapons[2].isActive = false;\n        gp.killTarget = 60;\n        gp.killCounter = 0;\n\n        gp.stopMusic();\n        gp.playMusic(9);\n    }\n\n    void stage4() {\n        gp.claire.active = false;\n        gp.claire.isDashActive = false;\n        gp.claire.weapons[0].isActive = true;\n        gp.claire.weapons[1].isActive = false;\n        gp.leon.active = true;\n        gp.activeCharacter = gp.leon;\n        gp.leon.weapons[0].isActive = true;\n        gp.leon.weapons[1].isActive = true;\n        gp.leon.weapons[2].isActive = false;\n        gp.killTarget = 150;\n        gp.killCounter = 0;\n\n        if (gp.leon.weapons[1].bullets < 20) {\n            gp.leon.weapons[1].bullets = 30;\n\n        }\n        gp.leon.weapons[1].bulletsInMagazine = 6;\n\n        gp.stopMusic();\n        gp.playMusic(8);\n    }\n\n    void stage5() {\n        gp.claire.active = false;\n        gp.claire.isDashActive = false;\n        gp.claire.weapons[0].isActive = true;\n        gp.claire.weapons[1].isActive = false;\n        gp.leon.active = true;\n        gp.activeCharacter = gp.leon;\n        gp.leon.weapons[0].isActive = true;\n        gp.leon.weapons[1].isActive = true;\n        gp.leon.weapons[2].isActive = false;\n        gp.killTarget = 150;\n        gp.killCounter = 0;\n\n        gp.stopMusic();\n        gp.playMusic(1);\n    }\n\n    void stage6() {\n        gp.claire.active = false;\n        gp.claire.isDashActive = true;\n        gp.claire.weapons[0].isActive = true;\n        gp.claire.weapons[1].isActive = true;\n        gp.leon.active = true;\n        gp.activeCharacter = gp.leon;\n        gp.leon.weapons[0].isActive = true;\n        gp.leon.weapons[1].isActive = true;\n        gp.leon.weapons[2].isActive = false;\n        gp.killTarget = 250;\n        gp.killCounter = 0;\n\n        if (gp.claire.weapons[1].bullets < 20) {\n            gp.claire.weapons[1].bullets = 20;\n        }\n\n        gp.stopMusic();\n        gp.playMusic(0);\n    }\n\n    void stage7() {\n        gp.claire.active = true;\n        gp.activeCharacter = gp.claire;\n        gp.claire.weapons[0].isActive = true;\n        gp.claire.weapons[1].isActive = true;\n        gp.claire.isDashActive = true;\n        gp.leon.active = false;\n        gp.leon.weapons[0].isActive = true;\n        gp.leon.weapons[1].isActive = true;\n        gp.leon.weapons[2].isActive = true;\n        gp.killTarget = 1000;\n        gp.killCounter = 0;\n\n        gp.stopMusic();\n        gp.playMusic(0);\n    }\n\n}\n",
      "GamePanel.java": "package main;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.util.List;\nimport java.util.Vector;\nimport java.util.Collections;\n\nimport javax.swing.JPanel;\nimport entity.characters.*;\nimport entity.zombi.TukurenZombi;\nimport entity.zombi.Zombi;\nimport weapons.Ammunation;\nimport weapons.RPG;\n\npublic class GamePanel extends JPanel implements Runnable {\n\n    public static int screenWidth;\n    public static int screenHeight;\n\n    // STAGE VARIABLES\n    public static final int gamePause = 0;\n    public static final int gamePlay = 1;\n    public static final int stageSelect = 2;\n    public static int gameState = gamePlay;\n\n    private int FPS;\n    public int realFPS;\n\n    Font fpsFont = new Font(\"Arial\", Font.BOLD, 10);\n    Color fpsColor = new Color(255, 255, 255, 200);\n\n    public Thread gameThread;\n    public MyKeyListener input = new MyKeyListener();\n    public MyMouseListener mouse = new MyMouseListener();\n    StageSetter ss;\n\n    public int stage = 1;\n    // boolean[] stageUnlocked = { true, false, false, false, false, false, false };\n    boolean[] stageUnlocked = { true, true, true, true, true, true, true };\n    int killTarget;\n    int killCounter;\n\n    // Objects\n    public Map map;\n    public static Kamera kamera;\n    ZombiSpawner zs;\n    PauseScreen ps;\n    UI ui;\n    public Leon leon;\n    public Claire claire;\n    public MainCharacter activeCharacter;\n    Sound music = new Sound();\n\n    // Lists\n    public volatile Vector<Zombi> zombiler = new Vector<>();\n    public List<Zombi> syncZombi = Collections.synchronizedList(zombiler);\n\n    public Vector<RPG.Roket> roketler = new Vector<>();\n    public Mermi mermi = new Mermi(this);\n    public Vector<TukurenZombi.Tukuruk> tukurukler = new Vector<>();\n    public Vector<Ammunation> ammunation = new Vector<>(10);\n    public int maxAmmunation = 10;\n\n    public GamePanel() throws Exception {\n        setVisible(false);\n\n        screenHeight = 720;\n        screenWidth = 1280;\n        FPS = 240;\n\n        setPreferredSize(new Dimension(screenWidth, screenHeight));\n        setBackground(Color.black);\n        setFocusable(true);\n\n        this.setDoubleBuffered(true);\n        this.addKeyListener(input);\n        input.setGp(this);\n        this.addMouseListener(mouse);\n        this.addMouseMotionListener(mouse);\n        mouse.setGp(this);\n\n        // SETUP GAME\n        map = new Map(this);\n        kamera = new Kamera(this);\n        zs = new ZombiSpawner(this);\n        ps = new PauseScreen(this);\n        ss = new StageSetter(this);\n        ui = new UI(this);\n\n        // Karakter resimleri\n        try {\n            claire = new Claire(this, input, mouse);\n            leon = new Leon(this, input, mouse);\n            leon.setClaire(claire);\n            claire.setLeon(leon);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new Exception(\"Karakterler yuklenemedi\");\n        }\n        // Diğer resimler\n        AssetSetter as = new AssetSetter();\n        as.setAsset();\n\n        // STAGE\n        playMusic(1);\n        ss.setStage(stage);\n\n        leon.weapons[2].bullets = 50;\n        claire.weapons[1].bullets = 200;\n    }\n\n    public void startGameThread() {\n        gameThread = new Thread(this);\n        gameThread.setName(\"Game Panel\");\n        gameThread.start();\n    }\n\n    @Override\n    public void run() {\n        double drawInterval = 1000000000 / FPS;\n        double delta = 0;\n        long lastTime = System.nanoTime();\n        long currentTime;\n        long timer = 0;\n        int drawCount = 0;\n        while (gameThread != null) {\n            currentTime = System.nanoTime();\n            timer += currentTime - lastTime;\n            delta += (currentTime - lastTime) / drawInterval;\n            lastTime = currentTime;\n\n            if (delta > 0) {\n                try {\n                    update();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.err.println(\"update metodunda hata var\");\n                    System.exit(0);\n                }\n                repaint();\n                delta--;\n                drawCount++;\n            }\n\n            if (timer >= 1000000000) {\n                realFPS = drawCount;\n                // System.out.println(realFPS);\n                timer = 0;\n                drawCount = 0;\n            }\n        }\n    }\n\n    public void update() {\n        if (gameState == gamePlay) {\n            // Karakterler\n            if (leon.health > 0 && claire.health > 0) {\n                leon.update();\n                claire.update();\n            }\n\n            // Zombi spawn ve update\n            zs.spawnZombi(stage);\n\n            for (int i = syncZombi.size() - 1; i >= 0; i--) {\n                Zombi z = syncZombi.get(i);\n                if (z.isAlive == false) {\n                    killCounter++;\n                    syncZombi.remove(i);\n                    continue;\n                }\n                z.update();\n            }\n\n            // Roket update\n            for (int i = roketler.size() - 1; i >= 0; i--) {\n                if (roketler.get(i).remove) {\n                    roketler.remove(i);\n                } else {\n                    roketler.get(i).update();\n                }\n            }\n            // Tukuruk\n            for (int i = tukurukler.size() - 1; i >= 0; i--) {\n                if (tukurukler.get(i).remove) {\n                    tukurukler.remove(i);\n                } else {\n                    tukurukler.get(i).update();\n                }\n            }\n\n        } else if (gameState == gamePause) {\n            ps.update();\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n        Graphics2D g2 = (Graphics2D) g;\n\n        if (gameState == gamePlay) {\n            kamera.setCoordinates();\n\n            map.draw(g2);\n            // ZOMBİLER\n            for (int i = 0; i < syncZombi.size(); i++) {\n                syncZombi.get(i).draw(g2);\n            }\n            // CEPHANE\n            for (int i = ammunation.size() - 1; i >= 0; i--) {\n                if (ammunation.get(i).remove) {\n                    ammunation.remove(i);\n                    continue;\n                }\n                ammunation.get(i).draw(g2);\n            }\n            // KARAKTER\n            if (leon.y > claire.y) {\n                claire.draw(g2);\n                leon.draw(g2);\n            } else {\n                leon.draw(g2);\n                claire.draw(g2);\n            }\n\n            // mermiler\n            mermi.draw(g2);\n            // tükürük\n            for (int i = tukurukler.size() - 1; i >= 0; i--) {\n                tukurukler.get(i).draw(g2);\n            }\n            // SİLAH\n            leon.weapon.draw(g2);\n            claire.weapon.draw(g2);\n            // UI\n            ui.update();\n            ui.draw(g2);\n\n        } else if (gameState == gamePause) {\n            ps.drawPauseScreen(g2);\n        } else if (gameState == stageSelect) {\n            int upperLeftx = 60;\n            int upperLefty = (screenHeight - 560) / 2;\n\n            Font f = new Font(\"Arial\", Font.BOLD, 60);\n            g2.setColor(new Color(255, 255, 255, 200));\n            g2.setFont(f);\n            for (int i = 1; i < 8; i++) {\n                g2.drawString(\"\" + i, upperLeftx + 10, upperLefty - 80 + i * 80 - 10);\n            }\n        }\n\n        g2.setColor(fpsColor);\n        g2.setFont(fpsFont);\n        g2.drawString(\"FPS:\" + realFPS, 5, 10);\n    }\n\n    public int getFPS() {\n        return FPS;\n    }\n\n    public void setFPS(int fPS) {\n        FPS = fPS;\n    }\n\n    public void playMusic(int i) {\n        music.setFile(i);\n        music.play();\n        music.loop();\n    }\n\n    public void stopMusic() {\n        music.stop();\n    }\n\n}\n",
      "UI.java": "package main;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\n\npublic class UI {\n\n    GamePanel gp;\n    String bullet;\n    Font font = new Font(\"Arial\", Font.BOLD, 40);\n    private int healthBarBottom = GamePanel.screenWidth - 70;;\n\n    public UI(GamePanel gp) {\n        this.gp = gp;\n\n    }\n\n    public void update() {\n        int bulletCount = gp.activeCharacter.weapon.bullets;\n        int bulletsInMagazine = gp.activeCharacter.weapon.bulletsInMagazine;\n        bullet = String.format(\"%4d/%2d\", bulletCount, bulletsInMagazine);\n    }\n\n    public void draw(Graphics2D g2) {\n        g2.setStroke(new BasicStroke(1));\n        // Mermi\n        g2.setColor(Color.white);\n        g2.setFont(font);\n        g2.drawString(bullet, 20, 70);\n\n        // Can\n        g2.setColor(Color.white);\n        g2.drawRect(GamePanel.screenWidth - 120, 20, 100, 7);\n        g2.setColor(Color.blue);\n        g2.fillRect(healthBarBottom, 21, gp.leon.health / 2, 5);\n        g2.setColor(new Color(255, 0, 220));\n        g2.fillRect(healthBarBottom - gp.claire.health / 2, 21, gp.claire.health / 2, 5);\n\n        // Hedef\n        if (gp.killCounter >= gp.killTarget) {\n            g2.setColor(Color.yellow);\n            g2.setFont(font.deriveFont(60f));\n            g2.drawString(\"Bölüm Tamamlandı\", GamePanel.screenWidth / 2 - 300, GamePanel.screenHeight / 2 - 50);\n            g2.setFont(font.deriveFont(15f));\n            g2.drawString(\"Sonraki bölümün kilidi açıldı\", GamePanel.screenWidth / 2 - 70,\n                    GamePanel.screenHeight / 2 + 100);\n            gp.stageUnlocked[gp.stage] = true;\n        } else {\n            g2.setColor(Color.white);\n            g2.setFont(font.deriveFont(15f));\n            g2.drawString(\"Kalan Zombi : \" + (gp.killTarget - gp.killCounter), GamePanel.screenWidth / 2 - 30,\n                    GamePanel.screenHeight - 50);\n        }\n\n        // KAYBETTİN\n        if (gp.leon.health <= 0 || gp.claire.health <= 0) {\n            g2.setColor(Color.red);\n            g2.setFont(font.deriveFont(80f));\n            g2.drawString(\"ÖLDÜN\", GamePanel.screenWidth / 2 - 130, GamePanel.screenHeight / 2);\n            g2.drawString(\"Tekrar Dene\", GamePanel.screenWidth / 2 - 230, GamePanel.screenHeight / 2 + 120);\n        }\n    }\n}\n",
      "AssetSetter.java": "package main;\n\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport entity.zombi.DuzZombi;\nimport entity.zombi.SurungenZombi;\nimport entity.zombi.TankZombi;\nimport entity.zombi.TukurenZombi;\nimport weapons.Ammunation;\nimport weapons.RPG;\n\npublic class AssetSetter {\n    public void setAsset() throws IOException {\n        readZombiSprites();\n        TukurenZombi.image[0] = ImageIO.read(getClass().getResourceAsStream(\"/res/tukurenZombi/right.png\"));\n        TukurenZombi.image[1] = ImageIO.read(getClass().getResourceAsStream(\"/res/tukurenZombi/left.png\"));\n        readRoketSprites();\n\n        Ammunation.image = ImageIO.read(getClass().getResourceAsStream(\"/res/ammunation1.png\"));\n    }\n\n    void readZombiSprites() throws IOException {\n        readDuzZombiSprites();\n        readTankZombiSprites();\n        readSurungenSprites();\n    }\n\n    void readDuzZombiSprites() throws IOException {\n        try {\n\n            DuzZombi.walkCycle[0][0] = ImageIO.read(getClass().getResourceAsStream(\"/res/duzZombi/walk/right0.png\"));\n            DuzZombi.walkCycle[0][1] = ImageIO.read(getClass().getResourceAsStream(\"/res/duzZombi/walk/right1.png\"));\n            DuzZombi.walkCycle[1][0] = ImageIO.read(getClass().getResourceAsStream(\"/res/duzZombi/walk/left0.png\"));\n            DuzZombi.walkCycle[1][1] = ImageIO.read(getClass().getResourceAsStream(\"/res/duzZombi/walk/left1.png\"));\n\n            DuzZombi.attackAnimation[0][0] = ImageIO\n                    .read(getClass().getResourceAsStream(\"/res/duzZombi/walk/rightAttack0.png\"));\n            DuzZombi.attackAnimation[0][1] = ImageIO\n                    .read(getClass().getResourceAsStream(\"/res/duzZombi/walk/rightAttack1.png\"));\n            DuzZombi.attackAnimation[1][0] = ImageIO\n                    .read(getClass().getResourceAsStream(\"/res/duzZombi/walk/leftAttack0.png\"));\n            DuzZombi.attackAnimation[1][1] = ImageIO\n                    .read(getClass().getResourceAsStream(\"/res/duzZombi/walk/leftAttack1.png\"));\n\n            for (int i = 0; i < 4; i++) {\n                DuzZombi.death[0][i] = ImageIO\n                        .read(getClass().getResourceAsStream(\"/res/duzZombi/death/rightdeath\" + i + \".png\"));\n                DuzZombi.death[1][i] = ImageIO\n                        .read(getClass().getResourceAsStream(\"/res/duzZombi/death/leftdeath\" + i + \".png\"));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new IOException(\"Normal zombi resimleri yüklenmedi\");\n        }\n    }\n\n    void readTankZombiSprites() {\n        try {\n            TankZombi.walkCycle[0][0] = ImageIO.read(getClass().getResourceAsStream(\"/res/TankZombi/walk1.png\"));\n            TankZombi.walkCycle[0][1] = ImageIO.read(getClass().getResourceAsStream(\"/res/TankZombi/walk2.png\"));\n            TankZombi.walkCycle[0][2] = ImageIO.read(getClass().getResourceAsStream(\"/res/TankZombi/walk3.png\"));\n            TankZombi.walkCycle[0][3] = ImageIO.read(getClass().getResourceAsStream(\"/res/TankZombi/walk4.png\"));\n            TankZombi.walkCycle[1][0] = ImageIO.read(getClass().getResourceAsStream(\"/res/TankZombi/left1.png\"));\n            TankZombi.walkCycle[1][1] = ImageIO.read(getClass().getResourceAsStream(\"/res/TankZombi/left2.png\"));\n            TankZombi.walkCycle[1][2] = ImageIO.read(getClass().getResourceAsStream(\"/res/TankZombi/left3.png\"));\n            TankZombi.walkCycle[1][3] = ImageIO.read(getClass().getResourceAsStream(\"/res/TankZombi/left4.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.err.println(\"Tank zombi resimleri yüklenemedi\");\n        }\n    }\n\n    void readSurungenSprites() {\n        try {\n            SurungenZombi.attackAnimation[0] = ImageIO\n                    .read(getClass().getResourceAsStream(\"/res/Surungen/dashRight/1.png\"));\n            SurungenZombi.attackAnimation[1] = ImageIO\n                    .read(getClass().getResourceAsStream(\"/res/Surungen/dashLeft/1.png\"));\n\n            for (int i = 1; i < 25; i++) {\n                String path1 = \"/res/Surungen/walkRight/\";\n                String path2 = \"/res/Surungen/walkLeft/\";\n\n                if (i < 10) {\n                    path1 += \"000\" + i + \".png\";\n                    path2 += \"000\" + i + \".png\";\n                } else {\n                    path1 += \"00\" + i + \".png\";\n                    path2 += \"00\" + i + \".png\";\n                }\n\n                SurungenZombi.walkCycle[0][i - 1] = ImageIO.read(getClass().getResourceAsStream(path1));\n                SurungenZombi.walkCycle[1][i - 1] = ImageIO.read(getClass().getResourceAsStream(path2));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.err.println(\"Surungen zombi resimleri yüklenmedi\");\n        }\n    }\n\n    void readRoketSprites() throws IOException {\n        try {\n            RPG.Roket.patlama[0] = ImageIO.read(getClass().getResourceAsStream(\"/res/roket/001.png\"));\n            RPG.Roket.patlama[1] = ImageIO.read(getClass().getResourceAsStream(\"/res/roket/002.png\"));\n            RPG.Roket.patlama[2] = ImageIO.read(getClass().getResourceAsStream(\"/res/roket/003.png\"));\n            RPG.Roket.patlama[3] = ImageIO.read(getClass().getResourceAsStream(\"/res/roket/004.png\"));\n            RPG.Roket.patlama[4] = ImageIO.read(getClass().getResourceAsStream(\"/res/roket/005.png\"));\n            RPG.Roket.patlama[5] = ImageIO.read(getClass().getResourceAsStream(\"/res/roket/006.png\"));\n            RPG.Roket.patlama[6] = ImageIO.read(getClass().getResourceAsStream(\"/res/roket/007.png\"));\n            RPG.Roket.patlama[7] = ImageIO.read(getClass().getResourceAsStream(\"/res/roket/008.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new IOException(\"Roket resimleri yüklenmedi\");\n        }\n\n    }\n}\n",
      "MyKeyListener.java": "package main;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\nimport entity.characters.Claire;\nimport entity.characters.Leon;\n\npublic class MyKeyListener implements KeyListener {\n\n    Leon leon;\n    Claire claire;\n    GamePanel gp;\n\n    public boolean upPressed, downPressed, leftPressed, rightPressed;\n\n    public void setLeon(Leon leon) {\n        this.leon = leon;\n    }\n\n    public void setClaire(Claire claire) {\n        this.claire = claire;\n    }\n\n    public void setGp(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n        char code = e.getKeyChar();\n\n        if (code == ' ') {\n            if (leon.active) {\n                leon.dash();\n            }\n            if (claire.active) {\n                claire.dash();\n            }\n\n        }\n        if (code == 'q' || code == 'Q') {\n            gp.activeCharacter.changeWeapon();\n        }\n        if (code == 'r' || code == 'R') {\n            gp.activeCharacter.weapon.relaod();\n        }\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int code = e.getKeyCode();\n\n        if (code == KeyEvent.VK_W) {\n            upPressed = true;\n        }\n        if (code == KeyEvent.VK_S) {\n            downPressed = true;\n        }\n        if (code == KeyEvent.VK_A) {\n            leftPressed = true;\n        }\n        if (code == KeyEvent.VK_D) {\n            rightPressed = true;\n        }\n        if (code == KeyEvent.VK_T) {\n            if (leon.active) {\n                if (gp.claire.weapons[0].isActive) {\n                    gp.activeCharacter = gp.claire;\n                    leon.active = !leon.active;\n                    claire.active = !claire.active;\n                }\n\n            } else {\n                gp.activeCharacter = gp.leon;\n                leon.active = !leon.active;\n                claire.active = !claire.active;\n            }\n\n        }\n        if (code == KeyEvent.VK_ESCAPE) {\n            if (GamePanel.gameState == GamePanel.gamePause) {\n                GamePanel.gameState = GamePanel.gamePlay;\n            } else if (GamePanel.gameState == GamePanel.gamePlay) {\n                GamePanel.gameState = GamePanel.gamePause;\n            } else if (GamePanel.gameState == GamePanel.stageSelect) {\n                GamePanel.gameState = GamePanel.gamePause;\n            }\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int code = e.getKeyCode();\n\n        if (code == KeyEvent.VK_W) {\n            upPressed = false;\n        }\n        if (code == KeyEvent.VK_S) {\n            downPressed = false;\n        }\n        if (code == KeyEvent.VK_A) {\n            leftPressed = false;\n        }\n        if (code == KeyEvent.VK_D) {\n            rightPressed = false;\n        }\n    }\n\n}\n",
      "Game.java": "package main;\n\nimport java.awt.FlowLayout;\n\nimport javax.swing.JFrame;\n\npublic class Game {\n    public static void main(String[] args) throws Exception {\n        JFrame frame = new JFrame();\n        frame.setTitle(\"RE\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setResizable(false);\n\n        frame.setLayout(new FlowLayout());\n\n        LoadingPage lp = new LoadingPage(1280, 720);\n        frame.add(lp);\n        lp.setVisible(true);\n        frame.pack();\n\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n        lp.startLoadingPage();\n\n        try {\n            GamePanel gp = new GamePanel();\n            System.out.println(\"Game Panel yüklendi\");\n            frame.add(gp);\n            lp.setVisible(false);\n            lp.loadingThread.interrupt();\n            // lp.music.stop();\n            gp.setVisible(true);\n            gp.requestFocusInWindow();\n            frame.pack();\n            gp.startGameThread();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n",
      "Sniper.java": "package weapons;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.util.Vector;\n\nimport entity.zombi.Zombi;\nimport main.GamePanel;\n\npublic class Sniper extends Weapon {\n\n    public Sniper(GamePanel gp) {\n        this.gp = gp;\n\n        reloadSound = 11;\n\n        bullets = 10;\n        magazineCapacity = 5;\n        bulletsInMagazine = magazineCapacity;\n        reloadDuration = 2800;\n\n        length = 150;\n        damage = 200;\n        headShotDamage = 600;\n\n        shootingRate = 36;\n        shootingInterval = ((long) 1000000000 / shootingRate * 60);\n\n        coolDown = 0;\n        lastTime = System.nanoTime();\n    }\n\n    @Override\n    public void shoot(Vector<Zombi> zombies, double x, double y, double x2, double y2) {\n        coolDown += System.nanoTime() - lastTime;\n        lastTime = System.nanoTime();\n        if (coolDown < shootingInterval) {\n            return;\n        }\n\n        isShooting = true;\n        bulletsInMagazine--;\n\n        sortZombies(zombies);\n\n        for (int i = zombies.size() - 1; i >= 0; i--) {\n            if (checkCollision(((Zombi) zombies.get(i)), x, y, x2, y2)) {\n            }\n        }\n        lastshotx1 = (int) x;\n        lastshoty1 = (int) y;\n        lastshotx2 = (int) x2;\n        lastshoty2 = (int) y2;\n\n        coolDown = 0;\n\n        // SES\n        playSound(3);\n    }\n\n    public void draw(Graphics2D g2) {\n        if (isShooting) {\n            if (drawCount < 90) {\n                int x1 = (int) (lastshotx1 - GamePanel.kamera.x + GamePanel.screenWidth / 2);\n                int y1 = (int) (lastshoty1 - GamePanel.kamera.y + GamePanel.screenHeight / 2);\n                int x2 = (int) (lastshotx2 - GamePanel.kamera.x + GamePanel.screenWidth / 2);\n                int y2 = (int) (lastshoty2 - GamePanel.kamera.y + GamePanel.screenHeight / 2);\n\n                x2 += (x2 - x1) * 8;\n                y2 += (y2 - y1) * 8;\n\n                g2.setColor(new Color(200, 10, 200, 100));\n                g2.setStroke(new BasicStroke(8));\n                g2.drawLine(x1, y1, x2, y2);\n\n                g2.setColor(new Color(255, 245, 5));\n                g2.setStroke(new BasicStroke(2));\n                g2.drawLine(x1, y1, x2, y2);\n\n                drawCount++;\n            } else {\n                isShooting = false;\n                drawCount = 0;\n            }\n        }\n    }\n}\n",
      "Ammunation.java": "package weapons;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\n\nimport main.GamePanel;\n\npublic class Ammunation {\n    public static BufferedImage image;\n\n    public double x, y;\n    int WIDTH = 40;\n    int HEIGHT = 40;\n\n    public int quantity;\n    public String type;\n\n    public boolean remove = false;\n\n    public Ammunation(double x, double y, int num, String type) {\n        this.x = x;\n        this.y = y;\n        quantity = num;\n        this.type = type;\n    }\n\n    public void draw(Graphics2D g2) {\n        g2.drawImage(image, (int) (x - GamePanel.kamera.x + GamePanel.screenWidth / 2),\n                (int) (y - GamePanel.kamera.y + GamePanel.screenHeight / 2), WIDTH, HEIGHT, null);\n    }\n\n}\n",
      "Weapon.java": "package weapons;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.util.Vector;\n\nimport entity.characters.MainCharacter;\nimport entity.zombi.Zombi;\nimport main.GamePanel;\nimport main.Sound;\n\npublic abstract class Weapon {\n    public double length;\n    public long lastTime;\n    public long coolDown;\n    public int shootingRate;\n    public long shootingInterval;\n    public int damage;\n    public int headShotDamage;\n    public int bullets;\n    public int magazineCapacity;\n    public int bulletsInMagazine;\n\n    public boolean isActive = false;\n    MainCharacter character;\n    Sound sound = new Sound();\n    int reloadSound;\n\n    GamePanel gp;\n\n    int lastshotx1, lastshotx2, lastshoty1, lastshoty2;\n\n    boolean isShooting = false;\n    public boolean reloading = false;\n    public long reloadStartTime;\n    public int reloadDuration;\n    int drawCount = 0;\n\n    public int relativeweaponx = 0;\n    public int relativeweapony = -30;\n\n    public abstract void shoot(Vector<Zombi> zombies, double x, double y, double x2, double y2);\n\n    public boolean relaod() {\n        if (bullets <= 0) {\n            return false;\n        } else {\n            reloadStartTime = System.currentTimeMillis();\n            reloading = true;\n            playSound(reloadSound);\n            return true;\n        }\n    }\n\n    public boolean checkCollision(Zombi zombi, double x, double y, double x2, double y2) {\n        double c = (y2 - y) / (x2 - x);\n        double d = -(c * x) + y;\n        int[] kordinatlar = zombi.hitbox.checkCollision(c, d);\n        if (kordinatlar == null) {\n            return false;\n        }\n\n        double testx = (kordinatlar[0] - x) * (x2 - x);\n        double testy = (kordinatlar[1] - y) * (y2 - y);\n\n        if (testx >= 0 && testy >= 0) {\n            if (kordinatlar[2] == 0) {\n                zombi.hasarAl(headShotDamage);\n            } else {\n                zombi.hasarAl(damage);\n            }\n            int[] a = { kordinatlar[0], kordinatlar[1], 0 };\n            gp.mermi.add(a);\n            return true;\n        }\n        return false;\n    }\n\n    public void draw(Graphics2D g2) {\n        if (isShooting) {\n            if (drawCount < 2) {\n                int x1 = (int) (lastshotx1 - GamePanel.kamera.x + GamePanel.screenWidth / 2);\n                int y1 = (int) (lastshoty1 - GamePanel.kamera.y + GamePanel.screenHeight / 2);\n                int x2 = (int) (lastshotx2 - GamePanel.kamera.x + GamePanel.screenWidth / 2);\n                int y2 = (int) (lastshoty2 - GamePanel.kamera.y + GamePanel.screenHeight / 2);\n\n                g2.setColor(Color.yellow);\n                g2.setStroke(new BasicStroke(4));\n                g2.drawLine(x1, y1, x2, y2);\n\n                drawCount++;\n            } else {\n                isShooting = false;\n                drawCount = 0;\n            }\n        }\n    }\n\n    public void setCharacter(MainCharacter character) {\n        this.character = character;\n    }\n\n    void sortZombies(Vector<Zombi> zombies) {\n        for (int i = 0; i < zombies.size(); i++) {\n            boolean isSorted = true;\n            for (int j = 0; j < zombies.size() - 1 - i; j++) {\n                if (zombies.get(j).distanceToTarget < zombies.get(j + 1).distanceToTarget) {\n                    Zombi temp = zombies.get(j);\n                    zombies.set(j, zombies.get(j + 1));\n                    zombies.set(j + 1, temp);\n                    isSorted = false;\n                }\n            }\n            if (isSorted) {\n                break;\n            }\n        }\n    }\n\n    void playSound(int i) {\n        sound.setFile(i);\n        sound.play();\n    }\n\n}\n",
      "Gun.java": "package weapons;\n\nimport java.util.Vector;\n\nimport entity.zombi.Zombi;\nimport main.GamePanel;\n\npublic class Gun extends Weapon {\n\n    public Gun(GamePanel gp) {\n        this.gp = gp;\n\n        reloadSound = 12;\n\n        bullets = 9999;\n        magazineCapacity = 12;\n        bulletsInMagazine = magazineCapacity;\n        reloadDuration = 2500;\n\n        length = 60;\n        damage = 15;\n        headShotDamage = 60;\n        relativeweapony = -35;\n\n        shootingRate = 240;\n        shootingInterval = (long) (1000000000 / shootingRate * 60);\n\n        coolDown = 0;\n        lastTime = System.nanoTime();\n    }\n\n    @Override\n    public void shoot(Vector<Zombi> zombies, double x, double y, double x2, double y2) {\n        coolDown += System.nanoTime() - lastTime;\n        lastTime = System.nanoTime();\n        if (coolDown < shootingInterval) {\n            return;\n        }\n\n        isShooting = true;\n        bulletsInMagazine--;\n\n        sortZombies(zombies);\n\n        for (int i = zombies.size() - 1; i >= 0; i--) {\n            if (zombies.get(i).healt <= 0) {\n                continue;\n            }\n            if (checkCollision(((Zombi) zombies.get(i)), x, y, x2, y2)) {\n                break;\n            }\n        }\n        lastshotx1 = (int) x;\n        lastshoty1 = (int) y;\n        lastshotx2 = (int) x2;\n        lastshoty2 = (int) y2;\n\n        coolDown = 0;\n\n        // Silah sesi\n        playSound(5);\n    }\n\n}\n",
      "Shotgun.java": "package weapons;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.util.Vector;\n\nimport entity.zombi.Zombi;\nimport main.GamePanel;\n\npublic class Shotgun extends Weapon {\n\n    public Shotgun(GamePanel gp) {\n        this.gp = gp;\n\n        reloadSound = 10;\n\n        bullets = 10;\n        magazineCapacity = 6;\n        bulletsInMagazine = magazineCapacity;\n        reloadDuration = 3000;\n\n        length = 150;\n        damage = 20;\n        headShotDamage = 80;\n\n        shootingRate = 60;\n        shootingInterval = ((long) 1000000000 / shootingRate * 60);\n\n        coolDown = 0;\n        lastTime = System.nanoTime();\n    }\n\n    @Override\n    public void shoot(Vector<Zombi> zombies, double x, double y, double x2, double y2) {\n        coolDown += System.nanoTime() - lastTime;\n        lastTime = System.nanoTime();\n        if (coolDown < shootingInterval) {\n            return;\n        }\n\n        isShooting = true;\n        bulletsInMagazine--;\n\n        double teta;\n\n        if (x == x2) {\n            if (y - y2 > 0) {\n                teta = Math.PI / 2;\n            } else {\n                teta = Math.PI * 3 / 2;\n            }\n        } else {\n            teta = Math.atan((y - y2) / (x2 - x));\n            if (x2 < character.x) {\n                teta += Math.PI;\n            }\n        }\n\n        for (int j = -4; j < 5; j++) {\n            double teta2 = teta + Math.PI / 36 * j;\n            double yenix2 = x + Math.cos(teta2) * 100;\n            double yeniy2 = y - Math.sin(teta2) * 100;\n\n            for (int i = zombies.size() - 1; i >= 0; i--) {\n                if (zombies.get(i).healt <= 0) {\n                    continue;\n                }\n                if (checkCollision(((Zombi) zombies.get(i)), x, y, yenix2, yeniy2)) {\n                    break;\n                }\n            }\n        }\n\n        lastshotx1 = (int) x;\n        lastshoty1 = (int) y;\n        lastshotx2 = (int) x2;\n        lastshoty2 = (int) y2;\n\n        coolDown = 0;\n\n        // SES\n        playSound(2);\n    }\n\n    public void draw(Graphics2D g2) {\n        if (isShooting) {\n            if (drawCount < 10) {\n                int x1 = (int) (lastshotx1 - GamePanel.kamera.x + GamePanel.screenWidth / 2);\n                int y1 = (int) (lastshoty1 - GamePanel.kamera.y + GamePanel.screenHeight / 2);\n                int x2 = (int) (lastshotx2 - GamePanel.kamera.x + GamePanel.screenWidth / 2);\n                int y2 = (int) (lastshoty2 - GamePanel.kamera.y + GamePanel.screenHeight / 2);\n\n                double teta;\n\n                if (x1 == x2) {\n                    if (y1 - y2 > 0) {\n                        teta = Math.PI / 2;\n                    } else {\n                        teta = Math.PI * 3 / 2;\n                    }\n                } else {\n                    teta = Math.atan((double) (y1 - y2) / (x2 - x1));\n                    if (lastshotx2 < character.x) {\n                        teta += Math.PI;\n                    }\n                }\n\n                for (int j = -4; j < 5; j++) {\n                    double teta2 = teta + Math.PI / 36 * j;\n                    double yenix2 = x1 + Math.cos(teta2) * 100;\n                    double yeniy2 = y1 - Math.sin(teta2) * 100;\n\n                    yenix2 += (yenix2 - x1) * 10;\n                    yeniy2 += (yeniy2 - y1) * 10;\n\n                    g2.setColor(new Color(255, 10, 40, 100));\n                    g2.setStroke(new BasicStroke(4));\n                    g2.drawLine(x1, y1, (int) yenix2, (int) yeniy2);\n                }\n\n                drawCount++;\n            } else {\n                isShooting = false;\n                drawCount = 0;\n            }\n        }\n    }\n}\n",
      "Rifle.java": "package weapons;\n\nimport java.util.Random;\nimport java.util.Vector;\n\nimport entity.zombi.Zombi;\nimport main.GamePanel;\n\npublic class Rifle extends Weapon {\n\n    Random random;\n\n    public Rifle(GamePanel gp) {\n        this.gp = gp;\n\n        reloadSound = 13;\n\n        bullets = 30;\n        magazineCapacity = 30;\n        bulletsInMagazine = magazineCapacity;\n        reloadDuration = 1600;\n\n        length = 100;\n        damage = 30;\n        headShotDamage = 120;\n\n        shootingRate = 585;\n        shootingInterval = (long) (1000000000 / shootingRate * 60);\n\n        coolDown = 0;\n        lastTime = System.nanoTime();\n\n        random = new Random();\n    }\n\n    @Override\n    public void shoot(Vector<Zombi> zombies, double x, double y, double x2, double y2) {\n        coolDown += System.nanoTime() - lastTime;\n        lastTime = System.nanoTime();\n        if (coolDown < shootingInterval) {\n            return;\n        }\n\n        isShooting = true;\n        bulletsInMagazine--;\n\n        double teta;\n\n        if (x == x2) {\n            if (y - y2 > 0) {\n                teta = Math.PI / 2;\n            } else {\n                teta = Math.PI * 3 / 2;\n            }\n        } else {\n            teta = Math.atan((y - y2) / (x2 - x));\n            if (x2 < character.x) {\n                teta += Math.PI;\n            }\n        }\n\n        double teta2 = teta + Math.PI / 12 * (random.nextDouble() - 0.5);\n        double yenix2 = x + Math.cos(teta2) * 10000;\n        double yeniy2 = y - Math.sin(teta2) * 10000;\n\n        sortZombies(zombies);\n\n        for (int i = zombies.size() - 1; i >= 0; i--) {\n            if (zombies.get(i).healt <= 0) {\n                continue;\n            }\n            if (checkCollision(((Zombi) zombies.get(i)), x, y, yenix2, yeniy2)) {\n                break;\n            }\n        }\n        lastshotx1 = (int) x;\n        lastshoty1 = (int) y;\n        lastshotx2 = (int) yenix2;\n        lastshoty2 = (int) yeniy2;\n\n        coolDown = 0;\n\n        //\n        playSound(4);\n    }\n\n}\n",
      "RPG.java": "package weapons;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.Serializable;\nimport java.util.Vector;\n\nimport entity.zombi.Zombi;\nimport main.GamePanel;\nimport main.Sound;\n\npublic class RPG extends Weapon {\n\n    GamePanel gp;\n    Sound sound = new Sound();\n\n    public class Roket implements Serializable {\n        double x, y;\n        double targetx, targety;\n        double rawSpeed, speed;\n        double distance;\n        int spriteCounter = 0;\n        public boolean remove = false;\n        boolean isExploded = false;\n        GamePanel gp;\n\n        static Color color = new Color(250, 100, 20);\n        public static BufferedImage[] patlama = new BufferedImage[8];\n\n        public Roket(GamePanel gp, double x, double y, double targetx, double targety) {\n            this.gp = gp;\n            this.x = x;\n            this.y = y;\n            this.targetx = targetx;\n            this.targety = targety;\n\n            rawSpeed = 1;\n            speed = rawSpeed * gp.getFPS() / 60;\n        }\n\n        public void update() {\n            if (isExploded) {\n                return;\n            }\n\n            distance = Math.sqrt((targetx - x) * (targetx - x) + (targety - y) * (targety - y));\n\n            if (x > GamePanel.kamera.x + GamePanel.screenWidth / 2\n                    || y > GamePanel.kamera.y + GamePanel.screenHeight / 2\n                    || x < GamePanel.kamera.x - GamePanel.screenWidth / 2\n                    || y < GamePanel.kamera.y - GamePanel.screenHeight / 2) {\n                remove = true;\n                return;\n            }\n\n            if (distance <= speed) {\n                explode();\n                isExploded = true;\n            }\n\n            move();\n        }\n\n        void move() {\n            double speedx = targetx - x;\n            double speedy = targety - y;\n            speedx = speedx / distance * speed;\n            speedy = speedy / distance * speed;\n\n            x += speedx;\n            y += speedy;\n        }\n\n        void explode() {\n            Vector<Zombi> zombiler2 = gp.zombiler;\n\n            for (int i = zombiler2.size() - 1; i >= 0; i--) {\n                double dx = zombiler2.get(i).x - x;\n                double dy = zombiler2.get(i).y - y;\n\n                double distance2 = Math.sqrt(dy * dy + dx * dx);\n\n                if (distance2 < 200) {\n                    zombiler2.get(i).hasarAl(damage);\n                }\n            }\n\n            playSound(7);\n        }\n\n        public void draw(Graphics2D g2) {\n            int screenx = (int) (x - GamePanel.kamera.x + GamePanel.screenWidth / 2);\n            int screeny = (int) (y - GamePanel.kamera.y + GamePanel.screenHeight / 2);\n\n            if (isExploded) {\n                if (spriteCounter >= patlama.length * gp.getFPS() / 30) {\n                    remove = true;\n                    return;\n                } else {\n                    g2.drawImage(patlama[spriteCounter / (gp.getFPS() / 30)], (int) (screenx - 200),\n                            (int) (screeny - 200), 400,\n                            400, null);\n                    spriteCounter++;\n                }\n            } else {\n                g2.setColor(color);\n                g2.fillOval((int) (screenx - 10), (int) (screeny - 10), 20, 20);\n            }\n        }\n    }\n\n    public RPG(GamePanel gp) {\n        this.gp = gp;\n\n        bullets = 2;\n        magazineCapacity = 1;\n        bulletsInMagazine = magazineCapacity;\n        reloadDuration = 3000;\n        reloadSound = 11;\n\n        length = 150;\n        damage = 900;\n\n        shootingRate = 36;\n        shootingInterval = ((long) 1000000000 / shootingRate * 60);\n\n        coolDown = 0;\n\n        lastTime = System.nanoTime();\n    }\n\n    @Override\n    public void shoot(Vector<Zombi> zombies, double x, double y, double x2, double y2) {\n        coolDown += System.nanoTime() - lastTime;\n        lastTime = System.nanoTime();\n        if (coolDown < shootingInterval) {\n            return;\n        }\n\n        bulletsInMagazine--;\n\n        gp.roketler.add(new Roket(gp, x, y, x2, y2));\n        coolDown = 0;\n\n        playSound(2);\n    }\n\n    public boolean relaod() {\n        if (bullets <= 0) {\n            return false;\n        } else {\n            reloadStartTime = System.currentTimeMillis();\n            reloading = true;\n            return true;\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2) {\n        for (int i = gp.roketler.size() - 1; i >= 0; i--) {\n            gp.roketler.get(i).draw(g2);\n        }\n    }\n\n}\n"
    },
    {
      "id": "6494434",
      "Game.java": "package com.topdownshooter;\n\nimport javax.swing.*;\n\nimport com.topdownshooter.model.GameState;\nimport com.topdownshooter.util.FileIO;\nimport com.topdownshooter.view.GamePanel;\nimport com.topdownshooter.view.MainMenuPanel;\n\npublic class Game {\n\n    private JFrame frame;\n    private GamePanel gamePanel;\n\n    public Game() {\n        frame = new JFrame(\"Top-Down Shooter\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setResizable(false);\n        frame.setSize(800, 600);\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n\n        showMainMenu();\n    }\n\n    private void showMainMenu() {\n        MainMenuPanel menu = new MainMenuPanel(this);\n        frame.setContentPane(menu);\n        frame.revalidate();\n        menu.requestFocusInWindow();\n    }\n\n    public void startNewGame() {\n        gamePanel = new GamePanel();\n        frame.setContentPane(gamePanel);\n        frame.revalidate();\n        gamePanel.requestFocusInWindow();\n        gameLoop();\n    }\n\n    public void loadGame(GameState state) {\n        gamePanel = new GamePanel(state);\n        frame.setContentPane(gamePanel);\n        frame.revalidate();\n        gamePanel.requestFocusInWindow();\n        gameLoop();\n    }\n\n\n    private void gameLoop() {\n        Thread loop = new Thread(() -> {\n            final double fps = 60.0;\n            final double timePerTick = 1000000000 / fps;\n            double delta = 0;\n            long lastTime = System.nanoTime();\n\n            while (true) {\n                long now = System.nanoTime();\n                delta += (now - lastTime) / timePerTick;\n                lastTime = now;\n\n                if (delta >= 1) {\n                    gamePanel.update();\n                    gamePanel.repaint();\n                    delta--;\n                }\n            }\n        });\n        loop.start();\n    }\n\n    public static void main(String[] args) {\n        new Game();\n    }\n}\n",
      "InputHandler.java": "package com.topdownshooter.controller;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class InputHandler implements KeyListener {\n    private final Set<Integer> pressed = new HashSet<>();\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        pressed.add(e.getKeyCode());\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        pressed.remove(e.getKeyCode());\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {}\n\n    public boolean isPressed(int keyCode) {\n        return pressed.contains(keyCode);\n    }\n}\n",
      "Wave.java": "package com.topdownshooter.model;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class Wave implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private int waveNumber;\n    private int zombiesToSpawn;\n    private int spawnedCount;\n    private List<BaseZombie> activeZombies;\n    private Random rand = new Random();\n\n    public Wave(int waveNumber) {\n        this.waveNumber = waveNumber;\n        this.zombiesToSpawn = waveNumber * 5 + (int)(Math.pow(waveNumber, 1.5));\n        this.spawnedCount = 0;\n        this.activeZombies = new ArrayList<>();\n    }\n\n    public boolean isComplete() {\n        return spawnedCount >= zombiesToSpawn && activeZombies.isEmpty();\n    }\n\n    public void spawn(ZombieFactory factory, List<Bullet> bulletList) {\n        if (spawnedCount < zombiesToSpawn) {\n            int x = 0, y = 0;\n\n            int edge = rand.nextInt(4); // 0: Sol, 1: Sağ, 2: Üst, 3: Alt\n            switch (edge) {\n                case 0: x = 0; y = rand.nextInt(600); break;\n                case 1: x = 800 - 40; y = rand.nextInt(600); break;\n                case 2: x = rand.nextInt(800); y = 0; break;\n                case 3: x = rand.nextInt(800); y = 600 - 40; break;\n            }\n\n            String type = getZombieTypeForWave(waveNumber);\n            BaseZombie z = factory.createZombie(type, x, y);\n            if (z instanceof AcidZombie) {\n                ((AcidZombie) z).setBulletList(bulletList);\n            }\n\n            activeZombies.add(z);\n            spawnedCount++;\n        }\n    }\n\n    private String getZombieTypeForWave(int wave) {\n        List<String> types = new ArrayList<>();\n\n        if (wave >= 1) {\n            types.add(\"normal\");\n        }\n        if (wave >= 2) {\n            types.add(\"tank\");\n        }\n        if (wave >= 3) {\n            types.add(\"crawler\");\n        }\n        if (wave >= 4) {\n            types.add(\"acid\");\n        }\n\n        return types.get(rand.nextInt(types.size()));\n    }\n\n    public List<BaseZombie> getActiveZombies() {\n        return activeZombies;\n    }\n\n    public int getWaveNumber() {\n        return waveNumber;\n    }\n}\n",
      "Zombie.java": "package com.topdownshooter.model;\n\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.io.Serializable;\n\npublic class Zombie implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private double x, y;\n    private final double speed = 1.5;\n    private final int size = 32;\n    private int health = 50;\n\n    public Zombie(int startX, int startY) {\n        this.x = startX;\n        this.y = startY;\n    }\n\n    public void update(Player player) {\n        double dx = player.getX() - x;\n        double dy = player.getY() - y;\n        double dist = Math.hypot(dx, dy);\n        if (dist > 0) {\n            x += (dx / dist) * speed;\n            y += (dy / dist) * speed;\n        }\n    }\n\n    public void render(Graphics g) {\n        g.fillRect((int) x, (int) y, size, size);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle((int) x, (int) y, size, size);\n    }\n\n    public boolean isDead() {\n        return health <= 0;\n    }\n\n    public void damage(int amount) {\n        health -= amount;\n    }\n}\n",
      "PiercingBullet.java": "package com.topdownshooter.model;\n\nimport java.awt.*;\n\npublic class PiercingBullet extends Bullet {\n    private int hitsLeft = 3;\n\n    public PiercingBullet(int startX, int startY, int targetX, int targetY) {\n        super(startX, startY, targetX, targetY);\n        this.color = Color.YELLOW;\n        this.size = 8;\n    }\n\n    public void hit() {\n        hitsLeft--;\n    }\n\n    public boolean isActive() {\n        return hitsLeft > 0;\n    }\n\n    public int getHitsLeft() {\n        return hitsLeft;\n    }\n\n    public void deactivate() {\n        hitsLeft = 0;\n    }\n}\n",
      "AcidZombie.java": "package com.topdownshooter.model;\n\nimport java.awt.*;\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class AcidZombie extends BaseZombie implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private static final int WIDTH = 40;\n    private static final int HEIGHT = 40;\n    private static final int SHOOT_INTERVAL = 120; // 2 saniyede bir (60 FPS)\n    private int shootCooldown = 0;\n\n    private List<Bullet> bullets;\n\n    public AcidZombie() {\n        super(0, 0);\n        setStats();\n    }\n\n    public AcidZombie(int x, int y) {\n        super(x, y);\n        setStats();\n    }\n\n    @Override\n    protected void setStats() {\n        this.width = WIDTH;\n        this.height = HEIGHT;\n        this.health = 60;\n        this.speed = 3;\n        this.damage = 10;\n        this.color = Color.GREEN.darker();\n    }\n\n    public void setBulletList(List<Bullet> bullets) {\n        this.bullets = bullets;\n    }\n\n    @Override\n    public void update(Player player) {\n        int dx = player.getX() - x;\n        int dy = player.getY() - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance > 0) {\n            x += (int) (speed * dx / distance);\n            y += (int) (speed * dy / distance);\n        }\n\n        // Uzaktan asit atışı\n        if (shootCooldown > 0) {\n            shootCooldown--;\n        }\n\n        if (shootCooldown <= 0 && bullets != null) {\n            int startX = x + width / 2;\n            int startY = y + height / 2;\n            int targetX = player.getX() + player.getBounds().width / 2;\n            int targetY = player.getY() + player.getBounds().height / 2;\n\n            bullets.add(new AcidBullet(startX, startY, targetX, targetY));\n            shootCooldown = SHOOT_INTERVAL;\n\n\n            System.out.println(\"AcidZombie -> asit attı!\");\n        }\n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(color);\n        g.fillRect(x, y, width, height);\n    }\n}\n",
      "Weapon.java": "package com.topdownshooter.model;\n\nimport java.util.List;\n\npublic interface Weapon {\n\n    void shoot(int startX, int startY, int targetX, int targetY, List<Bullet> bullets);\n    void reload();\n    int getMagazine();\n    int getAmmo();\n    String getName();\n    void updateCooldown();\n\n}\n",
      "Bullet.java": "package com.topdownshooter.model;\n\nimport java.awt.*;\nimport java.awt.Rectangle;\nimport java.io.Serializable;\n\npublic abstract class Bullet implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    protected int x, y;\n    protected double dx, dy;\n    protected int speed = 10;\n    protected int size = 6;\n    protected Color color = Color.WHITE;\n\n    public Bullet(int startX, int startY, int targetX, int targetY) {\n        this.x = startX;\n        this.y = startY;\n        double angle = Math.atan2(targetY - startY, targetX - startX);\n        this.dx = Math.cos(angle) * speed;\n        this.dy = Math.sin(angle) * speed;\n    }\n\n    public void update() {\n        x += dx;\n        y += dy;\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, size, size);\n    }\n\n    public void render(Graphics g) {\n        g.setColor(color);\n        g.fillOval(x, y, size, size);\n\n    }\n}\n",
      "Shotgun.java": "package com.topdownshooter.model;\n\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class Shotgun implements Weapon, Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private int magazine = 5;\n    private int ammo = 100;\n    private final int capacity = 5;\n\n    private int fireCooldown = 0;\n    private final int cooldownMax = 60; // 60 mermi/dk = 1 mermi/sn = her 60 frame\n\n    @Override\n    public void shoot(int startX, int startY, int targetX, int targetY, List<Bullet> bullets) {\n        if (fireCooldown > 0 || magazine <= 0) return;\n\n        double angle = Math.atan2(targetY - startY, targetX - startX);\n\n\n        for (int i = -4; i <= 4; i++) {\n            double spread = Math.toRadians(i * 5);\n            double finalAngle = angle + spread;\n\n            double dx = Math.cos(finalAngle);\n            double dy = Math.sin(finalAngle);\n\n            int endX = startX + (int)(dx * 100);\n            int endY = startY + (int)(dy * 100);\n\n            bullets.add(new StandardBullet(startX, startY, endX, endY));\n        }\n\n        magazine--;\n        fireCooldown = cooldownMax;\n    }\n\n    @Override\n    public void reload() {\n        int need = capacity - magazine;\n        if (ammo >= need) {\n            ammo -= need;\n            magazine = capacity;\n        } else {\n            magazine += ammo;\n            ammo = 0;\n        }\n    }\n\n    @Override\n    public int getMagazine() {\n        return magazine;\n    }\n\n    @Override\n    public int getAmmo() {\n        return ammo;\n    }\n\n    @Override\n    public String getName() {\n        return \"Shotgun\";\n    }\n\n    public void addAmmo(int amount) {\n        ammo += amount;\n    }\n\n    @Override\n    public void updateCooldown() {\n        if (fireCooldown > 0) fireCooldown--;\n    }\n}\n",
      "NormalZombie.java": "package com.topdownshooter.model;\n\nimport java.awt.*;\nimport java.io.Serializable;\n\npublic class NormalZombie extends BaseZombie implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    public NormalZombie() {\n        super(0, 0);\n        setStats();\n    }\n\n    public NormalZombie(int x, int y) {\n        super(x, y);\n        setStats();\n    }\n\n    @Override\n    protected void setStats() {\n        this.width = 40;\n        this.height = 40;\n        this.health = 100;\n        this.speed = 3;\n        this.damage = 10;\n        this.color = Color.GRAY;\n    }\n}\n",
      "SniperRifle.java": "package com.topdownshooter.model;\n\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class SniperRifle implements Weapon, Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private int magazine = 5;\n    private int ammo = 100;\n    private final int capacity = 5;\n\n    private int fireCooldown = 0;\n    private final int cooldownMax = 120; // 30 mermi/dk = 0.5 mermi/sn = 120 frame\n\n    @Override\n    public void shoot(int startX, int startY, int targetX, int targetY, List<Bullet> bullets) {\n        if (fireCooldown > 0 || magazine <= 0) return;\n\n        bullets.add(new PiercingBullet(startX, startY, targetX, targetY));\n        magazine--;\n        fireCooldown = cooldownMax;\n    }\n\n    @Override\n    public void reload() {\n        int need = capacity - magazine;\n        if (ammo >= need) {\n            ammo -= need;\n            magazine = capacity;\n        } else {\n            magazine += ammo;\n            ammo = 0;\n        }\n    }\n\n    @Override\n    public int getMagazine() {\n        return magazine;\n    }\n\n    @Override\n    public int getAmmo() {\n        return ammo;\n    }\n\n    @Override\n    public String getName() {\n        return \"Sniper Rifle\";\n    }\n\n    public void addAmmo(int amount) {\n        ammo += amount;\n    }\n\n    @Override\n    public void updateCooldown() {\n        if (fireCooldown > 0) fireCooldown--;\n    }\n}\n",
      "Pistol.java": "package com.topdownshooter.model;\n\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class Pistol implements Weapon, Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private int magazine = 12;\n    private int ammo = Integer.MAX_VALUE;\n    private final int capacity = 12;\n\n    private int fireCooldown = 0;\n    private final int cooldownMax = 30; // 120 mermi/dk = 2 mermi/sn = her 30 frame'de 1 mermi\n\n    @Override\n    public void shoot(int startX, int startY, int targetX, int targetY, List<Bullet> bullets) {\n        if (fireCooldown > 0 || magazine <= 0) return;\n\n        bullets.add(new StandardBullet(startX, startY, targetX, targetY));\n        magazine--;\n        fireCooldown = cooldownMax;\n    }\n\n    @Override\n    public void reload() {\n        int toReload = capacity - magazine;\n        if (ammo >= toReload) {\n            ammo -= toReload;\n            magazine = capacity;\n        } else {\n            magazine += ammo;\n            ammo = 0;\n        }\n    }\n\n    @Override\n    public int getMagazine() {\n        return magazine;\n    }\n\n    @Override\n    public int getAmmo() {\n        return Integer.MAX_VALUE; // Her zaman \"∞\" görünsün diye\n    }\n\n    @Override\n    public String getName() {\n        return \"Pistol\";\n    }\n\n    @Override\n    public void updateCooldown() {\n        if (fireCooldown > 0) fireCooldown--;\n    }\n}\n",
      "FastZombie.java": "package com.topdownshooter.model;\n\nimport java.awt.*;\nimport java.io.Serializable;\n\npublic class FastZombie extends BaseZombie implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n\n    public FastZombie() {\n        super(0, 0);\n        setStats();\n    }\n\n    public FastZombie(int x, int y) {\n        super(x, y);\n        setStats();\n    }\n\n    @Override\n    protected void setStats() {\n        this.width = 30;\n        this.height = 30;\n        this.health = 60;\n        this.speed = 4;\n        this.damage = 10;\n        this.color = Color.RED;\n    }\n}\n",
      "AssaultRifle.java": "package com.topdownshooter.model;\n\nimport java.io.Serializable;\nimport java.util.List;\nimport java.util.Random;\n\npublic class AssaultRifle implements Weapon, Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private int magazine = 30;\n    private int ammo = 120;\n    private final int capacity = 30;\n    private final Random rand = new Random();\n\n    private int fireCooldown = 0;\n    private final int cooldownMax = 6; // 600 mermi/dk = 10 mermi/sn = her 6 frame'de 1 mermi\n\n    @Override\n    public void shoot(int startX, int startY, int targetX, int targetY, List<Bullet> bullets) {\n        if (fireCooldown > 0 || magazine <= 0) return;\n\n        double angle = Math.atan2(targetY - startY, targetX - startX);\n        double spread = Math.toRadians(rand.nextDouble() * 30 - 15);\n        double finalAngle = angle + spread;\n\n        int newTargetX = startX + (int) (Math.cos(finalAngle) * 100);\n        int newTargetY = startY + (int) (Math.sin(finalAngle) * 100);\n\n        bullets.add(new StandardBullet(startX, startY, newTargetX, newTargetY));\n\n        magazine--;\n        fireCooldown = cooldownMax;\n    }\n\n    @Override\n    public void reload() {\n        int need = capacity - magazine;\n        if (ammo >= need) {\n            ammo -= need;\n            magazine = capacity;\n        } else {\n            magazine += ammo;\n            ammo = 0;\n        }\n    }\n\n    @Override\n    public int getMagazine() {\n        return magazine;\n    }\n\n    @Override\n    public int getAmmo() {\n        return ammo;\n    }\n\n    @Override\n    public String getName() {\n        return \"Assault Rifle\";\n    }\n\n    public void addAmmo(int amount) {\n        ammo += amount;\n    }\n\n    @Override\n    public void updateCooldown() {\n        if (fireCooldown > 0) fireCooldown--;\n    }\n}\n",
      "ZombieFactory.java": "package com.topdownshooter.model;\n\nimport java.io.Serializable;\n\npublic class ZombieFactory implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    public BaseZombie createZombie(String type, int x, int y) {\n        switch (type.toLowerCase()) {\n            case \"normal\":\n                return new NormalZombie(x, y);\n            case \"fast\":\n                return new FastZombie(x, y);\n            case \"tank\":\n                return new TankZombie(x, y);\n            case \"acid\":\n                return new AcidZombie(x, y);\n            case \"crawler\":\n                return new CrawlerZombie(x, y);\n            default:\n                return new NormalZombie(x, y);\n        }\n    }\n}\n",
      "BaseZombie.java": "package com.topdownshooter.model;\n\nimport java.awt.*;\nimport java.io.Serializable;\n\npublic abstract class BaseZombie implements Serializable {\n    private static final long serialVersionUID = 1L;\n    protected int x, y;\n    protected int width, height;\n    protected int health;\n    protected int speed;\n    protected int damage;\n    protected Color color;\n\n    public BaseZombie(int x, int y) {\n        this.x = x;\n        this.y = y;\n\n    }\n\n    protected abstract void setStats();\n\n    public void update(Player player) {\n        int dx = player.getX() - x;\n        int dy = player.getY() - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance > 0) {\n            x += (int) (speed * dx / distance);\n            y += (int) (speed * dy / distance);\n        }\n    }\n\n    public void render(Graphics g) {\n        g.setColor(color);\n        g.fillOval(x, y, width, height);\n    }\n\n    public void damage(int amount) {\n        health -= amount;\n    }\n\n    public boolean isDead() {\n        return health <= 0;\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, width, height);\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public int getX() { return x; }\n    public int getY() { return y; }\n}",
      "CrawlerZombie.java": "package com.topdownshooter.model;\n\nimport java.awt.*;\n\npublic class CrawlerZombie extends BaseZombie {\n    private boolean jumping = false;\n    private int jumpCooldown = 0;\n\n    public CrawlerZombie() {\n        super(0, 0);\n        setStats();\n    }\n\n    public CrawlerZombie(int x, int y) {\n        super(x, y);\n        setStats();\n    }\n\n    @Override\n    protected void setStats() {\n        this.width = 30;\n        this.height = 30;\n        this.health = 60;\n        this.speed = 6;\n        this.damage = 10;\n        this.color = Color.MAGENTA;\n    }\n\n    @Override\n    public void update(Player player) {\n        int dx = player.getX() - x;\n        int dy = player.getY() - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        // Eğer oyuncu yakınsa ve zıplama süresi dolmuşsa, aniden ileri atılır\n        if (distance < 100 && jumpCooldown <= 0) {\n            int jumpDistance = 40;\n            x += (int)(jumpDistance * dx / distance);\n            y += (int)(jumpDistance * dy / distance);\n            jumpCooldown = 60;\n        } else {\n            if (distance > 0) {\n                x += (int)(speed * dx / distance);\n                y += (int)(speed * dy / distance);\n            }\n            if (jumpCooldown > 0) jumpCooldown--;\n        }\n    }\n    @Override\n    public void render(Graphics g) {\n        int[] xPoints = { x + width / 2, x, x + width };\n        int[] yPoints = { y, y + height, y + height };\n\n        g.setColor(color);\n        g.fillPolygon(xPoints, yPoints, 3);\n    }\n\n}\n",
      "TankZombie.java": "package com.topdownshooter.model;\n\nimport java.awt.*;\nimport java.io.Serializable;\n\npublic class TankZombie extends BaseZombie implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n\n    public TankZombie() {\n        super(0, 0);\n        setStats();\n    }\n\n    public TankZombie(int x, int y) {\n        super(x, y);\n        setStats();\n    }\n\n    @Override\n    protected void setStats() {\n        this.width = 60;\n        this.height = 60;\n        this.health = 200;\n        this.speed = 2;\n        this.damage = 25;\n        this.color = Color.YELLOW;\n    }\n}\n",
      "StandardBullet.java": "package com.topdownshooter.model;\n\nimport java.awt.*;\n\npublic class StandardBullet extends Bullet {\n\n    public StandardBullet(int startX, int startY, int targetX, int targetY) {\n        super(startX, startY, targetX, targetY);\n        this.color = Color.WHITE;\n        this.size = 6;\n    }\n}\n",
      "AcidBullet.java": "package com.topdownshooter.model;\n\nimport java.awt.*;\n\npublic class AcidBullet extends Bullet {\n\n\n    public AcidBullet(int startX, int startY, int targetX, int targetY) {\n        super(startX, startY, targetX, targetY);\n        this.speed = 2;\n        this.size = 14;\n        this.color = Color.GREEN;\n\n        double angle = Math.atan2(targetY - startY, targetX - startX);\n        this.dx = Math.cos(angle) * speed;\n        this.dy = Math.sin(angle) * speed;\n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(color);\n        g.fillOval(x, y, size, size);\n        g.setColor(Color.BLACK);\n        g.drawOval(x, y, size, size);\n    }\n\n}\n",
      "RocketLauncher.java": "package com.topdownshooter.model;\n\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class RocketLauncher implements Weapon, Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private int magazine = 1;\n    private int ammo = 25;\n    private final int capacity = 1;\n\n    private int fireCooldown = 0;\n    private final int cooldownMax = 360;\n\n    @Override\n    public void shoot(int startX, int startY, int targetX, int targetY, List<Bullet> bullets) {\n        if (fireCooldown > 0 || magazine <= 0) return;\n\n        bullets.add(new ExplosiveBullet(startX, startY, targetX, targetY));\n        magazine--;\n        fireCooldown = cooldownMax;\n    }\n\n    @Override\n    public void reload() {\n        int need = capacity - magazine;\n        if (ammo >= need) {\n            ammo -= need;\n            magazine = capacity;\n        } else {\n            magazine += ammo;\n            ammo = 0;\n        }\n    }\n\n    @Override\n    public int getMagazine() {\n        return magazine;\n    }\n\n    @Override\n    public int getAmmo() {\n        return ammo;\n    }\n\n    @Override\n    public String getName() {\n        return \"Rocket Launcher\";\n    }\n\n    public void addAmmo(int amount) {\n        ammo += amount;\n    }\n\n    @Override\n    public void updateCooldown() {\n        if (fireCooldown > 0) fireCooldown--;\n    }\n}\n",
      "ExplosiveBullet.java": "package com.topdownshooter.model;\n\nimport java.awt.*;\n\npublic class ExplosiveBullet extends Bullet {\n    private int targetX, targetY;\n\n    private boolean exploded = false;\n    private Rectangle explosionArea;\n\n    public ExplosiveBullet(int startX, int startY, int targetX, int targetY) {\n        super(startX, startY, targetX, targetY);\n        this.color = Color.ORANGE;\n        this.size = 10;\n        this.speed = 6;\n\n        this.targetX = targetX;\n        this.targetY = targetY;\n    }\n\n\n    @Override\n    public void update() {\n        if (!exploded && Math.hypot(dx, dy) > 0) {\n            x += dx;\n            y += dy;\n            if (Math.hypot(x - targetX, y - targetY) < 10) {\n                exploded = true;\n                explosionArea = new Rectangle(x - 50, y - 50, 100, 100);\n            }\n        }\n    }\n\n    public boolean hasExploded() {\n        return exploded;\n    }\n\n    public Rectangle getExplosionArea() {\n        return explosionArea;\n    }\n}\n",
      "Player.java": "package com.topdownshooter.model;\n\nimport java.awt.*;\nimport java.io.Serializable;\n\nimport com.topdownshooter.controller.InputHandler;\nimport java.awt.event.KeyEvent;\n\npublic class Player implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private transient Image playerImage;\n\n    private int mouseX = 0;\n    private int mouseY = 0;\n\n    private int x, y;\n    private int speed = 4;\n    private int health = 100;\n    private int width = 48;\n    private int height = 48;\n    private long lastDamageTime = 0;\n\n    public Player(int x, int y) {\n        this.x = x;\n        this.y = y;\n        try {\n            playerImage = Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/characters/survivor-idle_shotgun_0.png\"));\n        } catch (Exception e) {\n            System.out.println(\"Player görseli yüklenemedi: \" + e.getMessage());\n        }\n\n    }\n\n    public void setMousePosition(int mx, int my) {\n        this.mouseX = mx;\n        this.mouseY = my;\n    }\n\n    public void update(InputHandler input) {\n        if (input.isPressed(KeyEvent.VK_W) || input.isPressed(KeyEvent.VK_UP)) {\n            y -= speed;\n        }\n        if (input.isPressed(KeyEvent.VK_S) || input.isPressed(KeyEvent.VK_DOWN)) {\n            y += speed;\n        }\n        if (input.isPressed(KeyEvent.VK_A) || input.isPressed(KeyEvent.VK_LEFT)) {\n            x -= speed;\n        }\n        if (input.isPressed(KeyEvent.VK_D) || input.isPressed(KeyEvent.VK_RIGHT)) {\n            x += speed;\n        }\n    }\n\n    public void render(Graphics g) {\n        Graphics2D g2d = (Graphics2D) g;\n\n        double centerX = x + width / 2.0;\n        double centerY = y + height / 2.0;\n\n        double angle = Math.atan2(mouseY - centerY, mouseX - centerX);\n\n        g2d.translate(centerX, centerY);\n        g2d.rotate(angle);\n\n        if (playerImage != null) {\n            g2d.drawImage(playerImage, -width / 2, -height / 2, width, height, null);\n        } else {\n            g2d.setColor(Color.BLUE);\n            g2d.fillRect(-width / 2, -height / 2, width, height);\n        }\n\n        g2d.rotate(-angle);\n        g2d.translate(-centerX, -centerY);\n    }\n\n\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, width, height);\n    }\n\n    public int getX() { return x; }\n    public int getY() { return y; }\n    public void damage(int amount) {\n        long now = System.currentTimeMillis();\n        if (now - lastDamageTime >= 1000) { // 1 saniyede 1 kez hasar\n            health -= amount;\n            if (health < 0) health = 0;\n            lastDamageTime = now;\n        }\n    }\n    public int getHealth() { return health; }\n\n    public void setHealth(int health) {\n        this.health = Math.max(0, Math.min(health, 100));\n    }\n\n}\n",
      "GameState.java": "package com.topdownshooter.model;\n\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class GameState implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    public Player player;\n    public List<Bullet> bullets;\n    public Wave currentWave;\n    public int score;\n\n    public GameState(Player player, List<Bullet> bullets, Wave wave, int score) {\n        this.player = player;\n        this.bullets = bullets;\n        this.currentWave = wave;\n        this.score = score;\n    }\n}\n",
      "MainMenuPanel.java": "package com.topdownshooter.view;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\nimport com.topdownshooter.Game;\nimport com.topdownshooter.model.GameState;\nimport com.topdownshooter.util.FileIO;\n\n\npublic class MainMenuPanel extends JPanel {\n\n    private final String[] options = {\"Başla\", \"Yükle\", \"Çıkış\"};\n    private int selectedIndex = 0;\n    private final Game parent;\n\n    public MainMenuPanel(Game parent) {\n        this.parent = parent;\n        setFocusable(true);\n        setBackground(Color.BLACK);\n\n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                int key = e.getKeyCode();\n                if (key == KeyEvent.VK_UP) {\n                    selectedIndex = (selectedIndex - 1 + options.length) % options.length;\n                    repaint();\n                } else if (key == KeyEvent.VK_DOWN) {\n                    selectedIndex = (selectedIndex + 1) % options.length;\n                    repaint();\n                } else if (key == KeyEvent.VK_ENTER) {\n                    handleSelection();\n                }\n            }\n        });\n    }\n\n    private void handleSelection() {\n        switch (selectedIndex) {\n            case 0:\n                parent.startNewGame();\n                break;\n            case 1:\n                GameState gs = FileIO.load();\n                if (gs != null) parent.loadGame(gs);\n                break;\n            case 2:\n                System.exit(0);\n                break;\n        }\n    }\n\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n        g.setFont(new Font(\"Arial\", Font.BOLD, 36));\n        g.setColor(Color.WHITE);\n        g.drawString(\"Top-Down Shooter\", getWidth() / 2 - 170, 100);\n\n        g.setFont(new Font(\"Arial\", Font.PLAIN, 28));\n        for (int i = 0; i < options.length; i++) {\n            g.setColor(i == selectedIndex ? Color.YELLOW : Color.WHITE);\n            g.drawString(options[i], getWidth() / 2 - 60, 200 + i * 50);\n        }\n    }\n}\n",
      "GamePanel.java": "package com.topdownshooter.view;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.topdownshooter.controller.InputHandler;\nimport com.topdownshooter.model.*;\nimport com.topdownshooter.util.FileIO;\nimport com.topdownshooter.util.GameConstants;\n\npublic class GamePanel extends JPanel {\n\n    private Player player;\n    private InputHandler input;\n    private List<Bullet> bullets = new ArrayList<>();\n    private Wave currentWave = new Wave(1);\n    private ZombieFactory zombieFactory = new ZombieFactory();\n    private int spawnTimer, score;\n    private boolean paused = false;\n    private boolean showMenu = false;\n    private int menuSelection = 0;\n    private final String[] menuOptions = {\"Devam Et\", \"Kaydet\", \"Yukle\", \"Cikis\"};\n    private boolean rifleGiven = false, shotgunGiven = false, sniperGiven = false, rocketGiven = false;\n    private boolean gameOver = false;\n    private Image backgroundImage;\n\n    private Weapon pistol = new Pistol();\n    private Weapon rifle = null;\n    private Weapon shotgun = null;\n    private Weapon sniper = null;\n    private Weapon rocket = null;\n    private Weapon currentWeapon = pistol;\n\n    public GamePanel() {\n        setPreferredSize(new Dimension(GameConstants.WIDTH, GameConstants.HEIGHT));\n        setFocusable(true);\n        input = new InputHandler();\n        addKeyListener(input);\n        player = new Player(GameConstants.WIDTH / 2, GameConstants.HEIGHT / 2);\n\n        try {\n            backgroundImage = Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"/backgrounds/forest_castle_background.png\"));\n        } catch (Exception e) {\n            System.out.println(\"Arka plan yuklenemedi.\");\n        }\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (!paused && !showMenu && !gameOver) {\n                    currentWeapon.shoot(player.getX() + player.getBounds().width / 2,\n                            player.getY() + player.getBounds().height / 2,\n                            e.getX(), e.getY(), bullets);\n                }\n            }\n        });\n\n        addMouseMotionListener(new MouseMotionAdapter() {\n            @Override\n            public void mouseMoved(MouseEvent e) {\n                player.setMousePosition(e.getX(), e.getY());\n            }\n        });\n\n\n        requestFocus();\n    }\n\n    public GamePanel(GameState state) {\n        this();\n        this.player = state.player;\n        this.bullets = state.bullets;\n        this.currentWave = state.currentWave;\n        this.score = state.score;\n    }\n\n    public void update() {\n\n        if (input.isPressed(KeyEvent.VK_ESCAPE)) {\n            showMenu = !showMenu;\n            sleep(200);\n        }\n\n        pistol.updateCooldown();\n        if (rifle != null) rifle.updateCooldown();\n        if (shotgun != null) shotgun.updateCooldown();\n        if (sniper != null) sniper.updateCooldown();\n        if (rocket != null) rocket.updateCooldown();\n\n\n        if (input.isPressed(KeyEvent.VK_1)) currentWeapon = pistol;\n        if (input.isPressed(KeyEvent.VK_2) && rifle != null) currentWeapon = rifle;\n        if (input.isPressed(KeyEvent.VK_3) && shotgun != null) currentWeapon = shotgun;\n        if (input.isPressed(KeyEvent.VK_4) && sniper != null) currentWeapon = sniper;\n        if (input.isPressed(KeyEvent.VK_5) && rocket != null) currentWeapon = rocket;\n\n        if (showMenu) {\n            if (input.isPressed(KeyEvent.VK_UP)) {\n                menuSelection = (menuSelection - 1 + menuOptions.length) % menuOptions.length;\n                sleep(150);\n            }\n\n            if (input.isPressed(KeyEvent.VK_DOWN)) {\n                menuSelection = (menuSelection + 1) % menuOptions.length;\n                sleep(150);\n            }\n\n            if (input.isPressed(KeyEvent.VK_ENTER)) {\n                switch (menuSelection) {\n                    case 0:\n                        showMenu = false;\n                        break;\n                    case 1:\n                        FileIO.save(new GameState(player, bullets, currentWave, score));\n                        break;\n                    case 2:\n                        GameState gs = FileIO.load();\n                        if (gs != null) {\n                            this.player = gs.player;\n                            this.bullets = gs.bullets;\n                            this.currentWave = gs.currentWave;\n                            this.score = gs.score;\n                        }\n                        break;\n                    case 3:\n                        System.exit(0);\n                        break;\n                }\n                sleep(200);\n            }\n            return;\n        }\n\n        if (gameOver) {\n            if (input.isPressed(KeyEvent.VK_ENTER)) {\n                player = new Player(GameConstants.WIDTH / 2, GameConstants.HEIGHT / 2);\n                bullets.clear();\n                currentWave = new Wave(1);\n                score = 0;\n                pistol = new Pistol();\n                rifle = shotgun = sniper = rocket = null;\n                currentWeapon = pistol;\n                rifleGiven = shotgunGiven = sniperGiven = rocketGiven = false;\n                gameOver = false;\n            }\n            return;\n        }\n\n        if (input.isPressed(KeyEvent.VK_R)) currentWeapon.reload();\n\n        player.update(input);\n        bullets.forEach(Bullet::update);\n        bullets.removeIf(b -> b.getBounds().x < 0 || b.getBounds().x > GameConstants.WIDTH ||\n                b.getBounds().y < 0 || b.getBounds().y > GameConstants.HEIGHT);\n\n        if (!currentWave.isComplete()) {\n            spawnTimer++;\n            if (spawnTimer >= 60) {\n                currentWave.spawn(zombieFactory, bullets);\n                spawnTimer = 0;\n            }\n        }\n\n\n        for (BaseZombie z : currentWave.getActiveZombies()) {\n            if (z instanceof AcidZombie) {\n                ((AcidZombie) z).setBulletList(bullets);\n            }\n        }\n\n        currentWave.getActiveZombies().forEach(z -> z.update(player));\n\n        for (BaseZombie z : new ArrayList<>(currentWave.getActiveZombies())) {\n            if (z instanceof AcidZombie && z.isDead()) {\n                Rectangle explosionArea = new Rectangle(z.getX() - 30, z.getY() - 30, 60, 60);\n                for (BaseZombie other : currentWave.getActiveZombies()) {\n                    if (other != z && !other.isDead() && other.getBounds().intersects(explosionArea)) {\n                        other.damage(30);\n                    }\n                }\n            }\n        }\n\n        List<BaseZombie> deadZombies = new ArrayList<>();\n        for (Bullet b : new ArrayList<>(bullets)) {\n            for (BaseZombie z : currentWave.getActiveZombies()) {\n                if (b.getBounds().intersects(z.getBounds())) {\n                    z.damage(50);\n                    if (z.isDead()) {\n                        deadZombies.add(z);\n                        score += 10;\n                        if (Math.random() < 0.2) {\n                            dropRandomAmmo();\n                        }\n                    }\n\n                    if (b instanceof PiercingBullet) {\n                        PiercingBullet pb = (PiercingBullet) b;\n                        pb.hit();\n                        if (pb.getHitsLeft() <= 0) pb.deactivate();\n                    } else if (!(b instanceof ExplosiveBullet)) {\n                        bullets.remove(b);\n                        break;\n                    }\n                }\n            }\n        }\n\n        List<ExplosiveBullet> rockets = new ArrayList<>();\n        for (Bullet b : bullets) {\n            if (b instanceof ExplosiveBullet) {\n                ExplosiveBullet rocket = (ExplosiveBullet) b;\n                if (rocket.hasExploded()) {\n                    rockets.add(rocket);\n                }\n            }\n        }\n\n        for (ExplosiveBullet rocket : rockets) {\n            Rectangle area = rocket.getExplosionArea();\n            for (BaseZombie z : currentWave.getActiveZombies()) {\n                if (z.getBounds().intersects(area)) {\n                    z.damage(50);\n                    if (z.isDead()) {\n                        deadZombies.add(z);\n                        score += 10;\n                    }\n                }\n            }\n            bullets.remove(rocket);\n        }\n\n        List<Bullet> toRemove = new ArrayList<>();\n        for (Bullet b : bullets) {\n            if (b instanceof AcidBullet && b.getBounds().intersects(player.getBounds())) {\n                player.damage(15);\n                toRemove.add(b);\n            }\n        }\n        bullets.removeAll(toRemove);\n\n        for (BaseZombie z : currentWave.getActiveZombies()) {\n            if (z.getBounds().intersects(player.getBounds())) {\n                player.damage(z.getDamage());\n            }\n        }\n\n        currentWave.getActiveZombies().removeAll(deadZombies);\n        bullets.removeIf(b -> b instanceof PiercingBullet && !((PiercingBullet) b).isActive());\n\n        if (currentWave.isComplete()) {\n            dropRandomAmmo(); // Dalga sonunda bonus mermi\n\n\n            int newHealth = player.getHealth() + 20;\n            player.setHealth(Math.min(newHealth, 100));\n\n            currentWave = new Wave(currentWave.getWaveNumber() + 1);\n        }\n\n\n\n        if (player.getHealth() <= 0) {\n            gameOver = true;\n        }\n\n        if (currentWave.getWaveNumber() >= 2 && !rifleGiven) {\n            rifle = new AssaultRifle();\n            rifleGiven = true;\n        }\n        if (currentWave.getWaveNumber() >= 4 && !shotgunGiven) {\n            shotgun = new Shotgun();\n            shotgunGiven = true;\n        }\n        if (currentWave.getWaveNumber() >= 6 && !sniperGiven) {\n            sniper = new SniperRifle();\n            sniperGiven = true;\n        }\n        if (currentWave.getWaveNumber() >= 11 && !rocketGiven) {\n            rocket = new RocketLauncher();\n            rocketGiven = true;\n        }\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n        if (backgroundImage != null)\n            g.drawImage(backgroundImage, 0, 0, getWidth(), getHeight(), this);\n\n        player.render(g);\n        bullets.forEach(b -> b.render(g));\n        currentWave.getActiveZombies().forEach(z -> z.render(g));\n\n        String ammoText = currentWeapon.getAmmo() == Integer.MAX_VALUE ? \"∞\" : String.valueOf(currentWeapon.getAmmo());\n        g.setColor(Color.WHITE);\n        g.drawString(\"Weapon: \" + currentWeapon.getName() + \" [\" + currentWeapon.getMagazine() + \"/\" + ammoText + \"]\", 10, 20);\n        g.drawString(\"Wave: \" + currentWave.getWaveNumber(), 10, 40);\n        String stats = \"Health: \" + player.getHealth() + \"    Score: \" + score;\n        g.drawString(stats, getWidth() - g.getFontMetrics().stringWidth(stats) - 10, 20);\n\n        if (showMenu) {\n            int boxWidth = 200;\n            int boxHeight = menuOptions.length * 40 + 20;\n            int x = (GameConstants.WIDTH - boxWidth) / 2;\n            int y = (GameConstants.HEIGHT - boxHeight) / 2;\n\n            g.setColor(new Color(0, 0, 0, 180));\n            g.fillRoundRect(x, y, boxWidth, boxHeight, 20, 20);\n            g.setColor(Color.WHITE);\n            g.drawRoundRect(x, y, boxWidth, boxHeight, 20, 20);\n\n            for (int i = 0; i < menuOptions.length; i++) {\n                g.setColor(i == menuSelection ? Color.YELLOW : Color.WHITE);\n                g.drawString(menuOptions[i], x + 50, y + 50 + i * 40);\n            }\n        }\n\n        if (gameOver) {\n            g.setFont(new Font(\"Arial\", Font.BOLD, 48));\n            g.setColor(Color.RED);\n            g.drawString(\"GAME OVER\", getWidth() / 2 - 150, getHeight() / 2);\n            g.setFont(new Font(\"Arial\", Font.PLAIN, 20));\n            g.setColor(Color.WHITE);\n            g.drawString(\"Yeniden başlamak için ENTER'a basın\", getWidth() / 2 - 160, getHeight() / 2 + 40);\n        }\n    }\n\n\n    private void sleep(int ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException ignored) {}\n    }\n    private void dropRandomAmmo() {\n        if (rifle != null && Math.random() < 0.5) {\n            ((AssaultRifle) rifle).addAmmo(30);\n        }\n        if (shotgun != null && Math.random() < 0.5) {\n            ((Shotgun) shotgun).addAmmo(5);\n        }\n        if (sniper != null && Math.random() < 0.5) {\n            ((SniperRifle) sniper).addAmmo(3);\n        }\n        if (rocket != null && Math.random() < 0.3) {\n            ((RocketLauncher) rocket).addAmmo(1);\n        }\n    }\n\n}\n",
      "GameConstants.java": "package com.topdownshooter.util;\n\npublic class GameConstants {\n    public static final int WIDTH = 800;\n    public static final int HEIGHT = 600;\n}\n",
      "FileIO.java": "package com.topdownshooter.util;\n\nimport com.topdownshooter.model.GameState;\n\nimport java.io.*;\n\npublic class FileIO {\n    private static final String PATH = \"savegame.dat\";\n\n    public static void save(GameState state) {\n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(PATH))) {\n            oos.writeObject(state);\n            System.out.println(\"Oyun kaydedildi → \" + PATH);\n        } catch (IOException e) {\n            System.err.println(\"Kaydetme hatasi: \" + e.getMessage());\n        }\n    }\n\n    public static GameState load() {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(PATH))) {\n            System.out.println(\"Oyun yukleniyor → \" + PATH);\n            return (GameState) ois.readObject();\n        } catch (FileNotFoundException e) {\n            System.err.println(\"Kayit dosyasi bulunamadi.\");\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Yukleme hatasi:\");\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n}\n"
    },
    {
      "id": "6539697",
      "Sniper.java": "public class Sniper extends Gun {\n    public Sniper(Player player) {\n        super(\"Sniper\", 5, 2000, 10, 3700, player);\n    }\n    public Projectile createProjectile() {\n        currentAmmo--;\n        return new SniperBullet(player);\n    }\n}",
      "WaveManager.java": "import java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class WaveManager implements Serializable {\n    private static final int screenWidth = Game.getScreenWidth();\n    private static final int screenHeight = Game.getScreenHeight();\n\n    private Player player;\n\n    private int currentWave;\n    private long nextWaveTime;\n    private boolean isWaiting;\n    private static final int totalWaves = 15;\n    private static final  int firstWaveZombieCount = 3;\n    private static final  int moreZombiesPerWave = 3;\n    private static final  long pauseTimeBetweenWaves = 4000;\n\n    private List<Zombie> activeZombies;\n    private List<Zombie> zombiesToRemove;\n    private int lastKilledZombieX;\n    private int lastKilledZombieY;\n\n    private List<Drop> activeDrops;\n    private List<Drop> dropsToRemove;\n    private boolean isGunDropGiven;\n    private static final double dropChance = 0.1;\n\n    public WaveManager(Player player) {\n        this.player = player;\n        activeZombies = new ArrayList<>();\n        zombiesToRemove = new ArrayList<>();\n        activeDrops = new ArrayList<>();\n        dropsToRemove = new ArrayList<>();\n    }\n\n    public List<Zombie> getActiveZombies() { return activeZombies; }\n    public List<Drop> getActiveDrops() { return activeDrops; }\n    public List<Drop> getDropsToRemove() { return dropsToRemove; }\n    public boolean isWaveComplete() { return activeZombies.isEmpty(); }\n    public boolean isOver() { return currentWave == totalWaves && isWaveComplete(); }\n\n    public void startWave() {\n        if (isOver())\n            return;\n        if(!isWaiting) {\n            isWaiting = true;\n            nextWaveTime = Game.getGamePanel().getGameTime() + pauseTimeBetweenWaves;\n            return;\n        }\n        if (Game.getGamePanel().getGameTime() < nextWaveTime)\n            return;\n        isWaiting = false;\n        isGunDropGiven = false;\n        int numberOfZombies = firstWaveZombieCount + currentWave  * moreZombiesPerWave;\n        currentWave++;\n        activeZombies.clear();\n\n        for (int i = 0; i < numberOfZombies; i++) {\n            Zombie zombie = newRandomZombie();\n            activeZombies.add(zombie);\n        }\n    }\n    private Zombie newRandomZombie() {\n        Map<String, Double> spawnChances = getSpawnChances();\n        Map<String, Integer> position = randomPosition();\n        int x = position.get(\"x\") , y = position.get(\"y\");\n        double random = Math.random();\n\n        double chance = spawnChances.get(\"normal\");\n        if (random < chance)\n            return new NormalZombie(x, y, player);\n        chance += spawnChances.get(\"tank\");\n        if (random < chance)\n            return new TankZombie(x, y, player);\n        chance += spawnChances.get(\"crawler\");\n        if (random < chance)\n            return new CrawlerZombie(x, y, player);\n        chance += spawnChances.get(\"acid\");\n        if (random < chance)\n            return new AcidZombie(x, y, player);\n        return null;\n    }\n    private Map<String, Integer> randomPosition() {\n        Map<String, Integer> positions = new HashMap<>();\n        int edge = (int) (Math.random() * 4);\n        int x , y;\n\n        switch (edge) {\n            case 0:\n                x = (int) (Math.random() * screenWidth);\n                y = 0;\n                break;\n            case 1:\n                x = screenWidth;\n                y = (int) (Math.random() * screenHeight);\n                break;\n            case 2:\n                x = (int) (Math.random() * screenWidth);\n                y = screenHeight;\n                break;\n            case 3:\n                x = 0;\n                y = (int) (Math.random() * screenHeight);\n                break;\n            default:\n                x = 0;\n                y = 0;\n        }\n\n        positions.put(\"x\",x);\n        positions.put(\"y\",y);\n        return  positions;\n    }\n    private Map<String, Double> getSpawnChances() {\n        Map<String, Double> spawnChances = new HashMap<>();\n        double acidChance = 0.0;\n        double crawlerChance = 0.0;\n        double tankChance = 0.0;\n\n        if (currentWave >= 5)\n            acidChance = 0.2 + 0.05 * (currentWave - 5);\n        if (currentWave >= 3)\n            crawlerChance = 0.15 + 0.05 * (currentWave - 3);\n        if (currentWave >= 2)\n            tankChance = 0.1 + 0.03 * (currentWave - 2);\n\n        double normalChance = 1.0 - (tankChance + crawlerChance + acidChance);\n        if (normalChance < 0) {\n            normalChance = 0.1;\n            double total = normalChance + tankChance + crawlerChance + acidChance;\n            acidChance /= total;\n            crawlerChance /= total;\n            tankChance /= total;\n        }\n\n        spawnChances.put(\"normal\",normalChance);\n        spawnChances.put(\"tank\",tankChance);\n        spawnChances.put(\"crawler\",crawlerChance);\n        spawnChances.put(\"acid\",acidChance);\n        return spawnChances;\n    }\n    public void updateWave() {\n        for(Zombie zombie : activeZombies) {\n            if(zombie.isAlive()) {\n                zombie.move();\n                zombie.attack();\n            }\n            else {\n                lastKilledZombieX = zombie.getXPosition() + zombie.getSize()/2;\n                lastKilledZombieY =  zombie.getYPosition() + zombie.getSize()/2;\n                zombiesToRemove.add(zombie);\n                player.addScore(zombie.getScore());\n                double chance1 = Math.random();\n                if (chance1 <= dropChance) {\n                    Drop drop;\n                    double chance2 = Math.random();\n                    if (chance2 <= 0.5 && currentWave > 3)\n                        drop = new AmmoDrop(lastKilledZombieX,lastKilledZombieY, player);\n                    else\n                        drop = new HealDrop(lastKilledZombieX,lastKilledZombieY, player);\n                    activeDrops.add(drop);\n                }\n            }\n        }\n        activeZombies.removeAll(zombiesToRemove);\n        zombiesToRemove.clear();\n\n        if (isWaveComplete())\n            if (!isGunDropGiven && (currentWave == 3 || currentWave == 6 || currentWave == 9 || currentWave == 12)) {\n                createGunDrop(currentWave, lastKilledZombieX, lastKilledZombieY);\n                isGunDropGiven = true;\n            }\n    }\n    public void createGunDrop(int waveNumber, int lastZombieX, int lastZombieY) {\n        Gun dropGun = null;\n        switch (waveNumber) {\n            case 3:\n                dropGun = new Rifle(player);\n                break;\n            case 6:\n                dropGun = new Shotgun(player);\n                break;\n            case 9:\n                dropGun = new Sniper(player);\n                break;\n            case 12:\n                dropGun = new RocketLauncher(player);\n                break;\n        }\n        if (dropGun != null) {\n            GunDrop gunDrop = new GunDrop(lastZombieX, lastZombieY,dropGun);\n            activeDrops.add(gunDrop);\n        }\n    }\n    protected void checkDropCollision(Drop drop) {\n        double distance = player.calculateDistance(drop);\n        if (distance <= (double) (player.getSize() + drop.getSize()) /2) {\n            if(drop instanceof HealDrop) {\n                if (player.getHealth() < player.getMaxHealth()) {\n                    drop.pickUp();\n                    dropsToRemove.add(drop);\n                }\n            }\n            else {\n                drop.pickUp();\n                dropsToRemove.add(drop);\n            }\n        }\n    }\n}",
      "Projectile.java": "import javax.swing.*;\nimport java.awt.*;\n\npublic abstract class Projectile implements Placeable {\n    protected int xPosition;\n    protected int yPosition;\n    protected int size;\n\n    protected int speed;\n    protected int damage;\n\n    protected double deltaX;\n    protected double deltaY;\n    protected double distance;\n\n    public Projectile(Player player, int size, int speed, int damage) {\n        xPosition = player.getXPosition() + player.getSize()/2;\n        yPosition = player.getYPosition() + player.getSize()/2;\n        this.speed = speed;\n        this.damage = damage;\n        this.size = size;\n\n        Point mousePoint = MouseInfo.getPointerInfo().getLocation();\n        SwingUtilities.convertPointFromScreen(mousePoint, Game.getGamePanel());\n\n        deltaX = mousePoint.getX() - (xPosition + size/2);\n        deltaY = mousePoint.getY() - (yPosition + size/2);\n        distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    }\n\n    public int getXPosition() { return xPosition; }\n    public int getYPosition() { return yPosition; }\n    public int getDamage() { return damage; }\n    public int getSize() { return size;}\n\n    public void move() {\n        xPosition += (int) (speed * (deltaX / distance));\n        yPosition += (int) (speed * (deltaY / distance));\n    }\n    public void draw(Graphics g) {\n        g.setColor(Color.yellow);\n        g.fillOval(xPosition,yPosition,size,size);\n    }\n}",
      "Zombie.java": "public abstract class Zombie implements Placeable {\n    protected int xPosition;\n    protected int yPosition;\n    protected static final int size = 20;\n\n    protected int health;\n    protected int damage;\n    protected int speed;\n\n    protected long lastAttackTime;\n    protected static final long attackCooldown = 1000;\n\n    protected Player player;\n\n    public Zombie(int health, int damage, int speed, int xPosition, int yPosition, Player player) {\n        this.health = health;\n        this.damage = damage;\n        this.speed = speed;\n        this.xPosition = xPosition;\n        this.yPosition = yPosition;\n        this.player = player;\n    }\n\n    public int getSize() { return size; }\n    public int getXPosition() { return xPosition; }\n    public int getYPosition() { return yPosition; }\n    public boolean isAlive() { return health > 0; }\n    public abstract int getScore();\n\n    public void move() {\n        double deltaX = (player.getXPosition() + player.getSize()/2) - (xPosition + size/2);\n        double deltaY = (player.getYPosition() + player.getSize()/2) - (yPosition + size/2);\n        double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n        xPosition += (int) (speed * (deltaX / distance));\n        yPosition += (int) (speed * (deltaY / distance));\n    }\n    public void attack() {\n        double distance = calculateDistance(player);\n        if (distance <= player.getSize()/2 && Game.getGamePanel().getGameTime() - lastAttackTime > attackCooldown) {\n            lastAttackTime = Game.getGamePanel().getGameTime();\n            player.takeDamage(damage);\n        }\n    }\n    public void takeDamage(int amount) {\n        health -= amount;\n        if(!isAlive())\n            health = 0;\n    }\n}",
      "SaveLoadManager.java": "import java.io.*;\nimport java.util.List;\n\npublic class SaveLoadManager {\n    private static class GameState implements Serializable {\n        private Player player;\n        private WaveManager waveManager;\n        private List<Projectile> activeProjectiles;\n        private List<Projectile> projectilesToRemove;\n        private List<Explosion> activeExplosions;\n        private List<Drawable> drawables;\n\n        private GameState(GamePanel gamePanel) {\n            player = gamePanel.getPlayer();\n            waveManager = gamePanel.getWaveManager();\n            activeProjectiles = gamePanel.getActiveProjectiles();\n            projectilesToRemove = gamePanel.getProjectilesToRemove();\n            activeExplosions = gamePanel.getActiveExplosions();\n            drawables = gamePanel.getDrawables();\n        }\n\n        private Player getPlayer() { return player; }\n        private WaveManager getWaveManager() { return waveManager; }\n        private List<Projectile> getActiveProjectiles() { return activeProjectiles; }\n        private List<Projectile> getProjectilesToRemove() { return projectilesToRemove; }\n        private List<Explosion> getActiveExplosions() { return activeExplosions; }\n        private List<Drawable> getDrawables() { return drawables; }\n    }\n    public static void saveGame(GamePanel gamePanel,String fileName) throws IOException {\n        GameState gameState = new GameState(gamePanel);\n        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(fileName));\n        out.writeObject(gameState);\n        out.close();\n    }\n    public static GamePanel loadGame(String fileName) throws IOException,ClassNotFoundException {\n        ObjectInputStream in = new ObjectInputStream(new FileInputStream(fileName));\n        GameState gameState = (GameState) in.readObject();\n        in.close();\n\n        GamePanel gamePanel = new GamePanel();\n        gamePanel.setPlayer(gameState.getPlayer());\n        gamePanel.setWaveManager(gameState.getWaveManager());\n        gamePanel.setActiveProjectiles(gameState.getActiveProjectiles());\n        gamePanel.setProjectilesToRemove(gameState.getProjectilesToRemove());\n        gamePanel.setActiveExplosions(gameState.getActiveExplosions());\n        gamePanel.setDrawables(gameState.getDrawables());\n\n        return gamePanel;\n    }\n}",
      "AcidZombie.java": "import java.awt.*;\n\npublic class AcidZombie extends Zombie {\n    private static final int deathScore = 25;\n    private static final int attackRange = 250;\n    private static final int explosionRadius = 50;\n    private static final int explosionDamage = 20;\n    private static final long rangeAttackCooldown = 2000;\n    private long lastRangeAttackTime;\n\n    public AcidZombie(int xPosition, int yPosition, Player player) {\n        super(50, 10, 3, xPosition, yPosition, player);\n    }\n\n    public int getScore() { return deathScore; }\n\n    private class AcidExplosion extends Explosion {\n        private AcidExplosion(int xPosition, int yPosition, int explosionRadius, Player player) {\n            super(xPosition,yPosition,explosionRadius);\n        }\n        public void draw(Graphics g) {\n            updateRadius();\n            g.setColor(Color.green);\n            g.fillOval(xPosition - currentRadius,yPosition - currentRadius,2 * currentRadius,2 * currentRadius);\n        }\n    }\n    public Explosion explode() {\n        double distance = calculateDistance(player);\n        if(distance <= explosionRadius)\n            player.takeDamage(explosionDamage);\n\n        for (Zombie zombie : Game.getGamePanel().getWaveManager().getActiveZombies())\n            if (!(zombie instanceof AcidZombie && !zombie.isAlive())) {\n                distance = calculateDistance(zombie);\n                if (distance <= explosionRadius)\n                    zombie.takeDamage(explosionDamage);\n            }\n        return new AcidExplosion(xPosition,yPosition,explosionRadius,player);\n    }\n\n    public void attack() {\n        double distance = calculateDistance(player);\n        if (distance <= player.getSize()/2 && Game.getGamePanel().getGameTime() - lastAttackTime > attackCooldown) {\n            lastAttackTime = Game.getGamePanel().getGameTime();\n            player.takeDamage(damage);\n        }\n        if (distance <= attackRange && Game.getGamePanel().getGameTime() - lastRangeAttackTime > rangeAttackCooldown) {\n            lastRangeAttackTime = Game.getGamePanel().getGameTime();\n            Game.getGamePanel().getActiveProjectiles().add(new Acid(player,this,damage));\n        }\n    }\n    public void takeDamage(int amount) {\n        super.takeDamage(amount);\n        if (!isAlive())\n            Game.getGamePanel().getActiveExplosions().add(explode());\n    }\n    public void draw(Graphics g) {\n        g.setColor(Color.green);\n        g.fillOval(xPosition,yPosition,size,size);\n        g.setColor(Color.white);\n        g.drawString(String.valueOf(health),xPosition,yPosition);\n    }\n}",
      "AmmoDrop.java": "import java.awt.*;\n\npublic class AmmoDrop extends Drop {\n    private Player player;\n\n    public AmmoDrop(int xPosition, int yPosition,Player player) {\n        super(xPosition, yPosition, 10);\n        this.player = player;\n    }\n\n    public void pickUp() {\n        int gunNum = 0;\n        while(gunNum == 0)\n            gunNum = (int) (Math.random() * player.getInventory().size());\n        player.getInventory().get(gunNum).addAmmo();\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.yellow);\n        g.fillOval(xPosition, yPosition, size, size);\n    }\n}",
      "Gun.java": "import java.io.Serializable;\n\npublic abstract class Gun implements Serializable {\n    protected String name;\n    protected int magSize;\n    protected int currentAmmo;\n    protected long totalAmmo;\n    protected long fireDuration;\n    protected long lastFireTime;\n    protected boolean isReloading;\n    protected long reloadDuration;\n    protected long reloadStartTime;\n    protected Player player;\n\n    public Gun(String name, int magSize, long fireDuration, long totalAmmo,long reloadDuration, Player player) {\n        this.name = name;\n        this.magSize = magSize;\n        this.totalAmmo = totalAmmo;\n        this.currentAmmo = magSize;\n        this.reloadDuration = reloadDuration;\n        this.fireDuration = fireDuration;\n        this.player = player;\n    }\n\n    public String getName() { return name; }\n    public String getAmmoInfo() { return getCurrentAmmo() + \"/\" + getTotalAmmo(); }\n    public boolean isReloading() { return isReloading; }\n    public boolean isEquipped() { return player.getEquippedGun().equals(this); }\n    public int getCurrentAmmo() { return currentAmmo; }\n    public long getTotalAmmo() { return totalAmmo; }\n    public void addAmmo() { totalAmmo += 2L * magSize; }\n    public void addToInventory() { player.getInventory().add(this); }\n    public boolean canFire() { return currentAmmo > 0 && !isReloading; }\n\n    public void reload() {\n        if(!isReloading && currentAmmo != magSize && totalAmmo != 0) {\n            isReloading = true;\n            reloadStartTime = Game.getGamePanel().getGameTime();\n        }\n    }\n    public void updateReload() {\n        if(!isEquipped())\n            isReloading = false;\n        else if(isReloading) {\n            if(Game.getGamePanel().getGameTime() - reloadStartTime > reloadDuration) {\n                if(totalAmmo >= magSize - currentAmmo) {\n                    totalAmmo -= magSize - currentAmmo;\n                    currentAmmo = magSize;\n                }\n                else {\n                    currentAmmo += (int) totalAmmo;\n                    totalAmmo = 0;\n                }\n                isReloading = false;\n            }\n        }\n    }\n    public Projectile fire() {\n        if(canFire()) {\n            if(Game.getGamePanel().getGameTime() - lastFireTime > fireDuration) {\n                lastFireTime = Game.getGamePanel().getGameTime();\n                return createProjectile();\n            }\n        }\n        else\n            reload();\n        return null;\n    }\n    public abstract Projectile createProjectile();\n}",
      "Bullet.java": "public abstract class Bullet extends Projectile {\n    public Bullet(Player player, int size, int speed, int damage) {\n        super(player, size, speed,damage);\n    }\n}",
      "Shotgun.java": "public class Shotgun extends Gun {\n    public Shotgun(Player player) {\n        super(\"Shotgun\", 5, 1000, 10, 2400, player);\n    }\n    public Projectile createProjectile() {\n        currentAmmo--;\n        return new ShotgunBullet(player, false);\n    }\n}",
      "Acid.java": "import java.awt.*;\n\npublic class Acid extends Projectile {\n    public Acid(Player player, Zombie zombie, int damage) {\n        super(player,5,10,damage);\n        xPosition = zombie.getXPosition() + zombie.getSize()/2;\n        yPosition = zombie.getYPosition() + zombie.getSize()/2;\n\n        deltaX = (player.getXPosition() + player.getSize() /2) - (getXPosition() + getSize()/2);\n        deltaY = (player.getYPosition() + player.getSize() /2) - (getYPosition() + getSize()/2);\n        distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    }\n    public void draw(Graphics g) {\n        g.setColor(Color.green);\n        g.fillOval(xPosition,yPosition,size,size);\n    }\n}",
      "SniperBullet.java": "public class SniperBullet extends Bullet {\n    public SniperBullet(Player player) {\n        super(player,5,30,80);\n    }\n}",
      "NormalZombie.java": "import java.awt.*;\n\npublic class NormalZombie extends Zombie {\n    private static final int deathScore = 10;\n\n    public NormalZombie(int xPosition, int yPosition, Player player) {\n        super(75, 10, 3, xPosition, yPosition, player);\n    }\n\n    public int getScore() { return deathScore; }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.lightGray);\n        g.fillOval(xPosition,yPosition,size,size);\n        g.setColor(Color.white);\n        g.drawString(String.valueOf(health),xPosition,yPosition);\n    }\n}",
      "MainMenuPanel.java": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionListener;\n\npublic class MainMenuPanel extends JPanel {\n    private JLabel title;\n    private JButton newGameButton;\n    private JButton continueButton;\n    private JButton quitButton;\n\n    public MainMenuPanel(ActionListener newGameListener, ActionListener continueListener, ActionListener quitListener) {\n        setLayout(new BorderLayout());\n        setBackground(Color.darkGray);\n\n        JPanel titlePanel = new JPanel(new FlowLayout());\n        titlePanel.setOpaque(false);\n        titlePanel.setPreferredSize(new Dimension(800, 150));\n\n        title = new JLabel(\"Top-Down Shooter\");\n        title.setForeground(Color.white);\n        title.setFont(new Font(\"Arial\", Font.BOLD, 32));\n\n        titlePanel.add(title);\n        add(titlePanel, BorderLayout.NORTH);\n\n        JPanel buttonsPanel = new JPanel(new GridLayout(3, 1, 300, 20));\n        buttonsPanel.setOpaque(false);\n        buttonsPanel.setPreferredSize(new Dimension(400, 200));\n\n        newGameButton = new JButton(\"New Game\");\n        newGameButton.setFont(new Font(\"Arial\", Font.PLAIN, 22));\n        newGameButton.setPreferredSize(new Dimension(200, 100));\n        newGameButton.addActionListener(newGameListener);\n\n        continueButton = new JButton(\"Continue\");\n        continueButton.setFont(new Font(\"Arial\", Font.PLAIN, 22));\n        continueButton.setPreferredSize(new Dimension(200, 100));\n        continueButton.addActionListener(continueListener);\n\n        quitButton = new JButton(\"Quit\");\n        quitButton.setFont(new Font(\"Arial\", Font.PLAIN, 22));\n        quitButton.setPreferredSize(new Dimension(200, 100));\n        quitButton.addActionListener(quitListener);\n\n        buttonsPanel.add(newGameButton);\n        buttonsPanel.add(continueButton);\n        buttonsPanel.add(quitButton);\n\n        JPanel centerPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));\n        centerPanel.setBackground(Color.darkGray);\n        centerPanel.add(buttonsPanel);\n        add(centerPanel, BorderLayout.CENTER);\n    }\n}",
      "PauseMenuPanel.java": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionListener;\n\npublic class PauseMenuPanel extends JPanel {\n    private JLabel title;\n    private JButton continueButton;\n    private JButton saveButton;\n    private JButton quitButton;\n\n    public PauseMenuPanel(ActionListener continueListener,ActionListener saveListener, ActionListener quitListener) {\n        setLayout(new BorderLayout());\n        setBackground(Color.black);\n\n        JPanel titlePanel = new JPanel(new FlowLayout());\n        titlePanel.setOpaque(false);\n        titlePanel.setPreferredSize(new Dimension(800, 150));\n\n        title = new JLabel(\"Paused\");\n        title.setForeground(Color.white);\n        title.setFont(new Font(\"Arial\", Font.BOLD, 32));\n\n        titlePanel.add(title);\n        add(titlePanel, BorderLayout.NORTH);\n\n        JPanel buttonsPanel = new JPanel(new GridLayout(3, 1, 300, 20));\n        buttonsPanel.setOpaque(false);\n        buttonsPanel.setPreferredSize(new Dimension(400, 200));\n\n        continueButton = new JButton(\"Continue\");\n        continueButton.setFont(new Font(\"Arial\", Font.PLAIN, 22));\n        continueButton.setPreferredSize(new Dimension(200, 100));\n        continueButton.addActionListener(continueListener);\n\n        saveButton = new JButton(\"Save\");\n        saveButton.setFont(new Font(\"Arial\", Font.PLAIN, 22));\n        saveButton.setPreferredSize(new Dimension(200, 100));\n        saveButton.addActionListener(saveListener);\n\n        quitButton = new JButton(\"Quit\");\n        quitButton.setFont(new Font(\"Arial\", Font.PLAIN, 22));\n        quitButton.setPreferredSize(new Dimension(200, 100));\n        quitButton.addActionListener(quitListener);\n\n        buttonsPanel.add(continueButton);\n        buttonsPanel.add(saveButton);\n        buttonsPanel.add(quitButton);\n\n        JPanel centerPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));\n        centerPanel.setBackground(Color.black);\n        centerPanel.add(buttonsPanel);\n        add(centerPanel, BorderLayout.CENTER);\n    }\n}",
      "GunDrop.java": "import java.awt.*;\n\npublic class GunDrop extends Drop {\n    private Gun gun;\n\n    public GunDrop(int xPosition, int yPosition,Gun gun) {\n        super(xPosition, yPosition, 10);\n        this.gun = gun;\n    }\n\n    public void pickUp() { gun.addToInventory(); }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.orange);\n        g.fillOval(xPosition, yPosition, size, size);\n        g.setColor(Color.white);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 12));\n        g.drawString(gun.getName(), xPosition - (size/2), yPosition - (size/2));\n    }\n}",
      "Rocket.java": "import java.awt.*;\nimport java.util.List;\n\npublic class Rocket extends Projectile {\n    private static final int explosionRadius = 50;\n\n    public Rocket(Player player) {\n        super(player,10,5,100);\n    }\n    private class RocketExplosion extends Explosion {\n        private RocketExplosion(int xPosition, int yPosition, int explosionRadius) {\n            super(xPosition,yPosition,explosionRadius);\n        }\n        public void draw(Graphics g) {\n            updateRadius();\n            g.setColor(Color.orange);\n            g.fillOval(xPosition - currentRadius,yPosition - currentRadius,2 * currentRadius,2 * currentRadius);\n        }\n    }\n\n    public Explosion explode(List<Zombie> activeZombies) {\n        for (Zombie zombie : activeZombies) {\n            distance = calculateDistance(zombie);\n            if(distance <= explosionRadius)\n                zombie.takeDamage(damage);\n        }\n        return new RocketExplosion(xPosition,yPosition,explosionRadius);\n    }\n}",
      "PistolBullet.java": "public class PistolBullet extends Bullet {\n    public PistolBullet(Player player) {\n        super(player,5,20,10);\n    }\n}",
      "Pistol.java": "public class Pistol extends Gun {\n    public  Pistol(Player player) {\n        super(\"Pistol\", 12, 500, Long.MAX_VALUE, 2000, player);\n        addToInventory();\n    }\n\n    public String getAmmoInfo() { return getCurrentAmmo() + \"/inf\"; }\n\n    public Projectile createProjectile() {\n        currentAmmo--;\n        return new PistolBullet(player);\n    }\n}",
      "GamePanel.java": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class GamePanel extends JPanel implements KeyListener,MouseListener,Runnable {\n    private static final int screenWidth = 800;\n    private static final int screenHeight = 600;\n\n    private long gameTime;\n    private long pauseStartTime;\n    private long totalPauseTime;\n\n    private PauseMenuPanel pauseMenuPanel;\n\n    private Set<Integer> pressedKeys;\n\n    private boolean isPaused;\n    private boolean isRunning;\n    private boolean gameWon;\n    private boolean gameEnded;\n    private boolean rifleFiring;\n\n    private Player player;\n    private WaveManager waveManager;\n    private List<Drawable> drawables;\n    private List<Explosion> activeExplosions;\n    private List<Projectile> activeProjectiles;\n    private List<Projectile> projectilesToRemove;\n\n    public GamePanel() {\n        totalPauseTime = 0;\n        gameTime = 0;\n\n        player = new Player(100,screenWidth/2,screenHeight/2);\n        waveManager = new WaveManager(player);\n\n        activeExplosions = new ArrayList<>();\n        activeProjectiles = new ArrayList<>();\n        projectilesToRemove = new ArrayList<>();\n        drawables = new ArrayList<>();\n\n        pressedKeys = new HashSet<>();\n\n        setPreferredSize(new Dimension(screenWidth,screenHeight));\n        setFocusable(true);\n        addKeyListener(this);\n        addMouseListener(this);\n\n        pauseMenuPanel = new PauseMenuPanel(\n                new ActionListener() {\n                    public void actionPerformed(ActionEvent e) {\n                        PauseOrResume();\n                    }\n            },  new ActionListener() {\n                    public void actionPerformed(ActionEvent e) {\n                        save();\n                    }\n            },  new ActionListener() {\n                    public void actionPerformed(ActionEvent e) {\n                        System.exit(0);\n                    }\n                });\n        pauseMenuPanel.setPreferredSize(new Dimension(screenWidth,screenHeight));\n        pauseMenuPanel.setVisible(false);\n        add(pauseMenuPanel);\n\n        Thread gameThread = new Thread(this);\n        gameThread.start();\n        isPaused = false;\n        isRunning = true;\n    }\n\n    public long getGameTime() { return gameTime; }\n    public Player getPlayer() { return player; }\n    public WaveManager getWaveManager() { return waveManager; }\n    public List<Drawable> getDrawables() { return drawables; }\n    public List<Explosion> getActiveExplosions() { return activeExplosions; }\n    public List<Projectile> getActiveProjectiles() { return activeProjectiles; }\n    public List<Projectile> getProjectilesToRemove() { return projectilesToRemove; }\n\n    public void setPlayer(Player player) { this.player = player; }\n    public void setWaveManager(WaveManager waveManager) { this.waveManager = waveManager; }\n    public void setDrawables(List<Drawable> drawables) { this.drawables = drawables; }\n    public void setActiveExplosions(List<Explosion> activeExplosions) { this.activeExplosions = activeExplosions; }\n    public void setActiveProjectiles(List<Projectile> activeProjectiles) { this.activeProjectiles = activeProjectiles; }\n    public void setProjectilesToRemove(List<Projectile> projectilesToRemove) { this.projectilesToRemove = projectilesToRemove; }\n\n    protected void paintComponent(Graphics g) {\n        g.setColor(Color.black);\n        g.fillRect(0,0,screenWidth,screenHeight);\n\n        drawables.addAll(waveManager.getActiveZombies());\n        drawables.addAll(waveManager.getActiveDrops());\n        drawables.addAll(activeProjectiles);\n        drawables.addAll(activeExplosions);\n        drawables.add(player);\n\n        if (!isPaused && !gameEnded)\n            for(Drawable object : drawables)\n                object.draw(g);\n        else {\n            g.setColor(Color.white);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 60));\n            if(gameWon) {\n                g.drawString(\"You Win!\", (screenWidth - 250) / 2, (screenHeight - 350) / 2);\n                g.drawString(\"Press Esc to Quit.\", (screenWidth - 500) / 2, (screenHeight - 100) / 2);\n            }\n            else {\n                g.drawString(\"You lose.\", (screenWidth - 250) / 2, (screenHeight - 350) / 2);\n                g.drawString(\"Press Esc to Quit.\", (screenWidth - 500) / 2, (screenHeight - 100) / 2);\n            }\n        }\n        drawables.clear();\n    }\n    private void PauseOrResume() {\n        isPaused = !isPaused;\n        pauseMenuPanel.setVisible(isPaused);\n        requestFocusInWindow();\n        if(isPaused)\n            pauseStartTime = System.currentTimeMillis();\n        else\n            totalPauseTime += System.currentTimeMillis() - pauseStartTime;\n    }\n    private void updatePlayer() {\n        if(player.isDead()) {\n            gameEnded = true;\n            gameWon = false;\n        }\n        else if (waveManager.isOver()) {\n            gameEnded = true;\n            gameWon = true;\n        }\n        if (pressedKeys.contains(KeyEvent.VK_W)) player.move(0, -1);\n        if (pressedKeys.contains(KeyEvent.VK_S)) player.move(0, 1);\n        if (pressedKeys.contains(KeyEvent.VK_A)) player.move(-1, 0);\n        if (pressedKeys.contains(KeyEvent.VK_D)) player.move(1, 0);\n        if (rifleFiring) {\n            Projectile projectile = player.getEquippedGun().fire();\n            if (projectile != null)\n                activeProjectiles.add(projectile);\n        }\n        player.getEquippedGun().updateReload();\n    }\n    private void checkCollision(Projectile projectile) {\n        if (!(projectile instanceof Acid))\n            for (Zombie zombie : waveManager.getActiveZombies()) {\n                double distance = projectile.calculateDistance(zombie);\n                if(distance <= (double) (projectile.getSize() + zombie.getSize()) /2) {\n                    if (projectile instanceof Rocket)\n                        activeExplosions.add(((Rocket) projectile).explode(waveManager.getActiveZombies()));\n                    else\n                        zombie.takeDamage(projectile.getDamage());\n                    if (!(projectile instanceof SniperBullet))\n                        projectilesToRemove.add(projectile);\n                }\n            }\n        else {\n            double distance = projectile.calculateDistance(player);\n            if(distance <= (double) (projectile.getSize() + player.getSize()) /2) {\n                player.takeDamage(projectile.getDamage());\n                projectilesToRemove.add(projectile);\n            }\n        }\n    }\n    public void run() {\n        while(isRunning) {\n            if (!isPaused && !gameEnded) {\n                gameTime = System.currentTimeMillis() - totalPauseTime;\n\n                updatePlayer();\n\n                if(waveManager.isWaveComplete())\n                    waveManager.startWave();\n                waveManager.updateWave();\n\n                for (Projectile projectile : activeProjectiles) {\n                    projectile.move();\n                    checkCollision(projectile);\n                    if (projectile.getXPosition() < 0 || projectile.getXPosition() > screenWidth || projectile.getYPosition() < 0 || projectile.getYPosition() > screenHeight)\n                        projectilesToRemove.add(projectile);\n                }\n                activeProjectiles.removeAll(projectilesToRemove);\n                projectilesToRemove.clear();\n\n                for (Drop drop : waveManager.getActiveDrops())\n                    waveManager.checkDropCollision(drop);\n                waveManager.getActiveDrops().removeAll(waveManager.getDropsToRemove());\n                waveManager.getDropsToRemove().clear();\n\n                activeExplosions.removeIf(explosion -> !explosion.isActive());\n            }\n\n            repaint();\n\n            try {\n                Thread.sleep(16);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void keyPressed(KeyEvent e) {\n        int key = e.getKeyCode();\n        switch (key) {\n            case KeyEvent.VK_R:\n                player.getEquippedGun().reload();\n                break;\n            case KeyEvent.VK_ESCAPE:\n                if (!gameEnded)\n                    PauseOrResume();\n                else\n                    System.exit(0);\n                break;\n            case KeyEvent.VK_Q:\n                if (!player.getLastGun().equals(player.getEquippedGun())) {\n                    Gun tempGun = player.getLastGun();\n                    player.setLastGun(player.getEquippedGun());\n                    player.setEquippedGun(tempGun);\n                }\n                break;\n            case KeyEvent.VK_1:\n                if (!player.getEquippedGun().equals(player.getInventory().get(0))) {\n                    player.setLastGun(player.getEquippedGun());\n                    player.setEquippedGun(player.getInventory().get(0));\n                    rifleFiring = false;\n                }\n                break;\n            case KeyEvent.VK_2:\n                if (player.getInventory().size() > 1 && !player.getEquippedGun().equals(player.getInventory().get(1))) {\n                    player.setLastGun(player.getEquippedGun());\n                    player.setEquippedGun(player.getInventory().get(1));\n                    rifleFiring = false;\n                }\n                break;\n            case KeyEvent.VK_3:\n                if (player.getInventory().size() > 2 && !player.getEquippedGun().equals(player.getInventory().get(2))) {\n                    player.setLastGun(player.getEquippedGun());\n                    player.setEquippedGun(player.getInventory().get(2));\n                    rifleFiring = false;\n                }\n                break;\n            case KeyEvent.VK_4:\n                if (player.getInventory().size() > 3 && !player.getEquippedGun().equals(player.getInventory().get(3))) {\n                    player.setLastGun(player.getEquippedGun());\n                    player.setEquippedGun(player.getInventory().get(3));\n                    rifleFiring = false;\n                }\n                break;\n            case KeyEvent.VK_5:\n                if (player.getInventory().size() > 4 && !player.getEquippedGun().equals(player.getInventory().get(4))) {\n                    player.setLastGun(player.getEquippedGun());\n                    player.setEquippedGun(player.getInventory().get(4));\n                    rifleFiring = false;\n                }\n                break;\n            default:\n                pressedKeys.add(key);\n                break;\n        }\n    }\n    public void save() {\n        try {\n            SaveLoadManager.saveGame(this,Game.getSaveFile());\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public void keyReleased(KeyEvent e) { pressedKeys.remove(e.getKeyCode()); }\n    public void keyTyped(KeyEvent e) {}\n\n    public void mousePressed(MouseEvent e) {\n        if (SwingUtilities.isLeftMouseButton(e) && !isPaused)\n            if(!(player.getEquippedGun() instanceof Rifle)) {\n                Projectile projectile = player.getEquippedGun().fire();\n                if (projectile != null)\n                    activeProjectiles.add(projectile);\n            }\n            else\n                rifleFiring = true;\n    }\n    public void mouseReleased(MouseEvent e) {\n        if (SwingUtilities.isLeftMouseButton(e) || isPaused)\n            rifleFiring = false;\n    }\n    public void mouseClicked(MouseEvent e) {}\n    public void mouseEntered(MouseEvent e) {}\n    public void mouseExited(MouseEvent e) {}\n}",
      "Drop.java": "public abstract class Drop implements Placeable {\n    protected int xPosition;\n    protected int yPosition;\n    protected int size;\n\n    public Drop(int xPosition, int yPosition, int size) {\n        this.xPosition = xPosition;\n        this.yPosition = yPosition;\n        this.size = size;\n    }\n\n    public int getXPosition() { return xPosition; }\n    public int getYPosition() { return yPosition; }\n    public int getSize() { return size; }\n\n    public abstract void pickUp();\n}",
      "Rifle.java": "public class Rifle extends Gun {\n    public Rifle(Player player) {\n        super(\"Rifle\", 30, 100, 60, 3100, player);\n    }\n    public Projectile createProjectile() {\n        currentAmmo--;\n        return new RifleBullet(player);\n    }\n}",
      "HealDrop.java": "import java.awt.*;\n\npublic class HealDrop extends Drop {\n    private Player player;\n\n    public HealDrop(int xPosition, int yPosition, Player player) {\n        super(xPosition, yPosition, 10);\n        this.player = player;\n    }\n\n    public void pickUp() { player.addHealth(); }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.green);\n        g.fillOval(xPosition, yPosition, size, size);\n    }\n}",
      "CrawlerZombie.java": "import java.awt.*;\n\npublic class CrawlerZombie extends Zombie {\n    private static final int deathScore = 20;\n\n    public CrawlerZombie(int xPosition, int yPosition, Player player) {\n        super(30, 10, 5, xPosition, yPosition, player);\n    }\n\n    public int getScore() { return deathScore; }\n\n    public void move() {\n        double deltaX = (player.getXPosition() + player.getSize()/2) - (xPosition + size/2);\n        double deltaY = (player.getYPosition() + player.getSize()/2) - (yPosition + size/2);\n        double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n        int currentSpeed = (distance <= 10) ? speed * 2 : speed;\n\n        xPosition += (int) (currentSpeed * (deltaX / distance));\n        yPosition += (int) (currentSpeed * (deltaY / distance));\n    }\n    public void draw(Graphics g) {\n        g.setColor(Color.blue);\n        g.fillOval(xPosition,yPosition,size,size);\n        g.setColor(Color.white);\n        g.drawString(String.valueOf(health),xPosition,yPosition);\n    }\n}",
      "Explosion.java": "public abstract class Explosion implements Drawable {\n    protected int xPosition;\n    protected int yPosition;\n\n    protected int maxRadius;\n    protected int currentRadius;\n\n    protected static final long duration = 200;\n    protected long startTime;\n\n    public Explosion(int xPosition, int yPosition, int explosionRadius) {\n        this.xPosition = xPosition;\n        this.yPosition = yPosition;\n        maxRadius = explosionRadius;\n        currentRadius = maxRadius;\n        startTime = Game.getGamePanel().getGameTime();\n    }\n\n    public boolean isActive() {\n        return Game.getGamePanel().getGameTime() - startTime < duration;\n    }\n    public void updateRadius() {\n        double progress = (double) (Game.getGamePanel().getGameTime() - startTime) / duration;\n        currentRadius = (int) (maxRadius * progress);\n    }\n}",
      "TankZombie.java": "import java.awt.*;\n\npublic class TankZombie extends Zombie {\n    private static final int deathScore = 15;\n\n    public TankZombie(int xPosition, int yPosition, Player player) {\n        super(150, 20, 2, xPosition, yPosition, player);\n    }\n\n    public int getScore() { return deathScore; }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.red);\n        g.fillOval(xPosition,yPosition,size,size);\n        g.setColor(Color.white);\n        g.drawString(String.valueOf(health),xPosition,yPosition);\n    }\n}",
      "Drawable.java": "import java.awt.*;\nimport java.io.Serializable;\n\npublic interface Drawable extends Serializable {\n    public abstract void draw(Graphics g);\n}",
      "Game.java": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.IOException;\n\npublic class Game {\n    private static final int screenWidth = 800;\n    private static final int screenHeight = 600;\n\n    private static final String saveFile = \"save.bin\";\n\n    private static JFrame gameFrame;\n    private static MainMenuPanel mainMenuPanel;\n    private static GamePanel gamePanel;\n\n    public static void main(String[] args) {\n        gameFrame = new JFrame(\"Top-Down Shooter\");\n        gameFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n\n        mainMenuPanel = new MainMenuPanel(\n            new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    gamePanel = new GamePanel();\n                    gameFrame.add(gamePanel);\n                    mainMenuPanel.setVisible(false);\n                    gamePanel.setVisible(true);\n                    gamePanel.requestFocusInWindow();\n            }\n        },  new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    gamePanel = load();\n                    gameFrame.add(gamePanel);\n                    mainMenuPanel.setVisible(false);\n                    gamePanel.setVisible(true);\n                    gamePanel.requestFocusInWindow();\n                }\n        }, new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    System.exit(0);\n            }\n        });\n\n        mainMenuPanel.setPreferredSize(new Dimension(screenWidth,screenHeight));\n        gameFrame.add(mainMenuPanel);\n        gameFrame.pack();\n        gameFrame.setResizable(false);\n        gameFrame.setVisible(true);\n    }\n    public static GamePanel load() {\n        try {\n            return SaveLoadManager.loadGame(saveFile);\n        } catch (IOException | ClassNotFoundException e) {\n            System.out.println(e.getMessage());\n        }\n        return new GamePanel();\n    }\n    public static int getScreenWidth() { return screenWidth; }\n    public static int getScreenHeight() { return screenHeight; }\n    public static String getSaveFile() { return saveFile; }\n    public static GamePanel getGamePanel() { return gamePanel; }\n}",
      "RifleBullet.java": "public class RifleBullet extends Bullet {\n    public RifleBullet(Player player) {\n        super(player,5,25,20);\n\n        double spreadAngle = Math.toRadians((Math.random() * 60) - 30);\n\n        double newDeltaX = deltaX * Math.cos(spreadAngle) - deltaY * Math.sin(spreadAngle);\n        double newDeltaY = deltaX * Math.sin(spreadAngle) + deltaY * Math.cos(spreadAngle);\n        deltaX = newDeltaX;\n        deltaY = newDeltaY;\n    }\n}",
      "ShotgunBullet.java": "public class ShotgunBullet extends Bullet {\n    private static final double gapAngle = Math.toRadians(5);\n\n    public ShotgunBullet(Player player, boolean pelletsCreated) {\n        super(player,5,15,10);\n        double baseAngle = Math.atan2(deltaY,deltaX);\n\n        if (!pelletsCreated) {\n            for (int i = 1; i < 5; i++) {\n                double pelletAngle = baseAngle - gapAngle * i;\n                new ShotgunPellet(player,distance * Math.cos(pelletAngle),distance * Math.sin(pelletAngle));\n            }\n            for (int i = 1; i < 5; i++) {\n                double pelletAngle = baseAngle + gapAngle * i;\n                new ShotgunPellet(player,distance * Math.cos(pelletAngle),distance * Math.sin(pelletAngle));\n            }\n        }\n    }\n    private class ShotgunPellet extends ShotgunBullet {\n        private ShotgunPellet(Player player, double newDeltaX, double newDeltaY) {\n            super(player,true);\n            deltaX = newDeltaX;\n            deltaY = newDeltaY;\n            Game.getGamePanel().getActiveProjectiles().add(this);\n        }\n    }\n}",
      "Placeable.java": "public interface Placeable extends Drawable {\n    public default double calculateDistance(Placeable placeable) {\n        double deltaX = (placeable.getXPosition() + placeable.getSize()/2) - (getXPosition() + getSize()/2);\n        double deltaY = (placeable.getYPosition() + placeable.getSize()/2) - (getYPosition() + getSize()/2);\n        return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    }\n    public abstract int getXPosition();\n    public abstract int getYPosition();\n    public abstract int getSize();\n}",
      "RocketLauncher.java": "public class RocketLauncher extends Gun {\n    public RocketLauncher(Player player) {\n        super(\"Rocket Launcher\", 1, 6000, 3, 6000, player);\n    }\n    public Projectile createProjectile() {\n        currentAmmo--;\n        return new Rocket(player);\n    }\n}",
      "Player.java": "import java.awt.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Player implements Placeable {\n    private static final int screenWidth = 800;\n    private static final int screenHeight = 600;\n\n    private int xPosition;\n    private int yPosition;\n    private static final  int size = 20;\n    private static final int speed = 5;\n\n    private int health;\n    private int score;\n    private static final int maxHealth = 100;\n\n    private Gun lastGun;\n    private Gun equippedGun;\n    private List<Gun> inventory;\n\n    public Player(int health, int xPosition, int yPosition) {\n        this.health = health;\n        this.xPosition = xPosition;\n        this.yPosition = yPosition;\n        inventory = new ArrayList<>();\n        equippedGun = new Pistol(this);\n        lastGun = equippedGun;\n        score = 0;\n    }\n\n    public int getHealth() { return health;}\n    public int getMaxHealth() { return maxHealth; }\n    public int getSize() { return size; }\n    public int getXPosition() { return xPosition; }\n    public int getYPosition() { return yPosition; }\n    public Gun getEquippedGun() { return equippedGun; }\n    public Gun getLastGun() { return lastGun; }\n    public List<Gun> getInventory() { return inventory; }\n    public void setEquippedGun(Gun gun) { equippedGun = gun; }\n    public void setLastGun(Gun gun) { lastGun = gun; }\n    public void addScore(int amount) { score += amount; }\n    public void addHealth() {\n        health += 10;\n        if(health > maxHealth)\n            health = maxHealth;\n    }\n\n    public boolean isDead() { return health <= 0; }\n    public void move(int deltaX, int deltaY) {\n        int newX = xPosition + deltaX * speed;\n        int newY = yPosition + deltaY * speed;\n\n        if(newX <= screenWidth - size && newX >= 0)\n            xPosition = newX;\n        if(newY <= screenHeight - size && newY >= 0)\n            yPosition = newY;\n    }\n    public void takeDamage(int damage) {\n        health -= damage;\n        if(isDead())\n            health = 0;\n    }\n    public void draw(Graphics g) {\n        g.setColor(Color.white);\n        g.fillOval(xPosition,yPosition,size,size);\n\n        g.setFont(new Font(\"Arial\",Font.BOLD,16));\n        g.drawString(equippedGun.getName(),10,20);\n        g.drawString(\"Ammo: \" + equippedGun.getAmmoInfo(),10,40);\n        if(equippedGun.isReloading())\n            g.drawString(\"Reloading...\",10,60);\n\n        g.drawString(\"Health: \" + health + \"/\" + maxHealth,screenWidth-200,20);\n        g.drawString(\"Score: \" + score,screenWidth-200,40);\n    }\n}"
    },
    {
      "id": "9245287",
      "Sniper.java": "import java.util.ArrayList;\n\npublic class Sniper extends Weapon {\n    public Sniper() {\n        super(\"Sniper\", 5, 0, 30, 6); // Rifle'ın kapasitesi 24, ateş açısı 30 derece\n    }\n\n    @Override\n    public void fire(int startX, int startY, int targetX, int targetY, ArrayList<Bullet> bullets) {\n        double angle = getAngle();\n\n        double dx = (double) targetX - startX;\n        double dy = (double) targetY - startY;\n\n        double baseAngle = Math.atan2(dy, dx); // Hedef açısını bul\n        double adjustedAngleUp = baseAngle - angle;\n\n        bullets.add(new Bullet(startX, startY, adjustedAngleUp, 50, true, false));\n    }\n}\n",
      "Zombie.java": "import java.awt.*;\nimport java.io.Serializable;\nimport java.util.ArrayList;\n\npublic abstract class Zombie implements Serializable {\n    protected int x, y; // Zombinin konumu\n    protected int speed; // Zombinin hızı\n    protected boolean isDead = false; // Zombi öldü mü?\n    protected double damage; // Zombinin hasarı\n    protected int health; // Zombinin canı\n    protected Color color; // Zombinin rengi\n\n    public Zombie(int startX, int startY) {\n        this.x = startX;\n        this.y = startY;\n    }\n\n    public abstract void moveTowardsPlayer(int playerX, int playerY);\n\n    public void draw(Graphics g, Color color) {\n        if (!isDead) {\n            g.setColor(color);\n            g.fillRect(x, y, 40, 40); // Zombi yeşil kare ile gösterilir\n        }\n    }\n\n    public boolean checkCollision(Bullet bullet) {\n        // Zombinin mermi ile çarpışmasını kontrol et\n        return (bullet.getX() >= x && bullet.getX() <= x + 40 &&\n                bullet.getY() >= y && bullet.getY() <= y + 40);\n    }\n\n    public boolean checkCollision(Character player) {\n        int zombieWidth = 40;\n        int zombieHeight = 40;\n        int playerWidth = 50; // Oyuncunun genişliği\n        int playerHeight = 50; // Oyuncunun yüksekliği\n\n        return (player.getX() <= x + zombieWidth &&\n                player.getX() + playerWidth >= x &&\n                player.getY() <= y + zombieHeight &&\n                player.getY() + playerHeight >= y);\n    }\n\n    public void die() {\n        isDead = true; // Zombi öldü\n    }\n\n    public boolean isDead() {\n        return isDead;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public double getDamage() {\n        return damage; // Zombinin hasar değeri\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public boolean isWithinExplosionRange(Bullet bullet) {\n        return bullet.isWithinExplosionRadius(x, y);\n    }\n\n    public void takeDamage(double damage) {\n        this.health -= damage;\n        if (this.health <= 0) {\n            die();\n        }\n    }\n}\n\nclass NormalZombie extends Zombie {\n    public NormalZombie(int startX, int startY) {\n        super(startX, startY);\n        this.speed = 2;\n        this.damage = 0.2;\n        this.health = 100; // Orta seviyede can\n        this.color = Color.GREEN; // Normal zombi için yeşil renk\n\n    }\n\n    @Override\n    public void moveTowardsPlayer(int playerX, int playerY) {\n        if (x < playerX)\n            x += speed;\n        if (x > playerX)\n            x -= speed;\n        if (y < playerY)\n            y += speed;\n        if (y > playerY)\n            y -= speed;\n    }\n}\n\nclass SurungeZombie extends Zombie {\n    private boolean isYapisik;\n\n    public SurungeZombie(int startX, int startY) {\n        super(startX, startY);\n        this.speed = 4; // Hızlı hareket eder\n        this.damage = 0.2;\n        this.health = 50; // Düşük can\n        this.color = Color.CYAN; // Sürünge zombi için mavi renk\n        this.isYapisik = false;\n\n    }\n\n    @Override\n    public void moveTowardsPlayer(int playerX, int playerY) {\n        if (x < playerX)\n            x += speed;\n        if (x > playerX)\n            x -= speed;\n        if (y < playerY)\n            y += speed;\n        if (y > playerY)\n            y -= speed;\n\n        // Eğer oyuncuya çok yakınsa doğrudan üstüne zıpla\n        if (Math.abs(x - playerX) < 100 && Math.abs(y - playerY) < 100) {\n            if (!isYapisik) {\n                int zombieSize = 40;\n                int playerSize = 50;\n                isYapisik = true;\n\n                if (x < playerX) {\n                    x = playerX - zombieSize; // Soluna yapış\n                    y = playerY;\n                } else if (x > playerX) {\n                    x = playerX + playerSize; // Sağına yapış\n                    y = playerY;\n                }\n\n                else if (y < playerY) {\n                    y = playerY - zombieSize; // Üstüne yapış\n                    x = playerX;\n                } else {\n                    y = playerY + playerSize; // Altına yapış\n                    x = playerX;\n                }\n            }\n        } else {\n            isYapisik = false;\n        }\n    }\n}\n\nclass TankZombie extends Zombie {\n    public TankZombie(int startX, int startY) {\n        super(startX, startY);\n        this.speed = 1; // Çok yavaş\n        this.damage = 0.5; // Yüksek hasar\n        this.health = 200; // Yüksek can\n        this.color = Color.DARK_GRAY; // Tank zombi için koyu gri renk\n    }\n\n    @Override\n    public void moveTowardsPlayer(int playerX, int playerY) {\n        if (x < playerX)\n            x += speed;\n        if (x > playerX)\n            x -= speed;\n        if (y < playerY)\n            y += speed;\n        if (y > playerY)\n            y -= speed;\n    }\n}\n\nclass AsitZombi extends Zombie {\n    private GamePanel panel; // GamePanel nesnesi ekleniyor\n\n    public AsitZombi(int startX, int startY, GamePanel panel) {\n        super(startX, startY);\n        this.speed = 2;\n        this.panel = panel; // panel nesnesi sınıfa aktarılıyor\n        this.damage = 0.3; // Asit tükürme hasarı\n        this.health = 50; // Düşük can\n        this.color = Color.MAGENTA; // Asit zombi için mor renk\n    }\n\n    @Override\n    public void moveTowardsPlayer(int playerX, int playerY) {\n        if (x < playerX)\n            x += speed;\n        if (x > playerX)\n            x -= speed;\n        if (y < playerY)\n            y += speed;\n        if (y > playerY)\n            y -= speed;\n\n        // Zombinin ve karakterin merkezleri arasındaki mesafe\n        double distance = Math.sqrt(Math.pow((playerX + 25) - (x + 20), 2) + Math.pow((playerY + 25) - (y + 20), 2));\n\n        if (distance < 100 && Math.random() <= 0.4) {\n            double dx = (playerX + 25) - (x + 20);\n            double dy = (playerY + 25) - (y + 20);\n            double angle = Math.atan2(dy, dx);\n\n            // AcidBullet'i zombinin merkezinden başlat\n            AcidBullet acid = new AcidBullet(x + 20 - 15, y + 20 - 15, angle, 20);\n            panel.acidBullets.add(acid);\n        }\n    }\n\n    private boolean checkCollisionWithPlayer(int newX, int newY, int playerX, int playerY) {\n        int zombieSize = 40; // Zombinin boyutu\n        int playerSize = 50; // Oyuncunun boyutu\n\n        return (newX < playerX + playerSize && newX + zombieSize > playerX &&\n                newY < playerY + playerSize && newY + zombieSize > playerY);\n    }\n\n    public void spitAcidDie(ArrayList<Zombie> allZombies) {\n        int acidRange = 100; // Asit tükürme mesafesi\n        for (Zombie z : allZombies) {\n            if (z != this && !z.isDead()) {\n                // Öklidyen mesafe hesaplama\n                double distance = Math.sqrt(Math.pow(x - z.getX(), 2) + Math.pow(y - z.getY(), 2));\n\n                // Eğer mesafe acidRange'den küçükse, hasar ver\n                if (distance < acidRange) {\n                    z.takeDamage(50); // Asit hasarı\n                }\n            }\n        }\n    }\n\n    @Override\n    public void die() {\n        super.die();\n    }\n}",
      "Character.java": "import java.awt.*;\nimport java.io.Serializable;\n\npublic class Character implements Serializable {\n    private int x, y; // Karakter konumu\n    private final int speed = 12; // Karakterin hızı\n    private double health;\n\n    public Character(int startX, int startY) {\n        this.x = startX;\n        this.y = startY;\n        this.health = 100.0;\n    }\n\n    public void move(boolean up, boolean down, boolean left, boolean right) {\n        if (up)\n            y -= speed;\n        if (down)\n            y += speed;\n        if (left)\n            x -= speed;\n        if (right)\n            x += speed;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.RED);\n        g.fillRect(x, y, 50, 50); // Kırmızı kare karakter\n    }\n\n    public void takeDamage(double damage) {\n        health -= damage;\n        if (health <= 0)\n            health = 0;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public double getHealth() {\n        return health;\n    }\n}\n",
      "Weapon.java": "import java.io.Serializable;\nimport java.util.ArrayList;;\n\npublic abstract class Weapon implements Serializable {\n    private String name;\n    private int maxBullets;\n    private int currentBulletCount;\n    private double angle;\n    private int fireRate; // Ateş hızı (mermi/dakika)\n    private int availableFrom;\n    private long lastFiredTime; // HER SİLAHIN KENDİ SON ATEŞ ZAMANI\n\n    public Weapon(String name, int maxBullets, double angle, int fireRate, int availableFrom) {\n        this.name = name;\n        this.maxBullets = maxBullets;\n        this.currentBulletCount = maxBullets;\n        this.angle = angle;\n        this.fireRate = fireRate;\n        this.availableFrom = availableFrom;\n        this.lastFiredTime = 0;\n    }\n\n    public long getLastShotTime() {\n        return lastFiredTime;\n    }\n\n    public void addAmmo(int ammo) {\n        // Mevcut mermi sayısını ekle, ancak maksimum mermi kapasitesini aşma\n        currentBulletCount = Math.min(currentBulletCount + ammo, maxBullets);\n    }\n\n    // Silah ateşleme işlemi\n    public abstract void fire(int startX, int startY, int targetX, int targetY, ArrayList<Bullet> bullets);\n\n    public boolean canFire() {\n        long currentTime = System.currentTimeMillis();\n        long fireCooldown = 60000 / fireRate; // Fire rate'yi süreye çevir (ms)\n        return (currentTime - lastFiredTime) >= fireCooldown;\n    }\n\n    public void updateLastFiredTime() {\n        lastFiredTime = System.currentTimeMillis();\n    }\n\n    public void decreaseBulletCount() {\n        if (currentBulletCount > 0) {\n            currentBulletCount -= 1; // Her ateş etmede 1 mermi azalır\n        }\n    }\n\n    // Mermileri yeniden yükle\n    public void reload() {\n        currentBulletCount = maxBullets;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public long getShotDelay() {\n        return (60 * 1000) / fireRate; // RPM'yi ms cinsinden gecikmeye çevir\n    }\n\n    public int availableFrom() {\n        return availableFrom;\n    }\n\n    public int getMaxBullets() {\n        return maxBullets;\n    }\n\n    public int getCurrentBulletCount() {\n        return currentBulletCount;\n    }\n\n    public double getAngle() {\n        return angle;\n    }\n}\n",
      "Bullet.java": "import java.io.Serializable;\n\npublic class Bullet implements Serializable {\n    private int x, y;\n    private double speedX, speedY;\n    private static final int SPEED = 10;\n    private double damage = 50; // Merminin hasar değeri\n    private boolean canPass;\n    private boolean isExplosive; // Patlama alanı çapı\n\n    // public Bullet(int startX, int startY, double angle) {\n    // this.x = startX;\n    // this.y = startY;\n\n    // Açıyı kullanarak hız vektörünü belirleme\n    // speedX = Bullet.SPEED * Math.cos(angle);\n    // speedY = Bullet.SPEED * Math.sin(angle);\n    // }\n\n    public Bullet(int startX, int startY, double angle, double damage, boolean canPass, boolean isExplosive) {\n        this.x = startX;\n        this.y = startY;\n        this.canPass = canPass;\n        this.damage = damage;\n        this.isExplosive = isExplosive;\n        // Açıyı kullanarak hız vektörünü belirleme\n        speedX = SPEED * Math.cos(angle);\n        speedY = SPEED * Math.sin(angle);\n    }\n\n    public void update() {\n        x += speedX;\n        y += speedY;\n    }\n\n    public boolean isOutOfBounds() {\n        return (x < 0 || x > 1500 || y < 0 || y > 800);\n    }\n\n    public boolean isWithinExplosionRadius(int targetX, int targetY) {\n        double distance = Math.sqrt(Math.pow((double) targetX - x, 2) + Math.pow((double) targetY - y, 2));\n        return distance <= 200;\n    }\n\n    public double getDamage() {\n        return damage;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public boolean getCanPass() {\n        return canPass;\n    }\n\n    public boolean isExplosive() {\n        return isExplosive;\n    }\n}\n",
      "Shotgun.java": "import java.util.ArrayList;\n\npublic class Shotgun extends Weapon {\n    public Shotgun() {\n        super(\"Pompali Tufek: \", 5, 0, 60, 4); // Şarjör kapasitesi 5, ateş hızı 60 mermi/dakika\n    }\n\n    @Override\n    public void fire(int playerX, int playerY, int mouseX, int mouseY, ArrayList<Bullet> bullets) {\n        int startX = playerX + 25;\n        int startY = playerY + 25;\n\n        double dx = (double) mouseX - startX;\n        double dy = (double) mouseY - startY;\n        double baseAngle = Math.atan2(dy, dx);\n\n        // 9 mermi ateşle, 45 derece yayda ve her biri arasına 5 derece ekle\n        for (int i = -4; i <= 4; i++) {\n            double angle = baseAngle + Math.toRadians(i * 5);\n            bullets.add(new Bullet(startX, startY, angle, 50, false, false)); // 9 mermi ateşle\n        }\n    }\n}",
      "Magazine.java": "import java.awt.*;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\n\npublic class Magazine implements Serializable {\n    private int x, y;\n    private int width = 30, height = 30;\n    private boolean collected = false;\n    private transient BufferedImage image; // Resmi tutan değişken\n\n    public Magazine(int x, int y) {\n        this.x = x;\n        this.y = y;\n        try {\n            image = ImageIO.read(new File(\"img/magazine.png\")); // Resmi yükle\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void draw(Graphics g) {\n        if (!collected && image != null) {\n            g.drawImage(image, x, y, width, height, null);\n        }\n    }\n\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        loadImage();\n    }\n\n    private void loadImage() {\n        try {\n            image = ImageIO.read(new File(\"img/magazine.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean checkCollision(Character player) {\n        int playerWidth = 50;\n        int playerHeight = 50;\n\n        return (player.getX() <= x + width &&\n                player.getX() + playerWidth >= x &&\n                player.getY() <= y + height &&\n                player.getY() + playerHeight >= y);\n    }\n\n    public boolean isCollected() {\n        return collected;\n    }\n}\n",
      "Pistol.java": "import java.util.ArrayList;\n\npublic class Pistol extends Weapon {\n    public Pistol() {\n        super(\"Pistol\", 12, 0, 120, 1); // Pistolün kapasitesi 12, ateş açısı 15 derece\n    }\n\n    @Override\n    public void fire(int startX, int startY, int targetX, int targetY, ArrayList<Bullet> bullets) {\n        double angle = getAngle();\n\n        double dx = (double) targetX - startX;\n        double dy = (double) targetY - startY;\n\n        double baseAngle = Math.atan2(dy, dx); // Hedef açısını bul\n\n        // Açıyı 30° yukarı ve aşağı eğ\n        double adjustedAngleUp = baseAngle - angle;\n        // double adjustedAngleDown = baseAngle + angle;\n\n        // 2 mermi ateşle (yukarı ve aşağı açıları)\n        bullets.add(new Bullet(startX, startY, adjustedAngleUp, 50, false, false));\n    }\n}\n",
      "GamePanel.java": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\n\npublic class GamePanel extends JPanel implements Runnable, KeyListener, MouseListener, Serializable {\n    private boolean running = false;\n    private transient Thread gameThread;\n    private final int FPS = 20;\n    private boolean up = false, down = false, left = false, right = false;\n    private boolean shooting = false;\n    private boolean isFirstShot = true;\n    private boolean gameOver = false;\n\n    public Character player;\n    private ArrayList<Bullet> bullets = new ArrayList<>();\n    private ArrayList<Zombie> zombies = new ArrayList<>();\n    private ArrayList<Magazine> magazines = new ArrayList<>();\n    protected ArrayList<AcidBullet> acidBullets = new ArrayList<>();\n\n    private int score = 0;\n    private int level = 1;\n    private Weapon currentWeapon;\n    Pistol gunPistol = new Pistol();\n    Rifle gunRifle = new Rifle();\n    Sniper gunSniper = new Sniper();\n    Shotgun gunShotgun = new Shotgun();\n    Roket gunRoket = new Roket();\n    private Weapon[] weaponArr = { gunPistol, gunRifle, gunShotgun, gunSniper, gunRoket };\n    private boolean gamePaused = false;\n\n    public GamePanel() {\n        setFocusable(true);\n        addKeyListener(this);\n        addMouseListener(this);\n\n        // Karakteri oluştur\n        player = new Character(1500 / 2, 800 / 2);\n        spawnZombies();\n        currentWeapon = gunPistol; // Başlangıçta Pistol seçili\n    }\n\n    public void startGame() {\n        if (gameThread == null || !gameThread.isAlive()) {\n            running = true;\n            gameThread = new Thread(this);\n            gameThread.start();\n        }\n    }\n\n    // public void startGame() {\n    // running = true;\n    // gameThread = new Thread(this);\n    // gameThread.start();\n    // }\n    public void stopGame() {\n        running = false;\n    }\n\n    public Character getPlayer() {\n        return player;\n    }\n\n    public void togglePause() {\n        gamePaused = !gamePaused; // Duraklatmayı değiştir\n        repaint(); // Ekranı yenile\n    }\n\n    public void resumeGame() {\n        gamePaused = false; // Duraklatmayı kaldır\n        repaint(); // Ekranı yenile\n    }\n\n    public void saveGame() {\n        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"savegame.ser\"))) {\n            out.writeObject(this); // GamePanel içeriğini kaydet\n            System.out.println(\"Oyun başarıyla kaydedildi.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static GamePanel loadGame() {\n        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"savegame.ser\"))) {\n            GamePanel panel = (GamePanel) in.readObject(); // GamePanel nesnesini yükle\n            System.out.println(\"Oyun başarıyla yüklendi.\");\n            panel.reinitializeAfterLoad();\n            return panel;\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private void reinitializeAfterLoad() {\n        this.gameThread = new Thread(this);\n\n        this.addKeyListener(this);\n        this.addMouseListener(this);\n        this.setFocusable(true);\n        this.requestFocusInWindow();\n\n        this.gamePaused = false;\n        this.running = true;\n\n        this.gunPistol = new Pistol();\n        this.gunRifle = new Rifle();\n        this.gunSniper = new Sniper();\n        this.gunShotgun = new Shotgun();\n        this.gunRoket = new Roket();\n        this.weaponArr = new Weapon[] { gunPistol, gunRifle, gunShotgun, gunSniper, gunRoket };\n    }\n\n    public void applyLoadedGame(GamePanel loadedPanel) {\n        if (loadedPanel != null) {\n            this.player = loadedPanel.player;\n            this.zombies = loadedPanel.zombies;\n            this.bullets = loadedPanel.bullets;\n            this.level = loadedPanel.level;\n            this.gamePaused = false; // Oyun yüklenince duraklatılmış olmamalı\n            this.running = true; // Oyun aktif hale gelmeli\n\n            // Eski thread'i sıfırla ve yenisini başlat\n            if (gameThread == null || !gameThread.isAlive()) {\n                gameThread = new Thread(this);\n                gameThread.start();\n            }\n\n            // Klavye ve fare dinleyicilerini tekrar ekle\n            this.addKeyListener(loadedPanel);\n            this.addMouseListener(loadedPanel);\n            this.setFocusable(true);\n            this.requestFocusInWindow();\n\n            repaint();\n            System.out.println(\"Oyun başarıyla yüklendi ve başlatıldı.\");\n        } else {\n            System.out.println(\"Oyun yüklenirken hata oluştu.\");\n        }\n    }\n\n    public void spawnZombies() {\n        int numberOfZombiesToSpawn = level; // For each level, spawn more zombies\n        for (int i = 0; i < numberOfZombiesToSpawn; i++) {\n            int randomType = (int) (Math.random() * 4);\n            int spawnX = (int) (Math.random() * 1500);\n            int spawnY = (int) (Math.random() * 800);\n\n            switch (randomType) {\n                case 0:\n                    zombies.add(new NormalZombie(spawnX, spawnY));\n                    break;\n                case 1:\n                    zombies.add(new SurungeZombie(spawnX, spawnY));\n                    break;\n                case 2:\n                    zombies.add(new TankZombie(spawnX, spawnY));\n                    break;\n                case 3:\n                    zombies.add(new AsitZombi(spawnX, spawnY, this));\n                    break;\n            }\n        }\n    }\n\n    @Override\n    public void run() {\n        while (running) {\n            if (!gamePaused) {\n                GameUpdate();\n                repaint();\n            }\n            try {\n                Thread.sleep(1000 / FPS);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void GameUpdate() {\n        player.move(up, down, left, right);\n\n        for (int i = 0; i < magazines.size(); i++) {\n            if (magazines.get(i).checkCollision(player) && (!(currentWeapon instanceof Pistol))\n                    && currentWeapon.getCurrentBulletCount() != currentWeapon.getMaxBullets()) {\n                currentWeapon.addAmmo(currentWeapon.getMaxBullets());\n                magazines.remove(i);\n                i--;\n            }\n        }\n        for (int i = 0; i < acidBullets.size(); i++) {\n            AcidBullet acid = acidBullets.get(i);\n            acid.update();\n            if (acid.isOutOfBounds()) {\n                acidBullets.remove(i);\n                i--;\n            }\n            if (acid.checkCollision(player)) {\n                acidBullets.remove(i);\n                i--;\n                player.takeDamage(acid.getDamage());\n            }\n        }\n        // Mermileri güncelle\n        for (int i = 0; i < bullets.size(); i++) {\n            Bullet bullet = bullets.get(i);\n            bullet.update();\n            if (bullet.isOutOfBounds()) {\n                bullets.remove(i);\n                i--;\n            }\n            for (Zombie zombie : zombies) {\n                if (!zombie.isDead() && zombie.checkCollision(bullet)) {\n                    zombie.takeDamage(bullet.getDamage());\n                    if (zombie.isDead()) {\n                        if (Math.random() < 0.8) {\n                            magazines.add(new Magazine(zombie.x, zombie.y));\n                        }\n                        if (zombie instanceof AsitZombi) {\n                            ((AsitZombi) zombie).spitAcidDie(zombies);\n                            Graphics g = this.getGraphics();\n                            g.setColor(new Color(255, 0, 0, 128)); // Yarı şeffaf kırmızı renk\n                            g.fillOval(zombie.getX() - 200 / 2, zombie.getY() - 200 / 2, 200, 200);\n                        }\n                        score = score + level; // Zombi öldüğünde puan arttır\n                    }\n                    if (!bullet.getCanPass()) {\n                        bullets.remove(i);\n                        i--;\n                    }\n                    if (bullet.isExplosive()) {\n                        for (Zombie z : zombies) {\n                            if (z.isWithinExplosionRange(bullet)) {\n                                z.takeDamage(bullet.getDamage());\n                                Graphics g = this.getGraphics();\n                                g.setColor(new Color(255, 140, 0, 128)); // Yarı şeffaf kırmızı renk\n                                g.fillOval(z.getX() - 200 / 2, z.getY() - 200 / 2, 200, 200);\n                            }\n                        }\n                    }\n                    break; // Çarpışan ilk zombiyi öldür, daha fazlasına bakma\n                }\n            }\n        }\n        zombies.removeIf(Zombie::isDead);\n        for (Zombie zombie : zombies) {\n            if (!zombie.isDead()) {\n                zombie.moveTowardsPlayer(player.getX(), player.getY());\n                // Eğer zombi player'a çarparsa, player hasar alır\n                if (zombie.checkCollision(player)) {\n                    player.takeDamage(zombie.getDamage()); // Player hasar alır\n                }\n            }\n        }\n        // Ateş kontrolü\n        if (shooting && currentWeapon.getCurrentBulletCount() > 0) {\n            long currentTime = System.currentTimeMillis();\n            long shotDelay = currentWeapon.getShotDelay();\n\n            if (isFirstShot || (currentTime - currentWeapon.getLastShotTime() >= shotDelay)) {\n                Point mousePos = getMousePosition();\n                if (mousePos != null) {\n                    currentWeapon.fire(player.getX() + 25, player.getY() + 25, mousePos.x, mousePos.y, bullets);\n                    currentWeapon.decreaseBulletCount();\n                    currentWeapon.updateLastFiredTime(); // Sadece mevcut silahın zamanını güncelle\n                    isFirstShot = false;\n                }\n            }\n        }\n        if (zombies.isEmpty()) {\n            if (level == 1) {\n                currentWeapon = gunRifle;\n            } else if (level == 3) {\n                currentWeapon = gunShotgun;\n            } else if (level == 5) {\n                currentWeapon = gunSniper;\n            } else if (level == 10) {\n                currentWeapon = gunRoket;\n            }\n            level++;\n            spawnZombies();\n        }\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        // Karakteri çiz\n        player.draw(g);\n\n        // Mermileri çiz\n        g.setColor(Color.BLUE);\n        for (Bullet bullet : bullets) {\n            g.fillOval(bullet.getX(), bullet.getY(), 10, 10);\n        }\n        for (AcidBullet acid : acidBullets) {\n            acid.draw(g);\n        }\n        // Zombileri çiz\n        for (Zombie zombie : zombies) {\n            zombie.draw(g, zombie.color);\n        }\n        for (Magazine magazine : magazines) {\n            magazine.draw(g);\n        }\n\n        g.setColor(Color.BLACK);\n        g.drawString(\"Can: \" + String.format(\"%.2f\", player.getHealth()), 1300, 20);\n        g.drawString(\n                \"Silah: \" + currentWeapon.getName() + \" | Kalan Mermi: \"\n                        + currentWeapon.getCurrentBulletCount(),\n                400, 20);\n\n        // Puanı göster\n        g.drawString(\"Puan: \" + score, 1300, 30);\n\n        if (player.getHealth() <= 0) {\n            Font currentFont = g.getFont();\n            g.setColor(Color.RED);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 100));\n            g.drawString(\"Game Over\", 500, 400);\n            running = false;\n            g.setFont(currentFont);\n            // return;\n        }\n        if (gamePaused) {\n            Font currentFont = g.getFont();\n            g.setColor(Color.BLACK);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 100));\n            g.drawString(\"Duraklatildi\", 500, 400);\n            g.setFont(currentFont);\n        }\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        // int targetX = e.getX();\n        // int targetY = e.getY();\n        // fireBulletWithAngle(targetX, targetY, Math.toRadians(30)); // 30° açılı mermi\n        // ateşle\n        // if (currentWeapon.getCurrentBulletCount() > 0 && currentWeapon.canFire()) {\n        // int targetX = e.getX();\n        // int targetY = e.getY();\n        // currentWeapon.fire(player.getX() + 25, player.getY() + 25, targetX, targetY,\n        // bullets);\n        // currentWeapon.decreaseBulletCount(); // Mermi sayısını azalt\n        // }\n    }\n\n    public void fireBulletWithAngle(int targetX, int targetY, double angle) {\n        int startX = player.getX() + 25; // Karakterin merkezi\n        int startY = player.getY() + 25;\n\n        double dx = targetX - startX;\n        double dy = targetY - startY;\n\n        double baseAngle = Math.atan2(dy, dx); // Hedef açısını bul\n\n        // Açıyı 30° yukarı ve aşağı eğ\n        double adjustedAngleUp = baseAngle - angle;\n        double adjustedAngleDown = baseAngle + angle;\n\n        // İki yönde de mermi ateşle\n        // bullets.add(new Bullet(startX, startY, adjustedAngleUp));\n        // bullets.add(new Bullet(startX, startY, adjustedAngleDown));\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int key = e.getKeyCode();\n        if (key == KeyEvent.VK_W)\n            up = true;\n        if (key == KeyEvent.VK_S)\n            down = true;\n        if (key == KeyEvent.VK_A)\n            left = true;\n        if (key == KeyEvent.VK_D)\n            right = true;\n        if (key == KeyEvent.VK_R && currentWeapon instanceof Pistol) {\n            currentWeapon.reload();\n        }\n\n        if (key == KeyEvent.VK_E) {\n            switchWeapon();\n        }\n        if (key == KeyEvent.VK_Q) {\n            switchWeaponBackward();\n        }\n    }\n\n    public void switchWeapon() {\n        int ind = 0;\n        for (int i = 0; i < weaponArr.length; i++) {\n            Weapon w = weaponArr[i];\n            if (currentWeapon.equals(w)) {\n                ind = i;\n                break;\n            }\n        }\n        ind++;\n        while (weaponArr[(ind) % weaponArr.length].availableFrom() > level) {\n            ind++;\n        }\n        currentWeapon = weaponArr[(ind) % weaponArr.length];\n        isFirstShot = true;\n    }\n\n    public void switchWeaponBackward() {\n        int ind = 0;\n        for (int i = 0; i < weaponArr.length; i++) {\n            Weapon w = weaponArr[i];\n            if (currentWeapon.equals(w)) {\n                ind = i;\n                break;\n            }\n        }\n        ind--;\n        if (ind < 0)\n            ind += weaponArr.length;\n        while (weaponArr[(ind) % weaponArr.length].availableFrom() > level) {\n            ind--;\n            if (ind < 0)\n                ind += weaponArr.length;\n        }\n        currentWeapon = weaponArr[(ind) % weaponArr.length];\n        isFirstShot = true;\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int key = e.getKeyCode();\n        if (key == KeyEvent.VK_W)\n            up = false;\n        if (key == KeyEvent.VK_S)\n            down = false;\n        if (key == KeyEvent.VK_A)\n            left = false;\n        if (key == KeyEvent.VK_D)\n            right = false;\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        shooting = true;\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        shooting = false;\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e) {\n    }\n}",
      "Rifle.java": "import java.util.ArrayList;\n\npublic class Rifle extends Weapon {\n    public Rifle() {\n        super(\"Rifle\", 30, Math.toRadians(30), 600, 2); // Rifle'ın kapasitesi 24, ateş açısı 30 derece\n    }\n\n    @Override\n    public void fire(int startX, int startY, int targetX, int targetY, ArrayList<Bullet> bullets) {\n        double randomValue = (Math.random() * 30) - 15;\n        double angle = Math.toRadians(randomValue);\n\n        double dx = (double) targetX - startX;\n        double dy = (double) targetY - startY;\n\n        double baseAngle = Math.atan2(dy, dx); // Hedef açısını bul\n\n        // Açıyı 30° yukarı ve aşağı eğ\n        double adjustedAngleUp = baseAngle - angle;\n        // double adjustedAngleDown = baseAngle + angle;\n\n        bullets.add(new Bullet(startX, startY, adjustedAngleUp, 50, false, false));\n        // bullets.add(new Bullet(startX, startY, adjustedAngleDown, 50, false));\n    }\n}\n",
      "Game.java": "import java.io.Serializable;\nimport javax.swing.*;\n\npublic class Game implements Serializable {\n    private static GamePanel panel; // panel'i static yaptık\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"SelimGame\");\n        panel = new GamePanel(); // Global panel değişkeni kullan\n\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(1500, 800);\n        frame.add(panel);\n\n        // Menü öğeleri\n        JMenu fileMenu = new JMenu(\"MENU\");\n        JMenuItem pauseItem = new JMenuItem(\"Pause/Resume\");\n        JMenuItem saveItem = new JMenuItem(\"Save\");\n        JMenuItem reloadItem = new JMenuItem(\"Load from Save\");\n        fileMenu.add(pauseItem);\n        fileMenu.add(saveItem);\n        fileMenu.add(reloadItem);\n\n        JMenuBar menubar = new JMenuBar();\n        menubar.add(fileMenu);\n        frame.setJMenuBar(menubar);\n\n        // Menü eventleri\n        pauseItem.addActionListener(e -> panel.togglePause());\n        saveItem.addActionListener(e -> panel.saveGame());\n        reloadItem.addActionListener(e -> reloadGame(frame));\n\n        frame.setVisible(true);\n        panel.startGame();\n    }\n\n    private static void reloadGame(JFrame frame) {\n        panel.stopGame();\n        GamePanel loadedGame = GamePanel.loadGame();\n\n        if (loadedGame != null) {\n            frame.setContentPane(loadedGame);\n            frame.revalidate();\n            frame.repaint();\n\n            panel = loadedGame; // panel'i güncelle\n            loadedGame.addKeyListener(loadedGame);\n            loadedGame.setFocusable(true);\n            loadedGame.requestFocusInWindow();\n            loadedGame.startGame();\n        }\n    }\n}\n",
      "AcidBullet.java": "import java.awt.*;\nimport java.io.Serializable;\n\npublic class AcidBullet extends Bullet implements Serializable {\n    private int size = 30; // Merminin boyutu\n    private boolean isAlive = true;\n\n    public AcidBullet(int startX, int startY, double angle, double damage) {\n        super(startX, startY, angle, damage, false, false);\n    }\n\n    @Override\n    public void update() {\n        super.update();\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.GREEN); // Asit mermisi yeşil renkte\n        g.fillOval(getX(), getY(), size, size); // Mermi daire şeklinde çizilir\n    }\n\n    public boolean checkCollision(Character player) {\n        int playerWidth = 50;\n        int playerHeight = 50;\n\n        return (player.getX() <= getX() + size &&\n                player.getX() + playerWidth >= getX() &&\n                player.getY() <= getY() + size &&\n                player.getY() + playerHeight >= getY());\n    }\n\n    public boolean isAlive() {\n        return isAlive;\n    }\n\n    public void die() {\n        isAlive = false; // Mermi öldü\n    }\n}",
      "Roket.java": "import java.util.ArrayList;\n\npublic class Roket extends Weapon {\n\n    public Roket() {\n        super(\"Roketatar: \", 1, 0, 10, 11);\n    }\n\n    @Override\n    public void fire(int playerX, int playerY, int mouseX, int mouseY, ArrayList<Bullet> bullets) {\n        int startX = playerX + 25;\n        int startY = playerY + 25;\n\n        double dx = (double) mouseX - startX;\n        double dy = (double) mouseY - startY;\n        double baseAngle = Math.atan2(dy, dx);\n\n        // 9 mermi ateşle, 45 derece yayda ve her biri arasına 5 derece ekle\n        bullets.add(new Bullet(startX, startY, baseAngle, 50, false, true));\n\n    }\n}\n"
    },
    {
      "id": "2179244",
      "Sniper.java": "class Sniper extends AbstractWeapon {\n    public Sniper() {\n        super(5, 15, 30); // 5 mermi, 15 toplam, 30 RPM\n    }\n\n    @Override\n    public Bullet[] fire(int x, int y, int targetX, int targetY) {\n        if (!canFire()) return null;\n        lastFiredTime = System.currentTimeMillis();\n        currentAmmo--;\n\n        return new Bullet[] { new PiercingBullet(x, y, targetX, targetY) };\n    }\n\n   \n}\n",
      "Zombie.java": "import java.awt.*;\n\npublic interface Zombie {\n    void update(int playerX, int playerY);\n    void draw(Graphics g);\n    Rectangle getBounds();\n    int getDamage();         // <-- Gerekli!\n    void takeDamage();\n    boolean isDead();        // <-- Gerekli!\n}\n",
      "PiercingBullet.java": "import java.awt.Graphics;\nimport java.awt.Color;\n\nclass PiercingBullet extends Bullet {\n    public PiercingBullet(int x, int y, int targetX, int targetY) {\n        super(x, y, targetX, targetY);\n    }\n\n    @Override\n    public boolean isPiercing() {\n        return true;\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        g.setColor(Color.CYAN);\n        g.fillOval((int)getX() - 6, (int)getY() - 6, 12, 12);\n    }\n}\n",
      "AcidZombie.java": "import java.awt.*;\nimport java.util.ArrayList;\n\npublic class AcidZombie implements Zombie {\n    private double x, y;\n    private final int SIZE = 30;\n    private final double speed = 1.0;\n    private boolean dead = false;\n\n    public static ArrayList<AcidProjectile> acidShots = new ArrayList<>();\n\n    public AcidZombie(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void update(int playerX, int playerY) {\n        double angle = Math.atan2(playerY - y, playerX - x);\n        x += Math.cos(angle) * speed;\n        y += Math.sin(angle) * speed;\n\n        // Her 100 frame'de bir asit atabilir (örnek)\n        if (Math.random() < 0.01) {\n            acidShots.add(new AcidProjectile(x, y, playerX, playerY));\n        }\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.GREEN);\n        g.fillOval((int)(x - SIZE / 2), (int)(y - SIZE / 2), SIZE, SIZE);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle((int)(x - SIZE / 2), (int)(y - SIZE / 2), SIZE, SIZE);\n    }\n\n    public int getDamage() {\n        return 10;\n    }\n\n    public void takeDamage() {\n        dead = true;\n    }\n\n    public boolean isDead() {\n        return dead;\n    }\n\n    public void explode(Player player, ArrayList<Zombie> zombies) {\n        int radius = 60;\n        double centerX = x;\n        double centerY = y;\n\n        for (Zombie z : zombies) {\n            if (z == this) continue;\n            double dist = Math.hypot(centerX - z.getBounds().getCenterX(), centerY - z.getBounds().getCenterY());\n            if (dist <= radius) {\n                z.takeDamage();\n            }\n        }\n\n        double playerDist = Math.hypot(centerX - player.getX(), centerY - player.getY());\n        if (playerDist <= radius) {\n            player.takeDamage(15);\n        }\n    }\n}\n",
      "AmmoDrop.java": "import java.awt.*;\n\npublic class AmmoDrop {\n    private int x, y;\n    private final int SIZE = 20;\n    private boolean collected = false;\n\n    public AmmoDrop(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void draw(Graphics g) {\n        if (!collected) {\n            g.setColor(Color.YELLOW);\n            g.fillRect(x - SIZE / 2, y - SIZE / 2, SIZE, SIZE);\n            g.setColor(Color.BLACK);\n            g.drawString(\"A\", x - 4, y + 5); // \"A\" harfi: Ammo!\n        }\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x - SIZE / 2, y - SIZE / 2, SIZE, SIZE);\n    }\n\n    public boolean isCollected() {\n        return collected;\n    }\n\n    public void collect() {\n        collected = true;\n    }\n}\n",
      "Weapon.java": "interface Weapon {\n    Bullet[] fire(int x, int y, int targetX, int targetY);\n    void reload();\n    int getCurrentAmmo();\n    int getTotalAmmo();\n    void addAmmo(int amount);\n\n}\n",
      "Bullet.java": "import java.awt.*;\nimport java.awt.geom.AffineTransform;\nclass Bullet {\n    private double x, y, dx, dy;\n    private final double speed = 10;\n    private final int SIZE = 10;\n    private boolean active = true;\n\n    public boolean isExplosive() { return false; }\n    public boolean isPiercing() { return false; }\n\n    public double getX() { return x; }\n    public double getY() { return y; }\n\n    // Orijinal constructor\n    public Bullet(int x, int y, int targetX, int targetY) {\n        this.x = x;\n        this.y = y;\n        double angle = Math.atan2(targetY - y, targetX - x);\n        dx = Math.cos(angle) * speed;\n        dy = Math.sin(angle) * speed;\n    }\n\n    // ➕ Yeni constructor: doğrudan angle ile\n    public Bullet(int x, int y, double angle) {\n        this.x = x;\n        this.y = y;\n        dx = Math.cos(angle) * speed;\n        dy = Math.sin(angle) * speed;\n    }\n\n    public void update() {\n        x += dx;\n        y += dy;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.YELLOW);\n        g.fillOval((int)x - SIZE / 2, (int)y - SIZE / 2, SIZE, SIZE);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle((int)x - SIZE / 2, (int)y - SIZE / 2, SIZE, SIZE);\n    }\n\n    public boolean isActive() {\n        return active;\n    }\n\n    public void deactivate() {\n        active = false;\n    }\n}\n",
      "Shotgun.java": "import java.lang.Math;\n\nclass Shotgun extends AbstractWeapon {\n    public Shotgun() {\n        super(5, 20, 60); // 5 mermi, 20 toplam, 60 RPM\n    }\n\n    @Override\n    public Bullet[] fire(int x, int y, int targetX, int targetY) {\n        if (!canFire()) return null;\n        lastFiredTime = System.currentTimeMillis();\n        currentAmmo--;\n\n        Bullet[] pellets = new Bullet[9];\n        double baseAngle = Math.atan2(targetY - y, targetX - x);\n        for (int i = 0; i < 9; i++) {\n            double offset = Math.toRadians((i - 4) * 5); // -20° ila +20°\n            double angle = baseAngle + offset;\n            int tx = x + (int)(1000 * Math.cos(angle));\n            int ty = y + (int)(1000 * Math.sin(angle));\n            pellets[i] = new Bullet(x, y, tx, ty);\n        }\n\n        return pellets;\n    }\n\n    \n}\n",
      "FileManager.java": "\nimport java.io.*;\n\nclass FileManager {\n    private static final String SAVE_FILE = \"savegame.txt\";\n\n    public static void saveGame(Player player) {\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(SAVE_FILE))) {\n            writer.write(player.getX() + \"\\n\");\n            writer.write(player.getY() + \"\\n\");\n            writer.write(player.getHealth() + \"\\n\");\n            writer.write(player.getScore() + \"\\n\");\n            writer.write(player.getWeaponName() + \"\\n\");\n            System.out.println(\"Oyun kaydedildi.\");\n        } catch (IOException e) {\n            System.out.println(\"Kaydetme hatası: \" + e.getMessage());\n        }\n    }\n\n    public static void loadGame(Player player) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(SAVE_FILE))) {\n            int x = Integer.parseInt(reader.readLine());\n            int y = Integer.parseInt(reader.readLine());\n            int health = Integer.parseInt(reader.readLine());\n            int score = Integer.parseInt(reader.readLine());\n            String weaponName = reader.readLine();\n    \n            player.setX(x);\n            player.setY(y);\n            player.setHealth(health);\n            player.setScore(score);\n            player.setWeaponByName(weaponName);\n    \n            System.out.println(\"Oyun yüklendi.\");\n        } catch (IOException | NumberFormatException e) {\n            System.out.println(\"Yükleme hatası: \" + e.getMessage());\n        }\n    }\n}\n",
      "NormalZombie.java": "import java.awt.*;\n\npublic class NormalZombie implements Zombie {\n    private double x, y;\n    private final int SIZE = 30;\n    private final double speed = 1.0;\n    private int health = 2;\n\n    public NormalZombie(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void update(int playerX, int playerY) {\n        double angle = Math.atan2(playerY - y, playerX - x);\n        x += Math.cos(angle) * speed;\n        y += Math.sin(angle) * speed;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.GREEN);\n        g.fillRect((int)(x - SIZE / 2), (int)(y - SIZE / 2), SIZE, SIZE);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle((int)(x - SIZE / 2), (int)(y - SIZE / 2), SIZE, SIZE);\n    }\n\n    public void takeDamage() {\n        health--;\n    }\n\n    public boolean isDead() {\n        return health <= 0;\n    }\n\n    public int getDamage() {\n        return 10;\n    }\n}\n",
      "MainMenuPanel.java": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\npublic class MainMenuPanel extends JPanel {\n    public MainMenuPanel(JFrame frame) {\n        setLayout(new GridLayout(3, 1));\n        setBackground(Color.DARK_GRAY);\n\n        JButton startButton = new JButton(\"Yeni Oyun\");\n        JButton loadButton = new JButton(\"Oyunu Yükle\");\n        JButton exitButton = new JButton(\"Çıkış\");\n\n        startButton.addActionListener(e -> {\n            GamePanel game = new GamePanel();\n            frame.setContentPane(game);\n            frame.revalidate();\n            game.startGame();\n        });\n\n        loadButton.addActionListener(e -> {\n            GamePanel game = new GamePanel();\n            game.loadGame(); // File I/O'dan yükle\n            frame.setContentPane(game);\n            frame.revalidate();\n            game.startGame();\n        });\n\n        exitButton.addActionListener(e -> System.exit(0));\n\n        add(startButton);\n        add(loadButton);\n        add(exitButton);\n    }\n}\n",
      "AcidProjectile.java": "import java.awt.*;\n\npublic class AcidProjectile {\n    private double x, y, dx, dy;\n    private final int SIZE = 10;\n    private final double speed = 4.0;\n    private boolean active = true;\n\n    public AcidProjectile(double startX, double startY, double targetX, double targetY) {\n        this.x = startX;\n        this.y = startY;\n\n        double angle = Math.atan2(targetY - startY, targetX - startX);\n        dx = Math.cos(angle) * speed;\n        dy = Math.sin(angle) * speed;\n    }\n\n    public void update() {\n        x += dx;\n        y += dy;\n\n        // Ekran dışına çıktıysa pasifleştir\n        if (x < 0 || x > 800 || y < 0 || y > 600) {\n            active = false;\n        }\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.MAGENTA);\n        g.fillOval((int)(x - SIZE / 2), (int)(y - SIZE / 2), SIZE, SIZE);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle((int)(x - SIZE / 2), (int)(y - SIZE / 2), SIZE, SIZE);\n    }\n\n    public boolean isActive() {\n        return active;\n    }\n\n    public void deactivate() {\n        active = false;\n    }\n}\n",
      "AbstractWeapon.java": "abstract class AbstractWeapon implements Weapon {\n    protected int magazineSize;\n    protected int currentAmmo;\n    protected int totalAmmo;\n    protected long lastFiredTime = 0;\n    protected int fireRateMs;\n\n    public AbstractWeapon(int magazineSize, int totalAmmo, int fireRateRpm) {\n        this.magazineSize = magazineSize;\n        this.currentAmmo = magazineSize;\n        this.totalAmmo = totalAmmo;\n        this.fireRateMs = 60000 / fireRateRpm;\n    }\n\n    protected boolean canFire() {\n        return currentAmmo > 0 && System.currentTimeMillis() - lastFiredTime >= fireRateMs;\n    }\n\n    public void reload() {\n        int needed = magazineSize - currentAmmo;\n        int reloadAmount = Math.min(needed, totalAmmo);\n        currentAmmo += reloadAmount;\n        totalAmmo -= reloadAmount;\n    }\n    @Override\n    public void addAmmo(int amount) {\n        totalAmmo += amount;\n    }\n\n    public int getCurrentAmmo() { return currentAmmo; }\n    public int getTotalAmmo() { return totalAmmo; }\n}\n",
      "Pistol.java": "import java.awt.*;\n\nclass Pistol extends AbstractWeapon {\n    public Pistol() {\n        super(12, Integer.MAX_VALUE, 120);\n    }\n\n    public Bullet[] fire(int x, int y, int targetX, int targetY) {\n        if (!canFire()) return null;\n        currentAmmo--;\n        lastFiredTime = System.currentTimeMillis();\n        return new Bullet[]{ new Bullet(x, y, targetX, targetY) };\n    }\n}\n",
      "GamePanel.java": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.ArrayList;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class GamePanel extends JPanel implements ActionListener, KeyListener, MouseListener {\n    private JDialog pauseDialog;\n    private Timer timer;\n    private Player player;\n    private ArrayList<Bullet> bullets = new ArrayList<>();\n    private ArrayList<Zombie> zombies = new ArrayList<>();\n    private ArrayList<AcidProjectile> acidShots = AcidZombie.acidShots;\n    private boolean paused = false;\n    private boolean gameOver = false;\n\n    private int waveNumber = 1;\n    private boolean waveInProgress = true;\n\n    private long rewardMessageTime = 0;\n    private String rewardMessage = \"\";\n    private ArrayList<AmmoDrop> ammoDrops = new ArrayList<>();\n\n    public GamePanel() {\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.BLACK);\n        setFocusable(true);\n        addKeyListener(this);\n        addMouseListener(this);\n        player = new Player(400, 300);\n        spawnZombies();\n        setupPauseDialog();\n    }\n\n    private void setupPauseDialog() {\n        pauseDialog = new JDialog((Frame) null, \"Menü\", true);\n        pauseDialog.setSize(200, 200);\n        pauseDialog.setLayout(new GridLayout(4, 1));\n\n        JButton resumeButton = new JButton(\"Devam Et\");\n        resumeButton.addActionListener(e -> {\n            paused = false;\n            pauseDialog.setVisible(false);\n        });\n\n        JButton saveButton = new JButton(\"Oyunu Kaydet\");\n        saveButton.addActionListener(e -> saveGame());\n\n        JButton loadButton = new JButton(\"Oyunu Yükle\");\n        loadButton.addActionListener(e -> loadGame());\n\n        JButton exitButton = new JButton(\"Çıkış\");\n        exitButton.addActionListener(e -> System.exit(0));\n\n        pauseDialog.add(resumeButton);\n        pauseDialog.add(saveButton);\n        pauseDialog.add(loadButton);\n        pauseDialog.add(exitButton);\n        pauseDialog.setLocationRelativeTo(null);\n    }\n\n    public void startGame() {\n        timer = new Timer(16, this);\n        timer.start();\n        requestFocusInWindow();\n    }\n\n    private void spawnZombies() {\n        zombies.clear();\n        int count = 3 + waveNumber * 2;\n        for (int i = 0; i < count; i++) {\n            double rand = Math.random();\n            int x = (int)(Math.random() * 800);\n            int y = (int)(Math.random() * 600);\n\n            if (waveNumber == 1) {\n                zombies.add(new NormalZombie(x, y));\n            } else if (waveNumber == 2) {\n                zombies.add(rand < 0.7 ? new NormalZombie(x, y) : new CrawlerZombie(x, y));\n            } else {\n                if (rand < 0.25) zombies.add(new NormalZombie(x, y));\n                else if (rand < 0.5) zombies.add(new CrawlerZombie(x, y));\n                else if (rand < 0.75) zombies.add(new TankZombie(x, y));\n                else zombies.add(new AcidZombie(x, y));\n            }\n        }\n        waveInProgress = true;\n        if (waveNumber > 1 && Math.random() < 0.5) {\n            int dropX = (int)(Math.random() * 800);\n            int dropY = (int)(Math.random() * 600);\n            ammoDrops.add(new AmmoDrop(dropX, dropY));\n        }\n        \n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        if (paused || gameOver) return;\n\n        player.update();\n        for (Bullet bullet : bullets) bullet.update();\n        for (Zombie zombie : zombies) zombie.update(player.getX(), player.getY());\n        for (AcidProjectile acid : acidShots) acid.update();\n\n        checkCollisions();\n        repaint();\n\n        if (player.getHealth() <= 0 || (player.getTotalAmmo() <= 0 && player.getCurrentAmmo() == 0)) {\n            gameOver = true;\n            timer.stop();\n            repaint();\n            return;\n        }\n\n        if (waveInProgress && zombies.isEmpty()) {\n            waveNumber++;\n            waveInProgress = false;\n            giveWeaponReward();\n            Timer delay = new Timer(2000, evt -> spawnZombies());\n            delay.setRepeats(false);\n            delay.start();\n        }\n    }\n\n    private void checkCollisions() {\n        ArrayList<Zombie> zombiesToRemove = new ArrayList<>();\n        ArrayList<AcidProjectile> acidToRemove = new ArrayList<>();\n\n        for (Bullet bullet : bullets) {\n            if (!bullet.isActive()) continue;\n\n            for (Zombie zombie : zombies) {\n                if (zombie.getBounds().intersects(bullet.getBounds())) {\n\n                    if (zombie instanceof TankZombie tank) {\n                        tank.takeDamage();\n                        if (tank.isDead()) {\n                            zombiesToRemove.add(zombie);\n                            player.addScore(10);\n                        }\n                    } else if (zombie instanceof AcidZombie acid) {\n                        acid.takeDamage();\n                        if (acid.isDead()) {\n                            acid.explode(player, zombies);\n                            zombiesToRemove.add(zombie);\n                            player.addScore(10);\n                        }\n                    } else {\n                        zombiesToRemove.add(zombie);\n                        player.addScore(10);\n                    }\n\n                    bullet.deactivate();\n                    break;\n                }\n            }\n        }\n        ArrayList<AmmoDrop> dropsToRemove = new ArrayList<>();\n\n    for (AmmoDrop drop : ammoDrops) {\n        if (!drop.isCollected() && drop.getBounds().intersects(player.getBounds())) {\n            drop.collect();\n            player.addAmmo(20); // oyuncuya mermi ekle\n            dropsToRemove.add(drop);\n        }\n    }\n\n    ammoDrops.removeAll(dropsToRemove);\n\n        for (Zombie zombie : zombies) {\n            if (zombie.getBounds().intersects(player.getBounds())) {\n                player.takeDamage(zombie.getDamage());\n            }\n        }\n\n        for (AcidProjectile acid : acidShots) {\n            if (acid.getBounds().intersects(player.getBounds())) {\n                player.takeDamage(15);\n                acid.deactivate();\n                acidToRemove.add(acid);\n            }\n        }\n\n        bullets.removeIf(b -> !b.isActive());\n        zombies.removeAll(zombiesToRemove);\n        acidShots.removeIf(a -> !a.isActive());\n    }\n\n    private void giveWeaponReward() {\n        String reward = null;\n        switch (waveNumber) {\n            case 2 -> reward = \"Rifle\";\n            case 4 -> reward = \"Shotgun\";\n            case 6 -> reward = \"Sniper\";\n            case 11 -> reward = \"RocketLauncher\";\n        }\n\n        if (reward != null) {\n            player.setWeaponByName(reward);\n            rewardMessage = \"Yeni silah kazandın: \" + reward;\n            rewardMessageTime = System.currentTimeMillis();\n        }\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        for (AmmoDrop drop : ammoDrops) drop.draw(g);\n\n        player.draw(g);\n        for (Bullet bullet : bullets) bullet.draw(g);\n        for (Zombie zombie : zombies) zombie.draw(g);\n        for (AcidProjectile acid : acidShots) acid.draw(g);\n\n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 16));\n        g.drawString(\"Silah: \" + player.getWeaponName(), 10, 20);\n        g.drawString(\"Mermi: \" + player.getCurrentAmmo() + \"/\" + player.getTotalAmmo(), 10, 40);\n\n        String hpText = \"Can: \" + player.getHealth();\n        String scoreText = \"Skor: \" + player.getScore();\n        int panelWidth = getWidth();\n        FontMetrics fm = g.getFontMetrics();\n        g.drawString(hpText, panelWidth - fm.stringWidth(hpText) - 10, 20);\n        g.drawString(scoreText, panelWidth - fm.stringWidth(scoreText) - 10, 40);\n\n        if (!rewardMessage.isEmpty() && System.currentTimeMillis() - rewardMessageTime < 3000) {\n            g.setFont(new Font(\"Arial\", Font.BOLD, 20));\n            g.setColor(Color.YELLOW);\n            g.drawString(rewardMessage, getWidth() / 2 - 120, 70);\n        }\n\n        if (gameOver) {\n            g.setFont(new Font(\"Arial\", Font.BOLD, 48));\n            g.setColor(Color.RED);\n            g.drawString(\"GAME OVER\", getWidth() / 2 - 150, getHeight() / 2);\n        }\n    }\n\n    @Override public void keyPressed(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_ESCAPE && !gameOver) {\n            paused = true;\n            pauseDialog.setVisible(true);\n            return;\n        }\n        if (!paused && !gameOver) {\n            player.keyPressed(e);\n        }\n    }\n\n    @Override public void keyReleased(KeyEvent e) { player.keyReleased(e); }\n    @Override public void keyTyped(KeyEvent e) {}\n    @Override public void mousePressed(MouseEvent e) {}\n    @Override public void mouseReleased(MouseEvent e) {}\n    @Override public void mouseEntered(MouseEvent e) {}\n    @Override public void mouseExited(MouseEvent e) {}\n\n    @Override public void mouseClicked(MouseEvent e) {\n        Bullet[] newBullets = player.shoot(e.getX(), e.getY());\n        for (Bullet b : newBullets) bullets.add(b);\n    }\n\n    public void saveGame() {\n        try (PrintWriter writer = new PrintWriter(\"save.txt\")) {\n            writer.println(player.getX());\n            writer.println(player.getY());\n            writer.println(player.getHealth());\n            writer.println(player.getScore());\n            writer.println(player.getWeaponName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void loadGame() {\n        try (Scanner sc = new Scanner(new File(\"save.txt\"))) {\n            int x = Integer.parseInt(sc.nextLine());\n            int y = Integer.parseInt(sc.nextLine());\n            int hp = Integer.parseInt(sc.nextLine());\n            int score = Integer.parseInt(sc.nextLine());\n            String weapon = sc.nextLine();\n\n            player = new Player(x, y);\n            player.setHealth(hp);\n            player.setScore(score);\n            player.setWeaponByName(weapon);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n",
      "Rifle.java": "import java.lang.Math;\n\nclass Rifle extends AbstractWeapon {\n    public Rifle() {\n        super(30, 90, 600); // 30 mermi, 90 toplam, 600 RPM\n    }\n\n    @Override\n    public Bullet[] fire(int x, int y, int targetX, int targetY) {\n        if (!canFire()) return null;\n        lastFiredTime = System.currentTimeMillis();\n        currentAmmo--;\n\n        double angle = Math.atan2(targetY - y, targetX - x);\n        double spread = Math.toRadians((Math.random() - 0.5) * 30); // -15° ila +15°\n        double finalAngle = angle + spread;\n\n        int newTargetX = x + (int) (1000 * Math.cos(finalAngle));\n        int newTargetY = y + (int) (1000 * Math.sin(finalAngle));\n\n        return new Bullet[] { new Bullet(x, y, newTargetX, newTargetY) };\n    }\n\n    \n}\n",
      "CrawlerZombie.java": "import java.awt.*; // ⬅️ Bu satır tüm eksik sınıfları çözer\n\npublic class CrawlerZombie implements Zombie {\n    private double x, y;\n    private final int SIZE = 25;\n    private double speed = 1.2;\n    private boolean hasJumped = false;\n    private boolean dead = false;\n\n    public CrawlerZombie(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void update(int playerX, int playerY) {\n        double dist = Math.hypot(playerX - x, playerY - y);\n\n        if (!hasJumped && dist < 120) {\n            speed = 4.0; // Zıplama etkisi\n            hasJumped = true;\n        }\n\n        double angle = Math.atan2(playerY - y, playerX - x);\n        x += Math.cos(angle) * speed;\n        y += Math.sin(angle) * speed;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.ORANGE);\n        g.fillOval((int)(x - SIZE/2), (int)(y - SIZE/2), SIZE, SIZE);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle((int)(x - SIZE/2), (int)(y - SIZE/2), SIZE, SIZE);\n    }\n\n    public int getDamage() {\n        return 15;\n    }\n\n    public void takeDamage() {\n        dead = true;\n    }\n\n    public boolean isDead() {\n        return dead;\n    }\n}\n",
      "TankZombie.java": "import java.awt.*;\n\npublic class TankZombie implements Zombie {\n    private double x, y;\n    private final int SIZE = 40;\n    private final double speed = 0.4;\n    private int health = 5;\n    \n    public TankZombie(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void update(int playerX, int playerY) {\n        double angle = Math.atan2(playerY - y, playerX - x);\n        x += Math.cos(angle) * speed;\n        y += Math.sin(angle) * speed;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.BLUE);\n        g.fillRect((int)(x - SIZE/2), (int)(y - SIZE/2), SIZE, SIZE);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle((int)(x - SIZE/2), (int)(y - SIZE/2), SIZE, SIZE);\n    }\n\n    public int getDamage() {\n        return 20;\n    }\n\n    public void takeDamage() {\n        health--;\n    }\n\n    public boolean isDead() {\n        return health <= 0;\n    }\n}",
      "Game.java": "import javax.swing.*;\n\npublic class Game {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Top-Down Shooter\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setResizable(false);\n\n        GamePanel game = new GamePanel();\n        frame.setContentPane(game);\n        frame.setSize(800, 600);\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n\n        game.requestFocusInWindow(); // Klavye kontrolleri için odak ver\n        game.startGame();            // Oyunu başlat\n    }\n}\n",
      "RocketLauncher.java": "class RocketLauncher extends AbstractWeapon {\n    public RocketLauncher() {\n        super(1, 5, 10); // 1 roket, 5 toplam, 10 RPM\n    }\n\n    @Override\n    public Bullet[] fire(int x, int y, int targetX, int targetY) {\n        if (!canFire()) return null;\n        lastFiredTime = System.currentTimeMillis();\n        currentAmmo--;\n\n        return new Bullet[] { new ExplosiveBullet(x, y, targetX, targetY) };\n    }\n\n    \n}\n",
      "ExplosiveBullet.java": "import java.awt.*;\n\nclass ExplosiveBullet extends Bullet {\n    private final int explosionRadius = 50;\n\n    public ExplosiveBullet(int x, int y, int targetX, int targetY) {\n        super(x, y, targetX, targetY);\n    }\n\n    @Override\n    public boolean isExplosive() {\n        return true;\n    }\n\n    public int getExplosionRadius() {\n        return explosionRadius;\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        g.setColor(Color.RED);\n        g.fillOval((int)getX() - 6, (int)getY() - 6, 12, 12);\n    }\n}\n",
      "Player.java": "\n// import src.weapons.Pistol;\n// import src.weapons.Rifle;\nimport java.awt.*;\nimport java.awt.event.KeyEvent;\n\npublic class Player {\n    private int x, y, speed = 5;\n    private boolean up, down, left, right;\n    private Weapon weapon;\n    private int health = 100;\n    private int score = 0;\n\n    public Player(int x, int y) {\n        this.x = x;\n        this.y = y;\n        this.health = 100;\n        this.weapon = new Pistol(); // Başlangıç silahı\n    }\n\n    public void update() {\n        if (up) y -= speed;\n        if (down) y += speed;\n        if (left) x -= speed;\n        if (right) x += speed;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.WHITE); // ya da MAGENTA, WHITE, vs.\n\n        g.fillOval(x - 15, y - 15, 30, 30);\n    }\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 40, 40); // oyuncunun boyutuna göre ayarla\n    }\n    \n    public void keyPressed(KeyEvent e) {\n        switch (e.getKeyCode()) {\n            case KeyEvent.VK_W -> up = true;\n            case KeyEvent.VK_S -> down = true;\n            case KeyEvent.VK_A -> left = true;\n            case KeyEvent.VK_D -> right = true;\n            case KeyEvent.VK_1 -> weapon = new Pistol();\n            case KeyEvent.VK_2 -> weapon = new Rifle();\n            case KeyEvent.VK_3 -> weapon = new Shotgun();\n            case KeyEvent.VK_4 -> weapon = new Sniper();\n            case KeyEvent.VK_5 -> weapon = new RocketLauncher();\n            case KeyEvent.VK_R -> weapon.reload(); // 💥 R ile şarjör doldurma!\n        }\n    }\n    \n    public void reloadWeapon() {\n        weapon.reload();\n    }\n    \n    public void keyReleased(KeyEvent e) {\n        switch (e.getKeyCode()) {\n            case KeyEvent.VK_W -> up = false;\n            case KeyEvent.VK_S -> down = false;\n            case KeyEvent.VK_A -> left = false;\n            case KeyEvent.VK_D -> right = false;\n        }\n    }\n\n    public Bullet[] shoot(int targetX, int targetY) {\n        Bullet[] result = weapon.fire(x, y, targetX, targetY);\n        return result != null ? result : new Bullet[0];\n    }\n\n    public int getX() { return x; }\n    public int getY() { return y; }\n    public void setX(int x) { this.x = x; }\n    public void setY(int y) { this.y = y; }\n\n\n    public int getHealth() { return health; }\n    public int getScore() { return score; }\n    public void addScore(int amount) { score += amount; }\n    public String getWeaponName() {\n        return weapon.getClass().getSimpleName();\n    }\n\n    public int getCurrentAmmo() { return weapon.getCurrentAmmo(); }\n    public int getTotalAmmo() { return weapon.getTotalAmmo(); }\n    public void takeDamage(int amount) {\n        health -= amount;\n        if (health < 0) health = 0;\n    }\n    \n    public void addAmmo(int amount) {\n        weapon.addAmmo(amount); // totalAmmo Weapon sınıfında tutuluyor\n    }\n    \n    public void setHealth(int h) { health = h; }\n    public void setScore(int s) { score = s; }\n    public void setWeaponByName(String name) {\n        switch (name) {\n            case \"Pistol\" -> weapon = new Pistol();\n            case \"Rifle\" -> weapon = new Rifle();\n            case \"Shotgun\" -> weapon = new Shotgun();\n            case \"Sniper\" -> weapon = new Sniper();\n            case \"RocketLauncher\" -> weapon = new RocketLauncher();\n            default -> weapon = new Pistol(); // fallback\n        }\n    }\n    \n}\n"
    },
    {
      "id": "1889298",
      "OyunBaslat.java": "import javax.swing.*;\nimport game.MenuPanel;\n\npublic class OyunBaslat {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Oyun\");\n        frame.setSize(800, 600);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setResizable(false);\n\n        MenuPanel menuPanel = new MenuPanel(frame);\n        frame.add(menuPanel);\n\n        frame.setVisible(true);\n    }\n}\n",
      "SurungenZombie.java": "package game;\nimport java.awt.*;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class SurungenZombie extends Zombie {\n    private Image SurungenZombieImage;\n\n    public SurungenZombie(int x, int y) {\n        super(x, y, 30, 2, 10, \"Başlıksız.png\");\n        try {\n            SurungenZombieImage = ImageIO.read(new File(\"Başlıksız.png\")); \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void update(Player player) {\n        double angle = Math.atan2(player.getY() - y, player.getX() - x);\n        x += speed * Math.cos(angle);\n        y += speed * Math.sin(angle);\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        if (SurungenZombieImage != null) {\n            g.drawImage(SurungenZombieImage, x - 15, y - 15, 30, 30, null); \n        } else {\n            g.setColor(Color.YELLOW);\n            g.fillRect(x - 15, y - 15, 30, 30);\n        }\n    }\n\n    @Override\n        public Rectangle getBounds() {\n            return new Rectangle(x - 15, y - 15, 30, 30);\n        }\n}",
      "WaveManager.java": "package game;\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.Random;\n\npublic class WaveManager {\n    private ArrayList<Zombie> zombies = new ArrayList<>();\n    private int wave = 1;\n    private Player player;\n    private Random random;\n\n    public WaveManager(Player player) {\n        this.player = player;\n        this.random = new Random();\n        spawnZombies();\n    }\n\n    public void spawnZombies() {\n        zombies.clear();\n        for (int i = 0; i < wave * 5; i++) {\n            int maxType = wave >= 4 ? 4 : wave;\n            int type = random.nextInt(maxType);\n            switch (type) {\n                case 0 -> zombies.add(new NormalZombie(rand(800), rand(600)));\n                case 1 -> zombies.add(new SurungenZombie(rand(800), rand(600)));\n                case 2 -> zombies.add(new TankZombie(rand(800), rand(600)));\n                case 3 -> zombies.add(new AsitTukurenZombie(rand(800), rand(600)));\n            }\n        }\n        wave++;\n        checkForNewGuns();\n    }\n\n    public void update() {\n        zombies.forEach(z -> z.update(player));\n        if (zombies.isEmpty()) {\n            spawnZombies();\n        }\n    }\n\n    public void draw(Graphics g) {\n        zombies.forEach(z -> z.draw(g));\n    }\n\n    private int rand(int max) {\n        return random.nextInt(max);\n    }\n\n    public ArrayList<Zombie> getZombies() {\n        return zombies;\n    }\n\n    private void checkForNewGuns() {\n        switch (wave) {\n            case 2 -> {\n                player.addWeapon(new Tüfek());\n            }\n            case 3 -> {\n                player.addWeapon(new Pompalı());\n            }\n            case 5 -> {\n                player.addWeapon(new Nişancı());\n            }\n            case 10 -> {\n                player.addWeapon(new Roketatar());\n            }\n        }\n    }\n\n    public int getCurrentWave() {\n        return wave; \n    }\n\n    public boolean isWaveComplete() {\n        return zombies.isEmpty(); \n    }\n\n    public void startNextWave() {\n        zombies.clear();\n        spawnZombies(); \n    }\n\n    public void setZombies(ArrayList<Zombie> zombies) {\n        this.zombies = zombies;\n    }\n\n    public int getWave() {\n        return wave;\n    }\n\n    public void setWave(int wave) {\n        this.wave = wave;\n    }\n\n    public Player getPlayer() {\n        return player;\n    }\n\n    public void setPlayer(Player player) {\n        this.player = player;\n    }\n\n    public Random getRandom() {\n        return random;\n    }\n\n    public void setRandom(Random random) {\n        this.random = random;\n    }\n\n    \n}",
      "Tabanca.java": "package game;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Tabanca extends Weapon {\n    public Tabanca() {\n        super(\"Tabanca\", 12, Integer.MAX_VALUE, 120, 0);\n    }\n\n    @Override\n    public List<Mermi> shoot(int startX, int startY, int targetX, int targetY) {\n        List<Mermi> mermiler = new ArrayList<>();\n        if (currentAmmo > 0) {\n            currentAmmo--;\n            mermiler.add(new Mermi(startX, startY, targetX, targetY, 10));\n        }\n        return mermiler;\n    }\n}",
      "Zombie.java": "package game;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic abstract class Zombie {\n    protected int x, y, health, speed, damage, width = 50, height = 50; \n    protected BufferedImage zombieImage;\n\n    public Zombie(int x, int y, int health, int speed, int damage, String imagePath) {\n        this.x = x;\n        this.y = y;\n        this.health = health;\n        this.speed = speed;\n        this.damage = damage;\n    \n        try {\n            zombieImage = ImageIO.read(new File(imagePath)); \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void update(Player player) {\n        \n        if (player.getX() > x) {\n            x += speed;\n        } else if (player.getX() < x) {\n            x -= speed;\n        }\n\n        if (player.getY() > y) {\n            y += speed;\n        } else if (player.getY() < y) {\n            y -= speed;\n        }\n\n    \n        x = Math.max(0, Math.min(800 - width, x));\n        y = Math.max(0, Math.min(600 - height, y));\n    }\n\n    public void draw(Graphics g) {\n        if (zombieImage != null) {\n            g.drawImage(zombieImage, x - 15, y - 15, 30, 30, null);\n        } else {\n            g.setColor(Color.RED);\n            g.fillRect(x - 15, y - 15, 30, 30); \n        }\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x - 15, y - 15, 30, 30);\n    }\n    public int getX() {\n        return x;\n    }\n    public void setX(int x) {\n        this.x = x;\n    }\n    public int getY() {\n        return y;\n    }\n    public void setY(int y) {\n        this.y = y;\n    }\n    public int getHealth() {\n        return health;\n    }\n    public void setHealth(int health) {\n        this.health = health;\n    }\n    public int getSpeed() {\n        return speed;\n    }\n    public void setSpeed(int speed) {\n        this.speed = speed;\n    }\n    public int getDamage() {\n        return damage;\n    }\n    public void setDamage(int damage) {\n        this.damage = damage;\n    }\n\n    \n\n}",
      "Roketatar.java": "package game;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Roketatar extends Weapon {\n    public Roketatar() {\n        super(\"Roketatar\", 1, 5, 2000, 0.0);\n    }\n\n    @Override\n    public List<Mermi> shoot(int startX, int startY, int targetX, int targetY) {\n        List<Mermi> mermiler = new ArrayList<>();\n        if (currentAmmo > 0) {\n            currentAmmo--;\n            mermiler.add(new PatlayanMermi(startX, startY, targetX, targetY, 100)); \n        }\n        return mermiler;\n    }\n}",
      "Mermi.java": "package game;\nimport java.awt.*;\n\npublic class Mermi {\n    private int x, y, damage;\n    private double dx, dy;\n    private boolean explosive = false;\n    private boolean isPiercing = false; \n    private int speed = 15;\n    private int targetX, targetY;\n    private int size = 8; \n\n    public Mermi(int x, int y, int targetX, int targetY, int damage) {\n        double farkX = targetX - x;\n        double farkY = targetY - y;\n        double uzunluk = Math.sqrt(farkX * farkX + farkY * farkY);\n        dx = (farkX / uzunluk) * speed;\n        dy = (farkY / uzunluk) * speed;\n        this.x = x;\n        this.y = y;\n        this.damage = damage;\n    }\n\n    public Mermi(int x, int y, int targetX, int targetY, int damage, double spreadAngle) {\n        double farkX = targetX - x;\n        double farkY = targetY - y;\n        double aci = Math.atan2(farkY, farkX) + spreadAngle;\n        dx = speed * Math.cos(aci);\n        dy = speed * Math.sin(aci);\n        this.x = x;\n        this.y = y;\n        this.damage = damage;\n    }\n\n    public Mermi(int startX, int startY, int targetX, int targetY, int damage, boolean isPiercing) {\n        this.x = startX;\n        this.y = startY;\n        this.targetX = targetX;\n        this.targetY = targetY;\n        this.damage = damage;\n        this.isPiercing = isPiercing;\n    \n}\n\n   \n\n    public void setPiercing(boolean piercing) {\n        this.isPiercing = piercing;\n    }\n\n    public void setExplosive(boolean explosive) {\n        this.explosive = explosive;\n    }\n\n    public void update() {\n        x += dx;\n        y += dy;\n    }\n    public boolean isOutOfBounds() {\n        return x < 0 || x > 800 || y < 0 || y > 600;\n    }\n\n    public void draw(Graphics g) {\n        if (explosive) {\n            g.setColor(Color.ORANGE);\n        } else if (isPiercing) {\n            g.setColor(Color.MAGENTA);\n        } else {\n            g.setColor(Color.RED);\n        }\n        g.fillOval(x, y, size, size);\n    }\n\n    public boolean checkCollision(Rectangle target) {\n        Rectangle mermiKutusu = new Rectangle(x, y, size, size);\n        return mermiKutusu.intersects(target);\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n    public boolean isPiercing() {\n        return isPiercing;\n    }\n\n    public boolean isExplosive() {\n        return explosive;\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, size, size);\n    }\n\n    \n}",
      "Weapon.java": "package game;\nimport java.io.Serializable;\nimport java.util.List;\n\npublic abstract class Weapon implements Serializable {\n    protected String name;\n    protected int magazineCapacity;\n    protected int currentAmmo;\n    protected int totalAmmo;\n    protected int fireRate;\n    protected double spreadAngle;\n\n    public Weapon(String name, int magazineCapacity, int totalAmmo, int fireRate, double spreadAngle) {\n        this.name = name;\n        this.magazineCapacity = magazineCapacity;\n        this.currentAmmo = magazineCapacity;\n        this.totalAmmo = totalAmmo;\n        this.fireRate = fireRate;\n        this.spreadAngle = spreadAngle;\n    }\n\n    public abstract List<Mermi> shoot(int startX, int startY, int targetX, int targetY);\n\n    public void reload() {\n        int needed = magazineCapacity - currentAmmo;\n        if (totalAmmo >= needed) {\n            totalAmmo -= needed;\n            currentAmmo = magazineCapacity;\n        } else {\n            currentAmmo += totalAmmo;\n            totalAmmo = 0;\n        }\n    }\n\n    public String getName() { return name; }\n    public int getCurrentAmmo() { return currentAmmo; }\n    public int getTotalAmmo() { return totalAmmo; }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getMagazineCapacity() {\n        return magazineCapacity;\n    }\n\n    public void setMagazineCapacity(int magazineCapacity) {\n        this.magazineCapacity = magazineCapacity;\n    }\n\n    public void setCurrentAmmo(int currentAmmo) {\n        this.currentAmmo = currentAmmo;\n    }\n\n    public void setTotalAmmo(int totalAmmo) {\n        this.totalAmmo = totalAmmo;\n    }\n\n    public int getFireRate() {\n        return fireRate;\n    }\n\n    public void setFireRate(int fireRate) {\n        this.fireRate = fireRate;\n    }\n\n    public double getSpreadAngle() {\n        return spreadAngle;\n    }\n\n    public void setSpreadAngle(double spreadAngle) {\n        this.spreadAngle = spreadAngle;\n    }\n    \n}",
      "Pompalı.java": "package game;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Pompalı extends Weapon {\n    public Pompalı() {\n        super(\"Pompalı Tüfek\", 5, 32, 1000, 45.0); \n    }\n\n    @Override\n    public List<Mermi> shoot(int startX, int startY, int targetX, int targetY) {\n        List<Mermi> mermiler = new ArrayList<>();\n        if (currentAmmo > 0) {\n            currentAmmo--;\n    \n            double baseAngle = Math.atan2(targetY - startY, targetX - startX);\n            double spreadStep = Math.toRadians(spreadAngle / 8); \n            for (int i = -4; i <= 4; i++) { \n                double angle = baseAngle + spreadStep * i;\n                int adjustedTargetX = (int) (startX + Math.cos(angle) * 1000);\n                int adjustedTargetY = (int) (startY + Math.sin(angle) * 1000);\n    \n                Mermi bullet = new Mermi(startX, startY, adjustedTargetX, adjustedTargetY, 10, angle);\n                mermiler.add(bullet);\n            }\n        }\n        return mermiler;\n    }\n}",
      "NormalZombie.java": "package game;\nimport java.awt.*;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class NormalZombie extends Zombie {\n\n    private Image NormalZombieImage;\n\n    public NormalZombie(int x, int y) {\n        super(x, y, 50, 1, 1, \"images.png\");\n        try {\n            NormalZombieImage = ImageIO.read(new File(\"images.png\")); \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        if (NormalZombieImage != null) {\n            g.drawImage(NormalZombieImage, x - 15, y - 15, 30, 30, null); \n        } else {\n            g.setColor(Color.GREEN);\n            g.fillRect(x - 15, y - 15, 30, 30);\n        }\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x - 15, y - 15, 30, 30);\n    }\n\n    \n}",
      "Nişancı.java": "package game;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Nişancı extends Weapon {\n    public Nişancı() {\n        super(\"Keskin Nişancı\", 5, 15, 2000, 0);\n    }\n\n    @Override\n    public List<Mermi> shoot(int startX, int startY, int targetX, int targetY) {\n        List<Mermi> mermiler = new ArrayList<>();\n        if (currentAmmo > 0) {\n            currentAmmo--;\n            mermiler.add(new Mermi(startX, startY, targetX, targetY, 50, true));\n        }\n        return mermiler;\n    }\n}",
      "Tüfek.java": "package game;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Tüfek extends Weapon {\n    public Tüfek() {\n        super(\"Piyade Tüfeği\", 30, 150, 600, 30);\n    }\n\n    @Override\n    public List<Mermi> shoot(int startX, int startY, int targetX, int targetY) {\n        List<Mermi> mermiler = new ArrayList<>();\n        if (currentAmmo > 0) {\n            currentAmmo--;\n\n            double baseAngle = Math.atan2(targetY - startY, targetX - startX);\n            double spreadStep = Math.toRadians(spreadAngle / 2); \n\n            for (int i = -1; i <= 1; i++) { // -1, 0, 1 için 3 mermi\n                double angle = baseAngle + spreadStep * i;\n                int adjustedTargetX = (int) (startX + Math.cos(angle) * 1000);\n                int adjustedTargetY = (int) (startY + Math.sin(angle) * 1000);\n\n                mermiler.add(new Mermi(startX, startY, adjustedTargetX, adjustedTargetY, 20));\n            }\n        }\n        return mermiler;\n    }\n}",
      "PatlayanMermi.java": "package game;\n\nimport java.awt.*;\nimport java.util.List;\n\npublic class PatlayanMermi extends Mermi {\n    private int patlamaYaricapi;\n\n    public PatlayanMermi(int startX, int startY, int targetX, int targetY, int damage) {\n        super(startX, startY, targetX, targetY, damage, 0.0);\n        this.patlamaYaricapi = 50; \n    }\n\n    public void onHit(List<Zombie> zombies) {\n        for (Zombie zombi : zombies) {\n            double distance = Math.sqrt(Math.pow(zombi.getX() - this.getX(), 2) + Math.pow(zombi.getY() - this.getY(), 2));\n            if (distance <= patlamaYaricapi) {\n                zombi.setHealth(zombi.getHealth() - this.getDamage());\n            }\n        }\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        g.setColor(Color.ORANGE);\n        g.fillOval(this.getX() - 5, this.getY() - 5, 10, 10); \n    }\n}",
      "TankZombie.java": "package game;\nimport java.awt.*;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class TankZombie extends Zombie {\n    private Image TankZombieImage;\n\n    public TankZombie(int x, int y) {\n        super(x, y, 200, 1, 20, \"images3.png\");\n        try {\n            TankZombieImage = ImageIO.read(new File(\"images3.png\")); \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        if (TankZombieImage != null) {\n            g.drawImage(TankZombieImage, x - 20, y - 20, 40, 40, null); \n        } else {\n            g.setColor(Color.DARK_GRAY);\n            g.fillRect(x - 20, y - 20, 40, 40); \n        }\n    }\n\n    @Override\n        public Rectangle getBounds() {\n            return new Rectangle(x - 15, y - 15, 30, 30);\n        }\n}",
      "Game.java": "package game;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Game extends JPanel implements KeyListener, MouseListener, Runnable {\n    Player player;\n    WaveManager waveManager;\n    ArrayList<Mermi> mermiler = new ArrayList<>();\n    boolean paused = false;\n    boolean running = true;\n    boolean weaponMenuOpen = false;\n    private BufferedImage backgroundImage;\n    boolean gameOver = false;\n    private long endTime; \n    private long startTime;\n\n    public Game() {\n        \n        addKeyListener(this);\n        setFocusable(true);\n        requestFocus();\n        addMouseListener(this);\n\n        try {\n            backgroundImage = ImageIO.read(new File(\"backgrounddetailed2.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        this.setPreferredSize(new Dimension(800, 600));\n\n        player = new Player(400, 300);\n        waveManager = new WaveManager(player);\n\n        startTime = System.currentTimeMillis();\n        new Thread(this).start();\n    }\n\n    @Override\npublic void run() {\n    long lastUpdateTime = System.nanoTime();\n    final double nsPerUpdate = 1_000_000_000.0 / 25;\n\n    while (running) {\n        long now = System.nanoTime();\n        double delta = (now - lastUpdateTime) / nsPerUpdate;\n\n        if (!paused && delta >= 1) {\n            synchronized (this) {\n                updateGame();\n            }\n            lastUpdateTime = now;\n        }\n\n        repaint();\n        try {\n            Thread.sleep(1); \n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            e.printStackTrace();\n        }\n    }\n}\n\nprivate synchronized void updateGame() {\n    player.update();\n    waveManager.update();\n    mermiler.forEach(Mermi::update);\n    mermiler.removeIf(Mermi::isOutOfBounds);\n\n    ArrayList<Zombie> zombies = waveManager.getZombies();\n    ArrayList<Mermi> vurulanMermiler = new ArrayList<>();\n    ArrayList<Zombie> oldurulenZombiler = new ArrayList<>();\n\n    for (Mermi mermi : mermiler) {\n        for (Zombie zombi : zombies) {\n            if (mermi.getBounds().intersects(zombi.getBounds())) {\n                zombi.setHealth(zombi.getHealth() - mermi.getDamage());\n\n                if (zombi.getHealth() <= 0) {\n                    oldurulenZombiler.add(zombi);\n                    player.setScore(player.getScore() + 10);\n                }\n\n                if (mermi.isPiercing()) {\n                    \n                } else {\n                    vurulanMermiler.add(mermi);\n                    break;\n                }\n            }\n        }\n    }\n\n    zombies.removeAll(oldurulenZombiler);\n    mermiler.removeAll(vurulanMermiler);\n\n    for (Zombie zombi : zombies) {\n        zombi.update(player);\n\n        if (zombi.getBounds().intersects(player.getBounds())) {\n            player.takeDamage(zombi.getDamage());\n        }\n    }\n\n    if (player.getHealth() <= 0) {\n        running = false;\n        gameOver = true;\n        endTime = System.currentTimeMillis();\n    }\n\n    if (waveManager.isWaveComplete()) {\n        for (Weapon weapon : player.getInventory()) {\n            if (!weapon.getName().equals(\"Tabanca\")) {\n                weapon.setTotalAmmo(weapon.getTotalAmmo() + 30);\n            }\n        }\n        player.healAfterWave();\n        waveManager.startNextWave();\n    }\n}\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        if (backgroundImage != null) {\n            g.drawImage(backgroundImage, 0, 0, getWidth(), getHeight(), null); \n        } else {\n            g.setColor(Color.BLACK);\n            g.fillRect(0, 0, getWidth(), getHeight());\n        }\n        player.draw(g);\n        waveManager.draw(g);\n        mermiler.forEach(m -> m.draw(g));\n        drawHUD(g);\n        if (weaponMenuOpen) {\n            drawWeaponMenu(g);\n        }\n        if (gameOver) {\n            drawGameOverScreen(g);\n        }\n        if (paused && !gameOver) {\n            drawPauseMenu(g);\n        }\n    }\n\n    private void drawPauseMenu(Graphics g) {\n        g.setColor(new Color(0, 0, 0, 200));\n        g.fillRect(0, 0, getWidth(), getHeight());\n    \n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 40));\n        g.drawString(\"OYUN DURAKLATILDI\", getWidth() / 2 - 200, getHeight() / 2 - 100);\n    \n        g.setFont(new Font(\"Arial\", Font.PLAIN, 30));\n        g.drawString(\"1. Yükle\", getWidth() / 2 - 100, getHeight() / 2);\n        g.drawString(\"2. Çık\", getWidth() / 2 - 100, getHeight() / 2 + 50);\n    }\n\n    private void drawGameOverScreen(Graphics g) {\n        g.setColor(new Color(0, 0, 0, 200));\n        g.fillRect(0, 0, getWidth(), getHeight());\n    \n        g.setColor(Color.RED);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 50));\n        g.drawString(\"GAME OVER\", getWidth() / 2 - 150, getHeight() / 2 - 50);\n    \n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.PLAIN, 30));\n        g.drawString(\"Skor: \" + player.getScore(), getWidth() / 2 - 100, getHeight() / 2 + 10);\n    \n        long survivalTime = (endTime - startTime) / 1000;\n        g.drawString(\"Süre: \" + survivalTime + \" saniye\", getWidth() / 2 - 100, getHeight() / 2 + 50);\n    \n        g.setFont(new Font(\"Arial\", Font.PLAIN, 20));\n        g.drawString(\"Çıkmak için ESC'ye basın.\", getWidth() / 2 - 100, getHeight() / 2 + 100);\n    }\n\n    private void drawHUD(Graphics g) {\n        \n        g.setColor(new Color(50, 50, 50, 200));\n        g.fillRect(0, 0, getWidth(), 50);\n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 14));\n        g.drawString(\"Can: \" + player.getHealth(), 10, 20);\n        g.drawString(\"Skor: \" + player.getScore(), 150, 20);\n        g.drawString(\"Silah: \" + player.getCurrentWeapon().getName(), 300, 20);\n        g.drawString(\"Mermi: \" + player.getCurrentWeapon().getCurrentAmmo() + \" / \" + player.getCurrentWeapon().getTotalAmmo(), 450, 20);\n    }\n\n    private void drawWeaponMenu(Graphics g) {\n        g.setColor(new Color(0, 0, 0, 150));\n        g.fillRect(100, 100, 600, 400);\n\n        g.setColor(Color.WHITE);\n        g.drawString(\"Silah Seçimi\", 350, 130);\n\n        ArrayList<Weapon> inventory = player.getInventory();\n        for (int i = 0; i < inventory.size(); i++) {\n            Weapon weapon = inventory.get(i);\n            g.drawString((i + 1) + \". \" + weapon.getName(), 150, 180 + i * 30);\n        }\n\n        g.drawString(\"Bir silah seçmek için 1-\" + inventory.size() + \" tuşlarına basın.\", 150, 380);\n        g.drawString(\"Menüyü kapatmak için ESC'ye basın.\", 150, 410);\n    }\n\n    @Override\npublic void keyPressed(KeyEvent e) {\n    if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {\n        if (weaponMenuOpen) {\n            weaponMenuOpen = false;\n        } else {\n            paused = !paused;\n        }\n    } else if (paused && !gameOver) {\n        if (e.getKeyCode() == KeyEvent.VK_1) {\n            saveGame();\n            paused = false;\n        } else if (e.getKeyCode() == KeyEvent.VK_2) {\n            System.exit(0);\n        }\n    } else if (weaponMenuOpen) {\n        int key = e.getKeyCode() - KeyEvent.VK_1;\n        if (key >= 0 && key < player.getInventory().size()) {\n            player.setCurrentWeapon(player.getInventory().get(key));\n            weaponMenuOpen = false;\n        }\n    } else {\n        if (e.getKeyCode() == KeyEvent.VK_W) player.up = true;\n        if (e.getKeyCode() == KeyEvent.VK_S) player.down = true;\n        if (e.getKeyCode() == KeyEvent.VK_A) player.left = true;\n        if (e.getKeyCode() == KeyEvent.VK_D) player.right = true;\n        if (e.getKeyCode() == KeyEvent.VK_M) weaponMenuOpen = true;\n        if (e.getKeyCode() == KeyEvent.VK_R) player.reload();\n    }\n}\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_W) player.up = false;\n        if (e.getKeyCode() == KeyEvent.VK_S) player.down = false;\n        if (e.getKeyCode() == KeyEvent.VK_A) player.left = false;\n        if (e.getKeyCode() == KeyEvent.VK_D) player.right = false;\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        if (!gameOver && !paused) {\n            List<Mermi> yeniMermiler = player.getCurrentWeapon().shoot((int) player.getX(), (int) player.getY(), e.getX(), e.getY());\n            if (yeniMermiler != null) {\n                mermiler.addAll(yeniMermiler);\n            }\n        }\n    }\n\n    public void keyTyped(KeyEvent e) {}\n    public void mouseClicked(MouseEvent e) {}\n    public void mouseReleased(MouseEvent e) {}\n    public void mouseEntered(MouseEvent e) {}\n    public void mouseExited(MouseEvent e) {}\n\n    private void saveGame() {\n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"oyun_durumu.ser\"))) {\n            OyunDurumu oyunDurumu = new OyunDurumu(player, waveManager.getZombies(), mermiler, player.getScore());\n            oos.writeObject(oyunDurumu);\n            JOptionPane.showMessageDialog(this, \"Oyun başarıyla kaydedildi!\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            JOptionPane.showMessageDialog(this, \"Oyun kaydedilirken bir hata oluştu.\");\n        }\n    }\n\n    private void loadGame() {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"oyun_durumu.ser\"))) {\n            OyunDurumu oyunDurumu = (OyunDurumu) ois.readObject();\n            this.player = oyunDurumu.getPlayer();\n            this.waveManager.setZombies(new ArrayList<>(oyunDurumu.getZombies()));\n            this.mermiler = new ArrayList<>(oyunDurumu.getMermiler());\n            this.player.setScore(oyunDurumu.getScore());\n            JOptionPane.showMessageDialog(this, \"Oyun başarıyla yüklendi!\");\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n            JOptionPane.showMessageDialog(this, \"Oyun yüklenirken bir hata oluştu.\");\n        }\n    }\n}",
      "OyunDurumu.java": "package game;\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class OyunDurumu implements Serializable {\n    private Player player;\n    private List<Zombie> zombies;\n    private List<Mermi> mermiler;\n    private int score;\n\n    public OyunDurumu(Player player, List<Zombie> zombies, List<Mermi> mermiler, int score) {\n        this.player = player;\n        this.zombies = zombies;\n        this.mermiler = mermiler;\n        this.score = score;\n    }\n\n    public Player getPlayer() {\n        return player;\n    }\n\n    public List<Zombie> getZombies() {\n        return zombies;\n    }\n\n    public List<Mermi> getMermiler() {\n        return mermiler;\n    }\n\n    public int getScore() {\n        return score;\n    }\n}",
      "AsitTukurenZombie.java": "package game;\n\nimport java.awt.*;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.imageio.ImageIO;\n\npublic class AsitTukurenZombie extends Zombie {\n    private Image AsitTukurenZombieImage;\n    private List<Asit> asitler;\n    private long lastTukurmaTime;\n    private static final int TUKURME_DELAY = 2000;\n\n    public AsitTukurenZombie(int x, int y) {\n        super(x, y, 40, 1, 5, \"images2.png\");\n        asitler = new ArrayList<>();\n        lastTukurmaTime = System.currentTimeMillis();\n        try {\n            AsitTukurenZombieImage = ImageIO.read(new File(\"images2.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void update(Player player) {\n        if (player.getX() > x) {\n            x += speed;\n        } else if (player.getX() < x) {\n            x -= speed;\n        }\n\n        if (player.getY() > y) {\n            y += speed;\n        } else if (player.getY() < y) {\n            y -= speed;\n        }\n\n        long currentTime = System.currentTimeMillis();\n        if (currentTime - lastTukurmaTime >= TUKURME_DELAY) {\n            asitTukur(player);\n            lastTukurmaTime = currentTime;\n        }\n    }\n\n    private void asitTukur(Player player) {\n        int asitX = (int)player.getX() - 15;\n        int asitY = (int)player.getY() - 15;\n        asitler.add(new Asit(asitX, asitY, 30, 30, 10)); \n    }\n\n    @Override\n    public void draw(Graphics g) {\n        if (AsitTukurenZombieImage != null) {\n            g.drawImage(AsitTukurenZombieImage, x - 15, y - 15, 30, 30, null);\n        } else {\n            g.setColor(Color.BLUE);\n            g.fillRect(x - 15, y - 15, 30, 30);\n        }\n\n        for (Asit asit : asitler) {\n            asit.draw(g);\n        }\n    }\n\n    public List<Asit> getAsitler() {\n        return asitler;\n    }\n}",
      "MenuPanel.java": "package game;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class MenuPanel extends JPanel {\n    private JFrame frame;\n\n    public MenuPanel(JFrame frame) {\n        this.frame = frame;\n        setLayout(new GridBagLayout());\n        setBackground(new Color(30, 30, 30));\n\n        GridBagConstraints gbc = new GridBagConstraints();\n        gbc.insets = new Insets(10, 10, 10, 10);\n        gbc.gridx = 0;\n        gbc.gridy = 0;\n        gbc.anchor = GridBagConstraints.CENTER;\n\n        JLabel titleLabel = new JLabel(\"OYUN MENÜSÜ\");\n        titleLabel.setFont(new Font(\"Arial\", Font.BOLD, 32));\n        titleLabel.setForeground(Color.WHITE);\n        add(titleLabel, gbc);\n\n        gbc.gridy++;\n        JButton startButton = new JButton(\"Başla\");\n        startButton.setFont(new Font(\"Arial\", Font.BOLD, 20));\n        startButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                startGame();\n            }\n        });\n        add(startButton, gbc);\n\n        gbc.gridy++;\n        JButton loadButton = new JButton(\"Yükle\");\n        loadButton.setFont(new Font(\"Arial\", Font.BOLD, 20));\n        loadButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                loadGame();\n            }\n        });\n        add(loadButton, gbc);\n\n        gbc.gridy++;\n        JButton exitButton = new JButton(\"Çıkış\");\n        exitButton.setFont(new Font(\"Arial\", Font.BOLD, 20));\n        exitButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                System.exit(0);\n            }\n        });\n        add(exitButton, gbc);\n    }\n\n    private void startGame() {\n        frame.getContentPane().removeAll();\n        Game gamePanel = new Game();\n        frame.add(gamePanel);\n        frame.revalidate();\n        frame.repaint();\n        gamePanel.requestFocusInWindow();\n        new Thread(gamePanel).start();\n    }\n\n    private void loadGame() {\n        JOptionPane.showMessageDialog(this, \"Yükleme özelliği henüz eklenmedi.\");\n    }\n}",
      "Player.java": "package game;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.imageio.ImageIO;\n\npublic class Player extends Rectangle {\n    private int x, y, health = 100, score = 0;\n    public Weapon currentWeapon;\n    private ArrayList<Weapon> inventory = new ArrayList<>();\n    public boolean up,down,left,right;\n    private long lastDamageTime = 0;\n    private final long damageCooldown = 1000;\n    private BufferedImage playerImage;\n\n    public Player(int x, int y) {\n        this.x = x;\n        this.y = y;\n        currentWeapon = new Tabanca();\n        inventory.add(currentWeapon);\n        try {\n            playerImage = ImageIO.read(new File(\"survivor-idle_shotgun_0.png\")); \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void update() {\n        if (up) y -= 4;\n        if (down) y += 4;\n        if (left) x -= 4;\n        if (right) x += 4;\n        y = Math.max(0, Math.min(600 - 40, y));\n        x = Math.max(0, Math.min(800 - 40, x)); \n    }\n\n    public void draw(Graphics g) {\n        if (playerImage != null) {\n            g.drawImage(playerImage, x - 20, y - 20, 40, 40, null); \n        } else {\n            g.setColor(Color.BLUE);\n            g.fillOval(x - 20, y - 20, 40, 40); \n        }\n    }\n\n    public Mermi shoot(int targetX, int targetY) {\n        List<Mermi> bullets = currentWeapon.shoot(x, y, targetX, targetY);\n        return bullets.isEmpty() ? null : bullets.get(0);\n    }\n\n    public void reload() {\n        if (currentWeapon != null) {\n            currentWeapon.reload();\n        }\n    }\n\n    public void nextWeapon() {\n        int currentIndex = inventory.indexOf(currentWeapon);\n        currentIndex = (currentIndex + 1) % inventory.size();\n        currentWeapon = inventory.get(currentIndex);\n    }\n\n    public void addWeapon(Weapon weapon) {\n        inventory.add(weapon);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x - 15, y - 15, 30, 30); \n    }\n\n    public boolean canTakeDamage() {\n        return System.currentTimeMillis() - lastDamageTime >= damageCooldown;\n    }\n\n    public void takeDamage(int damage) {\n        if (canTakeDamage()) {\n            health -= damage;\n            lastDamageTime = System.currentTimeMillis();\n        }\n    }\n\n    public void healAfterWave() {\n        if (health <= 80) {\n            health += 20; \n        } else if (health > 80 && health < 100) {\n            health = 100; \n        }\n    }\n\n    public Weapon getCurrentWeapon() { return currentWeapon; }\n    public int getHealth() { return health; }\n    public int getScore() { return score; }\n\n    @Override\n    public double getX() {\n        return (double) x;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    @Override\n    public double getY() {\n        return (double) y;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n    public void setHealth(int health) {\n        this.health = health;\n    }\n\n    public void setScore(int score) {\n        this.score = score;\n    }\n\n    public void setCurrentWeapon(Weapon currentWeapon) {\n        this.currentWeapon = currentWeapon;\n    }\n\n    public ArrayList<Weapon> getInventory() {\n        return inventory;\n    }\n\n    public void setInventory(ArrayList<Weapon> inventory) {\n        this.inventory = inventory;\n    }\n\n    \n}",
      "Asit.java": "package game;\n\nimport java.awt.*;\n\npublic class Asit {\n    private int x, y, width, height, damage;\n\n    public Asit(int x, int y, int width, int height, int damage) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.damage = damage;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(new Color(0, 255, 0, 150));\n        g.fillOval(x, y, width, height);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, width, height);\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n}\n"
    },
    {
      "id": "4810237",
      "Tabanca.java": "package oyunproje;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Tabanca implements Weapon{\n\tprivate final int magazineCapacity = 12;\n    private int currentMagazine;\n    private int totalAmmo=Integer.MAX_VALUE;\n\tprivate long lastFireTime = 0;\n\tprivate final long cooldown = 500; // 500 ms (saniyede 2 mermi)\n\tprivate List<Bullet> bullets = new ArrayList<>(); // ✅ List<Bullet> olarak değiştirildi\n\tpublic Tabanca() {\n        this.currentMagazine = magazineCapacity;\n    }\n\n\tpublic void addAmmo(int amount) {\n        // Tabanca için mermi sınırsız, bu yüzden bir şey yapma\n    }\n    @Override\n    public void fire(int x, int y, double angle) {\n        long currentTime = System.currentTimeMillis();\n        if (currentTime - lastFireTime < cooldown || currentMagazine <= 0) {\n            return;\n        }\n        // Yeni Bullet nesnesi oluştur ve listeye ekle\n        bullets.add(new Bullet(x, y, angle)); // Sarı mermi\n        currentMagazine--;\n        lastFireTime = currentTime;\n    }\n    public void update() {\n        // Mermileri Bullet sınıfının update metoduyla güncelle\n        for (Bullet bullet : bullets) {\n            bullet.update();\n        }\n        bullets.removeIf(Bullet::isOutOfBounds);\n    }\n    public void draw(Graphics g) {\n        g.setColor(Color.YELLOW); // Sarı mermi\n        for (Bullet bullet : bullets) {\n            bullet.draw(g); // Renk burada belirleniyor\n        }\n    }\n    @Override\n    public void reload() {\n        currentMagazine = magazineCapacity;\n    }\n\n    @Override\n    public int getMagazineCapacity() {\n        return magazineCapacity;\n    }\n\n    @Override\n    public int getTotalAmmo() {\n        return totalAmmo;\n    }\n    public String getDisplayName() {\n        return \"Tabanca\";\n    }\n    // İsteğe bağlı: Şarjördeki kalan mermi sayısını döndüren metod\n    public int getCurrentMagazine() {\n        return currentMagazine;\n    }\n    public List<Bullet> getBullets() { // ✅ Interface ile uyumlu\n        return bullets;\n    }\n}\n",
      "Zombie.java": "package oyunproje;\n\nimport java.awt.*;\nimport java.util.Random;\nimport javax.swing.ImageIcon;\n\npublic class Zombie {\n    private double x, y;\n    private int width = 40, height = 40;\n    private double speed = 1.2; // Biraz daha hızlı yapalım\n    private Player player;\n    private int health = 3;\n    private Image zombieImage;\n    private boolean isPaused = false; // Rastgele durma kontrolü\n    private long pauseEndTime = 0;\n    private Random random = new Random();\n    private int baseSpeed = 1;\n    private double speedMultiplier = 1.0;\n\n    public Zombie(int startX, int startY, Player player) {\n        this.x = startX;\n        this.y = startY;\n        this.player = player;\n        zombieImage = new ImageIcon(getClass().getClassLoader().getResource(\"zombie.png\")).getImage();\n\n        if (zombieImage == null) {\n            System.err.println(\"⚠ Hata: zombie.png dosyası yüklenemedi!\");\n        }\n    }\n\n    public void setPosition(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setHealth(int health) {\n        this.health = health;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    // isPaused parametresi eklendi: Ana oyun döngüsünden kontrol edilecek\n    public void update(boolean isPaused) {\n        if (isPaused) return;\n\n        double currentSpeed = 0.4; // Hızı düşürdük\n\n        int dx = (int) (player.getX() - x);\n        int dy = (int) (player.getY() - y);\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance > 0) {\n            x += (dx / distance) * currentSpeed;\n            y += (dy / distance) * currentSpeed;\n        }\n    }\n\n\n    public void draw(Graphics g) {\n        g.drawImage(zombieImage, (int) x, (int) y, width, height, null);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle((int) x, (int) y, width, height);\n    }\n\n    public void takeDamage() {\n        health--;\n    }\n\n    public boolean isDead() {\n        return health <= 0;\n    }\n\n    public int getX() {\n        return (int) x;\n    }\n\n    public int getY() {\n        return (int) y;\n    }\n\n    // Zombiyi durdurmak için fonksiyon\n    private void stopForAWhile() {\n        this.isPaused = true;\n        pauseEndTime = System.currentTimeMillis() + (random.nextInt(400) + 200); // 0.2 - 0.6 saniye duracak\n    }\n}\n\n\n",
      "Weapon.java": "package oyunproje;\n\nimport java.awt.Graphics;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic interface Weapon {\n\tvoid fire(int x, int y, double angle);           // Ateş etme\n    void reload();         // Şarjör doldurma\n    void update(); // Mermileri yönetecek\n    void draw(Graphics g); // Mermileri çizecek\n    int getMagazineCapacity();\n    int getTotalAmmo();\n    List<Bullet> getBullets(); // ✅ Generic ekledik\n    void addAmmo(int amount);\n    int getCurrentMagazine();\n    String getDisplayName();\n}\n",
      "Bullet.java": "package oyunproje;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\n\npublic class Bullet {\n\tprivate int x, y; // Merminin konumu\n    private double angle; // Merminin ateşlenme açısı \n    private double speed = 5; // Sabit hız\n\n    public Bullet(int x, int y, double angle) {\n        this.x = x;\n        this.y = y;\n        this.angle = angle;\n    }\n\n    public void update() {\n        x += (int) (Math.cos(angle) * speed); \n        y += (int) (Math.sin(angle) * speed);\n    }\n    public boolean isOutOfBounds() {\n        return x < 0 || x > 800 || y < 0 || y > 600;\n    }\t\n\n    public void draw(Graphics g) {\n        // ❌ Sabit renk atamasını kaldırın!\n        g.fillOval(x - 2, y - 2, 5, 5);\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public double getAngle() {\n        return angle;\n    }\n}\n",
      "MainMenuPanel.java": "package oyunproje;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.GridBagLayout;\nimport java.awt.GridLayout;\n\nimport javax.swing.JButton;\nimport javax.swing.JPanel;\n\npublic class MainMenuPanel extends JPanel{\n\tprivate Game game;\n\n    public MainMenuPanel(Game game) {\n        this.game = game;\n        setLayout(new GridBagLayout());\n        setBackground(Color.BLACK);\n        setLayout(new BorderLayout());\n\n        // Başlangıç butonları\n        JButton startButton = new JButton(\"Oyun Başlat\");\n        \n\n        JButton quitButton = new JButton(\"Çık\");\n        quitButton.addActionListener(e -> {\n            System.exit(0); // Oyundan çık\n        });\n\n        // Butonları ekleyelim\n        JPanel buttonPanel = new JPanel();\n        buttonPanel.setLayout(new GridLayout(2, 1));\n        buttonPanel.add(startButton);\n        buttonPanel.add(quitButton);\n\n        add(buttonPanel, BorderLayout.CENTER);\n    }\n}\n",
      "WeaponType.java": "package oyunproje;\n\n\n\t public enum WeaponType {\n\t        PISTOL, RIFLE, SHOTGUN, SNIPER, ROCKET\n\t  }\n\n",
      "PiyadeTufegi.java": "package oyunproje;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PiyadeTufegi implements Weapon{\n\tprivate static final int MAX_AMMO = 30; // Şarjör kapasitesi\n    private int currentAmmo; // Geçerli mermi sayısı\n    private double firingRate; // Ateş hızı (dakikada mermi sayısı)\n    private double spreadAngle; // Sapma açısı (derece)\n    private List<Bullet> bullets = new ArrayList<>();\n    private int totalAmmo = 30;\n\n    public PiyadeTufegi() {\n        this.currentAmmo = MAX_AMMO; // Başlangıçta tüfekte tam mermi var\n        this.firingRate = 600.0; // 600 mermi/dakika\n        this.spreadAngle = 30.0; // 30 derece sapma\n        this.bullets = new ArrayList<>();\n    }\n    public void addAmmo(int amount) {\n        totalAmmo += amount;\n        System.out.println(\"Mermi eklendi! Yeni stok: \" + totalAmmo); // Debug\n    }\n    @Override\n    public void fire(int x, int y, double angle) {\n        if (currentAmmo > 0) {\n            double randomSpread = (Math.random() * 2 - 1) * Math.toRadians(30);\n            bullets.add(new Bullet(x, y, angle + randomSpread)); // Renk parametresi kaldırıldı\n            currentAmmo--;\n            System.out.println(\"Piyade Tüfeği ateşlendi! Kalan mermi: \" + currentAmmo); // Debug\n        } else {\n            System.out.println(\"Piyade Tüfeği şarjörü boş!\"); // Debug\n        }\n    }\n\n    @Override\n    public void reload() {\n    \tint needed = MAX_AMMO - currentAmmo;\n        int reloadAmount = Math.min(needed, totalAmmo);\n        currentAmmo += reloadAmount;\n        totalAmmo -= reloadAmount;\n    }\n\n    @Override\n    public void update() {\n        for (Bullet bullet : bullets) {\n            bullet.update();\n        }\n        bullets.removeIf(bullet ->\n                bullet.getX() < 0 || bullet.getX() > 800 ||\n                bullet.getY() < 0 || bullet.getY() > 600);\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        g.setColor(Color.RED); // Kırmızı renk\n        for (Bullet bullet : bullets) {\n            // Mermiyi kırmızı çiz\n            g.fillOval(bullet.getX() - 2, bullet.getY() - 2, 5, 5);\n        }\n    }\n\n    @Override\n    public int getMagazineCapacity() {\n        return MAX_AMMO; // Şarjör kapasitesini döndür\n    }\n\n    @Override\n    public int getTotalAmmo() {\n        return totalAmmo; // ✔️ Doğru değişken\n    }\n    public List<Bullet> getBullets() {\n        return bullets;\n    }\n    public int getCurrentMagazine() {\n        return currentAmmo;\n    }\n\t@Override\n\tpublic String getDisplayName() {\n\t\t// TODO Auto-generated method stub\n\t\treturn \"Piyade Tüfeği\";\n\t}\n}\n",
      "GamePanel.java": "package oyunproje;\n\nimport javax.swing.*;\n\nimport oyunproje.WeaponType; \n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Random;\n\npublic class GamePanel extends JPanel implements Runnable, KeyListener {\n\tprivate Game game;\n    private Thread gameThread;\n    private boolean running = false;\n    private ArrayList<Zombie> zombies;\n    private Random random;\n    // Diğer değişkenler\n    private int waveNumber = 1;\n    private int score = 0;  // Puan\n    private boolean isPaused = false;\n    private static final String SAVE_FILE = \"gameSave.dat\"; // Kaydetme dosyası\n    private ArrayList<AmmaDrop> ammaDrops = new ArrayList<>();\n\tprivate Player player;\n    \n    public GamePanel(Game game) {  // Game nesnesi parametre olarak alınır.\n        this.game = game;  // Game nesnesini alanımıza atıyoruz.\n        this.player = game.player; // Game'den Player'ı al\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.BLACK);\n        setFocusable(true);\n        requestFocusInWindow();\n        addKeyListener(this);\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (!isPaused) {\n                    fireBullet(e.getX(), e.getY()); // ✅ Fare tıklaması çalışıyor mu?\n                }\n            }\n        });\n\n        \n        zombies = new ArrayList<>();\n        random = new Random();\n        for (int i = 0; i < 3; i++) {\n            spawnZombie();\n        }\n        startGame();\n    }\n    public void nextWave() {\n        game.startNewWave();\n    }\n\n\n    private void startGame() {\n        running = true;\n        gameThread = new Thread(this);\n        gameThread.start();\n    }\n\n    public void togglePause() {\n        isPaused = !isPaused;\n        System.out.println(\"Oyun duraklatıldı: \" + isPaused);\n    }\n\n    @Override\n    public void run() {\n        while (running) {\n            update();   // Oyun mantığını güncelle\n            repaint();  // Ekranı yenile\n            if (player.isDead()) {\n                showGameOver(); // Oyuncu öldüğünde game over\n                break;\n            }\n            try {\n                Thread.sleep(16); // Yaklaşık 60 FPS\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    private void update() {\n        \n        // Ammo drop toplama kontrolü\n        Iterator<AmmaDrop> dropIterator = ammaDrops.iterator();\n        while (dropIterator.hasNext()) {\n            AmmaDrop drop = dropIterator.next();\n            if (player.getBounds().intersects(drop.getBounds())) {\n            \tif(drop.getType() == WeaponType.SHOTGUN) {\n            \t    player.getCurrentWeapon().addAmmo(5); \n            \t} \n            \telse if(drop.getType() == WeaponType.PISTOL) {\n            \t    player.getCurrentWeapon().addAmmo(15);\n            \t}\n                \n                dropIterator.remove();\n            }\n        }\n        \n        // Eğer dalga bittiğinde yeni ammo drop ekleme (bu kısım isteğe bağlı)\n        if (zombies.isEmpty()) {\n            game.startNewWave(); // Yeni dalgayı başlat\n            waveNumber++;\n            spawnNewWave(); // Yeni zombileri ekle\n            System.out.println(\"Yeni dalga: \" + waveNumber); // Debug\n        }\n\n        if (!isPaused) {\n            player.update();\n            player.getCurrentWeapon().update();\n\n            // Mermi ve zombi çarpışma kontrolü (Tabanca için)\n         // Mermi ve zombi çarpışma kontrolü\n            Weapon currentWeapon = player.getCurrentWeapon();\n            List<Bullet> bullets = currentWeapon.getBullets();\n\n            Iterator<Bullet> bulletIterator = bullets.iterator();\n            while (bulletIterator.hasNext()) {\n                Bullet bullet = bulletIterator.next();\n                int bulletX = bullet.getX();\n                int bulletY = bullet.getY();\n\n\n                // Zombi iterator'ı\n             // GamePanel.java içinde bullet-zombi çarpışma kısmını şöyle değiştirin:\n                Iterator<Zombie> zombieIterator1 = zombies.iterator();\n                while (zombieIterator1.hasNext()) {\n                    Zombie zombie = zombieIterator1.next();\n                    if (zombie.getBounds().contains(bulletX, bulletY)) {\n                        zombie.takeDamage();\n                        if (zombie.isDead()) {\n                            // ✔️ Mermi düşürme kontrolü buraya taşındı\n                            if (new Random().nextDouble() < 0.3) {\n                            \tWeaponType type = new Random().nextBoolean() ? WeaponType.SHOTGUN : WeaponType.PISTOL;\n                                ammaDrops.add(new AmmaDrop(zombie.getX(), zombie.getY(), type));\n                            }\n                            zombieIterator1.remove();\n                            score += 10;\n                        }\n                        bulletIterator.remove();\n                        break;\n                    }\n                }\n            }\n             \n\n            // Zombileri güncelle\n            for (int i = 0; i < zombies.size(); i++) {\n                zombies.get(i).update(isPaused);\n            }\n\n            // Oyuncu-zombi çarpışması kontrolü\n            for (Zombie zombie : zombies) {\n                if (player.getBounds().intersects(zombie.getBounds())) {\n                    player.takeDamage();\n                    if (player.isDead()) {\n                        showGameOver();\n                        running = false;\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        \n        // Oyun bitmişse GAME OVER ekranı göster\n        if (!running) {\n            g.setColor(Color.RED);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 50));\n            g.drawString(\"GAME OVER\", 250, 300);\n            return;\n        }\n        \n        if (isPaused) {\n            g.setColor(Color.RED);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 30));\n            g.drawString(\"Oyun Duraklatıldı\", 200, 200);\n        } else {\n            // Zombileri çiz\n            for (Zombie z : zombies) {\n                z.draw(g);\n            }\n            // Oyuncuyu çiz\n            player.draw(g);\n            // Oyuncunun silahı tarafından üretilen mermileri çiz\n            player.getCurrentWeapon().draw(g); \n        }\n        for (AmmaDrop drop : ammaDrops) {\n            drop.draw(g);\n        }\n        drawHUD(g);\n    }\n    \n    private void drawHUD(Graphics g) {\n        // Sol üst: Silah ve Mermi\n        g.setColor(new Color(0, 0, 0, 200)); // Daha opak siyah\n        g.fillRoundRect(10, 10, 200, 60, 15, 15);\n        \n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 20));\n        Weapon weapon = player.getCurrentWeapon();\n        g.drawString(weapon.getDisplayName(), 25, 35);\n        g.drawString(weapon.getCurrentMagazine() + \"/\" + weapon.getTotalAmmo(), 25, 60);\n\n        // Sağ üst: Can ve Puan (DÜZELTİLDİ)\n        int rightHudX = getWidth() - 210; // Sağ kenardan 210px içeri\n        int rightHudY = 10;\n        \n        // 1. Önce arka planı çiz\n        g.setColor(new Color(0, 0, 0, 200)); // %78 opak siyah\n        g.fillRoundRect(rightHudX, rightHudY, 200, 60, 15, 15);\n        \n        // 2. Sonra yazıları çiz\n        g.setColor(Color.WHITE);\n        g.drawString(\"CAN: \" + player.getHealth(), rightHudX + 20, rightHudY + 25);\n        g.drawString(\"PUAN: \" + score, rightHudX + 20, rightHudY + 50);\n    }\n    \n    private void spawnZombie() {\n        int x = random.nextInt(800);\n        int y = random.nextInt(600);\n        zombies.add(new Zombie(x, y, player));\n    }\n    \n    // Artık fireBullet metodu, Bullet nesnesi eklemek yerine oyuncunun silahını kullanır.\n    private void fireBullet(int targetX, int targetY) {\n        int playerCenterX = player.getX() + (player.getWidth() / 2); // Merkez X\n        int playerCenterY = player.getY() + (player.getHeight() / 2); // Merkez Y\n        double angle = Math.atan2(targetY - playerCenterY, targetX - playerCenterX);\n        player.fireCurrentWeapon(angle); // Açıyı radyan olarak gönder\n    }\n    \n    private void showGameOver() {\n        running = false;\n        repaint();\n    }\n    \n    @Override\n    public void keyTyped(KeyEvent e) {}\n    \n    @Override\n    public void keyPressed(KeyEvent e) {\n    \tplayer.keyPressed(e.getKeyCode());\n        if (e.getKeyCode() == KeyEvent.VK_P) {\n            togglePause();\n        } else if (e.getKeyCode() == KeyEvent.VK_S) {\n            saveGame();\n        } else if (e.getKeyCode() == KeyEvent.VK_L) {\n            loadGame();\n        } else if (e.getKeyCode() == KeyEvent.VK_R) { // ✔️ Yeni eklenen kısım\n        \tplayer.getCurrentWeapon().reload();\n        }\n    }\n    \n    @Override\n    public void keyReleased(KeyEvent e) {\n        player.keyReleased(e.getKeyCode());\n    }\n    \n    public void saveGame() {\n        try (PrintWriter writer = new PrintWriter(new FileWriter(\"save.txt\"))) {\n            writer.println(player.getX() + \" \" + player.getY());\n            writer.println(player.getImagePath());\n            writer.println(player.getHealth());\n            writer.println(zombies.size());\n            for (Zombie z : zombies) {\n                writer.println(z.getX() + \" \" + z.getY() + \" \" + z.getHealth());\n            }\n            System.out.println(\"Oyun kaydedildi!\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public void loadGame() {\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"save.txt\"))) {\n            String[] playerData = reader.readLine().split(\" \");\n            player.setPosition(Integer.parseInt(playerData[0]), Integer.parseInt(playerData[1]));\n            String imagePath = reader.readLine();\n            player.setImagePath(imagePath);\n            player.setHealth(Integer.parseInt(reader.readLine()));\n            int zombieCount = Integer.parseInt(reader.readLine());\n            zombies.clear();\n            for (int i = 0; i < zombieCount; i++) {\n                String[] zombieData = reader.readLine().split(\" \");\n                int zx = Integer.parseInt(zombieData[0]);\n                int zy = Integer.parseInt(zombieData[1]);\n                int zHealth = Integer.parseInt(zombieData[2]);\n                Zombie z = new Zombie(zx, zy, player);\n                z.setHealth(zHealth);\n                zombies.add(z);\n            }\n            System.out.println(\"Oyun yüklendi!\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    private void spawnNewWave() {\n        waveNumber++;\n        Random rand = new Random();\n\n        if (rand.nextDouble() < 0.5) {\n            int dropX = random.nextInt(800);\n            int dropY = random.nextInt(600);\n            // WeaponType ekleyin\n            ammaDrops.add(new AmmaDrop(dropX, dropY, WeaponType.SHOTGUN)); \n        }\n\n        int zombieCount = waveNumber + 2;\n        for (int i = 0; i < zombieCount; i++) {\n            spawnZombie();\n        }\n        System.out.println(\"Yeni dalga başladı! Dalga: \" + waveNumber);\n    }\n\n    \n    // Eğer ayrıca gameLoop() metodunu kullanmak istiyorsanız, onu da burada tutabilirsiniz.\n    public void gameLoop() {\n        if (isPaused) return;\n        if (player.isDead()) {\n            showGameOver();\n            running = false;\n            return;\n        }\n        for (Zombie z : zombies) {\n            z.update(isPaused);\n        }\n        for (Zombie z : zombies) {\n            if (player.getBounds().intersects(z.getBounds())) {\n                player.takeDamage();\n                if (player.isDead()) {\n                    showGameOver();\n                    running = false;\n                    return;\n                }\n            }\n        }\n        repaint();\n    }\n    \n    public boolean isPaused() {\n        return isPaused;\n    }\n}\n\n\n",
      "AmmaDrop.java": "// AmmaDrop.java\npackage oyunproje;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class AmmaDrop {\n    private WeaponType type;\n    private int x, y;\n    private final int SIZE = 16;\n\n    public AmmaDrop(int x, int y, WeaponType type) {\n        this.x = x;\n        this.y = y;\n        this.type = type;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(type == WeaponType.SHOTGUN ? Color.ORANGE : Color.GREEN);\n        g.fillRect(x, y, SIZE, SIZE);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, SIZE, SIZE);\n    }\n\n    public WeaponType getType() {\n        return type;\n    }\n}\n",
      "PompalНTufek.java": "package oyunproje;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PompalıTufek implements Weapon{\n\n\t    private static final int MAX_AMMO = 5;\n\t    private int currentAmmo;\n\t    private int totalAmmo;\n\t    private long lastFireTime;\n\t    private final long cooldown = 1000; // 60 RPM (saniyede 1 atış)\n\t    private List<Bullet> bullets; // Listeyi sınıf düzeyinde tanımlayın\n\t    \n\n\t    public PompalıTufek() {\n\t        this.currentAmmo = MAX_AMMO;\n\t        this.totalAmmo = 15; // Başlangıç mermisi\n\t        this.bullets = new ArrayList<>();\n\t    }\n\n\t    @Override\n\t    public void fire(int x, int y, double angle) {\n\t        long currentTime = System.currentTimeMillis();\n\t        \n\t        // Cooldown ve mermi kontrolü\n\t        if (currentTime - lastFireTime < cooldown || currentAmmo <= 0) {\n\t            return;\n\t        }\n\n\t        // 45 derecelik yayda 9 mermi\n\t        double startAngle = angle - Math.toRadians(22.5); // -22.5 derece (radyan)\n\t        double angleIncrement = Math.toRadians(5); // 5 derece (radyan)\n\n\t        for (int i = 0; i < 9; i++) {\n\t            double pelletAngle = startAngle + (angleIncrement * i);\n\t            System.out.println(\"Mermi \" + i + \" Açısı: \" + Math.toDegrees(pelletAngle));\n\t            bullets.add(new Bullet(x, y, pelletAngle));\n\t        }\n\n\t        currentAmmo--;\n\t        lastFireTime = currentTime; // Zamanı güncelle\n\t    }\n\n\t    @Override\n\t    public void reload() {\n\t        int reloadAmount = Math.min(MAX_AMMO - currentAmmo, totalAmmo);\n\t        currentAmmo += reloadAmount;\n\t        totalAmmo -= reloadAmount;\n\t    }\n\n\t    @Override\n\t    public void update() {\n\t        bullets.removeIf(Bullet::isOutOfBounds);\n\t    }\n\n\t    @Override\n\t    public void draw(Graphics g) {\n\t        g.setColor(new Color(139, 69, 19)); // Kahverengi\n\t        for (Bullet b : bullets) {\n\t            b.draw(g); // Mermileri çiz\n\t        }\n\t    }\n\n\t    @Override\n\t    public int getMagazineCapacity() {\n\t        return MAX_AMMO;\n\t    }\n\n\t    @Override\n\t    public int getTotalAmmo() {\n\t        return totalAmmo;\n\t    }\n\n\t    @Override\n\t    public List<Bullet> getBullets() {\n\t        return bullets;\n\t    }\n\n\t    @Override\n\t    public void addAmmo(int amount) {\n\t        totalAmmo += amount;\n\t    }\n\t    \n\t    public String getDisplayName() {\n\t        return \"Pompalı Tüfek\";\n\t    }\n\t    \n\t    public int getCurrentMagazine() {\n\t        return currentAmmo;\n\t    }\n\t}\n\n",
      "Game.java": "package oyunproje;\n\nimport java.awt.event.KeyEvent;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport javax.swing.JFrame;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JMenuItem;\nimport javax.swing.SwingUtilities;\nimport javax.swing.UIManager;\n\npublic class Game {\n    private JFrame frame;\n    private GamePanel gamePanel;\n    private boolean isPaused = false;\n    Player player;\n    private int currentWave;\n    private ArrayList<Zombie> zombies;\n\n    public Game() {\n        // Frame oluşturuluyor\n    \tthis.player = new Player(400, 300); // Oyuncu oluşturuldu\n    \t\n    \tthis.currentWave = 1; // Başlangıç dalgası 1\n    \t\n        frame = new JFrame(\"Top-Down Shooter\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setResizable(false);\n        frame.setSize(800, 600); // Pencere boyutu\n        frame.setLocationRelativeTo(null); // Pencereyi ekranın ortasına yerleştir\n\n        gamePanel = new GamePanel(this); // Oyun panelini oluştur\n        \n        frame.add(gamePanel); // Paneli frame'e ekle\n\n        // Menü çubuğu oluşturuluyor\n        JMenuBar menuBar = new JMenuBar();\n        JMenu gameMenu = new JMenu(\"Oyun\");\n\n        // Menü öğeleri: Duraklat, Kaydet, Yükle\n        JMenuItem pauseItem = new JMenuItem(\"Duraklat\");\n        JMenuItem saveItem = new JMenuItem(\"Kaydet\");\n        JMenuItem loadItem = new JMenuItem(\"Yükle\");\n\n        pauseItem.addActionListener(e -> {\n            gamePanel.togglePause();\n            System.out.println(\"Oyunun duraklatma durumu: \" + gamePanel.isPaused());\n            gamePanel.repaint();\n        });\n        saveItem.addActionListener(e -> gamePanel.saveGame());\n        loadItem.addActionListener(e -> {\n            gamePanel.loadGame();\n            gamePanel.repaint();\n        });\n        \n        // Menü öğeleri menüye ekleniyor\n        gameMenu.add(pauseItem);\n        gameMenu.add(saveItem);\n        gameMenu.add(loadItem);\n        menuBar.add(gameMenu);\n\n        // Menü çubuğu frame'e ekleniyor\n        frame.setJMenuBar(menuBar);\n        System.out.println(\"Menü eklendi mi? \" + (frame.getJMenuBar() != null)); // Menü eklenip eklenmediğini kontrol et\n        frame.revalidate(); // Bileşenleri yeniden hesapla\n        frame.repaint();   \n\n        // Frame görünür hale getirilmesi\n        frame.setVisible(true);\n\n        // GamePanel'in klavye odaklanmasını sağla\n        SwingUtilities.invokeLater(() -> gamePanel.requestFocusInWindow());\n    }\n    public void startNewWave() {\n        currentWave++; // Yeni dalgaya geç\n        checkForWeapons(); // Tüfeğin verilip verilmediğini kontrol et\n    }\n    private void checkForWeapons() {\n        if (currentWave == 2) {\n            player.addWeapon(new PiyadeTufegi());\n            System.out.println(\"🎯 PİYADE TÜFEĞİ VERİLDİ!\"); // Debug\n        }\n        else if (currentWave == 3) { // 3. dalgada pompalı tüfek ver\n            player.addWeapon(new PompalıTufek());\n        }\n    }\n    public void togglePause() {\n        isPaused = !isPaused;\n    }\n    public int getCurrentWave() {\n        return currentWave;\n    }\n\n    public void updateGame() {\n        if (isPaused) return; // Eğer duraklatılmışsa update etme\n        // Normal oyun güncelleme kodları buraya gelecek\n    }\n\n    public void loadGame() {\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"save.txt\"))) {\n            String[] playerData = reader.readLine().split(\" \");\n            player.setPosition(Integer.parseInt(playerData[0]), Integer.parseInt(playerData[1]));\n\n            int zombieCount = Integer.parseInt(reader.readLine());\n            zombies.clear();\n            for (int i = 0; i < zombieCount; i++) {\n                String[] zombieData = reader.readLine().split(\" \");\n                int zx = Integer.parseInt(zombieData[0]);\n                int zy = Integer.parseInt(zombieData[1]);\n                int zHealth = Integer.parseInt(zombieData[2]);\n\n                Zombie z = new Zombie(zx, zy, player);\n                z.setHealth(zHealth);\n                zombies.add(z);\n            }\n            System.out.println(\"Oyun yüklendi!\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void keyPressed(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_P) { // 'P' tuşuna basınca duraklat\n            togglePause();\n        }\n        if (e.getKeyCode() == KeyEvent.VK_S) { // 'S' tuşu -> Kaydet\n            saveGame();\n        }\n        if (e.getKeyCode() == KeyEvent.VK_L) { // 'L' tuşu -> Yükle\n            loadGame();\n        }\n    }\n\n    public void saveGame() {\n        try (PrintWriter writer = new PrintWriter(new FileWriter(\"save.txt\"))) {\n            writer.println(player.getX() + \" \" + player.getY()); // Oyuncu konumu\n            writer.println(zombies.size()); // Zombi sayısı\n            for (Zombie z : zombies) {\n                writer.println(z.getX() + \" \" + z.getY() + \" \" + z.getHealth());\n            }\n            System.out.println(\"Oyun kaydedildi!\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n    \ttry {\n    \t    UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());\n    \t} catch (Exception e) {\n    \t    e.printStackTrace();\n    \t}\n    \tSwingUtilities.invokeLater(() -> new Game());\n    \t\n    }\n}\n\n\n",
      "Player.java": "package oyunproje;\n\nimport java.awt.*;\nimport java.awt.event.KeyEvent;\nimport java.io.Serializable;\nimport java.util.ArrayList;\n\nimport javax.swing.ImageIcon;\n\npublic class Player implements Serializable {\n    private static final long serialVersionUID = 1L;\n    \n    private int x, y; // Oyuncunun konumu\n    private int speed = 5; // Hareket hızı\n    private int width = 40, height = 40; // Oyuncu boyutu\n    private boolean up, down, left, right; // Hareket kontrolleri\n    private int health = 100; // Oyuncunun sağlığı\n    private transient Image playerImage; // 'transient' ile görselin serileştirilememesi\n    private String imagePath = \"player.png\"; // Resmin dosya yolu (yol kaydedilecek)\n    private Weapon currentWeapon;\n    private ArrayList<Weapon> weapons = new ArrayList<>();\n    \n    \n    // Oyun alanı boyutları\n    private static final int GAME_WIDTH = 800;\n    private static final int GAME_HEIGHT = 600;\n    // Yapıcı metot\n    public Player(int startX, int startY) {\n        this.x = startX;\n        this.y = startY;\n        this.currentWeapon = new Tabanca(); // Oyuna bu silahla başlanıyor.\n        loadImage(); // Resmi yükle\n    }\n    public void fireCurrentWeapon(double aimAngle) {\n        System.out.println(\"Ateş ediliyor. Açı: \" + aimAngle); // ✅ Debug mesajı\n        currentWeapon.fire(x + width/2, y + height/2, aimAngle);\n    }\n    \n\n    public void reloadCurrentWeapon() {\n        currentWeapon.reload();\n    }\n    public Weapon getCurrentWeapon() {\n        return currentWeapon;\n    }\n    public void addWeapon(Weapon weapon) {\n        if (!weapons.contains(weapon.getClass())) {\n            weapons.add(weapon);\n            setCurrentWeapon(weapon);\n        }\n    }\n    public void setCurrentWeapon(Weapon weapon) {\n    \tthis.currentWeapon = weapon;\n        weapon.reload(); // Şarjörü doldur\n        System.out.println(\"🔄 YENİ SİLAH: \" + weapon.getDisplayName());\n    }\n    public void takeDamage() {\n        health -= 10; // Zombi oyuncuya çarptığında sağlık azalır\n        if (health <= 0) {\n            health = 0;\n            // Oyuncu öldü, gerekli işlemleri burada yapabilirsin (örneğin, game over ekranı)\n        }\n    }\n    \n    // Resmi yükleyen metod\n    public void loadImage() {\n        try {\n            this.playerImage = new ImageIcon(getClass().getClassLoader().getResource(imagePath)).getImage();\n            if (playerImage == null) {\n                throw new RuntimeException(\"⚠ Hata: \" + imagePath + \" dosyası yüklenemedi!\");\n            }\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n            this.playerImage = new ImageIcon(getClass().getClassLoader().getResource(\"default_player.png\")).getImage(); \n        }\n    }\n\n    // Oyuncunun pozisyonunu ayarla\n    public void setPosition(int x, int y) {\n        this.x = Math.max(0, Math.min(x, GAME_WIDTH - width));\n        this.y = Math.max(0, Math.min(y, GAME_HEIGHT - height));\n    }\n\n    // Sağlık durumunu ayarla\n    public void setHealth(int health) {\n        this.health = Math.max(0, health);\n    }\n\n    // Oyun güncellenmesi (hareket)\n    public void update() {\n        if (up) y = Math.max(0, y - speed);\n        if (down) y = Math.min(GAME_HEIGHT - height, y + speed);\n        if (left) x = Math.max(0, x - speed);\n        if (right) x = Math.min(GAME_WIDTH - width, x + speed);\n    }\n\n    // Oyuncuyu çizme metodu\n    public void draw(Graphics g) {\n        g.drawImage(playerImage, x, y, width, height, null);\n    }\n\n    // Tuşa basıldığında hareketi kontrol et\n    public void keyPressed(int keyCode) {\n        switch (keyCode) {\n            case KeyEvent.VK_W -> up = true;\n            case KeyEvent.VK_S -> down = true;\n            case KeyEvent.VK_A -> left = true;\n            case KeyEvent.VK_D -> right = true;\n        }\n    }\n\n    // Tuştan el çekildiğinde hareketi durdur\n    public void keyReleased(int keyCode) {\n        switch (keyCode) {\n            case KeyEvent.VK_W -> up = false;\n            case KeyEvent.VK_S -> down = false;\n            case KeyEvent.VK_A -> left = false;\n            case KeyEvent.VK_D -> right = false;\n        }\n    }\n    public void switchWeapon(int index) {\n        if (index >= 0 && index < weapons.size()) {\n            setCurrentWeapon(weapons.get(index));\n        }\n    }\n    // Oyuncunun etrafındaki sınırları döndür\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, width, height);\n    }\n\n    // Hasar aldığında sağlığı düşür\n    public void takeDamage(int amount) {\n        health -= amount;\n        if (health <= 0) {\n            health = 0;\n            onDeath();\n        }\n    }\n\n    // Oyuncu öldüğünde çağrılacak metod\n    private void onDeath() {\n        System.out.println(\"☠ Oyuncu öldü!\");\n        // Burada oyun sonu ekranı gibi işlemler yapılabilir.\n    }\n\n    // Sağlık durumunu al\n    public int getHealth() {\n        return health;\n    }\n\n    // Oyuncunun ölüp ölmediğini kontrol et\n    public boolean isDead() {\n        return health <= 0;\n    }\n\n    // X koordinatını al\n    public int getX() {\n        return x;\n    }\n\n    // Y koordinatını al\n    public int getY() {\n        return y;\n    }\n\n    // Resim yolunu al\n    public String getImagePath() {\n        return imagePath;\n    }\n\n    // Resim yolunu ayarla\n    public void setImagePath(String path) {\n        this.imagePath = path;\n        loadImage(); // Yeni yolu kullanarak resmi tekrar yükle\n    }\n    public int getWidth() {\n        return width;\n    }\n\n    public int getHeight() {\n        return height;\n    }\n\n}\n"
    },
    {
      "id": "6094496",
      "AcidSplash.java": "package lab11;\n\nimport java.awt.image.BufferedImage;\n\npublic class AcidSplash {\n    int x, y;\n    long creationTime;\n    BufferedImage image;\n\n    public AcidSplash(int x, int y, BufferedImage image) {\n        this.x = x;\n        this.y = y;\n        this.image = image;\n        this.creationTime = System.currentTimeMillis();\n    }\n\n    public boolean isExpired() {\n        return System.currentTimeMillis() - creationTime > 500; // 0.5 saniyelik efekt\n    }\n}\n",
      "Zombie.java": "package lab11;\n import javax.imageio.ImageIO;\n\n\nimport java.awt.image.BufferedImage;\n import java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\npublic class Zombie {\n    double x, y;\n    int type, hp, damage;\n    double speed;\n    boolean jumped = false;\n    long lastAttackTime = 0;\n    BufferedImage image;\n    BufferedImage jumpImage;\n    BufferedImage deadImage;\n\n    boolean hitPlayer = false;\n    long hitTime = 0;\n\n\n    Zombie(int x, int y, int type) {\n        this.x = x;\n        this.y = y;\n        this.type = type;\n        switch (type) {\n            case 1 -> {\n            \thp = 2; speed = 1.0; damage = 5; \n            \timage = loadImage(\"zombie_normal.png\");\n            \tdeadImage = loadImage(\"zombie_dead_normal.png\");\n            \t\n            }\n            case 2 -> { \n            \thp = 1; speed = 2.5; damage = 5; \n            \t image = loadImage(\"zombie_crawler.png\");\n            \t jumpImage = loadImage(\"zombie_crawler_jump.png\");            \n            \t deadImage = loadImage(\"zombie_dead_crawler.png\");            \n            }\n            \n            \n            case 3 -> { \n            \thp = 5; speed = 0.5; damage = 20; \n            \t image = loadImage(\"zombie_tank.png\");\n            \t deadImage = loadImage(\"zombie_dead_tank.png\");\n            }\n            case 4 -> { \n            \thp = 1; speed = 1.0; damage = 10; \n            \timage = loadImage(\"zombie_spitter.png\");\n            \t deadImage = loadImage(\"zombie_dead_spitter.png\");\n            }\n        }\n    }\n    \n    BufferedImage loadImage(String fileName) {\n        try {\n            return ImageIO.read(new File(\"src/lab11/assets/\" + fileName));\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    } \n   \n\n    \n   \n\n\n\n\n\n    void update(int playerX, int playerY, ArrayList<AcidBullet> acidBullets) {\n    \tif (type == 2 && !jumped && Math.abs(x - playerX) < 50 && Math.abs(y - playerY) < 50) {\n    \t    speed += 4.0;\n    \t    jumped = true;\n    \t    if (jumpImage != null) {\n    \t        image = jumpImage;\n    \t    }\n    \t  \n    \t}\n\n        if (type == 4) {\n            long now = System.currentTimeMillis();\n            if (now - lastAttackTime > 2000) {\n                acidBullets.add(new AcidBullet((int)x + 20, (int)y + 20, playerX + 15, playerY + 15));\n                lastAttackTime = now;\n            }\n        }\n        double dx = playerX - x;\n        double dy = playerY - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance != 0) {\n            x += (dx / distance) * speed;\n            y += (dy / distance) * speed;\n    }\n    }\n    }\n    \n\n",
      "Weapon.java": "package lab11;\n\npublic class Weapon {\n    String name, type;\n    int ammo, maxAmmo, fireRate;\n    boolean unlocked;\n    String soundPath;\n\n    Weapon(String name, int maxAmmo, int fireRate, boolean unlocked, String type, String soundPath) {\n        this.name = name;\n        this.ammo = maxAmmo;\n        this.maxAmmo = maxAmmo;\n        this.fireRate = fireRate;\n        this.unlocked = unlocked;\n        this.type = type;\n        this.soundPath = soundPath;\n    }\n\n    void reload() {\n        this.ammo = this.maxAmmo;\n    }\n}\n",
      "Bullet.java": "package lab11;\n\nimport java.awt.image.BufferedImage;\n\npublic class Bullet {\n    double x, y;\n    double dx, dy;\n    double speed = 10;\n    boolean penetrates;\n    boolean isRocket;\n    BufferedImage image;\n\n    Bullet(int x, int y, int angle, boolean penetrates, boolean isRocket ) {\n        this.x = x;\n        this.y = y;\n        this.penetrates = penetrates;\n       this.isRocket = isRocket;\n        double rad = Math.toRadians(angle);\n        dx = speed * Math.sin(rad);\n        dy = -speed * Math.cos(rad);\n    }\n\n    void update() {\n        x += dx;\n        y += dy;\n    }\n}\n",
      "MainMenuPanel.java": "package lab11;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionListener;\n\npublic class MainMenuPanel extends JPanel {\n    /**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 1L;\n\tprivate JButton startButton, continueButton, controlsButton;\n    private Image backgroundImage;\n\n    public MainMenuPanel(ActionListener listener) {\n        setLayout(new GridBagLayout());\n        try {\n            backgroundImage = new ImageIcon(\"src/lab11/assets/menu_background.png\").getImage();\n        } catch (Exception e) {\n            backgroundImage = null;\n        }\n\n        // Butonları hazırla\n        startButton = createStyledButton(\"Başla\", listener);\n        continueButton = createStyledButton(\"Devam Et\", listener);\n        controlsButton = createStyledButton(\"Nasıl Oynanır\", listener);\n\n        // GridBag ile ortala\n        GridBagConstraints gbc = new GridBagConstraints();\n        gbc.insets = new Insets(20, 0, 20, 0); // Butonlar arası boşluk\n        gbc.gridx = 0;\n        gbc.fill = GridBagConstraints.HORIZONTAL;\n\n        gbc.gridy = 0;\n        add(startButton, gbc);\n        gbc.gridy = 1;\n        add(continueButton, gbc);\n        gbc.gridy = 2;\n        add(controlsButton, gbc);\n    }\n\n    private JButton createStyledButton(String text, ActionListener listener) {\n        JButton button = new JButton(text);\n        button.setFont(new Font(\"Segoe UI\", Font.BOLD, 24));\n        button.setFocusPainted(false);\n        button.setForeground(Color.WHITE);\n        button.setBackground(new Color(0, 0, 0, 150)); // yarı saydam siyah\n        button.setBorder(BorderFactory.createLineBorder(Color.WHITE, 2));\n        button.setOpaque(true);\n        button.setContentAreaFilled(false);\n        button.setPreferredSize(new Dimension(300, 60));\n        button.addActionListener(listener);\n        return button;\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        if (backgroundImage != null) {\n            g.drawImage(backgroundImage, 0, 0, getWidth(), getHeight(), this);\n        } else {\n            g.setColor(new Color(30, 30, 30));\n            g.fillRect(0, 0, getWidth(), getHeight());\n        }\n    }\n}\n",
      "ControlsPanel.java": "package lab11;\n\nimport javax.swing.*;\nimport java.awt.*;\n// import java.awt.event.ActionListener;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class ControlsPanel extends JPanel {\n    /**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic ControlsPanel(CardLayout cardLayout, JPanel container) {\n        setLayout(new BorderLayout());\n        setBackground(Color.BLACK);\n\n        JPanel contentPanel = new JPanel();\n        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));\n        contentPanel.setBackground(Color.BLACK);\n\n        String[] imageNames = {\n            \"zombie_normal.png\",\n            \"zombie_crawler.png\",\n            \"zombie_tank.png\",\n            \"zombie_spitter.png\"\n        };\n\n        String[] descriptions = {\n            \"Normal Zombi: Orta hızda, orta can.\",\n            \"Sürünge Zombi: Yaklaştığında zıplar.\",\n            \"Tank Zombi: Yavaş ama dayanıklı.\",\n            \"Asitçi Zombi: Uzaktan asit fırlatır.\"\n        };\n\n        for (int i = 0; i < imageNames.length; i++) {\n            try {\n                BufferedImage img = ImageIO.read(new File(\"src/lab11/assets/\" + imageNames[i]));\n\n                JPanel row = new JPanel(new FlowLayout(FlowLayout.LEFT));\n                row.setBackground(Color.BLACK);\n\n                JLabel imageLabel = new JLabel(new ImageIcon(img.getScaledInstance(64, 64, Image.SCALE_SMOOTH)));\n                JLabel textLabel = new JLabel(descriptions[i]);\n                textLabel.setForeground(Color.WHITE);\n                textLabel.setFont(new Font(\"Arial\", Font.PLAIN, 16));\n\n                row.add(imageLabel);\n                row.add(Box.createHorizontalStrut(10));\n                row.add(textLabel);\n                contentPanel.add(row);\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        // 🔙 Geri Dön Butonu\n        JButton backButton = new JButton(\"Geri Dön\");\n        backButton.setFont(new Font(\"Arial\", Font.BOLD, 18));\n        backButton.setFocusPainted(false);\n        backButton.addActionListener(_ -> cardLayout.show(container, \"menu\"));\n\n        JPanel bottomPanel = new JPanel();\n        bottomPanel.setBackground(Color.BLACK);\n        bottomPanel.add(backButton);\n\n        add(contentPanel, BorderLayout.CENTER);\n        add(bottomPanel, BorderLayout.SOUTH);\n    }\n}\n",
      "BloodSplash.java": "package lab11;\n\nimport java.awt.image.BufferedImage;\n\npublic class BloodSplash {\n    int x, y;\n    long spawnTime;\n    BufferedImage image;\n\n    public BloodSplash(int x, int y, BufferedImage image) {\n        this.x = x;\n        this.y = y;\n        this.image = image;\n        this.spawnTime = System.currentTimeMillis();\n    }\n\n    public boolean isExpired() {\n        return System.currentTimeMillis() - spawnTime > 1000;\n    }\n}\n",
      "Blood.java": "package lab11;\n\nimport java.awt.image.BufferedImage;\n\npublic class Blood {\n    int x, y;\n    BufferedImage image;\n    long creationTime;\n\n    public Blood(int x, int y, BufferedImage image) {\n        this.x = x;\n        this.y = y;\n        this.image = image;\n        this.creationTime = System.currentTimeMillis();\n    }\n    public boolean isExpired() {\n        return System.currentTimeMillis() - creationTime > 15000; // 15 saniyede silinir\n    }\n}\n",
      "TopDownShooter.java": "package lab11;\n\nimport javax.swing.*;\nimport javax.imageio.ImageIO;\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport javax.sound.sampled.UnsupportedAudioFileException;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.awt.*;\nimport java.awt.event.*;\n  \nimport java.util.*;\nimport javax.sound.sampled.*;\nimport java.io.File;\n\npublic class TopDownShooter extends JPanel implements KeyListener, Runnable {\n\t\n\tprivate static final long serialVersionUID = 1L;\n    private int playerX, playerY, playerHealth, score; // OYUNCUNUN KONUMU,CANI,SKORU\n    private boolean up, down, left, right, paused;\n    // Oyuncunun hareket hızı (sabit bir sayı).\n    private final int SPEED = 5;\n// Oyunun sürekli çalışmasını sağlayacak ana thread\n    private Thread gameThread;\n    private ArrayList<Bullet> bullets;\n    private ArrayList<Zombie> zombies;\n    private ArrayList<AcidBullet> acidBullets;\n    private ArrayList<Blood> bloodSplats = new ArrayList<>();\n    private ArrayList<BloodSplash> bloodSplashes = new ArrayList<>();\n    private ArrayList<AcidSplash> acidSplashes = new ArrayList<>();\n    private ArrayList<Zombie> deadZombies = new ArrayList<>();\n   \n    private Random random;\n    private int difficultyLevel;\n    private Weapon currentWeapon;\n    private ArrayList<Weapon> weapons;\n    // Mermi ateşleme zamanı ve zombi doğma zamanlamaları.\n    private long lastShotTime;\n    private long lastSpawnTime = 0;\n    private long spawnInterval = 2000;  // 2 saniye aralıklarla yeni zombiler doğuyor\n  \n    //gerekli tüm görseller için değişkenler\n   \n    private BufferedImage playerImage;\n    private BufferedImage backgroundImage;\n    private BufferedImage bloodImage;\n    private BufferedImage bloodSplashImage;\n    private BufferedImage acidBulletImage;\n    private BufferedImage acidSplashImage;\n    private BufferedImage pistolBulletImage;\n    private BufferedImage rocketImage;\n    private BufferedImage sniperBulletImage;\n    private BufferedImage rifleBulletImage;\n    private BufferedImage shotgunBulletImage;\n   \n   \n\n\n    public TopDownShooter() {\n        setPreferredSize(new Dimension(800, 600));  // PANEL BOYUTU\n        setBackground(Color.BLACK);  // ARKA PLAN RENGİ\n      // BAŞLANGIÇ KONUMU CANI VE SKORU\n        playerX = 400;\n        playerY = 300;\n        playerHealth = 100;\n        score = 0;\n        paused = false;\n\n        \n\n        \n        bullets = new ArrayList<>();\n        zombies = new ArrayList<>();\n        acidBullets = new ArrayList<>();\n        random = new Random();\n        difficultyLevel = 1;\n        weapons = new ArrayList<>();\n    // BİZE VERİLEN SİLAHLARI EKLEDİK\n        weapons.add(new Weapon(\"Tabanca\", 12, 120, true, \"pistol\", \"sounds/pistol.wav\"));\n        weapons.add(new Weapon(\"Piyade Tüfeği\", 30, 600, false, \"rifle\", \"sounds/rifle.wav\"));\n        weapons.add(new Weapon(\"Pompalı Tüfek\", 5, 60, false, \"shotgun\", \"sounds/shotgun.wav\"));\n        weapons.add(new Weapon(\"Keskin Nişancı\", 5, 30, false, \"sniper\", \"sounds/sniper.wav\"));\n        weapons.add(new Weapon(\"Roketatar\", 1, 10, false, \"rocket\", \"sounds/rocket.wav\"));\n      // TALİMAT GEREĞİ OYUNCUYU TABANCA İLE BAŞLATIYORUZ VE SON ATEŞ EDİLEN ZAMANI KAYDEDİYORUZ\n        currentWeapon = weapons.get(0);\n        lastShotTime = System.currentTimeMillis();\n     // TUŞLARI ALGILAYABİLMEK İÇİN\n        addKeyListener(this);\n        setFocusable(true);\n        requestFocusInWindow();\n\n        //OYUN DÖNGÜSÜ BAŞLATIYORUZ\n        gameThread = new Thread(this);\n        gameThread.start();\n        try {\n            playerImage = ImageIO.read(new File(\"src/lab11/assets/player_soldier.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            backgroundImage = ImageIO.read(new File(\"src/lab11/assets/background.png\")); \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            bloodImage = ImageIO.read(new File(\"src/lab11/assets/blood_splatter.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            bloodSplashImage = ImageIO.read(new File(\"src/lab11/assets/blood_splash.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            acidBulletImage = ImageIO.read(new File(\"src/lab11/assets/acid_ball.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            acidSplashImage = ImageIO.read(new File(\"src/lab11/assets/acid_splash.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            pistolBulletImage = ImageIO.read(new File(\"src/lab11/assets/bullet_pistol.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n        \trocketImage = ImageIO.read(new File(\"src/lab11/assets/bullet_rocket.png\"));\n        \t\n        }catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n        \tsniperBulletImage = ImageIO.read(new File(\"src/lab11/assets/bullet_sniper.png\"));\n        }catch (IOException e) {\n            e.printStackTrace();\n        }\n        \n        try {\n        \t rifleBulletImage = ImageIO.read(new File(\"src/lab11/assets/bullet_rifle.png\"));\n        }catch (IOException e) {\n            e.printStackTrace();\n        }\n        \n        try {\n        \tshotgunBulletImage = ImageIO.read(new File(\"src/lab11/assets/bullet_shotgun.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n     \n        \n\n\n\n        \n        \n        \n        \n\n\n    }\n\n \n    \n\n    @Override\n    public void paintComponent(Graphics g) {  // oyundaki tüm görseller olaylar burada ekrana çizilir\n        super.paintComponent(g); //üst sınıftaki paintComponent metodunu çağırıyorum ve ekranı temizlettiriyorum. bu sayede kirlilik olmuyor akış devam ediyor\n        \n        if (backgroundImage != null) {\n            g.drawImage(backgroundImage, 0, 0, getWidth(), getHeight(), null);\n        } else {\n            g.setColor(Color.BLACK);\n            g.fillRect(0, 0, getWidth(), getHeight());\n        }\n        for (Blood blood : new ArrayList<>(bloodSplats)) {\n            g.drawImage(blood.image, blood.x, blood.y, 40, 40, null);\n        }\n\n        for (BloodSplash splash : new ArrayList<>(bloodSplashes)) {\n            g.drawImage(splash.image, splash.x - 20, splash.y - 20, 30, 30, null);\n        }\n        for (AcidSplash splash : new ArrayList<>(acidSplashes)) {\n            g.drawImage(splash.image, splash.x - 10, splash.y - 10, 30, 30, null);\n        }\n        for (Zombie dead : deadZombies) {\n            if (dead.deadImage != null) {\n                int drawWidth = 60;  \n                int drawHeight = 60;\n                int drawX = (int) dead.x - (drawWidth - 48) / 2; // Ortalamak için\n                int drawY = (int) dead.y - (drawHeight - 48) / 2;\n                g.drawImage(dead.deadImage, drawX, drawY, drawWidth, drawHeight, null);\n            }\n        }\n\n\n        \n\n        \n        if (playerImage != null) {\n            Graphics2D g2d = (Graphics2D) g;\n            double angle = 0;\n\n            if (up) angle = 0;\n            else if (down) angle = 180;\n            else if (left) angle = -90;\n            else if (right) angle = 90;\n\n            drawRotatedImage(g2d, playerImage, playerX, playerY, angle);\n        } else {\n            g.setColor(Color.WHITE);\n            g.fillOval(playerX, playerY, 30, 30);\n        }\n\n        \n\n     \n        // merminin rengi boyutu ve şekli burada ayarladım\n        g.setColor(Color.RED);\n        for (Bullet bullet : bullets) {\n            if (bullet.image != null) {\n                g.drawImage(bullet.image, (int) bullet.x, (int) bullet.y, 16, 16, null);\n            } else {\n                g.setColor(Color.RED);\n                g.fillOval((int) bullet.x, (int) bullet.y, 5, 5);\n            }\n        }\n\n        \n        // asit salgılayan zombinin asit toplarını burada renk ve şekil olarak ayarladım\n        for (AcidBullet acid : acidBullets) {\n            if (acidBulletImage != null) {\n                g.drawImage(acidBulletImage, (int) acid.x, (int) acid.y, 20, 20, null);\n            } else {\n                g.setColor(Color.MAGENTA);\n                g.fillOval((int) acid.x, (int) acid.y, 10, 10);\n            }\n        }\n        if (playerHealth <= 0) {\n            g.setColor(Color.RED);\n            g.setFont(new Font(\"Segoe UI\", Font.BOLD, 64));\n            g.drawString(\"GAME OVER\", getWidth() / 2 - 200, getHeight() / 2);\n            g.setFont(new Font(\"Arial\", Font.PLAIN, 14));\n        }\n\n\n        Graphics2D g2d = (Graphics2D) g;\n        for (Zombie zombie : new ArrayList<>(zombies)) {\n            if (zombie.image != null) {\n                double angle = Math.toDegrees(Math.atan2(playerY - zombie.y, playerX - zombie.x)) - 90;\n                drawRotatedImage(g2d, zombie.image, (int) zombie.x, (int) zombie.y, angle);\n            } else {\n                switch (zombie.type) {\n                    case 1 -> g.setColor(Color.GREEN);\n                    case 2 -> g.setColor(Color.ORANGE);\n                    case 3 -> g.setColor(Color.BLUE);\n                    case 4 -> g.setColor(Color.MAGENTA);\n                }\n                g.fillRect((int) zombie.x, (int) zombie.y, 40, 40);\n            }\n        }\n\n\n        g.setColor(Color.WHITE); // ekranın üstünde yer alan bilgileri beyaz renk olarak ayarladım\n        g.drawString(\"Health: \" + playerHealth, 10, 20); // can\n        g.drawString(\"Score: \" + score, 10, 40); // skor\n        g.drawString(\"Difficulty: \" + difficultyLevel, 10, 60); // zorluk seviyesi\n        g.drawString(\"Weapon: \" + currentWeapon.name, 10, 80); // mevcut silah ismi\n        g.drawString(\"Ammo: \" + currentWeapon.ammo + \"/\" + currentWeapon.maxAmmo, 10, 100); // kalan mermimiz\n    }\n    public void saveGame() {\n        try (PrintWriter writer = new PrintWriter(\"save.txt\")) {\n            writer.println(playerX);\n            writer.println(playerY);\n            writer.println(playerHealth);\n            writer.println(score);\n            writer.println(difficultyLevel);\n            writer.println(weapons.indexOf(currentWeapon)); // Silahın index'i\n            System.out.println(\"Oyun başarıyla kaydedildi.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public void loadGame() {\n        try (Scanner scanner = new Scanner(new File(\"save.txt\"))) {\n            playerX = Integer.parseInt(scanner.nextLine());\n            playerY = Integer.parseInt(scanner.nextLine());\n            playerHealth = Integer.parseInt(scanner.nextLine());\n            score = Integer.parseInt(scanner.nextLine());\n            difficultyLevel = Integer.parseInt(scanner.nextLine());\n            int weaponIndex = Integer.parseInt(scanner.nextLine());\n            currentWeapon = weapons.get(weaponIndex);\n\n            requestFocusInWindow(); // Tuşlar tekrar çalışsın\n            System.out.println(\"Oyun başarıyla yüklendi.\");\n        } catch (IOException | NumberFormatException | IndexOutOfBoundsException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    public void playSound(String soundFilePath) {\n        try {\n            File soundFile = new File(soundFilePath);\n            AudioInputStream audioStream = AudioSystem.getAudioInputStream(soundFile);\n            Clip clip = AudioSystem.getClip();\n            clip.open(audioStream);\n            clip.start();\n        } catch (UnsupportedAudioFileException | IOException | LineUnavailableException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    @Override\n    public void run() {\n        while (true) {\n            if (!paused) { // duraklama olmadığı sürece\n                update(); // oyun verilerini güncelliyorum\n                repaint(); //ekranı çiziyorum \n            }\n            try {\n                Thread.sleep(16); // yaklaşık 60 fps olarak 16ms arayla oyunumu yeniliyorum\n            } catch (InterruptedException e) {\n                e.printStackTrace(); // hata yakalarsa konsola yazdırıyorum\n            }\n        }\n    }\n\n    public void update() {\n    \t// basılan tuşa göre konumumu hızım akdar arttırıp azaltarak konum güncellemesi yapıyorum\n        if (up) playerY -= SPEED;\n        if (down) playerY += SPEED;\n        if (left) playerX -= SPEED;\n        if (right) playerX += SPEED;\n\n        long currentTime = System.currentTimeMillis(); // güncel zamanı milisaniye olarak tutuyorum\n        if (currentTime - lastSpawnTime > spawnInterval) { // eğer son zombi spawnından 2 saniye varsa\n            if (getWidth() > 40) { // oyun ekranın genişliği zombi genişliğinden büyükse\n                int zombieCount = Math.min(1 + difficultyLevel / 5, 5); // zorluk seviyesine göre zombi sayısı belirledim en fazla 5 ile sınırlı tuttum\n                for (int i = 0; i < zombieCount; i++) {\n                    int spawnX = random.nextInt(Math.max(getWidth() - 40, 1)); // zombi y = 0 ama x i random bir şekilde bir yerden spawn ettirdim\n                    int spawnY = 0; // zombie spawnı y = 0 konumundan(ekranın en üstünden)\n                    int maxType = Math.min(1 + difficultyLevel / 3, 4); // zorluk seviyesine göre zombi türlerini belirledim maksimum 4 tür zombimiz var\n                    int type = random.nextInt(maxType) + 1;\n                    zombies.add(new Zombie(spawnX, spawnY, type)); // oluşturulan zombiyi arraye ekledim\n                }\n                lastSpawnTime = currentTime; // son doğma zamanını güncelledim\n            }\n        }\n // mermiler ve zombiler çarpışıyor mu? çarpışıyorsa zombilerin canının azalması\n        \n        Iterator<Bullet> bulletIterator = bullets.iterator();\n        while (bulletIterator.hasNext()) {\n            Bullet bullet = bulletIterator.next();\n            bullet.update();\n\n            Iterator<Zombie> zombieIterator = zombies.iterator();\n            while (zombieIterator.hasNext()) {\n                Zombie zombie = zombieIterator.next();\n\n                if (Math.abs(bullet.x - zombie.x) < 20 && Math.abs(bullet.y - zombie.y) < 20) {\n                    bulletIterator.remove();\n\n                    if (bullet.isRocket) {\n                        Iterator<Zombie> aoeIterator = zombies.iterator();\n                        while (aoeIterator.hasNext()) {\n                            Zombie z = aoeIterator.next();\n                            double dx = (bullet.x + 5) - (z.x + 24);\n                            double dy = (bullet.y + 5) - (z.y + 24);\n                            double distance = Math.sqrt(dx * dx + dy * dy);\n                            if (distance < 120) {\n                                bloodSplats.add(new Blood((int) z.x, (int) z.y, bloodImage));\n                                aoeIterator.remove(); // güvenli silme\n                                score += 10;\n                                difficultyLevel++;\n                            }\n                        }\n\n                    } else {\n                        zombie.hp--;\n                        bloodSplashes.add(new BloodSplash((int) zombie.x, (int) zombie.y, bloodSplashImage));\n                        if (zombie.hp <= 0) {\n                            bloodSplats.add(new Blood((int) zombie.x, (int) zombie.y, bloodImage));\n                            deadZombies.add(zombie);\n\n                            zombieIterator.remove();\n                            if (bloodSplats.size() > 100) {\n                                bloodSplats.remove(0); // En eski kan lekesini sil\n                            }\n\n                            score += 10;\n                            difficultyLevel++;\n                        }\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        // 💡 bullets.removeIf kısmını ayrı ve güvenli hale getirdim (döngü dışı)\n        bullets.removeIf(b -> \n            b.x < -50 || b.x > getWidth() + 50 || \n            b.y < -50 || b.y > getHeight() + 50\n        );\n\n\n        for (Zombie z : zombies) z.update(playerX, playerY, acidBullets);\n\n    \n        zombies.removeIf(z -> {\n            if (z.y > getHeight() + 50) return true;\n\n            Rectangle zombieRect = new Rectangle((int) z.x, (int) z.y, 40, 40);\n            Rectangle playerRect = new Rectangle(playerX, playerY, 30, 30);\n\n            // Zıplamış sürünge zombi → çarptıysa işaretle, hemen silme\n            if (z.type == 2 && z.jumped && zombieRect.intersects(playerRect) && !z.hitPlayer) {\n                playerHealth -= z.damage;\n                z.hitPlayer = true;\n                z.hitTime = System.currentTimeMillis();\n            }\n\n            // Zombi daha önce çarptıysa → 300ms sonra sil\n            if (z.hitPlayer && System.currentTimeMillis() - z.hitTime > 9000) {\n                return true;\n            }\n\n            // Diğer zombiler\n            if (z.type != 4 && zombieRect.intersects(playerRect)) {\n                playerHealth -= z.damage;\n                return true;\n            }\n\n            return false;\n        });\n\n        \n        bloodSplashes.removeIf(BloodSplash::isExpired);\n        acidSplashes.removeIf(AcidSplash::isExpired);\n        \n\n\n\n\n        Iterator<AcidBullet> it = acidBullets.iterator();\n        while (it.hasNext()) {\n            AcidBullet acid = it.next();\n            acid.update();\n            Rectangle r = acid.getBounds();\n            Rectangle player = new Rectangle(playerX, playerY, 30, 30);\n            if (r.intersects(player)) {\n                playerHealth -= 10;\n                acidSplashes.add(new AcidSplash((int) acid.x, (int) acid.y, acidSplashImage));\n                it.remove();\n            }\n\n        }\n\n        if (playerHealth <= 0) {\n            playerHealth = 0;\n            paused = true;\n            System.out.println(\"Game Over!\");\n        }\n\n        if (difficultyLevel >= 1) weapons.get(1).unlocked = true;\n        if (difficultyLevel >= 3) weapons.get(2).unlocked = true;\n        if (difficultyLevel >= 5) weapons.get(3).unlocked = true;\n        if (difficultyLevel >= 10) weapons.get(4).unlocked = true;\n    }\n   \n\n    \n    @Override\n    public void keyPressed(KeyEvent e) {\n        int key = e.getKeyCode();\n        if (key == KeyEvent.VK_W) up = true;\n        if (key == KeyEvent.VK_S) down = true;\n        if (key == KeyEvent.VK_A) left = true;\n        if (key == KeyEvent.VK_D) right = true;\n        if (key == KeyEvent.VK_C) {\n            deadZombies.clear();\n        }\n        if (key == KeyEvent.VK_K) saveGame(); // K = Kaydet\n        if (key == KeyEvent.VK_L) loadGame(); // L = Load (Yükle)\n\n\n\n        if (key == KeyEvent.VK_SPACE) {\n            long currentTime = System.currentTimeMillis();\n            if (currentWeapon.ammo > 0 && (currentTime - lastShotTime) >= (60000 / currentWeapon.fireRate)) {\n                fireWeapon();\n                playSound(currentWeapon.soundPath); \n                currentWeapon.ammo--;\n                lastShotTime = currentTime;\n            }\n        }\n\n        if (key == KeyEvent.VK_R) currentWeapon.reload();\n\n        if (key >= KeyEvent.VK_1 && key <= KeyEvent.VK_5) {\n            int index = key - KeyEvent.VK_1;\n            if (index < weapons.size() && weapons.get(index).unlocked) {\n                currentWeapon = weapons.get(index);\n            }\n        }\n    }\n    private void drawRotatedImage(Graphics2D g2d, BufferedImage img, int x, int y, double angle) {\n        int targetWidth = 48;\n        int targetHeight = 48;\n        int cx = targetWidth / 2;\n        int cy = targetHeight / 2;\n\n        g2d.rotate(Math.toRadians(angle), x + cx, y + cy);\n        g2d.drawImage(img, x, y, targetWidth, targetHeight, null);\n        g2d.rotate(-Math.toRadians(angle), x + cx, y + cy);\n    }\n\n\n\n    private void fireWeapon() {\n        switch (currentWeapon.type) {\n        case \"pistol\" -> {\n            Bullet b = new Bullet(playerX + 12, playerY, 0, false, false);\n            b.image = pistolBulletImage;\n            bullets.add(b);\n        }\n            case \"rifle\" -> {\n                int angle = random.nextInt(31) - 15;\n                Bullet b = new Bullet(playerX + 12, playerY, angle, false, false);\n                b.image = rifleBulletImage;\n                bullets.add(b);\n            }\n            case \"shotgun\" -> {\n                for (int a = -22; a <= 22; a += 5) {\n                    Bullet b = new Bullet(playerX + 12, playerY, a, false, false);\n                    b.image = shotgunBulletImage;\n                    bullets.add(b);\n                }\n                \n            }\n            case \"sniper\" -> {\n                Bullet b = new Bullet(playerX + 12, playerY, 0, false, false);\n                b.image = sniperBulletImage;\n                bullets.add(b);\n            }\n\n            case \"rocket\" -> {\n                Bullet b = new Bullet(playerX + 12, playerY, 0, false, false);\n                b.image = rocketImage;\n                bullets.add(b);\n            }\n\n        }\n    }\n\n\n\n    @Override public void keyReleased(KeyEvent e) {\n        int key = e.getKeyCode();\n        if (key == KeyEvent.VK_W) up = false;\n        if (key == KeyEvent.VK_S) down = false;\n        if (key == KeyEvent.VK_A) left = false;\n        if (key == KeyEvent.VK_D) right = false;\n    }\n    @Override public void keyTyped(KeyEvent e) {}\n}",
      "SaveManager.java": "package lab11;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class SaveManager {\n    private static final String SAVE_FILE = \"save.txt\";\n\n    public static void saveGame(int playerX, int playerY, int health, int score, int difficulty, Weapon weapon) {\n        try (PrintWriter writer = new PrintWriter(new FileWriter(SAVE_FILE))) {\n            writer.println(playerX);\n            writer.println(playerY);\n            writer.println(health);\n            writer.println(score);\n            writer.println(difficulty);\n            writer.println(weapon.name);\n            writer.println(weapon.ammo);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static Map<String, String> loadGame() {\n        Map<String, String> data = new HashMap<>();\n        try (BufferedReader reader = new BufferedReader(new FileReader(SAVE_FILE))) {\n            data.put(\"playerX\", reader.readLine());\n            data.put(\"playerY\", reader.readLine());\n            data.put(\"health\", reader.readLine());\n            data.put(\"score\", reader.readLine());\n            data.put(\"difficulty\", reader.readLine());\n            data.put(\"weapon\", reader.readLine());\n            data.put(\"ammo\", reader.readLine());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return data;\n    }\n\n    public static boolean saveExists() {\n        return new File(SAVE_FILE).exists();\n    }\n}\n",
      "SoundPlayer.java": "package lab11;\n\nimport javax.sound.sampled.*;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class SoundPlayer {\n\n    public static void playSound(String filePath) {\n        try {\n            File soundFile = new File(filePath);\n            if (!soundFile.exists()) {\n                System.err.println(\"Ses dosyası bulunamadı: \" + filePath);\n                return;\n            }\n\n            AudioInputStream audioIn = AudioSystem.getAudioInputStream(soundFile);\n            Clip clip = AudioSystem.getClip();\n            clip.open(audioIn);\n            clip.start();\n        } catch (UnsupportedAudioFileException | IOException | LineUnavailableException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
      "Game.java": "package lab11;\n\nimport java.awt.CardLayout;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.SwingUtilities;\n\npublic class Game {\n\n\tpublic static void main(String[] args) {\n\t\t SwingUtilities.invokeLater(() -> {\n             JFrame frame = new JFrame(\"Top-Down Shooter\");\n             CardLayout cardLayout = new CardLayout();\n             JPanel container = new JPanel(cardLayout);\n\n             TopDownShooter gamePanel = new TopDownShooter();           // Tek sefer oluştur\n             frame.add(gamePanel);\n             gamePanel.requestFocusInWindow();\n             ControlsPanel controlsPanel = new ControlsPanel(cardLayout, container);\n      \n             MainMenuPanel menuPanel = new MainMenuPanel(e -> {\n                 String command = ((JButton) e.getSource()).getText();\n                 switch (command) {\n                     case \"Başla\" -> {\n                         cardLayout.show(container, \"game\");\n                         gamePanel.requestFocusInWindow(); // 🔥 PANEL GÖRÜNDÜKTEN SONRA FOKUS VERİLDİ\n                     }\n                     case \"Nasıl Oynanır\" -> cardLayout.show(container, \"controls\");\n                     case \"Devam Et\" -> {\n                         gamePanel.loadGame(); // 🔥 EN SON SAVE'İ YÜKLE\n                         cardLayout.show(container, \"game\");\n                         gamePanel.requestFocusInWindow();\n                     }\n                 }\n             });\n\n\n             container.add(menuPanel, \"menu\");\n             container.add(gamePanel, \"game\");\n             container.add(controlsPanel, \"controls\");\n\n             frame.setContentPane(container);\n             frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n             frame.setSize(800, 600);\n             frame.setLocationRelativeTo(null);\n             frame.setVisible(true);\n         });\n     }\n \n\n\t}\n\n\n",
      "AcidBullet.java": "package lab11;\n\nimport java.awt.Rectangle;\n\npublic class AcidBullet {\n    double x, y, dx, dy, speed = 3;\n    AcidBullet(int startX, int startY, int targetX, int targetY) {\n        x = startX;\n        y = startY;\n        double angle = Math.atan2(targetY - startY, targetX - startX);\n        dx = speed * Math.cos(angle);\n        dy = speed * Math.sin(angle);\n    }\n    void update() {\n        x += dx;\n        y += dy;\n    }\n    Rectangle getBounds() {\n        return new Rectangle((int)x, (int)y, 10, 10);\n    }\n}\n",
      "DeadZombie.java": "package lab11;\n\nimport java.awt.image.BufferedImage;\n\npublic class DeadZombie {\n    int x, y;\n    BufferedImage image;\n\n    public DeadZombie(int x, int y, BufferedImage image) {\n        this.x = x;\n        this.y = y;\n        this.image = image;\n    }\n}\n"
    },
    {
      "id": "6157698",
      "Sound.java": "package topdown.shooter.gfx;\n\nimport javax.sound.sampled.Clip;\nimport javax.sound.sampled.FloatControl;\n\npublic class Sound {\n\t\n\tClip clip;\n\t\n\tpublic Sound(Clip clip) {\n\t\tthis.clip = clip;\n\t}\n\t\n\tpublic void playSound() {\n\t\tclip.start();\n\t}\n\tpublic void stopSound() {\n\t\tclip.stop();\n\t}\n\t\n\tpublic void setSoundToRepeat(boolean repeat) {\n\t\tif(repeat) \n\t\t\tclip.loop(Clip.LOOP_CONTINUOUSLY);\n\t\t\n\t\telse\n\t\t\tclip.loop(0);\n\t}\n\n\tpublic void setVolume(float volume){\n        FloatControl gainControl = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);\n        float range = gainControl.getMaximum() - gainControl.getMinimum();\n        float gain = (range * volume) + gainControl.getMinimum();\n//        System.out.println(volume);\n        gainControl.setValue(gain);\n    }\n}\n",
      "Renderer.java": "package topdown.shooter.gfx;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\n\nimport topdown.shooter.math.Vector2f;\n\npublic class Renderer {\n\tprivate Camera camera;\n\tprivate AffineTransform transform;\n\tprivate float xOffset = 0, yOffset = 0;\n\t\n\tpublic Renderer() {\n\t\ttransform = new AffineTransform();\n\t}\n\n\tpublic Renderer(Camera camera) {\n\t\ttransform = new AffineTransform();\n\t\tthis.camera = camera;\n\t}\n\n\tpublic void drawImage(BufferedImage image, Graphics2D g2d, Vector2f position, float rotation, float width, float height) {\n\t\txOffset = (position.x - camera.position.x + camera.getVpWidth() / 2) - width / 2;\n\t\tyOffset = (position.y - camera.position.y + camera.getVpHeight() / 2) - height / 2;\n\n\t\ttransform = AffineTransform.getTranslateInstance(xOffset, yOffset);\n        \n        transform .rotate(rotation, width/2, height/2);\n        \n        g2d.setTransform(transform);\n        g2d.drawImage(image, 0, 0, (int) width, (int)height, null);\n        g2d.setTransform(new AffineTransform());\n\t}\n\t\n\t// for zombies\n\tpublic void fillRect(Graphics2D g2d,Vector2f position ,Color color, int width , int height){\n        xOffset  = (position.x - camera.position.x + camera.getVpWidth()/2)   - width/2;\n        yOffset  = (position.y - camera.position.y + camera.getVpHeight()/2)  - height/2;\n        transform = AffineTransform.getTranslateInstance(xOffset, yOffset);\n        g2d.setColor(color);\n        g2d.setTransform(transform);\n        g2d.fillRect(0,0,width,height);\n        g2d.setTransform(new AffineTransform());\n    }\n\n\tpublic Camera getCamera() {\n\t\treturn camera;\n\t}\n\n\tpublic void setCamera(Camera camera) {\n\t\tthis.camera = camera;\n\t}\n\tpublic float getXOffset() {\n\t\treturn xOffset;\n\t}\n\tpublic float getYOffset() {\n\t\treturn yOffset;\n\t}\n}\n",
      "Camera.java": "package topdown.shooter.gfx;\n\nimport topdown.shooter.gameobject.GameObject;\nimport topdown.shooter.math.Vector2f;\n\npublic class Camera {\n\tpublic Vector2f position;\n\tprivate float vpWidth, vpHeight;\n\tprivate float width, height; // Initialized at scene\n\t\n\tpublic Camera(Vector2f cameraPosition, float vpWidth, float vpHeight) {\n\t\tthis.position = cameraPosition;\n\t\tthis.vpWidth = vpWidth;\n\t\tthis.vpHeight = vpHeight;\n\t}\n\t\n\tpublic void centerOnGameObject(GameObject gameObject) {\n\t\tthis.position = gameObject.getPosition().clone();\n\t\tdontRenderOutsideOfMap();\n\t}\n\t\n\tpublic void dontRenderOutsideOfMap() {\n\t\tfloat halfWidth = width/2 ,halfHeight = height /2;\n        // left side\n        if(position.x < -halfWidth + vpWidth/2)\n            position.x = -halfWidth + vpWidth/2;\n        \n        // top side\n        if(position.y < -halfHeight + vpHeight/2)\n            position.y = -halfHeight + vpHeight/2;\n        \n        // right side (tam çalışmıyor) neden bulamıyorum\n        if(position.x > halfWidth - vpWidth/2 )\n            position.x = halfWidth - vpWidth/2;\n        \n        // bottom side (tam çalışmıyor) neden bulamıyorum\n        if(position.y > halfHeight - vpHeight/2)\n            position.y = halfHeight - vpHeight/2; \n\t}\n\t\n\tpublic float getVpWidth() {\n\t\treturn vpWidth;\n\t}\n\tpublic float getVpHeight() {\n\t\treturn vpHeight;\n\t}\n\tpublic void setVpWidth(float vpWidth) {\n\t\tthis.vpWidth = vpWidth;\n\t}\n\tpublic void setVpHeight(float vpHeight) {\n\t\tthis.vpHeight = vpHeight;\n\t}\n\tpublic void setWidth(float width) {\n\t\tthis.width = width;\n\t}\n\tpublic void setHeight(float height) {\n\t\tthis.height = height;\n\t}\n}\n",
      "GameObject.java": "package topdown.shooter.gameobject;\n\nimport java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\n\nimport topdown.shooter.gfx.Camera;\nimport topdown.shooter.gfx.Renderer;\nimport topdown.shooter.main.Game;\nimport topdown.shooter.math.Vector2f;\nimport topdown.shooter.scene.Scene;\n\npublic abstract class GameObject {\n\t// Custom renderer\n\tprotected Renderer renderer;\n\tprotected Scene scene;\n\tprotected Vector2f position;\n\tprotected AffineTransform transform;\n\tprotected float width, height;\n\tprotected double rotationAngle;\n\tprotected BufferedImage sprite;\n\tprotected String name = \"\";\n\n\tpublic abstract void init();\n\tpublic abstract void update();\n\tpublic abstract void render(Graphics2D g2d);\n\t\n\tpublic GameObject() {\n\t\tposition = new Vector2f();\n\t\ttransform = new AffineTransform();\n\t\twidth = height = 50f;\n\t}\n\t\n\tpublic GameObject(Scene scene) {\n//\t\trenderer = new Renderer();\n\t\tthis.scene = scene;\n\t\tposition = new Vector2f();\n\t\ttransform = new AffineTransform();\n\t\twidth = height = 50f;\n\t}\n\n\tpublic GameObject(Scene scene, Vector2f position, float width, float height) {\n\t\tthis.scene = scene;\n\t\tthis.position = position;\n\t\ttransform = new AffineTransform();\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\trenderer = new Renderer();\n\t\trenderer.setCamera(scene.getCamera());\n\t}\n\t\n\tpublic Vector2f getOnScreenCoordinates(){\n        Camera camera = renderer.getCamera();\n        float xoffset  = (position.x - camera.position.x + camera.getVpHeight()/2)   ;\n        float yoffset  = (position.y - camera.position.y + camera.getVpHeight()/2)  ;\n        xoffset = (xoffset/Game.width);\n        yoffset =  (yoffset/Game.height) ;\n        return  new Vector2f(xoffset, yoffset);\n    }\n\t\n\tpublic Vector2f getPosition() {\n\t\treturn position;\n\t}\n\n\tpublic AffineTransform getTransform() {\n\t\treturn transform;\n\t}\n\n\tpublic float getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic float getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic double getRotationAngle() {\n\t\treturn rotationAngle;\n\t}\n\n\tpublic BufferedImage getSprite() {\n\t\treturn sprite;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n}\n",
      "Projectile.java": "package topdown.shooter.gameobject.projectiles;\n\nimport topdown.shooter.gameobject.GameObject;\nimport topdown.shooter.math.Vector2f;\nimport topdown.shooter.scene.Scene;\n\npublic abstract class Projectile extends GameObject {\n\tprotected Vector2f direction;\n\tprotected float speed;\n\tprotected Vector2f velocity;\n\n\tpublic abstract void update();\n\n\tpublic Projectile() {\n\t\tsuper();\n\t\tdirection = new Vector2f();\n\t\tspeed = 0;\n\t\tvelocity = new Vector2f();\n\t}\n\n\tpublic Projectile(Scene scene, Vector2f position, Vector2f direction, float speed, float width, float height) {\n\t\tsuper(scene, position, width, height);\n\t\tthis.direction = direction;\n\t\tthis.speed = speed;\n\t\tvelocity = new Vector2f();\n\t}\n\n\tpublic void setSpeed(float speed) {\n\t\tthis.speed = speed;\n\t}\n\n\tpublic Vector2f getDirection() {\n\t\treturn direction;\n\t}\n\n\tpublic void setDirection(Vector2f direction) {\n\t\tthis.direction = direction;\n\t}\n\n\tpublic Vector2f getVelocity() {\n\t\treturn velocity;\n\t}\n\n\tpublic void setVelocity(Vector2f velocity) {\n\t\tthis.velocity = velocity;\n\t}\n}\n",
      "Bullet.java": "package topdown.shooter.gameobject.projectiles;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\n\nimport topdown.shooter.gameobject.GameObject;\nimport topdown.shooter.gameobject.entities.Player;\nimport topdown.shooter.gameobject.entities.zombies.Zombie;\nimport topdown.shooter.math.Vector2f;\nimport topdown.shooter.scene.GamePlayScene;\nimport topdown.shooter.scene.Scene;\n\n\npublic class Bullet extends  Projectile{\n\n\tdouble x, y;\n    double vx, vy;\n    int boyut = 6;\n    boolean aktif = true;\n    boolean dusmanMermisi = false;\n    boolean geciciDegil = false;\n    public float damage = 2;\n\n    public Bullet(Scene scene, Vector2f startPosition, Vector2f direction, float damage, float speed) {\n        super(scene,startPosition,direction, speed, 5, 5);\n        this.damage = damage;\n    }\n \n    @Override\n    public void init() {\n    }\n\n    @Override\n    public void update() {\n        position = position.add(direction.normalize().scale(speed));\n    }\n\n    @Override\n    public void render(Graphics2D g2d) {\n        renderer.fillRect(g2d, position, Color.yellow, 5, 5);\n    }\n\n\n    \n}\n",
      "Weapon.java": "\npackage topdown.shooter.gameobject.weapons;\n\nimport java.awt.Graphics2D;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.Timer;\n\nimport topdown.shooter.gameobject.GameObject;\nimport topdown.shooter.gameobject.projectiles.Bullet;\nimport topdown.shooter.input.InputManager;\nimport topdown.shooter.math.Vector2f;\nimport topdown.shooter.scene.Scene;\n\npublic class Weapon extends GameObject {\n\n\tprivate float damage = 5;\n\tprivate float speed = 600;\n\tprivate float fireRate = 8;\n\tprivate float accuracy = 70;\n\n\tVector2f direction = new Vector2f();\n\n\tpublic Weapon(Scene scene) {\n\t\tsuper(scene);\n\t\tint delay = (int) (1000 / fireRate);\n\t}\n\n\tprivate void releaseBullet() {\n\t\tfloat baseAngle = 30;\n\t\tfloat spread = baseAngle - baseAngle * (accuracy / 100);\n\t\tdouble value = Math.random() - 0.5;\n\t\tdouble angle = (value * 2) * spread;\n\t\tVector2f dir = direction.rotateRad(Math.toRadians(angle));\n\t\tshootBullet(dir);\n\t}\n\n\tprotected void shootBullet(Vector2f direction) {\n\t\tscene.addProjectile(new Bullet(scene, damage, position, direction, speed));\n\t}\n\n\t@Override\n\tpublic void init() {\n\t}\n\n\t@Override\n\tpublic void update() {\n\t}\n\n\t@Override\n\tpublic void render(Graphics2D graphics) {\n\t}\n\n\tpublic void setDirection(Vector2f direction) {\n\t\tthis.direction = direction;\n\t}\n\n\tpublic void setPosition(Vector2f position) {\n\t\tthis.position = position;\n\t}\n\n\tpublic float getDamage() {\n\t\treturn damage;\n\t}\n\n\tpublic float getSpeed() {\n\t\treturn speed;\n\t}\n}\n",
      "Shotgun.java": "package topdown.shooter.gameobject.weapons;\n\nimport topdown.shooter.gameobject.projectiles.Bullet;\nimport topdown.shooter.math.Vector2f;\nimport topdown.shooter.scene.Scene;\n\npublic class Shotgun extends Weapon {\n    int bulletAmnt = 10;\n    float spreadAngle = 15;\n\n    public Shotgun(Scene scene) {\n        super(scene);\n    }\n\n    @Override\n    protected void shootBullet(Vector2f direction) {\n        float individualAngle = spreadAngle / bulletAmnt;\n        float startAngle = -(spreadAngle/2);\n        \n        \n        for (int i = 0 ; i < bulletAmnt; i++){\n            Vector2f dir =  direction.rotateRad(Math.toRadians(startAngle));\n            scene.addProjectile(new Bullet(scene, getDamage() ,position,dir , getSpeed()));\n            startAngle+= individualAngle;\n        }\n    }\n    \n    \n}\n",
      "Entity.java": "package topdown.shooter.gameobject.entities;\n\nimport topdown.shooter.gameobject.GameObject;\nimport topdown.shooter.math.Vector2f;\nimport topdown.shooter.scene.Scene;\n\npublic abstract class Entity extends GameObject{\n\n\tprotected int health;\n\tprotected float speed;\n\tprotected Vector2f direction;\n\t\n    public abstract void kill();\n\n\tpublic Entity(Scene scene) {\n\t\tsuper(scene);\n\t\thealth = 100;\n\t\tspeed = 3;\n\t\tdirection = new Vector2f();\n\t}\n\t\n\tpublic Entity(Scene scene, Vector2f position, float width, float height) {\n\t\tsuper(scene, position, width, height);\n\t\thealth = 100;\n\t\tspeed = 3;\n\t\tdirection = new Vector2f();\n\t}\n\t\n\tpublic void hit(float damage){\n        health-= damage;\n        health = health < 0? 0 : health;\n    }\n\t\n\tpublic float getHealth() {\n\t\treturn health;\n\t}\n\n\tpublic float getSpeed() {\n\t\treturn speed;\n\t}\n\n\tpublic Vector2f getDirection() {\n\t\treturn direction;\n\t}\n\n}\n",
      "Player.java": "package topdown.shooter.gameobject.entities;\n\nimport java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Point2D;\nimport java.util.function.BiFunction;\n\nimport topdown.shooter.gameobject.weapons.Weapon;\nimport topdown.shooter.input.InputManager;\nimport topdown.shooter.math.Vector2f;\nimport topdown.shooter.scene.Scene;\nimport topdown.shooter.scene.SceneManager;\nimport topdown.shooter.utilities.Util;\n\npublic class Player extends Entity {\n\tWeapon weapon;\n\n\tpublic Player(Scene scene, Vector2f position) {\n\t\tsuper(scene, position, 100, 100);\n\t\tinit();\n\t}\n\t\n\t@Override\n\tpublic void kill() {\n        SceneManager.startScene(\"welcomescreen\");\n\t}\n\n\t@Override\n\tpublic void update() {\n        direction = new Vector2f();\n\n\t\tmanageInput();\n\t\t\n\t\trotateMouseFollow();\n\n\t\tmanageTransformation();\n\t}\n\n\t@Override\n\tpublic void render(Graphics2D g2d) {\n\t\trenderer.drawImage(sprite, g2d, position, (float) rotationAngle, width, height);\n\t}\n\n\t@Override\n\tpublic void init() {\n\t\tname = \"Player\";\n\t\thealth = 300;\n\t\tsprite = Util.loadImageFromFile(\"resources/images/player/test.png\");\n\t\ttransform = AffineTransform.getTranslateInstance(position.x - width / 2, position.y - height / 2);\n\t\tspeed = 3;\n\n\t}\n\n\tprivate void rotateMouseFollow() {\n\t\tBiFunction<Point2D, Point2D, Double> angle = (c,m) -> \n\t\t\t\t\t\t(Math.atan2(c.getY() - m.getY(),\n\t\t                c.getX() - m.getX())) + Math.PI*1.5;\n\t\t        \n\n\t\tPoint2D player = new Point2D.Double( renderer.getXOffset(), renderer.getYOffset());\n\t\tPoint2D mouse = new Point2D.Double(InputManager.getMouseX(), InputManager.getMouseY());\n\n\t\trotationAngle = angle.apply(player, mouse);\n\t}\n\n\tprivate void manageInput() {\n\t\tif (InputManager.getKeyPressed(\"w\"))\n\t\t\tdirection.y--;\n\t\tif (InputManager.getKeyPressed(\"a\"))\n\t\t\tdirection.x--;\n\t\tif (InputManager.getKeyPressed(\"d\"))\n\t\t\tdirection.x++;\n\t\tif (InputManager.getKeyPressed(\"s\"))\n\t\t\tdirection.y++;\n\t}\n\t\n\tprivate void manageTransformation() {\n\t\tdirection = direction.normalize().scale(speed);\n\t\tposition = position.add(direction);\n\n\t\ttransform = AffineTransform.getTranslateInstance(position.x - width / 2, position.y - height / 2);\n\t\ttransform.rotate(rotationAngle, width / 2, height / 2);\n\t}\n}",
      "Zombie.java": "package topdown.shooter.gameobject.entities.zombies;\n\nimport topdown.shooter.gameobject.entities.Entity;\nimport topdown.shooter.math.Vector2f;\nimport topdown.shooter.scene.Scene;\n\npublic abstract class Zombie extends Entity{\n\n\tpublic Zombie(Scene scene, Vector2f position, float width, float height) {\n\t\tsuper(scene, position, width, height);\n\t}\n\n}\n",
      "NormalZombie.java": "package topdown.shooter.gameobject.entities.zombies;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\n\nimport topdown.shooter.gameobject.entities.Entity;\nimport topdown.shooter.gameobject.entities.Player;\nimport topdown.shooter.math.Vector2f;\nimport topdown.shooter.scene.Scene;\n\npublic class NormalZombie extends Zombie {\n\tprivate Player player;\n\t\n\tpublic NormalZombie(Scene scene, Vector2f position, Player player) {\n\t\tsuper(scene, position, 40, 40);\n\t\tthis.health = 50;\n\t\tthis.speed = 1;\n\t\tthis.player = player;\n\t}\n\n\t@Override\n\tpublic void init() {\n\t\tname = \"NormalZombie\";\n\t\ttransform = AffineTransform.getTranslateInstance(position.x - width / 2, position.y - height / 2);\n\t}\n\n\t@Override\n\tpublic void update() {\n        direction = new Vector2f();\n        \n        if ( position.x > player.getPosition().x)\n\t\t\tdirection.x--;\n        if ( position.x < player.getPosition().x)\n\t\t\tdirection.x++;\n        if ( position.y > player.getPosition().y)\n\t\t\tdirection.y--;\n        if ( position.y < player.getPosition().y)\n\t\t\tdirection.y++;\n        \n        direction = direction.normalize().scale(speed);\n\t\tposition = position.add(direction);\n\n\t\ttransform = AffineTransform.getTranslateInstance(position.x - width / 2, position.y - height / 2);\n\t\ttransform.rotate(rotationAngle, width / 2, height / 2);\n\t}\n\n\t@Override\n\tpublic void render(Graphics2D g2d) {\n\t\trenderer.fillRect(g2d, position, Color.green, (int) width, (int) height);\n\t}\n\n\t@Override\n\tpublic void kill() {\t\t\n\t}\n}\n",
      "SurungeZombie.java": "package topdown.shooter.gameobject.entities.zombies;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\n\nimport topdown.shooter.gameobject.entities.Entity;\nimport topdown.shooter.gameobject.entities.Player;\nimport topdown.shooter.math.Vector2f;\nimport topdown.shooter.scene.Scene;\n\npublic class SurungeZombie extends Zombie {\n\n\tprivate Player player;\n\t\n\tpublic SurungeZombie(Scene scene, Vector2f position, Player player) {\n\t\tsuper(scene, position, 20, 20);\n\t\tthis.health = 100;\n\t\tthis.speed = 0.6f;\n\t\tthis.player = player;\n\t}\n\n\t@Override\n\tpublic void init() {\n\t\tname = \"SurungeZombie\";\n\t\ttransform = AffineTransform.getTranslateInstance(position.x - width / 2, position.y - height / 2);\n\t}\n\n\t@Override\n\tpublic void update() {\n        direction = new Vector2f();\n        \n        if ( position.x > player.getPosition().x)\n\t\t\tdirection.x--;\n        if ( position.x < player.getPosition().x)\n\t\t\tdirection.x++;\n        if ( position.y > player.getPosition().y)\n\t\t\tdirection.y--;\n        if ( position.y < player.getPosition().y)\n\t\t\tdirection.y++;\n        \n        direction = direction.normalize().scale(speed);\n\t\tposition = position.add(direction);\n\n\t\ttransform = AffineTransform.getTranslateInstance(position.x - width / 2, position.y - height / 2);\n\t\ttransform.rotate(rotationAngle, width / 2, height / 2);\n\t}\n\n\t@Override\n\tpublic void render(Graphics2D g2d) {\n\t\trenderer.fillRect(g2d, position, Color.pink ,(int) width, (int) height);\n\t}\n\n\t@Override\n\tpublic void kill() {\t\t\n\t}\n}\n",
      "TankZombie.java": "package topdown.shooter.gameobject.entities.zombies;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\n\nimport topdown.shooter.gameobject.entities.Entity;\nimport topdown.shooter.gameobject.entities.Player;\nimport topdown.shooter.math.Vector2f;\nimport topdown.shooter.scene.Scene;\n\npublic class TankZombie extends Zombie {\n\tprivate Player player;\n\t\n\tpublic TankZombie(Scene scene, Vector2f position, Player player) {\n\t\tsuper(scene, position, 70, 70);\n\t\tthis.health = 150;\n\t\tthis.speed = 0.4f;\n\t\tthis.player = player;\n\t}\n\n\t@Override\n\tpublic void init() {\n\t\tname = \"TankZombie\";\n\t\ttransform = AffineTransform.getTranslateInstance(position.x - width / 2, position.y - height / 2);\n\t}\n\n\t@Override\n\tpublic void update() {\n        direction = new Vector2f();\n        \n        if ( position.x > player.getPosition().x)\n\t\t\tdirection.x--;\n        if ( position.x < player.getPosition().x)\n\t\t\tdirection.x++;\n        if ( position.y > player.getPosition().y)\n\t\t\tdirection.y--;\n        if ( position.y < player.getPosition().y)\n\t\t\tdirection.y++;\n        \n        direction = direction.normalize().scale(speed);\n\t\tposition = position.add(direction);\n\n\t\ttransform = AffineTransform.getTranslateInstance(position.x - width / 2, position.y - height / 2);\n\t\ttransform.rotate(rotationAngle, width / 2, height / 2);\n\t}\n\n\t@Override\n\tpublic void render(Graphics2D g2d) {\n\t\trenderer.fillRect(g2d, position, Color.cyan ,(int) width, (int) height);\n\t}\n\n\t@Override\n\tpublic void kill() {\n\t\t\n\t}\n}\n",
      "AsitTukurenZombie.java": "package topdown.shooter.gameobject.entities.zombies;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\n\nimport topdown.shooter.gameobject.entities.Entity;\nimport topdown.shooter.gameobject.entities.Player;\nimport topdown.shooter.math.Vector2f;\nimport topdown.shooter.scene.Scene;\n\npublic class AsitTukurenZombie extends Zombie {\n\n\tprivate Player player;\n\t\n\tpublic AsitTukurenZombie(Scene scene, Vector2f position, Player player) {\n\t\tsuper(scene, position, 40, 40);\n\t\tthis.health = 10;\n\t\tthis.speed = 0.8f;\n\t\tthis.player = player;\n\t}\n\n\t@Override\n\tpublic void init() {\n\t\tname = \"AsitTukurenZombie\";\n\t\ttransform = AffineTransform.getTranslateInstance(position.x - width / 2, position.y - height / 2);\n\t}\n\n\t@Override\n\tpublic void update() {\n        direction = new Vector2f();\n        \n        if ( position.x > player.getPosition().x)\n\t\t\tdirection.x--;\n        if ( position.x < player.getPosition().x)\n\t\t\tdirection.x++;\n        if ( position.y > player.getPosition().y)\n\t\t\tdirection.y--;\n        if ( position.y < player.getPosition().y)\n\t\t\tdirection.y++;\n        \n        direction = direction.normalize().scale(speed);\n\t\tposition = position.add(direction);\n\n\t\ttransform = AffineTransform.getTranslateInstance(position.x - width / 2, position.y - height / 2);\n\t\ttransform.rotate(rotationAngle, width / 2, height / 2);\n\t}\n\n\t@Override\n\tpublic void render(Graphics2D g2d) {\n\t\trenderer.fillRect(g2d, position, Color.green, (int) width, (int) height);\n\t}\n\n\t@Override\n\tpublic void kill() {\n\t\t\n\t}\n}\n",
      "GameManager.java": "package topdown.shooter.main;\n\nimport java.awt.Canvas;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferStrategy;\n\nimport topdown.shooter.display.Display;\nimport topdown.shooter.input.InputManager;\nimport topdown.shooter.scene.Scene;\nimport topdown.shooter.scene.SceneManager;\n\npublic class GameManager extends Thread {\n\n\tprivate final int FPS = 60;\n\tprivate boolean running;\n\tprivate Display display;\n\tprivate Canvas canvas;\n\tprivate BufferStrategy bufferStrategy;\n\tprivate Scene scene;\n\n\tpublic GameManager(Display display) {\n\t\tthis.display = display;\n\t\tthis.running = true;\n\t\tinit();\n\t}\n\t\n\tpublic void init() {\n\t\tnew InputManager();\n\t\t\n\t\tSceneManager.initialize();\n\t\tSceneManager.startScene(\"WelcomeScene\");\n\t\tscene = SceneManager.getCurrentScene();\n\t}\n\n\tpublic void update() {// updating code\n\t\tscene = SceneManager.getCurrentScene();\n\t\tscene.update();\n\t}\n\n\tpublic void render() {// rendering or drawing\n\n\t\tinitializeGraphics();\n\t\tGraphics g = bufferStrategy.getDrawGraphics();\n\n\t\t// Drawing start\n\t\tg.clearRect(0, 0, Game.width, Game.height);\n\t\tGraphics2D g2d = (Graphics2D) g;\n\n\t\tscene.render(g2d);\n\t\t// Drawing end\n\n\t\tbufferStrategy.show();\n\t\tg.dispose();\n\t}\n\n\tpublic void initializeGraphics() {\n\t\tcanvas = display.getCanvas();\n\t\tbufferStrategy = canvas.getBufferStrategy();\n\t\tif (bufferStrategy != null)\n\t\t\treturn;\n\n\t\tcanvas.createBufferStrategy(3);\n\t\tbufferStrategy = canvas.getBufferStrategy();\n\t}\n\n\n\t@Override\n\tpublic void run() {\n\n\t\tfloat timePerUpdate = 1000000000 / FPS;\n\t\tint FPScounter = 0;\n\t\tlong FPSnowTime, FPSlastTime = System.currentTimeMillis();\n\t\tlong currentTime, prevTime = System.nanoTime(); // Time after update and render\n\n\t\twhile (running) {\n\t\t\tcurrentTime = System.nanoTime();\n\t\t\tif ((currentTime - prevTime) >= timePerUpdate) {\n\t\t\t\tupdate();\n\t\t\t\trender();\n\t\t\t\tFPScounter++;\n\t\t\t\tprevTime = currentTime;// Only reset if its updated\n\t\t\t}\n\n\t\t\tFPSnowTime = System.currentTimeMillis();\n\t\t\t// Takes fps 5 times a second\n\t\t\tif ((FPSnowTime - FPSlastTime) >= 200) {\n\t\t\t\tSystem.out.println(FPScounter * 5 + \" updates this second\");\n\t\t\t\tFPScounter = 0;\n\t\t\t\tFPSlastTime = FPSnowTime;\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "Game.java": "package topdown.shooter.main;\n\nimport topdown.shooter.display.Display;\n\npublic class Game {\n\tpublic static final int width = 640, height = 480;\n\t\n\tpublic static void main(String[] args) {\n\n\t\tDisplay display = new Display(\"Top-Down Shooter\",640, 480);\n\t\t\n\t\tGameManager gameManager = new GameManager(display);\n\t\tgameManager.start();\n\t\t\n\t}\n\n}\n",
      "Util.java": "package topdown.shooter.utilities;\n\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport javax.sound.sampled.LineUnavailableException;\nimport javax.sound.sampled.UnsupportedAudioFileException;\n\npublic class Util {\n\n\tpublic static BufferedImage loadImageFromFile(String path) {\n\n\t\tBufferedImage img = null;\n\t\ttry {\n\t\t\timg = ImageIO.read(new File(path));\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn img;\n\t}\n\n\t// .jar file'ı dosyaları yüklemesi için ama .jar'ı çalıştıramadım şuanlık\n\tpublic static BufferedImage loadImageFromClass(String path) {\n\n\t\tBufferedImage img = null;\n\t\ttry {\n\t\t\timg = ImageIO.read(Util.class.getResourceAsStream(\"/\"+path));\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn img;\n\t}\n\tpublic static Clip loadSoundFromFile(String path) {\n\n\t\tClip c = null;\n\t\ttry {\n\t\t\tc = AudioSystem.getClip();\n\t\t\tAudioInputStream audioInput = AudioSystem.getAudioInputStream(new File(path));\n\t\t\tc.open(audioInput);\n\n\t\t} catch (LineUnavailableException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (UnsupportedAudioFileException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn c;\n\t}\n\n\tpublic static Clip loadSoundFromClass(String path) {\n\n\t\tClip c = null;\n\t\ttry {\n\t\t\tc = AudioSystem.getClip();\n\t\t\tAudioInputStream audioInput = AudioSystem.getAudioInputStream( Util.class.getResourceAsStream(\"/\"+path));\n\t\t\tc.open(audioInput);\n\n\t\t} catch (LineUnavailableException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (UnsupportedAudioFileException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn c;\n\t}\n}\n",
      "InputManager.java": "package topdown.shooter.input;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.MouseEvent;\nimport java.util.HashMap;\n\npublic class InputManager {\n\n\tprivate static HashMap<String, Integer> keys;\n\tprivate static HashMap<String, Integer> buttons;\n\n\tpublic InputManager() {\n\t\tkeys = new HashMap<String, Integer>();\n\t\tbuttons = new HashMap<String, Integer>();\n\t\t// To not write KeyEvent.VK everytime\n\t\t// I just need to write the string name\n\t\tkeys.put(\"enter\", KeyEvent.VK_ENTER);\n\t\tkeys.put(\"esc\", KeyEvent.VK_ESCAPE);\n\n\t\tkeys.put(\"w\", KeyEvent.VK_W);\n\t\tkeys.put(\"a\", KeyEvent.VK_A);\n\t\tkeys.put(\"d\", KeyEvent.VK_D);\n\t\tkeys.put(\"s\", KeyEvent.VK_S);\n\n\t\tkeys.put(\"q\", KeyEvent.VK_Q);// Melee ?\n\t\tkeys.put(\"r\", KeyEvent.VK_R);// Relaod ?\n\t\tkeys.put(\"e\", KeyEvent.VK_E);// Power ?\n\t\tkeys.put(\"g\", KeyEvent.VK_G);// Grenade ?\n\n\t\tkeys.put(\"1\", KeyEvent.VK_1);// 1. Tabanca weapon\n\t\tkeys.put(\"2\", KeyEvent.VK_2);// 2. PiyadeTufegi weapon\n\t\tkeys.put(\"3\", KeyEvent.VK_3);// 3. Pompalı weapon\n\t\tkeys.put(\"4\", KeyEvent.VK_4);// 4. KeskinNişancı weapon\n\t\tkeys.put(\"5\", KeyEvent.VK_5);// 5. RoketAtar weapon\n\n\t\tbuttons.put(\"rightM\", MouseEvent.BUTTON3);\n\t\tbuttons.put(\"leftM\", MouseEvent.BUTTON1);\n\t\tbuttons.put(\"middleM\", MouseEvent.BUTTON2);\n\t}\n\n\tpublic static boolean getKeyPressed(String key) {\n\t\ttry {\n\t\t\treturn KeyInput.getKeyPressed(keys.get(key));\n\t\t} catch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static boolean getMouseKeyPressed(String key) {\n\t\ttry {\n\t\t\treturn MouseInput.getButtonPressed(buttons.get(key));\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static boolean isMouseMoving() {\n\t\tboolean moving = MouseInput.mouseMoving;\n\t\tMouseInput.update();\n\t\treturn moving;\n\t}\n\n\tpublic static int getMouseX() {\n\t\treturn MouseInput.mouseX;\n\t}\n\n\tpublic static int getMouseY() {\n\t\treturn MouseInput.mouseY;\n\t}\n}",
      "KeyInput.java": "package topdown.shooter.input;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\npublic class KeyInput implements KeyListener{\n\tpublic static boolean keys[];\n\t\n\tpublic KeyInput(){\n\t\tkeys = new boolean[255];\n\t}\n\t\n\t@Override\n\tpublic void keyTyped(KeyEvent e) {}\n\n\t@Override\n\tpublic void keyPressed(KeyEvent e) {\n\t\ttry {\n\t\t\tkeys[e.getKeyCode()] = true;\n\t\t}catch(Exception ex) {}\n\t}\n\n\t@Override\n\tpublic void keyReleased(KeyEvent e) {\n\t\ttry {\n\t\t\tkeys[e.getKeyCode()] = false;\n\t\t}catch(Exception ex) {}\n\t}\n\n\tpublic static boolean getKeyPressed(int key) {\n\t\treturn keys[key];\n\t}\n}\n",
      "MouseInput.java": "package topdown.shooter.input;\n\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\nimport java.awt.event.MouseWheelEvent;\nimport java.awt.event.MouseWheelListener;\n\npublic class MouseInput implements MouseListener, MouseWheelListener, MouseMotionListener {\n\tpublic static int mouseX, mouseY;\n\tpublic static boolean mouseMoving = false;\n\tpublic static boolean isMousePressed = false;\n\tpublic static boolean buttons[];\n\n\tpublic MouseInput() {\n\t\tbuttons = new boolean[100];\n\t}\n\n\tpublic static void update() {\n\t\tmouseMoving = false;\n\t}\n\n\t@Override\n\tpublic void mouseClicked(MouseEvent e) {\n\t}\n\n\t@Override\n\tpublic void mousePressed(MouseEvent e) {\n\t\ttry {\n\t\t\tbuttons[e.getButton()] = true;\n\t\t} catch (Exception ex) {\n\n\t\t}\n\t\tisMousePressed = true;\n\t}\n\n\t@Override\n\tpublic void mouseReleased(MouseEvent e) {\n\t\ttry {\n\t\t\tbuttons[e.getButton()] = false;\n\t\t} catch (Exception ex) {\n\n\t\t}\n\t\tisMousePressed = false;\n\t}\n\n\t@Override\n\tpublic void mouseEntered(MouseEvent e) {\n\t}\n\n\t@Override\n\tpublic void mouseExited(MouseEvent e) {\n\t}\n\n\t@Override\n\tpublic void mouseWheelMoved(MouseWheelEvent e) {\n\t}\n\n\t@Override\n\tpublic void mouseDragged(MouseEvent e) {\n\t\tmouseX = e.getX();\n\t\tmouseY = e.getY();\n\t\tmouseMoving = true;\n\t}\n\n\t@Override\n\tpublic void mouseMoved(MouseEvent e) {\n\t\tmouseX = e.getX();\n\t\tmouseY = e.getY();\n\t\tmouseMoving = true;\n\t}\n\n\tpublic static boolean getButtonPressed(int key) {\n\t\treturn buttons[key];\n\t}\n}\n",
      "GamePlayScene.java": "package topdown.shooter.scene;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\n\nimport topdown.shooter.gameobject.GameObject;\nimport topdown.shooter.gameobject.entities.Player;\nimport topdown.shooter.gameobject.projectiles.Bullet;\nimport topdown.shooter.gameobject.projectiles.Projectile;\nimport topdown.shooter.gfx.Sound;\nimport topdown.shooter.input.InputManager;\nimport topdown.shooter.math.Vector2f;\nimport topdown.shooter.utilities.Util;\n\npublic class GamePlayScene extends Scene {\n\n\tprivate BufferedImage map;\n\tprivate Sound mainSound;\n\tprivate GameObject cameraTarget;\n\tprivate boolean gamePlayMusicStop = false;\n    public static ArrayList<Projectile> projectiles;\n\n\tpublic GamePlayScene() {\n\t\tsuper(\"GamePlayScene\");\n        projectiles = new ArrayList<Projectile>();\n\t}\n\n\t@Override\n\tpublic void updateScene() {\n\t\tcamera.centerOnGameObject(cameraTarget);\n\t\t\n\t\tif (InputManager.getKeyPressed(\"esc\")) \n\t\t\tSceneManager.startScene(\"WelcomeScene\");\n\t\t\n\t\tfor(Projectile projectile : projectiles) {\n\t\t\tprojectile.update();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void end() {\n\t\tgamePlayMusicStop = true;\n\t\tmainSound.stopSound();\n\t}\n\n\t@Override\n\tpublic void init() {\n\n\t\tmap = Util.loadImageFromFile(\"resources/images/maps/image1_0.jpg\");\n\t\twidth = map.getWidth();\n\t\theight = map.getHeight();\n\t\t\n\t\tmainSound = new Sound(Util.loadSoundFromFile(\"resources/sounds/mainmenusound/ambientsound.wav\"));\n\n\t\taddObject(new Player(this, new Vector2f(0, 0)));\n\t\tcameraTarget = getGameObjectByName(\"Player\");\n\t}\n\n\t@Override\n\tpublic void drawScene(Graphics2D g2d) {\n\t\trenderer.drawImage(map, g2d, position, 0, width, height);\n\t\tif (!gamePlayMusicStop)\n\t\t\tmainSound.playSound();\n\t\tgamePlayMusicStop = false;\n\t}\n\n\tpublic void addProjectile(Projectile projectile){\n        projectiles.add(projectile);\n    }\n    public void removeProjectile(Projectile projectile){\n        projectiles.remove(projectile);\n    }\n\n}\n",
      "WelcomeScene.java": "package topdown.shooter.scene;\n\nimport java.awt.Graphics2D;\n\nimport topdown.shooter.gameobject.projectiles.Projectile;\nimport topdown.shooter.input.InputManager;\nimport topdown.shooter.main.Game;\nimport topdown.shooter.utilities.Util;\n\npublic class WelcomeScene extends Scene {\n\n\tpublic WelcomeScene() {\n\t\tsuper(\"WelcomeScene\");\n\t}\n\n\t@Override\n\tpublic void end() {\n\t}\n\n\t@Override\n\tpublic void init() {\n\t\tsprite = Util.loadImageFromFile(\"resources/images/loadingscreen/welcomescene.jpg\");\n\t\twidth = sprite.getWidth();\n\t\theight = sprite.getHeight();\n\n\t}\n\n\t@Override\n\tpublic void drawScene(Graphics2D g2d) {\n\t\tg2d.drawImage(sprite, 0, 0, (int) Game.width-10, (int) Game.height-35, null);\n\t}\n\n\t@Override\n\tpublic void updateScene() {\n\t\tif (InputManager.getKeyPressed(\"enter\"))\n\t\t\tSceneManager.startScene(\"GamePlayScene\");\n\t}\n\n\tpublic void addProjectile(Projectile projectile) {}\n\n}\n",
      "SceneManager.java": "package topdown.shooter.scene;\n\nimport java.util.ArrayList;\n\npublic class SceneManager {\n\tprivate static Scene currentScene;\n\tprivate static ArrayList<Scene> allScenes = new ArrayList<>();\n\t\n\tpublic static void initialize() {\n\t\tallScenes.add(new GamePlayScene());\n\t\tallScenes.add(new WelcomeScene());\n\t}\n\t\n\tpublic static void addScene(Scene scene) {\n\t\tallScenes.add(scene);\n\t}\n\t\n\t// Start a scene in allScenes arrayList by name\n\tpublic static void startScene(String sceneName) {\n\t\tfor(Scene scene : allScenes) {\n\t\t\tif(scene.getName().equals(sceneName) ) {\n\t\t\t\t\n\t\t\t\tif(currentScene != null)\n\t\t\t\t\tcurrentScene.endScene();\n\t\t\t\tcurrentScene = scene;\n\t\t\t\tcurrentScene.startScene();\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t}\n\t\n\tpublic static Scene getCurrentScene() {\n\t\treturn currentScene;\n\t}\n\t\n\tpublic static Scene getSceneByName(String name) {\n\t\tfor(Scene scene : allScenes) {\n\t\t\tif(scene.getName().equals(name))\n\t\t\t\treturn scene;\n\t\t}\n\t\treturn null;\n\t}\n}\n",
      "Scene.java": "package topdown.shooter.scene;\n\nimport java.awt.Graphics2D;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport topdown.shooter.gameobject.GameObject;\nimport topdown.shooter.gameobject.entities.zombies.Zombie;\nimport topdown.shooter.gameobject.projectiles.Projectile;\nimport topdown.shooter.gfx.Camera;\nimport topdown.shooter.gfx.Renderer;\nimport topdown.shooter.main.Game;\nimport topdown.shooter.math.Vector2f;\n\npublic abstract class Scene extends GameObject {\n\tprotected List<Zombie> zombies;\n\tprotected List<GameObject> gameObjects;\n\tprotected boolean hasSceneStarted = false;\n\tprotected Camera camera;\n\n\tprotected abstract void end();\n\tprotected abstract void drawScene(Graphics2D g2d);\n\tprotected abstract void updateScene();\n\tpublic abstract void addProjectile(Projectile projectile);\n\n \tpublic Scene(String sceneName) {\n\t\tsuper();\n\t\tscene = this;\n\t\tname = sceneName;\n\t\tgameObjects = new ArrayList<GameObject>();\n\t\tzombies = new ArrayList<Zombie>();\n\t\tcamera = new Camera(new Vector2f(width/2,height/2), Game.width, Game.height);\n\t}\n\t\n\tpublic void addObject(GameObject gameObject) {\n\t\tgameObjects.add(gameObject);\n\t}\n\n\tpublic void startScene() {\n\t\tif(hasSceneStarted)\n\t\t\treturn;\n\t\tcamera = new Camera(new Vector2f(0, 0), Game.width, Game.height);\t\t\n\t\trenderer = new Renderer();\n\t\trenderer.setCamera(camera);\n\n\t\tinit();\n\t\tcamera.setWidth(SceneManager.getSceneByName(\"GamePlayScene\").getWidth());\n\t\tcamera.setHeight(SceneManager.getSceneByName(\"GamePlayScene\").getHeight());\n\t\t\n\t\tfor(GameObject gameObject : gameObjects) {\n\t\t\tgameObject.init();\n\t\t}\n\t\thasSceneStarted = true;\n\t}\n\n\tpublic void endScene() {\n\t\tend();\n\t\thasSceneStarted = false;\n\t\tgameObjects.clear();\n\t}\n\n\t@Override\n\tpublic void update() {\n\t\tupdateScene();\n\t\tfor (GameObject gameObject : gameObjects) {\n\t\t\tgameObject.update();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void render(Graphics2D g2d) {\n\t\tdrawScene(g2d);\n\t\tfor (GameObject gameObject : gameObjects) {\n\t\t\tgameObject.render(g2d);\n\t\t}\n\t}\n\t\n\tpublic GameObject getGameObjectByName(String name) {\n\t\tfor(GameObject gameObject : gameObjects) {\n\t\t\tif(gameObject.getName().equals(name))\n\t\t\t\treturn gameObject;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic List<GameObject> getGameObjects() {\n\t\treturn gameObjects;\n\t}\n\tpublic Camera getCamera() {\n\t\treturn camera;\n\t}\n\tpublic void setCamera(Camera camera) {\n\t\tthis.camera = camera;\n\t}\n}\n",
      "Display.java": "package topdown.shooter.display;\n\nimport java.awt.Canvas;\nimport java.awt.Color;\n\nimport javax.swing.JFrame;\n\nimport topdown.shooter.input.KeyInput;\nimport topdown.shooter.input.MouseInput;\n\npublic class Display extends JFrame{\n\t\n\tprivate Canvas canvas;\n\tprivate KeyInput keyInput;\n\tprivate MouseInput mouseInput;\n\t\n\tpublic Display(String title, int width, int height) {\n\t\tthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tthis.setTitle(title);\n\t\tthis.setSize(width,height);\n\t\tcanvas = new Canvas();\n\t\tcanvas.setSize(width, height);\n\t\tcanvas.setBackground(Color.black);\n\t\tthis.add(canvas);\n\t\t\n\t\tkeyInput = new KeyInput();\n\t\tcanvas.addKeyListener(keyInput);\n\t\tmouseInput = new MouseInput();\n\t\tcanvas.addMouseListener(mouseInput);\n\t\tcanvas.addMouseMotionListener(mouseInput);\n\t\tcanvas.addMouseWheelListener(mouseInput);\n\t\t\n\t\tthis.setLocationRelativeTo(null);\n\t\tthis.setVisible(true);\n\t}\n\t\n\t\n\tpublic Canvas getCanvas() {\n\t\treturn canvas;\n\t}\n}\n",
      "Vector2f.java": "package topdown.shooter.math;\n\npublic class Vector2f {\n\n\tpublic float x, y;\n\n\tpublic Vector2f() {\n\t\tx = 0;\n\t\ty = 0;\n\t}\n\n\tpublic Vector2f(float x, float y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic Vector2f add(Vector2f a) {\n\t\treturn new Vector2f(x + a.x, y + a.y);\n\t}\n\n\tpublic Vector2f subtract(Vector2f a) {\n\t\treturn new Vector2f(x - a.x, y - a.y);\n\t}\n\n\tpublic Vector2f divide(float value) {\n\t\tif (value == 0)\n\t\t\treturn this;\n\t\treturn new Vector2f(x / value, y / value);\n\t}\n\n\tpublic Vector2f scale(float scale) {\n\t\treturn new Vector2f(x * scale, y * scale);\n\t}\n\n\tpublic float getLength() {\n\t\treturn (float) Math.sqrt(x * x + y * y);\n\t}\n\n\tpublic float calculateDistance(Vector2f b) {\n\t\treturn subtract(b).getLength();\n\t}\n\n\t// Make the vector a unit vector\n\tpublic Vector2f normalize() {\n\t\treturn divide(getLength());\n\t}\n\n\tpublic Vector2f rotateRad(double radians) {\n\t\tdouble x, y;\n\t\tVector2f normalized = normalize();\n\t\tx = (Math.cos(radians) * normalized.x) - (Math.sin(radians) * normalized.y);\n\t\ty = (Math.sin(radians) * normalized.x) + (Math.cos(radians) * normalized.y);\n\t\treturn new Vector2f((float) x, (float) y);\n\t}\n\n\tpublic Vector2f clone() {\n\t\treturn new Vector2f(x, y);\n\t}\n}\n"
    },
    {
      "id": "6418019",
      "CrawlingZombie.java": "package entity;\n\nimport main.GamePanel;\n\npublic class CrawlingZombie extends Entity{\n    GamePanel gp;\n\n    public CrawlingZombie(GamePanel gp){\n        super(gp);\n        this.gp = gp;\n        direction = \"down\";\n        speed = 2;\n        damage = 1;\n        maxLife = 1;\n        life = maxLife;\n        point = 100;\n\n        solidArea.x = 3;\n        solidArea.y = 18;\n        solidArea.width = 42;\n        solidArea.height = 30;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        getImage();\n    }\n\n    public void getImage(){\n\n        up1 = setup(\"/npc/crawling_z_right1\", gp.tileSize, gp.tileSize);\n        up2 = setup(\"/npc/crawling_z_right2\", gp.tileSize, gp.tileSize);\n        down1 = setup(\"/npc/crawling_z_left1\", gp.tileSize, gp.tileSize);\n        down2 = setup(\"/npc/crawling_z_left2\", gp.tileSize, gp.tileSize);\n        left1 = setup(\"/npc/crawling_z_left1\", gp.tileSize, gp.tileSize);\n        left2 = setup(\"/npc/crawling_z_left2\", gp.tileSize, gp.tileSize);\n        right1 = setup(\"/npc/crawling_z_right1\", gp.tileSize, gp.tileSize);\n        right2 = setup(\"/npc/crawling_z_right2\", gp.tileSize, gp.tileSize);\n    }\n\n    public void setAction() {\n        int dx = gp.player.worldX - worldX;\n        int dy = gp.player.worldY - worldY;\n        \n        if (Math.abs(dx) > Math.abs(dy)) {\n            if (dx > 0) {\n                direction = \"right\";\n            } else {\n                direction = \"left\";\n            }\n        }\n        else {\n            if (dy > 0) {\n                direction = \"down\";\n            } else {\n                direction = \"up\";\n            }\n        }\n    }\n    \n}\n",
      "Entity.java": "package entity;\n\nimport java.awt.AlphaComposite;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport main.GamePanel;\nimport main.UtilityTool;\n\npublic class Entity {\n\n    GamePanel gp;\n    public int worldX, worldY;\n    public int speed;\n\n    public BufferedImage up1, up2, down1, down2, left1, left2, right1, right2;\n    public String direction;\n\n    public int spriteCounter = 0;\n    public int spriteNum = 1;\n\n    //public Rectangle attackArea = new Rectangle(0, 0, 0, 0);\n    public Rectangle solidArea = new Rectangle(0, 0, 48, 48);\n    public int solidAreaDefaultX, solidAreaDefaultY;\n    public boolean collisionOn = false;\n\n    public int actionLockCounter = 0;\n    public boolean invincible = false;\n    public int invincibleCounter = 0;\n\n    public boolean gunAttack = false;\n\n    //character status\n    public int maxLife;\n    public int life;\n    public int wave;\n    public int damage;\n\n    public int point = 0;\n\n\n    public Entity(GamePanel gp){\n        this.gp = gp;\n    }\n\n    public void setAction(){}\n\n    public void update(){\n    \n        setAction();\n        collisionOn = false;\n        gp.cChecker.checkTile(this);\n\n        int npcIndex = gp.cChecker.checkEntity(this, gp.npc);\n        boolean contactPlayer = gp.cChecker.checkPlayer(this);\n\n        if(contactPlayer){\n            if(!gp.player.invincible && npcIndex != 999){\n\n                int damage = gp.npc[npcIndex].damage;\n                if(damage < 0){\n                    damage = 0;\n                }\n                gp.player.life -= damage;\n                gp.player.invincible = true;\n            }\n        }\n\n        if(collisionOn == false){\n\n            switch(direction){\n            case \"up\":\n                worldY -= speed;\n                break;\n            case \"down\":\n                worldY += speed;\n                break;\n            case \"left\":\n                worldX -= speed;\n                break;\n            case \"right\":\n                worldX += speed;\n                break;\n            }\n        }\n        \n\n        spriteCounter++;\n        if(spriteCounter > 12){\n            if(spriteNum == 1){\n                spriteNum = 2;\n            }\n            else if(spriteNum == 2){\n                spriteNum = 1;\n            }\n            spriteCounter = 0;\n        }\n\n        if(invincible){\n            invincibleCounter++;\n            if(invincibleCounter > 40){\n                invincible = false;\n                invincibleCounter = 0;\n            }\n        }\n    }\n\n    public void draw(Graphics2D g2){\n\n        BufferedImage image = null;\n        int screenX = worldX - gp.player.worldX + gp.player.screenX;\n        int screenY = worldY - gp.player.worldY + gp.player.screenY;\n\n        if(worldX  + gp.tileSize > gp.player.worldX - gp.player.screenX &&\n               worldX - gp.tileSize < gp.player.worldX + gp.player.screenX &&\n               worldY + gp.tileSize > gp.player.worldY - gp.player.screenY && \n               worldY - gp.tileSize < gp.player.worldY + gp.player.screenY ){\n\n                switch(direction){\n                    case \"up\":\n                    if(spriteNum == 1){\n                        image = up1;\n                    }\n                    if(spriteNum == 2){\n                        image = up2;\n                    } \n                    break;\n                    case \"down\":\n                    if(spriteNum == 1){\n                        image = down1;\n                    }\n                    if(spriteNum == 2){\n                        image = down2;\n                    } \n                        break;\n                    case \"left\":\n                    if(spriteNum == 1){\n                        image = left1;\n                    }\n                    if(spriteNum == 2){\n                        image = left2;\n                    } \n                        break;\n                    case \"right\":\n                    if(spriteNum == 1){\n                        image = right1;\n                    }\n                    if(spriteNum == 2){\n                        image = right2;\n                    } \n                    break;\n                }\n\n                if(invincible){\n                    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.3f));\n                }\n\n                g2.drawImage(image, screenX, screenY, null);\n                g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1f));\n            }\n\n    }\n\n    public BufferedImage setup(String imagePath, int widht, int height){\n\n        UtilityTool uTool = new UtilityTool();\n        BufferedImage image = null;\n\n        try{\n            image = ImageIO.read(getClass().getResourceAsStream( imagePath +  \".png\"));\n            image = uTool.scaleImage(image, widht, height);\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n\n        return image;\n    }\n}\n",
      "AcidZombie.java": "package entity;\n\nimport main.GamePanel;\n\npublic class AcidZombie extends Entity {\n    GamePanel gp;\n    private int acidAttackCounter;\n    private final int acidAttackInterval = 480;\n\n    public AcidZombie(GamePanel gp) {\n        super(gp);\n        this.gp = gp;\n        direction = \"down\";\n        speed = 1;\n        damage = 1;\n        maxLife = 1;\n        life = maxLife;\n        point = 150;\n        acidAttackCounter = 0;\n\n        solidArea.x = 3;\n        solidArea.y = 18;\n        solidArea.width = 42;\n        solidArea.height = 30;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        getImage();\n    }\n\n    public void getImage() {\n        up1 = setup(\"/npc/acid_z_up1\", gp.tileSize, gp.tileSize);\n        up2 = setup(\"/npc/acid_z_up2\", gp.tileSize, gp.tileSize);\n        down1 = setup(\"/npc/acid_z_down1\", gp.tileSize, gp.tileSize);\n        down2 = setup(\"/npc/acid_z_down2\", gp.tileSize, gp.tileSize);\n        left1 = setup(\"/npc/acid_z_left1\", gp.tileSize, gp.tileSize);\n        left2 = setup(\"/npc/acid_z_left2\", gp.tileSize, gp.tileSize);\n        right1 = setup(\"/npc/acid_z_right1\", gp.tileSize, gp.tileSize);\n        right2 = setup(\"/npc/acid_z_right2\", gp.tileSize, gp.tileSize);\n    }\n\n    public void setAction() {\n        acidAttackCounter++;\n\n        int diffX = gp.player.worldX - worldX;\n        int diffY = gp.player.worldY - worldY;\n        double distance = Math.sqrt(diffX * diffX + diffY * diffY);\n\n        if(acidAttackCounter >= acidAttackInterval) {\n            spitAcid();\n            acidAttackCounter = 0;\n        }\n\n        if(Math.abs(diffX) > Math.abs(diffY)) {\n            direction = (diffX > 0) ? \"right\" : \"left\";\n        } else {\n            direction = (diffY > 0) ? \"down\" : \"up\";\n        }\n    }\n\n    public int[] getAcidSpawnPosition() {\n        int spawnX = worldX + gp.tileSize / 2;\n        int spawnY = worldY + gp.tileSize / 2; \n\n        switch(direction) {\n            case \"up\":       spawnY -= 10; break;\n            case \"down\":     spawnY += 10; break;\n            case \"left\":     spawnX -= 10; break;\n            case \"right\":    spawnX += 10; break;\n            case \"upright\":  { spawnX += 7; spawnY -= 7; break; }\n            case \"upleft\":   { spawnX -= 7; spawnY -= 7; break; }\n            case \"downright\":{ spawnX += 7; spawnY += 7; break; }\n            case \"downleft\": { spawnX -= 7; spawnY += 7; break; }\n        }\n        return new int[]{spawnX, spawnY};\n    }\n\n    public void spitAcid() {\n        int[] spawnPos = getAcidSpawnPosition();\n        int startX = spawnPos[0];\n        int startY = spawnPos[1];\n\n        int targetX = gp.player.worldX + gp.tileSize / 2;\n        int targetY = gp.player.worldY + gp.tileSize / 2;\n        \n        AcidBullet acid = new AcidBullet(gp, startX, startY, targetX, targetY);\n        gp.acidBulletList.add(acid);\n    }\n}\n",
      "Bullet.java": "package entity;\n\nimport main.GamePanel;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\n\npublic class Bullet extends Entity {\n    public int dx;\n    public int dy;\n    public int bulletSpeed = 8;\n    public int damage = 1;\n    public boolean explosive = false;\n    public int explosionRadius = 20;\n    public int explosionTimer = 30; \n    public BufferedImage bulletImage;\n    public boolean piercing = false;\n\n    public Bullet(GamePanel gp, int startX, int startY, int targetX, int targetY) {\n        super(gp);\n        this.worldX = startX;\n        this.worldY = startY;\n        int diffX = targetX - startX;\n        int diffY = targetY - startY;\n        double distance = Math.sqrt(diffX * diffX + diffY * diffY);\n        if (distance == 0) distance = 1; // Bölme hatasını önlemek için\n        this.dx = (int) Math.round((diffX / distance) * bulletSpeed);\n        this.dy = (int) Math.round((diffY / distance) * bulletSpeed);\n        setupBulletImage();\n    }\n\n    private void setupBulletImage() {\n        bulletImage = setup(\"/bullet/bullet\", gp.tileSize, gp.tileSize);\n    }\n\n    public void update() {\n        worldX += dx;\n        worldY += dy;\n    }\n\n    public void draw(Graphics2D g2) {\n        int screenX = worldX - gp.player.worldX + gp.player.screenX;\n        int screenY = worldY - gp.player.worldY + gp.player.screenY;\n        g2.drawImage(bulletImage, screenX, screenY, null);\n    }\n    \n    public Rectangle getSolidArea() {\n        return new Rectangle(worldX, worldY, bulletImage.getWidth(), bulletImage.getHeight());\n    }\n}",
      "NormalZombie.java": "package entity;\n\nimport main.GamePanel;\n\npublic class NormalZombie extends Entity{\n\n    GamePanel gp;\n\n    public NormalZombie(GamePanel gp){\n        super(gp);\n        this.gp = gp;\n        direction = \"down\";\n        speed = 1;\n        damage = 1;\n        maxLife = 2;\n        life = maxLife;\n        point = 50;\n\n        solidArea.x = 3;\n        solidArea.y = 18;\n        solidArea.width = 42;\n        solidArea.height = 30;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        getImage();\n    }\n\n    public void getImage(){\n\n        up1 = setup(\"/npc/normal_z_up1\", gp.tileSize, gp.tileSize);\n        up2 = setup(\"/npc/normal_z_up2\", gp.tileSize, gp.tileSize);\n        down1 = setup(\"/npc/normal_z_down1\", gp.tileSize, gp.tileSize);\n        down2 = setup(\"/npc/normal_z_down2\", gp.tileSize, gp.tileSize);\n        left1 = setup(\"/npc/normal_z_left1\", gp.tileSize, gp.tileSize);\n        left2 = setup(\"/npc/normal_z_left2\", gp.tileSize, gp.tileSize);\n        right1 = setup(\"/npc/normal_z_right1\", gp.tileSize, gp.tileSize);\n        right2 = setup(\"/npc/normal_z_right2\", gp.tileSize, gp.tileSize);\n    }\n\n    public void setAction() {\n        \n        int dx = gp.player.worldX - worldX;\n        int dy = gp.player.worldY - worldY;\n        \n        if (Math.abs(dx) > Math.abs(dy)) {\n            if (dx > 0) {\n                direction = \"right\";\n            } else {\n                direction = \"left\";\n            }\n        }\n        else {\n            if (dy > 0) {\n                direction = \"down\";\n            } else {\n                direction = \"up\";\n            }\n        }\n\n        \n    }\n    \n\n\n}\n",
      "RocketBullet.java": "package entity;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\nimport main.GamePanel;\nimport main.UtilityTool;\n\npublic class RocketBullet extends Bullet {\n    \n    public int damage = 5;\n    public int speed = 10; \n    public BufferedImage rocketImage;\n\n    public RocketBullet(GamePanel gp, int startX, int startY, int targetX, int targetY) {\n        super(gp, startX, startY, targetX, targetY);\n        this.bulletSpeed = speed;\n        int diffX = targetX - startX;\n        int diffY = targetY - startY;\n        double distance = Math.sqrt(diffX * diffX + diffY * diffY);\n        if(distance == 0) distance = 1;\n        this.dx = (int)Math.round((diffX / distance) * speed);\n        this.dy = (int)Math.round((diffY / distance) * speed);\n        setupRocketImage();\n    }\n    \n    public void setupRocketImage() {\n        try {\n            rocketImage = ImageIO.read(getClass().getResourceAsStream(\"/bullet/rocketBullet.png\"));\n            rocketImage = new UtilityTool().scaleImage(rocketImage, gp.tileSize * 2, gp.tileSize * 2);\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n        if(rocketImage == null) {\n            System.out.println(\"RocketBullet resmi yüklenemedi!\");\n        } else {\n            System.out.println(\"RocketBullet resmi yüklendi, boyut: \" \n                + rocketImage.getWidth() + \"x\" + rocketImage.getHeight());\n        }\n    }\n    \n    @Override\n    public void draw(Graphics2D g2) {\n        int screenX = worldX - gp.player.worldX + gp.player.screenX;\n        int screenY = worldY - gp.player.worldY + gp.player.screenY;\n        g2.drawImage(rocketImage, screenX, screenY, null);\n    }\n    \n    @Override\n    public java.awt.Rectangle getSolidArea() {\n        return new java.awt.Rectangle(worldX, worldY, rocketImage.getWidth(), rocketImage.getHeight());\n    }\n}\n",
      "TankZombie.java": "package entity;\n\nimport main.GamePanel;\n\npublic class TankZombie extends Entity {\n    GamePanel gp;\n\n    public TankZombie(GamePanel gp){\n        super(gp);\n        this.gp = gp;\n        direction = \"down\";\n        speed = 1;\n        damage = 2;\n        maxLife = 3;\n        life = maxLife;\n        point = 200;\n\n        solidArea.x = 3;\n        solidArea.y = 18;\n        solidArea.width = 42;\n        solidArea.height = 30;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        getImage();\n    }\n\n    public void getImage(){\n\n        up1 = setup(\"/npc/tank_z_up1\", gp.tileSize, gp.tileSize);\n        up2 = setup(\"/npc/tank_z_up2\", gp.tileSize, gp.tileSize);\n        down1 = setup(\"/npc/tank_z_down1\", gp.tileSize, gp.tileSize);\n        down2 = setup(\"/npc/tank_z_down2\", gp.tileSize, gp.tileSize);\n        left1 = setup(\"/npc/tank_z_left1\", gp.tileSize, gp.tileSize);\n        left2 = setup(\"/npc/tank_z_left2\", gp.tileSize, gp.tileSize);\n        right1 = setup(\"/npc/tank_z_right1\", gp.tileSize, gp.tileSize);\n        right2 = setup(\"/npc/tank_z_right2\", gp.tileSize, gp.tileSize);\n    }\n\n    public void setAction() {\n     \n        int dx = gp.player.worldX - worldX;\n        int dy = gp.player.worldY - worldY;\n\n        if (Math.abs(dx) > Math.abs(dy)) {\n            if (dx > 0) {\n                direction = \"right\";\n            } else {\n                direction = \"left\";\n            }\n        }\n        else {\n            if (dy > 0) {\n                direction = \"down\";\n            } else {\n                direction = \"up\";\n            }\n        }\n    }\n}\n",
      "AcidBullet.java": "package entity;\n\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport java.awt.Graphics2D;\n\nimport main.GamePanel;\nimport main.UtilityTool;\n\n\npublic class AcidBullet extends Entity {\n    \n    public int worldX, worldY;\n    public int dx, dy;\n    public int speed = 5; \n    public int damage = 1; \n    \n    public BufferedImage acidImage;\n    public Rectangle solidArea;\n\n    public AcidBullet(GamePanel gp, int startX, int startY, int targetX, int targetY) {\n        super(gp);\n        this.worldX = startX;\n        this.worldY = startY;\n        \n        int diffX = targetX - startX;\n        int diffY = targetY - startY;\n        double distance = Math.sqrt(diffX*diffX + diffY*diffY);\n        dx = (int)Math.round(diffX / distance * speed);\n        dy = (int)Math.round(diffY / distance * speed);\n        \n        setupAcidImage();\n        System.out.println(\"AcidBullet oluşturuldu: startX=\" + startX + \", startY=\" + startY + \", targetX=\" + targetX + \", targetY=\" + targetY);\n\n    }\n    \n    public void setupAcidImage() {\n        try {\n            acidImage = ImageIO.read(getClass().getResourceAsStream(\"/bullet/aciddBullet.png\"));\n            acidImage = new UtilityTool().scaleImage(acidImage, gp.tileSize, gp.tileSize);\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n        if(acidImage == null) {\n            System.out.println(\"AcidBullet resmi yüklenemedi!\");\n        } else {\n            System.out.println(\"AcidBullet resmi yüklendi, boyut: \" \n                    + acidImage.getWidth() + \"x\" + acidImage.getHeight());\n    }\n}\n    \n    public void update() {\n        worldX += dx;\n        worldY += dy;\n\n    }\n   \n    public void draw(Graphics2D g2) {\n        int screenX = worldX - gp.player.worldX + gp.player.screenX;\n        int screenY = worldY - gp.player.worldY + gp.player.screenY;\n        g2.drawImage(acidImage, screenX, screenY, null);\n    }\n\n    public java.awt.Rectangle getSolidArea() {\n        return new java.awt.Rectangle(worldX, worldY, acidImage.getWidth(), acidImage.getHeight());\n    }\n\n}\n",
      "Player.java": "package entity;\n\nimport main.KeyHandler;\nimport weapons.Gun;\nimport weapons.Weapons;\n\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\n\nimport main.GamePanel;\n\npublic class Player extends Entity{\n\n    KeyHandler keyH;\n\n    public Weapons currentWeapon;\n    public ArrayList<Weapons> weaponInventory;\n    public int currentWeaponIndex;\n\n    public final int screenX;\n    public final int screenY;\n\n    public int attackTimer = 0;\n    public int totalPoint = 0;\n\n    public Player(GamePanel gp, KeyHandler keyH){\n\n        super(gp);\n        this.keyH = keyH;\n\n        screenX = gp.screenWidth/2 - (gp.tileSize/2);\n        screenY = gp.screenHeight/2 - (gp.tileSize/2);\n\n        solidArea = new Rectangle();\n        solidArea.x = 8;\n        solidArea.y = 16;\n        solidArea.width = 32;\n        solidArea.height = 32;\n\n        currentWeapon = new Gun(gp, gp.FPS);\n        weaponInventory = new ArrayList<>();\n        weaponInventory.add(new Gun(gp, gp.FPS));\n        currentWeaponIndex = 0;\n        currentWeapon = weaponInventory.get(currentWeaponIndex);\n\n        setDefaultValues();\n        getPlayerImage();\n        \n    }\n\n    public void setDefaultValues(){\n        worldX = gp.tileSize * 24;\n        worldY = gp.tileSize * 23;\n        speed = 4;\n        direction = \"down\";\n\n        //player status\n        wave = 1;\n        totalPoint = 0;\n        maxLife = 6;\n        life = maxLife;\n    }\n\n    public void resetPosition(){\n        worldX = gp.tileSize * 24;\n        worldY = gp.tileSize * 23;\n    }\n\n    public void getPlayerImage(){\n\n        up1 = setup(\"/player/boy_up_1\", gp.tileSize, gp.tileSize);\n        up2 = setup(\"/player/boy_up_2\", gp.tileSize, gp.tileSize);\n        down1 = setup(\"/player/boy_down_1\", gp.tileSize, gp.tileSize);\n        down2 = setup(\"/player/boy_down_2\", gp.tileSize, gp.tileSize);\n        left1 = setup(\"/player/boy_left_1\", gp.tileSize, gp.tileSize);\n        left2 = setup(\"/player/boy_left_2\", gp.tileSize, gp.tileSize);\n        right1 = setup(\"/player/boy_right_1\", gp.tileSize, gp.tileSize);\n        right2 = setup(\"/player/boy_right_2\", gp.tileSize, gp.tileSize);\n\n    }\n\n    public void switchWeapon(int index){\n        if(index >= 0 && index < weaponInventory.size()){\n            currentWeaponIndex = index;\n            currentWeapon = weaponInventory.get(currentWeaponIndex);\n        }\n    }\n\n    public void nextWeapon(){\n        currentWeaponIndex = (currentWeaponIndex + 1) % weaponInventory.size();\n        currentWeapon = weaponInventory.get(currentWeaponIndex);\n    }\n\n    public void previousWeapon(){\n        currentWeaponIndex = (currentWeaponIndex - 1 + weaponInventory.size()) % weaponInventory.size();\n        currentWeapon = weaponInventory.get(currentWeaponIndex);\n    }\n    \n\n    public void update(){\n        \n        currentWeapon.cooldownUpdate();\n\n        if(gunAttack){\n            gunAttacking();\n        }\n        else if(keyH.upPressed || keyH.downPressed ||\n            keyH.leftPressed || keyH.rightPressed || keyH.spacePressed){\n\n                if(keyH.upPressed){\n                    direction = \"up\";     \n                }\n                else if(keyH.downPressed){\n                    direction = \"down\"; \n                }\n                else if(keyH.leftPressed){\n                    direction = \"left\";\n                }\n                else if(keyH.rightPressed){\n                    direction = \"right\";\n                }\n\n                //check tile collision\n                collisionOn = false;\n                gp.cChecker.checkTile(this);\n\n                //check npc collision\n                int npcIndex = gp.cChecker.checkEntity(this, gp.npc);\n                //interactNPC(npcIndex);\n                contactZombie(npcIndex);\n\n\n                //if collision is false, player can move\n                if(collisionOn == false){\n                    switch(direction){\n                    case \"up\": worldY -= speed; break;\n                    case \"down\": worldY += speed; break;\n                    case \"left\": worldX -= speed; break;\n                    case \"right\": worldX += speed; break;\n                    }\n                }\n                \n        \n                spriteCounter++;\n                if(spriteCounter > 12){\n                    if(spriteNum == 1){\n                        spriteNum = 2;\n                    }\n                    else if(spriteNum == 2){\n                        spriteNum = 1;\n                    }\n                    spriteCounter = 0;\n                }\n            }\n\n            if(invincible){\n                invincibleCounter++;\n                if(invincibleCounter > 60){\n                    invincible = false;\n                    invincibleCounter = 0;\n                }\n            }\n\n            if(life <= 0){\n                gp.gameState = gp.gameOverState;\n            }\n\n        \n    }\n\n    public void contactZombie(int i){\n        if(i != 999){\n            if(!invincible){\n                int damage = gp.npc[i].damage;\n                if(damage < 0){\n                    damage = 0;\n                }\n                life -= damage;\n                invincible = true;\n            }\n        }\n    }\n\n    public void damageZombie(int i){\n        if(i != 999){\n            if(!(gp.npc[i].invincible)){\n\n                gp.npc[i].life -= 1;\n                gp.npc[i].invincible = true;\n\n                if(gp.npc[i].life <= 0){\n                    gp.npc[i] = null;\n                }\n            }\n        }\n    }\n\n    public void gunAttacking(){\n\n        spriteCounter++;\n        if(spriteCounter <= 10){ \n            spriteNum = 1;\n        }\n        else if(spriteCounter <= 30){\n            spriteNum = 2;\n        }\n        else{\n            spriteNum = 1;\n            spriteCounter = 0;\n            gunAttack = false;\n        }\n    }\n\n    public int[] getGunTipPosition() {\n        // Başlangıç olarak, oyuncunun \"worldX\" ve \"worldY\" si,\n        // sprite’ın sol üst köşesini temsil eder.\n        int spawnX = worldX;\n        int spawnY = worldY;\n        \n        switch(direction) {\n            case \"up\":\n                // Yukarı bakarken sprite 16 genişlik, 32 yükseklik\n                // Karakterin merkezini bul, sonra biraz yukarı kaydır\n                spawnX += gp.tileSize / 2 - 16;  // ortalamak için\n                spawnY -= 8;               // kılıç ucunu yakalamak için\n                break;\n            case \"down\":\n                spawnX += gp.tileSize / 2 - 20;\n                // Aşağıya bakarken en alt tarafa inmek için tileSize kadar + ufak offset\n                spawnY += gp.tileSize + 8;\n                break;\n            case \"left\":\n                // Sola bakarken sprite 32 genişlik, 16 yükseklik\n                // soldan biraz dışarı\n                spawnX -= 8;\n                spawnY += gp.tileSize / 2 - 15;\n                break;\n            case \"right\":\n                spawnX += gp.tileSize + 8;\n                spawnY += gp.tileSize / 2 - 15;\n                break;\n        }\n        return new int[]{spawnX, spawnY};\n    }\n\n\n    public void draw(Graphics2D g2){\n\n        BufferedImage image = null;\n        int tempScreenX = screenX;\n        int tempScreenY = screenY;\n\n        switch(direction){\n            case \"up\":\n                if(!gunAttack){\n                    if(spriteNum == 1){image = up1;}\n                    if(spriteNum == 2){image = up2;} \n                }\n                if(gunAttack){\n                    tempScreenY = screenY - gp.tileSize;\n                    if(spriteNum == 1){image = currentWeapon.weaponUp1;}\n                    if(spriteNum == 2){image = currentWeapon.weaponUp2;} \n                }\n                break;\n            case \"down\":\n                if(!gunAttack){\n                    if(spriteNum == 1){image = down1;}\n                    if(spriteNum == 2){image = down2;} \n                }\n                if(gunAttack){\n                    if(spriteNum == 1){image = currentWeapon.weaponDown1;}\n                    if(spriteNum == 2){image = currentWeapon.weaponDown2;} \n                }\n                break;\n            case \"left\":\n                if(!gunAttack){\n                    if(spriteNum == 1){image = left1;}\n                    if(spriteNum == 2){image = left2;}\n                }\n                if(gunAttack){\n                    tempScreenX = screenX - gp.tileSize;\n                    if(spriteNum == 1){image = currentWeapon.weaponLeft1;}\n                    if(spriteNum == 2){image = currentWeapon.weaponLeft2;} \n                }\n                break;\n            case \"right\":\n                if(!gunAttack){\n                    if(spriteNum == 1){image = right1;}\n                    if(spriteNum == 2){image = right2;}\n                }\n                if(gunAttack){\n                    if(spriteNum == 1){image = currentWeapon.weaponRight1;}\n                    if(spriteNum == 2){image = currentWeapon.weaponRight2;} \n                }\n                break;\n        }\n\n        g2.drawImage(image, tempScreenX, tempScreenY, null);\n\n    }\n}\n",
      "WaveManager.java": "package main;\n\nimport java.util.Random;\n\nimport entity.CrawlingZombie;\nimport entity.AcidZombie;\nimport entity.Entity;\nimport entity.NormalZombie;\nimport entity.TankZombie;\nimport weapons.Rifle;\nimport weapons.RocketLauncher;\nimport weapons.Sniper;\nimport weapons.Weapons;\nimport weapons.Shotgun;\n\npublic class WaveManager {\n    GamePanel gp;\n    public int currentWave = 0;\n\n    public WaveManager(GamePanel gp){\n        this.gp = gp;\n    }\n\n    public void startWave(){\n        int numberOfZombies = 5 + currentWave*3;\n        gp.npc = new Entity[numberOfZombies];\n\n        Random rnd = new Random();\n        int minX = gp.tileSize * 3;\n        int maxX = gp.worldWidth - gp.tileSize*3;\n        int minY = gp.tileSize * 3;\n        int maxY = gp.worldHeight - gp.tileSize*3;\n\n        for (int i = 0; i < numberOfZombies; i++) {\n            int worldX = rnd.nextInt(maxX - minX) + minX;\n            int worldY = rnd.nextInt(maxY - minY) + minY;\n            \n            if (currentWave < 3) {\n                gp.npc[i] = new NormalZombie(gp);\n            } else if (currentWave < 6) {\n                if (rnd.nextBoolean()) {\n                    gp.npc[i] = new NormalZombie(gp);\n                } else {\n                    gp.npc[i] = new CrawlingZombie(gp); \n                }\n            } else if (currentWave < 9) {\n                if (rnd.nextInt(100) < 50) {\n                    gp.npc[i] = new CrawlingZombie(gp);\n                } else {\n                    gp.npc[i] = new TankZombie(gp); \n                }\n            } else {\n                int type = rnd.nextInt(100);\n                if (type < 40) {\n                    gp.npc[i] = new CrawlingZombie(gp);\n                } else if (type < 80) {\n                    gp.npc[i] = new TankZombie(gp);\n                } else {\n                    gp.npc[i] = new AcidZombie(gp); \n                }\n            }\n            \n            gp.npc[i].worldX = worldX;\n            gp.npc[i].worldY = worldY;\n        }\n        System.out.println(\"Dalga \" + currentWave + \" başladı. Zombi sayısı: \" + numberOfZombies);\n    }\n\n    public boolean isWaveFinished() {\n        for (int i = 0; i < gp.npc.length; i++) {\n            if (gp.npc[i] != null) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public void nextWave() {\n        if(currentWave >= 12) {\n            gp.gameState = gp.winState; \n            System.out.println(\"Tebrikler! Oyunu kazandınız. Dalga \" + currentWave + \" tamamlandı.\");\n            return;\n        }\n        \n        currentWave++;\n        Weapons newWeapon = null;\n        if (currentWave == 2) {\n            newWeapon = new Rifle(gp, gp.FPS);\n        }\n        else if (currentWave == 4) {\n            newWeapon = new Shotgun(gp, gp.FPS);\n        }\n        else if (currentWave == 6) {\n            newWeapon = new Sniper(gp, gp.FPS);\n        }\n        else if (currentWave == 11) {\n            newWeapon = new RocketLauncher(gp, gp.FPS);\n        }\n\n        if(newWeapon != null) {\n            gp.player.weaponInventory.add(newWeapon);\n            gp.player.currentWeapon = newWeapon;\n            gp.player.currentWeaponIndex = gp.player.weaponInventory.size() - 1;\n            gp.newWeaponMessage = \"New weapon: \" + newWeapon.getClass().getSimpleName();\n            gp.newWeaponMessageTimer = gp.FPS * 2; \n        }\n\n        gp.waveText = \"WAVE \" + currentWave;\n        gp.waveTextTime = gp.FPS * 2;\n\n        gp.player.resetPosition();\n        \n        // Yeni dalgayı başlat\n        startWave();\n    }\n}\n",
      "UtilityTool.java": "package main;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\n\npublic class UtilityTool {\n\n    public BufferedImage scaleImage(BufferedImage original, int width, int height){\n\n        BufferedImage scaledImage = new BufferedImage(width, height, original.getType());\n        Graphics2D g2 = scaledImage.createGraphics();\n        g2.drawImage(original, 0, 0, width, height, null);\n        g2.dispose();\n\n        return scaledImage;\n    }\n}\n",
      "GamePanel.java": "package main;\n\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.util.Collections;\nimport java.util.Comparator;\n\nimport javax.swing.JPanel;\n\nimport data.SaveLoad;\nimport entity.AcidBullet;\nimport entity.Bullet;\nimport entity.Entity;\nimport entity.Player;\nimport entity.RocketBullet;\nimport tile.TileManager;\nimport weapons.Gun;\n\npublic class GamePanel extends JPanel implements Runnable{\n\n    final int originalTileSize = 16;\n    final int scale = 3;\n\n    public final int tileSize = originalTileSize*scale;\n    public final int maxScreenCol = 16;\n    public final int maxScreenRow = 12;\n    public final int screenWidth = tileSize*maxScreenCol;\n    public final int screenHeight = tileSize*maxScreenRow;\n\n    //world settings\n    public final int maxWorldCol = 50;\n    public final int maxWorldRow = 50;\n    public final int worldWidth = tileSize * maxWorldCol;\n    public final int worldHeight = tileSize * maxWorldRow;\n\n    //for full screen\n    int screenWidth2 = screenWidth;\n    int screenHeight2 = screenHeight;\n    BufferedImage tempScreen;\n    Graphics2D g2;\n\n    public int FPS = 60; \n\n    TileManager tileM = new TileManager(this);\n    SaveLoad saveLoad = new SaveLoad(this);\n    KeyHandler keyH = new KeyHandler(this);\n\n    public String waveText = \"\";\n    public int waveTextTime = 0;\n    public String newWeaponMessage = \"\";\n    public int newWeaponMessageTimer = 0;\n    public WaveManager waveManager;\n\n    public CollisionChecker cChecker = new CollisionChecker(this);\n    public UI ui = new UI(this);\n\n    Thread gameThread;\n    public Player player = new Player(this, keyH);\n\n    public AssetSetter aSetter = new AssetSetter(this);\n\n    //npc \n    public int initialNpcArraySize = 10;\n    public Entity npc[] = new Entity[10];\n    ArrayList<Entity> entityList = new ArrayList<>();\n\n    //game state\n    public int gameState;\n    public final int titleState = 0;\n    public final int playState = 1;\n    public final int pauseState = 2;\n    public final int characterState = 3;\n    public final int gameOverState = 4;\n    public final int winState = 5;\n\n    //bullet\n    public ArrayList<Bullet> bulletList = new ArrayList<>();\n    public int mouseX, mouseY;\n\n    public ArrayList<AcidBullet> acidBulletList = new ArrayList<>();\n    public ArrayList<RocketBullet> rocketBulletList = new ArrayList<>();\n\n\n    public GamePanel(){\n        this.setPreferredSize(new Dimension(screenWidth, screenHeight));\n        this.setBackground(Color.black);\n        this.setDoubleBuffered(true);\n        this.addKeyListener(keyH);\n        waveManager = new WaveManager(this);\n        this.setFocusable(true);\n        this.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if(e.getButton() == MouseEvent.BUTTON1) { \n                    int mouseX = e.getX();\n                    int mouseY = e.getY();\n        \n                    int[] spawnPos = player.getGunTipPosition();\n\n                    int targetX = player.worldX + (mouseX - player.screenX);\n                    int targetY = player.worldY + (mouseY - player.screenY);\n\n                    player.gunAttack = true;\n\n                    ArrayList<Bullet> bullets = player.currentWeapon.attackToZombie(GamePanel.this, spawnPos[0], spawnPos[1], targetX, targetY);\n                    for(Bullet b : bullets) {\n                        bulletList.add(b);\n                    }\n                }\n            }\n        });\n\n    }\n\n    public void setUpGame(){\n\n        aSetter.setNPC();\n        gameState = titleState;\n        waveManager.nextWave();\n    }\n\n    public void resetGame(){\n        player.setDefaultValues();  \n        player.totalPoint = 0;\n\n        player.weaponInventory.clear();\n        player.weaponInventory.add(new Gun(this, FPS));\n        player.currentWeaponIndex = 0;\n        player.currentWeapon = player.weaponInventory.get(0);\n\n        waveManager.currentWave = 1;\n        waveText = \"WAVE \" + waveManager.currentWave;\n        waveTextTime = FPS * 3; \n\n        waveManager.startWave();\n        bulletList.clear();\n        acidBulletList.clear();\n    }\n\n    public void startGameThread(){\n\n        gameThread = new Thread(this);\n        gameThread.start();\n    }\n\n\n    @Override\n    public void run() {\n\n        double drawInterval = 1000000000/FPS;\n        double delta = 0;\n        long lastTime =System.nanoTime();\n        long currentTime;\n        \n        while(gameThread != null){ \n\n            currentTime = System.nanoTime();\n            \n            delta += (currentTime - lastTime) / drawInterval;\n            lastTime = currentTime;\n\n            if(delta >= 1){\n                update();\n                repaint();\n                delta--;\n            }\n            \n        }\n    }\n\n    public void update(){\n\n        if(gameState == playState){\n            //player\n            player.update();\n\n            if(waveTextTime <= 0){\n                for(int i = 0; i<npc.length; i++){\n                    if(npc[i] != null){\n                        npc[i].update();\n                    }\n                }\n            }\n            for (int i = bulletList.size() - 1; i >= 0; i--) {\n                Bullet b = bulletList.get(i);\n                b.update();\n                if(b.explosive){\n                    int bulletCenterX = b.worldX + b.bulletImage.getWidth() / 2;\n                    int bulletCenterY = b.worldY + b.bulletImage.getHeight() / 2;\n        \n                    for (int j = 0; j < npc.length; j++) {\n                        if (npc[j] != null) {\n                            int zombieCenterX = npc[j].worldX + npc[j].solidArea.x + npc[j].solidArea.width / 2;\n                            int zombieCenterY = npc[j].worldY + npc[j].solidArea.y + npc[j].solidArea.height / 2;\n                            \n                            double distance = Math.sqrt(Math.pow(bulletCenterX - zombieCenterX, 2) + Math.pow(bulletCenterY - zombieCenterY, 2));\n                            if (distance <= b.explosionRadius) {\n                                npc[j].life -= b.damage;\n                                if (npc[j].life <= 0) {\n                                    player.totalPoint += npc[j].point;\n                                    npc[j] = null;\n                                }\n                            }\n                        }\n                    }\n                    if(b.explosionTimer > 0) {\n                        b.explosionTimer--;\n                    } else {\n                        bulletList.remove(i);\n                    }\n                }\n                else{\n                    for (int j = 0; j < npc.length; j++) {\n                        if(npc[j] != null) {\n                            Rectangle npcRect = new Rectangle(\n                                npc[j].worldX + npc[j].solidArea.x,\n                                npc[j].worldY + npc[j].solidArea.y,\n                                npc[j].solidArea.width,\n                                npc[j].solidArea.height\n                            );\n                            if(b.getSolidArea().intersects(npcRect)) {\n                \n                                npc[j].life -= b.damage;\n                                if(npc[j].life <= 0) {\n                                    player.totalPoint += npc[j].point;\n                                    npc[j] = null; \n                                }\n    \n                                if(!b.piercing){\n                                    bulletList.remove(i);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                \n            }\n\n            for (int i = acidBulletList.size() - 1; i >= 0; i--) {\n                AcidBullet ab = acidBulletList.get(i);\n                ab.update();\n\n                java.awt.Rectangle acidRect = ab.getSolidArea();\n\n                java.awt.Rectangle playerRect = new java.awt.Rectangle(\n                    player.worldX + player.solidArea.x,\n                    player.worldY + player.solidArea.y,\n                    player.solidArea.width,\n                    player.solidArea.height\n                );\n                \n                if(acidRect.intersects(playerRect)) {\n                    if(!player.invincible) {\n                        player.life -= ab.damage;\n                        player.invincible = true; \n                    }\n                    acidBulletList.remove(i);\n                    continue;\n                }\n            }\n\n            for (int i = rocketBulletList.size() - 1; i >= 0; i--) {\n                RocketBullet rb = rocketBulletList.get(i);\n                rb.update();\n                if(rb.worldX < 0 || rb.worldX > worldWidth ||\n                   rb.worldY < 0 || rb.worldY > worldHeight) {\n                    rocketBulletList.remove(i);\n                    continue;\n                }\n            }\n\n            if(waveManager.isWaveFinished()){\n                waveManager.nextWave();\n            }\n\n        }\n        \n        if(gameState == pauseState){\n\n        }\n        \n        \n    }\n    \n\n    public void paintComponent(Graphics g){\n\n        super.paintComponent(g);\n\n        Graphics2D g2 = (Graphics2D)g;\n\n        //title screen\n        if(gameState == titleState){\n            ui.draw(g2);\n        }\n\n        //others\n        else{\n            //tile\n            tileM.draw(g2);\n\n            //add entities to the list\n            entityList.add(player);\n            \n            for(int i = 0; i<npc.length; i++){\n                if(npc[i] != null){\n                    entityList.add(npc[i]);\n                }\n            }\n\n            //sort\n            Collections.sort(entityList, new Comparator<Entity>() {\n\n                @Override\n                public int compare(Entity e1, Entity e2) {\n                    int result = Integer.compare(e1.worldY, e2.worldY);\n                    return result;\n                }\n                \n            });\n\n            //draw entities\n            for(int i = 0; i<entityList.size(); i++){\n               entityList.get(i).draw(g2); \n            }\n\n            //empty entity list\n            entityList.clear();\n\n            for(Bullet b: bulletList){\n                b.draw(g2);\n            }\n\n            for (AcidBullet ab : acidBulletList) {\n                ab.draw(g2);\n            }\n\n            for(RocketBullet rb : rocketBulletList) {\n                rb.draw(g2);\n            }\n\n            \n            //ui\n            ui.draw(g2);\n        }\n\n        g2.dispose();\n    }\n}",
      "UI.java": "package main;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport weapons.Weapons;\n\npublic class UI {\n    GamePanel gp;\n    Font arial;\n    Graphics2D g2;\n    public int commandNum = 0;\n\n    BufferedImage heartFull, heartHalf, heartEmpty;\n\n    public UI(GamePanel gp){\n        this.gp = gp;\n        arial = new Font(\"Arial\", Font.BOLD, 27);\n        loadHeartImages();\n    }\n\n    public void draw(Graphics2D g2){\n        this.g2 = g2;\n\n        g2.setFont(arial);\n        g2.setColor(Color.white);\n\n        //title state\n        if(gp.gameState == gp.titleState){\n            drawTitleScreen();\n        }\n        //play state\n        if(gp.gameState == gp.playState){\n            \n            drawPlayerLife();\n            drawGunAndRemainingBullet();\n            drawPoint();\n            drawWaveText();\n            drawNewWeaponMessage();\n        }\n        //pause state\n        if(gp.gameState == gp.pauseState){\n            drawPlayerLife();\n            drawPauseScreen();\n        }\n        //character state\n        if(gp.gameState == gp.characterState){\n            drawCharacterScreen();\n        }\n        //game over state\n        if(gp.gameState == gp.gameOverState){\n            drawGameOverScreen();\n        }\n        //win state\n        if(gp.gameState == gp.winState){\n            drawWinState();\n        }\n\n\n    }\n\n    public void drawGameOverScreen(){\n        g2.setColor(new Color(0,0,0,150));\n        g2.fillRect(0, 0, gp.screenWidth, gp.screenHeight);\n\n        int x ;\n        int y ;\n        String text;\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD, 90f));\n        text = \"Game Over\";\n\n        g2.setColor(Color.black);\n        x = getXforCenteredText(text);\n        y = gp.tileSize*5;\n        g2.drawString(text, x, y);\n\n        g2.setColor(Color.white);\n        g2.drawString(text, x-4, y-4);\n\n        //back to main menu\n        g2.setFont(g2.getFont().deriveFont(35f));\n        text = \"Main Menu\";\n        x = getXforCenteredText(text);\n        y += gp.tileSize*4;\n        g2.drawString(text, x, y);\n        if(commandNum == 0){\n            g2.drawString(\">\", x-40, y);\n        }\n\n        //exit\n        text = \"Exit\";\n        x = getXforCenteredText(text);\n        y += 55;\n        g2.drawString(text, x, y);\n        if(commandNum == 1){\n            g2.drawString(\">\", x-40, y);\n        }\n\n    }\n\n    public void drawWinState(){\n        g2.setColor(new Color(0,0,0,150));\n        g2.fillRect(0, 0, gp.screenWidth, gp.screenHeight);\n\n        int x ;\n        int y ;\n        String text;\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD, 90f));\n        text = \"YOU WIN!\";\n\n        g2.setColor(Color.yellow);\n        x = getXforCenteredText(text);\n        y = gp.tileSize*5;\n        g2.drawString(text, x, y);\n\n        g2.setColor(Color.white);\n        g2.drawString(text, x-4, y-4);\n\n        //back to main menu\n        g2.setFont(g2.getFont().deriveFont(35f));\n        text = \"Main Menu\";\n        x = getXforCenteredText(text);\n        y += gp.tileSize*4;\n        g2.drawString(text, x, y);\n        if(commandNum == 0){\n            g2.drawString(\">\", x-40, y);\n        }\n\n        //exit\n        text = \"Exit\";\n        x = getXforCenteredText(text);\n        y += 55;\n        g2.drawString(text, x, y);\n        if(commandNum == 1){\n            g2.drawString(\">\", x-40, y);\n        }\n    }\n\n    public void drawGunAndRemainingBullet(){\n        int x = 20;\n        int y = 40;\n\n        g2.setColor(Color.white);\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD, 25));\n\n        String weaponName = gp.player.currentWeapon.getClass().getSimpleName();\n        int remainingBullet = gp.player.currentWeapon.getRemainingBullet();\n\n        String text = \"Weapon: \" + weaponName + \" | Bullet: \" + remainingBullet;\n        g2.drawString(text, x, y);\n\n    }\n\n    public void drawPoint(){\n\n        String point = \"Total Point: \" + gp.player.totalPoint;\n        \n        int heartAreaX = gp.screenWidth - (gp.tileSize * (gp.player.maxLife / 2)) - gp.tileSize;\n        int x = heartAreaX;\n        int y = (gp.tileSize / 2) - 2; \n\n        g2.setColor(Color.white);\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD, 21));\n        g2.drawString(point, x, y);\n\n    }\n\n    public void drawPlayerLife(){\n        int x = gp.screenWidth - (gp.tileSize * (gp.player.maxLife / 2)) - gp.tileSize;  \n        int y = gp.tileSize/2;\n        int i=0;\n\n        //draw max life\n        while(i < gp.player.maxLife/2){\n            g2.drawImage(heartEmpty, x, y, null);\n            i++;\n            x += gp.tileSize;\n        }\n\n        //reset\n        x = gp.screenWidth - (gp.tileSize * (gp.player.maxLife / 2)) - gp.tileSize;  \n        y = gp.tileSize/2;\n        i=0;\n\n        //draw current life\n        while(i < gp.player.life){\n            g2.drawImage(heartHalf, x, y, null);\n            i++;\n            if(i < gp.player.life){\n                g2.drawImage(heartFull, x, y, null);\n            }\n            i++;\n            x += gp.tileSize;\n        }\n\n\n    }\n\n    public void loadHeartImages(){\n\n        heartFull = setup(\"/heart/full_heart\");\n        heartHalf = setup(\"/heart/half_heart\");\n        heartEmpty = setup(\"/heart/empty_heart\");\n\n    }\n\n    public BufferedImage setup(String imagePath){\n\n        UtilityTool uTool = new UtilityTool();\n        BufferedImage image = null;\n\n        try{\n            image = ImageIO.read(getClass().getResourceAsStream( imagePath +  \".png\"));\n            image = uTool.scaleImage(image, gp.tileSize, gp.tileSize);\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n\n        return image;\n    }\n\n    public void drawTitleScreen(){\n\n        g2.setColor(new Color(0,0,0));\n        g2.fillRect(0, 0, gp.screenWidth, gp.screenHeight);\n        //title name\n        g2.setFont(g2.getFont().deriveFont(Font.ITALIC, 70));\n        String text = \"Top-Down Shooter\";\n        int x = getXforCenteredText(text);\n        int y = gp.tileSize*3;\n\n        //shadow\n        g2.setColor(Color.gray);\n        g2.drawString(text, x+4, y+4);\n\n        //main color\n        g2.setColor(Color.white);\n        g2.drawString(text, x, y);\n\n        //zombie image\n        x = gp.screenWidth/2 - (gp.tileSize*2)/2;\n        y += gp.tileSize*2;\n        g2.drawImage(gp.player.down1, x, y, gp.tileSize*2, gp.tileSize*2, null);\n\n        //menu\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD, 36));\n\n        text = \"NEW GAME\";\n        x = getXforCenteredText(text);\n        y += gp.tileSize*3;\n        g2.drawString(text, x, y);\n        if(commandNum == 0){\n            g2.drawString(\">\", x - gp.tileSize, y);\n        }\n\n        text = \"LOAD GAME\";\n        x = getXforCenteredText(text);\n        y += gp.tileSize;\n        g2.drawString(text, x, y);\n        if(commandNum == 1){\n            g2.drawString(\">\", x - gp.tileSize, y);\n        }\n\n        text = \"QUIT\";\n        x = getXforCenteredText(text);\n        y += gp.tileSize;\n        g2.drawString(text, x, y);\n        if(commandNum == 2){\n            g2.drawString(\">\", x - gp.tileSize, y);\n        }\n\n\n    }\n\n    public void drawPauseScreen(){\n        Color c = new Color(0, 0, 0, 185);\n        g2.setColor(c);\n        g2.fillRect(0, 0, gp.screenWidth, gp.screenHeight);\n       \n        g2.setFont(g2.getFont().deriveFont(Font.BOLD, 70));\n        String text = \"PAUSED\";\n        int x = getXforCenteredText(text);\n        int y = gp.tileSize*3;\n\n        g2.setColor(Color.gray);\n        g2.drawString(text, x+4, y+4);\n\n        g2.setColor(Color.white);\n        g2.drawString(text, x, y);\n\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD, 36));\n\n        text = \"Resume\";\n        x = getXforCenteredText(text);\n        y += gp.tileSize*3;\n        g2.drawString(text, x, y);\n        if(commandNum == 0){\n            g2.drawString(\">\", x - gp.tileSize, y);\n        }\n\n        text = \"Save Game\";\n        x = getXforCenteredText(text);\n        y += gp.tileSize;\n        g2.drawString(text, x, y);\n        if(commandNum == 1){\n            g2.drawString(\">\", x - gp.tileSize, y);\n        }\n\n        text = \"Exit\";\n        x = getXforCenteredText(text);\n        y += gp.tileSize;\n        g2.drawString(text, x, y);\n        if(commandNum == 2){\n            g2.drawString(\">\", x - gp.tileSize, y);\n        }\n\n\n\n    }\n\n    public int getXforCenteredText(String text){\n\n        int length = (int)g2.getFontMetrics().getStringBounds(text, g2).getWidth();\n        int x = gp.screenWidth/2 - length/2;\n        return x;\n    }\n\n    public void drawWaveText(){\n        if(gp.waveTextTime > 0){\n            g2.setFont(g2.getFont().deriveFont(Font.BOLD, 70));\n            g2.setColor(new Color(204, 0, 3));\n\n\n            String text = gp.waveText;\n            int x = getXforCenteredText(text);\n            int y = gp.screenHeight / 3;\n\n            g2.drawString(text, x, y);\n            gp.waveTextTime--;\n        }\n    }\n\n    public void drawNewWeaponMessage(){\n        if(gp.newWeaponMessageTimer > 0) {\n          \n            g2.setFont(g2.getFont().deriveFont(Font.BOLD, 40f));\n            g2.setColor(Color.black);\n            \n            int x = getXforCenteredText(gp.newWeaponMessage);\n            int y = gp.tileSize + 50; \n            \n            g2.drawString(gp.newWeaponMessage, x, y);\n            gp.newWeaponMessageTimer--; \n        }\n    }\n\n    public void drawCharacterScreen() {\n        final int frameX = gp.tileSize;\n        final int frameY = gp.tileSize;\n        final int frameWidth = gp.tileSize * 7;\n        final int frameHeight = gp.tileSize * 10;\n        drawSubWindow(frameX, frameY, frameWidth, frameHeight);\n    \n        g2.setColor(Color.white);\n        g2.setFont(g2.getFont().deriveFont(20F));\n    \n        int textX = frameX + 20;\n        int textY = frameY + gp.tileSize;\n        final int lineHeight = 35;\n    \n        // Tail x (sağ hizalama için)\n        int tailX = (frameX + frameWidth) - 30;\n    \n        // 1) Wave\n        g2.drawString(\"Wave\", textX, textY);\n        String value = String.valueOf(gp.waveManager.currentWave);\n        int xAligned = getXforAlignToRightText(value, tailX);\n        g2.drawString(value, xAligned, textY);\n        textY += lineHeight;\n    \n        // 2) Life\n        g2.drawString(\"Life\", textX, textY);\n        value = String.valueOf(gp.player.life);\n        xAligned = getXforAlignToRightText(value, tailX);\n        g2.drawString(value, xAligned, textY);\n        textY += lineHeight;\n    \n        // 3) Weapon\n        g2.drawString(\"Weapon\", textX, textY);\n        value = gp.player.currentWeapon.getClass().getSimpleName();\n        xAligned = getXforAlignToRightText(value, tailX);\n        g2.drawString(value, xAligned, textY);\n        textY += lineHeight;\n    \n        // 4) Available Weapons\n        g2.drawString(\"Available Weapons\", textX, textY);\n        textY += lineHeight; \n        int weaponListX = textX + 20;\n    \n        for (Weapons w : gp.player.weaponInventory) {\n            String weaponName = w.getClass().getSimpleName();\n            g2.drawString(weaponName, weaponListX, textY);\n            textY += lineHeight;\n        }\n    \n        // 5) Total point\n        g2.drawString(\"Total point\", textX, textY);\n        value = String.valueOf(gp.player.totalPoint);\n        xAligned = getXforAlignToRightText(value, tailX);\n        g2.drawString(value, xAligned, textY);\n    }\n    \n\n\n    public void drawSubWindow(int x, int y, int widht, int height){\n        Color c = new Color(0, 0, 0, 210);\n        g2.setColor(c);\n        g2.fillRoundRect(x, y, widht, height, 35, 35);\n\n        c = new Color(255, 255, 255);\n        g2.setColor(c);\n        g2.setStroke(new BasicStroke(5));\n        g2.drawRoundRect(x+5, y+5, widht-10, height-10, 25, 25);\n\n    }\n\n    public int getXforAlignToRightText(String text, int tailX){\n\n        int length = (int)g2.getFontMetrics().getStringBounds(text, g2).getWidth();\n        int x = tailX - length;\n        return x;\n    }\n\n}\n",
      "AssetSetter.java": "package main;\n\nimport entity.CrawlingZombie;\nimport entity.NormalZombie;\nimport entity.AcidZombie;\n\npublic class AssetSetter {\n\n    GamePanel gp;\n\n    public AssetSetter(GamePanel gp){\n        this.gp = gp;\n    }\n\n\n    public void setNPC(){\n        gp.npc[0] = new NormalZombie(gp);\n        gp.npc[0].worldX = gp.tileSize*21;\n        gp.npc[0].worldY = gp.tileSize*21;\n\n        gp.npc[1] = new NormalZombie(gp);\n        gp.npc[1].worldX = gp.tileSize*11;\n        gp.npc[1].worldY = gp.tileSize*21;\n\n        gp.npc[2] = new NormalZombie(gp);\n        gp.npc[2].worldX = gp.tileSize*31;\n        gp.npc[2].worldY = gp.tileSize*21;\n        \n        gp.npc[3] = new CrawlingZombie(gp);\n        gp.npc[3].worldX = gp.tileSize*38;\n        gp.npc[3].worldY = gp.tileSize*21;\n\n        gp.npc[4] = new CrawlingZombie(gp);\n        gp.npc[4].worldX = gp.tileSize*43;\n        gp.npc[4].worldY = gp.tileSize*21;\n\n        gp.npc[5] = new AcidZombie(gp);\n        gp.npc[5].worldX = gp.tileSize*2;\n        gp.npc[5].worldY = gp.tileSize*21;\n\n        gp.npc[7] = new AcidZombie(gp);\n        gp.npc[7].worldX = gp.tileSize*25;\n        gp.npc[7].worldY = gp.tileSize*25;\n\n    }\n}\n",
      "KeyHandler.java": "package main;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\npublic class KeyHandler implements KeyListener{\n\n    GamePanel gp;\n    public boolean upPressed, downPressed, leftPressed, rightPressed, enterPressed, spacePressed;\n\n    public KeyHandler(GamePanel gp){\n        this.gp = gp;\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n    }\n\n    public boolean attackRequested = false;\n    @Override\n    public void keyPressed(KeyEvent e) {\n        \n        int code = e.getKeyCode(); // getKeyCode returns the number of the key that was pressed\n\n        //title state\n        if(gp.gameState == gp.titleState){\n            if(code == KeyEvent.VK_W){\n                gp.ui.commandNum--;\n                if(gp.ui.commandNum < 0){\n                    gp.ui.commandNum = 2;\n                }\n            }\n            if(code == KeyEvent.VK_S){\n                gp.ui.commandNum++;\n                if(gp.ui.commandNum > 2){\n                    gp.ui.commandNum = 0;\n                }\n            }\n            if(code == KeyEvent.VK_ENTER){\n                if(gp.ui.commandNum == 0){\n\n                    gp.resetGame();\n                    gp.gameState = gp.playState;\n                }\n                if(gp.ui.commandNum == 1){\n                    gp.saveLoad.load();\n                    gp.gameState = gp.playState;\n                    \n                }\n                if(gp.ui.commandNum == 2){\n                    System.exit(0);\n                }\n            }\n        }\n        \n        //play state\n        else if(gp.gameState == gp.playState){\n\n            if(code == KeyEvent.VK_W){\n                upPressed = true;\n            }\n            if(code == KeyEvent.VK_A){\n                leftPressed = true;\n            }\n            if(code == KeyEvent.VK_S){\n                downPressed = true;\n            }\n            if(code == KeyEvent.VK_D){\n                rightPressed = true;\n            }\n            if(code == KeyEvent.VK_P){\n                gp.gameState = gp.pauseState;\n            }\n            if(code == KeyEvent.VK_SPACE){\n                spacePressed = true;\n                attackRequested = true;\n            }\n            if(code == KeyEvent.VK_R){\n                gp.player.currentWeapon.reloadMagazine();\n            }\n            if(code == KeyEvent.VK_Q){\n                gp.player.previousWeapon();\n            }\n            if(code == KeyEvent.VK_E){\n                gp.player.nextWeapon();\n            }\n            if(code == KeyEvent.VK_C){\n                gp.gameState = gp.characterState;\n            }\n        }\n        \n\n        //pause state\n        else if(gp.gameState == gp.pauseState){\n            if(code == KeyEvent.VK_P){\n                gp.gameState = gp.playState;\n            }\n            if(code == KeyEvent.VK_W){\n                gp.ui.commandNum--;\n                if(gp.ui.commandNum < 0){\n                    gp.ui.commandNum = 2;\n                }\n            }\n            if(code == KeyEvent.VK_S){\n                gp.ui.commandNum++;\n                if(gp.ui.commandNum > 2){\n                    gp.ui.commandNum = 0;\n                }\n            }\n            if(code == KeyEvent.VK_ENTER){\n                if(gp.ui.commandNum == 0){\n                    gp.gameState = gp.playState;\n                } \n                else if(gp.ui.commandNum == 1){\n                    gp.saveLoad.save();\n                }\n                else if(gp.ui.commandNum == 2){\n                    System.exit(0);\n                }\n            }\n        }\n\n        //character state\n        else if(gp.gameState == gp.characterState){\n            if(code == KeyEvent.VK_C){\n                gp.gameState = gp.playState; \n            }\n        }\n\n        //game over state\n        else if(gp.gameState == gp.gameOverState){\n            if(code == KeyEvent.VK_W){\n                gp.ui.commandNum--;\n                if(gp.ui.commandNum < 0){\n                    gp.ui.commandNum = 1;\n                }\n            }\n            if(code == KeyEvent.VK_S){\n                gp.ui.commandNum++;\n                if(gp.ui.commandNum < 1){\n                    gp.ui.commandNum = 0;\n                }\n            }\n            if(code == KeyEvent.VK_ENTER){\n                if(gp.ui.commandNum == 0){\n                    gp.gameState = gp.titleState;\n                } \n                else if(gp.ui.commandNum == 1){\n                    System.exit(0);\n                }\n            }\n        }\n\n        //game win state\n        else if(gp.gameState == gp.winState){\n            if(code == KeyEvent.VK_W){\n                gp.ui.commandNum--;\n                if(gp.ui.commandNum < 0){\n                    gp.ui.commandNum = 1;\n                }\n            }\n            if(code == KeyEvent.VK_S){\n                gp.ui.commandNum++;\n                if(gp.ui.commandNum < 1){\n                    gp.ui.commandNum = 0;\n                }\n            }\n            if(code == KeyEvent.VK_ENTER){\n                if(gp.ui.commandNum == 0){\n                    gp.gameState = gp.titleState;\n                } \n                else if(gp.ui.commandNum == 1){\n                    System.exit(0);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        \n        int code = e.getKeyCode();\n\n        if(code == KeyEvent.VK_W){\n            upPressed = false;\n        }\n        if(code == KeyEvent.VK_A){\n            leftPressed = false;\n        }\n        if(code == KeyEvent.VK_S){\n            downPressed = false;\n        }\n        if(code == KeyEvent.VK_D){\n            rightPressed = false;\n        }\n        if(code == KeyEvent.VK_ENTER){\n            enterPressed = false;\n        }\n        if(code == KeyEvent.VK_SPACE){\n            spacePressed = false;\n        }\n    }\n\n}\n",
      "Game.java": "package main;\n\nimport javax.swing.JFrame;\n\npublic class Game {\n    public static void main(String[] args) {\n        \n        JFrame window = new JFrame();\n        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        window.setResizable(false);\n        window.setTitle(\"Top_Down_Shooter\");\n\n        GamePanel gamePanel = new GamePanel();\n        window.add(gamePanel);\n\n        window.pack();\n\n        window.setLocationRelativeTo(null);\n        window.setVisible(true);\n\n        gamePanel.setUpGame();\n        gamePanel.startGameThread();\n\n    }\n}\n",
      "CollisionChecker.java": "package main;\n\nimport entity.Entity;\n\npublic class CollisionChecker {\n\n    GamePanel gp;\n\n    public CollisionChecker(GamePanel gp){\n        this.gp = gp;\n    }\n\n    public void checkTile(Entity entity){\n\n        int entityLeftWorldX = entity.worldX + entity.solidArea.x;\n        int entityRightWorldX = entity.worldX + entity.solidArea.x + entity.solidArea.width;\n        int entityTopWorldY = entity.worldY + entity.solidArea.y;\n        int entityBottomWorldY = entity.worldY + entity.solidArea.y + entity.solidArea.height;\n\n        int entityLeftCol = entityLeftWorldX/gp.tileSize;\n        int entityRightCol = entityRightWorldX/gp.tileSize;\n        int entityTopRow = entityTopWorldY/gp.tileSize;\n        int entityBottomRow = entityBottomWorldY/gp.tileSize;\n\n        int tileNum1; \n        int tileNum2;\n\n        if(entityLeftCol < 0 || entityRightCol >= gp.maxWorldCol ||\n            entityTopRow < 0 || entityBottomRow >= gp.maxWorldRow){\n           entity.collisionOn = true;\n           return;\n        }\n        \n\n        switch(entity.direction){\n            case \"up\":\n                entityTopRow = (entityTopWorldY - entity.speed)/gp.tileSize;\n                tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];\n                tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];\n                if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true){\n                     entity.collisionOn = true;   \n                }\n                break;\n            case \"down\":\n                entityBottomRow = (entityBottomWorldY + entity.speed)/gp.tileSize;\n                tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];\n                tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];\n                if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true){\n                    entity.collisionOn = true;   \n                }\n                break;\n            case \"left\":\n                entityLeftCol = (entityLeftWorldX - entity.speed)/gp.tileSize;\n                tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];\n                tileNum2 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];\n                if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true){\n                     entity.collisionOn = true;   \n                }\n                break;\n            case \"right\":\n                entityRightCol = (entityRightWorldX + entity.speed)/gp.tileSize;\n                tileNum1 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];\n                tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];\n                if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true){\n                     entity.collisionOn = true;   \n                }\n                break;\n            \n            \n\n        }\n    }\n\n    public int checkEntity(Entity entity, Entity[] target){\n\n        int index = 999;\n\n        for(int i= 0; i < target.length; i++){\n\n            if(target[i] != null){\n                entity.solidArea.x = entity.worldX + entity.solidArea.x;\n                entity.solidArea.y = entity.worldY + entity.solidArea.y;\n                target[i].solidArea.x = target[i].worldX + target[i].solidArea.x;\n                target[i].solidArea.y = target[i].worldY + target[i].solidArea.y;\n\n                switch(entity.direction){\n                case \"up\":\n                    entity.solidArea.y -= entity.speed;\n                    break;\n                case \"down\":\n                    entity.solidArea.y += entity.speed;\n                    break;\n                case \"left\":\n                    entity.solidArea.x -= entity.speed;\n                    break;\n                case \"right\":\n                    entity.solidArea.x += entity.speed;\n                    break;\n                }\n                if(entity.solidArea.intersects(target[i].solidArea)){\n                    if(target[i] != entity){\n                        entity.collisionOn = true;\n                        index = i;\n                    }\n                }\n\n                entity.solidArea.x = entity.solidAreaDefaultX;\n                entity.solidArea.y = entity.solidAreaDefaultY;\n                target[i].solidArea.x = target[i].solidAreaDefaultX;\n                target[i].solidArea.y = target[i].solidAreaDefaultY;\n            }\n        }\n\n        return index;\n    }\n\n    public boolean checkPlayer(Entity entity){\n\n        boolean contactPlayer = false;\n        entity.solidArea.x = entity.worldX + entity.solidArea.x;\n        entity.solidArea.y = entity.worldY + entity.solidArea.y;\n        gp.player.solidArea.x = gp.player.worldX + gp.player.solidArea.x;\n        gp.player.solidArea.y = gp.player.worldY + gp.player.solidArea.y;\n\n        switch(entity.direction){\n        case \"up\":\n            entity.solidArea.y -= entity.speed;\n            break;\n        case \"down\":\n            entity.solidArea.y += entity.speed;\n            break;\n        case \"left\":\n            entity.solidArea.x -= entity.speed;\n            break;\n        case \"right\":\n            entity.solidArea.x += entity.speed;\n            break;\n        }\n        \n        if(entity.solidArea.intersects(gp.player.solidArea)){\n            entity.collisionOn = true;\n            contactPlayer = true;\n        }\n\n        entity.solidArea.x = entity.solidAreaDefaultX;\n        entity.solidArea.y = entity.solidAreaDefaultY;\n        gp.player.solidArea.x = gp.player.solidAreaDefaultX;\n        gp.player.solidArea.y = gp.player.solidAreaDefaultY;\n\n        return contactPlayer;\n    }\n}\n",
      "Sniper.java": "package weapons;\n\nimport java.util.ArrayList;\n\nimport entity.Bullet;\nimport main.GamePanel;\n\npublic class Sniper extends Weapons {\n\n    public Sniper(GamePanel gp, int fps) {\n        super(gp, 5, 30, fps);\n        getWeaponImage();\n    }\n\n    public void getWeaponImage(){\n        weaponUp1 = setup(\"/player/boy_sniper_up\", gp.tileSize, gp.tileSize*2);\n        weaponUp2 = setup(\"/player/boy_sniper_up\", gp.tileSize, gp.tileSize*2);\n        weaponDown1 = setup(\"/player/boy_sniper_down\", gp.tileSize, gp.tileSize*2);\n        weaponDown2 = setup(\"/player/boy_sniper_down\", gp.tileSize, gp.tileSize*2);\n        weaponLeft1 = setup(\"/player/boy_sniper_left\", gp.tileSize*2, gp.tileSize);\n        weaponLeft2 = setup(\"/player/boy_sniper_left\", gp.tileSize*2, gp.tileSize);\n        weaponRight1 = setup(\"/player/boy_sniper_right\", gp.tileSize*2, gp.tileSize);\n        weaponRight2 = setup(\"/player/boy_sniper_right\", gp.tileSize*2, gp.tileSize);\n    }\n\n     public ArrayList<Bullet> attackToZombie(GamePanel gp, int startX, int startY, int targetX, int targetY) {\n        ArrayList<Bullet> firedBullets = new ArrayList<>();\n        \n        if(!canFire()){\n            return firedBullets;\n        }\n        \n       \n        remainingBulletNum--;\n        currentCooldown = cooldownFrames;\n        \n        Bullet newBullet = new Bullet(gp, startX, startY, targetX, targetY);\n        newBullet.damage = 1;\n        newBullet.piercing = true; \n        \n        firedBullets.add(newBullet);\n        return firedBullets;\n    }\n\n\n\n\n}\n",
      "Gun.java": "package weapons;\n\nimport java.util.ArrayList;\nimport entity.Bullet;\nimport main.GamePanel;\n\npublic class Gun extends Weapons{\n\n    public Gun(GamePanel gp, int fps){\n        super(gp, 12, 120, fps);\n\n        getWeaponImage();\n    }\n\n    public void getWeaponImage(){\n        weaponUp1 = setup(\"/player/boy_gun_up1\", gp.tileSize, gp.tileSize*2);\n        weaponUp2 = setup(\"/player/boy_gun_up2\", gp.tileSize, gp.tileSize*2);\n        weaponDown1 = setup(\"/player/boy_gun_down1\", gp.tileSize, gp.tileSize*2);\n        weaponDown2 = setup(\"/player/boy_gun_down2\", gp.tileSize, gp.tileSize*2);\n        weaponLeft1 = setup(\"/player/boy_gun_left1\", gp.tileSize*2, gp.tileSize);\n        weaponLeft2 = setup(\"/player/boy_gun_left2\", gp.tileSize*2, gp.tileSize);\n        weaponRight1 = setup(\"/player/boy_gun_right1\", gp.tileSize*2, gp.tileSize);\n        weaponRight2 = setup(\"/player/boy_gun_right2\", gp.tileSize*2, gp.tileSize);\n    }\n\n    public ArrayList<Bullet> attackToZombie(GamePanel gp, int startX, int startY, int targetX, int targetY){\n        \n        ArrayList<Bullet> firedBullets = new ArrayList<>();\n\n        if(!canFire()){\n            return firedBullets;\n        }\n\n        remainingBulletNum--;\n\n        currentCooldown = cooldownFrames;\n\n        Bullet newBullet = new Bullet(gp, startX, startY, targetX, targetY);\n        firedBullets.add(newBullet);\n\n        return firedBullets;\n    }\n}\n",
      "Shotgun.java": "package weapons;\n\nimport java.util.ArrayList;\n\nimport entity.Bullet;\nimport main.GamePanel;\n\npublic class Shotgun extends Weapons{\n    public Shotgun(GamePanel gp, int fps){\n        super(gp,5, 60, fps);\n\n        getWeaponImage();\n    }\n\n    public void getWeaponImage(){\n        weaponUp1 = setup(\"/player/boy_shotgun_up\", gp.tileSize, gp.tileSize*2);\n        weaponUp2 = setup(\"/player/boy_shotgun_up\", gp.tileSize, gp.tileSize*2);\n        weaponDown1 = setup(\"/player/boy_shotgun_down\", gp.tileSize, gp.tileSize*2);\n        weaponDown2 = setup(\"/player/boy_shotgun_down\", gp.tileSize, gp.tileSize*2);\n        weaponLeft1 = setup(\"/player/boy_shotgun_left\", gp.tileSize*2, gp.tileSize);\n        weaponLeft2 = setup(\"/player/boy_shotgun_left\", gp.tileSize*2, gp.tileSize);\n        weaponRight1 = setup(\"/player/boy_shotgun_right\", gp.tileSize*2, gp.tileSize);\n        weaponRight2 = setup(\"/player/boy_shotgun_right\", gp.tileSize*2, gp.tileSize);\n    }\n\n    public ArrayList<Bullet> attackToZombie(GamePanel gp, int startX, int startY, int targetX, int targetY){\n        \n        ArrayList<Bullet> firedBullets = new ArrayList<>();\n\n        if(!canFire()){\n            return firedBullets;\n        }\n\n        int pelletCount = 9;\n        double diffX = targetX - startX;\n        double diffY = targetY - startY;\n        double baseAngle = Math.atan2(diffY, diffX);\n        int midIndex = pelletCount / 2;\n\n        for (int i = 0; i < pelletCount; i++) {\n            double angleOffset = (i - midIndex) * 5.0;\n            double finalAngle = baseAngle + Math.toRadians(angleOffset);\n            int newTargetX = startX + (int)(Math.cos(finalAngle) * 1000);\n            int newTargetY = startY + (int)(Math.sin(finalAngle) * 1000);\n            \n            Bullet newBullet = new Bullet(gp, startX, startY, newTargetX, newTargetY);\n            firedBullets.add(newBullet);\n        }\n\n        remainingBulletNum--;\n        System.out.println(\"Kalan mermi: \" + remainingBulletNum);\n        currentCooldown = cooldownFrames;\n\n        return firedBullets;\n    }\n}\n\n",
      "Weapons.java": "package weapons;\n\nimport java.util.ArrayList;\n\nimport javax.imageio.ImageIO;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport entity.Bullet;\nimport main.GamePanel;\nimport main.UtilityTool;\n\npublic abstract class Weapons {\n\n    GamePanel gp;\n    public int magazineCapacity;\n    public int remainingBulletNum;\n    public int fireRate;\n    public int cooldownFrames;\n    public int currentCooldown = 0;\n    public int fps;\n    public BufferedImage weaponUp1, weaponUp2, weaponDown1, weaponDown2, weaponLeft1, weaponLeft2, weaponRight1, weaponRight2;\n\n    public Weapons(GamePanel gp, int magazineCapacity, int fireRate, int fps){\n        this.gp = gp;\n        this.magazineCapacity = magazineCapacity;\n        this.remainingBulletNum = magazineCapacity;\n        this.fireRate = fireRate;\n        this.fps = fps;\n        this.cooldownFrames = (fps * 60) / fireRate;\n    }\n\n    public void cooldownUpdate() {\n        if (currentCooldown > 0) {\n            currentCooldown--;\n        }\n    }\n\n    public boolean canFire(){\n        if(currentCooldown == 0 && remainingBulletNum > 0){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\n    public BufferedImage setup(String imagePath, int widht, int height){\n\n        UtilityTool uTool = new UtilityTool();\n        BufferedImage image = null;\n\n        try{\n            image = ImageIO.read(getClass().getResourceAsStream( imagePath +  \".png\"));\n            image = uTool.scaleImage(image, widht, height);\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n\n        return image;\n    }\n\n    public abstract void getWeaponImage();\n\n    public abstract ArrayList<Bullet> attackToZombie(GamePanel gp, int startX, int startY, int targetX, int targetY);\n\n    public void reloadMagazine(){\n        remainingBulletNum = magazineCapacity;\n    }\n\n    public int getMagazineCapacity(){\n        return magazineCapacity;\n    }\n\n    public int getRemainingBullet(){\n        return remainingBulletNum;\n    }\n\n    public String toString(){\n        return getClass().getSimpleName();\n    }\n\n}\n",
      "Rifle.java": "package weapons;\n\nimport java.util.ArrayList;\nimport java.util.Random;\n\nimport entity.Bullet;\nimport main.GamePanel;\n\npublic class Rifle extends Weapons {\n\n    public Rifle(GamePanel gp, int fps) {\n        super(gp, 30, 600, fps);\n        getWeaponImage();\n    }\n\n    public void getWeaponImage(){\n        weaponUp1 = setup(\"/player/boy_rifle_up\", gp.tileSize, gp.tileSize*2);\n        weaponUp2 = setup(\"/player/boy_rifle_up\", gp.tileSize, gp.tileSize*2);\n        weaponDown1 = setup(\"/player/boy_rifle_down\", gp.tileSize, gp.tileSize*2);\n        weaponDown2 = setup(\"/player/boy_rifle_down\", gp.tileSize, gp.tileSize*2);\n        weaponLeft1 = setup(\"/player/boy_rifle_left\", gp.tileSize*2, gp.tileSize);\n        weaponLeft2 = setup(\"/player/boy_rifle_left\", gp.tileSize*2, gp.tileSize);\n        weaponRight1 = setup(\"/player/boy_rifle_right\", gp.tileSize*2, gp.tileSize);\n        weaponRight2 = setup(\"/player/boy_rifle_right\", gp.tileSize*2, gp.tileSize);\n    }\n\n    public ArrayList<Bullet> attackToZombie(GamePanel gp, int startX, int startY, int targetX, int targetY) {\n        ArrayList<Bullet> firedBullets = new ArrayList<>();\n        \n        if(!canFire()){\n            return firedBullets;\n        }\n        \n        remainingBulletNum--;\n        currentCooldown = cooldownFrames;\n   \n        double diffX = targetX - startX;\n        double diffY = targetY - startY;\n        double baseAngle = Math.atan2(diffY, diffX);\n        \n        Random rand = new Random();\n        int deviationDegrees = rand.nextInt(61) - 30; \n        double finalAngle = baseAngle + Math.toRadians(deviationDegrees);\n    \n        int newTargetX = startX + (int)(Math.cos(finalAngle) * 1000);\n        int newTargetY = startY + (int)(Math.sin(finalAngle) * 1000);\n        \n        Bullet newBullet = new Bullet(gp, startX, startY, newTargetX, newTargetY);\n        firedBullets.add(newBullet);\n        \n        return firedBullets;\n    }\n\n    \n}\n",
      "RocketLauncher.java": "package weapons;\n\nimport java.util.ArrayList;\n\nimport entity.Bullet;\nimport entity.RocketBullet;\nimport main.GamePanel;\n\npublic class RocketLauncher extends Weapons{\n\n    public RocketLauncher(GamePanel gp, int fps) {\n        super(gp, 1, 10, fps);  // Şarjör kapasitesi: 1, Ateş hızı: 10 roket/dakika\n        getWeaponImage();\n    }\n\n    public void getWeaponImage(){\n        weaponUp1 = setup(\"/player/boy_rocket_up\", gp.tileSize, gp.tileSize*2);\n        weaponUp2 = setup(\"/player/boy_rocket_up\", gp.tileSize, gp.tileSize*2);\n        weaponDown1 = setup(\"/player/boy_rocket_down\", gp.tileSize, gp.tileSize*2);\n        weaponDown2 = setup(\"/player/boy_rocket_down\", gp.tileSize, gp.tileSize*2);\n        weaponLeft1 = setup(\"/player/boy_rocket_left\", gp.tileSize*2, gp.tileSize);\n        weaponLeft2 = setup(\"/player/boy_rocket_left\", gp.tileSize*2, gp.tileSize);\n        weaponRight1 = setup(\"/player/boy_rocket_right\", gp.tileSize*2, gp.tileSize);\n        weaponRight2 = setup(\"/player/boy_rocket_right\", gp.tileSize*2, gp.tileSize);\n    }\n\n    public ArrayList<Bullet> attackToZombie(GamePanel gp, int startX, int startY, int targetX, int targetY) {\n        ArrayList<Bullet> firedBullets = new ArrayList<>();\n        \n        if (!canFire()) {\n            return firedBullets;\n        }\n        \n        remainingBulletNum--;\n        currentCooldown = cooldownFrames;\n        \n        RocketBullet rocketBullet = new RocketBullet(gp, startX, startY, targetX, targetY);\n        rocketBullet.damage = 4;\n\n        firedBullets.add(rocketBullet);\n        System.out.println(\"Rocket fired. Remaining rockets: \" + remainingBulletNum);\n        \n        return firedBullets;\n    }\n}\n",
      "DataStorage.java": "package data;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\n\npublic class DataStorage implements Serializable {\n\n    public int maxLife;\n    public int life;\n    public int currentWave;\n    public int point;\n    \n    public int worldX;\n    public int worldY;\n    ArrayList<String> weaponNames = new ArrayList<>();\n    \n    \n}\n",
      "SaveLoad.java": "package data;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport main.GamePanel;\nimport weapons.Gun;\nimport weapons.RocketLauncher;\nimport weapons.Shotgun;\nimport weapons.Sniper;\nimport weapons.Rifle;\nimport weapons.Weapons;\n\npublic class SaveLoad {\n\n    GamePanel gp;\n\n    public SaveLoad(GamePanel gp){\n        this.gp = gp;\n    }\n\n    public Weapons getObject(String weaponName){\n        Weapons obj = null;\n        switch(weaponName){\n        case \"Gun\" : obj = new Gun(gp, gp.FPS); break;\n        case \"Rifle\" : obj = new Rifle(gp, gp.FPS); break;\n        case \"Shotgun\" : obj = new Shotgun(gp, gp.FPS); break;\n        case \"Sniper\" : obj = new Sniper(gp, gp.FPS); break;\n        case \"RocketLauncher\" : obj = new RocketLauncher(gp, gp.FPS); break;\n        }\n\n        return obj;\n    }\n\n    public void save(){\n        try{\n            File file = new File(\"save.dat\");\n            if(!file.exists()){\n                // Dosya mevcut değilse oluşturur\n                file.createNewFile();\n            }\n            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(\"save.dat\")));\n            DataStorage ds = new DataStorage();\n\n            ds.maxLife = gp.player.maxLife;\n            ds.life = gp.player.life;\n            ds.currentWave = gp.waveManager.currentWave;\n            ds.point = gp.player.totalPoint;\n            ds.worldX = gp.player.worldX;\n            ds.worldY = gp.player.worldY;\n\n            for(int i = 0; i < gp.player.weaponInventory.size(); i++){\n                ds.weaponNames.add(gp.player.weaponInventory.get(i).getClass().getSimpleName());\n            }\n\n            oos.writeObject(ds);\n            oos.close();\n        }\n        catch(Exception e){\n            System.out.println(\"save exception\");\n            e.printStackTrace();\n        }\n        \n    }\n\n    public void load(){\n\n        try{\n            System.out.println(\"Load işlemi başlatıldı.\");\n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\"save.dat\")));\n            DataStorage ds = (DataStorage)ois.readObject();\n            ois.close();\n\n            gp.player.maxLife = ds.maxLife;\n            gp.player.life = ds.life;\n            gp.waveManager.currentWave = ds.currentWave;\n            gp.waveText = \"WAVE \" + ds.currentWave;\n            gp.player.totalPoint = ds.point;\n            gp.player.worldX = ds.worldX;\n            gp.player.worldY = ds.worldY;\n\n            gp.player.weaponInventory.clear();\n            for(int i = 0; i < ds.weaponNames.size(); i++){\n                gp.player.weaponInventory.add(getObject(ds.weaponNames.get(i)));\n\n            }\n\n        }\n        catch(Exception e){\n            System.out.println(\"load exception\");\n            e.printStackTrace();\n        }\n    }\n}\n",
      "Tile.java": "package tile;\n\nimport java.awt.image.BufferedImage;\n\npublic class Tile {\n\n    public BufferedImage image;\n    public boolean collision = false;\n}\n",
      "TileManager.java": "package tile;\n\nimport java.awt.Graphics2D;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\nimport javax.imageio.ImageIO;\n\nimport main.GamePanel;\nimport main.UtilityTool;\n\npublic class TileManager {\n\n    GamePanel gp;\n    public Tile[] tile;\n    public int mapTileNum[][];\n\n    public TileManager(GamePanel gp){\n        this.gp = gp;\n        tile = new Tile[10];\n        mapTileNum = new int[gp.maxWorldCol][gp.maxWorldRow];\n\n        getTileImage();\n        loadMap(\"/maps/map.txt\");\n    }\n\n    public void getTileImage(){\n\n        setup(0, \"ground\", false);\n        setup(1, \"grass\", true);\n        setup(2, \"stone\", false);\n        setup(3, \"tree\", true);\n        setup(4, \"tree2\", true);\n        setup(5, \"light_left\", true);\n        setup(6, \"light_right\", true);\n    }\n\n    public void setup(int index, String imageName, boolean collision){\n\n        UtilityTool uTool = new UtilityTool();\n\n        try{\n            tile[index] = new Tile();\n            tile[index].image = ImageIO.read(getClass().getResourceAsStream(\"/tiles/\"  + imageName + \".png\"));\n            tile[index].image = uTool.scaleImage(tile[index].image, gp.tileSize, gp.tileSize);\n            tile[index].collision = collision;\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n\n    public void loadMap(String filePath){\n\n        try{\n            InputStream is = getClass().getResourceAsStream(filePath);\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n\n            int col = 0;\n            int row = 0;\n\n            while(col < gp.maxWorldCol && row < gp.maxWorldRow ){\n                String line = br.readLine();\n\n                while(col < gp.maxWorldCol){\n                    String numbers[] = line.split(\" \");\n                    int num = Integer.parseInt(numbers[col]);\n                    mapTileNum[col][row] = num;\n                    col++;\n                }\n                if(col == gp.maxWorldCol){\n                    col = 0;\n                    row++;\n                }\n            }\n\n            br.close();\n        }\n        catch(Exception e){\n            \n        }\n    }\n\n    public void draw(Graphics2D g2){\n\n        int worldCol = 0;\n        int worldRow= 0;\n       \n\n        while(worldCol < gp.maxWorldCol && worldRow < gp.maxWorldRow){\n\n            int tileNum = mapTileNum[worldCol][worldRow];\n\n            int worldX = worldCol * gp.tileSize;\n            int worldY = worldRow * gp.tileSize;\n            int screenX = worldX - gp.player.worldX + gp.player.screenX;\n            int screenY = worldY - gp.player.worldY + gp.player.screenY;\n\n            if(worldX  + gp.tileSize > gp.player.worldX - gp.player.screenX &&\n               worldX - gp.tileSize < gp.player.worldX + gp.player.screenX &&\n               worldY + gp.tileSize > gp.player.worldY - gp.player.screenY && \n               worldY - gp.tileSize < gp.player.worldY + gp.player.screenY ){\n\n                g2.drawImage(tile[tileNum].image, screenX, screenY, null);\n            }\n            \n            worldCol++;\n            \n\n            if(worldCol == gp.maxWorldCol){\n                worldCol = 0;\n                \n                worldRow++;\n                \n            }\n        }\n    }\n}\n"
    },
    {
      "id": "5628146",
      "Menu.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Menu {\n    private Game game;\n    private List<MenuButton> menuButtons = new ArrayList<>();\n    private boolean isMainMenu;\n    private BufferedImage backgroundImage;\n    \n    public Menu(Game game, boolean isMainMenu) {\n        this.game = game;\n        this.isMainMenu = isMainMenu;\n        backgroundImage = ImageCache.getImage(\"MenuBackground.png\");  \n        createButtons();\n        for (MenuButton button : menuButtons) {\n            button.tick();\n        }\n    }\n    \n    private void createButtons() {\n        int buttonWidth = 300;\n        int buttonHeight = 64;\n        int startY = Game.HEIGHT / 2 - 150;\n        int spacing = 80;\n        \n        if (isMainMenu) {\n            menuButtons.add(new MenuButton(\"Start\", Game.WIDTH / 2 - buttonWidth / 2, startY, buttonWidth, buttonHeight, \n                () -> game.startGame()));\n            \n            menuButtons.add(new MenuButton(\"Load Game\", Game.WIDTH / 2 - buttonWidth / 2, startY + spacing, buttonWidth, buttonHeight,\n                () -> game.loadGame()));\n                \n            menuButtons.add(new MenuButton(\"Quit\", Game.WIDTH / 2 - buttonWidth / 2, startY + spacing * 2, buttonWidth, buttonHeight,\n                () -> System.exit(0)));\n        } else {\n            menuButtons.add(new MenuButton(\"Resume\", Game.WIDTH / 2 - buttonWidth / 2, startY, buttonWidth, buttonHeight,\n                () -> game.resumeGame()));\n                \n            menuButtons.add(new MenuButton(\"Restart\", Game.WIDTH / 2 - buttonWidth / 2, startY + spacing, buttonWidth, buttonHeight,\n                () -> game.restartGame()));\n                \n            menuButtons.add(new MenuButton(\"Save Game\", Game.WIDTH / 2 - buttonWidth / 2, startY + spacing * 2, buttonWidth, buttonHeight,\n                () -> game.saveGame()));\n                \n            menuButtons.add(new MenuButton(\"Load Game\", Game.WIDTH / 2 - buttonWidth / 2, startY + spacing * 3, buttonWidth, buttonHeight,\n                () -> game.loadGame()));\n                \n            menuButtons.add(new MenuButton(\"Quit\", Game.WIDTH / 2 - buttonWidth / 2, startY + spacing * 4, buttonWidth, buttonHeight,\n                () -> System.exit(0)));\n        }\n    }\n    public void tick() {\n        if (game.getGameState() == GameState.MENU || game.getGameState() == GameState.PAUSED || game.getGameState() == GameState.GAME_OVER){ \n            for (MenuButton button : menuButtons) {\n                button.tick();\n            }\n        }\n    }\n    \n    \n    public void render(Graphics g) {\n    \t if (backgroundImage != null) {\n             g.drawImage(backgroundImage, 0, 0, Game.WIDTH, Game.HEIGHT, null);\n         } \n\n         // Başlık\n         g.setColor(Color.WHITE);\n         g.setFont(new Font(\"Arial\", Font.BOLD, 50));\n         String title = isMainMenu ? \"2D-Top Shooter Zombie Game\" : \"Paused\";\n         g.drawString(title, Game.WIDTH / 2 - g.getFontMetrics().stringWidth(title) / 2, 150);\n\n         if (isMainMenu && game.getGameState() == GameState.MENU) { \n             renderGameOverStats(g);\n         }\n\n         for (MenuButton button : menuButtons) {\n             button.render(g);\n         }\n    }\n    \n    \n    public void mousePressed(int mx, int my) {\n        for (MenuButton button : menuButtons) {\n            if (button.getBounds().contains(mx, my)) {\n                button.onClick();\n                break;\n            }\n        }\n    }\n    \n    public void mouseMoved(int mx, int my) {\n        for (MenuButton button : menuButtons) {\n            button.setHover(button.getBounds().contains(mx, my));\n        }\n    }\n    \n    public void renderGameOverStats(Graphics g) {\n    \tif (game.getGameOverWave() != -1 || game.getGameOverScore() != -1) { \n            int wave = game.getGameOverWave();\n            int score = game.getGameOverScore();\n\n            g.setColor(Color.RED);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 24));\n\n            FontMetrics fm = g.getFontMetrics();\n\n            int textWidth = fm.stringWidth(\"Oyun Bitti\");\n            g.drawString(\"Oyun Bitti\", (Game.WIDTH - textWidth) / 2, 200); \n\n            textWidth = fm.stringWidth(\"Ulaşılan Dalga: \" + wave);\n            g.drawString(\"Ulaşılan Dalga: \" + wave, (Game.WIDTH - textWidth) / 2, 250); \n\n            textWidth = fm.stringWidth(\"Ulaşılan Puan: \" + score);\n            g.drawString(\"Ulaşılan Puan: \" + score, (Game.WIDTH - textWidth) / 2, 300); \n        }\n    }\n    \n    private class MenuButton {\n        private String text;\n        private int x, y, width, height;\n        private Runnable action;\n        private boolean hover = false;\n        \n        public MenuButton(String text, int x, int y, int width, int height, Runnable action) {\n            this.text = text;\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.height = height;\n            this.action = action;\n        }\n        public void tick() {       \n        }\n        public void render(Graphics g) {    \t\n            if (hover) {\n                g.setColor(new Color(100, 100, 255, 200));\n            } else {\n                g.setColor(new Color(70, 70, 200, 150));\n            }\n            g.fillRect(x, y, width, height);\n\n            g.setColor(Color.WHITE);\n            g.drawRect(x, y, width, height);\n\n            g.setFont(new Font(\"Arial\", Font.BOLD, 24));\n            int textWidth = g.getFontMetrics().stringWidth(text);\n            int textHeight = g.getFontMetrics().getHeight();\n            g.drawString(text, x + width/2 - textWidth/2, y + height/2 + textHeight/4);\n        }\n        \n        public Rectangle getBounds() {\n            return new Rectangle(x, y, width, height);\n        }\n        \n        public void onClick() {\n            if (action != null) {\n                action.run();\n            }\n        }\n        \n        public void setHover(boolean hover) {\n            this.hover = hover;\n        }\n    }\n}\n",
      "WaveManager.java": "package ödev2;\n\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\n\npublic class WaveManager {\n    private Handler handler;\n    private Map map;\n    private Player player;\n    private ZombieSpawner zombieSpawner;\n    private int waveNumber = 0; \n    private int zombiesLeft; // Kalan zombi sayısı\n    private int zombiesToSpawn; // Oluşturulacak toplam zombi sayısı\n    private boolean waveInProgress = false;\n    private int zombiesRemaining = 0;\n    \n    private BufferedImage normalZombieImage;\n    private BufferedImage tankZombieImage;\n    private BufferedImage crawlerZombieImage;\n    private BufferedImage spitterZombieImage;\n    private BufferedImage kamikazeZombieImage;\n\n    \n    private Class<?>[] unlockedWeapons = {Pistol.class}; \n\n    private Timer spawnTimer = null;\n    private int remainingToSpawn = 0;\n    private static final int SPAWN_BATCH_SIZE = 5;  // oluşacak zombi\n    private static final int SPAWN_INTERVAL = 4000;  // oluşmaları arası zaman aralığı\n    private List<SpawnPosition> cachedSpawnPositions = new ArrayList<>();\n    private int cachedPositionsIndex = 0;\n    private static final int MAX_CACHED_POSITIONS = 100;\n    private Random random = new Random();\n    private boolean useObjectPool = false; \n    private ArrayList normalZombiePool = new ArrayList();\n    private ArrayList tankZombiePool = new ArrayList();\n    private ArrayList crawlerZombiePool = new ArrayList(); \n    private ArrayList acidSpitterZombiePool = new ArrayList();\n    private ArrayList kamikazeZombiePool = new ArrayList();\n\tprivate boolean isWaveActive = false;\n    private static final int INITIAL_POOL_SIZE = 50;\n\n    public WaveManager(Handler handler, Map map) {\n        this.handler = handler;\n        this.map = map;\n        this.zombieSpawner = new ZombieSpawner(handler, map, this);\n        normalZombieImage = ImageCache.getImage(\"/images/NormalZombie.png\");\n        tankZombieImage = ImageCache.getImage(\"/images/TankZombie.png\");\n        crawlerZombieImage = ImageCache.getImage(\"/images/CrawlerZombie.png\");\n        spitterZombieImage = ImageCache.getImage(\"/images/AcidSpitterZombie.png\");\n        kamikazeZombieImage = ImageCache.getImage(\"/images/KamikazeZombie.png\");\n        \n      precalculateSpawnPositions();\n\n        if (useObjectPool) {\n            initializeZombiePool();\n        }\n    }\n\n    public void startNextWave() {\n        waveNumber++;\n\n        clearAllZombies();\n        \n        zombiesToSpawn = calculateZombiesToSpawn(waveNumber);\n        zombiesLeft = zombiesToSpawn;\n        zombiesRemaining = zombiesToSpawn;\n        waveInProgress = true;\n        System.out.println(\"Dalga \" + waveNumber + \" başladı! (\" + zombiesToSpawn + \" zombi)\");\n        \n        refillPlayerHealthAndAmmo();\n\n        remainingToSpawn = zombiesToSpawn;\n\n        if (spawnTimer != null) {\n            spawnTimer.cancel();\n        }\n        \n        cachedPositionsIndex = 0;\n        \n        startBatchedSpawning();\n        unlockNewWeapon();\n    }\n    \n    private void startBatchedSpawning() {\n        spawnTimer = new Timer();\n        spawnTimer.scheduleAtFixedRate(new TimerTask() {\n            @Override\n            public void run() {\n                if (remainingToSpawn <= 0) {\n                    this.cancel();\n                    return;\n                }\n\n                int batchSize = Math.min(SPAWN_BATCH_SIZE, remainingToSpawn);\n\n                int actuallySpawned = zombieSpawner.spawnRandomZombies(batchSize);\n                remainingToSpawn -= actuallySpawned;\n\n                if (actuallySpawned == 0 && remainingToSpawn > 0) {\n                    System.out.println(\"UYARI: Zombi spawn edilemedi! Kalan:\" + remainingToSpawn);\n                    zombiesLeft = zombiesToSpawn - remainingToSpawn;\n                    zombiesRemaining = zombiesLeft;\n                    this.cancel();\n                }\n            }\n        }, 0, SPAWN_INTERVAL);\n    }\n    \n\tpublic void activateCurrentWave() {\n\t    isWaveActive  = true;\n\n\t    for (GameObject obj : handler.getObjects()) {\n\t        if (obj instanceof Enemy) {\n\t            ((Enemy)obj).setActive(true);\n\t        }\n\t    }\n\t}\n\n    public BufferedImage getZombieImage(ZombieType type) {\n        switch (type) {\n            case NORMAL: return normalZombieImage;\n            case TANK: return tankZombieImage;\n            case CRAWLER: return crawlerZombieImage;\n            case ACID_SPITTER: return spitterZombieImage;\n            case KAMIKAZE: return kamikazeZombieImage;\n            default: return normalZombieImage;\n        }\n    }\n    \n    private void clearAllZombies() {\n        ArrayList<GameObject> zombiesToRemove = new ArrayList<>();\n\n        for (GameObject obj : new ArrayList<>(handler.getObjects())) {\n            if (obj instanceof Enemy) {\n                zombiesToRemove.add(obj);\n            }\n        }\n\n        for (GameObject zombie : zombiesToRemove) {\n            handler.removeObject(zombie);\n        }\n\n        int remainingZombies = countActualZombiesOnMap();\n        if (remainingZombies > 0) {\n            System.out.println(\"UYARI: Temizleme sonrası hala \" + remainingZombies + \" zombi kaldı!\");\n        }\n    }\n    \n    public void tick() {\n        if (Game.tickCount % 60 == 0) { \n            int actualZombies = countActualZombiesOnMap();\n\n            if (actualZombies != zombiesLeft) {\n                zombiesLeft = actualZombies;\n                zombiesRemaining = actualZombies;\n            }\n\n            if (waveInProgress && actualZombies == 0 && remainingToSpawn <= 0) {\n                endWaveIfCompleted();\n            }\n        }\n    }\n    \n    private void endWaveIfCompleted() {\n        if (waveInProgress && zombiesLeft <= 0 && remainingToSpawn <= 0) {\n            waveInProgress = false;\n            System.out.println(\"Dalga \" + waveNumber + \" tamamlandı!\");\n            System.out.println(\"Tüm zombiler öldürüldü! Sonraki dalga 3 saniye içinde başlatılıyor...\");\n\n            Timer timer = new Timer();\n            timer.schedule(new TimerTask() {\n                @Override\n                public void run() {\n                    startNextWave();\n                    timer.cancel();\n                }\n            }, 3000); \n        }\n    }\n    \n    public void setPlayer(Player player) {\n        this.player = player;\n    }\n    \n    public int countActualZombiesOnMap() {\n        int count = 0;\n        for (GameObject obj : handler.getObjects()) {\n            if (obj instanceof Enemy) {\n                count++;\n            }\n        }\n        return count;\n    }\n    \n    private int calculateZombiesToSpawn(int waveNumber) {\n        return (int) (5 * Math.pow(1.2, waveNumber)); \n    }\n    \n    private void refillPlayerHealthAndAmmo() {\n        if (player != null) {\n            player.takeDamage(-player.getMaxHealth()); \n            \n            for (Class<?> weaponClass : player.getAvailableWeapons()) {\n                try {\n                    Weapon tempWeapon = (Weapon) weaponClass.getDeclaredConstructor().newInstance();\n                    tempWeapon.refillAmmo(); \n                    player.updateWeaponAmmoStorage(weaponClass, tempWeapon.getCurrentAmmo(), tempWeapon.getTotalAmmo());\n                } catch (Exception e) {\n                    System.err.println(\"Silah oluşturma hatası: \" + e.getMessage());\n                    e.printStackTrace();\n                }\n            }\n            if (player.getCurrentWeapon() != null) {\n                player.loadWeaponAmmo(player.getCurrentWeapon().getClass());\n            }\n        } else {\n            System.err.println(\"UYARI: Player nesnesi null, can ve mermi yenilenemedi!\");\n        }\n    }\n    \n    private void unlockNewWeapon() {\n        switch (waveNumber) {\n            case 2:\n                unlockWeapon(AssaultRifle.class); \n                break;\n            case 3:\n                unlockWeapon(Shotgun.class);\n                break;\n            case 5:\n                unlockWeapon(SniperRifle.class);\n                break;\n            case 10:\n                unlockWeapon(RocketLauncher.class);\n                break;\n        }\n    }\n    \n    public void unlockWeapon(Class<?> weaponClass) {\n        if (!isWeaponUnlocked(weaponClass)) {\n            unlockedWeapons = Arrays.copyOf(unlockedWeapons, unlockedWeapons.length + 1);\n            unlockedWeapons[unlockedWeapons.length - 1] = weaponClass;\n            System.out.println(weaponClass.getSimpleName() + \" açıldı!\");\n        }\n        player.unlockWeapon(weaponClass); \n    }\n    \n    public boolean isWeaponUnlocked(Class<?> weaponClass) {\n        if (weaponClass.equals(Pistol.class)) {\n            return true; \n        } else if (weaponClass.equals(AssaultRifle.class)) {\n            return waveNumber >= 2; \n        } else if (weaponClass.equals(Shotgun.class)) {\n            return waveNumber >= 3; \n        } else if (weaponClass.equals(SniperRifle.class)) {\n            return waveNumber >= 5; \n        } else if (weaponClass.equals(RocketLauncher.class)) {\n            return waveNumber >= 10; \n        }\n        return false;\n    }\n    \n    public void zombieDied() {\n        zombiesLeft--;\n        zombiesRemaining--;\n        System.out.println(\"Bir zombi öldürüldü! (\" + zombiesLeft + \" zombi kaldı)\");\n\n        if (zombiesLeft <= 0 && remainingToSpawn <= 0) {\n            waveInProgress = false;\n            new java.util.Timer().schedule(\n                new java.util.TimerTask() {\n                    @Override\n                    public void run() {\n                        startNextWave();\n                    }\n                },\n                3000\n            );\n        }\n    }\n    \n    private void precalculateSpawnPositions() {\n        for (int i = 0; i < MAX_CACHED_POSITIONS; i++) {\n            try {\n                int screenWidth = Game.WIDTH;\n                int screenHeight = Game.HEIGHT;\n\n                float spawnX, spawnY;\n                \n                if (random.nextBoolean()) {\n                    spawnX = random.nextBoolean() ? -50 : screenWidth + 50;\n                    spawnY = random.nextInt(screenHeight);\n                } else {\n                    spawnX = random.nextInt(screenWidth);\n                    spawnY = random.nextBoolean() ? -50 : screenHeight + 50;\n                }\n\n                int attempts = 0;\n                while (map.isBlock((int)spawnX, (int)spawnY) && attempts < 10) {\n                    spawnX = random.nextInt(screenWidth);\n                    spawnY = random.nextInt(screenHeight);\n                    attempts++;\n                }\n                \n                if (!map.isBlock((int)spawnX, (int)spawnY)) {\n                    cachedSpawnPositions.add(new SpawnPosition(spawnX, spawnY));\n                }\n            } catch (Exception e) {\n                System.err.println(\"Error calculating spawn position: \" + e.getMessage());\n            }\n        }\n        \n        System.out.println(\"Cached \" + cachedSpawnPositions.size() + \" spawn positions\");\n    }\n    \n    private void initializeZombiePool() {\n        if (!useObjectPool) return;\n        \n        for (int i = 0; i < INITIAL_POOL_SIZE; i++) {\n\n            Enemy normalZombie = createInactiveZombie(ZombieType.NORMAL);\n            normalZombiePool.add(normalZombie);\n\n            Enemy tankZombie = createInactiveZombie(ZombieType.TANK);\n            tankZombiePool.add(tankZombie);\n\n            Enemy crawlerZombie = createInactiveZombie(ZombieType.CRAWLER);\n            crawlerZombiePool.add(crawlerZombie);\n\n            Enemy acidSpitterZombie = createInactiveZombie(ZombieType.ACID_SPITTER);\n            acidSpitterZombiePool.add(acidSpitterZombie);\n            \n            Enemy KamikazeZombie = createInactiveZombie(ZombieType.KAMIKAZE);\n            acidSpitterZombiePool.add(KamikazeZombie);\n            \n        }\n\n    }\n    \n    private Enemy createInactiveZombie(ZombieType type) {\n        float hiddenX = -1000;\n        float hiddenY = -1000;\n\n        Enemy zombie = null;\n        switch (type) {\n            case NORMAL:\n                zombie = new NormalZombie(hiddenX, hiddenY, type, handler, map, this);\n                break;\n            case CRAWLER:\n                zombie = new CrawlerZombie(hiddenX, hiddenY, type, handler, map, this);\n                break;\n            case TANK:\n                zombie = new TankZombie(hiddenX, hiddenY, type, handler, map, this);\n                break;\n            case KAMIKAZE:\n                zombie = new KamikazeZombie(hiddenX, hiddenY, type, handler, map, this);\n            case ACID_SPITTER:\n                zombie = new AcidSpitterZombie(hiddenX, hiddenY, type, handler, map, this);\n                break;\n        }\n        \n        if (zombie != null) {\n            zombie.setActive(false);\n        }\n        \n        return zombie;\n    }\n    \n    private Enemy getZombieFromPool(ZombieType type) {\n        if (!useObjectPool) return null;\n\n        ArrayList typePool;\n        switch (type) {\n            case NORMAL:\n                typePool = normalZombiePool;\n                break;\n            case TANK:\n                typePool = tankZombiePool;\n                break;\n            case CRAWLER:\n                typePool = crawlerZombiePool;\n                break;\n            case KAMIKAZE:\n                typePool = kamikazeZombiePool;\n                break;\n            case ACID_SPITTER:\n                typePool = acidSpitterZombiePool;\n                break;\n            default:\n                System.err.println(\"Hata: Bilinmeyen zombi tipi: \" + type);\n                return null;\n        }\n\n        for (int i = 0; i < typePool.size(); i++) {\n            Enemy zombie = (Enemy) typePool.get(i);\n            if (!zombie.isActive()) {\n                return zombie;\n            }\n        }\n\n        Enemy newZombie = createInactiveZombie(type);\n        typePool.add(newZombie);\n        System.out.println(type + \" zombi havuzu genişletildi. Yeni boyut: \" + typePool.size());\n        \n        return newZombie;\n    }\n    \n    public Enemy spawnZombie(ZombieType type, float x, float y) {\n        Enemy zombie;\n        \n        if (useObjectPool) {\n            zombie = getZombieFromPool(type);\n            \n            if (zombie != null) {\n                zombie.setX(x);\n                zombie.setY(y);\n                zombie.setActive(true);\n                \n                if (!handler.object.contains(zombie)) {\n                    handler.addObject(zombie);\n                }\n            } else {\n                zombie = createZombieByType(type, x, y);\n                handler.addObject(zombie);\n            }\n        } else {\n            zombie = createZombieByType(type, x, y);\n            handler.addObject(zombie);\n        }\n        \n        return zombie;\n    }\n    \n    \n    private Enemy createZombieByType(ZombieType type, float x, float y) {\n        switch (type) {\n            case NORMAL:\n                return new NormalZombie(x, y, type, handler, map, this);\n            case CRAWLER:\n                return new CrawlerZombie(x, y, type, handler, map, this);\n            case TANK:\n                return new TankZombie(x, y, type, handler, map, this);\n            case ACID_SPITTER:\n                return new AcidSpitterZombie(x, y, type, handler, map, this);\n            case KAMIKAZE:\n                return new KamikazeZombie(x, y, type, handler, map, this);\n            default:\n                return new NormalZombie(x, y, type, handler, map, this);\n        }\n    }\n    \n    \n    \n    public void resetWave() {\n   \n        this.waveNumber = 0;\n        this.zombiesLeft = 0;\n        this.zombiesToSpawn = 0;\n        this.waveInProgress = false;\n        this.remainingToSpawn = 0;\n        this.zombiesRemaining = 0;\n\n        if (spawnTimer != null) {\n            spawnTimer.cancel();\n            spawnTimer = null;\n        }\n\n        clearAllZombies();\n\n        this.unlockedWeapons = new Class<?>[] {Pistol.class};\n\n        if (player != null) {\n            player.getAvailableWeapons().clear();\n            player.unlockWeapon(Pistol.class);\n\n            try {\n                Weapon pistol = (Weapon)Pistol.class.getDeclaredConstructor().newInstance();\n                player.updateWeaponAmmoStorage(Pistol.class, pistol.getCurrentAmmo(), pistol.getTotalAmmo());\n                player.switchWeapon(0); \n            } catch (Exception e) {\n                System.err.println(\"Pistol oluşturulamadı: \" + e.getMessage());\n            }\n        }\n    }\n    \n    public void setZombiesRemaining(int zombiesRemaining) {\n        this.zombiesRemaining = zombiesRemaining;\n    }\n    \n    public void adjustZombieCount(int actualSpawnedCount) {\n        if (actualSpawnedCount < zombiesToSpawn) {\n            System.out.println(\"UYARI: Sadece \" + actualSpawnedCount + \"/\" + zombiesToSpawn + \n                              \" zombi oluşturulabildi!\");\n            zombiesToSpawn = actualSpawnedCount;\n            zombiesLeft = actualSpawnedCount;\n            zombiesRemaining = actualSpawnedCount;\n            remainingToSpawn = 0; \n        }\n    }\n\n    public int getWaveNumber() {\n        return waveNumber;\n    }\n    \n    public void setWaveNumber(int waveNumber) {\n        this.waveNumber = waveNumber;\n    }\n    \n    public int getZombiesLeft() {\n        return zombiesLeft;\n    }\n    \n    public int getZombiesRemaining() {\n        return zombiesRemaining;\n    }\n    \n    private class SpawnPosition {\n        float x;\n        float y;\n        \n        SpawnPosition(float x, float y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n}\n\n\n",
      "Map.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport javax.imageio.ImageIO;\n\npublic class Map {\n    private static final int TILE_SIZE = 32;\n    private static final String MAP_FILE = \"Tiles.txt\";\n    private static final int MAP_WIDTH = 32;\n    private static final int MAP_HEIGHT = 32;\n\n    private int[][] mapData;\n    private int mapWidth, mapHeight;\n\n    private HashMap<Integer, BufferedImage> tileImages;\n\n    public Map() {\n        mapData = new int[MAP_HEIGHT][MAP_WIDTH];\n        loadMapData();\n        \n        this.mapWidth = MAP_WIDTH; \n        this.mapHeight = MAP_HEIGHT;\n\n        loadTileImages();\n    }\n    \n    private void loadTileImages() {\n        tileImages = new HashMap<>();\n        try {\n            // Temel zemin ve engel türleri\n            tileImages.put(0, ImageIO.read(new File(\"picsel/earth.png\")));\n            tileImages.put(1, ImageIO.read(new File(\"picsel/wall.png\")));\n            \n            // Çim türleri\n            tileImages.put(2, ImageIO.read(new File(\"picsel/grass00.png\")));\n            tileImages.put(3, ImageIO.read(new File(\"picsel/grass01.png\")));\n            \n            // Yol türleri\n            tileImages.put(4, ImageIO.read(new File(\"picsel/road00.png\")));\n            tileImages.put(5, ImageIO.read(new File(\"picsel/road01.png\")));\n            tileImages.put(6, ImageIO.read(new File(\"picsel/road02.png\")));\n            tileImages.put(7, ImageIO.read(new File(\"picsel/road03.png\")));\n            tileImages.put(8, ImageIO.read(new File(\"picsel/road04.png\")));\n            tileImages.put(9, ImageIO.read(new File(\"picsel/road05.png\")));\n            tileImages.put(10, ImageIO.read(new File(\"picsel/road06.png\")));\n            tileImages.put(11, ImageIO.read(new File(\"picsel/road07.png\")));\n            tileImages.put(12, ImageIO.read(new File(\"picsel/road08.png\")));\n            tileImages.put(13, ImageIO.read(new File(\"picsel/road09.png\")));\n            tileImages.put(14, ImageIO.read(new File(\"picsel/road10.png\")));\n            tileImages.put(15, ImageIO.read(new File(\"picsel/road11.png\")));\n            tileImages.put(16, ImageIO.read(new File(\"picsel/road12.png\")));\n            \n            // Su türleri\n            tileImages.put(20, ImageIO.read(new File(\"picsel/water00.png\")));\n            tileImages.put(21, ImageIO.read(new File(\"picsel/water01.png\")));\n            tileImages.put(22, ImageIO.read(new File(\"picsel/water02.png\")));\n            tileImages.put(23, ImageIO.read(new File(\"picsel/water03.png\")));\n            tileImages.put(24, ImageIO.read(new File(\"picsel/water04.png\")));\n            tileImages.put(25, ImageIO.read(new File(\"picsel/water05.png\")));\n            tileImages.put(26, ImageIO.read(new File(\"picsel/water06.png\")));\n            tileImages.put(27, ImageIO.read(new File(\"picsel/water07.png\")));\n            tileImages.put(28, ImageIO.read(new File(\"picsel/water08.png\")));\n            tileImages.put(29, ImageIO.read(new File(\"picsel/water09.png\")));\n            tileImages.put(30, ImageIO.read(new File(\"picsel/water10.png\")));\n            tileImages.put(31, ImageIO.read(new File(\"picsel/water11.png\")));\n            tileImages.put(32, ImageIO.read(new File(\"picsel/water12.png\")));\n            tileImages.put(33, ImageIO.read(new File(\"picsel/water13.png\")));\n            \n            // Diğer objeler\n            tileImages.put(34, ImageIO.read(new File(\"picsel/tree.png\")));\n            tileImages.put(35, ImageIO.read(new File(\"picsel/hut.png\")));\n            tileImages.put(36, ImageIO.read(new File(\"picsel/table01.png\")));\n            tileImages.put(37, ImageIO.read(new File(\"picsel/ateş.png\")));\n            tileImages.put(38, ImageIO.read(new File(\"picsel/cicek.png\")));\n            tileImages.put(39, ImageIO.read(new File(\"picsel/agac1.png\")));\n            tileImages.put(40, ImageIO.read(new File(\"picsel/agac2.png\")));\n            tileImages.put(41, ImageIO.read(new File(\"picsel/agac3.png\")));\n            tileImages.put(42, ImageIO.read(new File(\"picsel/agac4.png\")));\n            \n            \n            \n        } catch (IOException e) {\n            System.err.println(\"Tile görüntüleri yüklenirken hata oluştu: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    private void loadMapData() {\n        try {\n            Scanner scanner = new Scanner(new File(MAP_FILE));\n            int row = 0;\n            while (scanner.hasNextLine() && row < MAP_HEIGHT) {\n                String line = scanner.nextLine().trim();\n                if (!line.isEmpty()) {\n                    String[] values = line.split(\",\");\n                    for (int col = 0; col < MAP_WIDTH && col < values.length; col++) {\n                        String value = values[col].trim();\n                        if (!value.isEmpty()) {\n                            mapData[row][col] = Integer.parseInt(value);\n                        } else {\n                            mapData[row][col] = 0;\n                        }\n                    }\n                    row++;\n                }\n            }\n            scanner.close();\n        } catch (FileNotFoundException e) {\n            System.err.println(\"Harita dosyası bulunamadı: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n    \n    public void render(Graphics g, Camera camera) {\n        int startCol = 0;\n        int endCol = MAP_WIDTH;\n        int startRow = 0;\n        int endRow = MAP_HEIGHT;\n        \n        if (camera != null) {\n            startCol = (int)Math.max(0, camera.getX() / TILE_SIZE);\n            endCol = (int)Math.min(MAP_WIDTH, (camera.getX() + Game.WIDTH) / TILE_SIZE + 1);\n            startRow = (int)Math.max(0, camera.getY() / TILE_SIZE);\n            endRow = (int)Math.min(MAP_HEIGHT, (camera.getY() + Game.HEIGHT) / TILE_SIZE + 1);\n        }\n\n        BufferedImage backgroundTile = tileImages.get(0); // earth\n        if (backgroundTile != null) {\n            for (int row = startRow; row < endRow; row++) {\n                for (int col = startCol; col < endCol; col++) {\n                    int x = col * TILE_SIZE;\n                    int y = row * TILE_SIZE;\n                    g.drawImage(backgroundTile, x, y, TILE_SIZE, TILE_SIZE, null);\n                }\n            }\n        }\n\n        for (int row = startRow; row < endRow; row++) {\n            for (int col = startCol; col < endCol; col++) {\n                int tileId = mapData[row][col];\n                if (tileId > 0) { \n                    BufferedImage img = tileImages.get(tileId);\n                    if (img != null) {\n                        int x = col * TILE_SIZE;\n                        int y = row * TILE_SIZE;\n                        g.drawImage(img, x, y, TILE_SIZE, TILE_SIZE, null);\n                    } else {\n              \n                        int x = col * TILE_SIZE;\n                        int y = row * TILE_SIZE;\n                        g.setColor(getTileColor(tileId));\n                        g.fillRect(x, y, TILE_SIZE, TILE_SIZE);\n                        g.setColor(Color.BLACK);\n                        g.drawRect(x, y, TILE_SIZE, TILE_SIZE);\n                    }\n                }\n            }\n        }\n    }\n\n    private Color getTileColor(int tileId) {\n        switch (tileId) {\n            case 1: return Color.GRAY; // Duvar\n            case 2:\n            case 3: return Color.GREEN; // Çim\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n            case 16: return Color.DARK_GRAY; // Yol\n            case 20:\n            case 21:\n            case 22:\n            case 23: return Color.BLUE; // Su\n            default: return Color.LIGHT_GRAY;\n        }\n    }\n\n    public boolean isBlock(int x, int y) {\n        int mapX = x / TILE_SIZE;\n        int mapY = y / TILE_SIZE;\n\n        if (mapX >= 0 && mapX < MAP_WIDTH && mapY >= 0 && mapY < MAP_HEIGHT) {\n            int tileId = mapData[mapY][mapX];\n            return isBlockingTile(tileId);\n        } else {\n            return true; \n        }\n    }\n\n    private boolean isBlockingTile(int tileId) {\n        return tileId == 1 || // Duvar\n               tileId == 34 || // Ağaç\n               tileId == 35 || // Kulübe\n               (tileId >= 20 && tileId <= 33) || //Su\n               tileId== 37 || //ateş\n               (tileId >= 39 && tileId <= 42); // ağaç\n    }\n\n    public boolean isTileEmpty(int x, int y) {\n        if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) {\n            return false;\n        }\n        int tileId = mapData[y][x];\n        return tileId == 0 || // Boş alan (earth)\n               (tileId >= 2 && tileId <= 3) || // Çim\n               (tileId >= 4 && tileId <= 16); // Yollar\n    }\n\n    public boolean isWalkable(int x, int y) {\n        if (!isInBounds(x, y)) {\n            return false;\n        }\n        \n        int tileId = getTileAt(x, y);\n        return tileId != 1 && // Duvar değil\n               tileId != 34 && // Ağaç değil\n               tileId != 35 && // Kulübe değil\n               !(tileId >= 20 && tileId <= 33); // Su değil\n    }\n\n    public boolean isAreaEmpty(int x, int y, int width, int height) {\n        for (int row = y; row < y + height && row < MAP_HEIGHT; row++) { \n            for (int col = x; col < x + width && col < MAP_WIDTH; col++) {\n                if (!isTileEmpty(col, row)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public int getTileAt(int x, int y) {\n        if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) {\n            return 0;\n        }\n        return mapData[y][x];\n    }\n\n    public boolean isInBounds(int x, int y) {\n        return x >= 0 && y >= 0 && x < mapWidth && y < mapHeight;\n    }\n\n    public int getMapWidth() {\n        return mapWidth;\n    }\n\n    public int getMapHeight() {\n        return mapHeight;\n    }\n\n    public int getTileSize() {\n        return TILE_SIZE;\n    }\n\n    public void setTileAt(int x, int y, int tileId) {\n        if (isInBounds(x, y)) {\n            mapData[y][x] = tileId;\n        }\n    }\n}\n\n",
      "GameSave.java": "package ödev2;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GameSave implements Serializable {\n    private static final long serialVersionUID = 1L;\n    ZombieData zombieData;\n    private List<AmmoClipData> ammoClips = new ArrayList<>();\n\n    private float playerX;\n    private float playerY;\n    private int playerHealth;\n\n    private float cameraX;\n    private float cameraY;\n\n    private List<String> unlockedWeapons = new ArrayList<>();\n    private List<int[]> weaponAmmo = new ArrayList<>();\n    private int activeWeaponIndex;\n\n    private int waveNumber;\n    private int zombiesRemaining;\n    private int score;\n    \n    public List<AmmoClipData> getAmmoClips() {\n        return ammoClips;\n    }\n\n    public void setAmmoClips(List<AmmoClipData> ammoClips) {\n        this.ammoClips = ammoClips;\n    }\n    \n    private List<ZombieData> zombies = new ArrayList<>();\n    \n    public float getPlayerX() {\n        return playerX;\n    }\n    \n    public void setPlayerX(float playerX) {\n        this.playerX = playerX;\n    }\n    \n    public float getPlayerY() {\n        return playerY;\n    }\n    \n    public void setPlayerY(float playerY) {\n        this.playerY = playerY;\n    }\n    \n    public int getPlayerHealth() {\n        return playerHealth;\n    }\n    \n    public void setPlayerHealth(int playerHealth) {\n        this.playerHealth = playerHealth;\n    }\n    \n    public float getCameraX() {\n        return cameraX;\n    }\n    \n    public void setCameraX(float cameraX) {\n        this.cameraX = cameraX;\n    }\n    \n    public float getCameraY() {\n        return cameraY;\n    }\n    \n    public void setCameraY(float cameraY) {\n        this.cameraY = cameraY;\n    }\n    \n    public List<String> getUnlockedWeapons() {\n        return unlockedWeapons;\n    }\n    \n    public void setUnlockedWeapons(List<String> unlockedWeapons) {\n        this.unlockedWeapons = unlockedWeapons;\n    }\n    \n    public List<int[]> getWeaponAmmo() {\n        return weaponAmmo;\n    }\n    \n    public void setWeaponAmmo(List<int[]> weaponAmmo) {\n        this.weaponAmmo = weaponAmmo;\n    }\n    \n    public int getActiveWeaponIndex() {\n        return activeWeaponIndex;\n    }\n    \n    public void setActiveWeaponIndex(int activeWeaponIndex) {\n        this.activeWeaponIndex = activeWeaponIndex;\n    }\n    \n    public int getWaveNumber() {\n        return waveNumber;\n    }\n    \n    public void setWaveNumber(int waveNumber) {\n        this.waveNumber = waveNumber;\n    }\n    \n    public int getZombiesRemaining() {\n        return zombiesRemaining;\n    }\n    \n    public void setZombiesRemaining(int zombiesRemaining) {\n        this.zombiesRemaining = zombiesRemaining;\n    }\n    \n    public int getScore() {\n        return score;\n    }\n    \n    public void setScore(int score) {\n        this.score = score;\n    }\n    \n    public List<ZombieData> getZombies() {\n        return zombies;\n    }\n    \n    public void setZombies(List<ZombieData> zombies) {\n        this.zombies = zombies;\n    }\n    \n    public void addZombie(ZombieData zombie) {\n        this.zombies.add(zombie);\n    }\n}\n\n\n",
      "AidKit.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class AidKit extends GameObject {\n    \n    private int healAmount; \n    private Handler handler; \n    private boolean collected = false;\n    \n    public AidKit(float x, float y, ID id) {\n        super(x, y, id);\n        this.healAmount = 20; // Gives 20 health when collected\n    }\n    \n    public AidKit(float x, float y, ID id, Handler handler) {\n        super(x, y, id);\n        this.handler = handler;\n        this.healAmount = 20; // Gives 20 health when collected\n    }\n    \n    public void setHandler(Handler handler) {\n        this.handler = handler;\n    }\n    \n    @Override\n    public void tick() {\n        if (collected) return;\n      \n        if (handler != null) {\n            Player player = handler.getPlayer();\n            if (player != null && getBounds().intersects(player.getBounds())) {\n                // Calculate new health, ensuring it doesn't exceed max health\n                int newHealth = player.getHealth() + healAmount;\n                if (newHealth > player.getMaxHealth()) {\n                    newHealth = player.getMaxHealth();\n                }\n                \n                // Set the player's new health\n                player.setHealth(newHealth);\n                \n                collected = true;\n                handler.removeObject(this);\n            }\n        }\n    }\n    \n    @Override\n    public void render(Graphics g) {\n        if (collected) return;\n        \n        // Red square for aid kit\n        g.setColor(Color.RED);\n        g.fillRect((int) x, (int) y, 16, 16);\n        \n        // Black border\n        g.setColor(Color.BLACK); \n        g.drawRect((int) x, (int) y, 16, 16);\n        \n        // White plus symbol\n        g.setColor(Color.WHITE);\n        // Horizontal line of the plus\n        g.fillRect((int) x + 3, (int) y + 7, 10, 2);\n        // Vertical line of the plus\n        g.fillRect((int) x + 7, (int) y + 3, 2, 10);\n    }\n    \n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle((int) x, (int) y, 16, 16);\n    }\n    \n    public void setHealAmount(int amount) {\n        this.healAmount = amount;\n    }\n    \n    public int getHealAmount() {\n        return healAmount;\n    }\n    \n    public boolean isCollected() {\n        return collected;\n    }\n    \n    public void setCollected(boolean collected) {\n        this.collected = collected;\n    }\n}",
      "ZombieData.java": "package ödev2;\n\nimport java.io.Serializable;\n\npublic class ZombieData implements Serializable {\n    private static final long serialVersionUID = 1L;\n    \n    private float x;\n    private float y;\n    private int health;\n    private String type; \n\n    public float getX() {\n        return x;\n    }\n    \n    public void setX(float x) {\n        this.x = x;\n    }\n    \n    public float getY() {\n        return y;\n    }\n    \n    public void setY(float y) {\n        this.y = y;\n    }\n    \n    public int getHealth() {\n        return health;\n    }\n    \n    public void setHealth(int health) {\n        this.health = health;\n    }\n    \n    public String getType() {\n        return type;\n    }\n    \n    public void setType(String type) {\n        this.type = type;\n    }\n}\n",
      "Weapon.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.geom.AffineTransform;\nimport java.io.IOException;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport javax.imageio.ImageIO;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.geom.AffineTransform;\nimport java.io.IOException;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport javax.imageio.ImageIO;\n\npublic abstract class Weapon {\n    protected int magazineSize;  // Şarjör kapasitesi\n    protected int currentAmmo;   // Şarjördeki mermi sayısı\n    protected int totalAmmo;     // Toplam mermi sayısı\n    protected float fireRate;    // Ateş hızı \n    protected long lastShootTime;\n    protected boolean isReloading;\n    protected boolean hasInfiniteAmmo;\n    protected int maxReserveAmmo;\n    Camera camera;\n    private long reloadStartTime = 0;  \n    private int reloadDelay = 500;\n    protected int damage;\n    protected Handler handler;\n    protected float speed;\n    protected float spread;     \n    protected float bulletSpeed; \n    protected int bulletSize;   \n    protected boolean isPiercing; // Mermi delici mi?\n    protected boolean isExplosive; \n    protected String weaponName;\n    protected int penetration;\n    float actualAngle = 0;\n    protected float timeBetweenShots; \n    protected boolean isAutomatic;    \n    protected boolean isFiring;\n    private float firingAngle;\n    protected SoundPlayer shootSound;\n    protected Image weaponIcon;\n    private float damageMultiplier = 1.0f;\n    \n    public Weapon() {\n        this.handler = null;\n        this.weaponName = getClass().getSimpleName();\n        loadShootSound();\n        try {\n            String imagePath = \"/images/\" + getClass().getSimpleName() + \".png\";\n\n            weaponIcon = ImageIO.read(getClass().getResourceAsStream(imagePath));\n            \n            if (weaponIcon == null) {\n                //System.err.println(\"UYARI: \" + imagePath + \" dosyası bulundu ama yüklenemedi.\");\n            }\n        } catch (Exception e) {\n            //System.err.println(\"Silah simgesi yüklenemedi: \" + e.getMessage());\n        }\n        configureDefaultValues();\n    }\n\n    private void configureDefaultValues() {\n\n        this.timeBetweenShots = 0.5f; \n        this.isAutomatic = false;    \n        this.isFiring = false;       \n    }\n\n    public void setHandler(Handler handler) {\n        if (handler == null) {\n        \t\n        } else {\n            this.handler = handler;\n        }\n    }\n\n    public void setCamera(Camera camera) {\n        this.camera = camera;\n    }\n\n    protected abstract void loadShootSound();\n    public abstract int getMagazineCapacity(); \n    public abstract int getFireRate(); \n    \n    public void shoot(float angle, float playerX, float playerY) {\n        long currentTime = System.currentTimeMillis();\n        long timeBetweenShots = (long) (1000 / fireRate);\n        long timeSinceLastShot = currentTime - lastShootTime;\n        long requiredDelay = (long)(timeBetweenShots * 1000); \n        \n        if (isReloading) return; \n        \n        if (timeSinceLastShot < requiredDelay) {\n            return;\n        }\n        \n        if (currentAmmo <= 0) {\n            System.out.println(weaponName + \": Şarjör boş! Yeniden doldurun.\");\n            reload();\n            return;\n        }\n        \n        if (handler == null) {\n            System.err.println(\"HATA: \" + weaponName + \" silahının handler referansı null!\");\n            return; \n        }\n\n        this.actualAngle = angle;\n        \n        createBullet(angle, playerX, playerY);\n        currentAmmo--;\n        playShootSound();\n        lastShootTime = currentTime;\n    }\n\n    protected void playShootSound() {\n        if (shootSound != null) {\n            shootSound.play();\n        }\n    }\n\n    protected void createBullet(float angle, float playerX, float playerY) {\n    \t   if (handler == null) {\n    \t        return;\n    \t    }\n\n    \t    Player player = handler.getPlayer();\n    \t    if (player == null) {\n    \t        System.err.println(\"HATA: Player referansı bulunamadı!\");\n    \t        return;\n    \t    }\n\n    \t    float bulletStartX = playerX;\n    \t    float bulletStartY = playerY;\n\n    \t    float weaponLength = 30; \n    \t    bulletStartX += (float)(Math.cos(angle) * weaponLength);\n    \t    bulletStartY += (float)(Math.sin(angle) * weaponLength);\n\n    \t    float finalAngle = angle;\n    \t    if (spread > 0) {\n    \t        finalAngle = angle + (float)((Math.random() - 0.5) * 2 * spread);\n    \t    }\n\n    \t    float finalBulletSpeed = (bulletSpeed <= 0) ? 5.0f : bulletSpeed;\n    \t    float velX = (float)(Math.cos(finalAngle) * finalBulletSpeed);\n    \t    float velY = (float)(Math.sin(finalAngle) * finalBulletSpeed);\n\n    \t    Color bulletColor = Color.YELLOW; \n    \t    if (this instanceof Pistol) bulletColor = Color.BLUE;\n    \t    else if (this instanceof RocketLauncher) bulletColor = Color.RED;\n    \t    else if (this instanceof Shotgun) bulletColor = Color.ORANGE;\n\n    \t    try {\n    \t        Bullet bullet = new Bullet(\n    \t            bulletStartX, bulletStartY, ID.Bullet, handler, damage,\n    \t            finalAngle, finalBulletSpeed, penetration, isExplosive,\n    \t            bulletColor, bulletSize, player\n    \t        );\n\n    \t        bullet.setVelX(velX);\n    \t        bullet.setVelY(velY);\n\n    \t        handler.addObject(bullet);\n    \t    } catch (Exception e) {\n\n    \t    }\n    }\n\n    public void reload() {\n        if (isReloading || currentAmmo == magazineSize || totalAmmo <= 0) return;\n        isReloading = true;\n        Timer reloadTimer = new Timer();\n        reloadTimer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n                int bulletsToLoad = Math.min(magazineSize - currentAmmo, totalAmmo);\n                currentAmmo += bulletsToLoad;\n                totalAmmo -= bulletsToLoad;\n                isReloading = false;\n                reloadTimer.cancel();\n            }\n        }, 1000); // 1 saniye reload süresi\n    }\n\n    protected boolean canShoot() {\n        long currentTime = System.currentTimeMillis();\n        long timeSinceLastShot = currentTime - lastShootTime;\n        long requiredDelay = (long)(timeBetweenShots * 1000); \n        return !isReloading && currentAmmo > 0 && (timeSinceLastShot >= requiredDelay);\n    }\n\n    public void tick() {\n     \n        if (isReloading && System.currentTimeMillis() - reloadStartTime >= reloadDelay) {\n            completeReload();\n        }\n        \n        if (isAutomatic && isFiring && canShoot()) {\n            if (handler != null && handler.getPlayer() != null) {\n                Player player = handler.getPlayer();\n                float currentAngle = player.calculateAngleToMouse();\n                shoot(currentAngle, player.getX(), player.getY());\n            }\n        }\n    }\n\n    private void completeReload() {\n        if (hasInfiniteAmmo) {\n            currentAmmo = magazineSize;\n        } else {\n            int neededAmmo = magazineSize - currentAmmo;\n\n            if (totalAmmo >= neededAmmo) {\n                totalAmmo -= neededAmmo;\n                currentAmmo = magazineSize;\n            } else { \n                currentAmmo += totalAmmo;\n                totalAmmo = 0;\n            }\n        }\n        isReloading = false;\n    }\n\n    public void startReloading() {\n        if (!isReloading && currentAmmo < magazineSize) {\n            isReloading = true; \n            reloadStartTime = System.currentTimeMillis();\n        }\n    }\n\n    public void startFiring() {\n        isFiring = true;\n    }\n\n    public void stopFiring() {\n        isFiring = false;\n    }\n\n    public boolean isAutomatic() {\n        return isAutomatic;\n    }\n\n    public boolean isReloading() {\n        return isReloading;\n    }\n\n    public int getCurrentAmmo() {\n        return currentAmmo;\n    }\n\n    public int getTotalAmmo() {\n        return totalAmmo;\n    }\n\n    public void setTotalAmmo(int totalAmmo) {\n        this.totalAmmo = totalAmmo;\n    }\n\n    public void setCurrentAmmo(int currentAmmo) {\n        this.currentAmmo = Math.min(currentAmmo, magazineSize);\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public int getMagazineSize() {\n        return this.magazineSize;\n    }\n\n    public boolean hasInfiniteAmmo() {\n        return this.hasInfiniteAmmo;\n    }\n\n    public float getTimeBetweenShots() {\n        return timeBetweenShots;\n    }\n\n    public void refillAmmo() {\n       \n        if (this instanceof AssaultRifle) {\n            this.totalAmmo = 90;\n        } else if (this instanceof Shotgun) {\n            this.totalAmmo = 15;\n        } else if (this instanceof SniperRifle) {\n            this.totalAmmo = 15;\n        } else if (this instanceof RocketLauncher) {\n            this.totalAmmo = 5;\n        }\n    }\n\n    public void addAmmo(int ammo) {\n        if (!hasInfiniteAmmo) {\n            totalAmmo = Math.min(totalAmmo + ammo, maxReserveAmmo); \n        }\n    }\n    \n    \n\n    public void render(Graphics2D g2d) {\n    \t \tint handOffsetX = 1;  \n    \t    int handOffsetY = 4;   \n    \t    \n    \t    int gripPointX = -10;  \n    \t    int gripPointY = 0;    \n\n    \t    int weaponWidth = 30;  // Adjust based on your weapon icon size\n    \t    int weaponHeight = 15; // Adjust based on your weapon icon size\n    \t    \n    \t    int weaponX = handOffsetX - gripPointX - weaponWidth/2;\n    \t    int weaponY = handOffsetY - gripPointY - weaponHeight/2;\n\n    \t    if (weaponIcon != null) {\n    \t        g2d.drawImage(weaponIcon, weaponX, weaponY, weaponWidth, weaponHeight, null);\n    \t    } else {\n    \t        g2d.setColor(Color.BLACK);\n    \t        g2d.fillRect(weaponX, weaponY, weaponWidth, weaponHeight);\n    \t    }\n    }\n}\n",
      "Bullet.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\nimport javax.imageio.ImageIO;\n\npublic class Bullet extends GameObject {\n    \n    private int lifeSpan = 50;\n    Handler handler;\n    private int damage;\n    private float angle;\n    private int size = 8;\n    private boolean isPiercing = false; \n    private boolean isExplosive = false; \n    private int explosionRadius = 100; \n    private GameObject shooter;\n    float speed;\n    private GameObject owner;\n    private Color color;\n    private int penetration;\n    \n    private static BufferedImage bulletImage;\n    private static BufferedImage defaultBulletImage;\n    private boolean useImage = false; \n    private float scaleFactor = 1.0f;\n    private int width = 24;    \n    private int height = 24;   \n    private static HashMap<String, BufferedImage> bulletImageCache = new HashMap<>();\n    private boolean isExploding = false;\n    \n    static {\n        loadBulletImage(\"pistol\", \"images/Bullet.png\");\n        loadBulletImage(\"rifle\", \"images/Bullet.png\");\n        loadBulletImage(\"sniper\", \"images/Bullet.png\");\n        loadBulletImage(\"shotgun\", \"images/Bullet.png\");\n        loadBulletImage(\"rocket\", \"images/Bullet.png\");\n    }\n    \n    public Bullet(float x, float y, ID id, Handler handler) {\n        super(x, y, id);\n        this.handler = handler;\n        this.damage = 20;\n        this.bulletImage = defaultBulletImage;\n        this.angle = 0;\n    }\n    \n    public Bullet(float x, float y, ID id, Handler handler, int damage, \n                float angle, float bulletSpeed, int penetration, \n                boolean isExplosive, Color color, int size, GameObject owner) {\n        super(x, y, id);\n        this.handler = handler;\n        this.damage = damage;\n        this.angle = angle;\n        this.speed = bulletSpeed;\n        this.penetration = penetration;\n        this.isExplosive = isExplosive;\n        this.color = color;\n        this.size = size;\n        this.owner = owner;\n        this.bulletImage = defaultBulletImage;\n        this.useImage = false;\n        \n        calculateVelocity();\n    }\n    \n    private void calculateVelocity() {\n        this.velX = (float) Math.cos(angle) * speed;\n        this.velY = (float) Math.sin(angle) * speed;\n        \n        if (Math.abs(velX) < 0.01 && Math.abs(velY) < 0.01) {\n      \n            this.velX = (float) Math.cos(angle) * 5.0f;\n            this.velY = (float) Math.sin(angle) * 5.0f;\n        }\n        \n        \n    }\n\n    @Override\n    public void tick() {\n        x += velX;\n        y += velY;\n        \n        lifeSpan--;\n        if(lifeSpan <= 0) {\n            if (isExplosive) {\n                createExplosion();\n            }\n            handler.removeObject(this);\n            return;\n        }\n        if (checkMapCollision()) {\n            return; \n        }\n        checkEnemyCollision();\n    }\n    \n    private boolean checkMapCollision() {\n        Map map = null;\n        for(int i = 0; i < handler.object.size(); i++) {\n            if(handler.object.get(i).getId() == ID.Player) {\n                Player player = (Player) handler.object.get(i);\n                map = player.map;\n                break;\n            }\n        }\n        \n        if(map != null) {\n            int blockSize = 32; \n            int mapX = (int) (x / blockSize);\n            int mapY = (int) (y / blockSize);\n            \n            if(map.isBlock(mapX * blockSize, mapY * blockSize)) {\n                if(isExplosive) {\n                    createExplosion();\n                    handler.removeObject(this);\n                }\n                handler.removeObject(this);\n                return true; \n            }\n        }\n        return false; \n    }\n    \n    private static void loadBulletImage(String weaponType, String imagePath) {\n        try {\n    \n            File imageFile = new File(imagePath);\n            if (imageFile.exists()) {\n                bulletImageCache.put(weaponType, ImageIO.read(imageFile));\n                return;\n            }\n            \n            InputStream is = Bullet.class.getResourceAsStream(\"/\" + imagePath);\n            if (is != null) {\n                bulletImageCache.put(weaponType, ImageIO.read(is));\n                return;\n            }\n            \n            imageFile = new File(\"src/\" + imagePath);\n            if (imageFile.exists()) {\n                bulletImageCache.put(weaponType, ImageIO.read(imageFile));\n                return;\n            }\n        } catch (Exception e) {\n            System.err.println(\"HATA: \" + weaponType + \" mermi görseli yüklenemedi: \" + e.getMessage());\n        }\n    }\n    \n    public void setBulletImage(BufferedImage image) {\n        if (image != null) {\n            this.bulletImage = image;\n            this.useImage = true;\n        } else {\n            this.useImage = false;\n        }\n    }\n    \n    public void setBulletImage(String imagePath) {\n        try {\n            File imageFile = new File(imagePath);\n            if (imageFile.exists()) {\n                this.bulletImage = ImageIO.read(imageFile);\n                this.useImage = true;\n                return;\n            }\n            \n            InputStream is = getClass().getResourceAsStream(imagePath);\n            if (is != null) {\n                this.bulletImage = ImageIO.read(is);\n                this.useImage = true;\n                return;\n            }\n            \n            imageFile = new File(\"src\" + imagePath);\n            if (imageFile.exists()) {\n                this.bulletImage = ImageIO.read(imageFile);\n                this.useImage = true;\n                return;\n            }\n            \n            this.useImage = false;\n        } catch (Exception e) {\n            System.err.println(\"Mermi görseli yüklenirken hata: \" + e.getMessage());\n            this.useImage = false;\n        }\n    }\n    \n    private void createExplosion() {        \n        RocketExplosionEffect explosionEffect = new RocketExplosionEffect(\n            x, y, handler, explosionRadius);\n        handler.addObject(explosionEffect);\n        \n        for (int i = 0; i < handler.object.size(); i++) {\n            GameObject tempObject = handler.object.get(i);\n            \n            if (tempObject.getId() == ID.Enemy && owner != tempObject) {\n                float distance = calculateDistance(x, y, tempObject.getX(), tempObject.getY());\n                \n                if (distance <= explosionRadius) {\n                    float damageFactor = 1.0f - (distance / explosionRadius);\n                    int explosionDamage = (int)(damage * damageFactor);\n                    \n                    if (explosionDamage < damage / 4) {\n                        explosionDamage = damage / 4;\n                    }\n                    \n                    if (tempObject instanceof Enemy) {\n                        ((Enemy)tempObject).takeDamage(explosionDamage);\n                    }\n                }\n            }\n            \n            else if (tempObject.getId() == ID.Player && owner != tempObject && \n                    owner != null && owner.getId() == ID.Enemy) {\n                float distance = calculateDistance(x, y, tempObject.getX(), tempObject.getY());\n                \n                if (distance <= explosionRadius) {\n                    float damageFactor = 1.0f - (distance / explosionRadius);\n                    int explosionDamage = (int)(damage * damageFactor);\n                    \n                    if (explosionDamage < damage / 4) {\n                        explosionDamage = damage / 4;\n                    }\n                    \n                    Player player = (Player) tempObject;\n                    player.takeDamage(explosionDamage);\n                }\n            }\n        }\n    }\n\n    private void checkEnemyCollision() {\n        if (isExploding) return;\n\n        for (int i = 0; i < handler.object.size(); i++) {\n            GameObject tempObject = handler.object.get(i);\n\n            if (tempObject.getId() == ID.Enemy && owner != tempObject) {\n                if (getBounds().intersects(tempObject.getBounds())) {\n                    Enemy enemy = (Enemy) tempObject;\n                    enemy.takeDamage(damage);\n\n                    penetration--;\n\n                    if (penetration <= 0) {\n                        if (isExplosive) {\n                            createExplosion();\n                            handler.removeObject(this);\n                            return;\n                        }\n                        handler.removeObject(this);\n                        return; \n                    }\n                    return; \n                }\n            } else if (tempObject.getId() == ID.Player && owner != tempObject &&\n                      owner != null && owner.getId() == ID.Enemy) {\n                if (getBounds().intersects(tempObject.getBounds())) {\n                    Player player = (Player) tempObject;\n                    player.takeDamage(damage);\n\n                    penetration--;\n                    if (penetration <= 0) { \n                        if (isExplosive) {\n                            createExplosion();\n                            handler.removeObject(this);\n                            return;\n                        }\n                        handler.removeObject(this);\n                    }\n                    return;\n                }\n            }\n        }\n    }\n\n    \n    private float calculateDistance(float x1, float y1, float x2, float y2) {\n        return (float) Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    \n    public int getDamage() {\n        return damage;\n    }\n    \n    public float getAngle() {\n        return angle;\n    }\n    \n    public void setDamage(int damage) {\n        this.damage = damage;\n    }\n    \n    public boolean isPiercing() {\n        return isPiercing;\n    }\n    \n    public void setScaleFactor(float scale) {\n        this.scaleFactor = scale;\n    }\n    \n    public boolean isExplosive() {\n        return isExplosive;\n    }\n    \n    public void setExplosive(boolean isExplosive) {\n        this.isExplosive = isExplosive;\n    }\n    \n    public void setPiercing(boolean isPiercing) {\n        this.isPiercing = isPiercing;\n    }\n    \n    public void setShooter(GameObject shooter) {\n        this.shooter = shooter;\n    }\n    \n    public void setExplosionRadius(int radius) {\n        this.explosionRadius = radius;\n    }\n    \n    public int getExplosionRadius() {\n        return explosionRadius;\n    }\n    \n    public static Bullet createBullet(String weaponType, float playerX, float playerY, \n                float angle, float spread, float bulletSpeed, \n                int damage, int penetration, boolean isExplosive, \n                int bulletSize, Color bulletColor, Handler handler, GameObject owner) {\n    \t float finalAngle = angle;\n         if (spread > 0) {\n             finalAngle = angle + (float) ((Math.random() - 0.5) * 2 * spread);\n         }\n         \n         float muzzleLength = 30; \n         \n         float bulletX = playerX + (float)(Math.cos(finalAngle) * muzzleLength);\n         float bulletY = playerY + (float)(Math.sin(finalAngle) * muzzleLength);\n         \n\n         Bullet bullet = new Bullet(\n             bulletX, bulletY, ID.Bullet, handler, damage,\n             finalAngle, bulletSpeed, penetration, isExplosive,\n             bulletColor, bulletSize, owner\n         );\n         \n\n         bullet.velX = (float) Math.cos(finalAngle) * bulletSpeed;\n         bullet.velY = (float) Math.sin(finalAngle) * bulletSpeed;\n         \n         BufferedImage image = bulletImageCache.get(weaponType.toLowerCase());\n         \n         if (image != null) {\n             bullet.setBulletImage(image);\n             bullet.useImage = true;\n         } else {\n             try {\n                 image = ImageIO.read(new File(\"images/\" + weaponType + \"Bullet.png\"));\n                 if (image != null) {\n                     bulletImageCache.put(weaponType.toLowerCase(), image);\n                     bullet.setBulletImage(image);\n                     bullet.useImage = true;\n                 }\n             } catch (IOException e) {\n                 bullet.useImage = false;\n             }\n         }\n\n         if (handler != null) {\n             handler.addObject(bullet);\n         } else {\n             System.err.println(\"HATA: Handler null!\");\n         }\n         \n         return bullet;\n    }\n    \n    @Override\n    public void render(Graphics g) {\n        Camera camera = null;\n        try {\n            for (int i = 0; i < handler.object.size(); i++) {\n                if (handler.object.get(i).getId() == ID.Player) {\n                    Player player = (Player) handler.object.get(i);\n                    camera = player.getCamera();\n                    break;\n                }\n            }\n        } catch (Exception e) {\n        }\n        \n        float renderX = x;\n        float renderY = y;\n\n        if (camera != null) {\n            renderX = x - camera.getX();\n            renderY = y - camera.getY();\n        }\n        \n        Graphics2D g2d = (Graphics2D) g;\n\n        AffineTransform oldTransform = g2d.getTransform();\n        \n        AffineTransform at = new AffineTransform();\n        \n        at.translate(renderX - width / 2, renderY - height / 2);\n        \n        at.rotate(angle, width / 2, height / 2);\n        \n        g2d.setTransform(at);\n        \n        if (useImage && bulletImage != null) {\n            g2d.drawImage(bulletImage, 0, 0, width, height, null);\n        } else {\n            g2d.setColor(color != null ? color : Color.YELLOW);\n            g2d.fillRect(0, 0, width, height);\n        }\n        \n        g2d.setTransform(oldTransform);\n        \n    }\n\n    @Override\n    public Rectangle getBounds() {\n    \treturn new Rectangle( \n                (int)(x - width / 2), \n                (int)(y - height / 2), \n                width, \n                height\n            );\n    }\n}\n",
      "FileIO.java": "package ödev2;\n\nimport java.io.*;\n\npublic class FileIO {\n    private static final String SAVE_FILE_PATH = \"game_save.dat\";\n    \n    public static void saveGame(GameSave gameSave) {\n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(SAVE_FILE_PATH))) {\n            oos.writeObject(gameSave);\n            System.out.println(\"Oyun kaydedildi!\");\n        } catch (IOException e) {\n            System.err.println(\"Oyun kaydedilirken hata oluştu: \" + e.getMessage());\n        }\n    }\n    \n    public static GameSave loadGame() {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(SAVE_FILE_PATH))) {\n            GameSave gameSave = (GameSave) ois.readObject();\n            System.out.println(\"Oyun yüklendi!\");\n            return gameSave;\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Oyun yüklenirken hata oluştu: \" + e.getMessage());\n            return null;\n        }\n    }\n}\n\n",
      "Shotgun.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class Shotgun extends Weapon {\n    private static final int PELLET_COUNT = 9; // Saçma tanesi sayısı\n    private static final float SPREAD_ANGLE_DEGREES = 45.0f; // 45 derecelik yay\n\n    public Shotgun() {\n        super();\n\n        this.magazineSize = 5;\n        this.currentAmmo = magazineSize;\n        this.totalAmmo = 15;\n        this.damage = 8; \n        this.spread = (float) Math.toRadians(5.0); \n        this.bulletSpeed = 8.0f;\n        this.bulletSize = 4;\n        this.hasInfiniteAmmo = false;\n        this.isPiercing = false;\n        this.isExplosive = false;\n        this.penetration = 1;\n        \n        this.timeBetweenShots = 0.8f; // 0.8 saniye iki atış arası \n        this.isAutomatic = false;    \n        \n        try {\n      \tweaponIcon = ImageIO.read(new File(\"src/images/Shotgun.png\"));\n      } catch (IOException e) {\n          //System.err.println(\"Silah simgesi yüklenemedi: \" + e.getMessage());\n      }\n        \n       \n    }\n\n    @Override\n    public int getMagazineCapacity() {\n        return 5; \n    }\n\n    @Override\n    public int getFireRate() {\n        return 60; \n    }\n    \n    @Override\n    protected void createBullet(float angle, float playerX, float playerY) {\n        float startAngle = angle - (float) Math.toRadians(SPREAD_ANGLE_DEGREES / 2);\n        float angleStep = (float) Math.toRadians(SPREAD_ANGLE_DEGREES) / (PELLET_COUNT - 1);\n        \n        for (int i = 0; i < PELLET_COUNT; i++) {\n            float pelletAngle = startAngle + (angleStep * i);\n            \n            pelletAngle += (float) ((Math.random() - 0.5) * 2 * spread);\n            \n          \n            Bullet pellet = Bullet.createBullet(\n                \"shotgun\",             \n                playerX, playerY,      \n                pelletAngle,         \n                spread,              \n                bulletSpeed,        \n                damage,                \n                penetration,           \n                isExplosive,           \n                bulletSize,            \n                Color.RED,             \n                handler,               \n                handler.getPlayer()    \n            );\n            \n            if (handler != null) {\n                handler.addObject(pellet);\n            } else {\n                System.err.println(\"HATA: Shotgun - handler null!\");\n            }\n        }\n    }\n\n\t@Override\n\tprotected void loadShootSound() {\n\t\tshootSound = new SoundPlayer(\"sounds/shotgun_shot.wav\");\n\t\t\n\t}\n}\n",
      "NormalZombie.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\nimport javax.imageio.ImageIO;\n\npublic class NormalZombie extends Enemy {\n    private static final int HEALTH = 100;  // Orta\n    private static final float SPEED = 1.0f; // Yavaş\n    private static final int DAMAGE = 20;   // Orta\n    \n\n    public NormalZombie(float x, float y,ZombieType type, Handler handler, Map map , WaveManager waveManager) {\n        super(x, y, ID.Enemy,type, handler, map, waveManager);\n        this.health = HEALTH;\n        \n        try {\n            // Eğer üst sınıfta resim yüklenemezse, burada tekrar dene\n            if (zombieImage == null) {\n                //System.out.println(\"Resim Dosya Yolu: \" + new File(\"src/images/NormalZombie.png\").getAbsolutePath());\n                zombieImage = ImageIO.read(new File(\"src/images/NormalZombie.png\"));\n            }\n        } catch (IOException e) {\n           // System.err.println(\"Zombi resmi yüklenemedi: \" + e.getMessage());\n        }\n    }\n\n    @Override\n    public void render(Graphics g) {\n    \tint width = 32; \n        int height = 32;\n        if (zombieImage != null) {\n            g.drawImage(zombieImage, (int)x, (int)y, width, height, null);\n        } else {\n            g.setColor(Color.GREEN);\n            g.fillRect((int)x, (int)y, width, height);\n        }\n\n        g.setColor(Color.RED);\n        g.fillRect((int)x, (int)y - 10, width, 5);\n        g.setColor(Color.GREEN);\n        g.fillRect((int)x, (int)y - 10, (int)(width * ((float)health / maxHealth)), 5);\n    \n    }\n}\n",
      "ID.java": "package ödev2;\n\npublic enum ID {\n\tPlayer,\n\tZombie,\n\tBlock,\n\tBullet, \n\tEnemy, \n\tEnemyProjectile, \n\tAmmoClip, \n\tEffect,\n\tAidKit,\n\tSpeedBooster,\n}\n",
      "AmmoClipData.java": "package ödev2;\n\nimport java.io.Serializable;\n\nimport java.io.Serializable;\n\npublic class AmmoClipData implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private float x;\n    private float y;\n    private boolean collected; \n\n    public AmmoClipData(float x, float y, boolean collected) {\n        this.x = x;\n        this.y = y;\n        this.collected = collected;\n    }\n\n\n    public float getX() {\n        return x;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public float getY() {\n        return y;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public boolean isCollected() {\n        return collected;\n    }\n\n    public void setCollected(boolean collected) {\n        this.collected = collected;\n    }\n}",
      "AcidProjectile.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class AcidProjectile extends GameObject {\n    private float velX, velY;\n    private static final float SPEED = 5.0f;\n    Handler handler;\n    private int lifeSpan = 10 * 60;\n    private Map map;\n    private int range = 6 * 32; // 5 blok menzil\n    private float distanceTraveled = 0;\n    private int immunityFrames = 10;\n    private GameObject shooter;\n\n    public AcidProjectile(float x, float y, Handler handler, float angle, Map map, GameObject shooter) {\n        super(x, y, ID.EnemyProjectile); \n        this.handler = handler;\n        this.map = map;\n        this.shooter = shooter;\n        velX = (float) (SPEED * Math.cos(angle));\n        velY = (float) (SPEED * Math.sin(angle));\n    }\n\n    @Override\n    public void tick() {\n        x += velX;\n        y += velY;\n        \n        if (immunityFrames > 0) {\n            immunityFrames--;\n        }\n        \n        lifeSpan--;\n        if (lifeSpan <= 0) {\n            handler.removeObject(this);\n            return;\n        }\n\n        if (map.isBlock((int)x, (int)y)) {\n            handler.removeObject(this);\n            return;\n        }\n        \n        distanceTraveled += Math.sqrt(velX * velX + velY * velY);\n        if (distanceTraveled >= range) {\n            handler.removeObject(this);\n            return;\n        }\n        \n        checkCollision();\n    }\n\n    private void checkCollision() {\n        List<GameObject> objectsToProcess = new ArrayList<>();\n        boolean removeProjectile = false;\n        \n        for (int i = 0; i < handler.object.size(); i++) {\n            GameObject obj = handler.object.get(i);\n            \n            if (immunityFrames > 0 && obj == shooter) {\n                continue;\n            }\n            \n            if (obj.getId() == ID.Player && getBounds().intersects(obj.getBounds())) {\n                objectsToProcess.add(obj);\n                removeProjectile = true;\n                break;\n            } else if (obj != this && obj != shooter && obj.getId() != ID.Enemy && getBounds().intersects(obj.getBounds())) {\n                removeProjectile = true;\n                break;\n            }\n        }\n        \n        for (GameObject obj : objectsToProcess) {\n            if (obj.getId() == ID.Player) {\n                Player player = (Player) obj;\n//                player.setHealth(player.getHealth() - 20);\n                player.takeDamage(20);\n            }\n        }\n        \n        if (removeProjectile) {\n            handler.removeObject(this);\n        }\n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(Color.GREEN); \n        g.fillOval((int) x, (int) y, 8, 8); \n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle((int) x, (int) y, 8, 8);\n    }\n}",
      "KamikazeZombie.java": "package ödev2;\n\nimport java.awt.AlphaComposite;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.RadialGradientPaint;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class KamikazeZombie extends Enemy {\n    private static final int EXPLOSION_DAMAGE = 15;\n    private static final float EXPLOSION_RADIUS = 120f;\n    private static final float EXPLOSION_THRESHOLD = 50f;\n    private boolean isExploding = false;\n    private long explosionStartTime = 0;\n    private static final long EXPLOSION_DURATION = 500; // milliseconds\n    private float flashTimer = 0;\n    private boolean flashState = false;\n    \n    public KamikazeZombie(float x, float y, ZombieType type, Handler handler, Map map, WaveManager waveManager) {\n        super(x, y, ID.Enemy, type, handler, map, waveManager);\n        this.health = 70;\n        this.maxHealth = 70;\n        this.speed = 1.5f; \n        this.damage = 5; \n        \n        try {\n            \n            if (zombieImage == null) {\n                //System.out.println(\"Resim Dosya Yolu: \" + new File(\"src/images/CrawlerZombie.png\").getAbsolutePath());\n                zombieImage = ImageIO.read(new File(\"src/images/KamikazeZombie.png\"));\n            }\n        } catch (IOException e) {\n            //System.err.println(\"Zombi resmi yüklenemedi: \" + e.getMessage());\n        }\n    }\n    \n    @Override\n    public void tick() {\n        if (!isActive()) return;\n        \n        if (isExploding) {\n            handleExplosion();\n            return;\n        }\n\n        super.tick();\n        \n        // Check distance to player for explosion\n        float dx = player.getX() - x;\n        float dy = player.getY() - y;\n        float distanceToPlayer = (float) Math.sqrt(dx * dx + dy * dy);\n        \n        if (distanceToPlayer <= EXPLOSION_THRESHOLD) {\n            startExplosion();\n        }\n        \n        if (distanceToPlayer < 150) {\n            flashTimer += 0.1f;\n            if (flashTimer > 0.2f) {\n                flashState = !flashState;\n                flashTimer = 0;\n            }\n        }\n    }\n    \n    private void startExplosion() {\n        isExploding = true;\n        explosionStartTime = System.currentTimeMillis();\n        velX = 0;\n        velY = 0;\n    }\n    \n    private void handleExplosion() {\n        long currentTime = System.currentTimeMillis();\n        long elapsedTime = currentTime - explosionStartTime;\n        \n        if (elapsedTime >= EXPLOSION_DURATION) {\n            explode();\n        }\n    }\n    \n    private void explode() {\n        for (GameObject obj : handler.getObjects()) {\n            if (obj.getId() == ID.Player) {\n                float dx = obj.getX() - x;\n                float dy = obj.getY() - y;\n                float distance = (float) Math.sqrt(dx * dx + dy * dy);\n                \n                if (distance <= EXPLOSION_RADIUS) {\n                    float damageFactor = 1 - (distance / EXPLOSION_RADIUS);\n                    int actualDamage = (int)(EXPLOSION_DAMAGE * damageFactor);\n                    ((Player)obj).takeDamage(actualDamage);\n                }\n            }\n        }\n\n        ExplosionEffect explosion = new ExplosionEffect(x - 32, y - 32, ID.Effect, handler);\n        handler.addObject(explosion);\n        \n        kill();\n    }\n    \n    @Override\n    public void render(Graphics g) {\n        if (!isVisible()) return;\n\n        if (isExploding) {\n            // Render pre-explosion animation\n            long elapsedTime = System.currentTimeMillis() - explosionStartTime;\n            float scale = 1.0f + (elapsedTime / (float)EXPLOSION_DURATION) * 0.5f;\n\n            Graphics2D g2d = (Graphics2D) g;\n            AffineTransform oldTransform = g2d.getTransform();\n\n            g2d.translate(x + 16, y + 16);\n            g2d.scale(scale, scale);\n            g2d.translate(-16, -16);\n\n            g2d.drawImage(zombieImage, 0, 0, 32, 32, null);\n\n            Composite oldComposite = g2d.getComposite();\n            g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.7f));\n\n            RadialGradientPaint gradient = new RadialGradientPaint(\n                16, 16, 20 * scale,\n                new float[] {0.0f, 0.7f, 1.0f},\n                new Color[] {\n                    new Color(255, 100, 0, 180),  \n                    new Color(255, 40, 0, 150),   \n                    new Color(180, 30, 0, 100)    \n                }\n            );\n            \n            g2d.setPaint(gradient);\n            g2d.fillOval(-10, -10, 52, 52);\n            g2d.setComposite(oldComposite);\n\n            g2d.setTransform(oldTransform);\n        } else {\n            if (flashState && flashTimer > 0) {\n                Graphics2D g2d = (Graphics2D) g;\n                g2d.setColor(new Color(255, 0, 0, 100));\n                g2d.drawImage(zombieImage, (int)x, (int)y, 32, 32, null);\n                g2d.fillRect((int)x, (int)y, 32, 32);\n            } else {\n                g.drawImage(zombieImage, (int)x, (int)y, 32, 32, null);\n            }\n            g.setColor(Color.RED);\n            g.fillRect((int)x, (int)y - 10, width, 5);\n            g.setColor(Color.GREEN);\n            g.fillRect((int)x, (int)y - 10, (int)(width * ((float)health / maxHealth)), 5);\n        }\n    }\n\n}\n\n",
      "KeyInput.java": "package ödev2;\n\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\npublic class KeyInput extends KeyAdapter {\n\n    private boolean[] keysDown = new boolean[128];\n    Handler handler;\n    private Game game;\n    \n    public KeyInput(Handler handler, Game game) {\n    \tthis.handler = handler;\n    \tthis.game = game;\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int key = e.getKeyCode();\n        if (key >= 0 && key < keysDown.length) {\n            keysDown[key] = true;\n        }\n        \n        if (game.getGameState() == GameState.MENU) { \n            for (int i = 0; i < keysDown.length; i++) {\n                keysDown[i] = false;\n            }\n        }\n        \n        if (key == KeyEvent.VK_ESCAPE) {\n            if (game.getGameState() == GameState.PLAYING) {\n                game.pauseGame();\n            } else if (game.getGameState() == GameState.PAUSED) {\n                game.resumeGame();\n            }\n            return;\n        }\n        if (game.getGameState() == GameState.PLAYING) {\n            if (key >= 0 && key < keysDown.length) {\n                keysDown[key] = true;\n            }\n            \n            if (key == KeyEvent.VK_1) { handler.getPlayer().switchWeapon(0); } \n            if (key == KeyEvent.VK_2) { handler.getPlayer().switchWeapon(1); }\n            if (key == KeyEvent.VK_3) { handler.getPlayer().switchWeapon(2); }\n            if (key == KeyEvent.VK_4) { handler.getPlayer().switchWeapon(3); }\n            if (key == KeyEvent.VK_5) { handler.getPlayer().switchWeapon(4); }\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n\n        int key = e.getKeyCode();\n        if (key >= 0 && key < keysDown.length) {\n            keysDown[key] = false;\n        }\n\n        // Tuş bırakıldığında hızı sıfırla\n        if (key == KeyEvent.VK_D || key == KeyEvent.VK_A) {\n            handler.getPlayer().setVelX(0); \n        }\n        if (key == KeyEvent.VK_W || key == KeyEvent.VK_S) {\n            handler.getPlayer().setVelY(0); \n        }\n    }\n        \n    \n\n    public boolean isKeyDown(int keyCode) {\n        if (keyCode >= 0 && keyCode < keysDown.length) {\n            return keysDown[keyCode];\n        } else {\n            return false;\n        }\n    }\n}\n",
      "Enemy.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class Enemy extends GameObject {\n\n\tHandler handler;\n    protected Player player;\n    \n    private int sightRange = 18 * 32; // 18 blok görüş mesafesi (piksel cinsinden)\n    private int moveDistance = 12 * 32; // 12 blok hareket mesafesi (piksel cinsinden)\n    private int moveDirection = 1; // 1: Sağa/Aşağı, -1: Sola/Yukarı\n    private float startX, startY; // Başlangıç konumu\n    Map map;\n    protected float oldX;\n\tprotected float oldY;\n    private int patrolRadius = 4 * 32;\n    private boolean isReturningToStart = false;\n    protected ZombieType type;\n    protected float speed;\n    protected long lastAttackTime; // Son saldırı zamanı\n    protected final long ATTACK_COOLDOWN = 1000; // Saldırı bekleme süresi (1 saniye = 1000 ms)\n    Camera cam;\n    protected int damage;\n    private WaveManager waveManager;\n    protected BufferedImage zombieImage;\n    protected String imagePath;\n    protected boolean isDead = false;\n    private boolean active = true;\n    private boolean visible = true;\n    private boolean isStuck = false;\n    private int stuckCounter = 0;\n    private int stuckThreshold = 30; \n    private int escapeMode = 0;\n    private int escapeDuration = 0;\n    private float lastMovementDistance = 0;\n    private float previousX, previousY;\n    \n    \n\n    public Enemy(float x, float y, ID id,ZombieType type, Handler handler, Map map, WaveManager waveManager) {\n        super(x, y, id);\n        this.handler = handler;\n        this.waveManager = waveManager;\n        this.startX = x; \n        this.startY = y;\n        this.map = map;\n        this.oldX = x;\n        this.oldY = y;\n        this.type = type;\n        this.lastAttackTime = 0;\n\n        // Player'ı bul\n        for (GameObject obj : handler.object) {\n            if (obj.getId() == ID.Player) {\n                this.player = (Player) obj;\n                break;\n            }\n        }\n        switch (type) {\n        case NORMAL:\n            this.health = 100;   // Orta\n            this.maxHealth = 100;\n            this.speed = 1.5f;  // Yavaş hareket\n            this.damage = 10;\n            break;\n        case CRAWLER:\n            this.health = 70;   // Düşük\n            this.maxHealth = 60;\n            this.speed = 2f;  // Hızlı hareket\n            this.damage = 10;\n            break;\n        case TANK:\n            this.health = 200;  // Yüksek\n            this.maxHealth = 200;\n            this.speed = 1f;  // Çok yavaş hareket\n            this.damage = 15;\n            break;\n        case ACID_SPITTER:\n            this.health = 70;   // Düşük\n            this.maxHealth = 60;\n            this.speed = 1.5f;  // Yavaş hareket\n            this.damage = 10;\n            break;\n        case KAMIKAZE:\n            this.health = 70;\n            this.maxHealth = 70;\n            this.speed = 1.5f; \n            this.damage = 5; \n            break;\n    }\n        String imageType = getZombieImageType();\n        if (imageType != null) {\n            zombieImage = ImageCache.getImage(\"/images/\" + imageType);\n        }\n        \n        try {\n            String imagePath = \"/images/\" + getClass().getSimpleName() + \".png\";\n            //System.out.println(\"Resource yükleme deneniyor: \" + imagePath);\n            zombieImage = ImageIO.read(getClass().getResourceAsStream(imagePath));\n            \n            if (zombieImage == null) {\n                //System.out.println(\"Resource stream yüklemesi başarısız, dosya yolu denenecek.\");\n            }\n        } catch (Exception e) {\n            //System.out.println(\"Resource yüklemesi başarısız: \" + e.getMessage());\n        }\n    \n    }\n    \n    private String getZombieImageType() {\n        if (this instanceof NormalZombie) return \"NormalZombie.png\";\n        if (this instanceof TankZombie) return \"TankZombie.png\";\n        if (this instanceof CrawlerZombie) return \"CrawlerZombie.png\";\n        if (this instanceof AcidSpitterZombie) return \"AcidSpitterZombie.png\";\n        return null;\n    }\n    \n    @Override\n    public void tick() {\n    \tif (!active) return;\n    \t\n        oldX = x; \n        oldY = y;\n        previousX = x;\n        previousY = y;\n\n        \n        if (canSeePlayer() && isInRangeOfPlayer()) {\n            isReturningToStart = false;\n            moveToPlayer();\n            attackPlayer();\n        } else {\n\n            if (!isReturningToStart) {\n                isReturningToStart = true;\n            }\n            returnToStart();\n        }\n\n        x += velX;\n        y += velY;\n        checkCollision();\n        detectStuckState();\n        float movedDistance = (float) Math.sqrt(\n                Math.pow(x - previousX, 2) + \n                Math.pow(y - previousY, 2)\n            );\n            \n            lastMovementDistance = movedDistance;\n        }\n\n    private void detectStuckState() {\n      \n        if (lastMovementDistance < 0.1f) {\n            stuckCounter++;\n            if (stuckCounter >= stuckThreshold) {\n                isStuck = true;\n   \n                if (escapeDuration <= 0) {\n                    escapeMode = (escapeMode + 1) % 4;\n                    escapeDuration = 60; \n                }\n                applyEscapeBehavior();\n                escapeDuration--;\n            }\n        } else {\n        \n            stuckCounter = 0;\n            isStuck = false;\n        }\n    }\n    \n    private void applyEscapeBehavior() {\n      \n        switch (escapeMode) {\n            case 0: \n                velX = speed;\n                velY = -speed;\n                break;\n            case 1: \n                velX = speed;\n                velY = speed;\n                break;\n            case 2: \n                velX = -speed;\n                velY = speed;\n                break;\n            case 3: \n                velX = -speed; \n                velY = -speed;\n                break;\n        }\n    }\n    private boolean canSeePlayer() {\n        int x1 = (int) x;\n        int y1 = (int) y;\n        int x2 = (int) player.getX();\n        int y2 = (int) player.getY();\n\n\n        int dx = Math.abs(x2 - x1);\n        int dy = Math.abs(y2 - y1);\n        int sx = x1 < x2 ? 1 : -1;\n        int sy = y1 < y2 ? 1 : -1;\n        int err = (dx > dy ? dx : -dy) / 2;\n\n        while (true) {\n            if (map.isBlock(x1, y1)) {\n                return false; \n            }\n            if (x1 == x2 && y1 == y2) {\n                break;\n            }\n            int e2 = err;\n            if (e2 > -dx) {\n                err -= dy;\n                x1 += sx;\n            }\n            if (e2 < dy) {\n                err += dx;\n                y1 += sy;\n            }\n        }\n\n        return true; \n    }\n\n    private void returnToStart() {\n    \t    float dx = startX - x;\n    \t    float dy = startY - y;\n\n    \t    float distanceToStart = (float) Math.sqrt(dx * dx + dy * dy);\n\n    \t    if (distanceToStart > 1) {\n    \t        velX = (dx / distanceToStart);\n    \t        velY = (dy / distanceToStart);\n    \t    } else {\n    \t   \n    \t    \tx = startX; \n    \t        y = startY;\n    \t        velX = 0;\n    \t        velY = 0;\n\n    \t        moveDirection = -moveDirection; \n    \t        velX = 2 * moveDirection; \n        }\n    }\n    protected boolean isInRangeOfPlayer() {\n        return Math.abs(x - player.getX()) <= sightRange && \n               Math.abs(y - player.getY()) <= sightRange;\n    }\n    private void moveToPlayer() {\n        float diffX = player.getX() - x;\n        float diffY = player.getY() - y;\n        float distance = (float) Math.sqrt(diffX * diffX + diffY * diffY);\n        \n   \n        float dirX = diffX / distance;\n        float dirY = diffY / distance;\n     \n        velX = dirX * speed;\n        velY = dirY * speed;\n    }\n    protected void checkCollision() {\n        int size = 32; \n        boolean collisionX = false;\n        boolean collisionY = false;\n        \n      \n        if (map.isBlock((int) x, (int) y) || \n            map.isBlock((int) x, (int) (y + size - 1)) ||\n            map.isBlock((int) (x + size), (int) y) || \n            map.isBlock((int) (x + size), (int) (y + size - 1))) {\n            \n            x = oldX;\n            velX = 0;\n            collisionX = true;\n        }\n        \n      \n        if (map.isBlock((int) x, (int) y) || \n            map.isBlock((int) (x + size - 1), (int) y) ||\n            map.isBlock((int) x, (int) (y + size)) || \n            map.isBlock((int) (x + size - 1), (int) (y + size))) {\n            \n            y = oldY;\n            velY = 0;\n            collisionY = true;\n        }\n        \n        \n        if (collisionX || collisionY) {\n           \n        \thandleWallCollision(collisionX, collisionY);\n        }\n        \n        for (GameObject other : handler.getObjects()) {\n            if (other != this && other.getId() == ID.Enemy && getBounds().intersects(other.getBounds())) {\n                float diffX = x - other.getX();\n                float diffY = y - other.getY();\n                float distance = (float) Math.sqrt(diffX * diffX + diffY * diffY);\n                \n                if (distance > 0) {\n                  \n                    x += (diffX / distance) * 2.0f;\n                    y += (diffY / distance) * 2.0f;\n                } else {\n                   \n                    x += (Math.random() * 2 - 1) * 2.0f;\n                    y += (Math.random() * 2 - 1) * 2.0f;\n                }\n            }\n        }\n    }\n    \n    private void handleWallCollision(boolean collisionX, boolean collisionY) {\n        float playerX = player.getX();\n        float playerY = player.getY();\n        \n      \n        if (collisionX && !collisionY) {\n           \n            if (y < playerY) velY = speed * 1.5f;  \n            else velY = -speed * 1.5f;            \n        }\n        \n        if (collisionY && !collisionX) {\n            if (x < playerX) velX = speed * 1.5f;  \n            else velX = -speed * 1.5f;            \n        }\n        \n  \n        if (collisionX && collisionY) {\n     \n            velX = (float)(Math.random() * 4 - 2) * speed;\n            velY = (float)(Math.random() * 4 - 2) * speed;\n            \n            if (Math.abs(velX) < 0.5f) velX = (velX > 0) ? 0.5f : -0.5f;\n            if (Math.abs(velY) < 0.5f) velY = (velY > 0) ? 0.5f : -0.5f;\n        }\n    }\n\n    \n        \n    protected void attackPlayer() {\n    \tif (player != null && getBounds().intersects(player.getBounds())) {\n            long currentTime = System.currentTimeMillis();\n          \n            if (currentTime - lastAttackTime >= ATTACK_COOLDOWN) {\n                player.takeDamage(damage);\n                lastAttackTime = currentTime; \n            }\n        }\n    }\n    public void resetState(float x, float y) {\n     \n        this.x = x;\n        this.y = y;\n        this.oldX = x;\n        this.oldY = y;\n        this.startX = x;\n        this.startY = y;\n        \n        this.health = maxHealth;\n        this.isDead = false;\n        this.isReturningToStart = false;\n        this.active = true;\n        this.visible = true;\n        this.velX = 0;\n        this.velY = 0;\n        this.lastAttackTime = 0;\n    }\n    \n    public boolean isActive() {\n        return active && !isDead;\n    }\n    \n    public void setActive(boolean active) {\n        this.active = active;\n    }\n    \n    public boolean isVisible() {\n        return visible;\n    }\n    \n    public void setVisible(boolean visible) {\n        this.visible = visible;\n    }\n\n    public void setHealth(int health) {\n        this.health = health;\n    }\n    public void setImage(BufferedImage image) {\n        this.zombieImage = image;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n    public GameObject getPlayer() {\n        return player;\n    }\n    public void takeDamage(int damage) {\n    \tif (isDead) return;\n    \t\n        this.health -= damage;\n\n        if (this.health <= 0) {\n        \tkill();\n        }\n    }\n    public void kill() {\n     \n        if (isDead) return;\n\n        isDead = true;\n\n        dropAmmoClip();\n        dropAidKit();\n        dropSpeedBooster();\n\n        if (this instanceof AcidSpitterZombie) {\n            ((AcidSpitterZombie)this).onDeath();\n        }\n\n        if (this instanceof TankZombie) {\n            Game.increaseScore(3);\n        } else if (this instanceof CrawlerZombie || this instanceof AcidSpitterZombie) {\n            Game.increaseScore(2);\n        } else {\n            Game.increaseScore(1);\n        }\n\n        setActive(false);\n        setVisible(false);\n        waveManager.zombieDied();\n        \n        handler.removeObject(this);\n\n    }\n    \n    private void dropSpeedBooster() {\n        if (Math.random() < 0.3) {\n            SpeedBooster speedBooster = new SpeedBooster(x, y, ID.SpeedBooster, handler);\n            handler.addObject(speedBooster);\n        }\n    }\n\n    \n    private void dropAmmoClip() {\n\n        if (Math.random() < 0.3) {\n            AmmoClip ammoClip = new AmmoClip(x, y, ID.AmmoClip, handler);\n            handler.addObject(ammoClip);\n        }\n    }\n    \n    private void dropAidKit() {\n        // 30% chance to drop an aid kit\n        if (Math.random() < 0.3) {\n            AidKit aidKit = new AidKit(x, y, ID.AidKit, handler);\n            handler.addObject(aidKit);\n        }\n    }\n\n  \n    @Override\n    public void render(Graphics g) {\n    \tif (!visible) return;\n    \tif (zombieImage != null) {\n            g.drawImage(zombieImage, (int)x, (int)y, 32, 32, null);\n            renderHealthBar(g);\n        } else {\n            \n            if (this instanceof NormalZombie) {\n                g.setColor(Color.YELLOW);\n            } else if (this instanceof TankZombie) {\n                g.setColor(Color.GREEN);\n            } else if (this instanceof AcidSpitterZombie) {\n                g.setColor(Color.GREEN.darker());\n            } else if (this instanceof CrawlerZombie) {\n                g.setColor(Color.ORANGE);\n            } else {\n                g.setColor(Color.RED);\n            }\n            g.fillRect((int)x, (int)y, 32, 32);\n            renderHealthBar(g);\n        }\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle((int) x, (int) y, 32, 32);\n    }\n}",
      "SniperRifle.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class SniperRifle extends Weapon {\n\n    public SniperRifle() {\n        super();\n\n        this.magazineSize = 5;\n        this.currentAmmo = magazineSize;\n        this.totalAmmo = 15;\n        this.damage = 80; \n        this.spread = 0.005f; \n        this.bulletSpeed = 15.0f; \n        this.bulletSize = 8;\n        this.hasInfiniteAmmo = false;\n        this.isPiercing = true; // Delici özelliği\n        this.isExplosive = false;\n        this.penetration = 2;\n        \n        this.timeBetweenShots = 1.3f; // 1.3 saniye iki atış arası \n        this.isAutomatic = false; \n        \n        try {\n      \tweaponIcon = ImageIO.read(new File(\"src/images/SniperRifle.png\"));\n      } catch (IOException e) {\n         //System.err.println(\"Silah simgesi yüklenemedi: \" + e.getMessage());\n      }\n       \n    }\n\n    @Override\n    public int getMagazineCapacity() {\n        return 5; \n    }\n\n    @Override\n    public int getFireRate() {\n        return 30; \n    }\n    \n    @Override\n    protected void createBullet(float angle, float playerX, float playerY) {\n    \t float finalAngle = angle + (float) ((Math.random() - 0.5) * 2 * spread);\n\n         Bullet bullet = Bullet.createBullet(\n             \"sniper\",             \n             playerX, playerY,     \n             finalAngle,           \n             spread,                \n             bulletSpeed,           \n             damage,                \n             penetration,           \n             isExplosive,           \n             bulletSize,            \n             Color.RED,           \n             handler,              \n             handler.getPlayer()    \n         );\n         \n         if (handler != null) {\n             handler.addObject(bullet);\n         } else {\n             System.err.println(\"HATA: SniperRifle - handler null!\");\n         }\n    }\n\n\t@Override\n\tprotected void loadShootSound() {\n\t\tshootSound = new SoundPlayer(\"sounds/sniper_shot.wav\");\n\t\t\n\t}\n}\n\n",
      "Block.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Block extends GameObject {\n\n\tpublic Block(float x, float y, ID id) {\n\t\tsuper(x, y, id);\n\t\n\t}\n\n\t@Override\n\tpublic void tick() {}\n\n\t@Override\n\tpublic void render(Graphics g) {\n\t\tg.setColor(Color.GRAY);\n        g.fillRect((int)x, (int)y, 32, 32);\n\t\t\n\t}\n\n\t@Override\n\tpublic Rectangle getBounds() {\n\t\treturn new Rectangle((int)x, (int)y, 32, 32);\n\t}\n\n}\n",
      "ZombieSpawner.java": "package ödev2;\n\nimport java.awt.Rectangle;\nimport java.util.Random;\n\npublic class ZombieSpawner {\n    private Handler handler;\n    private Map map;\n    private Random rand;\n    private static final int TILE_SIZE = 32; \n    private static final float SAFE_MARGIN = 0.75f; \n    private static final int WALL_BUFFER = 8; // Duvardan minimum uzaklık \n    Camera cam;\n    private WaveManager waveManager;\n    \n    public ZombieSpawner(Handler handler, Map map, WaveManager waveManager) {\n        this.handler = handler;\n        this.map = map;\n        this.waveManager = waveManager;\n        this.rand = new Random();\n    }\n\n    public int spawnRandomZombies(int count) {\n        int successfulSpawns = 0;\n        for (int i = 0; i < count; i++) {\n            if (spawnRandomZombie()) {\n                successfulSpawns++;\n            }\n        }\n        return successfulSpawns; \n    }\n\n    \tprivate boolean spawnRandomZombie() {\n    \t\tZombieType type = getRandomZombieType();\n            Position spawnPos = findValidSpawnPosition(type);\n\n            if (spawnPos != null) {\n                float pixelX = spawnPos.x;\n                float pixelY = spawnPos.y;\n\n                Rectangle zombieHitbox = getZombieHitbox(type, pixelX, pixelY);\n\n                if (isHitboxCollidingWithWalls(zombieHitbox) || isHitboxTooCloseToWall(zombieHitbox)) {\n               \n                    spawnPos = findFallbackSpawnPositionWithValidation(type);\n                    if (spawnPos == null) {\n                        return false; \n                    }\n                    pixelX = spawnPos.x;\n                    pixelY = spawnPos.y;\n\n                    zombieHitbox = getZombieHitbox(type, pixelX, pixelY);\n                    if (isHitboxCollidingWithWalls(zombieHitbox) || isHitboxTooCloseToWall(zombieHitbox)) {\n                        return false; \n                    }\n                }\n\n                GameObject zombie = createZombieByType(type, pixelX, pixelY);\n\n                if (zombie != null) {\n                \n                    zombieHitbox = getZombieHitbox(type, pixelX, pixelY);\n                    if (!isHitboxCollidingWithWalls(zombieHitbox) && !isHitboxTooCloseToWall(zombieHitbox) && \n                        !isHitboxCollidingWithZombies(zombieHitbox)) {\n                        handler.addObject(zombie);\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n            return false;\n    }\n    \n\n    private Position findValidSpawnPosition(ZombieType type) {\n    \t  int maxAttempts = 500; \n          int attempt = 0;\n\n          Player player = findPlayer();\n          int playerTileX = 0;\n          int playerTileY = 0;\n\n          if (player != null) {\n              playerTileX = (int)(player.getX() / TILE_SIZE);\n              playerTileY = (int)(player.getY() / TILE_SIZE);\n          }\n\n          while (attempt < maxAttempts) {\n     \n              int x = rand.nextInt(map.getMapWidth() - 6) + 3;\n              int y = rand.nextInt(map.getMapHeight() - 6) + 3;\n\n              if (!map.isInBounds(x, y) || !map.isTileEmpty(x, y)) {\n                  attempt++;\n                  continue;\n              }\n\n              if (player != null) {\n                  int distanceX = Math.abs(x - playerTileX);\n                  int distanceY = Math.abs(y - playerTileY);\n                  double distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n                  if (distance < 8) {\n                      attempt++;\n                      continue; \n                  }\n              }\n\n              int requiredWidth = (type == ZombieType.TANK) ? 2 : 1;\n              int requiredHeight = (type == ZombieType.TANK) ? 2 : 1;\n\n              int safetyBuffer = 1; \n              if (isAreaTrulyEmpty(x - safetyBuffer, y - safetyBuffer, \n                                  requiredWidth + (2 * safetyBuffer), \n                                  requiredHeight + (2 * safetyBuffer))) {\n\n                  int spawnX = (x * TILE_SIZE) + (requiredWidth * TILE_SIZE / 2);\n                  int spawnY = (y * TILE_SIZE) + (requiredHeight * TILE_SIZE / 2);\n\n                  Rectangle zombieHitbox = getZombieHitbox(type, spawnX, spawnY);\n                  if (!isHitboxCollidingWithWalls(zombieHitbox) && \n                      !isHitboxTooCloseToWall(zombieHitbox) && \n                      !isHitboxCollidingWithZombies(zombieHitbox)) {\n                      return new Position(spawnX, spawnY);\n                  }\n              }\n\n              attempt++;\n          }\n\n          return findFallbackSpawnPositionWithValidation(type);\n    }\n    private boolean isHitboxTooCloseToWall(Rectangle hitbox) {\n        Rectangle expandedHitbox = new Rectangle(\n            hitbox.x - WALL_BUFFER,\n            hitbox.y - WALL_BUFFER,\n            hitbox.width + (WALL_BUFFER * 2),\n            hitbox.height + (WALL_BUFFER * 2)\n        );\n        \n        for (int i = 0; i < handler.object.size(); i++) {\n            GameObject tempObject = handler.object.get(i);\n            if (tempObject instanceof Block) {\n                Block wall = (Block) tempObject;\n                Rectangle wallRect = new Rectangle(\n                    (int)wall.getX(),\n                    (int)wall.getY(),\n                    32, 32\n                );\n\n                if (expandedHitbox.intersects(wallRect)) {\n                    return true; \n                }\n            }\n        }\n        return false; \n    }\n    \n    private Rectangle getZombieHitbox(ZombieType type, float x, float y) {\n        int width = (type == ZombieType.TANK) ? TILE_SIZE * 2 : TILE_SIZE;\n        int height = (type == ZombieType.TANK) ? TILE_SIZE * 2 : TILE_SIZE;\n\n        float margin = 0.9f; \n        int safeWidth = (int)(width * margin);\n        int safeHeight = (int)(height * margin);\n\n        return new Rectangle(\n            (int)(x - safeWidth/2),\n            (int)(y - safeHeight/2),\n            safeWidth,\n            safeHeight\n        );\n    }\n\n    private boolean isHitboxCollidingWithWalls(Rectangle hitbox) {\n\n        for (int i = 0; i < handler.object.size(); i++) {\n            GameObject tempObject = handler.object.get(i);\n            if (tempObject instanceof Block) {\n                Block wall = (Block) tempObject;\n                Rectangle wallRect = new Rectangle(\n                    (int)wall.getX(), \n                    (int)wall.getY(), \n                    32, 32\n                );\n\n                if (hitbox.intersects(wallRect)) {\n                    return true; \n                }\n            }\n        }\n        \n        return false; \n    }\n    \n    private GameObject createZombieByType(ZombieType type, float x, float y) {\n        switch (type) {\n        case NORMAL:\n            return new NormalZombie(x, y,ZombieType.NORMAL,  handler, map, waveManager);\n        case CRAWLER:\n            return new CrawlerZombie(x, y,ZombieType.CRAWLER, handler, map, waveManager);\n        case TANK:\n            return new TankZombie(x, y, ZombieType.TANK ,handler, map, waveManager);\n        case ACID_SPITTER:\n            return new AcidSpitterZombie(x, y, ZombieType.ACID_SPITTER, handler, map, waveManager);\n        case KAMIKAZE:\n            return new KamikazeZombie(x, y, ZombieType.KAMIKAZE, handler, map, waveManager);\n        default:\n            return new NormalZombie(x, y,ZombieType.NORMAL, handler, map, waveManager); // Varsayılan olarak NormalZombie\n    }\n    }\n    private boolean isHitboxCollidingWithZombies(Rectangle hitbox) {\n        for (int i = 0; i < handler.object.size(); i++) {\n            GameObject tempObject = handler.object.get(i);\n            if (tempObject instanceof NormalZombie || \n                tempObject instanceof CrawlerZombie || \n                tempObject instanceof TankZombie || \n                tempObject instanceof AcidSpitterZombie) {\n\n                Rectangle existingZombieHitbox;\n\n                if (tempObject instanceof TankZombie) {\n                    existingZombieHitbox = new Rectangle(\n                        (int)tempObject.getX() - TILE_SIZE,\n                        (int)tempObject.getY() - TILE_SIZE,\n                        TILE_SIZE * 2,\n                        TILE_SIZE * 2\n                    );\n                } else {\n                    existingZombieHitbox = new Rectangle(\n                        (int)tempObject.getX() - TILE_SIZE/2,\n                        (int)tempObject.getY() - TILE_SIZE/2,\n                        TILE_SIZE,\n                        TILE_SIZE\n                    );\n                }\n\n                if (hitbox.intersects(existingZombieHitbox)) {\n                    return true; \n                }\n            }\n        }\n        return false; \n    }\n    \n    private Position findFallbackSpawnPositionWithValidation(ZombieType type) {\n    \t\n        int mapWidth = map.getMapWidth();\n        int mapHeight = map.getMapHeight();\n\n        int[] safeX = {\n            mapWidth/4, mapWidth/3, (mapWidth*2)/3, (mapWidth*3)/4,\n            mapWidth/4, mapWidth/3, (mapWidth*2)/3, (mapWidth*3)/4,\n            mapWidth/4, mapWidth/3, (mapWidth*2)/3, (mapWidth*3)/4,\n            mapWidth/4, mapWidth/3, (mapWidth*2)/3, (mapWidth*3)/4\n        };\n        \n        int[] safeY = {\n            mapHeight/4, mapHeight/4, mapHeight/4, mapHeight/4,\n            mapHeight/3, mapHeight/3, mapHeight/3, mapHeight/3,\n            (mapHeight*2)/3, (mapHeight*2)/3, (mapHeight*2)/3, (mapHeight*2)/3,\n            (mapHeight*3)/4, (mapHeight*3)/4, (mapHeight*3)/4, (mapHeight*3)/4\n        };\n\n        Player player = findPlayer();\n\n        for (int i = 0; i < safeX.length; i++) {\n            int x = safeX[i];\n            int y = safeY[i];\n\n            int requiredWidth = (type == ZombieType.TANK) ? 2 : 1;\n            int requiredHeight = (type == ZombieType.TANK) ? 2 : 1;\n\n            if (isAreaTrulyEmpty(x - 1, y - 1, requiredWidth + 2, requiredHeight + 2)) {\n\n                int spawnX = (x * TILE_SIZE) + (requiredWidth * TILE_SIZE / 2);\n                int spawnY = (y * TILE_SIZE) + (requiredHeight * TILE_SIZE / 2);\n\n                Rectangle zombieHitbox = getZombieHitbox(type, spawnX, spawnY);\n                if (!isHitboxCollidingWithWalls(zombieHitbox) && \n                    !isHitboxTooCloseToWall(zombieHitbox) && \n                    !isHitboxCollidingWithZombies(zombieHitbox)) {\n                    return new Position(spawnX, spawnY);\n                }\n            }\n        }\n\n        int maxAttempts = 2000; \n        for (int attempt = 0; attempt < maxAttempts; attempt++) {\n            int x = rand.nextInt(map.getMapWidth() - 8) + 4;\n            int y = rand.nextInt(map.getMapHeight() - 8) + 4;\n\n            int zombieWidth = (type == ZombieType.TANK) ? TILE_SIZE * 2 : TILE_SIZE;\n            int zombieHeight = (type == ZombieType.TANK) ? TILE_SIZE * 2 : TILE_SIZE;\n            int spawnX = (x * TILE_SIZE) + (zombieWidth / 2);\n            int spawnY = (y * TILE_SIZE) + (zombieHeight / 2);\n\n            Rectangle zombieHitbox = getZombieHitbox(type, spawnX, spawnY);\n            if (!isHitboxCollidingWithWalls(zombieHitbox) && \n                !isHitboxTooCloseToWall(zombieHitbox) && \n                !isHitboxCollidingWithZombies(zombieHitbox)) {\n                return new Position(spawnX, spawnY);\n            }\n        }\n\n        return null; \n    }\n    private Player findPlayer() {\n        for (int i = 0; i < handler.object.size(); i++) {\n            GameObject tempObject = handler.object.get(i);\n            if (tempObject.getId() == ID.Player) {\n                return (Player) tempObject;\n            }\n        }\n        return null;\n    }\n\n\n    private ZombieType getRandomZombieType() {\n    \tRandom random = new Random();\n    \tint currentWave = waveManager.getWaveNumber();\n\n    \tif(currentWave >= 9) {\n    \t\tZombieType[] types = {ZombieType.NORMAL, ZombieType.CRAWLER, ZombieType.TANK, ZombieType.ACID_SPITTER, ZombieType.KAMIKAZE};\n            return types[random.nextInt(types.length)];\n    \t}\t\n    \telse if (currentWave >= 7) {\n           \n            ZombieType[] types = {ZombieType.NORMAL, ZombieType.CRAWLER, ZombieType.TANK, ZombieType.ACID_SPITTER};\n            return types[random.nextInt(types.length)];\n        } else if (currentWave >= 5) {\n           \n            ZombieType[] types = {ZombieType.NORMAL, ZombieType.CRAWLER, ZombieType.TANK};\n            return types[random.nextInt(types.length)];\n        } else if (currentWave >= 3) {\n         \n            ZombieType[] types = {ZombieType.NORMAL, ZombieType.CRAWLER};\n            return types[random.nextInt(types.length)];\n        } else {\n           \n            return ZombieType.NORMAL;\n        }\n    \n    }\n    \n    private boolean isAreaTrulyEmpty(int tileX, int tileY, int width, int height) {\n    \t\n        for (int x = tileX; x < tileX + width; x++) {\n            for (int y = tileY; y < tileY + height; y++) {\n           \n                if (!map.isInBounds(x, y) || !map.isTileEmpty(x, y)) {\n                    return false;\n                }\n            }\n        }\n        \n        float pixelX = tileX * TILE_SIZE + (width * TILE_SIZE / 2);\n        float pixelY = tileY * TILE_SIZE + (height * TILE_SIZE / 2);\n\n        Rectangle zombieHitbox = new Rectangle(\n            (int)(pixelX - width * TILE_SIZE / 2),\n            (int)(pixelY - height * TILE_SIZE / 2),\n            width * TILE_SIZE,\n            height * TILE_SIZE\n        );\n\n        return !isHitboxCollidingWithWalls(zombieHitbox) && !isHitboxTooCloseToWall(zombieHitbox);\n    }\n    \n    private boolean isPositionInWall(float pixelX, float pixelY) {\n        for (int i = 0; i < handler.object.size(); i++) {\n            GameObject tempObject = handler.object.get(i);\n            if (tempObject instanceof Block) {\n                Block wall = (Block) tempObject;\n                \n                // Pozisyon duvar içinde mi?\n                if (pixelX >= wall.getX() && pixelX <= wall.getX() + 32 &&\n                    pixelY >= wall.getY() && pixelY <= wall.getY() + 32) {\n                    return true; \n                }\n            }\n        }\n        return false; \n    }\n\n\tprivate static class Position {\n    int x, y;\n    \n    Position(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n}",
      "Pistol.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\nimport javax.imageio.ImageIO;\n\npublic class Pistol extends Weapon {\n\n    public Pistol() {\n        super();\n\n        this.magazineSize = 12;\n        this.currentAmmo = magazineSize;\n        this.totalAmmo = 999; \n        this.damage = 20;\n        this.spread = 0.02f; \n        this.bulletSpeed = 7.0f;\n        this.bulletSize = 5;\n        this.hasInfiniteAmmo = true; // Sonsuz yedek mermi\n        this.isPiercing = true;\n        this.isExplosive = false;\n        this.penetration = 1;\n        this.timeBetweenShots = 0.35f; // 0.3 saniye iki atış arası\n        this.isAutomatic = false;    \n        this.weaponName = \"Pistol\";\n        \n        try {\n        \t//System.out.println(\"Resim Dosya Yolu: \" + new File(\"src/images/Pistol.png\").getAbsolutePath());\n        \tweaponIcon = ImageIO.read(new File(\"src/images/Pistol.png\"));\n        } catch (IOException e) {\n            //System.err.println(\"Silah simgesi yüklenemedi: \" + e.getMessage());\n        }\n        \n    }\n\n    @Override\n    public int getMagazineCapacity() {\n        return 12; \n    }\n\n    @Override\n    public int getFireRate() {\n        return 120; \n    }\n    \n    @Override\n    protected void createBullet(float angle, float playerX, float playerY) {\n\n        Bullet.createBullet(\n                \"pistol\",         \n                playerX, playerY, \n                angle, spread,    \n                bulletSpeed,      \n                damage,           \n                penetration,     \n                isExplosive,      \n                bulletSize,       \n                Color.YELLOW,     \n                handler,          \n                handler.getPlayer() \n            );\n\n    }\n    \n    @Override\n    public void reload() {\n    \t if (isReloading || currentAmmo == magazineSize || (!hasInfiniteAmmo && totalAmmo <= 0)) {\n             if (currentAmmo == magazineSize) {\n                 System.out.println(\"Pistol: Şarjör zaten dolu.\");\n             }\n             return;\n         }\n         \n         isReloading = true;\n         System.out.println(\"Pistol: Şarjör değiştiriliyor...\");\n\n         Timer reloadTimer = new Timer();\n         reloadTimer.schedule(new TimerTask() {\n             @Override\n             public void run() {\n\n                 if (hasInfiniteAmmo) {\n\n                     currentAmmo = magazineSize;\n                 } else {\n\n                     int bulletsToLoad = Math.min(magazineSize - currentAmmo, totalAmmo);\n                     currentAmmo += bulletsToLoad;\n                     totalAmmo -= bulletsToLoad;\n                 }\n                 \n                 isReloading = false;\n                 System.out.println(weaponName + \": Şarjör değiştirildi. Mevcut: \" + currentAmmo + \", Toplam: \" + totalAmmo);\n                 reloadTimer.cancel();\n             }\n         }, 1000); // 1 saniye reload süresi\n     }\n\n\t@Override\n\tprotected void loadShootSound() {\n\t\tshootSound = new SoundPlayer(\"sounds/pistol_shot.wav\");\n\t\t\n\t}\n}\n\n\n",
      "AcidSpitterZombie.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class AcidSpitterZombie extends Enemy {\n    private static final int HEALTH = 50;    // Düşük\n    private static final float SPEED = 1.0f; // Yavaş\n    private static final int DAMAGE = 20;    // Orta\n    private static final int ACID_RANGE = 200;\n    private static final int ACID_COOLDOWN = 120; // 2 saniye\n    private int acidTimer = 0;\n    private boolean isAttacking = false;\n    private int attackDelayCounter = 0;\n    private boolean isPreparingToAttack = false; \n    \n\n    public AcidSpitterZombie(float x, float y,ZombieType type, Handler handler, Map map , WaveManager waveManager) {\n        super(x, y, ID.Enemy,type, handler, map , waveManager);\n        this.health = HEALTH;\n        \n        try {\n           \n            if (zombieImage == null) {             \n                zombieImage = ImageIO.read(new File(\"src/images/AcidSpitterZombie.png\"));\n            }\n        } catch (IOException e) {\n           \n        }\n    }\n\n    @Override\n    public void tick() {\n        super.tick();\n\n        oldX = x;\n        oldY = y;\n\n        float dx = player.getX() - x;\n        float dy = player.getY() - y;\n        float distance = (float) Math.sqrt(dx * dx + dy * dy);\n\n       \n        if (acidTimer > 0) {\n            acidTimer--;\n        }\n\n        if (acidTimer <= 0 && distance < ACID_RANGE) {\n            float angle = (float) Math.atan2(dy, dx);\n            \n            \n            float spawnDistance = 40; \n            float projectileX = x + (float) (spawnDistance * Math.cos(angle));\n            float projectileY = y + (float) (spawnDistance * Math.sin(angle));\n            \n           \n            if (!map.isBlock((int)projectileX, (int)projectileY)) {\n                handler.addObject(new AcidProjectile(projectileX, projectileY, handler, angle, map, this));\n                acidTimer = ACID_COOLDOWN;\n            }\n        }\n\n        checkCollision();\n    \n    }\n\n    public void onDeath() {\n    \thandler.addObject(new AcidExplosionEffect(x, y, 100, handler)); \n\n        for (GameObject obj : handler.object) {\n            if (obj.getId() == ID.Player || obj.getId() == ID.Enemy) {\n\n                float dx = obj.getX() - x;\n                float dy = obj.getY() - y;\n                float distance = (float) Math.sqrt(dx * dx + dy * dy);\n\n                if (distance < 100 && obj != this) {\n                    if (obj.getId() == ID.Player) {\n      \n                        Player player = (Player) obj;\n                        player.takeDamage(20);\n                    } else if (obj instanceof Enemy) {\n            \n                        Enemy enemy = (Enemy) obj;\n                        enemy.setHealth(enemy.getHealth() - DAMAGE);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void render(Graphics g) {\n       \tint width = 32; \n        int height = 32;\n        if (zombieImage != null) {\n           \n            g.drawImage(zombieImage, (int)x, (int)y, width, height, null);\n        } else {\n            \n            g.setColor(Color.GREEN);\n            g.fillRect((int)x, (int)y, width, height);\n        }\n             \n        g.setColor(Color.RED);\n        g.fillRect((int)x, (int)y - 10, width, 5);\n        g.setColor(Color.GREEN);\n        g.fillRect((int)x, (int)y - 10, (int)(width * ((float)health / maxHealth)), 5);\n    }\n}\n\n    \n",
      "SpeedBooster.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.Graphics2D;\nimport java.awt.AlphaComposite;\nimport java.awt.RenderingHints;\nimport java.awt.BasicStroke;\n\npublic class SpeedBooster extends GameObject {\n    \n    private Handler handler;\n    private boolean collected = false;\n    private float boostAmount = 1.5f; \n    private int boostDuration = 10000; \n    \n    public SpeedBooster(float x, float y, ID id) {\n        super(x, y, id);\n    }\n    \n    public SpeedBooster(float x, float y, ID id, Handler handler) {\n        super(x, y, id);\n        this.handler = handler;\n    }\n    \n    public void setHandler(Handler handler) {\n        this.handler = handler;\n    }\n    \n    @Override\n    public void tick() {\n        if (collected) return;\n        \n        if (handler != null) {\n            Player player = handler.getPlayer();\n            if (player != null && getBounds().intersects(player.getBounds())) {\n                // Oyuncuya hız boost'u uygula\n                player.applySpeedBoost(boostAmount, boostDuration);\n                \n                collected = true;\n                handler.removeObject(this);\n            }\n        }\n    }\n    \n    @Override\n    public void render(Graphics g) {\n        if (collected) return;\n        \n        Graphics2D g2d = (Graphics2D) g.create();\n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        \n      \n        g2d.setColor(new Color(255, 215, 0, 60));\n        g2d.fillOval((int) x - 2, (int) y - 2, 20, 20);\n    \n        g2d.setColor(new Color(255, 215, 0)); // Altın rengi\n        \n        int[] xPoints = {\n            (int) x + 8,  // Orta üst\n            (int) x + 4,  // Sol üst\n            (int) x + 9,  // Sol orta\n            (int) x + 6,  // Orta alt\n            (int) x + 12, // Sağ alt\n            (int) x + 8   // Sağ orta\n        };\n        \n        int[] yPoints = {\n            (int) y,      // Orta üst\n            (int) y + 7,  // Sol üst\n            (int) y + 7,  // Sol orta\n            (int) y + 16, // Orta alt\n            (int) y + 9,  // Sağ alt\n            (int) y + 9   // Sağ orta\n        };\n        \n        g2d.fillPolygon(xPoints, yPoints, 6);\n      \n        g2d.setColor(new Color(218, 165, 32)); \n        g2d.setStroke(new BasicStroke(1.0f));\n        g2d.drawPolygon(xPoints, yPoints, 6);\n    \n        g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));\n        g2d.setColor(new Color(255, 255, 255));\n        g2d.drawLine((int) x + 8, (int) y + 2, (int) x + 8, (int) y + 14);\n        \n        g2d.dispose();\n    }\n    \n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle((int) x, (int) y, 16, 16);\n    }\n    \n    public float getBoostAmount() {\n        return boostAmount;\n    }\n    \n    public void setBoostAmount(float boostAmount) {\n        this.boostAmount = boostAmount;\n    }\n    \n    public int getBoostDuration() {\n        return boostDuration;\n    }\n    \n    public void setBoostDuration(int boostDuration) {\n        this.boostDuration = boostDuration;\n    }\n    \n    public boolean isCollected() {\n        return collected;\n    }\n    \n    public void setCollected(boolean collected) {\n        this.collected = collected;\n    }\n}\n\n",
      "RocketExplosionEffect.java": "package ödev2;\n\nimport java.awt.AlphaComposite;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\n\npublic class RocketExplosionEffect extends GameObject {\n\tprivate int radius;\n    private int timer;\n    private Handler handler;\n    private float alpha = 0.7f; \n\n    private Color outerColor = new Color(255, 0, 0, 130); \n    private Color innerColor = new Color(255, 165, 0, 150); \n    \n    public RocketExplosionEffect(float x, float y, Handler handler, int radius) {\n        super(x, y, ID.Effect);\n        this.handler = handler;\n        this.radius = radius;\n        this.timer = 20;\n    }\n    \n    @Override\n    public void tick() {\n        timer--;\n        if (timer <= 0) {\n            handler.removeObject(this);\n        }\n    }\n    \n    @Override\n    public void render(Graphics g) {\n        Graphics2D g2d = (Graphics2D) g;\n\n        g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));\n\n        float scale = 0.6f; \n\n        int scaledOuterRadius = (int) (radius * scale);\n        g2d.setColor(outerColor);\n        g2d.fillOval(\n            (int) (x - scaledOuterRadius / 2), \n            (int) (y - scaledOuterRadius / 2), \n            scaledOuterRadius, \n            scaledOuterRadius\n        );\n\n        int scaledInnerRadius = (int) (scaledOuterRadius / 2); \n        g2d.setColor(innerColor);\n        g2d.fillOval(\n            (int) (x - scaledInnerRadius / 2), \n            (int) (y - scaledInnerRadius / 2), \n            scaledInnerRadius, \n            scaledInnerRadius\n        );\n\n        // Reset transparency for further rendering\n        g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));\n    }\n\n    \n    @Override\n    public Rectangle getBounds() {\n    \treturn new Rectangle(0, 0, 0, 0);\n    }\n}",
      "AssaultRifle.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class AssaultRifle extends Weapon {\n    private long lastShotTime = 0;\n    private static final long MIN_SHOT_INTERVAL = 100; \n    private boolean firedThisFrame = false;\n    private long lastFrameProcessed = -1;\n    public AssaultRifle() {\n    \t super();\n         \n         this.magazineSize = 30;\n         this.currentAmmo = magazineSize;\n         this.totalAmmo = 90;\n         this.damage = 20;\n         this.spread = (float) Math.toRadians(12.0); // 30 derecelik toplam sapma (±15 derece)\n         this.bulletSpeed = 6.0f;\n         this.bulletSize = 6;\n         this.penetration = 1;\n         this.hasInfiniteAmmo = false;\n         this.isPiercing = false;\n         this.isExplosive = false;\n         \n\n         this.timeBetweenShots = 0.15f; \n         this.isAutomatic = true;  \n         \n         try {\n       \tweaponIcon = ImageIO.read(new File(\"src/images/AssaultRifle.png\"));\n       } catch (IOException e) {\n           //System.err.println(\"Silah simgesi yüklenemedi: \" + e.getMessage());\n       }\n         //System.out.println(\"Rifle oluşturuldu: \" + magazineSize + \" mermi kapasiteli\");\n     }\n\n     @Override\n     public int getMagazineCapacity() {\n         return 30; \n     }\n\n     @Override\n     public int getFireRate() {\n         return 600; \n     }\n     \n     @Override\n     protected void createBullet(float angle, float playerX, float playerY) {\n    \t float finalAngle = angle + (float) ((Math.random() - 0.5) * 2 * spread);\n\n         float offsetX = (float) (Math.cos(finalAngle) * 15);\n         float offsetY = (float) (Math.sin(finalAngle) * 15);\n         float bulletX = playerX + offsetX;\n         float bulletY = playerY + offsetY;\n         \n         Bullet bullet = Bullet.createBullet(\n             \"rifle\",              \n             bulletX, bulletY,      \n             finalAngle,            \n             spread,               \n             bulletSpeed,          \n             damage,               \n             penetration,           \n             isExplosive,           \n             bulletSize,            \n             Color.ORANGE,          \n             handler,               \n             handler.getPlayer()    \n         );\n\n         if (handler != null) {\n             handler.addObject(bullet);\n             \n         } else {\n             System.err.println(\"HATA: Assault Rifle - handler null!\");\n         }\n         }\n     public void resetFrameFlag(long currentFrame) {\n         if (currentFrame != lastFrameProcessed) {\n             firedThisFrame = false;\n             lastFrameProcessed = currentFrame;\n         }\n     }\n     \n     @Override\n     public void shoot(float angle, float playerX, float playerY) {\n         long currentFrame = Game.getCurrentFrame();\n         resetFrameFlag(currentFrame);\n    \n         if (firedThisFrame) {\n             return;\n         }\n\n         long currentTime = System.currentTimeMillis();\n         if (currentTime - lastShotTime < MIN_SHOT_INTERVAL) {\n             return;\n         }\n\n         if (currentAmmo <= 0 || isReloading) {\n             if (!isReloading) {\n                 System.out.println(\"Şarjör boş. Yeniden doldurun.\");\n             } else {\n                 System.out.println(\"Şarjör değiştiriliyor, atış yapılamaz!\");\n             }\n             return;\n         }\n\n         firedThisFrame = true;\n         lastShotTime = currentTime;\n\n         currentAmmo--;\n\n         createBullet(angle, playerX, playerY);\n         if (shootSound != null) {\n             shootSound.play();\n         } else {\n             System.err.println(\"HATA: Assault Rifle - shootSound null!\");\n             loadShootSound();\n             if (shootSound != null) {\n                 shootSound.play();\n             }\n         }\n         \n     }\n\n\n     \n\n\t@Override\n\tprotected void loadShootSound() {\n\t\tshootSound = new SoundPlayer(\"sounds/assaultrifle_shot.wav\");\n\t\t\n\t}\n }",
      "Handler.java": "package ödev2;\n\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Point;\nimport java.awt.geom.AffineTransform;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Handler {\n\tLinkedList<GameObject> object = new LinkedList<GameObject>();\n\tprivate boolean up=false,down = false, right =false, left=false;\n\tprivate Camera camera;\n\tprivate Player player;\n\tprivate Point mousePosition = new Point(0, 0);\n\t private Map map;\n\t private int mouseX, mouseY;\n\t\n    public void tick() {\n\n        List<GameObject> objectsCopy = new ArrayList<>(object);\n\n        for (int i = 0; i < objectsCopy.size(); i++) {\n            GameObject tempObject = objectsCopy.get(i);\n            if (tempObject != null) {\n                tempObject.tick();\n            }\n        }\n         \n         \n    }\n    public LinkedList<GameObject> getObjects() {\n        return object;\n    }\n\n    public void render(Graphics g) {\n    \t   try {\n\n    \t        for (int i = 0; i < object.size(); i++) {\n    \t            GameObject tempObject = object.get(i);\n    \t            if (tempObject != null) {\n    \t                tempObject.render(g);\n    \t            }\n    \t        }\n    \t    } catch (Exception e) {\n    \t        System.err.println(\"Render error: \" + e.getMessage());\n    \t    }\n\n    }\n    \n    public void setMousePosition(int x, int y) {\n        this.mousePosition.x = x;\n        this.mousePosition.y = y;\n    }\n    public int getMouseX() {\n        return mouseX;\n    }\n\n    public int getMouseY() {\n        return mouseY;\n    }\n    \n    public Point getMousePosition() {\n        return mousePosition;\n    }\n    public boolean isUp() {\n\t\treturn up;\n\t}\n\n\tpublic void setUp(boolean up) {\n\t\tthis.up = up;\n\t}\n    public void setMap(Map map) {\n        this.map = map;\n    }\n\n    public Map getMap() {\n        return map;\n    }\n\n\tpublic boolean isDown() {\n\t\treturn down;\n\t}\n\n\tpublic void setDown(boolean down) {\n\t\tthis.down = down;\n\t}\n\n\tpublic boolean isRight() {\n\t\treturn right;\n\t}\n\n\tpublic void setRight(boolean right) {\n\t\tthis.right = right;\n\t}\n\n\tpublic boolean isLeft() {\n\t\treturn left;\n\t}\n\n\tpublic void setLeft(boolean left) {\n\t\tthis.left = left;\n\t}\n\t\n\tpublic void setCamera(Camera camera) {\n\t    this.camera = camera;\n\t}\n\n\tpublic Camera getCamera() {\n\t    return camera;\n\t}\n\tpublic Player getPlayer() {\n        if(player == null) {\n            for(int i = 0; i < object.size(); i++) {\n                if(object.get(i).getId() == ID.Player) {\n                    player = (Player) object.get(i);\n                    break;\n                }\n            }\n        }\n        return player;\n    }\n\t\n\n\tpublic void clearObjects() {\n\t\tthis.object.clear();\n        player = null;\n    }\n\tpublic void addObject(GameObject tempObject) {\n        this.object.add(tempObject);\n\n    }\n    public void removeObject(GameObject tempObject) {\n        object.remove(tempObject);\n    }\n\tpublic void setPlayer(Player player) {\n\t\tthis.player = player;\n\t\t\n\t}\n}\n",
      "CrawlerZombie.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class CrawlerZombie extends Enemy {\n    \n    private boolean isJumping = false;\n    private float jumpStrength = -5.0f;  \n    private float gravity = 0.5f;        \n    private float verticalVelocity = 0;  \n    private float groundY;               \n    private static final int JUMP_COOLDOWN = 5 * 60; \n    private int jumpTimer = 0;\n    private float jumpHeight = 32.0f;\n    private int damageTimer = 0;\n    private static final int DAMAGE_COOLDOWN = 60; \n    private int damageAmount = 10; \n    \n    \n    public CrawlerZombie(float x, float y,ZombieType type, Handler handler, Map map , WaveManager waveManager) {\n        super(x, y, ID.Enemy, type, handler, map, waveManager);\n        this.health = 60;\n        this.maxHealth = 60;\n        this.groundY = y;\n        \n        try {\n            \n            if (zombieImage == null) {\n                //System.out.println(\"Resim Dosya Yolu: \" + new File(\"src/images/CrawlerZombie.png\").getAbsolutePath());\n                zombieImage = ImageIO.read(new File(\"src/images/CrawlerZombie.png\"));\n            }\n        } catch (IOException e) {\n            //System.err.println(\"Zombi resmi yüklenemedi: \" + e.getMessage());\n        }\n    }\n\n    @Override\n    public void tick() {\n    \toldX = x;\n        oldY = y;\n        \n        float dx = player.getX() - x;\n        float dy = player.getY() - y;\n        float distance = (float) Math.sqrt(dx * dx + dy * dy);\n        \n        if (jumpTimer > 0) {\n            jumpTimer--;\n        }\n        \n        if (distance < 200 && !isJumping && jumpTimer <= 0 && Math.abs(dx) < 150) { \n            startJump();\n            jumpTimer = JUMP_COOLDOWN;\n        }\n        \n        if (distance > 32) {\n            velX = (dx / distance) * speed;\n            velY = (dy / distance) * speed;\n        } else {\n            velX = 0;\n            velY = 0;\n            dealDamageToPlayer();\n        }\n        \n        if (isJumping) {\n            verticalVelocity += gravity;\n            y += verticalVelocity;\n            \n            x += velX;\n            \n            if (y >= groundY) {\n                y = groundY;\n                isJumping = false;\n                verticalVelocity = 0;\n            }\n        } else {\n            x += velX;\n            y += velY;\n            \n            groundY = y;\n        }\n        \n        checkCollision();\n    }\n    private void dealDamageToPlayer() {\n        float playerWidth = 32; \n        float playerHeight = 32; \n        \n        // Basit çarpışma kontrolü (dikdörtgen-dikdörtgen)\n        boolean colliding = x < player.getX() + playerWidth &&\n                            x + 32 > player.getX() &&\n                            y < player.getY() + playerHeight &&\n                            y + 32 > player.getY();\n                           \n        if (colliding && damageTimer <= 0) {\n            player.takeDamage(damageAmount);\n            damageTimer = DAMAGE_COOLDOWN; \n        }\n        \n        if (damageTimer > 0) {\n            damageTimer--;\n        }\n    }\n    \n    private void startJump() {\n        if (!isJumping) {\n            isJumping = true;\n            groundY = y;\n            verticalVelocity = -1 * (float)Math.sqrt(2 * gravity * jumpHeight);\n        }\n    }\n\n    @Override\n    public void render(Graphics g) {\n       \tint width = 32; \n        int height = 32;\n        if (zombieImage != null) {\n          \n            g.drawImage(zombieImage, (int)x, (int)y, width, height, null);\n        } else {\n            \n            g.setColor(Color.GREEN);\n            g.fillRect((int)x, (int)y, width, height);\n        }\n             \n        g.setColor(Color.RED);\n        g.fillRect((int)x, (int)y - 10, width, 5);\n        g.setColor(Color.GREEN);\n        g.fillRect((int)x, (int)y - 10, (int)(width * ((float)health / maxHealth)), 5);\n    }\n}\n",
      "TankZombie.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class TankZombie extends Enemy {\n    private static final int HEALTH = 200;  \n    private static final float SPEED = 0.5f; \n    private static final int DAMAGE = 40;    \n   \n\n    public TankZombie(float x, float y,ZombieType type, Handler handler, Map map , WaveManager waveManager) {\n        super(x, y, ID.Enemy,type, handler, map , waveManager);\n        this.health = HEALTH;\n        \n        try {\n            if (zombieImage == null) {\n                //System.out.println(\"Resim Dosya Yolu: \" + new File(\"src/images/TankZombie.png\").getAbsolutePath());\n                zombieImage = ImageIO.read(new File(\"src/images/TankZombie.png\"));\n            }\n        } catch (IOException e) {\n            //System.err.println(\"Zombi resmi yüklenemedi: \" + e.getMessage());\n        }\n\n    }\n\n    @Override\n    public void render(Graphics g) {\n    \tint width = 50;  \n        int height = 50;\n        if (zombieImage != null) {\n  \n            g.drawImage(zombieImage, (int)x, (int)y, width, height, null);\n        } else {\n\n            g.setColor(Color.GREEN);\n            g.fillRect((int)x, (int)y, width, height);\n        }\n        \n        g.setColor(Color.RED);\n        g.fillRect((int)x, (int)y - 10, width, 5);\n        g.setColor(Color.GREEN);\n        g.fillRect((int)x, (int)y - 10, (int)(width * ((float)health / maxHealth)), 5);\n    \n    }\n}\n\n",
      "SaveManager.java": "package ödev2;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SaveManager {\n    private static final String SAVE_FILE = \"gamesave.dat\";\n    \n    public static void saveGame(Game game) {\n        try {\n            GameSave gameSave = new GameSave();\n\n            Player player = game.player;\n            gameSave.setPlayerX(player.getX());\n            gameSave.setPlayerY(player.getY());\n            gameSave.setPlayerHealth(player.getHealth());\n\n            gameSave.setCameraX(game.camera.getX());\n            gameSave.setCameraY(game.camera.getY());\n\n            gameSave.setScore(game.getScore());\n\n            gameSave.setWaveNumber(game.waveManager.getWaveNumber());\n            gameSave.setZombiesRemaining(game.waveManager.getZombiesRemaining());\n\n            List<String> unlockedWeapons = new ArrayList<>();\n            List<int[]> weaponAmmo = new ArrayList<>();\n\n            player.saveCurrentWeaponAmmo();\n\n            for (Class<?> weaponClass : player.getAvailableWeapons()) {\n                unlockedWeapons.add(weaponClass.getName());\n\n                int[] ammoInfo = player.getWeaponAmmoInfo(weaponClass);\n                weaponAmmo.add(ammoInfo);\n\n                System.out.println(\"Kaydediliyor - Silah: \" + weaponClass.getSimpleName() + \n                                   \" Mermi: \" + ammoInfo[0] + \"/\" + ammoInfo[1]);\n            }\n\n            gameSave.setUnlockedWeapons(unlockedWeapons);\n            gameSave.setWeaponAmmo(weaponAmmo);\n\n            int activeWeaponIndex = player.getActiveWeaponIndex();\n            gameSave.setActiveWeaponIndex(activeWeaponIndex);\n\n            List<ZombieData> zombieDataList = new ArrayList<>();\n            for (GameObject obj : game.handler.object) {\n                if (obj.getId() == ID.Enemy && obj instanceof Enemy) {\n                    Enemy zombie = (Enemy) obj;\n                    ZombieData zombieData = new ZombieData();\n                    zombieData.setX(zombie.getX());\n                    zombieData.setY(zombie.getY());\n                    zombieData.setHealth(zombie.getHealth());\n                    zombieData.setType(zombie.getClass().getSimpleName());\n                    zombieDataList.add(zombieData);\n                }\n            }\n            gameSave.setZombies(zombieDataList);\n            \n            List<AmmoClipData> ammoClipDataList = new ArrayList<>();\n            for (GameObject obj : game.handler.object) {\n                if (obj.getId() == ID.AmmoClip) {\n                    AmmoClip ammoClip = (AmmoClip) obj;\n                    ammoClipDataList.add(new AmmoClipData(ammoClip.getX(), ammoClip.getY(), ammoClip.isCollected()));\n                }\n            }\n            gameSave.setAmmoClips(ammoClipDataList);\n            FileOutputStream fileOut = new FileOutputStream(SAVE_FILE);\n            ObjectOutputStream out = new ObjectOutputStream(fileOut);\n            out.writeObject(gameSave);\n            out.close();\n            fileOut.close();\n\n            System.out.println(\"Oyun kaydedildi: \" + SAVE_FILE);\n\n        } catch (Exception e) {\n            System.err.println(\"Oyun kaydedilirken hata oluştu: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n    \n    public static GameSave loadGame() {\n    \ttry {\n            FileInputStream fileIn = new FileInputStream(SAVE_FILE);\n            ObjectInputStream in = new ObjectInputStream(fileIn);\n            GameSave gameSave = (GameSave) in.readObject();\n            in.close();\n            fileIn.close();\n\n            System.out.println(\"Oyun yüklendi: \" + SAVE_FILE);\n            if (gameSave.getPlayerX() < 0 || gameSave.getPlayerY() < 0) {\n                System.err.println(\"Invalid player position in save file\");\n                return null;\n            }\n            return gameSave;\n\n        } catch (Exception e) {\n            System.err.println(\"Oyun yüklenirken hata oluştu: \" + e.getMessage());\n            e.printStackTrace();\n            return null;\n        }\n    }\n}",
      "ExplosionEffect.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class ExplosionEffect extends GameObject {\n    private long startTime;\n    private static final long EFFECT_DURATION = 600; \n    private Handler handler;\n\n    private int frame = 0;\n    private int totalFrames = 8;\n    private int frameWidth = 48;\n    private int frameHeight = 48;\n    \n    public ExplosionEffect(float x, float y, ID id, Handler handler) {\n        super(x, y, id);\n        this.handler = handler;\n        this.startTime = System.currentTimeMillis();\n        \n    }\n    \n    @Override\n    public void tick() {\n        long currentTime = System.currentTimeMillis();\n        long elapsedTime = currentTime - startTime;\n        \n        frame = (int)((elapsedTime / (EFFECT_DURATION / totalFrames)) % totalFrames);\n        \n        if (elapsedTime >= EFFECT_DURATION) {\n            handler.removeObject(this);\n        }\n    }\n    \n    @Override\n    public void render(Graphics g) {\n\n        }\n    \n    \n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle((int)x, (int)y, frameWidth*2, frameHeight*2);\n    }\n}\n\n",
      "SoundPlayer.java": "package ödev2;\n\nimport javax.sound.sampled.*;\nimport java.io.File;\n\npublic class SoundPlayer {\n\n    private Clip clip;\n    private Runnable onStartedCallback;\n\n    public SoundPlayer(String soundFilePath) {\n        try {\n            File soundFile = new File(soundFilePath);\n            AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(soundFile);\n            clip = AudioSystem.getClip();\n            clip.open(audioInputStream);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void play() {\n        if (clip != null) {\n            clip.setFramePosition(0); \n            clip.start();\n        }\n    }\n\n    public void loop() {\n        if (clip != null) {\n            clip.setFramePosition(0);\n            clip.loop(Clip.LOOP_CONTINUOUSLY); \n        }\n        if (onStartedCallback != null) {\n            new java.util.Timer().schedule(\n                new java.util.TimerTask() {\n                    @Override\n                    public void run() {\n                        onStartedCallback.run();\n                    }\n                }, \n                500 \n            );\n        }\n    }\n\n    public void stop() {\n        if (clip != null && clip.isRunning()) {\n            clip.stop();\n        }\n    }\n    public boolean isPlaying() { \n        return clip != null && clip.isRunning(); \n    }\n    public void setOnStartedCallback(Runnable callback) {\n        this.onStartedCallback = callback;\n    }\n}\n",
      "Game.java": "package ödev2;\n\nimport java.awt.Canvas;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.RenderingHints;\nimport java.awt.SplashScreen;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseMotionAdapter;\nimport java.awt.event.MouseMotionListener;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferStrategy;\nimport java.awt.image.BufferedImage;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.TimerTask;\n\nimport javax.swing.SwingUtilities;\n\npublic class Game extends Canvas implements Runnable, MouseMotionListener {\n\n\tprivate static final long serialVersionUID = 2325082275330504548L;\n\tpublic static final int WIDTH = 1440;\n\tpublic static final int HEIGHT = 960;\n\tpublic String title = \"Top-Shooter Zombie Game\";\n\tprivate int score = 0;\n\tpublic static int mouseX = 0;\n\tpublic static int mouseY = 0;\n\t\n\tprivate Thread thread;\n\tprivate boolean running = false;\n\tprotected Player player;\n\tprotected Handler handler;\n\tprivate KeyInput input;\n\tprivate MouseInput minput;\n\tprotected Camera camera;\n\tprivate Map map;\n\tprivate ZombieSpawner zombieSpawner;\n\tprivate static Game instance;\n\tprotected WaveManager waveManager;\n\tprivate boolean isRestart = false;\n\tprivate static long currentFrame = 0;\n\tprivate SoundPlayer menuMusic;\n\tprivate SoundPlayer gameMusic;\n\tprivate GameState gameState = GameState.MENU;\n\tprivate Menu mainMenu;\n\tprivate Menu pauseMenu;\n\tprivate int gameOverWave = -1; // Başlangıçta geçersiz bir değer\n\tprivate int gameOverScore = -1;\n\tpublic static int tickCount = 0;\n\tprivate static final int LOADING_STAGE_INIT = 0;\n\tprivate static final int LOADING_STAGE_UI = 1;\n\tprivate static final int LOADING_STAGE_RESOURCES = 2;\n\tprivate static final int LOADING_STAGE_COMPLETE = 3;\n\t\n\tprivate int loadingStage = LOADING_STAGE_INIT;\n\tprivate boolean resourcesLoaded = false;\n\tprivate BufferedImage background;\n\tprivate boolean gameResourcesInitialized = false;\n    private long gameLoadStartTime;\n    private static final long EXTENDED_LOAD_TIME = 5000; // 3 saniye minimum yükleme süresi\n    private boolean gameInitialized = false;\n    private float loadingProgress = 0.0f;\n    private boolean musicStarted = false;\n    private boolean gameReadyToStart = false;\n    private static final int LOADING_PHASE_COUNT = 5;\n    private static final long PHASE_DURATION = EXTENDED_LOAD_TIME / LOADING_PHASE_COUNT;\n    private boolean gameFullyInitialized = false;\n    private static final long GAMEPLAY_INIT_WAIT = 5000;\n    private List<GameObject> preloadedZombies = new ArrayList<>();\n    private int frames = 0;              // Number of frames in the current second\n    private int fps = 0;                 // Smoothed FPS value\n    private long lastFpsUpdateTime = 0;\n\tprivate long gameStartTime = 0;\n\tprivate boolean timerRunning = false;\n\tprivate String formattedTime = \"00:00\";\n\n\t\n\tpublic Game() {\t    \t\n\t\tnew Window(WIDTH, HEIGHT, \"2D - Shooter Zombie Game\", this);\n\t\tloadingStage = LOADING_STAGE_UI;\n\n\t\tImageCache.preloadImagesAsync(ImageCache.ImageType.MENU, () -> {\n\t\t\t\n\t\t\tImageCache.preloadImages();\n\t\t\tmainMenu = new Menu(this, true); \n\t\t\tpauseMenu = new Menu(this, false); \n\t\t\tloadingStage = LOADING_STAGE_RESOURCES;\n\t\t\t\n\t\t\t\n\t\t\tloadResourcesAsync();\n\t\t});\n\t\t\n\t\tgameState = GameState.MENU;\n\t\tWindow.frame.setVisible(true);\n\t\t\n\t\t\n\t\tbasicInit();\n\t\tstart();\n\t}\n\n\t\n\tprivate void basicInit() {\n\t\thandler = new Handler();\n\t\tmap = new Map();\n\t\t\n\t\tinstance = this;\n\t\tcamera = new Camera(0f, 0f, handler, this);\n\t\thandler.setCamera(camera);\n\t\thandler.setMap(map);\n\t\tminput = new MouseInput(handler, camera, this);\n\t\tinput = new KeyInput(handler, this);\n\t\t\n\t\tthis.addKeyListener(input);\n\t\tthis.addMouseListener(minput);\n\t\tthis.addMouseMotionListener(new MouseMotionAdapter() {\n            @Override\n            public void mouseMoved(MouseEvent e) {\n                updateMouseCoordinates(e);\n            }\n            \n            @Override\n            public void mouseDragged(MouseEvent e) {\n                updateMouseCoordinates(e);\n            }\n        });\n\t\tbackground = ImageCache.getImage(\"MenuBackground.png\");\n\t}\n\t\n\t\n\tprivate void completeGameInit() {\n    if (gameResourcesInitialized) return;\n \n        waveManager = new WaveManager(handler, map);\n        player = new Player(100, 100, ID.Player, handler, map, minput, camera, input, waveManager);\n        camera.setX(player.getX() - Game.WIDTH/2 + 16);\n        camera.setY(player.getY() - Game.HEIGHT/2 + 16);\n        camera.setZoomLevel(45f);\n        waveManager.setPlayer(player);\n        handler.addObject(player);\n        handler.setPlayer(player);\n        zombieSpawner = new ZombieSpawner(handler, map, waveManager);\n        preloadZombies();\n        gameResourcesInitialized = true;\n\t}\n\t\n\tpublic synchronized void start() {\n\t\tif(running) return;\n\t\t\n\t\tthread = new Thread(this);\n\t\tthread.start();\n\t\trunning = true;\n\t}\n\n\tpublic synchronized void stop() {\n\t\tif(!running) return;\n\t\ttry {\n\t\t\tthread.join();\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\trunning = false;\n\t}\n\tpublic void updateCamera() {\n\t    \n\t    float offsetX = Game.WIDTH - 150;  \n\t    float offsetY = Game.HEIGHT - 80; \n\t    \n\t    \n\t    camera.setX(player.getX() - offsetX);\n\t    camera.setY(player.getY() - offsetY);\n\t}\n    private void updateMouseCoordinates(MouseEvent e) {\n    \t\n        mouseX = e.getX();\n        mouseY = e.getY();\n        \n        \n        int worldMouseX = mouseX + (int)camera.getX();\n        int worldMouseY = mouseY + (int)camera.getY();\n\n        handler.setMousePosition(worldMouseX, worldMouseY);\n    }\n\t@Override\n\tpublic void run() {\n\t\tthis.requestFocus();\n\t\tlong lastTime = System.nanoTime();\n\t\tdouble amountOfTicks = 60.0;\n\t\tdouble ns = 1000000000 / amountOfTicks;\n\t\tdouble delta = 0;\n\t\tlong timer = System.currentTimeMillis();\n\t\tint ticks = 0;\n\t\t\n\t\t\n\t\tfinal int TARGET_FPS = 120;\n\t\tfinal long OPTIMAL_TIME = 1000000000 / TARGET_FPS;\n\t\t\n\t\twhile(running) {\n\t\t\tlong now = System.nanoTime();\n\t\t\tdelta += (now - lastTime) / ns;\n\t\t\tlong updateTime = now - lastTime;\n\t\t\tlastTime = now;\n\t\t\t\n\t\t\twhile(delta >= 1) {\n\t\t\t\ttick();\n\t\t\t\tticks++;\n\t\t\t\tdelta--;\n\t\t\t}\n\t\t\t\n\t\t\trender();\n\t\t\tframes++;\n\t\t\t\n\t\t\tlong afterRender = System.nanoTime();\n\t\t\tlong sleepTime = (OPTIMAL_TIME - (afterRender - now)) / 1000000;\n\t\t\t\n\t\t\tif (sleepTime > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(sleepTime); \n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\n\t\t\tif(System.currentTimeMillis() - timer > 1000) {\n\t\t\t\ttimer += 1000;\n\t\t\t\tfps = frames;\n\t\t\t\tframes = 0;\n\t\t\t\tticks = 0;\n\t\t\t}\n\t\t}\n\t\tstop();\n\t}\n\n\tpublic static long getCurrentFrame() {\n\t\treturn currentFrame;\n\t} \n\n\tprivate void tick() {\n\t    if (gameState == GameState.PLAYING) {\n\t        if (loadingStage == LOADING_STAGE_COMPLETE && !gameResourcesInitialized) {\n\t            completeGameInit();\n\t        }\n\t        \n\t        currentFrame++;\n\t        tickCount++;\n\t        handler.tick();\n\t        \n\n\t        camera.tick(player);\n\n\n\t        if (waveManager != null) {\n\t            waveManager.tick();\n\t        }\n\t    }\n\t    \n\t    if (gameState == GameState.MENU) {\n\t        if (mainMenu != null) mainMenu.tick();\n\t    } else if (gameState == GameState.PAUSED) {\n\t        if (pauseMenu != null) pauseMenu.tick();\n\t    }\n\t    else if (gameState == GameState.GAME_OVER) { \n\t        gameOverWave = waveManager.getWaveNumber();\n\t        gameOverScore = score;\n\t        gameState = GameState.MENU; \n\t        return; \n\t    }\n\n\t}\n\n\tpublic GameState getGameState() {\n\t\treturn gameState;\n\t}\n\n\t\n\tpublic void startGame() {\n\t       if (gameState == GameState.MENU) {\n\t            // Kaynak kontrolü\n\t            if (!resourcesLoaded) {\n\t                System.out.println(\"Kaynaklar yükleniyor, lütfen bekleyin...\");\n\t                return;\n\t            }\n\n\t            // Yükleme durumuna geç\n\t            gameState = GameState.LOADING_GAME;\n\t            gameLoadStartTime = System.currentTimeMillis();\n\t            loadingProgress = 0.0f;\n\t            gameFullyInitialized = false;\n\n\t            // Oyun yüklemesini yapacak yeni bir thread oluştur\n\t            Thread gameLoadingThread = new Thread(() -> {\n\t                try {\n\t                    // Aşama 1: %0 -> %20\n\t                    loadingProgress = 0.0f;\n\t                    System.out.println(\"Yükleme başlıyor: %0\");\n\t                    if (!gameResourcesInitialized) {\n\t                        completeGameInit();\n\t                    }\n\t                    for (int i = 1; i <= 20; i++) {\n\t                        Thread.sleep(50);\n\t                        loadingProgress = i / 100.0f;\n\t                    }\n\t                    System.out.println(\"İlk aşama tamamlandı: %20\");\n\n\t                    // Aşama 2: %20 -> %40\n\t                    prepareGameWithoutStarting();\n\t                    for (int i = 21; i <= 40; i++) {\n\t                        Thread.sleep(50);\n\t                        loadingProgress = i / 100.0f;\n\t                    }\n\t                    System.out.println(\"İkinci aşama tamamlandı: %40\");\n\n\t                    // Aşama 3: %40 -> %60\n\t                    // Wave hazırlığı ve ilk ayarlar\n\t                    if (waveManager != null) {\n\t                        waveManager.setWaveNumber(0);\n\t                    }\n\t                    for (int i = 41; i <= 60; i++) {\n\t                        Thread.sleep(50);\n\t                        loadingProgress = i / 100.0f;\n\t                    }\n\t                    System.out.println(\"Üçüncü aşama tamamlandı: %60\");\n\n\t                    // Aşama 4: %60 -> %80 - Zombileri oluştur\n\t                    for (int i = 61; i <= 80; i++) {\n\t                        Thread.sleep(50);\n\t                        loadingProgress = i / 100.0f;\n\t                    }\n\t                    System.out.println(\"Dördüncü aşama tamamlandı: %80\");\n\n\t                    // Aşama 5: %80 -> %100\n\n\t                    if (waveManager != null) {\n\t                        waveManager.startNextWave();\n\t                    }\n\t                    for (int i = 81; i <= 100; i++) {\n\t                        Thread.sleep(40);\n\t                        loadingProgress = i / 100.0f;\n\t                    }\n\t                    System.out.println(\"Yükleme tamamlandı: %100\");\n\n\t                    if (menuMusic != null) {\n\t                        menuMusic.stop();\n\t                    }\n\t                    if (gameMusic != null) {\n\t                        gameMusic.loop();\n\t                    }\n\n\t                    gameStartTime = System.currentTimeMillis();\n\t                    timerRunning = true;\n\t                    formattedTime = \"00:00\";\n\t                    \n\t                    gameState = GameState.PLAYING;\n\t                    gameFullyInitialized = true;\n\t                    loadingProgress = 1.0f;  \n\n\n\t                } catch (InterruptedException e) {\n\t                    e.printStackTrace();\n\t                }\n\t            });\n\n\t            gameLoadingThread.start();\n\t        }\n\t}\n\n\tprivate void prepareGameWithoutStarting() {\n\t    handler.clearObjects();\n\n\t    score = 0;\n\n\t    camera.setX(0);\n\t    camera.setY(0);\n\n\t    waveManager = new WaveManager(handler, map);\n\n\t    player = new Player(100, 100, ID.Player, handler, map, minput, camera, input, waveManager);\n\t    minput.setCamera(camera);\n\t    minput.setPlayer(player);\n\t    waveManager.setPlayer(player);\n\n\t    handler.addObject(player);\n\n\t    zombieSpawner = new ZombieSpawner(handler, map, waveManager);\n\t}\n\t\n\tpublic void pauseGame() {\n\t\tif (gameState == GameState.PLAYING) {\n\t\t\tgameState = GameState.PAUSED;\n\t\t}\n\t}\n\t\n\tpublic void resumeGame() {\n\t\tif (gameState == GameState.PAUSED) {\n\t\t\tgameState = GameState.PLAYING;\n\t\t}\n\t}\n\t\n\tpublic void restartGame() {\n\t    handler.clearObjects();\n\t    \n\t    // Reset game state\n\t    score = 0;\n\t    camera.setX(0);\n\t    camera.setY(0);\n\t    \n\t    waveManager = new WaveManager(handler, map);\n\t    \n\t    player = new Player(100, 100, ID.Player, handler, map, minput, camera, input, waveManager);\n\t    \n\t    minput.setCamera(camera);\n\t    minput.setPlayer(player);\n\t    waveManager.setPlayer(player);\n\t    handler.addObject(player);\n\t    gameStartTime = System.currentTimeMillis();\n\t    timerRunning = true;\n\t    \n\t    zombieSpawner = new ZombieSpawner(handler, map, waveManager);\n\t    \n\t    gameState = GameState.PLAYING;\n\t    \n\t    waveManager.startNextWave();\n\t}\n\n\n\t\n\tpublic void saveGame() {\n\t\tSaveManager.saveGame(this);\n\t}\n\t\n\t\n\t\n\tpublic void loadGame() {\n\t    GameSave gameSave = SaveManager.loadGame();\n\t    if (gameSave == null) {\n\t        System.out.println(\"Yüklenecek kayıt bulunamadı.\");\n\t        return;\n\t    }\n\t    \n\t    handler.clearObjects();\n\t    \n\t    if (waveManager == null) {\n\t        waveManager = new WaveManager(handler, map);\n\t    }\n\t    \n\t    player = new Player(gameSave.getPlayerX(), gameSave.getPlayerY(),\n\t                       ID.Player, handler, map, minput, camera, input, waveManager);\n\n\t    handler.addObject(player);\n\t    handler.setPlayer(player);\n\t    \n\t    waveManager.setPlayer(player);\n\t    minput.setPlayer(player);\n\t    \n\t    gameState = GameState.PLAYING;\n\t    gameResourcesInitialized = true;\n\t    \n\t    for (int i = 0; i < handler.object.size(); i++) {\n\t        GameObject tempObject = handler.object.get(i);\n\t        if (tempObject.getId() == ID.Player) {\n\t            handler.removeObject(tempObject);\n\t            i--; \n\t        }\n\t    }\n\n\t    player = new Player(gameSave.getPlayerX(), gameSave.getPlayerY(),\n\t                       ID.Player, handler, map, minput, camera, input, waveManager);\n\t    \n\t    handler.setPlayer(player);\n\t    \n\t    waveManager.setPlayer(player);\n\n\t    minput.setPlayer(player);\n\t    \n\t    handler.addObject(player);\n\t    \n\t    player.setHealth(gameSave.getPlayerHealth());\n\t    \n\t    camera.setX(gameSave.getCameraX());\n\t    camera.setY(gameSave.getCameraY());\n\t    camera.setZoomLevel(45f);\n\t    \n\t    score = gameSave.getScore();\n\n\n\t    waveManager.setWaveNumber(gameSave.getWaveNumber());\n\t    waveManager.setZombiesRemaining(gameSave.getZombiesRemaining());\n\n\t    List<String> unlockedWeapons = gameSave.getUnlockedWeapons();\n\t    List<int[]> weaponAmmo = gameSave.getWeaponAmmo();\n\n\t    HashMap<Class<?>, int[]> tempStorage = new HashMap<>(player.weaponAmmoStorage);\n\n\t    player.getAvailableWeapons().clear();\n\t    for (int i = 0; i < unlockedWeapons.size(); i++) {\n\t        try {\n\t            Class<?> weaponClass = Class.forName(unlockedWeapons.get(i));\n\t            player.unlockWeapon(weaponClass);\n\t            // Mermi bilgilerini ayarla\n\t            if (i < weaponAmmo.size()) {\n\t                int[] ammoInfo = weaponAmmo.get(i);\n\t                player.updateWeaponAmmoStorage(weaponClass, ammoInfo[0], ammoInfo[1]);\n\t            }\n\t        } catch (ClassNotFoundException e) {\n\t            System.err.println(\"Silah sınıfı bulunamadı: \" + e.getMessage());\n\t        }\n\t    }\n\n\t    int activeWeaponIndex = gameSave.getActiveWeaponIndex();\n\t    player.switchWeapon(activeWeaponIndex);\n\t    \n        gameStartTime = System.currentTimeMillis();\n        timerRunning = true;\n        formattedTime = \"00:00\";\n\n\n\t    List<ZombieData> zombies = gameSave.getZombies();\n\t    for (ZombieData zombieData : zombies) {\n\n\t        float dx = zombieData.getX() - player.getX();\n\t        float dy = zombieData.getY() - player.getY();\n\t        float distance = (float) Math.sqrt(dx * dx + dy * dy);\n\n\t        if (distance < 50) {\n\t            float angle = (float) Math.atan2(dy, dx);\n\t            zombieData.setX(player.getX() + (float)Math.cos(angle) * 150);\n\t            zombieData.setY(player.getY() + (float)Math.sin(angle) * 150);\n\t            System.out.println(\"Zombie güvenli mesafeye taşındı!\");\n\t        }\n\t        \n\t        GameObject zombie = createZombieFromData(zombieData);\n\t        if (zombie != null) {\n\t            handler.addObject(zombie);\n\t        }\n\t    }\n\n\t    List<AmmoClipData> ammoClipDataList = gameSave.getAmmoClips();\n\t    for (AmmoClipData ammoClipData : ammoClipDataList) {\n\t        if (!ammoClipData.isCollected()) {\n\t            AmmoClip ammoClip = new AmmoClip(ammoClipData.getX(), ammoClipData.getY(), ID.AmmoClip, handler);\n\t            handler.addObject(ammoClip);\n\t        }\n\t    }\n\t    \n\t    player.setInvulnerable(true);\n\t    new java.util.Timer().schedule(\n\t        new java.util.TimerTask() {\n\t            @Override\n\t            public void run() {\n\t                if (player != null) {\n\t                    player.setInvulnerable(false);\n\t                }\n\t            }\n\t        },\n\t        3000 // 3 saniye\n\t    );\n\n\t    System.out.println(\"Oyun başarıyla yüklendi!\");\n\n\t    if (menuMusic != null) {\n\t        menuMusic.stop();\n\t    }\n\n\t    if (gameMusic != null) {\n\t        gameMusic.loop();\n\t    }\n\t    \n\t}\n\n\tprivate GameObject createZombieFromData(ZombieData zombieData) {\n\t\tGameObject zombie = null;\n\n\t\tZombieType zombieType = ZombieType.NORMAL; \n\t\t\n\t\tif (zombieData.getType().equals(\"TankZombie\")) {\n\t\t\tzombieType = ZombieType.TANK;\n\t\t} else if (zombieData.getType().equals(\"CrawlerZombie\")) {\n\t\t\tzombieType = ZombieType.CRAWLER;\n\t\t} else if (zombieData.getType().equals(\"NormalZombie\")) {\n\t\t\tzombieType = ZombieType.NORMAL;\n\t\t}\n\t\telse if (zombieData.getType().equals(\"KamikazeZombie\")) {\n\t\t\tzombieType = ZombieType.KAMIKAZE;\n\t\t}\n\t\telse if (zombieData.getType().equals(\"AcidSpitterZombie\")) {\n\t\t\tzombieType = ZombieType.ACID_SPITTER;\n\t\t}\n\t\t\n\t\tif (zombieData.getType().equals(\"NormalZombie\")) {\n\t\t\tzombie = new NormalZombie(\n\t\t\t\tzombieData.getX(), \n\t\t\t\tzombieData.getY(), \n\t\t\t\tzombieType,\n\t\t\t\thandler, \n\t\t\t\tmap, \n\t\t\t\twaveManager\n\t\t\t);\n\t\t} else if (zombieData.getType().equals(\"CrawlerZombie\")) {\n\t\t\tzombie = new CrawlerZombie(\n\t\t\t\tzombieData.getX(), \n\t\t\t\tzombieData.getY(), \n\t\t\t\tzombieType,\n\t\t\t\thandler, \n\t\t\t\tmap, \n\t\t\t\twaveManager\n\t\t\t);\n\t\t} else if (zombieData.getType().equals(\"KamikazeZombie\")) {\n\t\t\t\tzombie = new KamikazeZombie(\n\t\t\t\t\tzombieData.getX(), \n\t\t\t\t\tzombieData.getY(), \n\t\t\t\t\tzombieType,\n\t\t\t\t\thandler, \n\t\t\t\t\tmap, \n\t\t\t\t\twaveManager\n\t\t\t);\n\t\t} else if (zombieData.getType().equals(\"TankZombie\")) {\n\t\t\tzombie = new TankZombie(\n\t\t\t\tzombieData.getX(), \n\t\t\t\tzombieData.getY(), \n\t\t\t\tzombieType,\n\t\t\t\thandler, \n\t\t\t\tmap, \n\t\t\t\twaveManager\n\t\t\t);\n\t\t\t\n\t\t}\n\t\telse if (zombieData.getType().equals(\"AcidSpitterZombie\")) {\n\t\t\tzombie = new AcidSpitterZombie(\n\t\t\t\tzombieData.getX(), \n\t\t\t\tzombieData.getY(), \n\t\t\t\tzombieType,\n\t\t\t\thandler, \n\t\t\t\tmap, \n\t\t\t\twaveManager\n\t\t\t);\n\t\t\t\n\t\t}\n\t\t\n\t\t// Eğer zombie oluşturulmuşsa, sağlık değerini ayarla\n\t\tif (zombie != null && zombie instanceof Enemy) {\n\t\t\t((Enemy) zombie).setHealth(zombieData.getHealth());\n\t\t}\n\t\t\n\t\treturn zombie;\n\t}\n\tprivate void preloadZombies() {\n\n\t    if (waveManager == null) {\n\t        return;\n\t    }\n\n\t    try {\n\n\t        ImageCache.getImage(\"/images/NormalZombie.png\");\n\t        ImageCache.getImage(\"/images/TankZombie.png\");\n\t        ImageCache.getImage(\"/images/CrawlerZombie.png\");\n\t        ImageCache.getImage(\"/images/AcidSpitterZombie.png\");\n\t        ImageCache.getImage(\"/images/KamikazeZombie.png\");\n\t    } catch (Exception e) {\n\t        \n\t    }\n\n\t    float hiddenX = -1000;\n\t    float hiddenY = -1000;\n\t    \n\n\t    try {\n\n\t        GameObject normalZombie = new NormalZombie(hiddenX, hiddenY, ZombieType.NORMAL, handler, map, waveManager);\n\t        GameObject tankZombie = new TankZombie(hiddenX, hiddenY, ZombieType.TANK, handler, map, waveManager);\n\t        GameObject crawlerZombie = new CrawlerZombie(hiddenX, hiddenY, ZombieType.CRAWLER, handler, map, waveManager);\n\t        GameObject acidSpitterZombie = new AcidSpitterZombie(hiddenX, hiddenY, ZombieType.ACID_SPITTER, handler, map, waveManager);\n\t        GameObject KamikazeZombie = new KamikazeZombie(hiddenX, hiddenY, ZombieType.KAMIKAZE, handler, map, waveManager);\n\t        \n\t        preloadedZombies.add(normalZombie);\n\t        preloadedZombies.add(tankZombie);\n\t        preloadedZombies.add(crawlerZombie);\n\t        preloadedZombies.add(acidSpitterZombie);\n\t        preloadedZombies.add(KamikazeZombie);\n\t    } catch (Exception e) {\n\t        e.printStackTrace();\n\t    }\n\t}\n\t\n\tpublic Menu getMainMenu() {\n\t\treturn mainMenu;\n\t}\n\n\tpublic Menu getPauseMenu() {\n\t\treturn pauseMenu;\n\t}\n\n\t@Override\n\tpublic void mouseMoved(MouseEvent e) {\n\t\tmouseX = e.getX();\n\t\tmouseY = e.getY();\n\t}\n\n\t@Override\n\tpublic void mouseDragged(MouseEvent e) {\n\t\tmouseX = e.getX();\n\t\tmouseY = e.getY();\n\t}\n\t\n\tprivate void render() {\n\t\t   BufferStrategy bs = this.getBufferStrategy();\n\t\t    if (bs == null) {\n\t\t        this.createBufferStrategy(3);\n\t\t        return;\n\t\t    }\n\n\t\t    Graphics g = bs.getDrawGraphics();\n\t\t    Graphics2D g2d = (Graphics2D) g;\n\n\t\t    if (loadingStage < LOADING_STAGE_COMPLETE) {\n\t\t        renderLoadingScreen(g);\n\t\t    } else {\n\t\t        if (background != null) {\n\n\t\t            g.drawImage(background, 0, 0, WIDTH, HEIGHT, null);\n\t\t        } else {\n\n\t\t            g.setColor(Color.GRAY);\n\t\t            g.fillRect(0, 0, WIDTH, HEIGHT);\n\t\t        }\n\n\t\t        if ((gameState == GameState.PLAYING || gameState == GameState.PAUSED) && player != null) {\n\t\t         \n\t\t            float offsetX = player.getX() - WIDTH / 2 + Player.PLAYER_SIZE / 2;\n\t\t            float offsetY = player.getY() - HEIGHT / 2 + Player.PLAYER_SIZE / 2;\n\n\t\t    \n\t\t            camera.setX(offsetX);\n\t\t            camera.setY(offsetY);\n\n\t\t       \n\t\t            AffineTransform oldTransform = g2d.getTransform();\n\n\t\t \n\t\t            float zoomFactor = camera.getZoomLevel() / 20.0f;  \n\t\t            \n\t\t     \n\t\t            float centerX = WIDTH / 2;\n\t\t            float centerY = HEIGHT / 2;\n\t\t            \n\t\t         \n\t\t            g2d.translate(centerX, centerY);\n\t\t            g2d.scale(zoomFactor, zoomFactor);\n\t\t            g2d.translate(-centerX, -centerY);\n\t\t            \n\t\t   \n\t\t            g2d.translate(-camera.getX(), -camera.getY());\n\t\t            \n\t\t         \n\t\t            map.render(g, null);\n\t\t            handler.render(g);\t\t            \t\t            \n\t\t         \n\t\t            g2d.setTransform(oldTransform);\n\t\t            \t\t        \n\t\t            renderHUD(g2d);\n\t\t        }\n\t\t        \n\t\t        if (timerRunning && gameState == GameState.PLAYING) {\n\t\t            long currentTime = System.currentTimeMillis();\n\t\t            long elapsedTime = (currentTime - gameStartTime) / 1000; // Convert to seconds\n\t\t            \n\t\t            long minutes = elapsedTime / 60;\n\t\t            long seconds = elapsedTime % 60;\n\t\t            \n\t\t            formattedTime = String.format(\"%02d:%02d\", minutes, seconds);\n\t\t        }\n\n\t\t        // Stop timer when game ends\n\t\t        if (gameState == GameState.GAME_OVER && timerRunning) {\n\t\t            timerRunning = false;\n\t\t        }\n\n\t\t        if (gameState == GameState.MENU) {\n\t\t            mainMenu.render(g);\n\t\t        } else if (gameState == GameState.PAUSED) {\n\t\t            g.setColor(new Color(0, 0, 0, 150));\n\t\t            g.fillRect(0, 0, WIDTH, HEIGHT);\n\t\t            pauseMenu.render(g);\n\t\t        } else if (gameState == GameState.GAME_OVER) {\n\t\t            mainMenu.render(g);\n\t\t        } else if (gameState == GameState.LOADING_GAME) {\n\t\t            renderLoadingScreen(g);\n\t\t        }\n\t\t    }\n\n\t\t    bs.show();\n\t\t    g.dispose();\n\t}\n\n\tprivate void renderLoadingScreen(Graphics g) {\n\n        g.setColor(Color.BLACK);\n        g.fillRect(0, 0, WIDTH, HEIGHT);\n        \n\n        if (gameState == GameState.LOADING_GAME) {\n     \n            g.setColor(Color.WHITE);\n            \n\n            Font titleFont = new Font(\"Arial\", Font.BOLD, 40);\n            g.setFont(titleFont);\n            String titleText = \"Top-Shooter Zombie Game\";\n            FontMetrics titleFm = g.getFontMetrics();\n            g.drawString(titleText, WIDTH / 2 - titleFm.stringWidth(titleText) / 2, HEIGHT / 3);\n            \n            Font msgFont = new Font(\"Arial\", Font.BOLD, 24);\n            g.setFont(msgFont);\n            \n            String loadingMessage;\n            if (loadingProgress < 0.3f) {\n                loadingMessage = \"Oyun kaynakları hazırlanıyor...\";\n            } else if (loadingProgress < 0.6f) {\n                loadingMessage = \"Oyun dünyası oluşturuluyor...\";\n            } else if (loadingProgress < 0.9f) {\n                loadingMessage = \"Zombiler yerleştiriliyor...\";\n            } else if (!musicStarted) {\n                loadingMessage = \"Müzik başlatılıyor...\";\n            } else {\n                loadingMessage = \"Oyun başlıyor!\";\n            }\n            \n            FontMetrics msgFm = g.getFontMetrics();\n            g.drawString(loadingMessage, WIDTH / 2 - msgFm.stringWidth(loadingMessage) / 2, HEIGHT / 2);\n            \n            int barWidth = 600;\n            int barHeight = 30;\n            int barX = WIDTH / 2 - barWidth / 2;\n            int barY = HEIGHT / 2 + 50;\n            \n            g.setColor(Color.DARK_GRAY);\n            g.fillRect(barX, barY, barWidth, barHeight);\n            \n            g.setColor(Color.GREEN);\n            int fillWidth = (int)(barWidth * loadingProgress);\n            g.fillRect(barX, barY, fillWidth, barHeight);\n            \n            g.setColor(Color.WHITE);\n            String percentText = String.format(\"%%%.0f\", loadingProgress * 100);\n            g.drawString(percentText, WIDTH / 2 - msgFm.stringWidth(percentText) / 2, barY + barHeight + 30);\n            \n            Font hintFont = new Font(\"Arial\", Font.ITALIC, 18);\n            g.setFont(hintFont);\n            String hintText = \"Müziğin başlamasını bekleniyor...\";\n            FontMetrics hintFm = g.getFontMetrics();\n            g.drawString(hintText, WIDTH / 2 - hintFm.stringWidth(hintText) / 2, HEIGHT * 3/4);\n        } else {\n            g.setColor(Color.WHITE);\n            \n            String loadingMessage = \"\";\n            int progressPercent = 0;\n            \n            switch (loadingStage) {\n                case LOADING_STAGE_INIT:\n                    loadingMessage = \"Oyun başlatılıyor...\";\n                    progressPercent = 10;\n                    break;\n                case LOADING_STAGE_UI:\n                    loadingMessage = \"Arayüz elemanları yükleniyor...\";\n                    progressPercent = 30;\n                    break;\n                case LOADING_STAGE_RESOURCES:\n                    loadingMessage = \"Oyun kaynakları yükleniyor...\";\n                    progressPercent = 60;\n                    break;\n                case LOADING_STAGE_COMPLETE:\n                    loadingMessage = \"Tamamlandı!\";\n                    progressPercent = 100;\n                    break;\n            }\n            \n            Font font = new Font(\"Arial\", Font.BOLD, 20);\n            g.setFont(font);\n            FontMetrics fm = g.getFontMetrics();\n            int textWidth = fm.stringWidth(loadingMessage);\n            g.drawString(loadingMessage, WIDTH / 2 - textWidth / 2, HEIGHT / 2 - 30);\n\n            int barWidth = 400;\n            int barHeight = 20;\n            int fillWidth = (progressPercent * barWidth) / 100;\n\n            g.setColor(Color.GRAY);\n            g.drawRect(WIDTH / 2 - barWidth / 2, HEIGHT / 2, barWidth, barHeight);\n            \n            g.setColor(Color.GREEN);\n            g.fillRect(WIDTH / 2 - barWidth / 2, HEIGHT / 2, fillWidth, barHeight);\n        }\n\t}\n\t\n\tprivate void renderHUD(Graphics2D g2d) {\n\t    g2d.setColor(Color.WHITE);\n\t    g2d.setFont(new Font(\"Arial\", Font.BOLD, 15));\n\n\t    // Weapon and ammo info (left top)\n\t    if (player != null && player.getCurrentWeapon() != null) {\n\t        g2d.drawString(\"Silah: \" + player.getCurrentWeapon().getClass().getSimpleName(), 10, 20);\n\t        g2d.drawString(\"Mermi: \" + player.getCurrentWeapon().getCurrentAmmo() + \" / \" +\n\t            player.getCurrentWeapon().getTotalAmmo(), 10, 40);\n\t    } else {\n\t        g2d.drawString(\"Silah: Yok\", 10, 20);\n\t        g2d.drawString(\"Mermi: 0 / 0\", 10, 40);\n\t    }\n\n\t    // Wave info\n\t    g2d.drawString(\"Wave: \" + waveManager.getWaveNumber(), 10, 60);\n\t    \n\t    // Timer display \n\t    g2d.drawString(\"Süre: \" + formattedTime, 10, 80);\n\t    \n\t    \n\n\t    // Health and score info (right top)\n\t    if (player != null) {\n\t        String healthInfo = \"Can: \" + player.getHealth() + \" / \" + player.getMaxHealth();\n\t        String scoreInfo = \"Puan: \" + score;\n\n\t        FontMetrics fm = g2d.getFontMetrics();\n\t        int healthInfoWidth = fm.stringWidth(healthInfo);\n\t        int scoreInfoWidth = fm.stringWidth(scoreInfo);\n\t        int paddingRight = 30;\n\t        int yPos = 20;\n\n\t        g2d.drawString(healthInfo, WIDTH - healthInfoWidth - paddingRight, yPos);\n\t        g2d.drawString(scoreInfo, WIDTH - scoreInfoWidth - paddingRight, yPos + 20);\n\t        g2d.drawString(\"FPS: \" + fps, WIDTH - scoreInfoWidth - paddingRight, yPos + 40); \n\t    }\n\t}\n\n\n\n\tpublic int getScore() {\n\t\treturn score;\n\t}\n\n\tpublic void updateGameOverStats(int wave, int score) {\n\t\tgameOverWave = wave;\n\t\tgameOverScore = score;\n\t\tgameOverWave = -1; \n\t\tgameOverScore = -1;\n\t}\n\n\tpublic static Game getInstance() {\n\t\treturn instance;\n\t}\n\n\tpublic void setGameState(GameState gameState) {\n\t\tthis.gameState = gameState;\n\t}\n\n\tpublic int getGameOverWave() {\n\t\treturn gameOverWave;\n\t}\n\n\tpublic int getGameOverScore() {\n\t\treturn gameOverScore;\n\t}\n\n\tpublic static void increaseScore(int amount) {\n\t\tif (instance != null) { \n\t\t\tinstance.score += amount;\n\t\t}\n\t}\n\t\n\tprivate void loadResourcesAsync() {\n\t\tThread resourceLoadingThread = new Thread(() -> {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tSystem.out.println(\"Oyun kaynakları yükleniyor...\");\n\t\t\t\tImageCache.preloadImages(ImageCache.ImageType.GAME);\n\t\t\t\t\n\t\t\t\n\t\t\t\tmenuMusic = new SoundPlayer(\"sounds/menu_music.wav\");\n\t\t\t\tgameMusic = new SoundPlayer(\"sounds/game_music.wav\");\n\t\t\t\t\n\t\t\t\n\t\t\t\tresourcesLoaded = true;\n\t\t\t\tloadingStage = LOADING_STAGE_COMPLETE;\n\t\t\t\t\n\t\t\t\n\t\t\t\tif (gameState == GameState.MENU && menuMusic != null && !menuMusic.isPlaying()) {\n\t\t\t\t\tmenuMusic.loop();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println(\"Tüm kaynaklar başarıyla yüklendi.\");\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.err.println(\"Kaynak yükleme hatası: \" + e.getMessage());\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t});\n\t\t\n\t\tresourceLoadingThread.setPriority(Thread.MIN_PRIORITY); // Düşük öncelikli thread\n\t\tresourceLoadingThread.start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tSplashScreen splash = SplashScreen.getSplashScreen();\n\t\t\tif (splash != null) {\n\t\t\t\tGraphics2D g = splash.createGraphics();\n\t\t\t\tg.setColor(Color.BLACK);\n\t\t\t\tg.drawString(\"Oyun başlatılıyor...\", 120, 150);\n\t\t\t\tsplash.update();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(\"Splash screen hatası: \" + e.getMessage());\n\t\t}\n\t\t\n\t\tnew Game();\n\t}\n}\n",
      "MouseInput.java": "package ödev2;\n\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class MouseInput extends MouseAdapter {\n    private Handler handler;\n    private GameObject tempPlayer = null;\n    private Camera camera;\n    private int mx, my;\n    private boolean isShooting = false;\n    private Player objPlayer = null;\n    private long lastShotTime = 0;\n    private int shootCooldown = 100; // Milisaniye cinsinden atış gecikmesi\n    private float mouseX, mouseY;\n    private Game game;\n\n    public MouseInput(Handler handler, Camera camera, Game game) {\n        this.handler = handler;\n        this.camera=camera;\n        this.game = game;\n       \n    }\n\n    public void findPlayer() {\n        for(int i = 0; i < handler.object.size(); i++) {\n            if(handler.object.get(i).getId() == ID.Player) {\n                tempPlayer = handler.object.get(i);\n                objPlayer = (Player) handler.object.get(i);\n                break;\n            }\n        }\n    }\n\n    public void mousePressed(MouseEvent e) {\n    \t\n    \tif (game.getGameState() == GameState.MENU || game.getGameState() == GameState.PAUSED) {\n            if (game.getGameState() == GameState.MENU) {\n                game.getMainMenu().mousePressed(e.getX(), e.getY());\n            } else {\n                game.getPauseMenu().mousePressed(e.getX(), e.getY());\n            }\n            return;\n        }\n\n    \t if (e.getButton() == MouseEvent.BUTTON1 && game.getGameState() == GameState.PLAYING) { // Sol tık\n             if(tempPlayer == null) {\n                 findPlayer();\n             }\n             \n             if (objPlayer != null) {\n                 objPlayer.startFiring(); \n                 \n                 mx = e.getX();\n                 my = e.getY();\n                 \n                 updatePlayerMousePosition();\n                 \n\n                 float angle = objPlayer.calculateAngleToMouse();\n                 objPlayer.setAngle(angle);\n\n                 objPlayer.shoot(angle);\n             }\n         }\n    }\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        if (e.getButton() == MouseEvent.BUTTON1) {\n            isShooting = false; \n            if (objPlayer != null) {\n                objPlayer.stopFiring(); \n            }\n        }\n    }\n    private void updatePlayerMousePosition() {\n        if (objPlayer != null) {\n            float targetX = mx + camera.getX(); \n            float targetY = my + camera.getY();\n            objPlayer.updateMousePosition(targetX, targetY);\n        }\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        mx = e.getX();\n        my = e.getY();\n        \n        if (objPlayer != null) {\n            updatePlayerMousePosition();\n\n            float angle = objPlayer.calculateAngleToMouse();\n            objPlayer.setAngle(angle);\n\n        }\n    }\n    \n    \n    \n    public void setPlayer(Player player) {\n        this.objPlayer = player;\n        this.tempPlayer = player; \n    }\n    public int getMx() {\n        return mx;\n    }\n\n    public int getMy() {\n        return my;\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        mx = e.getX();\n        my = e.getY();\n\n        if (game.getGameState() == GameState.MENU) {\n            game.getMainMenu().mouseMoved(mx, my);\n        } else if (game.getGameState() == GameState.PAUSED) {\n            game.getPauseMenu().mouseMoved(mx, my);\n        }\n\n        if (game.getGameState() == GameState.PLAYING && objPlayer != null) {\n            updatePlayerMousePosition();\n            float angle = objPlayer.calculateAngleToMouse();\n            objPlayer.setAngle(angle);\n        }\n    }\n\n\tpublic void setCamera(Camera camera) {\n\t\tthis.camera = camera;\n\t\t\n\t}\n    }\n\n\n\n\n",
      "AcidExplosionEffect.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class AcidExplosionEffect extends GameObject {\n    private int radius;\n    private int timer;\n    private Handler handler;\n    \n    public AcidExplosionEffect(float x, float y, int radius, Handler handler) {\n        super(x, y, ID.Effect); \n        this.radius = radius;\n        this.timer = 20; \n        this.handler = handler;\n    }\n    \n    @Override\n    public void tick() {\n        timer--;\n        if (timer <= 0) {\n            handler.removeObject(this);\n        }\n    }\n    \n    @Override\n    public void render(Graphics g) {\n        g.setColor(new Color(0, 255, 0, 128 - (timer * 6))); \n        \n        int scaledRadius = (int) (radius * 0.6); \n        g.fillOval((int) (x - scaledRadius / 2), (int) (y - scaledRadius / 2), scaledRadius, scaledRadius);\n    }\n    \n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(0, 0, 0, 0); \n    }\n}\n",
      "Camera.java": "package ödev2;\n\npublic class Camera {\n    private float x, y;\n\tprivate Handler handler;\n    private Game game;\n    \n    private float zoomLevel = 20f;\n\n    public Camera(float x, float y, Handler handler, Game game) {\n        this.x = x;\n        this.y = y;\n        this.handler = handler;\n        this.game = game;\n    }\n\n    public void tick(GameObject object) {\n        float targetX = object.getX() - Game.WIDTH/2 + 16; // 16 is half player width\n        float targetY = object.getY() - Game.HEIGHT/2 + 16; // 16 is half player height\n        \n\n        x = targetX;\n        y = targetY;\n    }\n    public void follow(GameObject player) {\n        float offsetX = Game.WIDTH * 0.75f; \n        float offsetY = Game.HEIGHT * 0.8f;\n        \n        this.x = player.getX() - offsetX;\n        this.y = player.getY() - offsetY;\n    }\n    public float getX() {\n        return x;\n    }\n\n    public float getY() {\n        return y;\n    }\n    public void setX(float x) {\n\t\tthis.x = x;\n\t}\n\n\tpublic void setY(float y) {\n\t\tthis.y = y;\n\t}\n\n    public float getZoomLevel() {\n        return zoomLevel;\n    }\n\n    public void setZoomLevel(float zoomLevel) {\n        this.zoomLevel = zoomLevel;\n    }\n}\n\n\n",
      "SpriteSheet.java": "package ödev2;\n\nimport java.awt.image.BufferedImage;\n\npublic class SpriteSheet {\n    private BufferedImage sheet;\n    private int tileWidth;\n    private int tileHeight;\n    \n    public SpriteSheet(BufferedImage sheet, int tileWidth, int tileHeight) {\n        this.sheet = sheet;\n        this.tileWidth = tileWidth;\n        this.tileHeight = tileHeight;\n    }\n    \n    public BufferedImage grabImage(int col, int row) {\n        if (sheet == null) return null;\n        return sheet.getSubimage(col * tileWidth, row * tileHeight, tileWidth, tileHeight);\n    }\n}\n",
      "AmmoClip.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\n\npublic class AmmoClip extends GameObject {\n    private int ammoAmount; \n    private Handler handler; \n    private boolean collected = false;\n    \n    public AmmoClip(float x, float y, ID id) {\n        super(x, y, id);\n        this.ammoAmount = 30; \n    }\n    \n\n    public AmmoClip(float x, float y, ID id, Handler handler) {\n        super(x, y, id);\n        this.handler = handler;\n        this.ammoAmount = 30; \n    }\n    \n    public void setHandler(Handler handler) {\n        this.handler = handler;\n    }\n\n    @Override\n    public void tick() {\n        if (collected) return;\n\n      \n        if (handler != null) {\n            Player player = handler.getPlayer();\n            if (player != null && getBounds().intersects(player.getBounds())) {\n            \n                player.collectAmmo(ammoAmount);\n                collected = true;\n                handler.removeObject(this);\n            }\n        }\n    }\n\n    @Override\n    public void render(Graphics g) {\n        if (collected) return;\n\n        g.setColor(Color.ORANGE);\n        g.fillRect((int) x, (int) y, 16, 16);\n        g.setColor(Color.BLACK); \n        g.drawRect((int) x, (int) y, 16, 16);\n        \n        g.setColor(Color.YELLOW);\n        g.fillRect((int) x + 5, (int) y + 3, 6, 10);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle((int) x, (int) y, 16, 16);\n    }\n    \n    public void setAmmoAmount(int amount) {\n        this.ammoAmount = amount;\n    }\n    \n    public int getAmmoAmount() {\n        return ammoAmount;\n    }\n    public boolean isCollected() {\n        return collected;\n    }\n\n    public void setCollected(boolean collected) {\n        this.collected = collected;\n    }\n}\n\n",
      "RocketLauncher.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class RocketLauncher extends Weapon {\n\n    public RocketLauncher() {\n        super();\n\n        this.magazineSize = 1;\n        this.currentAmmo = magazineSize;\n        this.totalAmmo = 5;\n        this.damage = 100; \n        this.spread = 0.02f; \n        this.bulletSpeed = 12.0f; \n        this.bulletSize = 12; \n        this.hasInfiniteAmmo = false;\n        this.isPiercing = false;\n        this.isExplosive = true; \n        this.penetration = 1;\n        \n        this.timeBetweenShots = 1.5f; \n        this.isAutomatic = false;\n        \n        try {\n      \tweaponIcon = ImageIO.read(new File(\"src/images/RocketLauncher.png\"));\n      } catch (IOException e) {\n         // System.err.println(\"Silah simgesi yüklenemedi: \" + e.getMessage());\n      }\n        \n    }\n\n    @Override\n    public int getMagazineCapacity() {\n        return 1; \n    }\n\n    @Override\n    public int getFireRate() {\n        return 10; \n    }\n    \n    @Override\n    protected void createBullet(float angle, float playerX, float playerY) {\n    \t float finalAngle = angle + (float) ((Math.random() - 0.5) * 2 * spread);\n           \n         Bullet rocket = Bullet.createBullet(\n             \"rocket\",              \n             playerX, playerY,      \n             finalAngle,           \n             spread,               \n             bulletSpeed,           \n             damage,              \n             penetration,          \n             isExplosive,           \n             bulletSize,           \n             Color.RED,           \n             handler,               \n             handler.getPlayer()    \n         );\n         \n         // Patlama yarıçapını ayarla\n         rocket.setExplosionRadius(120);\n         \n         if (handler != null) {\n             handler.addObject(rocket);\n         } else {\n             System.err.println(\"HATA: RocketLauncher - handler null!\");\n         }\n    }\n\n\t@Override\n\tprotected void loadShootSound() {\n\t\tshootSound = new SoundPlayer(\"sounds/rocket_explosion.wav\");\n\t\t\n\t}\n}\n",
      "ImageCache.java": "package ödev2;\n\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport javax.imageio.ImageIO;\n\npublic class ImageCache {\n\n    private static HashMap<String, BufferedImage> imageCache = new HashMap<>();\n    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);\n    private static boolean isPreloadComplete = false;\n\n    public enum ImageType {\n        MENU, GAME\n    }\n\n    public static void preloadImagesAsync(ImageType type, Runnable onComplete) {\n        threadPool.submit(() -> {\n            preloadImages(type);\n            if (onComplete != null) {\n                onComplete.run();\n            }\n        });\n    }\n\n    public static void preloadImages(ImageType type) {\n        System.out.println(\"Önbelleğe alınıyor: \" + type);\n\n        String[] imageFiles;\n\n        switch (type) {\n            case MENU:\n                imageFiles = new String[]{\n                    \"MenuBackground2.png\"\n                  \n                };\n                break;\n            case GAME:\n                imageFiles = new String[]{\n                    \"NormalZombie.png\",\n                    \"TankZombie.png\",\n                    \"CrawlerZombie.png\",\n                    \"AcidSpitterZombie.png\",\n                    \"KamikazeZombie.png\",\n                    \"Pistol.png\",\n                    \"AssaultRifle.png\",\n                    \"Shotgun.png\",\n                    \"Bullet.png\"\n                  \n                };\n                break;\n            default:\n                throw new IllegalArgumentException(\"Bilinmeyen resim türü: \" + type);\n        }\n\n        for (String file : imageFiles) {\n            getImage(file); \n        }\n\n        \n    }\n    \n    // Load all game images at startup\n    public static void preloadImages() {\n        System.out.println(\"Preloading all game images...\");\n        \n        String[] imageFiles = {\n            \"NormalZombie.png\",\n            \"TankZombie.png\", \n            \"CrawlerZombie.png\",\n            \"AcidSpitterZombie.png\",\n            \"Pistol.png\",\n            \"AssaultRifle.png\",\n            \"Shotgun.png\",\n            \"Bullet.png\",\n            \"MenuBackground.png\",\n            \"SniperRifle.png\",\n            \"KamikazeZombie.png\",\n            \"RocketLauncher.png\"\n        };\n        \n        for (String file : imageFiles) {\n            getImage(\"/images/\" + file);\n        }\n        \n        System.out.println(\"Image preloading complete: \" + imageCache.size() + \" images loaded\");\n    }\n\n    public static BufferedImage getImage(String imageName) {\n        if (imageCache.containsKey(imageName)) {\n            return imageCache.get(imageName);\n        }\n\n        BufferedImage image = loadImage(imageName);\n        if (image != null) {\n            imageCache.put(imageName, image);\n            return image;\n        } else {\n            return null;\n        }\n    }\n\n    private static BufferedImage loadImage(String imageName) {\n        try {\n            InputStream is = ImageCache.class.getResourceAsStream(\"/images/\" + imageName);\n\n            if (is == null) {\n                String basePath = \"C:\\\\Users\\\\mkasl\\\\eclipse-workspace\\\\ödev2\\\\src\\\\images\\\\\"; \n                String imagePath = basePath + imageName; \n                File file = new File(imagePath);\n\n                if (file.exists()) {\n                    is = new FileInputStream(file);\n                } else {\n                    \n                    return null;\n                }\n            }\n\n            BufferedImage img = ImageIO.read(is);\n            is.close();\n\n            if (img != null) {\n                System.out.println(\"Image cached: \" + imageName);\n                return img;\n            } else {\n                \n                return null;\n            }\n        } catch (IOException e) {\n            \n            return null;\n        }\n    }\n\n    public static boolean isLoadingComplete() {\n        return isPreloadComplete;\n    }\n}",
      "Window.java": "package ödev2;\n\nimport java.awt.Dimension;\nimport javax.swing.JFrame;\n\n\npublic class Window {\n\tpublic static JFrame frame;\n    public Window(int width, int height, String title, Game game) {\n        frame = new JFrame(title);\n\n        frame.setPreferredSize(new Dimension(width, height));\n        frame.setMaximumSize(new Dimension(width, height));\n        frame.setMinimumSize(new Dimension(width, height));\n\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setResizable(false);\n        frame.setLocationRelativeTo(null);\n        frame.add(game);\n        frame.setVisible(true);\n        \n    }\n}\n",
      "Player.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.event.KeyEvent;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\nimport javax.imageio.ImageIO;\n\npublic class Player extends GameObject {\n    \n    Handler handler;\n    Map map;\n    static final int PLAYER_SIZE = 32;\n    private float oldX, oldY;\n    private Weapon currentWeapon; \n    private List<Weapon> weapons; \n    private float angle;\n    private MouseInput minput;\n    private Camera cam;\n    private KeyInput keyInput;\n    private WaveManager waveManager;\n    private List<Class<?>> availableWeapons;\n    private long lastShotTime = 0; \n    private int shotCooldown = 200; \n    protected HashMap<Class<?>, int[]> weaponAmmoStorage;\n    private boolean isFiring = false;\n    private float mouseX, mouseY;\n    private boolean mouseAngleUpdated = false;\n    private BufferedImage playerImage;\n    private AffineTransform transform;\n    private double rotation = 0;\n    private boolean invulnerable = false;\n    private float speedMultiplier = 1.0f;\n    private float damageMultiplier = 1.0f;\n    private long speedBoostEndTime = 0;\n    private long damageBoostEndTime = 0;\n    private boolean isSpeedBoosted = false;\n    private boolean isDamageBoosted = false;\n    \n    public Player(float x, float y, ID id, Handler handler, Map map, MouseInput minput, Camera cam, KeyInput keyInput, WaveManager waveManager) {\n        super(x, y, id);\n        this.handler = handler;\n        this.map = map;\n        this.minput = minput;\n        this.keyInput = keyInput;\n        this.cam = cam;\n        this.waveManager = waveManager;\n        this.maxHealth = 100; \n        this.health = maxHealth; \n        this.transform = new AffineTransform();\n        \n        availableWeapons = new ArrayList<>();\n        weaponAmmoStorage = new HashMap<>();\n        \n        availableWeapons.add(Pistol.class);\n        switchWeapon(0); \n        loadPlayerImage();\n    }\n    \n    private void loadPlayerImage() {\n        try {\n            File file = new File(\"src/images/player.png\");\n            if (!file.exists()) {\n                file = new File(\"images/player.png\");\n                if (!file.exists()) {\n                    file = new File(\"res/player.png\");\n                }\n            }\n            \n            if (file.exists()) {\n                playerImage = ImageIO.read(file);\n                System.out.println(\"Player image loaded successfully from: \" + file.getAbsolutePath());\n            } else {\n                System.err.println(\"Player image file not found. Tried multiple locations.\");\n                // Load from resources as a fallback method\n                playerImage = ImageIO.read(getClass().getResourceAsStream(\"/images/player.png\"));\n            }\n            \n            if (playerImage == null) {\n                System.err.println(\"Player image couldn't be loaded!\");\n            } else {\n                System.out.println(\"Player image loaded successfully.\");\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error loading player image: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n    \n    @Override\n    public void tick() {\n        oldX = x; \n        oldY = y;\n        \n        x += velX;\n        if(checkCollision()) {\n            x = oldX;\n            velX = 0;\n        }\n        \n        y += velY;\n        if(checkCollision()) {\n            y = oldY;\n            velY = 0;\n        }\n        \n        if (isSpeedBoosted && System.currentTimeMillis() > speedBoostEndTime) {\n            speedMultiplier = 0.6f;\n            isSpeedBoosted = false;\n            System.out.println(\"Hız boost'u sona erdi!\");\n        }\n\n        // Hız değerlerini speedMultiplier ile çarpıyoruz\n        float baseSpeed = 3.0f;\n        float boostedSpeed = baseSpeed * speedMultiplier;\n\n        if (keyInput.isKeyDown(KeyEvent.VK_D)) {\n            velX = boostedSpeed;\n        } else if (keyInput.isKeyDown(KeyEvent.VK_A)) {\n            velX = -boostedSpeed;\n        } else {\n            velX = 0;\n        }\n\n        if (keyInput.isKeyDown(KeyEvent.VK_W)) {\n            velY = -boostedSpeed;\n        } else if (keyInput.isKeyDown(KeyEvent.VK_S)) {\n            velY = boostedSpeed;\n        } else {\n            velY = 0;\n        }\n\n        if (keyInput.isKeyDown(KeyEvent.VK_R)) {\n            reloadWeapon();\n        }\n        \n        updateRotation();\n\n        angle = calculateAngleToMouse();\n\n        if (isFiring && currentWeapon != null && currentWeapon.isAutomatic()) {\n            long currentTime = System.currentTimeMillis();\n            long timeSinceLastShot = currentTime - lastShotTime;\n            long requiredDelay = (long)(currentWeapon.getTimeBetweenShots() * 1000);\n            \n            if (timeSinceLastShot >= requiredDelay) {\n                shoot(angle);\n                lastShotTime = currentTime;\n            }\n        }\n    }\n    \n    private void updateRotation() {\n\n    \t this.angle = calculateAngleToMouse();\n    \t    this.rotation = this.angle;\n    }\n    \n    private boolean checkCollision() {\n        int x1 = (int)x;\n        int y1 = (int)y;\n        int x2 = (int)x + PLAYER_SIZE - 1;\n        int y2 = (int)y + PLAYER_SIZE - 1;\n\n        return map.isBlock(x1, y1) || \n               map.isBlock(x2, y1) ||\n               map.isBlock(x1, y2) ||\n               map.isBlock(x2, y2);\n    }\n    \n    public void applySpeedBoost(float multiplier, int duration) {\n        this.speedMultiplier = multiplier;\n        this.speedBoostEndTime = System.currentTimeMillis() + duration;\n        this.isSpeedBoosted = true;\n        System.out.println(\"Hız boost'u aktifleştirildi: \" + multiplier + \"x, \" + (duration/1000) + \" saniye!\");\n    }\n\n    \n    public void switchWeapon(int index) {\n        if (index >= 0 && index < availableWeapons.size()) {\n            Class<?> weaponClass = availableWeapons.get(index);\n  \n            if (currentWeapon != null) {\n                saveCurrentWeaponAmmo();\n            }\n            try {\n  \n                currentWeapon = (Weapon) weaponClass.getDeclaredConstructor().newInstance();\n                currentWeapon.setHandler(handler);\n                loadWeaponAmmo(weaponClass);\n            } catch (Exception e) {\n                System.err.println(\"Silah değiştirme hatası: \" + e.getMessage());\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    public void shoot(float angle) {\n    \t if (currentWeapon != null) {\n    \t \n    \t        if (currentWeapon.handler == null) {\n    \t            currentWeapon.setHandler(this.handler);\n    \t        }\n\n    \t        long currentTime = System.currentTimeMillis();\n    \t        long timeSinceLastShot = currentTime - lastShotTime;\n\n    \t        long requiredCooldown = (long)(currentWeapon.getTimeBetweenShots() * 1000);\n\n    \t        if (timeSinceLastShot < requiredCooldown) {\n    \t            return;\n    \t        }\n\n    \t        if (currentWeapon.isReloading()) {\n    \t            return;\n    \t        }\n\n    \t        if (currentWeapon.getCurrentAmmo() > 0) {\n    \t            float playerCenterX = x + PLAYER_SIZE / 2;\n    \t            float playerCenterY = y + PLAYER_SIZE / 2;\n\n    \t            currentWeapon.shoot(angle, playerCenterX, playerCenterY);\n    \t            lastShotTime = currentTime; \n\n    \t            weaponAmmoStorage.put(currentWeapon.getClass(), new int[] {\n    \t                currentWeapon.getCurrentAmmo(),\n    \t                currentWeapon.getTotalAmmo()\n    \t            });\n    \t        } else {\n    \t            reloadWeapon();\n    \t        }\n    \t    }\n    }\n    \n    public void reloadWeapon() {\n        if (currentWeapon != null) {\n            currentWeapon.reload();\n            weaponAmmoStorage.put(currentWeapon.getClass(), new int[] {\n                currentWeapon.getCurrentAmmo(),\n                currentWeapon.getTotalAmmo()\n            });\n        }\n    }\n    \n    public void unlockWeapon(Class<?> weaponClass) {\n        if (!availableWeapons.contains(weaponClass)) {\n            availableWeapons.add(weaponClass);\n            System.out.println(weaponClass.getSimpleName() + \" silahı açıldı ve kullanılabilir!\");\n        } else {\n        }\n    }\n    \n    public void startFiring() {\n        isFiring = true;\n    }\n    \n    public void stopFiring() {\n        isFiring = false;\n    }\n    \n    public boolean isFiring() {\n        return isFiring;\n    }\n    \n    public float getAngle() {\n\n        return calculateAngleToMouse();\n    }\n    \n    public Weapon getCurrentWeapon() {\n        return currentWeapon;\n    }\n    \n    public int getMaxHealth() {\n        return maxHealth;\n    }\n    \n    public int getHealth() {\n        return health;\n    }\n    \n    public void setAngle(float angle) {\n        this.angle = angle;\n    }\n    public void setInvulnerable(boolean invulnerable) {\n        this.invulnerable = invulnerable;\n    }\n\n    public boolean isInvulnerable() {\n        return invulnerable;\n    }\n    \n    public void takeDamage(int damage) {\n    \t if (invulnerable) {\n    \t        return;\n    \t    }\n        this.health -= damage;\n        if (this.health <= 0) {\n            System.out.println(\"Oyuncu öldü!\");\n            Game.getInstance().setGameState(GameState.GAME_OVER);\n            Game.getInstance().updateGameOverStats(\n                waveManager.getWaveNumber(),\n                Game.getInstance().getScore()\n            );\n        } else if (this.health > maxHealth) {\n            this.health = maxHealth;\n        }\n    }\n    \n    public void setHealth(int health) {\n        this.health = health;\n    }\n    \n    public void collectAmmo(int amount) {\n        if (currentWeapon == null) return;\n   \n        int currentAmmoInMagazine = currentWeapon.getCurrentAmmo();\n        \n\n        int magazineCapacity = currentWeapon.getMagazineSize();\n\n        int totalAmmo = currentWeapon.getTotalAmmo();\n        \n        if (currentAmmoInMagazine >= magazineCapacity) {\n            return;\n        }\n\n        currentWeapon.setCurrentAmmo(magazineCapacity);\n        currentWeapon.setTotalAmmo(totalAmmo); \n\n        if (weaponAmmoStorage != null) {\n            weaponAmmoStorage.put(currentWeapon.getClass(), new int[] {\n                currentWeapon.getCurrentAmmo(),\n                currentWeapon.getTotalAmmo()\n            });\n        }\n        System.out.println(\"Şarjör dolduruldu.\");\n    }\n    \n    public void saveCurrentWeaponAmmo() {\n        weaponAmmoStorage.put(currentWeapon.getClass(), \n                              new int[]{currentWeapon.getCurrentAmmo(), currentWeapon.getTotalAmmo()});\n    }\n\n    public void loadWeaponAmmo(Class<?> weaponClass) {\n        if (weaponAmmoStorage.containsKey(weaponClass)) {\n            int[] ammoInfo = weaponAmmoStorage.get(weaponClass);\n            currentWeapon.setCurrentAmmo(ammoInfo[0]);\n            currentWeapon.setTotalAmmo(ammoInfo[1]);\n        } \n    }\n    \n    public void updateWeaponAmmoStorage(Class<?> weaponClass, int currentAmmo, int totalAmmo) {\n        weaponAmmoStorage.put(weaponClass, new int[]{currentAmmo, totalAmmo});\n    }\n    \n    public List<Class<?>> getAvailableWeapons() {\n        return availableWeapons;\n    }\n    \n    public void updateMousePosition(float x, float y) {\n        this.mouseX = x;\n        this.mouseY = y;\n    }\n    \n    public void resetWeapons() {\n\n        availableWeapons.clear();\n \n        currentWeapon = null;\n\n        weaponAmmoStorage.clear();\n    }\n    \n    public int getActiveWeaponIndex() {\n   \n        if (currentWeapon != null) {\n            for (int i = 0; i < availableWeapons.size(); i++) {\n                if (currentWeapon.getClass().equals(availableWeapons.get(i))) {\n                    return i;\n                }\n            }\n        }\n        return 0; \n    }\n\n    public int[] getWeaponAmmoInfo(Class<?> weaponClass) {\n        try {\n     \n            if (weaponAmmoStorage.containsKey(weaponClass)) {\n                int[] ammoInfo = new int[2];\n                ammoInfo[0] = weaponAmmoStorage.get(weaponClass)[0]; // currentAmmo\n                ammoInfo[1] = weaponAmmoStorage.get(weaponClass)[1]; // totalAmmo\n                return ammoInfo;\n            }\n        } catch (Exception e) {\n            System.err.println(\"Silah mermi bilgisi alınırken hata: \" + e.getMessage());\n        }\n\n        return new int[] {0, 0};\n    }\n\n    public float calculateAngleToMouse() {\n        int mouseX = Game.mouseX;  \n        int mouseY = Game.mouseY;\n        \n        float playerScreenX = x - handler.getCamera().getX();\n        float playerScreenY = y - handler.getCamera().getY();\n\n        float playerCenterX = playerScreenX + 16; \n        float playerCenterY = playerScreenY + 16; \n\n        float deltaX = mouseX - playerCenterX;\n        float deltaY = mouseY - playerCenterY;\n        \n        float angle = (float) Math.atan2(deltaY, deltaX);\n        \n        return angle;\n    }\n    \n    public Pistol getPistol() {\n      \n        for (Class<?> weaponClass : availableWeapons) {\n            if (weaponClass.equals(Pistol.class)) {\n                if (currentWeapon instanceof Pistol) {\n                    return (Pistol) currentWeapon;\n                }\n\n                int[] ammoInfo = getWeaponAmmoInfo(Pistol.class);\n                \n                try {\n                    Pistol pistol = (Pistol) Pistol.class.getDeclaredConstructor().newInstance();\n                    pistol.setHandler(handler);\n                    pistol.setCurrentAmmo(ammoInfo[0]);\n                    pistol.setTotalAmmo(ammoInfo[1]);\n                    return pistol;\n                } catch (Exception e) {\n                }\n            }\n        }\n\n        try {\n            Pistol pistol = new Pistol();\n            pistol.setHandler(handler);\n            return pistol;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n    \n    @Override\n    public void render(Graphics g) {\n        float renderX = x - cam.getX();\n        float renderY = y - cam.getY();\n\n        Graphics2D g2d = (Graphics2D) g.create();\n\n        AffineTransform oldTransform = g2d.getTransform();\n\n        AffineTransform at = new AffineTransform();\n\n        float centerX = renderX + (PLAYER_SIZE / 2);\n        float centerY = renderY + (PLAYER_SIZE / 2);\n\n        at.translate(centerX, centerY);\n        at.rotate(angle);\n\n        boolean isGüneyBatı = (angle > Math.PI / 2 && angle < Math.PI);\n        boolean isKuzeyBatı = (angle > Math.PI && angle < 3 * Math.PI / 2);\n\n        if (isGüneyBatı || isKuzeyBatı) {\n            at.scale(1, -1);\n        }\n\n        g2d.setTransform(at);\n        \n        int indicatorY = (int)y - 20;\n        \n        if (isSpeedBoosted) {\n            g.setColor(new Color(255, 215, 0));\n            g.fillOval((int)x - 10, indicatorY, 8, 8);\n            // Kalan süre animasyonu \n            float remainingTime = (speedBoostEndTime - System.currentTimeMillis()) / (float)10000;\n            g.setColor(new Color(255, 255, 255, 150));\n            g.fillArc((int)x - 10, indicatorY, 8, 8, 90, (int)(360 * remainingTime));\n        }\n        \n\n        float scaleFactor = 2.4f; \n        int scaledSize = (int)(PLAYER_SIZE * scaleFactor);\n\n        if (playerImage != null) {\n            g2d.drawImage(playerImage, -scaledSize/2, -scaledSize/2, scaledSize, scaledSize, null);\n        } else {\n            g2d.setColor(Color.white);\n            g2d.fillRect(-scaledSize/2, -scaledSize/2, scaledSize, scaledSize);\n        }\n\n        if (currentWeapon != null) {\n     \n            g2d.scale(scaleFactor, scaleFactor);\n            currentWeapon.render(g2d);\n            g2d.scale(1/scaleFactor, 1/scaleFactor); \n        }\n\n        g2d.setTransform(oldTransform);\n        g2d.dispose();\n\n        renderHealthBar(g);\n        if (invulnerable) {\n            g.setColor(new Color(0, 255, 255, 100)); \n            g.fillOval((int)x - 5, (int)y - 5, (int)width + 10, (int)height + 10);\n        }\n    }\n    \n    protected void renderHealthBar(Graphics g) {\n    \t \tint barWidth = 32;\n    \t    int barHeight = 5;\n\n    \t    int barX = (int)x;\n    \t    int barY = (int)y - 10; \n\n    \t    barX = barX + (PLAYER_SIZE/2) - (barWidth/2);\n\n    \t    g.setColor(Color.RED);\n    \t    g.fillRect(barX, barY, barWidth, barHeight);\n\n    \t    int healthWidth = (int)((float)health / maxHealth * barWidth);\n    \t    g.setColor(Color.GREEN);\n    \t    g.fillRect(barX, barY, healthWidth, barHeight);\n    \t    \n    \t    g.setColor(Color.BLACK);\n    \t    g.drawRect(barX, barY, barWidth, barHeight);\n    }\n    \n    @Override\n    public Rectangle getBounds() {\n    \treturn new Rectangle(\n    \t        (int) x,\n    \t        (int) y,\n    \t        PLAYER_SIZE,\n    \t        PLAYER_SIZE\n    \t    );\n    }\n\n\tpublic Camera getCamera() {\n\t\treturn cam;\n\t}\n}\n",
      "GameObject.java": "package ödev2;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic abstract class GameObject {\n\n    protected float x, y;\n    protected ID id;\n    protected float velX, velY;\n    protected int health;\n    protected int maxHealth;\n    protected Camera cam;\n    protected int width = 32;  // Default width\n    protected int height = 32; // Default height\n    \n    \n\n    public GameObject(float x, float y, ID id) {\n        this.x = x;\n        this.y = y;\n        this.id = id;\n        maxHealth = 100;\n        this.health = maxHealth;\n        \n    }\n\n    public abstract void tick();\n    public abstract void render(Graphics g);\n    public abstract Rectangle getBounds();\n    \n    \n    protected void renderHealthBar(Graphics g) {\n    \tint barWidth = 32;\n        int barHeight = 5;\n\n        int healthWidth = (int) ((health / (float) maxHealth) * barWidth);\n\n        g.setColor(Color.BLACK);\n        g.fillRect((int) x, (int) y - 10, barWidth, barHeight);\n\n        if (this instanceof Enemy) {\n            g.setColor(Color.RED);  \n        } else {\n            g.setColor(Color.GREEN);\n        }\n        g.fillRect((int) x, (int) y - 10, healthWidth, barHeight);\n\n    }\n \n\n    public float getX() {\n        return x;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public float getY() {\n        return y;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public float getVelX() {\n        return velX;\n    }\n\n    public void setVelX(float velX) {\n        this.velX = velX;\n    }\n\n    public float getVelY() {\n        return velY;\n    }\n\n    public void setVelY(float velY) {\n        this.velY = velY;\n    }\n\n    public ID getId() {\n        return id;\n    }\n\n    public void setId(ID id) {\n        this.id = id;\n    }\n    public int getWidth() {\n        return width;\n    }\n    \n    public int getHeight() {\n        return height;\n    }\n    \n    public void setWidth(int width) {\n        this.width = width;\n    }\n    \n    public void setHeight(int height) {\n        this.height = height;\n    }\n}",
      "GameState.java": "package ödev2;\n\npublic enum GameState {\n    MENU,     \n    PLAYING,  \n    PAUSED,    \n    GAME_OVER,\n    LOADING_GAME\n}\n",
      "ZombieType.java": "package ödev2;\n\npublic enum ZombieType {\n\tNORMAL(), \n    CRAWLER(), \n    TANK(), \n    ACID_SPITTER(),\n\tKAMIKAZE();\n}\n"
    },
    {
      "id": "8059049",
      "Zombie.java": "\n\npublic class Zombie extends Creatures {\n    public Zombie(GamePanel gp){\n        super(gp);\n        name=\"Normal Zombi\";\n        speed=2;\n        maxlife=3;\n        damage=1;\n        life=maxlife;\n        getImage();\n        solidArea.x=3;\n        solidArea.y=18;\n\n        solidArea.width=42;\n        solidArea.height=30;\n        solidAreaDefaultX=solidArea.x;\n        solidAreaDefaultY=solidArea.y;\n    }\n    public void getImage(){\n        up1=setup(\"/Res/Normal1\");\n        up2=setup(\"/Res/Normal2\");\n        down1=setup(\"/Res/Normal1\");\n        down2=setup(\"/Res/Normal2\");\n        left1=setup(\"/Res/Normal1\");\n        left2=setup(\"/Res/Normal2\");\n        right1=setup(\"/Res/Normal1\");\n        right2=setup(\"/Res/Normal2\");\n    }\n    public void setAction(){\n        int playerWorldX = gp.player.worldx;\n        int playerWorldY = gp.player.worldy;\n    \n        // X ve Y eksenlerindeki farkı hesapla\n        int deltaX = playerWorldX - this.worldx;\n        int deltaY = playerWorldY - this.worldy;\n    \n        // Hangi yöne hareket edeceğini belirle\n        if (Math.abs(deltaX) > Math.abs(deltaY)) {\n            // X ekseninde daha büyük fark varsa\n            if (deltaX > 0) {\n                direction = \"right\";\n            } else {\n                direction = \"left\";\n            }\n        } else {\n            // Y ekseninde daha büyük fark varsa\n            if (deltaY > 0) {\n                direction = \"down\";\n            } else {\n                direction = \"up\";\n            }\n        }\n}\n// Zombie.java\n@Override\npublic void update() {\n    setAction(); // Sürekli oyuncunun konumunu takip et\n    collisionOn = false;\n    gp.check.checkTile(this);\n    gp.check.checkCreature(this, gp.monster); // Diğer zombilerle çarpışma kontrolü\n    gp.check.checkPlayer(this);\n    if (!collisionOn) {\n        switch (direction) {\n            case \"up\": worldy -= speed; break;\n            case \"down\": worldy += speed; break;\n            case \"left\": worldx -= speed; break;\n            case \"right\": worldx += speed; break;\n        }\n    }\n    spriteCounter++;\n    if(spriteCounter>10){\n        if(spriteNum==1){\n          spriteNum=2;\n        }\n        else if(spriteNum==2){\n          spriteNum=1;\n        }\n        spriteCounter=0;\n      }\n    \n}\n\n}",
      "PiercingBullet.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class PiercingBullet extends Bullet {\n    private int pierceCount; // Bir merminin delip geçeceği düşman sayısı\n    \n    public PiercingBullet(GamePanel gp) {\n        super(gp);\n        pierceCount = 3; \n    }\n    \n    @Override\n    public void update() {\n        // Hareket\n        worldx += Math.cos(getDirectionAngle()) * speed;\n        worldy += Math.sin(getDirectionAngle()) * speed;\n        \n        // Tile çarpışma kontrolü\n        gp.check.checkTile(this);\n        if(collisionOn) {\n            return; // Çarpışma durumunda işaretle ama silme\n        }\n        \n        // Eğer oyuncudan geliyorsa, düşmanlara çarpmayı kontrol et\n        if (getSource() instanceof Player) {\n            // Canavarlarla çarpışma kontrolü\n            int monsterIndex = gp.check.checkCreature(this, gp.monster);\n            if (monsterIndex != 999) {\n                // Güvenli index kontrolü\n                if(monsterIndex >= 0 && monsterIndex < gp.monster.size()) {\n                    Creatures monster = gp.monster.get(monsterIndex);\n                    \n                    // Hasar ver\n                    if (monster != null) {\n                        monster.life -= getDamage();\n                        System.out.println(\"Monster hit by piercing bullet! Life: \" + monster.life);\n                        if (monster.life <= 0) {\n                            // Düşman öldü - güvenli silme\n                            if (monsterIndex < gp.monster.size()) {\n                                gp.monster.remove(monsterIndex);\n                                gp.currentScore += 10; // Puan kazanma\n                            }\n                        }\n                    }\n                }\n                \n                // Delici mermi olduğu için delip geçerek devam eder\n                pierceCount--;\n                if (pierceCount <= 0) {\n                    collisionOn = true; // Delme sayısı bittiğinde işaretle\n                    return;\n                }\n            }\n        }\n        \n       \n        if (worldx < 0 || worldx > gp.worldWidth || worldy < 0 || worldy > gp.worldHeight) {\n            collisionOn = true;\n        }\n    }\n    \n    @Override\n    public void draw(Graphics2D g2) {\n        \n        g2.setColor(Color.BLUE);\n        \n       \n        int screenX = worldx - gp.player.worldx + gp.player.screenx;\n        int screenY = worldy - gp.player.worldy + gp.player.screeny;\n        \n        g2.fillOval(screenX, screenY, getWidth(), getHeight());\n    }\n}",
      "Weapon.java": "public class Weapon extends Creatures {\n    public int damage;\n    public int speed;\n    public String direction;\n\n    public Weapon(GamePanel gp) {\n        super(gp);\n    }\n\n    public void update() {\n        // Hareket mantığı burada olacak\n        switch (direction) {\n            case \"up\": worldy -= speed; break;\n            case \"down\": worldy += speed; break;\n            case \"left\": worldx -= speed; break;\n            case \"right\": worldx += speed; break;\n        }\n        \n        // Tile çarpışma kontrolü\n        collisionOn = false;\n        gp.check.checkTile(this);\n        if (collisionOn) {\n            gp.projectiles.remove(this); // Çarpışma varsa mermiyi kaldır\n        }\n    }\n}",
      "Gun.java": "import java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\n\npublic abstract class Gun extends Creatures{\n    protected GamePanel gp;\n    protected String name;\n    protected int damage;\n    protected int magazineCapacity; // Şarjör kapasitesi\n    protected int currentAmmo; // Şarjördeki mevcut mermi\n    protected int totalAmmo; // Toplam mermi\n    protected int fireRate; // Atış hızı (mermi/dakika)\n    protected int fireRateCounter = 0; // Atış hızı sayacı\n    protected int fireRateTicks; // Atışlar arası gecikme (ticks)\n    protected boolean reloading = false;\n    protected int reloadingTime = 60; // 1 saniye (60 FPS)\n    protected int reloadingCounter = 0;\n    \n    public Gun(GamePanel gp, String name, int damage, int magazineCapacity, int fireRate) {\n        super(gp);\n        this.name = name;\n        this.damage = damage;\n        this.magazineCapacity = magazineCapacity;\n        this.fireRate = fireRate;\n        \n        // Atış hızını tick cinsinden hesapla (60 FPS'lik bir oyun için)\n        this.fireRateTicks = (int)(60.0 / (fireRate / 60.0));\n        \n        // Başlangıçta şarjör dolu\n        this.currentAmmo = magazineCapacity;\n    }\n     public BufferedImage getImage() {\n        BufferedImage image = null;\n        try {\n            image = ImageIO.read(getClass().getResourceAsStream(\"/Res/\" + name + \".png\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return image;\n    }\n    public boolean canShoot() {\n        return currentAmmo > 0 && !reloading && fireRateCounter <= 0;\n    }\n    \n    public void update() {\n        if (fireRateCounter > 0) {\n            fireRateCounter--;\n        }\n        \n        if (reloading) {\n            reloadingCounter++;\n            if (reloadingCounter >= reloadingTime) {\n                reload();\n                reloading = false;\n                reloadingCounter = 0;\n            }\n        }\n    }\n    \n    public void startReload() {\n        if (!reloading && currentAmmo < magazineCapacity && totalAmmo > 0) {\n            reloading = true;\n            reloadingCounter = 0;\n           \n        }\n    }\n    \n    protected void reload() {\n        int ammoToLoad = Math.min(magazineCapacity - currentAmmo, totalAmmo);\n        currentAmmo += ammoToLoad;\n        totalAmmo -= ammoToLoad;\n    }\n    \n    public abstract void shoot(int mouseX, int mouseY);\n    \n    // Getter ve Setter metodları\n    public String getName() {\n        return name;\n    }\n    \n    public int getCurrentAmmo() {\n        return currentAmmo;\n    }\n    \n    public int getTotalAmmo() {\n        return totalAmmo;\n    }\n    \n    public void setTotalAmmo(int totalAmmo) {\n        this.totalAmmo = totalAmmo;\n    }\n    \n    public void addAmmo(int amount) {\n        this.totalAmmo += amount;\n    }\n    \n    public int getMagazineCapacity() {\n        return magazineCapacity;\n    }\n    \n    public boolean isReloading() {\n        return reloading;\n    }\n}\n",
      "Bullet.java": "\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\n\npublic class Bullet extends Creatures {\n    private double directionAngle;\n    private double speedX;\n    private double speedY;\n    private int damage;\n    private Creatures source; // Mermiyi atan \n    \n    public Bullet(GamePanel gp) {\n        super(gp);\n        speed = 15; // Mermi hızı\n        damage = 1;\n        \n       \n        solidArea = new Rectangle(0, 0, 16, 16);\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n    }\n    \n    public void setPos(int x, int y) {\n        this.worldx = x;\n        this.worldy = y;\n    }\n    \n    public void setDirection(double angle) {\n        this.directionAngle = angle;\n        this.speedX = Math.cos(angle) * speed;\n        this.speedY = Math.sin(angle) * speed;\n    }\n    \n    public void setDamage(int damage) {\n        this.damage = damage;\n    }\n    \n    public int getDamage() {\n        return damage;\n    }\n    \n    public void setSource(Creatures source) {\n        this.source = source;\n    }\n    \n    public Creatures getSource() {\n        return source;\n    }\n    \n    public int getWidth() {\n        return solidArea.width;\n    }\n    \n    public int getHeight() {\n        return solidArea.height;\n    }\n    \n\n    @Override\n    public void update() {\n      \n        worldx += speedX;\n        worldy += speedY;\n        \n    \n        gp.check.checkTile(this);\n        if(collisionOn) {\n            if (gp.bulletList.contains(this)) {\n                gp.bulletList.remove(this);\n            }\n            return;\n        }\n        \n        \n        if (source instanceof Player) {\n            \n            int monsterIndex = gp.check.checkCreature(this, gp.monster);\n            if (monsterIndex != 999) {\n                \n                if(monsterIndex >= 0 && monsterIndex < gp.monster.size()) {\n                    Creatures monster = gp.monster.get(monsterIndex);\n                    \n                    \n                    if (monster != null) {\n                        monster.life-=damage;\n                        System.out.println(\"Monster hit! Life: \" + monster.life);\n                        if (monster.life <= 0) {\n                           \n                            if (monsterIndex < gp.monster.size()) {\n                                gp.monster.remove(monsterIndex);\n                                gp.currentScore += 10;\n                            }\n                        }\n                    }\n                }\n                \n                \n                collisionOn = true;\n                return;\n            }\n        }\n        \n        \n        if (worldx < 0 || worldx > gp.worldWidth || worldy < 0 || worldy > gp.worldHeight) {\n            collisionOn=true;\n        }\n    }\n\n\n\n\n    \n    public double getDirectionAngle(){\n        return directionAngle;\n    }\n    \n    @Override\npublic void draw(Graphics2D g2) {\n  \n    g2.setColor(Color.YELLOW);\n    int screenX = worldx - gp.player.worldx + gp.player.screenx;\n    int screenY = worldy - gp.player.worldy + gp.player.screeny;\n    g2.fillOval(screenX, screenY, solidArea.width, solidArea.height); // DÜZELTME: Oval çiz\n}\n   \n}\n",
      "Tile.java": "\nimport java.awt.image.BufferedImage;\n\npublic class Tile {\n    public BufferedImage image;\n    public boolean collision=false;\n}\n",
      "Spitter.java": "public class Spitter extends Creatures {\n    private int attackCounter = 0;\n    private final int attackInterval = 180;\n    public Spitter(GamePanel gp){\n        super(gp);\n        name=\"Tüküren Zombi\";\n        speed=1;\n        maxlife=3;\n        damage=1;\n        life=maxlife;\n        getImage();\n        solidArea.x=3;\n        solidArea.y=18;\n\n        solidArea.width=42;\n        solidArea.height=30;\n        solidAreaDefaultX=solidArea.x;\n        solidAreaDefaultY=solidArea.y;\n    }\n    public void getImage(){\n        up1=setup(\"/Res/Spit1\");\n        up2=setup(\"/Res/Spit2\");\n        down1=setup(\"/Res/Spit1\");\n        down2=setup(\"/Res/Spit2\");\n        left1=setup(\"/Res/Spit1\");\n        left2=setup(\"/Res/Spit2\");\n        right1=setup(\"/Res/Spit1\");\n        right2=setup(\"/Res/Spit2\");\n    }\n    public void setAction(){\n        int playerWorldX = gp.player.worldx;\n        int playerWorldY = gp.player.worldy;\n    \n        // X ve Y eksenlerindeki farkı hesapla\n        int deltaX = playerWorldX - this.worldx;\n        int deltaY = playerWorldY - this.worldy;\n    \n        // Hangi yöne hareket edeceğini belirle\n        if (Math.abs(deltaX) > Math.abs(deltaY)) {\n            // X ekseninde daha büyük fark varsa\n            if (deltaX > 0) {\n                direction = \"right\";\n            } else {\n                direction = \"left\";\n            }\n        } else {\n            // Y ekseninde daha büyük fark varsa\n            if (deltaY > 0) {\n                direction = \"down\";\n            } else {\n                direction = \"up\";\n            }\n        }\n}\n\n@Override\npublic void update() {\n    setAction(); \n    collisionOn = false;\n    gp.check.checkTile(this);\n    gp.check.checkCreature(this, gp.monster); // Diğer zombilerle çarpışma kontrolü\n    gp.check.checkPlayer(this);\n    if (!collisionOn) {\n        switch (direction) {\n            case \"up\": worldy -= speed; break;\n            case \"down\": worldy += speed; break;\n            case \"left\": worldx -= speed; break;\n            case \"right\": worldx += speed; break;\n        }\n    }\n    spriteCounter++;\n    if(spriteCounter>10){\n        if(spriteNum==1){\n          spriteNum=2;\n        }\n        else if(spriteNum==2){\n          spriteNum=1;\n        }\n        spriteCounter=0;\n      }\n      attackCounter++;\n      if (attackCounter >= attackInterval) {\n          shootAcid();\n          attackCounter = 0;\n      }\n      if(life<=0){\n        gp.monster.remove(this);\n      }\n}\nprivate void shootAcid() {\n    // Asit'i Spitter'in bulunduğu konumdan fırlat\n    Asit acid = new Asit(gp, worldx, worldy, direction);\n    gp.projectiles.add(acid);\n}\n\n\n}\n",
      "Shotgun.java": "public class Shotgun extends Gun {\n    \n    private final int pelletCount = 9; // Saçma sayısı\n    private final double spreadAngle = Math.toRadians(45); // 45 derece toplam yayılma açısı\n    \n    public Shotgun(GamePanel gp) {\n        super(gp, \"shotgun\", 1, 5, 60); // 5 mermi kapasiteli, dakikada 60 atış hızı\n        this.gp=gp;\n        this.totalAmmo = 20; // 4 şarjör yedek mermi\n    }\n    \n    @Override\n    public void shoot(int mouseX, int mouseY) {\n        if (canShoot()) {\n            // Oyuncu merkezinden fare pozisyonuna doğru atış vektörü hesapla\n            int playerCenterX = gp.player.screenx + gp.tilesize / 2;\n            int playerCenterY = gp.player.screeny + gp.tilesize / 2;\n            \n            double baseAngle = Math.atan2(mouseY - playerCenterY, mouseX - playerCenterX);\n            \n            // Her bir saçma için açı hesapla (5 derecelik aralıklarla)\n            double angleStep = spreadAngle / (pelletCount - 1);\n            double startAngle = baseAngle - (spreadAngle / 2);\n            \n            // Saçmaları oluştur\n            for (int i = 0; i < pelletCount; i++) {\n                double angle = startAngle + (angleStep * i);\n                \n                Bullet pellet = new Bullet(gp);\n                pellet.setPos(gp.player.worldx + gp.tilesize / 2 - (pellet.getWidth() / 2),\n                              gp.player.worldy + gp.tilesize / 2 - (pellet.getHeight() / 2));\n                pellet.setDirection(angle);\n                pellet.setDamage(damage);\n                pellet.setSource(gp.player);\n                \n                // Mermiyi oyun panosuna ekle\n                gp.bulletList.add(pellet);\n            }\n            \n            // Atış hızı sayacını güncelle\n            fireRateCounter = fireRateTicks;\n            \n            // Mermi sayısını azalt\n            currentAmmo--;\n            \n        \n           \n        }\n    }\n}\n\n\n",
      "KeyInput.java": "\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\npublic class KeyInput implements KeyListener {\n      public boolean uppress,downpress,rightpress,leftpress;\n     \n      GamePanel gp;\n      public KeyInput(GamePanel gp){\n        this.gp=gp;\n\n      }\n\n\n\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n      int code=e.getKeyCode();//Keycode döndürür\n      if(gp.gameState==gp.titleState){\n        if(code==KeyEvent.VK_W){\n         gp.ui.commandNum--;\n         if(gp.ui.commandNum<0){\n          gp.ui.commandNum=3;\n         }\n     }\n     if(code==KeyEvent.VK_S){\n     gp.ui.commandNum++;\n     if(gp.ui.commandNum>3){\n      gp.ui.commandNum=0;\n     }\n     }\n     if(code==KeyEvent.VK_ENTER){\n      if(gp.ui.commandNum==0){\n        gp.gameState=gp.playState;\n        gp.playMusic(0);\n      }\n      if(gp.ui.commandNum==1){\n        gp.gameState=gp.playState;\n      }\n      if(gp.ui.commandNum==2){\n       \n      \n      // Try to load game\n      gp.loadGame();\n      gp.gameState=gp.playState;\n     \n      }\n      if(gp.ui.commandNum==3){\n        System.exit(0);\n        }\n        \n     }\n     \n      }\n     else  if(gp.gameState==gp.pauseState){\n        if(code==KeyEvent.VK_W){\n         gp.ui.commandNum--;\n         if(gp.ui.commandNum<0){\n          gp.ui.commandNum=2;\n         }\n     }\n     if(code==KeyEvent.VK_S){\n     gp.ui.commandNum++;\n     if(gp.ui.commandNum>2){\n      gp.ui.commandNum=0;\n     }\n     }\n     if(code==KeyEvent.VK_ENTER){\n      if(gp.ui.commandNum==0){\n        gp.gameState=gp.playState;\n        gp.playMusic(0);\n      }\n      \n      if(gp.ui.commandNum==1){\n          \n      gp.saveGame(); \n     \n     \n\n      }\n      if(gp.ui.commandNum==2){\n        \n        gp.reset();\n        }\n        \n     }\n      }\n      else if (gp.gameState == gp.finalState) {\n        if (code == KeyEvent.VK_ENTER) {\n            // Oyunu başlangıç durumuna resetle\n            gp.reset();\n        }\n    }\n      \n      if(code==KeyEvent.VK_W){\n           uppress=true;\n      }\n      if(code==KeyEvent.VK_S){\n       downpress=true; \n      }\n      if(code==KeyEvent.VK_A){\n        leftpress=true;\n      }\n      if(code==KeyEvent.VK_D){\n        rightpress=true;\n      }\n     \n  \nif (code == KeyEvent.VK_P) {\n  if (gp.gameState == gp.playState) {\n      gp.gameState = gp.pauseState;\n  } else if (gp.gameState == gp.pauseState) {\n      gp.gameState = gp.playState;\n  }\n}\n\nif (code == KeyEvent.VK_R) {\n    gp.player.currentGun.reload();\n}\n\nif (code == KeyEvent.VK_1) {\n  gp.player.switchWeapon(0); // Pistol\n}\nif (code == KeyEvent.VK_2) {\n  gp.player.switchWeapon(1); // Assault Rifle\n}\nif (code == KeyEvent.VK_3) {\n  gp.player.switchWeapon(2); // Shotgun\n}\nif (code == KeyEvent.VK_4) {\n  gp.player.switchWeapon(3); // Sniper Rifle\n}\nif (code == KeyEvent.VK_5) {\n  gp.player.switchWeapon(4); // Rocket Launcher\n}\n}\n\n    \n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int code=e.getKeyCode();\n      if(code==KeyEvent.VK_W){\n           uppress=false;\n      }\n      if(code==KeyEvent.VK_S){\n       downpress=false; \n      }\n      if(code==KeyEvent.VK_A){\n        leftpress=false;\n      }\n      if(code==KeyEvent.VK_D){\n        rightpress=false;\n      }\n    \n    }\n    \n}\n",
      "Sound.java": "\nimport java.net.URL;\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\n\npublic class Sound {\n    Clip clip;\n    URL soundURL[]=new URL[30];\n    public Sound(){\n        soundURL[0]=getClass().getResource(\"/music/Bad Meets Evil - Fast Lane [Official Instrumental + Hook].wav\");\n\n    }\n    public void setFile(int i) {\n    try {\n        AudioInputStream ais = AudioSystem.getAudioInputStream(soundURL[i]);\n        clip = AudioSystem.getClip();\n        clip.open(ais);\n    } catch (Exception e) {\n        System.err.println(\"Ses dosyasını yüklerken hata: \" + e.getMessage());\n        e.printStackTrace();\n    }\n}\npublic void play() {\n    if (clip != null) {\n        clip.start();\n    } else {\n        System.err.println(\"Çalınacak ses bulunamadı! (clip null)\");\n    }\n}\n\npublic void loop() {\n    if (clip != null) {\n        clip.loop(Clip.LOOP_CONTINUOUSLY);\n    } else {\n        System.err.println(\"Döngüye alınacak ses bulunamadı! (clip null)\");\n    }\n}\n\npublic void stop() {\n    if (clip != null) {\n        clip.stop();\n    }\n}\n}\n",
      "SniperRifle.java": "public class SniperRifle extends Gun {\n    \n    public SniperRifle(GamePanel gp) {\n        super(gp, \"sniperrifle\", 3, 5, 30); // 5 mermi kapasiteli, dakikada 30 atış hızı, 3 kat zarar\n        this.gp=gp;\n        this.totalAmmo = 15; // 3 şarjör yedek mermi\n    }\n    \n    @Override\n    public void shoot(int mouseX, int mouseY) {\n        if (canShoot()) {\n            // Oyuncu merkezinden fare pozisyonuna doğru atış vektörü hesapla\n            int playerCenterX = gp.player.screenx + gp.tilesize / 2;\n            int playerCenterY = gp.player.screeny + gp.tilesize / 2;\n            \n            double angle = Math.atan2(mouseY - playerCenterY, mouseX - playerCenterX);\n            \n            // Delici mermi oluştur\n            PiercingBullet bullet = new PiercingBullet(gp);\n            bullet.setPos(gp.player.worldx + gp.tilesize / 2 - (bullet.getWidth() / 2),\n                          gp.player.worldy + gp.tilesize / 2 - (bullet.getHeight() / 2));\n            bullet.setDirection(angle);\n            bullet.setDamage(damage);\n            bullet.setSource(gp.player);\n            \n            // Mermiyi oyun panosuna ekle\n            gp.bulletList.add(bullet);\n            \n            // Atış hızı sayacını güncelle\n            fireRateCounter = fireRateTicks;\n            \n            // Mermi sayısını azalt\n            currentAmmo--;\n            \n        \n        }\n    }\n}\n\n\n",
      "Rocket.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\n\npublic class Rocket extends Bullet {\n    private int explosionRadius;\n    \n    public Rocket(GamePanel gp) {\n        super(gp);\n        speed = 8; \n        solidArea = new Rectangle(0, 0, 24, 24); \n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n    }\n    \n    public void setExplosionRadius(int radius) {\n        this.explosionRadius = radius;\n    }\n    \n    @Override\n    public void update() {\n       \n        worldx += Math.cos(getDirectionAngle()) * speed;\n        worldy += Math.sin(getDirectionAngle()) * speed;\n        \n        \n        gp.check.checkTile(this);\n        if(collisionOn) {\n            // Çarpışınca patlama yap ve işaretle\n            explode();\n            return;\n        }\n        \n        // Eğer oyuncudan geliyorsa, düşmanlara çarpmayı kontrol et\n        if (getSource() instanceof Player) {\n            // Canavarlarla çarpışma kontrolü\n            int monsterIndex = gp.check.checkCreature(this, gp.monster);\n            if (monsterIndex != 999) {\n                // Patlama oluştur\n                explode();\n                \n                // Roketi işaretle\n                collisionOn = true;\n                return;\n            }\n        }\n        \n        // Ekran dışı kontrolü\n        if (worldx < 0 || worldx > gp.worldWidth || worldy < 0 || worldy > gp.worldHeight) {\n            collisionOn = true;\n        }\n    }\n    \n    private void explode() {\n        System.out.println(\"Rocket exploded!\");\n        \n        \n        // Patlama mesafesine göre tüm düşmanlara hasar ver\n        for (int i = gp.monster.size() - 1; i >= 0; i--) {\n            if (i >= gp.monster.size()) continue; // Güvenlik kontrolü\n            \n            Creatures monster = gp.monster.get(i);\n            if (monster != null) {\n                // Düşman ile roket arasındaki mesafeyi hesapla\n                double distance = Math.sqrt(\n                    Math.pow(monster.worldx + monster.solidArea.x - worldx, 2) +\n                    Math.pow(monster.worldy + monster.solidArea.y - worldy, 2)\n                );\n                \n                // Eğer patlama yarıçapı içindeyse\n                if (distance <= explosionRadius) {\n                    // Uzaklığa göre hasar hesapla\n                    int explosionDamage = (int)(getDamage() * (1 - (distance / explosionRadius)));\n                    if (explosionDamage < 1) explosionDamage = 1; // Minimum hasar\n                    \n                    // Hasar ver\n                    monster.life -= explosionDamage;\n                    System.out.println(\"Monster hit by explosion! Damage: \" + explosionDamage + \", Life: \" + monster.life);\n                    \n                    if (monster.life <= 0) {\n                       \n                        if (i < gp.monster.size()) {\n                            gp.monster.remove(i);\n                            gp.currentScore += 10; \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    public void draw(Graphics2D g2) {\n        \n        g2.setColor(Color.RED);\n        \n      \n        int screenX = worldx - gp.player.worldx + gp.player.screenx;\n        int screenY = worldy - gp.player.worldy + gp.player.screeny;\n        \n        g2.fillOval(screenX, screenY, getWidth(), getHeight());\n    }\n}",
      "Pistol.java": "public class Pistol extends Gun {\n    \n    public Pistol(GamePanel gp) {\n        super(gp, \"tabanca\", 1, 12, 120); // 12 mermi kapasiteli, dakikada 120 atış hızı\n        this.gp=gp;\n        this.totalAmmo = Integer.MAX_VALUE; // Sınırsız yedek mermi\n    }\n    \n    @Override\n    public void shoot(int mouseX, int mouseY) {\n        if (canShoot()) {\n            // Oyuncu merkezinden fare pozisyonuna doğru atış vektörü hesapla\n            int playerCenterX = gp.player.worldx + gp.tilesize / 2;\n            int playerCenterY = gp.player.worldy + gp.tilesize / 2;\n            \n            double angle = Math.atan2(mouseY - (gp.player.screeny + gp.tilesize/2), \n            mouseX - (gp.player.screenx + gp.tilesize/2));\n            \n            // Yeni mermi oluştur\n            Bullet bullet = new Bullet(gp);\n            bullet.setPos(playerCenterX , playerCenterY );\n            bullet.setDirection(angle);\n            bullet.setDamage(damage);\n            bullet.setSource(gp.player);\n            \n            // Mermiyi oyun panosuna ekle\n            gp.bulletList.add(bullet);\n            \n            // Atış hızı sayacını güncelle\n            fireRateCounter = fireRateTicks;\n            \n            // Mermi sayısını azalt\n            currentAmmo--;\n            \n            \n           \n        }\n    }\n}\n\n",
      "GamePanel.java": "import java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport javax.swing.JPanel;\nimport java.io.*;\npublic class GamePanel extends JPanel implements Runnable {\n    public SaveLoad saveLoad;\n    public Gun[] playerGuns;\n    public int currentScore = 0;\n    final int originaltilesize = 16;\n    final int scale = 3;\n    public final int tilesize = originaltilesize * scale;\n    final int maxscreencol = 16;\n    final int maxscreenrow = 12;\n    final int screenwidth = tilesize * maxscreencol;\n    final int screenheight = tilesize * maxscreenrow;\n    public final int maxWorldCol = 66;\n    public final int maxWorldRow = 62;\n    public final int worldWidth = tilesize * maxWorldCol;\n    public final int worldHeight = tilesize * maxWorldRow;\n    public int currentLevel = 1;\n    \n    int fps = 60;\n\n   \n    Thread gamethread;\n    \n   \n    Sound music = new Sound();\n    Sound sound = new Sound();\n   \n    public UI ui = new UI(this);\n    public  KeyInput key = new KeyInput(this);\n    public MouseInput mouse = new MouseInput(this);\n    public Player player = new Player(this, key, mouse);\n    TileManager tileM = new TileManager(this);\n    public CollisionChecker check = new CollisionChecker(this);\n    ArrayList<Creatures> monster = new ArrayList<>();\n    ArrayList<Bullet> bulletList = new ArrayList<>();\n    ArrayList<Creatures> crealist = new ArrayList<>();\n    public ArrayList<Weapon> projectiles = new ArrayList<>();\n    public int gameState;\n    public final int titleState = 0;\n    public final int playState = 1;\n    public final int pauseState = 2;\n    public final int finalState=3;\n    AssetSetter a = new AssetSetter(this);\n    \n    \n       \n      \n        \n        public GamePanel() {\n            this.setPreferredSize(new Dimension(screenwidth, screenheight));\n            this.setBackground(Color.black);\n            this.setDoubleBuffered(true);\n            \n            // Önce input nesnelerini oluştur\n            this.key = new KeyInput(this);\n            this.mouse = new MouseInput(this);\n            // Sonra player'a bu nesneleri ver\n            this.player = new Player(this, key, mouse);\n            \n            this.addKeyListener(key);\n            this.setFocusable(true);\n            this.addMouseListener(mouse);\n            this.addMouseMotionListener(mouse); // Mouse hareketlerini de izle\n            \n            this.bulletList = new ArrayList<>();\n            this.saveLoad = new SaveLoad(this);\n        }\n        \n        \n    \n    public void startGameThread() {\n        gamethread = new Thread(this);\n        gamethread.start();\n    }\n\n    public void setup() {\n        a.setMonster();\n        spawnMonstersForLevel(currentLevel);\n        gameState = titleState; // titleState yerine playState\n    }\n\n    public void run() {\n        //1. Update character information,2.draw screen with updated info.\n        double interval = 1000000000 / fps;\n        double nextdraw = System.nanoTime() + interval;\n        while (gamethread != null) {\n            update();\n            repaint();\n            try {\n                double remain = nextdraw - System.nanoTime();\n                remain /= 1000000;\n                if (remain < 0)\n                    remain = 0;\n                Thread.sleep((long) remain);\n                nextdraw += interval;\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void update() {\n        if (gameState == playState) {\n            checkLevelCompletion();\n            if(player.life<=0){\n                gameState=finalState;\n            }\n             \n            if (player.invincible) {\n                player.invincibleCounter++;\n                if (player.invincibleCounter > player.invincibleDuration) {\n                    player.invincible = false;\n                    player.invincibleCounter = 0;\n                }\n            }\n\n            player.update();\n            \n            for (Creatures mon: monster) {\n                if(mon!=null)\n                 mon.update();\n            }\n            \n                     // Mermileri güncelle\n                     for (Gun gun : player.weapons) {\n                        gun.update();\n                    }\n        // Mermileri güncelle\n        \nfor (int i = bulletList.size() - 1; i >= 0; i--) {\n    if (i >= bulletList.size()) {\n        continue;\n    }\n    \n    Bullet bullet = bulletList.get(i);\n    if (bullet == null) {\n        bulletList.remove(i);\n        continue;\n    }\n    \n    \n    bullet.update();\n    check.checkTile(bullet);\n    // Eğer çarpışma veya sınır dışı durum varsa\n    if (bullet.collisionOn || \n        bullet.worldx < 0 || bullet.worldx > worldWidth ||\n        bullet.worldy < 0 || bullet.worldy > worldHeight) {\n            try {\n                bulletList.remove(i);\n            } catch (IndexOutOfBoundsException e) {\n                System.out.println(\"Hata: Mermi silinirken index hatası - \" + e.getMessage());\n            }\n    }\n}\n\n           \nfor (int i = projectiles.size() - 1; i >= 0; i--) {\n    \n    if (i >= projectiles.size() || projectiles.isEmpty()) {\n        break; // Hiç eleman kalmadıysa döngüden çık\n    }\n\n    Weapon projectile = projectiles.get(i);\n    if (projectile == null) {\n        projectiles.remove(i);\n        continue;\n    }\n\n    projectile.update();\n\n    \n    if (i < projectiles.size()) {\n        if (projectile.worldx < 0 || projectile.worldx > worldWidth ||\n            projectile.worldy < 0 || projectile.worldy > worldHeight) {\n            projectiles.remove(i);\n            continue;\n        }\n\n        // Acid collision check\n        if (i < projectiles.size() && projectile instanceof Asit) {\n            boolean hitPlayer = check.checkProjectile(projectile);\n            if (hitPlayer) {\n                this.player.takeDamage(projectile.damage);\n                if (i < projectiles.size()) { // Son kontrol\n                    projectiles.remove(i);\n                }\n            }\n        }\n    }\n}\n\n            if (gameState == pauseState) {\n            \n            }\n        }\n    }\n\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2 = (Graphics2D) g;\n        long drawStart = 0;\n       \n        if (gameState == titleState) {\n            ui.draw(g2);\n        } else {\n            tileM.draw(g2);\n            crealist.add(player);\n            player.draw(g2);\n            for (int i = 0; i < monster.size(); i++) {\n                if (monster.get(i) != null) {\n                    crealist.add(monster.get(i));\n                }\n            }\n            Collections.sort(crealist, new Comparator<Creatures>() {\n                public int compare(Creatures c1, Creatures c2) {\n                    int result = Integer.compare(c1.worldy, c2.worldy);\n                    return result;\n                }\n            });\n            for (int i = 0; i < crealist.size(); i++) {\n                crealist.get(i).draw(g2);\n            }\n            crealist.clear();\n            for (Weapon projectile : projectiles) {\n                projectile.draw(g2);\n            }\n            for (Bullet bullet : bulletList) {\n                bullet.draw(g2);\n            }\n            ui.draw(g2);\n        }\n        \n\n        g2.dispose();\n    }\n\n    public void playMusic(int i) {\n        music.setFile(i);\n        music.play();\n        music.loop();\n    }\n\n    public void stopMusic() {\n        music.stop();\n    }\n\n    public void playSE(int i) {\n        sound.setFile(i);\n        sound.play();\n    }\n    public void spawnMonstersForLevel(int level){\n        monster.clear();\n        \n        \n        int monsterCount = 2*level;\n        \n        // Canavarları oluştur\n        for (int i = 0; i < monsterCount; i++) {\n            Creatures newMonster;\n            \n            // Seviyeye göre canavar tiplerini belirle\n            if (level <= 2) {\n                // Seviye 1-2: Sadece normal zombiler\n                newMonster = new Zombie(this);\n            } else if (level <= 5) {\n                // Seviye 3-5: Normal zombiler + sürüngenler + spitter'lar\n                int type = (int)(Math.random() * 3); // 0, 1, 2\n                if (type == 0) newMonster = new Zombie(this);\n                else if (type == 1) newMonster = new Surungen(this);\n                else newMonster = new Spitter(this);\n            } else {\n                // Seviye 6-10: Tüm canavar tipleri\n                int type = (int)(Math.random() * 4); // 0, 1, 2, 3\n                if (type == 0) newMonster = new Zombie(this);\n                else if (type == 1) newMonster = new Surungen(this);\n                else if (type == 2) newMonster = new Spitter(this);\n                else newMonster = new Tank(this);\n            }\n            \n            // Rastgele konuma yerleştir (harita sınırları içinde ve oyuncudan uzakta)\n            boolean validPosition = false;\n            while (!validPosition) {\n                int x = (int)(Math.random() * (maxWorldCol - 10)) + 5;\n                int y = (int)(Math.random() * (maxWorldRow - 10)) + 5;\n                \n                // Oyuncudan yeterince uzakta olduğunu kontrol et\n                double distance = Math.sqrt(\n                    Math.pow(x*tilesize - player.worldx, 2) + \n                    Math.pow(y*tilesize - player.worldy, 2)\n                );\n                \n                if (distance > 10 * tilesize) { // En az 10 tile uzaklıkta\n                    newMonster.worldx = x * tilesize;\n                    newMonster.worldy = y * tilesize;\n                    validPosition = true;\n                }\n            }\n            \n            monster.add(newMonster);\n        }\n    }\n        public void checkLevelCompletion() {\n            if (monster.isEmpty()) {\n                // Tüm canavarlar ölmüş, sonraki seviyeye geç\n                currentLevel++;\n                \n\n                \n                    player.unlockWeaponsForLevel(currentLevel);\n                    \n                    // Yeni canavarları oluştur\n                    spawnMonstersForLevel(currentLevel);\n                    \n                  \n                \n            }\n        }\n        public void reset(){\n            stopMusic();\n            gameState = titleState;\n            player.setDefaultValues(); // Oyuncu değerlerini sıfırla\n            currentScore = 0; // Skoru sıfırla\n            currentLevel = 1; // Seviyeyi sıfırla\n            ui.gameFinished = false;\n            monster.clear(); // Canavarları temizle\n            bulletList.clear(); // Mermileri temizle\n            projectiles.clear(); // Diğer projeleri temizle\n            setup(); // Oyunu yeniden kur\n        }\n        public void saveGame() {\n            try {\n                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"save.dat\"));\n                \n                // Save basic game information\n                GameData data = new GameData();\n                \n                // Save player info\n                data.playerX = this.player.worldx;\n                data.playerY = this.player.worldy;\n                data.playerLife = this.player.life;\n                data.playerMaxLife = this.player.maxlife;\n                data.playerDirection = this.player.direction;\n                \n                // Save game state\n                data.currentScore = this.currentScore;\n                data.currentLevel = this.currentLevel;\n                \n                // Save weapons information\n                data.weaponUnlocked = this.player.weaponUnlocked.clone();\n                data.currentWeaponIndex = this.player.currentWeaponIndex;\n                \n                // Save ammunition information for each weapon\n                data.weaponAmmo = new int[this.player.weapons.size()];\n                data.weaponTotalAmmo = new int[this.player.weapons.size()];\n                \n                for (int i = 0; i < this.player.weapons.size(); i++) {\n                    Gun gun = this.player.weapons.get(i);\n                    data.weaponAmmo[i] = gun.currentAmmo;\n                    data.weaponTotalAmmo[i] = gun.totalAmmo;\n                }\n                \n                // Save monster information\n                data.monsterCount = this.monster.size();\n                if (data.monsterCount > 0) {\n                    data.monsterTypes = new String[data.monsterCount];\n                    data.monsterX = new int[data.monsterCount];\n                    data.monsterY = new int[data.monsterCount];\n                    data.monsterLife = new int[data.monsterCount];\n                    data.monsterDirection = new String[data.monsterCount];\n                    \n                    for (int i = 0; i < data.monsterCount; i++) {\n                        Creatures monster = this.monster.get(i);\n                        if (monster != null) {\n                            data.monsterTypes[i] = monster.getClass().getSimpleName();\n                            data.monsterX[i] = monster.worldx;\n                            data.monsterY[i] = monster.worldy;\n                            data.monsterLife[i] = monster.life;\n                            data.monsterDirection[i] = monster.direction;\n                        }\n                    }\n                }\n                \n                // Write the data object\n                oos.writeObject(data);\n                oos.close();\n                \n            \n        \n                \n            } catch (IOException e) {\n                e.printStackTrace();\n              \n            }\n        }\n        \n        /**\n         * Loads a saved game from a file\n         * @return true if the game was loaded successfully\n         */\n        public void loadGame() {\n            try {\n                File saveFile = new File(\"save.dat\");\n                if (!saveFile.exists()) {\n                   \n                    return ;\n                }\n                \n                ObjectInputStream ois = new ObjectInputStream(new FileInputStream(saveFile));\n                GameData data = (GameData) ois.readObject();\n                ois.close();\n                \n                // Load player info\n                this.player.worldx = data.playerX;\n                this.player.worldy = data.playerY;\n                this.player.life = data.playerLife;\n                this.player.maxlife = data.playerMaxLife;\n                this.player.direction = data.playerDirection;\n                \n                // Load game state\n                this.currentScore = data.currentScore;\n                this.currentLevel = data.currentLevel;\n                \n                // Load weapons information\n                this.player.weaponUnlocked = data.weaponUnlocked.clone();\n                this.player.resetWeapons(); // First reset weapons to their default state\n                \n                // Load ammunition information for each weapon\n                for (int i = 0; i < this.player.weapons.size() && i < data.weaponAmmo.length; i++) {\n                    Gun gun = this.player.weapons.get(i);\n                    gun.currentAmmo = data.weaponAmmo[i];\n                    gun.totalAmmo = data.weaponTotalAmmo[i];\n                }\n                \n                // Set the current weapon\n                this.player.switchWeapon(data.currentWeaponIndex);\n                \n                // Load monster information\n                this.monster.clear(); // Clear existing monsters\n                if (data.monsterCount > 0) {\n                    for (int i = 0; i < data.monsterCount; i++) {\n                        Creatures monster = null;\n                        \n                        // Create the appropriate monster type\n                        switch (data.monsterTypes[i]) {\n                            case \"Zombie\":\n                                monster = new Zombie(this);\n                                break;\n                            case \"Surungen\":\n                                monster = new Surungen(this);\n                                break;\n                            case \"Tank\":\n                                monster = new Tank(this);\n                                break;\n                            case \"Spitter\":\n                                monster = new Spitter(this);\n                                break;\n                        }\n                        \n                        if (monster != null) {\n                            monster.worldx = data.monsterX[i];\n                            monster.worldy = data.monsterY[i];\n                            monster.life = data.monsterLife[i];\n                            monster.direction = data.monsterDirection[i];\n                            this.monster.add(monster);\n                        }\n                    }\n                }\n                \n               \n         \n                \n                \n            } catch (IOException | ClassNotFoundException e) {\n                e.printStackTrace();\n              \n               \n            }\n        }\n        \n    }\n    \n",
      "UI.java": "\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nclass UtilityTool {\n    public BufferedImage scaleImage(BufferedImage original,int width,int height){\n        BufferedImage scaledImage=new BufferedImage(width,height,original.getType());\n        Graphics2D g2=scaledImage.createGraphics();\n        g2.drawImage(original,0,0,width,height,null);\n        g2.dispose();\n        return scaledImage;\n    }\n}\npublic class UI extends Creatures{\n    public String message = \"\";\n    public int messageCounter = 0;\n    public boolean gameFinished = false;\n    Graphics2D g2;\n    Font arial20;\n    Font arial40;\n    public int commandNum=0;\n    BufferedImage heart_full,heart_half,heart_blank;\n    public UI(GamePanel gp){\n        super(gp);\n        arial40=new Font(\"Arial\",Font.BOLD,80);\n        arial20=new Font(\"Arial\",Font.BOLD,30);\n       Creatures heart=new Heart(gp);\n       heart_full=heart.image;\n       heart_half=heart.image2;\n       heart_blank=heart.image3;\n    }\n    \n    public void draw(Graphics2D g2){\n        this.g2=g2;\n        g2.setFont(arial40);\n        g2.setColor(Color.black);\n       if(gp.gameState==gp.playState){\n        drawLife();\n        g2.setFont(arial20);\n        drawScore();\n        drawCurrentAmmo();\n        drawGun();\n        drawLevel();\n       }\n       if(gp.gameState==gp.titleState){\n        drawTitle();\n       }\n        if(gp.gameState==gp.pauseState){\n            drawPause();\n          }\n          else if (gp.gameState == gp.finalState) {\n            drawGameOver();\n        }\n    }\n    public void drawLevel() {\n        g2.setColor(Color.WHITE);\n        g2.drawString(\"Level: \" + gp.currentLevel, 50, gp.screenheight - 30);\n    }\n    public void drawMessage() {\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD, 30F));\n        g2.setColor(Color.WHITE);\n        int x = getxfortext(message);\n        int y = gp.screenheight / 2;\n        \n        // Gölge\n        g2.setColor(Color.BLACK);\n        g2.drawString(message, x+2, y+2);\n        \n        // Mesaj\n        g2.setColor(Color.YELLOW);\n        g2.drawString(message, x, y);\n    }\n    public void drawLife() {\n        int x = gp.tilesize / 2;\n        int y = gp.tilesize / 2;\n        int fullHearts = gp.player.life / 2;    // Tam kalp sayısı\n        int halfHearts = gp.player.life % 2;    // Yarım kalp var mı?\n    \n        // Tam kalpleri çiz\n        for (int i = 0; i < fullHearts; i++) {\n            g2.drawImage(heart_full, x, y, null);\n            x += gp.tilesize;\n        }\n    \n        // Yarım kalp çiz\n        if (halfHearts > 0) {\n            g2.drawImage(heart_half, x, y, null);\n            x += gp.tilesize;\n        }\n    \n        // Boş kalpleri çiz\n        int remainingHearts = (gp.player.maxlife / 2) - fullHearts - halfHearts;\n        for (int i = 0; i < remainingHearts; i++) {\n            g2.drawImage(heart_blank, x, y, null);\n            x += gp.tilesize;\n        }\n    }\n    \n    public void drawTitle(){\n        g2.setColor(new Color(32,73,67));\n        g2.fillRect(0, 0, gp.screenwidth, gp.screenheight);\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD,64F));\n        String text=\"SHOOTER GAME\";\n        int x=getxfortext(text);\n        int y=gp.tilesize*3;\n        g2.setColor(Color.red);\n        g2.drawString(text,x+3,y+3);\n        g2.setColor(Color.YELLOW);\n       \n        g2.drawString(text, x, y);\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD,32F));\n        text=\"NEW GAME\";\n        x=getxfortext(text);\n        y+=gp.tilesize*2;\n        if(commandNum==0)\n        g2.drawString(\"- >\", x-gp.tilesize, y);\n        g2.drawString(text, x, y);\n        text=\"CONTINUE\";\n        x=getxfortext(text);\n        y+=gp.tilesize;\n        if(commandNum==1)\n        g2.drawString(\"- >\", x-gp.tilesize, y);\n        g2.drawString(text, x, y);\n        text=\"LOAD GAME\";\n        x=getxfortext(text);\n        y+=gp.tilesize;\n        if(commandNum==2)\n        g2.drawString(\"- >\", x-gp.tilesize, y);\n        g2.drawString(text, x, y);\n        text=\"QUIT\";\n        x=getxfortext(text);\n        y+=gp.tilesize;\n        if(commandNum==3)\n        g2.drawString(\"- >\", x-gp.tilesize, y);\n        g2.drawString(text, x, y);\n        \n\n    }\n    public void drawScore() {\n        g2.setColor(Color.YELLOW);\n        g2.drawString(\"Puan: \" + gp.currentScore, gp.screenwidth - 150, 25);\n    }\n    public void drawCurrentAmmo() {\n        g2.setColor(Color.YELLOW);\n        g2.drawString(\"Şarjör: \" + gp.player.getCurrentGun().currentAmmo, gp.screenwidth - 300, 25);\n    }\n    public void drawGun(){\n        g2.setColor(Color.YELLOW);\n        g2.drawString(\"Gun: \" + gp.player.getCurrentGun().name, gp.screenwidth - 600, 25);\n    }\n    public int getxfortext(String text){\n        int length = (int)g2.getFontMetrics().getStringBounds(text, g2).getWidth();\n        int x=gp.screenwidth/2-length/2;\n        return x;\n    }\n\n    public void drawGameOver() {\n        g2.setColor(new Color(0, 0, 0, 200)); // Yarı saydam siyah\n        g2.fillRect(0, 0, gp.screenwidth, gp.screenheight);\n        \n        // \"GAME OVER\" yazısı\n        g2.setColor(Color.RED);\n        g2.setFont(arial40);\n        String text = \"GAME OVER\";\n        int x = getxfortext(text);\n        int y = gp.tilesize * 4;\n        \n        // Gölge efekti\n        g2.setColor(Color.CYAN);\n        g2.drawString(text, x+4, y+4);\n        \n        // Ana metin\n        g2.setColor(Color.RED);\n        g2.drawString(text, x, y);\n        \n        // Skor gösterimi\n        g2.setFont(arial20);\n        text = \"Final Score: \" + gp.currentScore;\n        x = getxfortext(text);\n        y += gp.tilesize * 2;\n        g2.setColor(Color.WHITE);\n        g2.drawString(text, x, y);\n        \n        text = \"Level Reached: \" + gp.currentLevel;\n        x = getxfortext(text);\n        y += gp.tilesize;\n        g2.drawString(text, x, y);\n\n      \n        text = \"Press ENTER to return to title screen\";\n        x = getxfortext(text);\n        y += gp.tilesize * 2;\n        g2.drawString(text, x, y);\n    }\n    public void drawPause(){\n        g2.setColor(new Color(45,73,88));\n        g2.fillRect(0, 0, gp.screenwidth, gp.screenheight);\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD,64F));\n        String text=\"PAUSED\";\n        int x=getxfortext(text);\n        int y=gp.tilesize*3;\n        g2.setColor(Color.red);\n        g2.drawString(text,x+3,y+3);\n        g2.setColor(Color.YELLOW);\n       \n        g2.drawString(text, x, y);\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD,32F));\n        text=\"CONTINUE\";\n        x=getxfortext(text);\n        y+=gp.tilesize*2;\n        if(commandNum==0)\n        g2.drawString(\"- >\", x-gp.tilesize, y);\n        g2.drawString(text, x, y);\n        text=\"SAVE GAME\";\n        x=getxfortext(text);\n        y+=gp.tilesize;\n        if(commandNum==1)\n        g2.drawString(\"- >\", x-gp.tilesize, y);\n        g2.drawString(text, x, y);\n        text=\"QUIT\";\n        x=getxfortext(text);\n        y+=gp.tilesize;\n        if(commandNum==2)\n        g2.drawString(\"- >\", x-gp.tilesize, y);\n        g2.drawString(text, x, y);\n       \n\n    }\n    }\n",
      "SaveLoad.java": "import java.io.*;\n\n\npublic class SaveLoad implements Serializable {\n    GamePanel gp;\n    \n    public SaveLoad(GamePanel gp) {\n        this.gp = gp;\n    }\n    \n    /**\n     * Saves the current game state to a file\n     */\n   \n    /**\n     * This class stores all the game data to be saved\n     * It must be serializable to be written to a file\n     */\n    \n}",
      "Surungen.java": "public class Surungen extends Creatures {\n    private final int jumpDistance = 5 * gp.tilesize; // 5 tile mesafe (zıplama tetikleme mesafesi)\n    private final int jumpSpeedBoost = 2; // Zıplama anındaki hız artışı\n    private boolean hasJumped = false; // Zıplama durumu kontrolü\n    private int jumpCooldown = 0; // Zıplama sonrası bekleme süresi\n    private final int maxCooldown = 240;\n    public Surungen(GamePanel gp){\n        super(gp);\n        name=\"Sürüngen Zombi\";\n        speed=4;\n        maxlife=2;\n        damage=1;\n        life=maxlife;\n        getImage();\n        solidArea.x=3;\n        solidArea.y=18;\n\n        solidArea.width=42;\n        solidArea.height=30;\n        solidAreaDefaultX=solidArea.x;\n        solidAreaDefaultY=solidArea.y;\n    }\n    public void getImage(){\n        up1=setup(\"/Res/surun1\");\n        up2=setup(\"/Res/surun2\");\n        down1=setup(\"/Res/surun1\");\n        down2=setup(\"/Res/surun2\");\n        left1=setup(\"/Res/surun1\");\n        left2=setup(\"/Res/surun2\");\n        right1=setup(\"/Res/surun1\");\n        right2=setup(\"/Res/surun2\");\n    }\n    public void setAction() {\n        int playerWorldX = gp.player.worldx;\n        int playerWorldY = gp.player.worldy;\n        \n        // Mesafe hesapla\n        double deltaX = playerWorldX - this.worldx;\n        double deltaY = playerWorldY - this.worldy;\n        double distance = Math.sqrt(deltaX*deltaX + deltaY*deltaY);\n\n        // Zıplama kontrolü\n        if(distance <= jumpDistance && !hasJumped && jumpCooldown <= 0) {\n            // Hızı artır ve zıplama durumunu aktif et\n            speed += jumpSpeedBoost;\n            hasJumped = true;\n            jumpCooldown = maxCooldown;\n            \n            // Hız artışını 1 saniye sonra kaldır\n            new java.util.Timer().schedule( \n                new java.util.TimerTask() {\n                    @Override\n                    public void run() {\n                        speed -= jumpSpeedBoost;\n                        hasJumped = false;\n                    }\n                }, \n                1000 // 1 saniye sonra\n            );\n        }\n\n        // Yön belirleme (orijinal kod)\n        if (Math.abs(deltaX) > Math.abs(deltaY)) {\n            if (deltaX > 0) direction = \"right\";\n            else direction = \"left\";\n        } else {\n            if (deltaY > 0) direction = \"down\";\n            else direction = \"up\";\n        }\n    }\n\n    @Override\n    public void update() {\n        // Cooldown sayacını azalt\n        if(jumpCooldown > 0) jumpCooldown--;\n        \n        setAction();\n        collisionOn = false;\n        gp.check.checkTile(this);\n        gp.check.checkCreature(this, gp.monster);\n        gp.check.checkPlayer(this);\n        \n        if (!collisionOn) {\n            switch (direction) {\n                case \"up\": worldy -= speed; break;\n                case \"down\": worldy += speed; break;\n                case \"left\": worldx -= speed; break;\n                case \"right\": worldx += speed; break;\n            }\n        }\n        \n        // Animasyon güncelleme\n        spriteCounter++;\n        if(spriteCounter > 10) {\n            spriteNum = (spriteNum == 1) ? 2 : 1;\n            spriteCounter = 0;\n        }\n    }\n    \n}\n\n",
      "AssaultRifle.java": "public class AssaultRifle extends Gun {\n    \n    private final double spreadAngle = Math.toRadians(30); // 30 derece sapma açısı\n    \n    public AssaultRifle(GamePanel gp) {\n        super(gp, \"assaultrifle\", 1, 30, 600); // 30 mermi kapasiteli, dakikada 600 atış hızı\n        this.gp=gp;\n        this.totalAmmo = 120; // 4 şarjör yedek mermi\n    }\n    \n    @Override\n    public void shoot(int mouseX, int mouseY) {\n        if (canShoot()) {\n            \n            int playerCenterX = gp.player.screenx + gp.tilesize / 2;\n            int playerCenterY = gp.player.screeny + gp.tilesize / 2;\n            \n            double angle = Math.atan2(mouseY - playerCenterY, mouseX - playerCenterX);\n            \n            \n            double spread = (Math.random() * spreadAngle * 2) - spreadAngle;//sapma\n            angle += spread;\n            \n          \n            Bullet bullet = new Bullet(gp);\n            bullet.setPos(gp.player.worldx + gp.tilesize / 2 - (bullet.getWidth() / 2),\n                          gp.player.worldy + gp.tilesize / 2 - (bullet.getHeight() / 2));\n            bullet.setDirection(angle);\n            bullet.setDamage(damage);\n            bullet.setSource(gp.player);\n            \n          \n            gp.bulletList.add(bullet);\n            \n            // Atış hızı sayacını güncelle\n            fireRateCounter = fireRateTicks;\n            \n            // Mermi sayısını azalt\n            currentAmmo--;\n            \n            \n           \n        }\n    }\n}\n\n// Pompalı Tüfek sınıfı\n",
      "Tank.java": "public class Tank extends Creatures {\n    public Tank(GamePanel gp){\n        super(gp);\n        name=\"Tank Zombi\";\n        speed=1;\n        maxlife=6;\n        damage=2;\n        life=maxlife;\n        getImage();\n        solidArea.x=3;\n        solidArea.y=18;\n\n        solidArea.width=42;\n        solidArea.height=30;\n        solidAreaDefaultX=solidArea.x;\n        solidAreaDefaultY=solidArea.y;\n    }\n    public void getImage(){\n        up1=setup(\"/Res/Tank1\");\n        up2=setup(\"/Res/Tank2\");\n        down1=setup(\"/Res/Tank1\");\n        down2=setup(\"/Res/Tank2\");\n        left1=setup(\"/Res/Tank1\");\n        left2=setup(\"/Res/Tank2\");\n        right1=setup(\"/Res/Tank1\");\n        right2=setup(\"/Res/Tank2\");\n    }\n    public void setAction(){\n        int playerWorldX = gp.player.worldx;\n        int playerWorldY = gp.player.worldy;\n    \n        // X ve Y eksenlerindeki farkı hesapla\n        int deltaX = playerWorldX - this.worldx;\n        int deltaY = playerWorldY - this.worldy;\n    \n        // Hangi yöne hareket edeceğini belirle\n        if (Math.abs(deltaX) > Math.abs(deltaY)) {\n            // X ekseninde daha büyük fark varsa\n            if (deltaX > 0) {\n                direction = \"right\";\n            } else {\n                direction = \"left\";\n            }\n        } else {\n            // Y ekseninde daha büyük fark varsa\n            if (deltaY > 0) {\n                direction = \"down\";\n            } else {\n                direction = \"up\";\n            }\n        }\n}\n// Zombie.java\n@Override\npublic void update() {\n    setAction(); // Sürekli oyuncunun konumunu takip et\n    collisionOn = false;\n    gp.check.checkTile(this);\n    gp.check.checkCreature(this, gp.monster); // Diğer zombilerle çarpışma kontrolü\n    gp.check.checkPlayer(this);\n    if (!collisionOn) {\n        switch (direction) {\n            case \"up\": worldy -= speed; break;\n            case \"down\": worldy += speed; break;\n            case \"left\": worldx -= speed; break;\n            case \"right\": worldx += speed; break;\n        }\n    }\n    spriteCounter++;\n    if(spriteCounter>10){\n        if(spriteNum==1){\n          spriteNum=2;\n        }\n        else if(spriteNum==2){\n          spriteNum=1;\n        }\n        spriteCounter=0;\n      }\n    \n}\n\n}\n",
      "Game.java": "\nimport javax.swing.JFrame;\n\n\n\npublic class Game {\n    public static void main(String[] args) {\n   \n        JFrame window = new JFrame();\n        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        window.setResizable(false);\n        window.setTitle(\"2D SHOOTER GAME\");\n\n        GamePanel gamepanel = new GamePanel();\n        window.add(gamepanel);\n        window.pack();\n        window.setLocationRelativeTo(null);\n        window.setVisible(true);\n        gamepanel.setup();\n        gamepanel.startGameThread();\n    \n}\n}\n",
      "MouseInput.java": "\nimport java.awt.Cursor;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\n\npublic class MouseInput implements MouseListener, MouseMotionListener{\n\n    GamePanel gp;\n    public MouseEvent event;\n\n    public boolean mouseLeftPressed;\n    public int mouseX, mouseY;\n\n    public MouseInput(GamePanel gp){\n        this.gp = gp;\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        \n    }\n\n  \n    @Override\npublic void mousePressed(MouseEvent e) {\n    int code = e.getButton();\n    if(code == MouseEvent.BUTTON1){\n        mouseLeftPressed = true;\n        event = e;\n        mouseX = e.getX(); // Koordinatları güncelle\n        mouseY = e.getY();\n        if(gp.gameState == gp.playState&&gp.player.getCurrentGun().canShoot()) { \n            gp.player.getCurrentGun().shoot(mouseX, mouseY);\n        }\n    }\n}\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        mouseLeftPressed = false;\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e) {\n        gp.setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR)); // El simgesine değiştir\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e) {\n        gp.setCursor(new Cursor(Cursor.DEFAULT_CURSOR)); // Varsayılana dön\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        // Update current mouse position while dragging\n        if(mouseLeftPressed) {\n            mouseX = e.getX();\n            mouseY = e.getY();\n            event = e; \n        }\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        // Update current mouse position while moving\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n}\n\n",
      "CollisionChecker.java": "import java.util.ArrayList;\n\npublic class CollisionChecker {\n    GamePanel gp;\n    public CollisionChecker(GamePanel gp){\n     this.gp=gp;\n    }\n    public void checkTile(Creatures creature){\n        int creatureLeftWorldx = creature.worldx + creature.solidArea.x;\n        int creatureRightWorldx = creature.worldx + creature.solidArea.x + creature.solidArea.width;\n        int creatureTopWorldy = creature.worldy + creature.solidArea.y;\n        int creatureBottomWorldy = creature.worldy + creature.solidArea.y + creature.solidArea.height;\n    \n        int creatureLeftCol = creatureLeftWorldx / gp.tilesize;\n        int creatureRightCol = creatureRightWorldx / gp.tilesize;\n        int creatureTopRow = creatureTopWorldy / gp.tilesize;\n        int creatureBottomRow = creatureBottomWorldy / gp.tilesize;\n    \n        // Sınır kontrolü ekle\n        creatureLeftCol = Math.max(0, Math.min(creatureLeftCol, gp.maxWorldCol - 1));\n        creatureRightCol = Math.max(0, Math.min(creatureRightCol, gp.maxWorldCol - 1));\n        creatureTopRow = Math.max(0, Math.min(creatureTopRow, gp.maxWorldRow - 1));\n        creatureBottomRow = Math.max(0, Math.min(creatureBottomRow, gp.maxWorldRow - 1));\n\n      int tileNum1,tileNum2;\n     switch(creature.direction) {\n        case \"up\":\n        creatureTopRow=(creatureTopWorldy-creature.speed)/gp.tilesize;\n        tileNum1=gp.tileM.mapTileNum[creatureLeftCol][creatureTopRow];\n        tileNum2=gp.tileM.mapTileNum[creatureRightCol][creatureTopRow];\n        if(gp.tileM.tile[tileNum1].collision==true||gp.tileM.tile[tileNum2].collision==true){\n            creature.collisionOn=true;\n        }\n        break;\n        case \"down\":\n        creatureBottomRow=(creatureBottomWorldy+creature.speed)/gp.tilesize;\n        tileNum1=gp.tileM.mapTileNum[creatureLeftCol][creatureBottomRow];\n        tileNum2=gp.tileM.mapTileNum[creatureRightCol][creatureBottomRow];\n        if(gp.tileM.tile[tileNum1].collision==true||gp.tileM.tile[tileNum2].collision==true){\n            creature.collisionOn=true;\n        }\n        break;\n        case \"left\":\n        creatureLeftCol=(creatureLeftWorldx-creature.speed)/gp.tilesize;\n        tileNum1=gp.tileM.mapTileNum[creatureLeftCol][creatureTopRow];\n        tileNum2=gp.tileM.mapTileNum[creatureLeftCol][creatureBottomRow];\n        if(gp.tileM.tile[tileNum1].collision==true||gp.tileM.tile[tileNum2].collision==true){\n            creature.collisionOn=true;\n        }\n        break;\n        case \"right\":\n        creatureRightCol=(creatureRightWorldx+creature.speed)/gp.tilesize;\n        tileNum1=gp.tileM.mapTileNum[creatureRightCol][creatureTopRow];\n        tileNum2=gp.tileM.mapTileNum[creatureRightCol][creatureBottomRow];\n        if(gp.tileM.tile[tileNum1].collision==true||gp.tileM.tile[tileNum2].collision==true){\n            creature.collisionOn=true;\n        }\n        break;\n     }\n    }\n    public int checkCreature(Creatures creature, ArrayList<? extends Creatures> target) {\n    int index = 999;\n\n    \n    boolean isBullet = creature instanceof Bullet;\n\n    for(int i = 0; i < target.size(); i++) {\n        if(target.get(i) != null) {\n            Creatures trgt = target.get(i);\n            \n            // Get solid area positions\n            creature.solidArea.x = creature.worldx + creature.solidAreaDefaultX;\n            creature.solidArea.y = creature.worldy + creature.solidAreaDefaultY;\n            \n            trgt.solidArea.x = trgt.worldx + trgt.solidAreaDefaultX;\n            trgt.solidArea.y = trgt.worldy + trgt.solidAreaDefaultY;\n            \n            // Mermi değilse normal yön kontrolü yap\n            if (!isBullet) {\n                switch(creature.direction) {\n                    case \"up\": creature.solidArea.y -= creature.speed; break;\n                    case \"down\": creature.solidArea.y += creature.speed; break;\n                    case \"left\": creature.solidArea.x -= creature.speed; break;\n                    case \"right\": creature.solidArea.x += creature.speed; break;\n                }\n            }\n            \n            // Çarpışma kontrolü\n            if(creature.solidArea.intersects(trgt.solidArea)) {\n                if(trgt != creature) {\n                    creature.collisionOn = true;\n                    index = i;\n                }\n            }\n\n            // Solid area pozisyonlarını sıfırla\n            creature.solidArea.x = creature.solidAreaDefaultX;\n            creature.solidArea.y = creature.solidAreaDefaultY;\n            trgt.solidArea.x = trgt.solidAreaDefaultX;\n            trgt.solidArea.y = trgt.solidAreaDefaultY;\n        }\n    }\n\n    return index;\n}\n   \n   \n public boolean checkPlayer(Creatures creature){\n    boolean contactPlayer = false;\n\n    if(gp.player != null){\n        // Get Entity's Solid Area Position\n        creature.solidArea.x = creature.worldx + creature.solidArea.x;\n        creature.solidArea.y = creature.worldy + creature.solidArea.y;\n        // Get The Object's Solid Area Position\n        gp.player.solidArea.x = gp.player.worldx + gp.player.solidArea.x;\n        gp.player.solidArea.y = gp.player.worldy + gp.player.solidArea.y;\n    \n        switch(creature.direction){\n            case \"up\":\n            creature.solidArea.y -= creature.speed;\n                break;\n            case \"down\":\n            creature.solidArea.y += creature.speed;\n                break;\n            case \"left\":\n            creature.solidArea.x -= creature.speed;\n                break;\n            case \"right\":\n            creature.solidArea.x += creature.speed;\n                break;\n        }\n\n        if(creature.solidArea.intersects(gp.player.solidArea)){\n            creature.collisionOn = true;\n            gp.player.takeDamage(creature.damage);\n            contactPlayer = true;\n        }\n\n        creature.solidArea.x = creature.solidAreaDefaultX;\n        creature.solidArea.y = creature.solidAreaDefaultY;\n        gp.player.solidArea.x = gp.player.solidAreaDefaultX;\n        gp.player.solidArea.y = gp.player.solidAreaDefaultY;\n    }\n\n    return contactPlayer;\n}\npublic boolean checkProjectile(Weapon projectile) {\n    boolean contact = false;\n    \n    // Get projectile's solid area position\n    projectile.solidArea.x = projectile.worldx + projectile.solidArea.x;\n    projectile.solidArea.y = projectile.worldy + projectile.solidArea.y;\n    \n    // Get player's solid area position\n    gp.player.solidArea.x = gp.player.worldx + gp.player.solidArea.x;\n    gp.player.solidArea.y = gp.player.worldy + gp.player.solidArea.y;\n    \n    // Check if the solid areas intersect\n    if(projectile.solidArea.intersects(gp.player.solidArea)) {\n        if(!gp.player.invincible) {\n            contact = true;\n        }\n    }\n    \n    // Reset solid area positions\n    projectile.solidArea.x = projectile.solidAreaDefaultX;\n    projectile.solidArea.y = projectile.solidAreaDefaultY;\n    gp.player.solidArea.x = gp.player.solidAreaDefaultX;\n    gp.player.solidArea.y = gp.player.solidAreaDefaultY;\n    \n    return contact;\n}\npublic boolean checkBullet(Bullet projectile) {\n    boolean contact = false;\n    \n    // Get projectile's solid area position\n    projectile.solidArea.x = projectile.worldx + projectile.solidArea.x;\n    projectile.solidArea.y = projectile.worldy + projectile.solidArea.y;\n    \n    // Get player's solid area position\n    gp.player.solidArea.x = gp.player.worldx + gp.player.solidArea.x;\n    gp.player.solidArea.y = gp.player.worldy + gp.player.solidArea.y;\n    \n    // Check if the solid areas intersect\n    if(projectile.solidArea.intersects(gp.player.solidArea)) {\n        if(!gp.player.invincible) {\n            contact = true;\n        }\n    }\n    \n    // Reset solid area positions\n    projectile.solidArea.x = projectile.solidAreaDefaultX;\n    projectile.solidArea.y = projectile.solidAreaDefaultY;\n    gp.player.solidArea.x = gp.player.solidAreaDefaultX;\n    gp.player.solidArea.y = gp.player.solidAreaDefaultY;\n    \n    return contact;\n}\n\n}\n",
      "RocketLauncher.java": "public class RocketLauncher extends Gun {\n    \n    private final int explosionRadius = 100; // Patlama yarıçapı (piksel)\n    \n    public RocketLauncher(GamePanel gp) {\n        super(gp, \"rocketlauncher\", 5, 1, 10);\n        this.gp=gp; // 1 roket kapasiteli, dakikada 10 atış hızı, 5 kat zarar\n        this.totalAmmo = 5; // 5 yedek roket\n    }\n    \n    @Override\n    public void shoot(int mouseX, int mouseY) {\n        if (canShoot()) {\n            // Oyuncu merkezinden fare pozisyonuna doğru atış vektörü hesapla\n            int playerCenterX = gp.player.screenx + gp.tilesize / 2;\n            int playerCenterY = gp.player.screeny + gp.tilesize / 2;\n            \n            double angle = Math.atan2(mouseY - playerCenterY, mouseX - playerCenterX);\n            \n           \n            Rocket rocket = new Rocket(gp);\n            rocket.setPos(gp.player.worldx + gp.tilesize / 2 - (rocket.getWidth() / 2),\n                          gp.player.worldy + gp.tilesize / 2 - (rocket.getHeight() / 2));\n            rocket.setDirection(angle);\n            rocket.setDamage(damage);\n            rocket.setExplosionRadius(explosionRadius);\n            rocket.setSource(gp.player);\n            \n            // Roketi oyun panosuna ekle\n            gp.bulletList.add(rocket);\n            \n            // Atış hızı sayacını güncelle\n            fireRateCounter = fireRateTicks;\n            \n            // Mermi sayısını azalt\n            currentAmmo--;\n            \n         \n        }\n    }\n}\n",
      "Creatures.java": "\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport javax.imageio.ImageIO;\nimport java.io.*;\n\npublic class Creatures {\n    GamePanel gp;\n    public int worldx,worldy;\n    public int speed;\n    public BufferedImage up1,up2,down1,down2,left1,left2,right1,right2;\n    public BufferedImage attackUp1,attackUp2,attackDown1,attackDown2,attackLeft1,attackLeft2,attackRight1,attackRight2;\n    public String direction=\"down\";\n    public int spriteCounter=0;\n    public int invincibleCounter=0;\n    public int spriteNum=1;\n    public Rectangle solidArea=new Rectangle(0,0,48,48);\n    public boolean invincible=false;\n    public boolean collisionOn=false;\n    public int maxlife;\n    public int life;\n    public BufferedImage image;\n    public BufferedImage image2;\n    public BufferedImage image3;\n    public String name;\n    public int damage;\n    public boolean collision = false;\n    UtilityTool uTool = new UtilityTool();\n    public int actionLockCounter=0;\n    public int Maxmana;\n    public int mana;\n    public boolean alive;\n    public int solidAreaDefaultX = 0;\n    public int solidAreaDefaultY = 0;\n    private int worldX;\n   \n    public int useCost;\n    // Yapıcıya solidArea'nın başlatılmasını ekleyin\n    public Creatures(GamePanel gp){\n        this.gp = gp;\n        solidArea = new Rectangle(); // Bu satırı ekleyin\n    }\n    \n    public BufferedImage setup(String imagePath){\n        UtilityTool uTool=new UtilityTool();\n        BufferedImage image=null;\n        try{\n            image=ImageIO.read(getClass().getResourceAsStream(imagePath+\".png\"));\n            image=uTool.scaleImage(image,gp.tilesize,gp.tilesize);\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }\n        return image;\n    }\n    public void setAction(){\n\n    }\n    public void takeDamage(int damage) {\n        if (!invincible) { // Sadece invincible değilse hasar al\n            life -= damage;\n            invincible = true; \n            if (life < 0) life = 0;\n        }\n    }\npublic void update() {\n    if (invincible) {\n        invincibleCounter++;\n        if (invincibleCounter > 60) { // 30 frame (yaklaşık 0.5 saniye) sonra tekrar hasar alabilsin\n            invincible = false;\n            invincibleCounter = 0;\n        }\n    }\n    solidArea.x = solidAreaDefaultX;\n    solidArea.y = solidAreaDefaultY;\n    setAction();\n    collisionOn = false;\n    gp.check.checkTile(this);\n    gp.check.checkCreature(this,gp.monster);\n    gp.check.checkPlayer(this);\n    \n    if(!collisionOn){\n        switch(direction){\n            case \"up\":\n                worldy -= speed;\n                break;\n            case \"down\":\n                worldy += speed;\n                break;\n            case \"left\":\n                worldx -= speed;\n                break;\n            case \"right\":\n                worldx += speed;\n                break;\n        }\n    }\n\n    spriteCounter++;\n    if(spriteCounter > 12){\n        if(spriteNum == 1){\n            spriteNum = 2;\n        }\n        else if(spriteNum == 2){\n            spriteNum = 1;\n        }\n        spriteCounter = 0;\n    }\n}\npublic void draw(Graphics2D g2){\n    int screenX = worldx- gp.player.worldx + gp.player.screenx;\n    int screenY = worldy - gp.player.worldy + gp.player.screeny;\n    \n    if(worldx + gp.tilesize > gp.player.worldx - gp.player.screenx\n    && worldx - gp.tilesize < gp.player.worldx + gp.player.screenx\n    && worldy + gp.tilesize > gp.player.worldy - gp.player.screeny \n    && worldy - gp.tilesize < gp.player.worldy + gp.player.screeny){\n        \n        BufferedImage image = null;\n\n        switch(direction){\n            case \"up\":\n                if(spriteNum == 1){\n                    image = up1;\n                }\n                if(spriteNum == 2){\n                    image = up2;\n                }\n                break;\n            case \"down\":\n                if(spriteNum == 1){\n                    image = down1;\n                }\n                if(spriteNum == 2){\n                    image = down2;\n                }\n                break;\n            case \"left\":\n                if(spriteNum == 1){\n                    image = left1;\n                }\n                if(spriteNum == 2){\n                    image = left2;\n                }\n                break;\n            case \"right\":\n                if(spriteNum == 1){\n                    image = right1;\n                }\n                if(spriteNum == 2){\n                    image = right2;\n                }\n                break;\n        }\n        g2.drawImage(image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n    }\n   \n\n}\n}\n class AssetSetter implements Serializable {\n    GamePanel gp;\n    public AssetSetter(GamePanel gp){\n        this.gp=gp;\n    }\n    public void setMonster(){\n        gp.monster.add(new Zombie(gp));\n        gp.monster.get(0).worldx=gp.tilesize*23;\n        gp.monster.get(0).worldy=gp.tilesize*36;\n        gp.monster.add(new Zombie(gp));\n        gp.monster.get(1).worldx=gp.tilesize*24;\n        gp.monster.get(1).worldy=gp.tilesize*35;\n        gp.monster.add(new Tank(gp));\n        gp.monster.get(2).worldx=gp.tilesize*22;\n        gp.monster.get(2).worldy=gp.tilesize*33;\n        gp.monster.add(new Tank(gp));\n        gp.monster.get(3).worldx=gp.tilesize*21;\n        gp.monster.get(3).worldy=gp.tilesize*32;\n        gp.monster.add(new Surungen(gp));\n        gp.monster.get(4).worldx=gp.tilesize*11;\n        gp.monster.get(4).worldy=gp.tilesize*24;\n        gp.monster.add(new Surungen(gp));\n        gp.monster.get(5).worldx=gp.tilesize*13;\n        gp.monster.get(5).worldy=gp.tilesize*26;\n        gp.monster.add(new Spitter(gp));\n        gp.monster.get(6).worldx=gp.tilesize*35;\n        gp.monster.get(6).worldy=gp.tilesize*23;\n        gp.monster.add(new Spitter(gp));\n        gp.monster.get(7).worldx=gp.tilesize*15;\n        gp.monster.get(7).worldy=gp.tilesize*27;\n}\n\n }\nclass Heart extends Creatures  {\n  \n    public Heart(GamePanel gp){\n        super(gp);\n        name=\"Heart\";\n         image=setup(\"/Life/heart_full\");\n         image2=setup(\"/Life/heart_half\");\n         image3=setup(\"/Life/heart_blank\");\n    }\n}",
      "TileManager.java": "\nimport java.awt.Graphics2D;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport javax.imageio.ImageIO;\n\npublic class TileManager {\n    GamePanel gp;\n    public Tile[]tile;\n    public int[][] mapTileNum;\n    public TileManager(GamePanel gp){\n        this.gp=gp;\n        tile=new Tile[50];\n        mapTileNum=new int[gp.maxWorldCol][gp.maxWorldRow];\n        getTileImage();\n        loadMap();\n    }\n    public void getTileImage(){\n            \n            setup(0,\"grass00\",false);\n            setup(1,\"grass00\",false);\n            setup(2,\"grass00\",false);\n            setup(3,\"grass00\",false);\n            setup(4,\"grass00\",false);\n            setup(5,\"grass00\",false);\n            setup(6,\"grass00\",false);\n            setup(7,\"grass00\",false);\n            setup(8,\"grass00\",false);\n            setup(9,\"grass00\",false);\n            setup(10,\"grass00\",false);\n            setup(11,\"grass01\",false);\n            setup(12,\"water00\",true);\n            setup(13,\"water01\",true);\n            setup(14,\"water02\",true);\n            setup(15,\"water03\",true);\n            setup(16,\"water04\",true);\n            setup(17,\"water05\",true);\n            setup(18,\"water06\",true);\n            setup(19,\"water07\",true);\n            setup(20,\"water08\",true);\n            setup(21,\"water09\",true);\n            setup(22,\"water10\",true);\n            setup(23,\"water11\",true);\n            setup(24,\"water12\",true);\n            setup(25,\"water13\",true);\n            setup(26,\"road00\",false);\n            setup(27,\"road01\",false);\n            setup(28,\"road02\",false);\n            setup(29,\"road03\",false);\n            setup(30,\"road04\",false);\n            setup(31,\"road05\",false);\n            setup(32,\"road06\",false);\n            setup(33,\"road07\",false);\n            setup(34,\"road08\",false);\n            setup(35,\"road09\",false);\n            setup(36,\"road10\",false);\n            setup(37,\"road11\",false);\n            setup(38,\"road12\",false);\n            setup(39,\"earth\",false);\n            setup(40,\"wall\",true);\n            setup(41,\"tree\",true);\n            \n          \n            \n            \n         \n    }\n    public void setup(int index,String imagePath,boolean collision){\n        UtilityTool uTool=new UtilityTool();\n        try {\n            tile[index]=new Tile();\n            tile[index].image=ImageIO.read(getClass().getResourceAsStream(\"/picsel/\"+imagePath+\".png\"));\n            tile[index].image=uTool.scaleImage(tile[index].image,gp.tilesize,gp.tilesize);\n            tile[index].collision=collision;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public void loadMap() {\n        try {\n            InputStream is = getClass().getResourceAsStream(\"/maps/Grassland1_modified.txt\");\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            int row = 0;\n            String line;\n            while ((line = br.readLine()) != null && row < gp.maxWorldRow) {\n                String[] numbers = line.split(\" \");\n                for (int col = 0; col < gp.maxWorldCol; col++) {\n                    int num = Integer.parseInt(numbers[col]);\n                    mapTileNum[col][row] = num;\n                }\n                row++;\n            }\n            br.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public void draw(Graphics2D g2){\n       int col=0;\n       int row=0;\n     \n       while(col<gp.maxWorldCol&& row< gp.maxWorldRow){\n        int tileNum=mapTileNum[col][row];\n        int worldx=col*gp.tilesize;\n        int worldy=row*gp.tilesize;\n        int screenx=worldx-gp.player.worldx+gp.player.screenx;\n        int screeny=worldy-gp.player.worldy+gp.player.screeny;\n\n        if(worldx+gp.tilesize>gp.player.worldx-gp.player.screenx&&worldx-gp.tilesize<gp.player.worldx+gp.player.screenx&&\n        worldy+gp.tilesize>gp.player.worldy-gp.player.screeny&&worldy-gp.tilesize<gp.player.worldy+gp.player.screeny){\n        g2.drawImage(tile[tileNum].image,screenx,screeny,gp.tilesize,gp.tilesize,null);\n        }\n        col++;\n      \n        if(col==gp.maxWorldCol){\n            col=0;\n           \n            row++;\n        \n\n        }\n       }\n    }\n}\n",
      "GameData.java": "import java.io.*;\npublic class GameData implements Serializable {\n    private static final long serialVersionUID = 1L;\n    \n    // Player data\n    int playerX, playerY;\n    int playerLife, playerMaxLife;\n    String playerDirection;\n    \n    // Game state\n    int currentScore;\n    int currentLevel;\n    \n    // Weapons data\n    boolean[] weaponUnlocked;\n    int currentWeaponIndex;\n    int[] weaponAmmo;\n    int[] weaponTotalAmmo;\n    \n    // Monster data\n    int monsterCount;\n    String[] monsterTypes;\n    int[] monsterX, monsterY;\n    int[] monsterLife;\n    String[] monsterDirection;\n}\n",
      "Player.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.imageio.ImageIO;\n\npublic class Player extends Creatures {\n    public boolean[] weaponUnlocked = new boolean[5];\n    public List<Gun> weapons = new ArrayList<>();\n    public int currentWeaponIndex = 0;\n    public Gun currentGun;\n    public final int screenx;\n    public final int screeny;\n    public boolean invincible = false; // Hasar alınamaz durum\n    public int invincibleCounter = 0; // Cooldown sayacı\n    public final int invincibleDuration = 60; // Cooldown süresi (60 frame ≈ 1 saniye)\n    KeyInput key;\n    MouseInput mouse;\n    Bullet bullet;\n    public Player(GamePanel gp, KeyInput key, MouseInput mouse) {\n        super(gp);\n        \n        this.key = key;\n        this.mouse = mouse;\n        screenx = gp.screenwidth / 2 - (gp.tilesize / 2);\n        screeny = gp.screenheight / 2 - (gp.tilesize / 2);\n        solidArea = new Rectangle();\n        solidArea.x = 0;\n        solidArea.y = 0;\n        solidArea.width = 32;\n        solidArea.height = 32;\n        setDefaultValues();\n        getPlayerImage();\n\n        // Initialize weapons\n        weapons.add(new Pistol(gp));\n        weapons.add(new AssaultRifle(gp));\n        weapons.add(new Shotgun(gp));\n        weapons.add(new SniperRifle(gp));\n        weapons.add(new RocketLauncher(gp));\n        weaponUnlocked[0] = true;\n        for (int i = 1; i < weaponUnlocked.length; i++) {\n            weaponUnlocked[i] = false;\n        }\n        \n        currentWeaponIndex = 0;\n        currentGun = weapons.get(currentWeaponIndex);\n    }\n\n    public void setDefaultValues() {\n        worldx = gp.tilesize * 23;\n        worldy = gp.tilesize * 21;\n        speed = 6;\n        maxlife = 20;\n        life = maxlife;\n        resetWeapons();\n    }\n\n    public void getPlayerImage() {\n        up1 = setup(\"boy_up_1\");\n        up2 = setup(\"boy_up_2\");\n        down1 = setup(\"boy_down_1\");\n        down2 = setup(\"boy_down_2\");\n        left1 = setup(\"boy_left_1\");\n        left2 = setup(\"boy_left_2\");\n        right1 = setup(\"boy_right_1\");\n        right2 = setup(\"boy_right_2\");\n    }\n\n    public BufferedImage setup(String imageName) {\n        UtilityTool uTool = new UtilityTool();\n        BufferedImage scaledImage = null;\n        try {\n            scaledImage = ImageIO.read(getClass().getResourceAsStream(\"/Res/\" + imageName + \".png\"));\n            scaledImage = uTool.scaleImage(scaledImage, gp.tilesize, gp.tilesize);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return scaledImage;\n    }\n\n    public void takeDamage(int damage) {\n        if (!invincible) { // Sadece invincible değilse hasar al\n            life -= damage;\n            invincible = true; // Hasar alınamaz durumu aktif et\n            if (life < 0) life = 0;\n        }\n    }\n\n    public void update() {\n        if (key.uppress || key.downpress || key.leftpress || key.rightpress) {\n            if (key.uppress) {\n                direction = \"up\";\n            } else if (key.downpress) {\n                direction = \"down\";\n            } else if (key.leftpress) {\n                direction = \"left\";\n            } else if (key.rightpress) {\n                direction = \"right\";\n            }\n            collisionOn = false;\n            gp.check.checkTile(this);\n            gp.check.checkCreature(this, gp.monster);\n\n            if (!collisionOn) {\n                switch (direction) {\n                    case \"up\":\n                        worldy -= speed;\n                        break;\n                    case \"down\":\n                        worldy += speed;\n                        break;\n                    case \"left\":\n                        worldx -= speed;\n                        break;\n                    case \"right\":\n                        worldx += speed;\n                        break;\n                }\n            }\n            spriteCounter++;\n            if (spriteCounter > 10) {\n                spriteNum = (spriteNum == 1) ? 2 : 1;\n                spriteCounter = 0;\n            }\n            \n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        BufferedImage image = null;\n        switch (direction) {\n            case \"up\":\n                if (spriteNum == 1) image = up1;\n                if (spriteNum == 2) image = up2;\n                break;\n            case \"down\":\n                if (spriteNum == 1) image = down1;\n                if (spriteNum == 2) image = down2;\n                break;\n            case \"left\":\n                if (spriteNum == 1) image = left1;\n                if (spriteNum == 2) image = left2;\n                break;\n            case \"right\":\n                if (spriteNum == 1) image = right1;\n                if (spriteNum == 2) image = right2;\n                break;\n        }\n        g2.drawImage(image, screenx, screeny, gp.tilesize, gp.tilesize, null);\n\n        // Draw the current weapon\n        drawWeapon(g2);\n    }\n\n    public void drawWeapon(Graphics2D g2) {\n        // Draw the weapon in the player's hand or near the player\n        int weaponX = screenx + gp.tilesize / 2;\n        int weaponY = screeny + gp.tilesize / 2;\n        g2.drawImage(currentGun.getImage(), weaponX, weaponY, gp.tilesize, gp.tilesize, null);\n    }\n\n    public Gun getCurrentGun() {\n        return weapons.get(currentWeaponIndex);\n    }\n\n    public void switchWeapon(int index) {\n        if (index >= 0 && index < weapons.size() && weaponUnlocked[index]) {\n            currentWeaponIndex = index;\n            currentGun = weapons.get(currentWeaponIndex);\n        }\n    }\n    public void resetWeapons() {\n        // Tüm silahları ve mermi miktarlarını sıfırla\n        weapons.clear();\n        \n        // Silahları yeniden oluştur\n        weapons.add(new Pistol(gp));\n        weapons.add(new AssaultRifle(gp));\n        weapons.add(new Shotgun(gp));\n        weapons.add(new SniperRifle(gp));\n        weapons.add(new RocketLauncher(gp));\n        weaponUnlocked[0] = true;\n        for (int i = 1; i < weaponUnlocked.length; i++) {\n            weaponUnlocked[i] = false;\n        }\n        // İlk silahı seç\n        currentWeaponIndex = 0;\n        currentGun = weapons.get(currentWeaponIndex);\n    }\n    public void unlockWeaponsForLevel(int level) {\n        if (level >= 2) weaponUnlocked[1] = true; // Assault Rifle\n        if (level >= 3) weaponUnlocked[2] = true; // Shotgun\n        if (level >= 5) weaponUnlocked[3] = true; // Sniper Rifle\n        if (level >= 10) weaponUnlocked[4] = true; // Rocket Launcher\n        \n       \n    }\n \n    \n}",
      "Asit.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Asit extends Weapon {\n    public Asit(GamePanel gp, int startX, int startY, String direction) {\n        super(gp);\n        this.worldx = startX;\n        this.worldy = startY;\n        this.direction = direction;\n        this.speed = 5; \n        this.damage = 1; \n        solidArea = new Rectangle(8, 8, 16, 16);\n      \n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        getImage();\n    }\n\n    public void getImage() {\n        up1 = setup(\"/Res/Asit\");\n        up2 = setup(\"/Res/Asit\");\n        down1 = setup(\"/Res/Asit\");\n        down2 = setup(\"/Res/Asit\");\n        left1 = setup(\"/Res/Asit\");\n        left2 = setup(\"/Res/Asit\");\n        right1 = setup(\"/Res/Asit\");\n        right2 = setup(\"/Res/Asit\");\n    }\n\n    @Override\n    public void update() {\n        // First check tile collision\n        gp.check.checkTile(this);\n        \n        // If not colliding with tiles, move the projectile\n        if(collisionOn == false) {\n            switch (direction) {\n                case \"up\": worldy -= speed; break;\n                case \"down\": worldy += speed; break;\n                case \"left\": worldx -= speed; break;\n                case \"right\": worldx += speed; break;\n            }\n        } else {\n            // If colliding with tiles, remove the projectile\n            gp.projectiles.remove(this);\n            return; // Exit the update method\n        }\n        \n        // Check player collision separately\n        boolean hitPlayer = gp.check.checkProjectile(this);\n        if (hitPlayer) {\n            // If hitting player, apply damage and remove projectile\n            gp.player.takeDamage(this.damage);\n            gp.projectiles.remove(this);\n        }\n        \n        // Check if projectile is out of bounds\n        if (worldx < 0 || worldx > gp.worldWidth || worldy < 0 || worldy > gp.worldHeight) {\n            gp.projectiles.remove(this);\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        BufferedImage image = null;\n        switch (direction) {\n            case \"up\":    image = up1; break;\n            case \"down\":  image = down1; break;\n            case \"left\":  image = left1; break;\n            case \"right\": image = right1; break;\n        }\n        int screenX = worldx - gp.player.worldx + gp.player.screenx;\n        int screenY = worldy - gp.player.worldy + gp.player.screeny;\n        g2.drawImage(image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n    }\n}"
    },
    {
      "id": "6914659",
      "Weapon.java": "\npublic class Weapon {\n\n}\n",
      "Pistol.java": "\npublic class Pistol {\n\n}\n",
      "Game.java": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.geom.Point2D;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport java.util.*;\nimport java.util.List;\nimport java.util.Timer;\nimport javax.imageio.ImageIO;\nimport java.awt.image.*;\n\npublic class Game extends JFrame implements KeyListener, MouseListener, MouseMotionListener{\n    \n    private static final long serialVersionUID = 1L;\n    // Game constants\n    private static final int WINDOW_WIDTH = 1000;\n    private static final int WINDOW_HEIGHT = 600;\n    private static final int PLAYER_SIZE = 30;\n    private static final int ZOMBIE_SIZE = 25;\n    private static final int PROJECTILE_SIZE = 5;\n    private static final int PLAYER_SPEED = 5;\n    // Game state\n    private boolean running = false;\n    private boolean paused = false;\n    private int score = 0;\n    private int currentWave = 0;\n    private long lastWaveTime = 0;\n    private long waveDelay = 5000; // wave'ler arası 5 saniye\n    // Game entities\n    private Player player;\n    private List<Zombie> zombies = new ArrayList<>();\n    private List<Projectile> projectiles = new ArrayList<>();\n    private List<Pickup> pickups = new ArrayList<>();\n    private List<Wall> walls = new ArrayList<>();\n    // UI elements\n    //private BufferedImage background;\n    private JPanel gamePanel;\n    private JMenuBar menuBar;\n    private JMenuItem pauseItem, saveItem, loadItem, exitItem;\n    private transient BufferedImage background;\n\n    // Input tracking\n    private boolean up, down, left, right;\n    private Point mousePosition = new Point(0, 0);\n    // Game timer\n    private transient Timer gameTimer;\n    private int FPS = 60;\n    //Backgorund\n    private transient BufferedImage coverImage;\n    \n    public static void main(String[] args){\n        new Game();\n    }\n\n    public Game(){\n        setTitle(\"Zombie Shooter\");\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setResizable(false);\n        try{\n            coverImage = ImageIO.read(getClass().getClassLoader().getResourceAsStream(\"background.png\"));\n        }catch(IOException e){\n            System.out.println(\"Gorsel yuklenemedi: \" + e.getMessage());\n            e.printStackTrace();\n        }\n        // Arayuz initialize ediyorum\n        createMenuBar();\n        createGamePanel();\n        addWindowFocusListener(new WindowAdapter(){\n            @Override\n            public void windowGainedFocus(WindowEvent e){\n                gamePanel.requestFocusInWindow();\n            }\n        });\n        // Oyunu initialize ediyorum\n        initializeGame();\n        pack();\n        setLocationRelativeTo(null);\n        setVisible(true);\n        // Oyun loopunu baslatiyorum\n        startGameLoop();\n    }\n\n    private void createMenuBar(){\n        menuBar = new JMenuBar();\n        JMenu gameMenu = new JMenu(\"Game\");\n        pauseItem = new JMenuItem(\"Pause\");\n        pauseItem.addActionListener(e -> togglePause());\n        saveItem = new JMenuItem(\"Save Game\");\n        saveItem.addActionListener(e -> saveGame());\n        loadItem = new JMenuItem(\"Load Game\");\n        loadItem.addActionListener(e -> loadGame());\n        exitItem = new JMenuItem(\"Exit\");\n        exitItem.addActionListener(e -> System.exit(0));\n        gameMenu.add(pauseItem);\n        gameMenu.add(saveItem);\n        gameMenu.add(loadItem);\n        gameMenu.addSeparator();\n        gameMenu.add(exitItem);\n        menuBar.add(gameMenu);\n        setJMenuBar(menuBar);\n    }\n\n    private void createGamePanel(){\n        gamePanel = new JPanel(){\n            @Override\n            protected void paintComponent(Graphics g){\n                super.paintComponent(g);\n                Graphics2D g2d = (Graphics2D) g;\n                // Oyun calismiyorsa kapak ekrani\n                if (!running){\n                    BufferedImage coverImage = null;\n                    try{\n                        coverImage = ImageIO.read(getClass().getClassLoader().getResourceAsStream(\"background.png\"));\n                    }catch(IOException e){\n                        System.out.println(\"Kapak resmi yüklenemedi: \" + e.getMessage());\n                        e.printStackTrace();\n                    }\n                    // Kapak resmi\n                    if (coverImage != null){\n                        g2d.drawImage(coverImage, 0, 0, getWidth(), getHeight(), null);\n                    } \n                    else{\n                        // Eğer fotograf yuklenmezse siyah background ve ustune hata mesaji yazacak\n                        g2d.setColor(Color.BLACK);\n                        g2d.fillRect(0, 0, getWidth(), getHeight());\n                        g2d.setColor(Color.WHITE);\n                        g2d.setFont(new Font(\"Arial\", Font.BOLD, 36));\n                        g2d.drawString(\"Kapak resmi yüklenemedi!\", getWidth() / 2 - 150, getHeight() / 2 - 20);\n                    }\n                    // Baslik ve buyruklar\n                    g2d.setColor(Color.WHITE);\n                    g2d.setFont(new Font(\"Arial\", Font.BOLD, 36));\n                    //g2d.drawString(\"ZOMBIE SHOOTER\", getWidth() / 2 - 150, getHeight() / 2 - 50);\n                    g2d.setFont(new Font(\"Arial\", Font.PLAIN, 20));\n                    //g2d.drawString(\"Press ENTER to start\", getWidth() / 2 - 100, getHeight() / 2);\n                } \n                else{\n                    // Oyun calisiyorsa background siyah\n                    g2d.setColor(Color.BLACK);\n                    g2d.fillRect(0, 0, getWidth(), getHeight());\n                    // Duvarlar\n                    for (Wall wall: walls){\n                        wall.render(g2d);\n                    }\n                    // Projeler\n                    for (Projectile p: projectiles){\n                        p.render(g2d);\n                    }\n                    // Zombiler\n                    for (Zombie z: zombies){\n                        z.render(g2d);\n                    }\n                    // Pickuplar\n                    for (Pickup pickup: pickups){\n                        pickup.render(g2d);\n                    }\n                    // Oyuncu (biz)\n                    player.render(g2d);\n                    // Arayuz elemanlari\n                    drawUI(g2d);\n                }\n            }\n        };\n        gamePanel.setPreferredSize(new Dimension(WINDOW_WIDTH, WINDOW_HEIGHT));\n        gamePanel.setFocusable(true);\n        gamePanel.addKeyListener(this);\n        gamePanel.addMouseListener(this);\n        gamePanel.addMouseMotionListener(this);\n        add(gamePanel);\n    }\n\n    private void drawUI(Graphics2D g2d){\n        // Silah bilgisi (solda)\n        g2d.setColor(Color.WHITE);\n        g2d.setFont(new Font(\"Arial\", Font.BOLD, 14));\n        Weapon currentWeapon = player.getCurrentWeapon();\n        g2d.drawString(\"Weapon: \" + currentWeapon.getName(), 20, 30);\n        g2d.drawString(\"Ammo: \" + currentWeapon.getAmmo() + \"/\" + currentWeapon.getTotalAmmo(), 20, 50);\n        // Saglik durumu ve Score\n        g2d.drawString(\"Health: \" + player.health, 800, 30); // Sag ust\n        g2d.drawString(\"Score: \" + score, 780, 60);         // Sag ustun alti\n        // Hangi level'da (wave) oldugumuzun bilgisi (orta ust)\n        g2d.drawString(\"Wave: \" + currentWave, WINDOW_WIDTH / 2 - 30, 30);\n        // Saglik durumu guncellemesi gorsel gorunum\n        g2d.setColor(Color.RED);\n        g2d.fillRect(WINDOW_WIDTH - 150, 40, 100, 10);\n        g2d.setColor(Color.GREEN);\n        g2d.fillRect(WINDOW_WIDTH - 150, 40, player.health, 10);\n        // Zombi turlerinin bilgisi \n        drawZombieKey(g2d);\n    }\n    \n    // Ustte zombilerin ikon ve isimlerini gösteren panel\n    private void drawZombieKey(Graphics2D g2d){\n        int iconSize = 20;\n        int margin = 10;\n        int startX = WINDOW_WIDTH/2 - 200; // baslangic noktasi\n        int y = 60; \n        // Normal Zombie: yesil daire\n        g2d.setColor(Color.GREEN);\n        g2d.fillOval(startX, y, iconSize, iconSize);\n        g2d.setColor(Color.WHITE);\n        g2d.drawString(\"Normal Zombie\", startX + iconSize + margin, y + iconSize - 3);\n        // Crawler (Surungen) Zombie: sari kare\n        startX += 180;\n        g2d.setColor(Color.YELLOW);\n        g2d.fillRect(startX, y, iconSize, iconSize);\n        g2d.setColor(Color.WHITE);\n        g2d.drawString(\"Crawler Zombie\", startX + iconSize + margin, y + iconSize - 3);\n        // Tank Zombie: kirmizi dortgen\n        startX += 180;\n        int centerX = startX + iconSize / 2;\n        int centerY = y + iconSize / 2;\n        Polygon diamond = new Polygon();\n        diamond.addPoint(centerX, centerY - iconSize / 2); // Ust nokta\n        diamond.addPoint(centerX + iconSize / 2, centerY); // Sag nokta\n        diamond.addPoint(centerX, centerY + iconSize / 2); // Alt nokta\n        diamond.addPoint(centerX - iconSize / 2, centerY); // Sol nokta\n        g2d.setColor(Color.RED);\n        g2d.fillPolygon(diamond);\n        g2d.setColor(Color.BLACK);\n        g2d.setStroke(new BasicStroke(2));\n        g2d.drawPolygon(diamond);\n        g2d.setColor(Color.WHITE);\n        g2d.setStroke(new BasicStroke(1));\n        g2d.drawString(\"Tank Zombie\", startX + iconSize + margin, y + iconSize - 3);\n        // Acid (Asit tukuren) Zombie: mor ucgen\n        startX += 180;\n        g2d.setColor(Color.MAGENTA);\n        int[] xPoints = {startX + iconSize/2, startX, startX + iconSize};\n        int[] yPoints = {y, y + iconSize, y + iconSize};\n        g2d.fillPolygon(xPoints, yPoints, 3);\n        g2d.setColor(Color.WHITE);\n        g2d.drawString(\"Acid Zombie\", startX + iconSize + margin, y + iconSize - 3);\n    }\n    // Duvarlarin cakismasini istemedigim icin bunun kontrolunu burada yapiyorum\n    private boolean canPlaceWall(int x, int y, int width, int height){\n        Rectangle newWallRect = new Rectangle(x, y, width, height);\n        for (Wall wall: walls){\n            Rectangle existingWallRect = new Rectangle(wall.x, wall.y, wall.width, wall.height);\n            if(newWallRect.intersects(existingWallRect)){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void initializeGame(){\n        // Oyuncu (ben) oyun ekraninin merkezinde oyuna basliyorum\n        player = new Player(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2);\n        player.addWeapon(new Pistol());\n        // Resetleme\n        zombies.clear();\n        projectiles.clear();\n        pickups.clear();\n        walls.clear();\n        score = 0;\n        currentWave = 0;\n        if(canPlaceWall(150, 50, 20, 200)){\n            walls.add(new Wall(350, 90, 20, 200));   \n        }\n        if(canPlaceWall(550, 300, 20, 200)){\n            walls.add(new Wall(550, 300, 20, 200));  \n        }\n        if(canPlaceWall(700, 100, 20, 200)){\n            walls.add(new Wall(700, 150, 20, 200));  \n        }\n        if(canPlaceWall(200, 350, 200, 20)){\n            walls.add(new Wall(200, 350, 200, 20));  \n        }\n        if(canPlaceWall(400, 500, 200, 20)){\n            walls.add(new Wall(700, 500, 200, 20));  \n        }\n        if(canPlaceWall(50, 300, 100, 20)){\n            walls.add(new Wall(50, 200, 100, 20));   \n        }\n        if(canPlaceWall(850, 50, 100, 20)){\n            walls.add(new Wall(850, 250, 100, 20));   \n        }\n        if(canPlaceWall(300, 450, 20, 100)){\n            walls.add(new Wall(300, 450, 20, 100));  \n        }\n        // Baslangicta oyun calismasin\n        running = false;\n        paused = false;\n    }\n\n    private void startGameLoop(){\n        gameTimer = new Timer();\n        gameTimer.scheduleAtFixedRate(new TimerTask(){\n            @Override\n            public void run(){\n                if(running && !paused){\n                    update();\n                }\n                gamePanel.repaint();\n            }\n        }, 0, 1000 / FPS);\n    }\n\n    private void update(){\n        // Oyuncu guncellemesi\n        player.update();\n        // Mermi guncellemesi ve carpisma kontrolu\n        for(int i = projectiles.size() - 1; i >= 0; i--){\n            Projectile p = projectiles.get(i);\n            p.update();\n            // Sinir disinda kalan mermileri yok ediyorum\n            if (p.x < 0 || p.x > WINDOW_WIDTH || p.y < 0 || p.y > WINDOW_HEIGHT){\n                projectiles.remove(i);\n                continue;\n            }\n            // Duvarlarla carpisma olup olmadığını kontrol ediyorum, carpisma varsa mermiyi cikariyorum\n            for(Wall wall: walls){\n                if(circleRectCollision(p, wall)){\n                    projectiles.remove(i);\n                    break;\n                }\n            }\n            // Zombilerle carpismayi kontrol ediyorum\n            for(int j = zombies.size() - 1; j >= 0; j--){\n                Zombie z = zombies.get(j);\n                if(checkCollision(p, z)){\n                    z.takeDamage(p.damage);\n                    // Roketatar icin special case: Patlama etkisiyle birden fazla zombiye zarar verir\n                    if(p instanceof RocketProjectile){\n                        ((RocketProjectile) p).explode(zombies);\n                        projectiles.remove(i);\n                        break;\n                    }\n                    // Keskin nisanci tufegi icin special case: Mermileri zombileri delip arasındaki zombilere de hasar verir\n                    if(!(p instanceof SniperProjectile)){\n                        projectiles.remove(i);\n                        break;\n                    }\n                }\n            }\n        }\n        // Zombileri guncelliyorum ve oyuncu carpismasini kontrol ediyorum\n        for(int i = zombies.size() - 1; i >= 0; i--){\n            Zombie z = zombies.get(i);\n            z.update();\n            // Zombinin olup olmedigini kontrol et\n            if(z.health <= 0){\n                // Asit tukuren zombinin ozel efekti\n                if(z instanceof AcidZombie){\n                    ((AcidZombie) z).splashAcid(zombies);\n                }\n                // Cephane dusurme\n                if(Math.random() < 0.15){\n                    pickups.add(new AmmoPickup(z.x, z.y));\n                }\n                zombies.remove(i);\n                score += 10 * currentWave;\n                continue;\n            }\n            // Oyuncuyla carpisma olup olmadigini kontrol ediyorum\n            if(checkCollision(player, z)){\n                player.takeDamage(z.damage);\n                // Oyuncuyu zombiden uzaklastiriyorum\n                double angle = Math.atan2(player.y - z.y, player.x - z.x);\n                player.x += Math.cos(angle) * 10;\n                player.y += Math.sin(angle) * 10;\n                // Oyuncu olunce oyun bitiyor\n                if(player.health <= 0){\n                    running = false;\n                }\n            }\n        }\n        // Pickuplari guncelliyorum ve collectionlari kontrol ediyorum\n        for(int i = pickups.size() - 1; i >= 0; i--){\n            Pickup pickup = pickups.get(i);\n            if(checkCollision(player, pickup)){\n                pickup.collect(player);\n                pickups.remove(i);\n            }\n        }\n        // Level'in (wave) bitip bitmedigini kontrol ediyorum\n        if(zombies.isEmpty()){\n            if (System.currentTimeMillis() - lastWaveTime > waveDelay){\n                startNextWave();\n            }\n        }\n    }\n    private void startNextWave() {\n        currentWave++;\n        lastWaveTime = System.currentTimeMillis();\n        // Silah ekleme kontrolleri\n        if(currentWave == 2){\n            player.addWeapon(new AssaultRifle());\n        } \n        else if(currentWave == 4){\n            player.addWeapon(new Shotgun());\n        } \n        else if(currentWave == 6){\n            player.addWeapon(new SniperRifle());\n        } \n        else if(currentWave == 11){\n            player.addWeapon(new RocketLauncher());\n        }\n        // Level'lara gore zombiler\n        if(currentWave == 1){\n            // Sadece Normal Zombi\n            int normalCount = 3; // temel sayı\n            for(int i = 0; i < normalCount; i++){\n                spawnZombieAtEdge(new NormalZombie(0, 0));\n            }\n        } \n        else if(currentWave == 2){\n            // Normal ve Surungen Zombi\n            int normalCount = 3;\n            int crawlerCount = 2;\n            for(int i = 0; i < normalCount; i++){\n                spawnZombieAtEdge(new NormalZombie(0, 0));\n            }\n            for(int i = 0; i < crawlerCount; i++){\n                spawnZombieAtEdge(new CrawlerZombie(0, 0));\n            }\n        } \n        else if(currentWave == 3){\n            // Normal, Surungen ve Tank Zombie\n            int normalCount = 3;\n            int crawlerCount = 2;\n            int tankCount = 3;\n            for(int i = 0; i < normalCount; i++){\n                spawnZombieAtEdge(new NormalZombie(0, 0));\n            }\n            for(int i = 0; i < crawlerCount; i++){\n                spawnZombieAtEdge(new CrawlerZombie(0, 0));\n            }\n            for(int i = 0; i < tankCount; i++){\n                spawnZombieAtEdge(new TankZombie(0, 0));\n            }\n        } \n        else if(currentWave >= 4){\n            // 4. Wave ve sonrasında: Normal, Surungen, Tank ve Asit Tukuren Zombi spawn ediyorum\n            // Surungen haricinde tum zombi türlerine her wavede 1'er adet ekliyorum\n            int increase = currentWave - 3; // 4. dalgada artis=1, 5. dalgada artis=2\n            int normalCount = 3 + increase;\n            int tankCount = 3 + increase;\n            int acidCount = 3 + increase;\n            int crawlerCount = 1; // sabit\n            for(int i = 0; i < normalCount; i++){\n                spawnZombieAtEdge(new NormalZombie(0, 0));\n            }\n            for(int i = 0; i < crawlerCount; i++){\n                spawnZombieAtEdge(new CrawlerZombie(0, 0));\n            }\n            for(int i = 0; i < tankCount; i++){\n                spawnZombieAtEdge(new TankZombie(0, 0));\n            }\n            for(int i = 0; i < acidCount; i++){\n                spawnZombieAtEdge(new AcidZombie(0, 0));\n            }\n        }\n    }\n    \n    /* \n    private void startNextWave(){\n        /*\n         * OYUNUN BU KISMINI SADECE KONTROL ETME AMACLI YAZDIM VE WAVELER ARASI GECİS KONTROLU ICIN\n         * OYUNDAKI ZOMBI SAYILARINI 1'E INDIREREK OYUNU KODUN BU KISMINDA KOLAYLASTIRDIM.\n         * BUNDAN DOLAYI BU KISMI COMMENT SATIRINA ALDIM.\n         *\n        /* \n        // Normal zombi\n        for(int i = 0; i < 1; i++){\n            spawnZombieAtEdge(new NormalZombie(0, 0));\n        }\n        // Surungen zombi\n        if(currentWave >= 2){\n            for(int i = 0; i < 1; i++){\n                spawnZombieAtEdge(new CrawlerZombie(0, 0));\n            }\n        }\n        // Tank zombi\n        if(currentWave >= 3){\n            for(int i = 0; i < 1; i++){\n                spawnZombieAtEdge(new TankZombie(0, 0));\n            }\n        }\n        // Asit zombi\n        if(currentWave >= 4){\n            for(int i = 0; i < 1; i++){\n                spawnZombieAtEdge(new AcidZombie(0, 0));\n            }\n        }\n    }*/\n\n    private void spawnZombieAtEdge(Zombie zombie){\n        int side = (int) (Math.random() * 4); // 0:ust, 1:sag, 2:alt, 3:sol\n        switch(side){\n            case 0: // ust\n                zombie.x = Math.random() * WINDOW_WIDTH;\n                zombie.y = -ZOMBIE_SIZE;\n                break;\n            case 1: // sag\n                zombie.x = WINDOW_WIDTH + ZOMBIE_SIZE;\n                zombie.y = Math.random() * WINDOW_HEIGHT;\n                break;\n            case 2: // alt\n                zombie.x = Math.random() * WINDOW_WIDTH;\n                zombie.y = WINDOW_HEIGHT + ZOMBIE_SIZE;\n                break;\n            case 3: // sol\n                zombie.x = -ZOMBIE_SIZE;\n                zombie.y = Math.random() * WINDOW_HEIGHT;\n                break;\n        }\n        zombies.add(zombie);\n    }\n\n    private boolean checkCollision(GameObject a, GameObject b){\n        double distance = Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n        return distance < (a.size + b.size) / 2;\n    }\n\n    // Daire ile dikdortgen carpismasini tespit ediyorum\n    private boolean circleRectCollision(GameObject circle, Wall wall){\n        double radius = circle.size / 2.0;\n        double cx = circle.x;\n        double cy = circle.y;\n        double closestX = Math.max(wall.x, Math.min(cx, wall.x + wall.width));\n        double closestY = Math.max(wall.y, Math.min(cy, wall.y + wall.height));\n        double dx = cx - closestX;\n        double dy = cy - closestY;\n        return (dx * dx + dy * dy) < (radius * radius);\n    }\n    \n    // Carpisma olunca nesneyi duvardan itiyorum\n    private void resolveCollision(GameObject circle, Wall wall){\n        double radius = circle.size / 2.0;\n        double cx = circle.x;\n        double cy = circle.y;\n        double closestX = Math.max(wall.x, Math.min(cx, wall.x + wall.width));\n        double closestY = Math.max(wall.y, Math.min(cy, wall.y + wall.height));\n        double dx = cx - closestX;\n        double dy = cy - closestY;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n        if(distance < radius && distance != 0){\n            double penetration = radius - distance;\n            circle.x += (dx / distance) * penetration;\n            circle.y += (dy / distance) * penetration;\n        } \n        else if(distance == 0){\n            circle.x += radius;\n        }\n    }\n\n    private void togglePause(){\n        paused = !paused;\n        pauseItem.setText(paused ? \"Resume\" : \"Pause\");\n    }\n\n    private void saveGame(){\n        if(!running){\n            return;\n        }\n        try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"savegame.dat\"))){\n            GameState state = new GameState();\n            state.player = player;\n            state.zombies = zombies;\n            state.projectiles = projectiles;\n            state.pickups = pickups;\n            state.score = score;\n            state.currentWave = currentWave;\n            oos.writeObject(state);\n            JOptionPane.showMessageDialog(this, \"Game saved successfully!\");\n        } \n        catch(Exception e){\n            JOptionPane.showMessageDialog(this, \"Failed to save game: \" + e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n    }\n\n    private void loadGame(){\n        try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"savegame.dat\"))){\n            GameState state = (GameState) ois.readObject();\n            player = state.player;\n            zombies = state.zombies;\n            projectiles = state.projectiles;\n            pickups = state.pickups;\n            score = state.score;\n            currentWave = state.currentWave;\n            gameTimer = new Timer();\n            startGameLoop();\n            reloadAssets();\n            running = true;\n            paused = false;\n            pauseItem.setText(\"Pause\");\n            JOptionPane.showMessageDialog(this, \"Game loaded successfully!\");\n        } \n        catch(Exception e){\n            JOptionPane.showMessageDialog(this, \"Failed to load game: \" + e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n    }\n    private void reloadAssets() {\n        try {\n            background = ImageIO.read(new File(\"background.png\"));\n            // Diğer grafik nesneleri burada tekrar yüklenir\n        } catch (IOException e) {\n            JOptionPane.showMessageDialog(this, \"Failed to load assets: \" + e.getMessage(),\n                                          \"Error\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n    }\n\n    // Kaydetme ve yukleme islerini yapiyorum\n    private static class GameState implements Serializable{\n        private static final long serialVersionUID = 1L;\n        Player player;\n        List<Zombie> zombies;\n        List<Projectile> projectiles;\n        List<Pickup> pickups;\n        int score;\n        int currentWave;\n    }\n\n    // Game objelerinin base class'i\n    private abstract class GameObject implements Serializable{\n        private static final long serialVersionUID = 1L;\n        double x, y;\n        int size;\n        Color color;\n        public GameObject(double x, double y, int size, Color color){\n            this.x = x;\n            this.y = y;\n            this.size = size;\n            this.color = color;\n        }\n        public abstract void update();\n        public void render(Graphics2D g){\n            g.setColor(color);\n            g.fillOval((int)(x - size/2), (int)(y - size/2), size, size);\n        }\n    }\n\n    // Duvar\n    private class Wall implements Serializable{\n        private static final long serialVersionUID = 1L;\n        int x, y, width, height;\n        public Wall(int x, int y, int width, int height){\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.height = height;\n        }\n        public void render(Graphics2D g){\n            g.setColor(Color.LIGHT_GRAY);\n            g.fillRect(x, y, width, height);\n        }\n    }\n\n    private class Player extends GameObject{\n        private static final long serialVersionUID = 1L;\n        private int health = 100;\n        private List<Weapon> weapons = new ArrayList<>();\n        private int currentWeaponIndex = 0;\n        private double angle = 0;\n        public Player(double x, double y){\n            super(x, y, PLAYER_SIZE, Color.BLUE);\n        }\n        public void addWeapon(Weapon weapon){\n            weapons.add(weapon);\n        }\n        public Weapon getCurrentWeapon(){\n            return weapons.get(currentWeaponIndex);\n        }\n        public void switchWeapon(int index){\n            if(index >= 0 && index < weapons.size()){\n                currentWeaponIndex = index;\n            }\n        }\n        public void nextWeapon(){\n            currentWeaponIndex = (currentWeaponIndex + 1) % weapons.size();\n        }\n        public void previousWeapon(){\n            currentWeaponIndex = (currentWeaponIndex - 1 + weapons.size()) % weapons.size();\n        }\n        public void shoot(){\n            getCurrentWeapon().shoot(x, y, angle);\n        }\n        public void reload(){\n            getCurrentWeapon().reload();\n        }\n        public void takeDamage(int amount){\n            health -= amount;\n            if (health < 0) health = 0;\n        }\n        @Override\n        public void update(){\n            double oldX = x, oldY = y;\n            double dx = 0, dy = 0;\n            if (up) dy -= PLAYER_SPEED;\n            if (down) dy += PLAYER_SPEED;\n            if (left) dx -= PLAYER_SPEED;\n            if (right) dx += PLAYER_SPEED;\n            // Capraz hareket\n            if(dx != 0 && dy != 0){\n                double factor = PLAYER_SPEED / Math.sqrt(dx * dx + dy * dy);\n                dx *= factor;\n                dy *= factor;\n            }\n            x += dx;\n            y += dy;\n            // Oyuncuyu sinirlar icinde tutuyorum\n            if(x < size/2){\n                x = size/2;\n            } \n            if(x > WINDOW_WIDTH - size/2){\n                x = WINDOW_WIDTH - size/2;\n            } \n            if(y < size/2){\n                y = size/2;\n            } \n            if(y > WINDOW_HEIGHT - size/2){\n                y = WINDOW_HEIGHT - size/2;\n            } \n            // Duvara carpinca geri don\n            for (Wall wall: walls){\n                if (circleRectCollision(this, wall)){\n                    x = oldX;\n                    y = oldY;\n                    break;\n                }\n            }\n            // Aciyi mouse'un konumuna gore guncelliyorum\n            double dx2 = mousePosition.x - x;\n            double dy2 = mousePosition.y - y;\n            angle = Math.atan2(dy2, dx2);\n        }\n        @Override\n        public void render(Graphics2D g){\n            // Oyuncuyu ciziyorum\n            g.setColor(color);\n            g.fillOval((int)(x - size/2), (int)(y - size/2), size, size);\n            // Silahin yonu\n            int gunLength = size/2 + 10;\n            int endX = (int)(x + Math.cos(angle) * gunLength);\n            int endY = (int)(y + Math.sin(angle) * gunLength);\n            g.setColor(Color.DARK_GRAY);\n            g.setStroke(new BasicStroke(3));\n            g.drawLine((int)x, (int)y, endX, endY);\n        }\n    }\n\n    private abstract class Zombie extends GameObject{\n        private static final long serialVersionUID = 1L;\n        protected int health;\n        protected int damage;\n        protected double speed;\n        protected long lastAttackTime = 0;\n        protected int attackCooldown = 1000; // 1 saniye\n        public Zombie(double x, double y, int size, Color color, int health, int damage, double speed){\n            super(x, y, size, color);\n            this.health = health;\n            this.damage = damage;\n            this.speed = speed;\n        }\n        public void takeDamage(int amount){\n            health -= amount;\n        }\n        @Override\n        public void update(){\n            double dx = player.x - x;\n            double dy = player.y - y;\n            double distance = Math.sqrt(dx * dx + dy * dy);\n            if(distance > 0){\n                dx = dx / distance * speed;\n                dy = dy / distance * speed;\n                x += dx;\n                y += dy;\n            }\n            // Carpisma durumu\n            for(Wall wall: walls){\n                if(circleRectCollision(this, wall)){\n                    resolveCollision(this, wall);\n                }\n            }\n        }\n        // Varsayılan render() => yuvarlak (NormalZombie)\n    }\n\n    // Normal Zombie: yesil daire (default durum)  \n    private class NormalZombie extends Zombie{\n        private static final long serialVersionUID = 1L;\n        public NormalZombie(double x, double y){\n            super(x, y, ZOMBIE_SIZE, Color.GREEN, 30, 10, 1.0);\n        }\n    }\n\n    // Crawler (Surungen) Zombie: sari kare \n    private class CrawlerZombie extends Zombie {\n        private static final long serialVersionUID = 1L;\n        private boolean isJumping = false;\n        private double jumpTime = 0;\n        public CrawlerZombie(double x, double y){\n            super(x, y, ZOMBIE_SIZE - 5, Color.YELLOW, 15, 8, 2.0);\n        }\n        @Override\n        public void update(){\n            double dx = player.x - x;\n            double dy = player.y - y;\n            double distance = Math.sqrt(dx * dx + dy * dy);\n            if(distance < 150 && !isJumping){\n                isJumping = true;\n                jumpTime = 0;\n            }\n            if(isJumping){\n                jumpTime += 0.05;\n                if(jumpTime < 1.0){\n                    dx = dx / distance * (speed * 2);\n                    dy = dy / distance * (speed * 2);\n                    x += dx;\n                    y += dy;\n                } \n                else{\n                    isJumping = false;\n                }\n            } \n            else{\n                double ddx = player.x - x;\n                double ddy = player.y - y;\n                double dDistance = Math.sqrt(ddx * ddx + ddy * ddy);\n                if(dDistance > 0){\n                    ddx = ddx / dDistance * speed;\n                    ddy = ddy / dDistance * speed;\n                    x += ddx;\n                    y += ddy;\n                }\n            }\n            for(Wall wall: walls){\n                if(circleRectCollision(this, wall)){\n                    resolveCollision(this, wall);\n                }\n            }\n        }\n        // Kare\n        @Override\n        public void render(Graphics2D g){\n            g.setColor(color);\n            int drawX = (int)(x - size/2);\n            int drawY = (int)(y - size/2);\n            g.fillRect(drawX, drawY, size, size);\n        }\n    }\n\n    // Tank Zombie: kirmizi dortgen\n    private class TankZombie extends Zombie{\n        private static final long serialVersionUID = 1L;\n        public TankZombie(double x, double y){\n            super(x, y, ZOMBIE_SIZE + 10, Color.RED, 100, 20, 0.5);\n        }\n        @Override\n        public void render(Graphics2D g){\n            // Icini dolduruyorum \n            g.setColor(color);\n            g.fillOval((int)(x - size/2), (int)(y - size/2), size, size);\n            // Kalin siyah border\n            g.setColor(Color.BLACK);\n            g.setStroke(new BasicStroke(3));\n            g.drawOval((int)(x - size/2), (int)(y - size/2), size, size);\n            g.setStroke(new BasicStroke(1));\n        }\n    }\n\n    // Acid (asit tukuren) Zombie: mor ucgen\n    private class AcidZombie extends Zombie{\n        private static final long serialVersionUID = 1L;\n        private long lastSpitTime = 0;\n        private int spitCooldown = 3000; // 3 seconds\n        public AcidZombie(double x, double y){\n            super(x, y, ZOMBIE_SIZE, Color.MAGENTA, 20, 8, 0.7);\n        }\n        @Override\n        public void update(){\n            super.update();\n            double distance = Math.sqrt(Math.pow(player.x - x, 2) + Math.pow(player.y - y, 2));\n            if(distance < 200 && System.currentTimeMillis() - lastSpitTime > spitCooldown){\n                double angle = Math.atan2(player.y - y, player.x - x);\n                projectiles.add(new AcidProjectile(x, y, angle));\n                lastSpitTime = System.currentTimeMillis();\n            }\n        }\n        // Ucgen\n        @Override\n        public void render(Graphics2D g){\n            g.setColor(color);\n            int halfSize = size / 2;\n            int[] xPoints = {(int)x, (int)(x - halfSize), (int)(x + halfSize)};\n            int[] yPoints = {(int)(y - halfSize), (int)(y + halfSize), (int)(y + halfSize)};\n            g.fillPolygon(xPoints, yPoints, 3);\n        }\n        public void splashAcid(List<Zombie> zombies){\n            for(Zombie z : zombies){\n                if(z != this){\n                    double distance = Math.sqrt(Math.pow(z.x - x, 2) + Math.pow(z.y - y, 2));\n                    if(distance < 100){\n                        z.takeDamage(15);\n                    }\n                }\n            }\n        }\n    }\n\n    private abstract class Projectile extends GameObject{\n        private static final long serialVersionUID = 1L;\n        protected double vx, vy;\n        protected int damage;\n        public Projectile(double x, double y, double angle, double speed, int damage, int size, Color color){\n            super(x, y, size, color);\n            this.vx = Math.cos(angle) * speed;\n            this.vy = Math.sin(angle) * speed;\n            this.damage = damage;\n        }\n        @Override\n        public void update(){\n            x += vx;\n            y += vy;\n        }\n    }\n\n    private class BulletProjectile extends Projectile{\n        private static final long serialVersionUID = 1L;\n        public BulletProjectile(double x, double y, double angle, int damage){\n            super(x, y, angle, 10.0, damage, PROJECTILE_SIZE, Color.YELLOW);\n        }\n    }\n\n    private class ShotgunProjectile extends Projectile{\n        private static final long serialVersionUID = 1L;\n        public ShotgunProjectile(double x, double y, double angle, int damage){\n            super(x, y, angle, 8.0, damage, PROJECTILE_SIZE, Color.ORANGE);\n        }\n    }\n\n    private class SniperProjectile extends Projectile{\n        private static final long serialVersionUID = 1L;\n        public SniperProjectile(double x, double y, double angle, int damage){\n            super(x, y, angle, 15.0, damage, PROJECTILE_SIZE, Color.RED);\n        }\n    }\n\n    private class RocketProjectile extends Projectile{\n        private static final long serialVersionUID = 1L;\n        public RocketProjectile(double x, double y, double angle, int damage){\n            super(x, y, angle, 5.0, damage, PROJECTILE_SIZE * 2, Color.GRAY);\n        }\n        public void explode(List<Zombie> zombies){\n            for(Zombie z : zombies){\n                double distance = Math.sqrt(Math.pow(z.x - x, 2) + Math.pow(z.y - y, 2));\n                if(distance < 100){\n                    int explosionDamage = (int)(damage * (1 - distance / 100));\n                    z.takeDamage(explosionDamage);\n                }\n            }\n        }\n        @Override\n        public void render(Graphics2D g){\n            g.setColor(color);\n            g.fillOval((int)(x - size/2), (int)(y - size/2), size, size);\n            g.setColor(Color.ORANGE);\n            g.fillOval((int)(x - vx - size/4), (int)(y - vy - size/4), size/2, size/2);\n        }\n    }\n\n    private class AcidProjectile extends Projectile{\n        private static final long serialVersionUID = 1L;\n        public AcidProjectile(double x, double y, double angle){\n            super(x, y, angle, 3.0, 5, PROJECTILE_SIZE, Color.GREEN);\n        }\n    }\n\n    private interface Weapon extends Serializable{\n        void shoot(double x, double y, double angle);\n        void reload();\n        int getAmmo();\n        int getMaxAmmo();\n        int getTotalAmmo();\n        String getName();\n    }\n\n    private abstract class AbstractWeapon implements Weapon{\n        private static final long serialVersionUID = 1L;\n        protected int ammo;\n        protected int maxAmmo;\n        protected int totalAmmo;\n        protected int damage;\n        protected long lastShotTime = 0;\n        protected int fireRate; \n        public AbstractWeapon(int maxAmmo, int totalAmmo, int damage, int fireRate){\n            this.maxAmmo = maxAmmo;\n            this.ammo = maxAmmo;\n            this.totalAmmo = totalAmmo;\n            this.damage = damage;\n            this.fireRate = fireRate;\n        }\n        @Override\n        public void reload(){\n            if (totalAmmo > 0){\n                int ammoNeeded = maxAmmo - ammo;\n                int ammoToAdd = Math.min(ammoNeeded, totalAmmo);\n                ammo += ammoToAdd;\n                totalAmmo -= ammoToAdd;\n            }\n        }\n        @Override\n        public int getAmmo(){\n            return ammo;\n        }\n        @Override\n        public int getMaxAmmo(){\n            return maxAmmo;\n        }\n        @Override\n        public int getTotalAmmo(){\n            return totalAmmo;\n        }\n        protected boolean canShoot(){\n            return ammo > 0 && System.currentTimeMillis() - lastShotTime > fireRate;\n        }\n    }\n\n    private class Pistol extends AbstractWeapon{\n        private static final long serialVersionUID = 1L;\n        public Pistol(){\n            super(12, 60, 15, 400);\n        }\n        @Override\n        public void shoot(double x, double y, double angle){\n            if(canShoot()){\n                projectiles.add(new BulletProjectile(x, y, angle, damage));\n                ammo--;\n                lastShotTime = System.currentTimeMillis();\n            }\n        }\n\n        @Override\n        public String getName(){\n            return \"Pistol\";\n        }\n    }\n\n    private class AssaultRifle extends AbstractWeapon{\n        private static final long serialVersionUID = 1L;\n        public AssaultRifle(){\n            super(30, 120, 10, 100);\n        }\n        @Override\n        public void shoot(double x, double y, double angle){\n            if(canShoot()){\n                double spread = Math.toRadians((Math.random() - 0.5) * 30); // -15° ile +15° arası sapma\n                projectiles.add(new BulletProjectile(x, y, angle + spread, damage));\n                ammo--;\n                lastShotTime = System.currentTimeMillis();\n            }\n        }\n        @Override\n        public String getName(){\n            return \"Assault Rifle\";\n        }\n    }\n\n    private class Shotgun extends AbstractWeapon{\n        private static final long serialVersionUID = 1L;\n        public Shotgun(){\n            super(8, 32, 8, 700);\n        }\n        @Override\n        public void shoot(double x, double y, double mainAngle){\n            if(canShoot()){\n                int pelletCount = 9;\n                double totalSpread = Math.toRadians(45); // 45 derece aci\n                // Ilk aci: Yay araliginin yarisini sola cekiyorum\n                double startAngle = mainAngle - totalSpread / 2;\n                double angleIncrement = totalSpread / (pelletCount - 1);\n                for(int i = 0; i < pelletCount; i++){\n                    double pelletAngle = startAngle + i * angleIncrement;\n                    projectiles.add(new ShotgunProjectile(x, y, pelletAngle, damage));\n                }\n                ammo--;\n                lastShotTime = System.currentTimeMillis();\n            }\n        }\n        @Override\n        public String getName(){\n            return \"Shotgun\";\n        }\n    }\n\n    private class SniperRifle extends AbstractWeapon{\n        private static final long serialVersionUID = 1L;\n        public SniperRifle(){\n            super(5, 20, 50, 1200);\n        }\n        @Override\n        public void shoot(double x, double y, double angle){\n            if(canShoot()){\n                projectiles.add(new SniperProjectile(x, y, angle, damage));\n                ammo--;\n                lastShotTime = System.currentTimeMillis();\n            }\n        }\n        @Override\n        public String getName(){\n            return \"Sniper Rifle\";\n        }\n    }\n\n    private class RocketLauncher extends AbstractWeapon{\n        private static final long serialVersionUID = 1L;\n        public RocketLauncher(){\n            super(1, 5, 100, 2000);\n        }\n        @Override\n        public void shoot(double x, double y, double angle) {\n            if(canShoot()){\n                projectiles.add(new RocketProjectile(x, y, angle, damage));\n                ammo--;\n                lastShotTime = System.currentTimeMillis();\n            }\n        }\n        @Override\n        public String getName(){\n            return \"Rocket Launcher\";\n        }\n    }\n\n    private abstract class Pickup extends GameObject{\n        private static final long serialVersionUID = 1L;\n        public Pickup(double x, double y, int size, Color color){\n            super(x, y, size, color);\n        }\n        public abstract void collect(Player player);\n        @Override\n        public void update(){\n            // Pickuplar hareket etmeyecek\n        }\n    }\n\n    private class AmmoPickup extends Pickup{\n        private static final long serialVersionUID = 1L;\n        public AmmoPickup(double x, double y){\n            super(x, y, 15, Color.ORANGE);\n        }\n        @Override\n        public void collect(Player player){\n            Weapon weapon = player.getCurrentWeapon();\n            ((AbstractWeapon)weapon).totalAmmo += weapon.getMaxAmmo();\n        }\n        @Override\n        public void render(Graphics2D g){\n            g.setColor(color);\n            g.fillRect((int)(x - size/2), (int)(y - size/2), size, size);\n            g.setColor(Color.BLACK);\n            g.drawString(\"A\", (int)x - 3, (int)y + 3);\n        }\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e){\n        switch(e.getKeyCode()){\n            case KeyEvent.VK_W:\n                up = true;\n                break;\n            case KeyEvent.VK_S:\n                down = true;\n                break;\n            case KeyEvent.VK_A:\n                left = true;\n                break;\n            case KeyEvent.VK_D:\n                right = true;\n                break;\n            case KeyEvent.VK_R:\n                if(running && !paused){\n                    player.reload();\n                }\n                break;\n            case KeyEvent.VK_1:\n            case KeyEvent.VK_2:\n            case KeyEvent.VK_3:\n            case KeyEvent.VK_4:\n            case KeyEvent.VK_5:\n                if(running && !paused){\n                    int index = e.getKeyCode() - KeyEvent.VK_1;\n                    player.switchWeapon(index);\n                }\n                break;\n            case KeyEvent.VK_ESCAPE:\n                if(running){\n                    togglePause();\n                }\n                break;\n            case KeyEvent.VK_ENTER:\n                if(!running){\n                    initializeGame();\n                    running = true;\n                    startNextWave();\n                }\n                break;\n            case KeyEvent.VK_K:\n                if(running && !paused){\n                    saveGame();\n                }\n                break;\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e){\n        switch(e.getKeyCode()){\n            case KeyEvent.VK_W:\n                up = false;\n                break;\n            case KeyEvent.VK_S:\n                down = false;\n                break;\n            case KeyEvent.VK_A:\n                left = false;\n                break;\n            case KeyEvent.VK_D:\n                right = false;\n                break;\n        }\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e){\n        // Kullanmiyorum\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e){\n        if(running && !paused && e.getButton() == MouseEvent.BUTTON1){\n            player.shoot();\n        }\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e){\n        // Kullanmiyorum\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e){\n        // Kullanmiyorum\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e){\n        // Kullanmiyorum\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e){\n        // Kullanmiyorum\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e){\n        mousePosition.x = e.getX();\n        mousePosition.y = e.getY();\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e){\n        mousePosition.x = e.getX();\n        mousePosition.y = e.getY();\n        // Surukleme\n        if (running && !paused && SwingUtilities.isLeftMouseButton(e)) {\n            player.shoot();\n        }\n    }\n}"
    },
    {
      "id": "8862077",
      "WaveManager.java": "import java.util.Random;\n\npublic class WaveManager {\n\n    private int currentWave = 1;\n    private final int maxWaves = 12;\n    private Handler handler;\n    private Soldier player;\n    private TileManager tileManager;\n    private Random rand = new Random();\n\n    public WaveManager(Handler handler, Soldier player, TileManager tileManager) {\n        this.handler = handler;\n        this.player = player;\n        this.tileManager = tileManager;\n    }\n\n    public void spawnWave() {\n        int zombiesToSpawn = currentWave;\n\n        if (currentWave == maxWaves && Game.difficulty.equals(\"TEST\")) {\n            spawnZombieOfEachType();\n            return;\n        }\n\n        for (int i = 0; i < zombiesToSpawn; i++) {\n            Zombie z = createRandomZombie();\n            placeZombieSafe(z);\n        }\n\n        System.out.println(\"[WaveManager] \" + currentWave + \". dalga başlatıldı.\");\n    }\n\n    private void spawnZombieOfEachType() {\n        Zombie[] zombies = {\n            new NormalZombie(0, 0),\n            new CrawlerZombie(0, 0),\n            new TankZombie(0, 0),\n            new AcidZombie(0, 0, handler)\n        };\n\n        for (Zombie z : zombies) {\n            placeZombieSafe(z);\n        }\n    }\n\n    private Zombie createRandomZombie() {\n        int type = rand.nextInt(4);\n        switch (type) {\n            case 0: return new NormalZombie(0, 0);\n            case 1: return new CrawlerZombie(0, 0);\n            case 2: return new TankZombie(0, 0);\n            case 3: return new AcidZombie(0, 0, handler);\n        }\n        return new NormalZombie(0, 0); // fallback\n    }\n\n    private void placeZombieSafe(Zombie z) {\n        int attempts = 0;\n        int maxAttempts = 100;\n        boolean placed = false;\n\n        while (!placed && attempts < maxAttempts) {\n            int x = rand.nextInt(800 - 32);\n            int y = rand.nextInt(600 - 32);\n\n            if (!tileManager.isBlocked(x, y)) {\n                z.setX(x);\n                z.setY(y);\n                handler.addObject(z);\n                placed = true;\n            }\n            attempts++;\n        }\n\n        if (!placed) {\n            z.setX(50);\n            z.setY(50);\n            handler.addObject(z);\n        }\n    }\n\n    public int getCurrentWave() {\n        return currentWave;\n    }\n\n    public void nextWave() {\n        if (currentWave < maxWaves) {\n            currentWave++;\n            spawnWave();\n        }\n    }\n}\n",
      "Zombie.java": "\n\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic abstract class Zombie extends GameObject {\n\n    protected int health;\n    protected int speed;\n    protected int damage;\n\n    public Zombie(int x, int y, int health, int speed, int damage) {\n        super(x, y);\n        this.health = health;\n        this.speed = speed;\n        this.damage = damage;\n    }\n\n    public void tick(Soldier player, TileManager tileManager) {\n        int dx = player.getX() - x;\n        int dy = player.getY() - y;\n\n        int moveX = Integer.signum(dx) * speed;\n        int moveY = Integer.signum(dy) * speed;\n\n        if (!tileManager.isBlocked(x + moveX, y)) {\n            x += moveX;\n        }\n\n        if (!tileManager.isBlocked(x, y + moveY)) {\n            y += moveY;\n        }\n    }\n\n    public abstract void render(Graphics g);\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 32, 32);\n    }\n\n    public void takeDamage(int amount) {\n        health -= amount;\n    }\n\n    public boolean isDead() {\n        return health <= 0;\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n}\n",
      "SMG.java": "\n\npublic class SMG extends Weapon {\n\n    public SMG() {\n        super(\"SMG\", 30, 5, 800);\n    }\n\n    @Override\n    public void fire(int x, int y, Handler handler, double angle) {\n        if (canFire()) {\n            handler.addObject(new Bullet(x, y, angle, damage));\n            currentAmmo--;\n            lastFired = System.currentTimeMillis();\n        }\n    }\n}\n",
      "AcidZombie.java": "\n\nimport java.awt.Color;\nimport java.awt.Graphics;\n\npublic class AcidZombie extends Zombie {\n\n    private long lastSpitTime = 0;\n    private final long spitCooldown = 3000; \n    private final int spitRange = 150;\n\n    private Handler handler;\n\n    public AcidZombie(int x, int y, Handler handler) {\n        super(x, y, 90, 1, 10); \n        this.handler = handler;\n    }\n\n    @Override\n    public void tick(Soldier player, TileManager tileManager) {\n        int dx = player.getX() - x;\n        int dy = player.getY() - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance <= spitRange) {\n            long now = System.currentTimeMillis();\n            if (now - lastSpitTime >= spitCooldown) {\n                player.takeDamage(damage); \n                lastSpitTime = now;\n            }\n        } else {\n            \n            if (distance != 0) {\n                int moveX = (int) (speed * dx / distance);\n                int moveY = (int) (speed * dy / distance);\n\n                if (!tileManager.isBlocked(x + moveX, y)) {\n                    x += moveX;\n                }\n\n                if (!tileManager.isBlocked(x, y + moveY)) {\n                    y += moveY;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void tick() {\n        \n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(Color.GREEN);\n        g.fillRect(x, y, 32, 32);\n    }\n}\n",
      "Weapon.java": "\npublic abstract class Weapon {\n    protected String name;\n    protected int currentAmmo;\n    protected int totalAmmo;\n    protected int damage;\n    protected long reloadTime;\n    protected long reloadStart = 0;\n    protected boolean reloading = false;\n    protected long lastFired = 0;\n\n    public Weapon(String name, int magazineSize, int damage, long reloadTime) {\n        this.name = name;\n        this.currentAmmo = magazineSize;\n        this.totalAmmo = magazineSize * 3;\n        this.damage = damage;\n        this.reloadTime = reloadTime;\n    }\n    public void setCurrentAmmo(int ammo) {\n        this.currentAmmo = ammo;\n    }\n\n    public void setTotalAmmo(int ammo) {\n        this.totalAmmo = ammo;\n    }\n\n    \n\n    public boolean canFire() {\n        return !reloading && currentAmmo > 0;\n    }\n\n    public void startReload() {\n        if (!reloading && currentAmmo < totalAmmo) {\n            reloading = true;\n            reloadStart = System.currentTimeMillis();\n        }\n    }\n\n    public void tickReload() {\n        if (reloading) {\n            long now = System.currentTimeMillis();\n            if (now - reloadStart >= reloadTime) {\n                int needed = totalAmmo - currentAmmo;\n                currentAmmo += Math.min(needed, totalAmmo);\n                reloading = false;\n            }\n        }\n    }\n\n    public double getReloadProgress() {\n        if (!reloading) return 0;\n        return (double) (System.currentTimeMillis() - reloadStart) / reloadTime;\n    }\n\n    public boolean isReloading() {\n        return reloading;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getCurrentAmmo() {\n        return currentAmmo;\n    }\n\n    public int getTotalAmmo() {\n        return totalAmmo;\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public abstract void fire(int x, int y, Handler handler, double angle);\n\n}\n",
      "Bullet.java": "\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Bullet extends GameObject {\n\n    private double angle;\n    private double speed = 10.0;\n    private int damage;\n\n    public Bullet(int x, int y, double angle, int damage) {\n        super(x, y);\n        this.angle = angle;\n        this.damage = damage;\n    }\n\n    public void tick() {\n        x += (int)(speed * Math.cos(Math.toRadians(angle)));\n        y += (int)(speed * Math.sin(Math.toRadians(angle)));\n    }\n\n    public void render(Graphics g) {\n        g.setColor(Color.YELLOW);\n        g.fillOval(x, y, 6, 6);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 6, 6);\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n}\n",
      "Tile.java": "\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class Tile {\n    private int x, y;\n    private BufferedImage image;\n    private boolean solid;\n\n    public Tile(int x, int y, BufferedImage image, boolean solid) {\n        this.x = x;\n        this.y = y;\n        this.image = image;\n        this.solid = solid;\n    }\n\n    public void render(Graphics g) {\n        g.drawImage(image, x, y, null);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 32, 32);\n    }\n\n    public boolean isSolid() {\n        return solid;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n}\n",
      "Shotgun.java": "\npublic class Shotgun extends Weapon {\n\n    public Shotgun() {\n        super(\"Shotgun\", 5, 25, 1500);\n    }\n\n    @Override\n    public void fire(int x, int y, Handler handler, double angle) {\n        if (canFire()) {\n            for (int i = -1; i <= 1; i++) {\n                handler.addObject(new Bullet(x, y, angle + i * 10, damage));\n            }\n            currentAmmo--;\n            lastFired = System.currentTimeMillis();\n        }\n    }\n}\n",
      "NormalZombie.java": "\n\nimport java.awt.Color;\nimport java.awt.Graphics;\n\npublic class NormalZombie extends Zombie {\n\n    public NormalZombie(int x, int y) {\n        super(x, y, 100, 1, 10); \n    }\n\n    @Override\n    public void tick(Soldier player, TileManager tileManager) {\n        int dx = player.getX() - x;\n        int dy = player.getY() - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n       \n\n        if (distance != 0) {\n            int moveX = (int) (speed * dx / distance);\n            int moveY = (int) (speed * dy / distance);\n\n            if (!tileManager.isBlocked(x + moveX, y)) {\n                x += moveX;\n            }\n\n            if (!tileManager.isBlocked(x, y + moveY)) {\n                y += moveY;\n            }\n        }\n    }\n    @Override\n    public void tick() {}\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(Color.GREEN);\n        g.fillRect(x, y, 32, 32);\n    }\n}\n",
      "KeyInput.java": "\n\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\npublic class KeyInput extends KeyAdapter {\n    private Handler handler;\n    private Game game;\n\n    public KeyInput(Handler handler, Game game) {\n        this.handler = handler;\n        this.game = game;\n    }\n\n    public void keyPressed(KeyEvent e) {\n        int key = e.getKeyCode();\n\n        if (key == KeyEvent.VK_ESCAPE) {\n            if (game.getGameState() == Game.GameState.GAME) {\n                game.setGameState(Game.GameState.PAUSED);\n            } else if (game.getGameState() == Game.GameState.PAUSED) {\n                game.setGameState(Game.GameState.GAME);\n            }\n        }\n        \n        if (key == KeyEvent.VK_M && game.getGameState() == Game.GameState.GAME) {\n            game.manualSave();\n        }\n\n    }\n\n    public void keyReleased(KeyEvent e) {\n     \n    }\n}\n",
      "Rocket.java": "\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Rocket extends GameObject {\n\n    private double angle;\n    private double speed = 6.0;\n    private int damage;\n\n    public Rocket(int x, int y, double angle, int damage) {\n        super(x, y);\n        this.angle = angle;\n        this.damage = damage;\n    }\n\n    public void tick() {\n        x += (int)(speed * Math.cos(Math.toRadians(angle)));\n        y += (int)(speed * Math.sin(Math.toRadians(angle)));\n    }\n\n    public void render(Graphics g) {\n        g.setColor(Color.ORANGE);\n        g.fillRect(x, y, 8, 8);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 8, 8);\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n}\n",
      "Soldier.java": "\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Soldier extends GameObject {\n\n    private int health = 100;\n    private int score = 0;\n    private Weapon currentWeapon;\n\n    public Soldier(int x, int y, Weapon weapon) {\n        super(x, y);\n        this.currentWeapon = weapon;\n    }\n\n    \n    @Override\n    public void tick() {    }\n\n    public void tick(TileManager tileManager) {\n        int nextX = x + velX;\n        int nextY = y + velY;\n\n        if (!tileManager.isBlocked(nextX, y)) {\n            x = nextX;\n        }\n        if (!tileManager.isBlocked(x, nextY)) {\n            y = nextY;\n        }\n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(Color.BLUE);\n        g.fillRect(x, y, 32, 32);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 32, 32);\n    }\n\n    public Weapon getCurrentWeapon() {\n        return currentWeapon;\n    }\n\n    public void setCurrentWeapon(Weapon weapon) {\n        this.currentWeapon = weapon;\n    }\n\n    public void takeDamage(int amount) {\n        health -= amount;\n        if (health < 0) health = 0;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public int getScore() {\n        return score;\n    }\n\n    public void addScore(int s) {\n        this.score += s;\n    }\n\n    public void setHealth(int health) {\n        this.health = health;\n    }\n\n    public void setScore(int score) {\n        this.score = score;\n    }\n}\n",
      "Pistol.java": "\n\npublic class Pistol extends Weapon {\n\n    public Pistol() {\n        super(\"Pistol\", 10, 10, 1000); \n    }\n\n    @Override\n    public void fire(int x, int y, Handler handler, double angle) {\n        if (canFire()) {\n            handler.addObject(new Bullet(x, y, angle, damage));\n            currentAmmo--;\n            lastFired = System.currentTimeMillis();\n        }\n    }\n}\n",
      "Handler.java": "\n\nimport java.awt.Graphics;\nimport java.util.LinkedList;\n\npublic class Handler {\n    public LinkedList<GameObject> objects = new LinkedList<>();\n    private Soldier player;\n\n    public void setPlayer(Soldier player) {\n        this.player = player;\n    }\n\n    public void tick() {\n        for (GameObject obj : objects) {\n            obj.tick();\n        }\n    }\n\n    public void render(Graphics g) {\n        for (GameObject obj : objects) {\n            obj.render(g);\n        }\n    }\n\n    public void addObject(GameObject obj) {\n        objects.add(obj);\n    }\n\n    public void removeObject(GameObject obj) {\n        objects.remove(obj);\n    }\n\n    public Soldier getPlayer() {\n        for (GameObject obj : objects) {\n            if (obj instanceof Soldier) {\n                return (Soldier) obj;\n            }\n        }\n        return null;\n    }\n}\n",
      "CrawlerZombie.java": "\n\nimport java.awt.Color;\nimport java.awt.Graphics;\n\npublic class CrawlerZombie extends Zombie {\n\n    public CrawlerZombie(int x, int y) {\n        super(x, y, 70, 1, 5);\n    }\n\n    @Override\n    public void tick(Soldier player, TileManager tileManager) {\n        int dx = player.getX() - x;\n        int dy = player.getY() - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance != 0) {\n            int moveX = (int) (speed * dx / distance);\n            int moveY = (int) (speed * dy / distance);\n\n            if (!tileManager.isBlocked(x + moveX, y)) {\n                x += moveX;\n            }\n\n            if (!tileManager.isBlocked(x, y + moveY)) {\n                y += moveY;\n            }\n        }\n    }\n    @Override\n    public void tick() {}\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(Color.ORANGE);\n        g.fillRect(x, y, 32, 32);\n    }\n}\n",
      "TankZombie.java": "\n\nimport java.awt.Color;\nimport java.awt.Graphics;\n\npublic class TankZombie extends Zombie {\n\n    public TankZombie(int x, int y) {\n        super(x, y, 200, 1, 20);\n    }\n\n    @Override\n    public void tick(Soldier player, TileManager tileManager) {\n        int dx = player.getX() - x;\n        int dy = player.getY() - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance != 0) {\n            int moveX = (int) (speed * dx / distance);\n            int moveY = (int) (speed * dy / distance);\n\n            if (!tileManager.isBlocked(x + moveX, y)) {\n                x += moveX;\n            }\n\n            if (!tileManager.isBlocked(x, y + moveY)) {\n                y += moveY;\n            }\n        }\n    }\n    @Override\n    public void tick() {}\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(Color.RED);\n        g.fillRect(x, y, 32, 32);\n    }\n}\n",
      "BufferedImageLoader.java": "\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class BufferedImageLoader {\n\n    private BufferedImage image;\n\n    public BufferedImage loadImage(String path) {\n        try {\n            image = ImageIO.read(getClass().getResource(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return image;\n    }\n}\n",
      "Game.java": "\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.image.BufferStrategy;\nimport java.io.*;\n\npublic class Game extends Canvas implements Runnable {\n    public enum GameState { MENU, GAME, PAUSED }\n\n    private GameState state = GameState.MENU;\n    private Handler handler;\n    private boolean running = false;\n    private Thread thread;\n    private int currentWave = 1;\n    private TileManager tileManager;\n    private String waveMessage = \"\";\n    private long waveMessageTimer = 0;\n\n    private long lastAutoSaveTime = 0;\n    private final long AUTO_SAVE_INTERVAL = 90000; \n    public synchronized void start() {\n        if (running) return;\n        running = true;\n        thread = new Thread(this);\n        thread.start();\n    }\n\n    public synchronized void stop() {\n        if (!running) return;\n        running = false;\n        try {\n            thread.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    public static String difficulty = \"NORMAL\";\n\n    public static void setDifficulty(String diff) {\n        difficulty = diff;\n    }\n    public Game() {\n        handler = new Handler();\n        new Window(800, 600, \"Top-Down Shooter\", this);\n        this.addKeyListener(new KeyInput(handler, this));\n        this.addMouseListener(new MouseInput(handler, this));\n    }\n\n    public void manualSave() {\n        autoSave();\n        System.out.println(\"[Manual Save] Oyun manuel olarak kaydedildi.\");\n    }\n\n    public void run() {\n        this.requestFocus();\n        long lastTime = System.nanoTime();\n        double amountOfTicks = 60.0;\n        double ns = 1000000000 / amountOfTicks;\n        double delta = 0;\n        long timer = System.currentTimeMillis();\n        int frames = 0;\n        while (running) {\n            long now = System.nanoTime();\n            delta += (now - lastTime) / ns;\n            lastTime = now;\n            while (delta >= 1) {\n                tick();\n                delta--;\n            }\n            if (running)\n                render();\n            frames++;\n\n            if (System.currentTimeMillis() - timer > 1000) {\n                timer += 1000;\n                frames = 0;\n            }\n        }\n        stop();\n    }\n\n    private void tick() {\n        if (state == GameState.GAME) {\n            handler.tick();\n            Soldier player = handler.getPlayer();\n            if (player != null && player.getCurrentWeapon() != null) {\n                player.getCurrentWeapon().tickReload();\n            }\n\n            long now = System.currentTimeMillis();\n            if (lastAutoSaveTime == 0 || now - lastAutoSaveTime >= AUTO_SAVE_INTERVAL) {\n                autoSave();\n                lastAutoSaveTime = now;\n            }\n        }\n    }\n    \n    public void loadGame() {\n        try (BufferedReader br = new BufferedReader(new FileReader(\"autosave.txt\"))) {\n            int x = Integer.parseInt(br.readLine());\n            int y = Integer.parseInt(br.readLine());\n            int health = Integer.parseInt(br.readLine());\n            int score = Integer.parseInt(br.readLine());\n            String weaponName = br.readLine();\n            int currentAmmo = Integer.parseInt(br.readLine());\n            int totalAmmo = Integer.parseInt(br.readLine());\n            currentWave = Integer.parseInt(br.readLine());\n\n            handler = new Handler();\n            tileManager = new TileManager();\n            WaveManager waveManager = new WaveManager(handler, null, tileManager);\n\n            Weapon weapon;\n            switch (weaponName) {\n                case \"Pistol\": weapon = new Pistol(); break;\n                case \"SMG\": weapon = new SMG(); break;\n                case \"Shotgun\": weapon = new Shotgun(); break;\n                case \"RocketLauncher\": weapon = new RocketLauncher(); break;\n                default: weapon = new Pistol(); break;\n            }\n\n            weapon.setCurrentAmmo(currentAmmo);\n            weapon.setTotalAmmo(totalAmmo);\n\n            Soldier player = new Soldier(x, y, weapon);\n            player.setHealth(health);\n            player.setScore(score);\n            handler.setPlayer(player);\n            handler.addObject(player);\n\n            int zombieCount = Integer.parseInt(br.readLine());\n            for (int i = 0; i < zombieCount; i++) {\n                String type = br.readLine();\n                int zx = Integer.parseInt(br.readLine());\n                int zy = Integer.parseInt(br.readLine());\n                int zHealth = Integer.parseInt(br.readLine());\n\n                Zombie z = switch (type) {\n                    case \"NormalZombie\" -> new NormalZombie(zx, zy);\n                    case \"CrawlerZombie\" -> new CrawlerZombie(zx, zy);\n                    case \"TankZombie\" -> new TankZombie(zx, zy);\n                    case \"AcidZombie\" -> new AcidZombie(zx, zy, handler);\n                    default -> new NormalZombie(zx, zy);\n                };\n                z.health = zHealth;\n                handler.addObject(z);\n            }\n\n            this.setGameState(GameState.GAME);\n            System.out.println(\"[Load Game] Oyun yüklendi.\");\n        } catch (IOException | NumberFormatException e) {\n            e.printStackTrace();\n            System.out.println(\"[Load Game] Yükleme başarısız.\");\n        }\n    }\n\n    \n    \n    \n\n    private void render() {\n        BufferStrategy bs = this.getBufferStrategy();\n        if (bs == null) {\n            this.createBufferStrategy(3);\n            return;\n        }\n\n        Graphics g = bs.getDrawGraphics();\n        g.setColor(Color.black);\n        g.fillRect(0, 0, getWidth(), getHeight());\n        \n        \n        if (state == GameState.PAUSED) {\n            g.setColor(Color.WHITE);\n            g.setFont(new Font(\"Arial\", Font.PLAIN, 28));\n            g.drawRect(300, 180, 200, 40);\n            g.drawString(\"Resume\", 330, 210);\n\n            g.drawRect(300, 240, 200, 40);\n            g.drawString(\"Save Game\", 320, 270); \n\n            g.drawRect(300, 300, 200, 40);\n            g.drawString(\"Exit to Menu\", 310, 330);\n        }\n\n        if (state == GameState.MENU) {\n            g.setColor(Color.WHITE);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 36));\n            g.drawString(\"Top Down Shooter\", 180, 100);\n\n            g.setFont(new Font(\"Arial\", Font.PLAIN, 28));\n            g.drawRect(300, 180, 200, 40);\n            g.drawString(\"Start Game\", 320, 210);\n\n            g.drawRect(300, 240, 200, 40);\n            g.drawString(\"Load Game\", 320, 270);\n\n            g.drawRect(300, 300, 200, 40);\n            g.drawString(\"Music ON/OFF\", 310, 330);\n\n            g.drawRect(300, 360, 200, 40);\n            g.drawString(\"Exit\", 360, 390);\n\n        } else if (state == GameState.GAME) {\n            handler.render(g);\n\n            g.setColor(Color.WHITE);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 16));\n\n            Soldier player = handler.getPlayer();\n            if (player != null) {\n                Weapon weapon = player.getCurrentWeapon();\n                if (weapon != null) {\n                    g.drawString(\"Silah: \" + weapon.getName(), 20, 30);\n                    g.drawString(\"Mermi: \" + weapon.getCurrentAmmo() + \" / \" + weapon.getTotalAmmo(), 20, 50);\n\n                    if (weapon.isReloading()) {\n                        double progress = weapon.getReloadProgress();\n                        int radius = 30;\n                        int centerX = 70;\n                        int centerY = 80;\n                        g.setColor(Color.LIGHT_GRAY);\n                        g.drawOval(centerX - radius, centerY - radius, radius * 2, radius * 2);\n                        g.setColor(Color.CYAN);\n                        int angle = (int) (360 * progress);\n                        g.fillArc(centerX - radius, centerY - radius, radius * 2, radius * 2, 90, -angle);\n                    }\n                }\n\n                int maxHealth = 100;\n                int barWidth = 100;\n                int barHeight = 10;\n                int health = player.getHealth();\n                int healthBar = (int) ((double) health / maxHealth * barWidth);\n\n                g.setColor(Color.GRAY);\n                g.fillRect(getWidth() - 160, 20, barWidth, barHeight);\n                g.setColor(Color.RED);\n                g.fillRect(getWidth() - 160, 20, healthBar, barHeight);\n                g.setColor(Color.BLACK);\n                g.drawRect(getWidth() - 160, 20, barWidth, barHeight);\n\n                g.setColor(Color.WHITE);\n                g.drawString(\"Skor: \" + player.getScore(), getWidth() - 150, 50);\n            }\n\n            if (!waveMessage.isEmpty() && System.currentTimeMillis() - waveMessageTimer < 2000) {\n                g.setFont(new Font(\"Arial\", Font.BOLD, 36));\n                g.setColor(Color.YELLOW);\n                g.drawString(waveMessage, getWidth() / 2 - 150, 100);\n            }\n        }\n\n        g.dispose();\n        bs.show();\n    }\n    \n    \n\n    private void autoSave() {\n        try (PrintWriter pw = new PrintWriter(new FileWriter(\"autosave.txt\"))) {\n            Soldier player = handler.getPlayer();\n            if (player != null) {\n                pw.println(player.getX());\n                pw.println(player.getY());\n                pw.println(player.getHealth());\n                pw.println(player.getScore());\n                pw.println(player.getCurrentWeapon().getName());\n                pw.println(player.getCurrentWeapon().getCurrentAmmo());\n                pw.println(player.getCurrentWeapon().getTotalAmmo());\n                pw.println(currentWave);\n            }\n\n            int zombieCount = 0;\n            for (GameObject obj : handler.objects) {\n                if (obj instanceof Zombie) zombieCount++;\n            }\n            pw.println(zombieCount);\n            for (GameObject obj : handler.objects) {\n                if (obj instanceof Zombie) {\n                    Zombie z = (Zombie) obj;\n                    pw.println(z.getClass().getSimpleName());\n                    pw.println(z.getX());\n                    pw.println(z.getY());\n                    pw.println(z.getHealth());\n                }\n            }\n            System.out.println(\"[AutoSave] Oyun otomatik kaydedildi.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void setGameState(GameState state) {\n        this.state = state;\n    }\n\n    public GameState getGameState() {\n        return state;\n    }\n\n    public static void main(String[] args) {\n        new Game();\n    }\n}\n",
      "MouseInput.java": "\n\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class MouseInput extends MouseAdapter {\n\n    private Handler handler;\n    private Game game;\n\n    public MouseInput(Handler handler, Game game) {\n        this.handler = handler;\n        this.game = game;\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        int mx = e.getX();\n        int my = e.getY();\n\n        if (game.getGameState() == Game.GameState.MENU) {\n            if (mx >= 300 && mx <= 500 && my >= 240 && my <= 280) {\n                game.loadGame();\n            }\n        }\n\n        if (game.getGameState() == Game.GameState.PAUSED) {\n            if (mx >= 300 && mx <= 500 && my >= 240 && my <= 280) {\n                game.manualSave();\n            }\n        }\n\n        if (e.getButton() == MouseEvent.BUTTON1 && game.getGameState() == Game.GameState.GAME) {\n            int mouseX = e.getX();\n            int mouseY = e.getY();\n\n            Soldier player = handler.getPlayer();\n            if (player != null && player.getCurrentWeapon() != null) {\n                int playerX = player.getX() + 16;\n                int playerY = player.getY() + 16;\n\n                double dx = mouseX - playerX;\n                double dy = mouseY - playerY;\n                double angle = Math.atan2(dy, dx);\n\n                player.getCurrentWeapon().fire(playerX, playerY, handler, angle);\n            }\n        }\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        \n    }\n}\n",
      "RocketLauncher.java": "\n\npublic class RocketLauncher extends Weapon {\n\n    public RocketLauncher() {\n        super(\"RocketLauncher\", 2, 100, 3000);\n    }\n\n    @Override\n    public void fire(int x, int y, Handler handler, double angle) {\n        if (canFire()) {\n            handler.addObject(new Rocket(x, y, angle, damage));\n            currentAmmo--;\n            lastFired = System.currentTimeMillis();\n        }\n    }\n}\n",
      "TileManager.java": "\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.Color;\nimport java.awt.Rectangle;\n\n\npublic class TileManager {\n\n    private ArrayList<Tile> tiles = new ArrayList<>();\n    private BufferedImage lava, water, bush, grass, brick, stone, tree;\n    private final int TILE_SIZE = 32;\n\n    public TileManager() {\n        BufferedImageLoader loader = new BufferedImageLoader();\n        brick = loader.loadImage(\"/brick.png\");\n        stone = loader.loadImage(\"/stone.png\");\n        lava = loader.loadImage(\"/lava.png\");\n        water = loader.loadImage(\"/water.png\");\n        tree = loader.loadImage(\"/tree.png\");\n        bush = loader.loadImage(\"/bush.png\");\n        grass = loader.loadImage(\"/grass.png\");\n\n        generateMap();\n    }\n\n    public void render(Graphics g) {\n        for (Tile tile : tiles) {\n            tile.render(g);\n        }\n    }\n\n    public boolean isBlocked(int x, int y) {\n        Rectangle point = new Rectangle(x, y, 1, 1);\n        for (Tile tile : tiles) {\n            if (tile.isSolid() && tile.getBounds().intersects(point)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void addTile(Tile tile) {\n        tiles.add(tile);\n    }\n\n    public ArrayList<Tile> getTiles() {\n        return tiles;\n    }\n\n    private void generateMap() {\n        int cols = 800 / TILE_SIZE;\n        int rows = 600 / TILE_SIZE;\n        Random rand = new Random();\n\n        for (int y = 0; y < rows; y++) {\n            for (int x = 0; x < cols; x++) {\n                BufferedImage img;\n                boolean solid = false;\n\n              \n                if (x == 0 || y == 0 || x == cols - 1 || y == rows - 1) {\n                    img = brick;\n                    solid = true;\n                } else {\n                    int r = rand.nextInt(100);\n                    if (r < 5) {\n                        img = tree;\n                        solid = true;\n                    } else if (r < 10) {\n                        img = bush;\n                    } else {\n                        img = grass;\n                    }\n                }\n\n                Tile tile = new Tile(x * TILE_SIZE, y * TILE_SIZE, img, solid);\n                tiles.add(tile);\n            }\n        }\n    }\n}\n",
      "Window.java": "\n\nimport javax.swing.*;\n\npublic class Window {\n\n    public Window(int width, int height, String title, Game game) {\n        JFrame frame = new JFrame(title);\n        frame.setSize(width, height);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setResizable(false);\n        frame.setLocationRelativeTo(null);\n        frame.add(game);\n        frame.setVisible(true);\n    }\n}\n",
      "GameObject.java": "\n\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic abstract class GameObject {\n    protected int x, y;\n    protected int velX = 0, velY = 0;\n\n    public GameObject(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public abstract void tick();\n    public abstract void render(Graphics g);\n    public abstract Rectangle getBounds();\n\n    public int getX() { return x; }\n    public int getY() { return y; }\n    public void setX(int x) { this.x = x; }\n    public void setY(int y) { this.y = y; }\n\n    public int getVelX() { return velX; }\n    public int getVelY() { return velY; }\n    public void setVelX(int velX) { this.velX = velX; }\n    public void setVelY(int velY) { this.velY = velY; }\n}\n"
    },
    {
      "id": "4275079",
      "zombies.java": "//This game was made by Efe Selim Surekli.\npackage entity;\n\nimport main.GamePanel;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport main.collisionChechker;\n\n// Abstract base class for all zombie types defining common properties and behaviors\npublic abstract class zombies {\n    GamePanel gp;\n    public int score;\n    player p;\n    public boolean isAlive = true; // Zombi hayatta mı?\n\n    public BufferedImage image;\n    public int healt;\n    public double speed;\n    public int damage;\n    public int worldX, worldY;\n\n    // Constructor: Initializes zombie with game panel reference\n    public zombies(GamePanel gp) {\n        this.gp = gp;\n        this.p = gp.p; // Oyuncuya erişim\n    }\n\n    // Basic update method for zombie movement and collision with player\n    public void update() {\n        // Basit bir takip algoritması\n\n        if (p.worldX > worldX) {\n            worldX += speed; // Oyuncuya doğru ilerle\n        } else if (p.worldX < worldX) {\n            worldX -= speed;\n        }\n\n        if (p.worldY > worldY) {\n            worldY += speed;\n        } else if (p.worldY < worldY) {\n            worldY -= speed;\n        }\n\n        // Oyuncuya çarptığında hasar verme\n        int distanceX = Math.abs(p.worldX - worldX);\n        int distanceY = Math.abs(p.worldY - worldY);\n        if (distanceX < gp.tileSize && distanceY < gp.tileSize) {\n            hit();\n        }\n    }\n\n    // Draws the zombie on screen at its current position\n    public void draw(Graphics2D g2) {\n        int screenX = worldX - gp.p.worldX + gp.p.screenX;\n        int screenY = worldY - gp.p.worldY + gp.p.screenY;\n\n        // Ekran içinde mi kontrol edelim\n        if (screenX + gp.tileSize > 0 && screenX < gp.screenWidth &&\n                screenY + gp.tileSize > 0 && screenY < gp.screenHeight) {\n            g2.drawImage(image, screenX, screenY, gp.tileSize, gp.tileSize, null);\n        }\n    }\n\n    // Reduces zombie's health and checks if it died\n    public void takeDamage(int damage) {\n        healt -= damage; // Canı azalt\n        if (healt <= 0) {\n            isAlive = false; // Zombi öldü\n        }\n    }\n\n    // Abstract method for attacking the player (to be implemented by subclasses)\n    public abstract void hit(); // Oyuncuya zarar verme metodu\n\n    // Abstract method for special abilities (to be implemented by subclasses)\n    public abstract void feature(); // Özel yetenek metodu\n}",
      "AcidZombie.java": "//This game was made by Efe Selim Surekli.\npackage entity;\n\nimport main.GamePanel;\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\npublic class AcidZombie extends zombies {\n    private long lastHitTime = 0; // Tracks the last time damage was dealt\n    public long cooldownTime = 2000; // Cooldown period between attacks in milliseconds\n    private BufferedImage zombieWest; // Image when facing west\n    private BufferedImage zombieEast; // Image when facing east\n    public ArrayList<AcidShoot> acidShoot;\n    private long lastShotTime = 0;\n    private int shootRange = 3 * gp.tileSize; // 3 tiles range\n\n    // Constructor: Initializes AcidZombie with game panel reference and sets properties\n    public AcidZombie(GamePanel gp) {\n        super(gp);\n        this.score = 50; // Points awarded when killed\n        this.healt = 150; // Initial health\n        this.damage = 75; // Damage dealt to player\n        this.speed = 1.5; // Movement speed\n        this.acidShoot = new ArrayList<>();\n\n        // Load images for both directions\n        loadImages();\n    }\n\n    // Loads the images for the zombie facing both directions from resources\n    private void loadImages() {\n        try {\n            zombieWest = ImageIO.read(getClass().getResourceAsStream(\"/zombies/acidWest.png\"));\n            zombieEast = ImageIO.read(getClass().getResourceAsStream(\"/zombies/acidEast.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Updates the zombie's state each frame including movement and facing direction\n    @Override\n    public void update() {\n        // Update facing direction based on player position\n        if (worldX >= gp.p.worldX) {\n            image = zombieWest; // Face west if player is to the left\n        } else {\n            image = zombieEast; // Face east if player is to the right\n        }\n\n        // Calculate distance to player\n        double distanceToPlayer = Math.sqrt(Math.pow(worldX - gp.p.worldX, 2) + Math.pow(worldY - gp.p.worldY, 2));\n\n        // If within shooting range but not too close, stop and shoot\n        if (distanceToPlayer <= shootRange && distanceToPlayer > gp.tileSize) {\n            // Stop moving\n            speed = 0;\n\n            // Shoot acid projectile if cooldown is over\n            long currentTime = System.currentTimeMillis();\n            if (currentTime - lastShotTime >= cooldownTime) {\n                shootAcid();\n                lastShotTime = currentTime;\n            }\n        } else if (distanceToPlayer > shootRange) {\n            // If too far, keep moving toward player\n            speed = 1.6;\n            super.update(); // Call parent update for movement\n        } else if (distanceToPlayer <= gp.tileSize) {\n            // If too close, melee attack\n            speed = 0;\n            hit();\n        }\n\n        // Update acid projectiles\n        AcidShoot();\n    }\n\n    // Shoots an acid projectile toward the player\n    private void shootAcid() {\n        AcidShoot acid = new AcidShoot(worldX, worldY, gp.p.worldX, gp.p.worldY, gp);\n        acidShoot.add(acid);\n    }\n\n    // Updates all acid projectiles and checks for collisions\n    private void AcidShoot() {\n        for (int i = acidShoot.size() - 1; i >= 0; i--) {\n            AcidShoot acid = acidShoot.get(i);\n            acid.update();\n\n            // Check if projectile hit player\n            if (acid.checkCollision(gp.p)) {\n                player.health -= 30; // Damage player\n                acidShoot.remove(i);\n                continue;\n            }\n\n            // Remove projectiles that are out of bounds\n            if (acid.isOutOfBounds()) {\n                acidShoot.remove(i);\n            }\n        }\n    }\n\n    // Handles melee attacking the player with cooldown\n    @Override\n    public void hit() {\n        long currentTime = System.currentTimeMillis();\n        // Check if player is within attack range (1 tile)\n        boolean isPlayerInRange = (Math.abs(gp.p.worldX - worldX) < gp.tileSize &&\n                Math.abs(gp.p.worldY - worldY) < gp.tileSize);\n\n        // Check cooldown and range before attacking\n        if (currentTime - lastHitTime >= cooldownTime && isPlayerInRange) {\n            player.health -= damage; // Deal damage\n            lastHitTime = currentTime; // Reset cooldown timer\n            System.out.println(\"Oyuncuya \" + damage + \" hasar verildi! Kalan can: \" + player.health);\n        }\n    }\n\n    // Draws the zombie and its acid projectiles\n    @Override\n    public void draw(java.awt.Graphics2D g2) {\n        super.draw(g2);\n\n        // Draw all acid projectiles\n        for (AcidShoot acid : acidShoot) {\n            acid.draw(g2);\n        }\n    }\n\n    // Special ability: Changes image when dead and removes corpse after 2 seconds\n    @Override\n    public void feature() {\n        if (healt <= 0) {\n            try {\n                // Load dead zombie image\n                image = ImageIO.read(getClass().getResourceAsStream(\"/zombies/deadTank.png\"));\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        // Set timer to remove corpse after 2 seconds\n        Timer timer = new Timer();\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n                System.out.println(\"2 saniye bekledikten sonra işlem yapılıyor...\");\n                image = null; // Remove image\n            }\n        }, 2000); // 2000 ms = 2 seconds\n    }\n}",
      "NormalZombie.java": "//This game was made by Efe Selim Surekli.\npackage entity;\n\nimport main.GamePanel;\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\npublic class NormalZombie extends zombies {\n    private long lastHitTime = 0; // Tracks last attack time\n    private long cooldownTime = 2000; // Attack cooldown in ms\n    private BufferedImage zombieWest; // West-facing image\n    private BufferedImage zombieEast; // East-facing image\n\n    // Constructor: Initializes NormalZombie with game panel reference and sets properties\n    public NormalZombie(GamePanel gp) {\n        super(gp);\n        this.score=50; // Points when killed\n        this.healt = 250; // Initial health\n        this.damage = 75; // Attack damage\n        this.speed = 1.8; // Movement speed\n\n        loadImages(); // Load directional images\n    }\n\n    // Loads images for both facing directions from resources\n    private void loadImages() {\n        try {\n            zombieWest = ImageIO.read(getClass().getResourceAsStream(\"/zombies/zombieWest.png\"));\n            zombieEast = ImageIO.read(getClass().getResourceAsStream(\"/zombies/zombieEast.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Updates zombie state each frame including movement and facing direction\n    @Override\n    public void update() {\n        super.update(); // Parent handles basic movement\n\n        // Update facing direction based on player position\n        if (worldX >= gp.p.worldX) {\n            image = zombieWest; // Face west if player is left\n        } else {\n            image = zombieEast; // Face east if player is right\n        }\n    }\n\n    // Handles attacking the player with cooldown and range checks\n    @Override\n    public void hit() {\n        long currentTime = System.currentTimeMillis();\n\n        // Check if player is within attack range (1 tile)\n        boolean isPlayerInRange = (Math.abs(p.worldX - worldX) < gp.tileSize &&\n                Math.abs(p.worldY - worldY) < gp.tileSize);\n\n        // Check cooldown and range before attacking\n        if (currentTime - lastHitTime >= cooldownTime && isPlayerInRange) {\n            player.health -= damage; // Deal damage\n            lastHitTime = currentTime; // Reset cooldown\n\n            System.out.println(\"Normal Zombie oyuncuya \" + damage + \" hasar verdi! Kalan can: \" + player.health);\n        }\n    }\n\n    // Special ability - Normal zombie has none (empty implementation)\n    @Override\n    public void feature() {\n        System.out.println(\"NormalZombie'nin ekstra bir yeteneği yok.\");\n    }\n}",
      "AcidShoot.java": "//This game was made by Efe Selim Surekli.\npackage entity;\n\nimport main.GamePanel;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nclass AcidShoot {\n    public double worldX, worldY;\n    private double targetX, targetY;\n    private double speed = 3.0;\n    public GamePanel gp;\n    public BufferedImage image;\n    private double directionX, directionY;\n    public int size ;\n\n    public AcidShoot(double startX, double startY, double targetX, double targetY, GamePanel gp) {\n        this.worldX = startX;\n        this.size= gp.tileSize / 2;\n        this.worldY = startY;\n        this.targetX = targetX;\n        this.targetY = targetY;\n        this.gp = gp;\n\n        // Calculate direction vector\n        double dx = targetX - startX;\n        double dy = targetY - startY;\n        double length = Math.sqrt(dx * dx + dy * dy);\n        this.directionX = dx / length;\n        this.directionY = dy / length;\n\n        // Load image\n        try {\n            this.image = ImageIO.read(getClass().getResourceAsStream(\"/zombies/acid.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void update() {\n        // Move projectile\n        worldX += directionX * speed;\n        worldY += directionY * speed;\n    }\n\n    public boolean checkCollision(player p) {\n        // Check collision with player\n        return Math.abs(worldX - p.worldX) < size && Math.abs(worldY - p.worldY) < size;\n    }\n\n    public boolean isOutOfBounds() {\n        // Check if projectile is out of game bounds\n        return worldX < 0 || worldX > gp.worldWidth || worldY < 0 || worldY > gp.worldHeight;\n    }\n\n    public void draw(java.awt.Graphics2D g2) {\n        if (image != null) {\n            int screenX = (int) (worldX - gp.p.worldX + gp.p.screenX);\n            int screenY = (int) (worldY - gp.p.worldY + gp.p.screenY);\n\n            // Only draw if on screen\n            if (screenX + size > 0 && screenX < gp.screenWidth &&\n                    screenY + size > 0 && screenY < gp.screenHeight) {\n                g2.drawImage(image, screenX, screenY, size, size, null);\n            }\n        }\n    }\n}",
      "player.java": "//This game was made by Efe Selim Surekli.\npackage entity;\n\nimport main.GamePanel;\nimport main.KeyHandler;\nimport main.mouseHandler;\nimport objects.*;\nimport objects.bulletObjects;\n\nimport javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseMotionListener;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\n// Main player class handling player movement, shooting, health, and rendering\npublic class player implements MouseMotionListener {\n    private boolean hasShot = false;\n    private long lastShotTime = 0; // Son ateş zamanı\n    private boolean canShoot = true; // Ateş edilebilir mi?\n\n    public ArrayList<bulletObjects> bulletList;\n    boolean isShooting;\n    public boolean collisionOn;\n\n    public String direction = \"\";\n    public ArrayList<guns> gunList;\n    public String lastDirection = \"right\";\n    public static int health;\n    public  static int score;\n    public BufferedImage default1, up1, down1, left1, right1;\n    public guns currentGun;\n    public int screenX;\n    public int screenY;\n    GamePanel gp;\n    KeyHandler keyH;\n    public int worldX;\n    public int worldY;\n\n    public static int speed;\n    public Rectangle solidArea;\n    public int solidAreaDefaultX, solidAreaDefaultY;\n\n    mouseHandler mh;\n\n    public int index;\n\n    public int mouseX, mouseY;\n    private double rotationAngle = 0; // Görselin dönüş açısı\n\n    // Constructor: Initializes player with game panel, key handler, and mouse handler\n    public player(GamePanel gp, KeyHandler keyh, mouseHandler mh) {\n        this.bulletList = new ArrayList<>();\n        this.gunList = new ArrayList<>();\n        gunList.add(new pistol());\n\n        this.index = 0;\n        this.currentGun = gunList.get(index);\n\n        score = 0;\n        health = 2500;\n        this.keyH = keyh;\n        this.mh = mh;\n        this.gp = gp;\n        screenX = gp.screenWidth / 2 - (gp.tileSize / 2);\n        screenY = gp.screenHeight / 2 - (gp.tileSize / 2);\n\n        solidArea = new Rectangle();\n        solidArea.x = 8;\n        solidArea.y = 16;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        solidArea.width = 16;\n        solidArea.height = 16;\n\n        setDefaultLocation();\n        getPlayerImage();\n\n        // Mouse hareketlerini dinlemesi için\n        gp.addMouseMotionListener(this);\n    }\n\n    // Sets default spawn location for the player\n    public void setDefaultLocation() {\n        worldY = gp.tileSize * 20;\n        worldX = gp.tileSize * 24;\n        direction = \"default\";\n    }\n\n    // Loads appropriate player image based on current weapon and state\n    public void getPlayerImage() {\n        try {\n            if (gp.index == 0) {\n                if (isShooting && canShoot()) {\n                    default1 = up1 = down1 = left1 = right1 = resizeImage(\n                            ImageIO.read(getClass().getResourceAsStream(\"/player/playerPistol1Ates.png\")),\n                            gp.tileSize * 2, gp.tileSize * 2\n                    );\n                } else {\n                    default1 = up1 = down1 = left1 = right1 = resizeImage(\n                            ImageIO.read(getClass().getResourceAsStream(\"/player/playerPistol1.png\")),\n                            gp.tileSize * 2, gp.tileSize * 2\n                    );\n                }\n            } else if (gp.index == 1 && gp.Round >= 2) {\n                if (isShooting && canShoot()) {\n                    default1 = up1 = down1 = left1 = right1 = resizeImage(\n                            ImageIO.read(getClass().getResourceAsStream(\"/player/playerRifle2Ates3.png\")),\n                            gp.tileSize * 2, gp.tileSize * 2\n                    );\n                } else {\n                    default1 = up1 = down1 = left1 = right1 = resizeImage(\n                            ImageIO.read(getClass().getResourceAsStream(\"/player/playerRifle3.png\")),\n                            gp.tileSize * 2, gp.tileSize * 2\n                    );\n                }\n            } else if (gp.index == 2 && gp.Round >= 4) {\n                if (isShooting && canShoot()) {\n                    default1 = up1 = down1 = left1 = right1 = resizeImage(\n                            ImageIO.read(getClass().getResourceAsStream(\"/player/playerShotgunAtes1.png\")),\n                            gp.tileSize * 2, gp.tileSize * 2\n                    );\n                } else {\n                    default1 = up1 = down1 = left1 = right1 = resizeImage(\n                            ImageIO.read(getClass().getResourceAsStream(\"/player/playerShotgun1.png\")),\n                            gp.tileSize * 2, gp.tileSize * 2\n                    );\n                }\n            } else if (gp.index == 3 && gp.Round >= 6) {\n                if (isShooting && canShoot()) {\n                    default1 = up1 = down1 = left1 = right1 = resizeImage(\n                            ImageIO.read(getClass().getResourceAsStream(\"/player/playerSniperAtes1.png\")),\n                            gp.tileSize * 2, gp.tileSize * 2\n                    );\n                } else {\n                    default1 = up1 = down1 = left1 = right1 = resizeImage(\n                            ImageIO.read(getClass().getResourceAsStream(\"/player/playerSniper1.png\")),\n                            gp.tileSize * 2, gp.tileSize * 2\n                    );\n                }\n            } else if (gp.index == 4 && gp.Round > 11) {\n                if (isShooting && canShoot()) {\n                    default1 = up1 = down1 = left1 = right1 = resizeImage(\n                            ImageIO.read(getClass().getResourceAsStream(\"/player/playerRocketAtes1.png\")),\n                            gp.tileSize * 2, gp.tileSize * 2\n                    );\n                } else {\n                    default1 = up1 = down1 = left1 = right1 = resizeImage(\n                            ImageIO.read(getClass().getResourceAsStream(\"/player/playerRocket1.png\")),\n                            gp.tileSize * 2, gp.tileSize * 2\n                    );\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Resizes an image to specified dimensions\n    private BufferedImage resizeImage(BufferedImage originalImage, int width, int height) {\n        BufferedImage resizedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2d = resizedImage.createGraphics();\n        g2d.drawImage(originalImage, 0, 0, width, height, null);\n        g2d.dispose();\n        return resizedImage;\n    }\n\n    // Handles mouse press event for shooting\n    public void mousePressed() {\n        if (currentGun.canShoot() && !hasShot) {\n            int targetX = mh.mouseX;\n            int targetY = mh.mouseY;\n\n            // Diğer silahlar için tek mermi oluştur\n            bulletObjects bullet = new bulletObjects(worldX, worldY, targetX, targetY, gp);\n            bulletList.add(bullet);\n\n            currentGun.setBullets(currentGun.getBullets() - 1);\n            System.out.println(\"Mermi oluşturuldu ve listeye eklendi.\");\n\n            // Ateş etme durumunu kilitle\n            hasShot = true;\n\n            // Timer ile ateş etme kilidini aç\n            long minTimeBetweenShots = 60000 / currentGun.fireRate;\n            Timer timer = new Timer();\n            timer.schedule(new TimerTask() {\n                @Override\n                public void run() {\n                    hasShot = false; // Ateş etme kilidini aç\n                    timer.cancel(); // Timer'ı temizle\n                }\n            }, minTimeBetweenShots); // FireRate'e göre gecikme\n        }\n    }\n\n    // Main update method called each frame to handle all player actions\n    public void update() {\n        if (health <= 0) {\n            System.exit(1);\n        }\n\n        updateRotationBasedOnMouse(); // Mouse'un yönüne göre dönüş açısını ayarla\n\n        // Silah ateşleme ve yeniden doldurma işlemleri\n        handleShooting();\n        handleReload();\n        keyH.reloading = false;\n\n        // Oyuncu hareketi\n        handleMovement();\n\n        if (mh.isPressed) {\n            mousePressed();\n        }\n\n        // Mermi güncelleme\n        for (int i = bulletList.size() - 1; i >= 0; i--) {\n            bulletObjects bullet = bulletList.get(i);\n            bullet.update();\n\n            // Zombilerle çarpışma kontrolü\n            for (zombies zombie : gp.zombiesList) {\n                if (bullet.checkCollision(zombie)) {\n\n                    //SniperFeature\n                    if (currentGun instanceof sniper) {\n                        bullet.active = true;\n                    }\n                    //RocketFeature\n                    else if (currentGun instanceof rocket) {\n                        if (Math.abs(zombie.worldX - bullet.worldX) < 3 || Math.abs(zombie.worldY - bullet.worldY) < 3) {\n                            zombie.healt -= 50;\n                            try {\n                                bullet.image=ImageIO.read(getClass().getResourceAsStream(\"/player/rocketBomb.png\"));\n                            } catch (IOException e) {\n                                throw new RuntimeException(e);\n                            }\n                        }\n                        bullet.active = false;\n                    }\n                    else\n                        bullet.active = false;\n\n                    break;\n                }\n            }\n\n            // Aktif olmayan mermileri listeden kaldır\n            if (!bullet.active&&!(currentGun instanceof shotgun)) {\n                bulletList.remove(i);\n            }\n        }\n        getPlayerImage();\n    }\n\n    // Handles shooting logic including fire rate and bullet creation\n    private void handleShooting() {\n        isShooting = mh.isPressed;\n        long currentTime = System.currentTimeMillis();\n\n        // Eğer ateş ediliyorsa ve daha önce mermi atılmamışsa\n        if (isShooting && !hasShot) {\n            if (currentGun.canShoot() && currentGun.getBullets() > 0 && canShoot) {\n                // FireRate (RPM) hesaplama: 60.000 ms / fireRate = her atış arasındaki minimum süre\n                long minTimeBetweenShots = 60000 / currentGun.fireRate;\n                long timeSinceLastShot = currentTime - lastShotTime;\n                int targetX = mh.mouseX;\n                int targetY = mh.mouseY;\n                if (timeSinceLastShot >= minTimeBetweenShots) {\n                    if (currentGun instanceof shotgun) {\n                        if (currentGun.canShoot()) {\n                            currentGun.setBullets(currentGun.getBullets() - 1); // Sadece 1 mermi eksilt\n\n                            int mouseX = mh.mouseX;\n                            int mouseY = mh.mouseY;\n                            int playerScreenX = screenX;\n                            int playerScreenY = screenY;\n\n                            // Ana hedef noktasını hesapla\n                            double mainTargetX = mouseX - playerScreenX + worldX;\n                            double mainTargetY = mouseY - playerScreenY + worldY;\n\n                            // 9 mermi oluştur (5 derece spread ile)\n                            double spreadAngle = Math.toRadians(10); // Toplam 5 derece spread\n                            double angleStep = spreadAngle / 8; // 9 mermi için 8 adım (ortadaki + 4'er yan)\n\n                            for (int i = -5; i <= 5; i++) { // -4, -3, ..., 0, ..., +4\n                                // Her mermi için açıyı hesapla\n                                double angle = Math.atan2(mainTargetY - worldY, mainTargetX - worldX);\n                                angle += i * angleStep;\n\n                                // Her mermi için hedef noktayı yeniden hesapla\n                                double distance = 1000; // Yeterince uzak bir nokta\n                                double bulletTargetX = worldX + distance * Math.cos(angle);\n                                double bulletTargetY = worldY + distance * Math.sin(angle);\n\n                                bulletObjects bullet = new bulletObjects(worldX, worldY, bulletTargetX, bulletTargetY, gp);\n                                bulletList.add(bullet);\n                            }\n                        }\n                    } else {\n                        // Mermi sayısını azalt\n                        currentGun.setBullets(currentGun.getBullets() - 1);\n\n                        // Mermi oluştur ve listeye ekle\n                        bulletObjects bullet = new bulletObjects(worldX, worldY, targetX, targetY, gp);\n                        bulletList.add(bullet);\n\n                        System.out.println(\"Ateş edildi! Kalan mermi: \" + currentGun.getBullets());\n\n                        // Son ateş zamanını güncelle\n                        lastShotTime = currentTime;\n\n                        // Ateş etme durumunu kilitle\n                        canShoot = false;\n\n                        // Timer ile ateş etme kilidini aç\n                        Timer timer = new Timer();\n                        timer.schedule(new TimerTask() {\n                            @Override\n                            public void run() {\n                                canShoot = true; // Ateş etme kilidini aç\n                                timer.cancel(); // Timer'ı temizle\n                            }\n                        }, minTimeBetweenShots); // FireRate'e göre gecikme\n                    }  } else{\n                    System.out.println(\"Ateş hızı sınırı aşıldı! Bekleyin...\");\n                }\n            } else {\n                System.out.println(\"Mermi bitti, reload at!\");\n                isShooting = false;\n            }\n        }\n    }\n\n    // Eğer fare tıklaması bırakıldıysa, mermi atma durumunu sıfırla\n\n\n\n// Handles weapon reloading when R key is pressed\nprivate void handleReload() {\n    if (keyH.reloading && currentGun.canReload()) {\n        currentGun.reload(); // Yeniden doldur\n        System.out.println(\"Yeniden dolduruldu! Kalan şarjör: \" + currentGun.getMagazine());\n        keyH.reloading = false;\n    } else if (keyH.reloading && !currentGun.canReload()) {\n        System.out.println(\"Şarjör yok!\");\n        keyH.reloading = false;\n    }\n}\n\n// Handles player movement based on keyboard input\nprivate void handleMovement() {\n    if (keyH.upPressed) {\n        direction = \"up\";\n        lastDirection = \"up\";\n        speed = 3;\n    } else if (keyH.downPressed) {\n        direction = \"down\";\n        lastDirection = \"down\";\n        speed = 3;\n    } else if (keyH.leftPressed) {\n        direction = \"left\";\n        lastDirection = \"left\";\n        speed = 3;\n    } else if (keyH.rightPressed) {\n        direction = \"right\";\n        lastDirection = \"right\";\n        speed = 3;\n    } else {\n        speed = 0;\n    }\n\n    collisionOn = false;\n    gp.cC.checkTile(this);\n\n    if (!collisionOn) {\n        switch (direction) {\n            case \"up\":\n                worldY -= speed;\n                break;\n            case \"down\":\n                worldY += speed;\n                break;\n            case \"left\":\n                worldX -= speed;\n                break;\n            case \"right\":\n                worldX += speed;\n                break;\n        }\n    }\n\n    // Son yönü güncelle\n    if (speed != 0) {\n        lastDirection = direction;\n    }\n}\n\n// Checks if player can shoot based on current ammo\npublic boolean canShoot() {\n    return currentGun.getBullets() > 0; // Guns sınıfındaki getBullets metodu kullanılıyor\n}\n\n// Updates player rotation angle based on mouse position\npublic void updateRotationBasedOnMouse() {\n    int deltaX = mouseX - (screenX + gp.tileSize / 2);\n    int deltaY = mouseY - (screenY + gp.tileSize / 2);\n\n    // Mouse pozisyonuna göre açıyı hesapla\n    rotationAngle = Math.toDegrees(Math.atan2(deltaY, deltaX));\n\n    // Görselin doğru yönde dönmesi için 90 derece ekle\n    rotationAngle -= 90;\n}\n\n// Mouse motion listener methods\n@Override\npublic void mouseMoved(MouseEvent e) {\n    this.mouseX = e.getX();\n    this.mouseY = e.getY();\n}\n\n@Override\npublic void mouseDragged(MouseEvent e) {\n    this.mouseX = e.getX();\n    this.mouseY = e.getY();\n}\n\n// Rotates player image based on current rotation angle\npublic BufferedImage rotateImage(BufferedImage image, double angle) {\n    int width = image.getWidth();\n    int height = image.getHeight();\n\n    // Yeni bir BufferedImage oluşturuyoruz, boyutları orijinal görüntüyle aynı\n    BufferedImage rotatedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    Graphics2D g2d = rotatedImage.createGraphics();\n\n    // Görüntüyü merkez etrafında döndürmek için AffineTransform kullanıyoruz\n    AffineTransform transform = new AffineTransform();\n    transform.rotate(Math.toRadians(angle), width /2 , height / 2);\n\n    // Döndürme işlemini uyguluyoruz\n    g2d.setTransform(transform);\n    g2d.drawImage(image, 0, 0, null);\n    g2d.dispose();\n\n    return rotatedImage;\n}\n\n// Draws player and bullets on screen\npublic void draw(Graphics g) {\n    if (g == null) return; // Null Graphics nesnesini kontrol et\n\n    Graphics2D g2 = (Graphics2D) g;\n\n    try {\n        if (default1 == null) {\n            System.err.println(\"Hata: default1 resmi null!\");\n            return;\n        }\n\n        BufferedImage rotatedImage = rotateImage(default1, rotationAngle);\n        if (rotatedImage == null) {\n            System.err.println(\"Hata: Döndürülen resim null!\");\n            return;\n        }\n\n        // Görüntüyü ekrana çizerken merkez noktasını doğru bir şekilde ayarlıyoruz\n        int drawX = screenX - rotatedImage.getWidth() / 2;\n        int drawY = screenY - rotatedImage.getHeight() / 2;\n\n        for (bulletObjects bullet : bulletList) {\n            if(currentGun instanceof shotgun){\n                for(int i=0;i<9;i++){\n                    bullet.draw(g2);}\n            }\n            else { bullet.draw(g2);\n            }}\n        g2.drawImage(rotatedImage, drawX, drawY, null);\n\n        // Pause durumunda \"PAUSED\" yazısını çiz\n        if (keyH.isPaused) {\n            gp.ui.drawPauseScreen(g2);\n        }\n    } finally {\n        g2.dispose(); // Kaynak yönetimi için güvenli kapatma\n    }\n}\n}",
      "reptileZombie.java": "//This game was made by Efe Selim Surekli.\npackage entity;\n\nimport main.GamePanel;\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\npublic class reptileZombie extends zombies {\n    public long lastHitTime = 0; // Son hasar zamanını tutar\n    public long cooldownTime = 1000; // Cooldown süresi (milisecond cinsinden, örnek: 1000ms = 1 saniye)\n\n    // Resimler\n    private BufferedImage reptileWest;\n    private BufferedImage reptileEast;\n    private BufferedImage reptileWestJump;\n    private BufferedImage reptileEastJump;\n\n    // Constructor: Initializes reptileZombie with game panel reference and sets properties\n    public reptileZombie(GamePanel gp) {\n        super(gp);\n        loadImages(); // Resimleri yükle\n        image = reptileEast; // Başlangıç resmi\n        this.score = 80;\n        this.healt = 150;\n        this.damage = 75;\n        this.speed = 2.5; // Daha hızlı\n    }\n\n    // Loads images for different states and directions from resources\n    public void loadImages() {\n        try {\n            reptileWest = ImageIO.read(getClass().getResourceAsStream(\"/zombies/reptileWest.png\"));\n            reptileEast = ImageIO.read(getClass().getResourceAsStream(\"/zombies/reptileEast.png\"));\n            reptileWestJump = ImageIO.read(getClass().getResourceAsStream(\"/zombies/reptileWestJump.png\"));\n            reptileEastJump = ImageIO.read(getClass().getResourceAsStream(\"/zombies/reptileEastJump.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Updates zombie state each frame including movement and special feature\n    @Override\n    public void update() {\n        super.update();\n        feature(); // Apply special jumping feature\n    }\n\n    // Handles attacking the player with cooldown and range checks\n    @Override\n    public void hit() {\n        long currentTime = System.currentTimeMillis(); // Şu anki zamanı al\n\n        // Cooldown kontrolü\n        if (currentTime - lastHitTime >= cooldownTime&&(Math.abs(gp.p.worldX - worldX) < 2 * gp.tileSize || Math.abs(gp.p.worldY - worldY) < 2 * gp.tileSize)) {\n            // Cooldown süresi doldu, hasar verebilir\n            player.health -= damage;\n            lastHitTime = currentTime; // Son hasar zamanını güncelle\n\n            System.out.println(\"Oyuncuya \" + damage + \" hasar verildi! Kalan can: \" + player.health);\n        } else {\n            // Cooldown süresi dolmadı, hasar veremez\n            System.out.println(\"Hasar verme cooldown'da! Lütfen bekleyin...\");\n        }\n    }\n\n    // Special ability: Changes image to jumping animation when close to player\n    @Override\n    public void feature() {\n        double distanceToPlayer = Math.sqrt(Math.pow(p.worldX - worldX, 2) + Math.pow(p.worldY - worldY, 2));\n\n        // Eşik mesafesi (örneğin, 2 tile boyutu)\n        double thresholdDistance = 2 * gp.tileSize;\n\n        // Eğer zombi oyuncuya yakınsa\n        if (distanceToPlayer < thresholdDistance) {\n            // Oyuncuya hasar ver\n            hit();\n\n            // Resmi zıplama animasyonuna değiştir\n            if (worldX >= gp.p.worldX) {\n                image = reptileWestJump;\n            } else {\n                image = reptileEastJump;\n            }\n        }else{\n            // Eğer zombi oyuncudan uzaksa, resmi eski haline getir\n            if (worldX >= gp.p.worldX) {\n                image = reptileWest;\n            } else {\n                image = reptileEast;\n            }\n        }\n    }\n}",
      "TankZombie.java": "//This game was made by Efe Selim Surekli.\npackage entity;\n\nimport main.GamePanel;\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\npublic class TankZombie extends zombies {\n    private long lastHitTime = 0; // Son hasar zamanını tutar\n    public long cooldownTime = 1000; // Cooldown süresi (mil\n\n    private BufferedImage tankWest; // Batıya bakan tank zombi resmi\n    private BufferedImage tankEast; // Doğuya bakan tank zombi resmi\n\n    // Constructor: Initializes TankZombie with game panel reference and sets properties\n    public TankZombie(GamePanel gp) {\n        super(gp);\n        this.score=500;\n        this.healt = 500;\n        this.damage = 100;\n        this.speed = 1.5;\n\n        // Resimleri yükle\n        loadImages();\n    }\n\n    // Loads images for both directions from resources\n    private void loadImages() {\n        try {\n            tankWest = ImageIO.read(getClass().getResourceAsStream(\"/zombies/tankWest.png\"));\n            tankEast = ImageIO.read(getClass().getResourceAsStream(\"/zombies/tankEast.png\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Updates zombie state each frame including movement and facing direction\n    @Override\n    public void update() {\n        super.update(); // Üst sınıfın update metodunu çağır (varsa ek işlemler için)\n\n        // Savaşçının konumuna göre yönü güncelle\n        if (worldX >= gp.p.worldX) {\n            image = tankWest; // Batıya bak\n        } else {\n            image = tankEast; // Doğuya bak\n        }\n    }\n\n    // Handles attacking the player with cooldown and high damage\n    @Override\n    public void hit() {\n        long currentTime = System.currentTimeMillis(); // Şu anki zamanı al\n\n        // Cooldown kontrolü\n        if (currentTime - lastHitTime >= cooldownTime&&(Math.abs(gp.p.worldX - worldX) < 2 * gp.tileSize || Math.abs(gp.p.worldY - worldY) < 2 * gp.tileSize)) {\n            // Cooldown süresi doldu, hasar verebilir\n            player.health -= damage;\n            lastHitTime = currentTime; // Son hasar zamanını güncelle\n\n            System.out.println(\"Oyuncuya \" + damage + \" hasar verildi! Kalan can: \" + player.health);\n        } else {\n            // Cooldown süresi dolmadı, hasar veremez\n        }\n    }\n\n    // Special ability - Tank zombie has none (empty implementation)\n    @Override\n    public void feature() {\n    }\n}",
      "assetSetter.java": "//This game was made by Efe Selim Surekli.\npackage main;\n\nimport objects.*;\nimport entity.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\n// Handles spawning of zombies and setting up game assets\npublic class assetSetter {\n\n    public int count = 0;\n\n    // Enum defining different types of zombies\n    public enum ZombieType {\n        NORMAL,\n        ACID,\n        TANK,\n        REPTILE\n    }\n\n    public GamePanel gp;\n\n    // Constructor: Initializes with game panel reference\n    public assetSetter(GamePanel gp) {\n        this.gp = gp;\n        this.gp.zombiesList = new ArrayList<>();\n        this.gp.gunList = new ArrayList<>();\n    }\n\n    // Spawns zombies based on current round and difficulty\n    public void setZombies() {\n        // Set zombie count based on round\n        switch (gp.Round) {\n            case 1:\n                count = 10;\n                break;\n            case 2:\n                gp.p.gunList.add(new rifle());\n                count = 10;\n                break;\n            case 3:\n                count = 10;\n                break;\n            case 4:\n                gp.p.gunList.add(new shotgun());\n                count = 15;\n                break;\n            case 5:\n                count = 20;\n                break;\n            case 6:\n                gp.p.gunList.add(new sniper());\n                count = 20;\n                break;\n            case 7:\n                count = 25;\n                break;\n            case 8:\n                count = 25;\n                break;\n            case 9:\n                count = 25;\n                break;\n            case 10:\n                count = 30;\n                break;\n            case 11:\n                gp.p.gunList.add(new rocket());\n                count = 30;\n                break;\n            case 12:\n                count = 30;\n                break;\n            case 13:\n                count = 40;\n                break;\n            case 14:\n                count = 40;\n                break;\n            case 15:\n                count = 40;\n                break;\n            case 16:\n                System.exit(15);\n            default:\n                System.out.println(\"Geçersiz round!\");\n                return;\n        }\n\n        // Randomly select and create zombies\n        Random random = new Random();\n        for (int i = 0; i < count; i++) {\n            // Determine available zombie types based on round\n            List<ZombieType> availableZombieTypes = new ArrayList<>();\n            if (gp.Round >= 1) {\n                availableZombieTypes.add(ZombieType.NORMAL);\n            }\n            if (gp.Round >= 4) {\n                availableZombieTypes.add(ZombieType.ACID);\n            }\n            if (gp.Round >= 6) {\n                availableZombieTypes.add(ZombieType.REPTILE);\n            }\n            if (gp.Round >= 11) {\n                availableZombieTypes.add(ZombieType.TANK);\n            }\n\n            // Randomly select zombie type\n            ZombieType zombieType = availableZombieTypes.get(random.nextInt(availableZombieTypes.size()));\n\n            // Generate random positions\n            int worldX = random.nextInt(gp.worldWidth);\n            int worldY = random.nextInt(gp.worldHeight);\n\n            // Create zombie based on type\n            zombies zombie;\n            switch (zombieType) {\n                case NORMAL:\n                    zombie = new NormalZombie(gp);\n                    break;\n                case ACID:\n                    zombie = new AcidZombie(gp);\n                    break;\n                case TANK:\n                    zombie = new TankZombie(gp);\n                    break;\n                case REPTILE:\n                    zombie = new reptileZombie(gp);\n                    break;\n                default:\n                    throw new IllegalStateException(\"Geçersiz zombi türü: \" + zombieType);\n            }\n\n            // Set zombie position\n            zombie.worldX = worldX;\n            zombie.worldY = worldY;\n\n            // Add zombie to list\n            gp.zombiesList.add(zombie);\n        }\n\n        System.out.println(\"Round \" + gp.Round + \" için \" + count + \" zombi başarıyla eklendi. Toplam: \" + gp.zombiesList.size());\n    }\n}",
      "GamePanel.java": "//This game was made by Efe Selim Surekli.\npackage main;\n\nimport entity.*;\nimport objects.*;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.io.Serializable;\nimport java.util.ArrayList;\n\n// Main game panel that handles rendering, game loop, and game state\npublic class GamePanel extends JPanel implements Runnable, Serializable {\n\n    public int PauseState;\n    public int PlayState;\n    boolean isZombiesDead;\n    public int GameState;\n    public final int TitleState = 0;\n\n    // Game world settings\n    public int tileSize = 48;\n    public ArrayList<zombies> zombiesList;\n    public ArrayList<bulletObjects> bulletList;\n    public mouseHandler mouseHandler = new mouseHandler();\n    public int maxWorldCol = 100;\n    public final int maxWorldRow = 100;\n    public int worldWidth = maxWorldCol * tileSize;\n    public final int worldHeight = maxWorldRow * tileSize;\n    public int screenWidth = tileSize * 20;\n    public int screenHeight = tileSize * 16;\n    public int Round;\n    public ArrayList<guns> gunList;\n    Thread gameThread;\n    public assetSetter aSetter = new assetSetter(this);\n\n    public player p;\n\n    // Game performance\n    int FPS = 120;\n\n    // Game systems\n    public KeyHandler keyH = new KeyHandler(this);\n    TileManager tm = new TileManager(this);\n    public collisionChechker cC = new collisionChechker(this);\n    public UI ui=new UI(this);\n    public int index;\n\n    // Constructor: Sets up game panel and initializes components\n    GamePanel() {\n        this.Round=0;\n        this.isZombiesDead=false;\n        this.zombiesList = new ArrayList<>();\n        this.bulletList = new ArrayList<>();\n        this.gunList=new ArrayList<>();\n\n        p = new player(this, keyH, mouseHandler);\n        this.setPreferredSize(new Dimension(screenWidth, screenHeight));\n        this.setBackground(Color.BLACK);\n        this.addKeyListener(keyH);\n        this.addMouseListener(mouseHandler);\n        this.setDoubleBuffered(true);\n        this.setFocusable(true);\n        startGameThread();\n    }\n\n    // Initializes game state and spawns zombies\n    public void setUpGame() {\n        aSetter.setZombies();\n        GameState = TitleState;\n        if(GameState!=TitleState||GameState!=PauseState){\n            GameState=PlayState;\n        }\n    }\n\n    // Draws Heads-Up Display with player stats\n    public void drawHUD(Graphics g) {\n        // Draw semi-transparent background panels\n        g.setColor(new Color(0, 100, 100, 150));\n\n        // Left panel (weapon info)\n        g.fillRect(10, 10, 200, 90);\n\n        // Right panel (health/score)\n        g.fillRect(getWidth() - 210, 10, 200, 90);\n\n        // Draw borders\n        g.setColor(Color.WHITE);\n        g.drawRect(10, 10, 200, 90);\n        g.drawRect(getWidth() - 210, 10, 200, 90);\n\n        // Set text properties\n        g.setColor(Color.white);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 16));\n\n        // Draw weapon info\n        g.drawString(\"Weapon: \" + p.currentGun.name, 20, 40);\n        g.drawString(\"Ammo: \" + p.currentGun.getBullets()+ \" / \" +(p.currentGun.magazine*p.currentGun.bulletCapacity), 20, 60);\n        if (p.currentGun.image != null) {\n            g.drawImage(p.currentGun.image, 20, 70, 50, 30, null);\n        } else {\n            g.drawString(\"No Image\", 20, 70);\n        }\n\n        // Draw player stats\n        g.drawString(\"Health: \" + player.health, getWidth() - 190, 40);\n        g.drawString(\"Score: \" + player.score, getWidth() - 190, 60);\n        g.drawString(\"Round : \" + Round+ \" /15\", getWidth() - 190, 80);\n    }\n\n    // Main rendering method\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2 = (Graphics2D) g;\n\n        // Draw game elements in order\n        tm.draw(g2); // Tiles/background\n        drawHUD(g2); // Player HUD\n\n        // Draw all zombies\n        for (zombies z : zombiesList) {\n            if (z != null) z.draw(g2);\n        }\n\n        // Draw all bullets\n        for (bulletObjects bullet : bulletList) {\n            if(p.currentGun instanceof shotgun){\n                for(int i=0;i<9;i++){\n                    bullet.draw(g2);\n                }\n            } else {\n                bullet.draw(g2);\n            }\n        }\n\n        p.draw(g2); // Player\n        g2.dispose();\n    }\n\n    // Main game update loop\n    public void update() {\n        if ((keyH.isPaused)) {\n            // Handle pause menu input\n            ui.checkPauseMenuInput();\n        } else {\n            // Normal game updates\n            zombieAndLootController();\n            p.update();\n        }\n    }\n\n    // Manages zombie behavior and loot drops\n    void zombieAndLootController(){\n        // Check zombie-zombie collisions\n        for (int i = 0; i < zombiesList.size(); i++) {\n            for (int j = i + 1; j < zombiesList.size(); j++) {\n                cC.checkZombieCollision(zombiesList.get(i), zombiesList.get(j));\n            }\n        }\n\n        // Update zombies and check deaths\n        boolean allZombiesDead = true;\n\n        for (int i = 0; i < zombiesList.size(); i++) {\n            zombies z = zombiesList.get(i);\n            if (z.healt <= 0) {\n                zombiesList.remove(i);\n                player.score+=z.score;\n                i--;\n\n                // Handle loot drops based on zombie type\n                if (z instanceof NormalZombie) {\n                    if (shouldBulletDrop()&&Round>=2) {\n                        p.gunList.get(1).magazine++;\n                    }\n                } else if (z instanceof AcidZombie) {\n                    if (shouldBulletDrop()) {\n                        p.gunList.get(2).magazine++;\n                    }\n                } else if (z instanceof reptileZombie) {\n                    if (shouldBulletDrop()) {\n                        p.gunList.get(1).magazine++;\n                        p.gunList.get(2).magazine++;\n                        p.gunList.get(3).magazine++;\n                    }\n                } else if (z instanceof TankZombie) {\n                    if (shouldBulletDrop()) {\n                        p.gunList.get(3).magazine++;\n                        p.gunList.get(4).magazine++;\n                    }\n                }\n                System.out.println(\"Zombie öldü! Kalan zombie sayısı: \" + zombiesList.size());\n            } else {\n                z.update();\n                allZombiesDead = false;\n            }\n        }\n\n        // Advance round if all zombies dead\n        if (allZombiesDead && zombiesList.isEmpty()) {\n            Round++;\n            player.health += 50;\n            System.out.println(\"Tüm zombiler öldü! Yeni round: \" + Round);\n            aSetter.setZombies();\n        }\n    }\n\n    // Starts the game thread\n    public void startGameThread() {\n        System.out.println(\"startGameThread() called!\");\n\n        if (gameThread != null) {\n            System.out.println(\"GameThread is already running!\");\n            return;\n        }\n\n        gameThread = new Thread(this);\n        gameThread.start();\n        System.out.println(\"GameThread started!\");\n    }\n\n    // Main game loop\n    @Override\n    public void run() {\n        double drawInterval = (double) 1_000_000_000 / FPS; // 0.01666 seconds\n        double delta = 0;\n        long lastTime = System.nanoTime();\n        long currentTime;\n        long timer = 0;\n        long drawCount = 0;\n\n        while (gameThread != null) {\n            currentTime = System.nanoTime();\n            delta += (currentTime - lastTime) / drawInterval;\n            timer += (currentTime - lastTime);\n            lastTime = currentTime;\n\n            if (delta >= 1) {\n                update();\n                repaint();\n                delta--;\n                drawCount++;\n            }\n\n            if (timer >= 1000000000) {\n                System.out.println(\"FPS : \" + drawCount);\n                timer=0;\n                drawCount=0;\n            }\n        }\n    }\n\n    // Determines if loot should drop (25% chance)\n    public boolean shouldBulletDrop() {\n        return Math.random() < 0.25;\n    }\n}",
      "UI.java": "//This game was made by Efe Selim Surekli.\npackage main;\n\nimport objects.*;\nimport entity.player;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n// Handles all user interface elements including menus, HUD, and game states\npublic class UI {\n    GamePanel gp;\n\n    // Constructor: Initializes with game panel reference\n    public UI(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    // Draws the pause screen overlay with menu options\n    public void drawPauseScreen(Graphics2D g2) {\n        // Darken background\n        g2.setColor(new Color(0, 0, 0, 150)); // Semi-transparent black\n        g2.fillRect(0, 0, gp.screenWidth, gp.screenHeight);\n\n        // \"PAUSED\" text\n        String text = \"PAUSED\";\n        int x = getXforCenteredText(g2, text, gp.screenWidth);\n        int y = gp.screenHeight / 2 - 50;\n        g2.setColor(Color.WHITE);\n        g2.setFont(new Font(\"Courier New\", Font.BOLD, 50));\n        g2.drawString(text, x, y);\n\n        // \"Continue\" option\n        text = \"P: Devam Et\";\n        x = getXforCenteredText(g2, text, gp.screenWidth);\n        y += 60;\n        g2.drawString(text, x, y);\n\n        // \"Save Game\" option\n        text = \"2: Oyunu Kaydet\";\n        x = getXforCenteredText(g2, text, gp.screenWidth);\n        y += 60;\n        g2.drawString(text, x, y);\n    }\n\n    // Handles input while in pause menu\n    public void checkPauseMenuInput() {\n        if (gp.keyH.num1Pressed) {\n            gp.GameState = gp.PlayState; // Resume game\n            gp.keyH.num1Pressed = false; // Reset key state\n        }\n        if (gp.keyH.num2Pressed) {\n            saveGame(); // Save game\n            gp.keyH.num2Pressed = false; // Reset key state\n        }\n    }\n\n    // Saves game state to file\n    public void saveGame() {\n        try (FileWriter writer = new FileWriter(\"saved_game.txt\")) {\n            // Save player info\n            writer.write(\"Score: \" + gp.p.score + \"\\n\");\n            writer.write(\"Health: \" + gp.p.health + \"\\n\");\n            writer.write(\"Round: \" + gp.Round + \"\\n\");\n\n            // Save weapon info\n            for (guns gun : gp.gunList) {\n                writer.write(\"Weapon: \" + gun.name + \"\\n\");\n                writer.write(\"Damage: \" + gun.damage + \"\\n\");\n                writer.write(\"BulletCapacity: \" + gun.bulletCapacity + \"\\n\");\n                writer.write(\"Magazine: \" + gun.magazine + \"\\n\");\n                writer.write(\"FireRate: \" + gun.fireRate + \"\\n\");\n                writer.write(\"Bullets: \" + gun.bullets + \"\\n\");\n                writer.write(\"Image: \" + gun.getImagePath() + \"\\n\");\n            }\n\n            JOptionPane.showMessageDialog(null, \"Oyun kaydedildi!\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Oyun kaydedilirken hata oluştu!\");\n        }\n    }\n\n    // Loads game state from file\n    public void loadGame() {\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"saved_game.txt\"))) {\n            String line;\n            guns currentGun = null;\n            if(gp.Round>=2)\n                gp.gunList.add(new rifle());\n            if(gp.Round>=4)\n                gp.gunList.add(new shotgun());\n            if(gp.Round>=6)\n                gp.gunList.add(new sniper());\n            if(gp.Round>=11)\n                gp.gunList.add(new rocket());\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"Score: \")) {\n                    player.score = Integer.parseInt(line.substring(7));\n                } else if (line.startsWith(\"Health: \")) {\n                    player.health = Integer.parseInt(line.substring(8));\n                } else if (line.startsWith(\"Round: \")) {\n                    gp.Round = Integer.parseInt(line.substring(7));\n                } else if (line.startsWith(\"Weapon: \")) {\n                    String name = line.substring(8);\n                    currentGun = new guns(0, 0, 0, 0, name, \"\");\n                    gp.gunList.add(currentGun);\n                } else if (line.startsWith(\"Damage: \")) {\n                    if (gp.p.currentGun != null) {\n                        gp.p.currentGun.damage = Integer.parseInt(line.substring(8));\n                    }\n                } else if (line.startsWith(\"BulletCapacity: \")) {\n                    if (currentGun != null) {\n                        gp.p.currentGun.bulletCapacity = Integer.parseInt(line.substring(16));\n                    }\n                } else if (line.startsWith(\"Magazine: \")) {\n                    if (currentGun != null) {\n                        gp.p.currentGun.magazine = Integer.parseInt(line.substring(10));\n                    }\n                } else if (line.startsWith(\"FireRate: \")) {\n                    if (currentGun != null) {\n                        gp.p.currentGun.fireRate = Integer.parseInt(line.substring(10));\n                    }\n                } else if (line.startsWith(\"Bullets: \")) {\n                    if (currentGun != null) {\n                        gp.p.currentGun.bullets = Integer.parseInt(line.substring(9));\n                    }\n                } else if (line.startsWith(\"Image: \")) {\n                    if (currentGun != null) {\n                        gp.p.currentGun.imagePath = line.substring(7);\n                        gp.p.currentGun.loadImage();\n                    }\n                }\n            }\n\n            JOptionPane.showMessageDialog(null, \"Oyun yüklendi!\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            JOptionPane.showMessageDialog(null, \"Oyun yüklenirken hata oluştu!\");\n        }\n    }\n\n    // Calculates X position to center text on screen\n    public int getXforCenteredText(Graphics2D g2, String text, int screenWidth) {\n        int length = (int) g2.getFontMetrics().getStringBounds(text, g2).getWidth();\n        return screenWidth / 2 - length / 2;\n    }\n\n    // Displays main menu with game options\n    public static void showMenu() {\n        JFrame menuFrame = new JFrame(\"Zombi Avı Oyunu - Menü\");\n\n        menuFrame.setSize(900, 700);\n        menuFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        menuFrame.setResizable(true);\n        menuFrame.setLocationRelativeTo(null);\n\n        // Create menu panel\n        JMenuBar menuBar = new JMenuBar();\n        menuBar.setLayout(new BoxLayout(menuBar, BoxLayout.Y_AXIS));\n        menuBar.setBackground(Color.BLACK);\n\n        Font font = new Font(\"MV Boli\", Font.BOLD, 30);\n\n        // \"New Game\" button\n        JButton yeni = new JButton(\"NEW GAME\");\n        yeni.setFont(font);\n        yeni.setForeground(Color.WHITE);\n        yeni.setAlignmentX(Component.CENTER_ALIGNMENT);\n        yeni.setContentAreaFilled(false);\n        yeni.setBorderPainted(false);\n        yeni.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                menuFrame.dispose();\n                startGame(false);\n            }\n        });\n\n        // \"Load Game\" button\n        JButton eski = new JButton(\"LOAD GAME\");\n        eski.setFont(font);\n        eski.setForeground(Color.WHITE);\n        eski.setAlignmentX(Component.CENTER_ALIGNMENT);\n        eski.setContentAreaFilled(false);\n        eski.setBorderPainted(false);\n        eski.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                menuFrame.dispose();\n                startGame(true);\n            }\n        });\n\n        // \"Quit\" button\n        JButton cikisButton = new JButton(\"QUIT\");\n        cikisButton.setFont(font);\n        cikisButton.setForeground(Color.WHITE);\n        cikisButton.setAlignmentX(Component.CENTER_ALIGNMENT);\n        cikisButton.setContentAreaFilled(false);\n        cikisButton.setBorderPainted(false);\n        cikisButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                System.exit(0);\n            }\n        });\n\n        // Game title label\n        JLabel okLabel = new JLabel(\"Zombie Hunting Game\");\n        okLabel.setFont(font);\n        okLabel.setForeground(Color.WHITE);\n        okLabel.setAlignmentX(Component.CENTER_ALIGNMENT);\n\n        // Tutorial text\n        JTextArea tutorial = new JTextArea();\n        tutorial.setSize(100, 100);\n        tutorial.setEditable(false);\n        tutorial.setOpaque(true);\n        tutorial.setFocusable(false);\n        String text = \" W : UP \\t\\t 2 : Save Game \\n S : DOWN \\t\\t Q : Switch Gun \\n A : LEFT \\t\\t R : Reload \\n D : RIGHT \\t\\t P : Pause Game \";\n        tutorial.setText(text);\n        tutorial.setAlignmentX(Component.CENTER_ALIGNMENT);\n        tutorial.setFont(font);\n        tutorial.setBackground(Color.BLACK);\n        tutorial.setForeground(Color.WHITE);\n        okLabel.setAlignmentX(Component.CENTER_ALIGNMENT);\n\n        // Add components to menu\n        menuBar.add(okLabel);\n        menuBar.add(Box.createVerticalStrut(100));\n        menuBar.add(yeni);\n        menuBar.add(Box.createVerticalStrut(20));\n        menuBar.add(eski);\n        menuBar.add(Box.createVerticalStrut(20));\n        menuBar.add(cikisButton);\n        menuBar.add(Box.createVerticalStrut(20));\n        menuBar.add(tutorial);\n\n        menuFrame.add(menuBar);\n        menuFrame.setVisible(true);\n    }\n\n    // Starts the game with specified mode (new or loaded)\n    public static void startGame(boolean loadSavedGame) {\n        JFrame gameFrame = new JFrame(\"Zombi Avı Oyunu\");\n        gameFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        gameFrame.setResizable(false);\n\n        GamePanel gamePanel = new GamePanel();\n        gameFrame.add(gamePanel);\n\n        gameFrame.pack();\n        gameFrame.setLocationRelativeTo(null);\n        gameFrame.setVisible(true);\n\n        if (loadSavedGame) {\n            gamePanel.ui.loadGame();\n        } else {\n            gamePanel.setUpGame();\n        }\n\n        gamePanel.startGameThread();\n    }\n}",
      "KeyHandler.java": "//This game was made by Efe Selim Surekli.\npackage main;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\n// Handles keyboard input for player controls\npublic class KeyHandler implements KeyListener {\n    public boolean upPressed;\n    public boolean downPressed;\n    public boolean leftPressed;\n    public boolean rightPressed;\n    public boolean takeItem=true;\n    public boolean reloading;\n    public boolean isPaused =false;\n    public boolean num1Pressed;\n    public boolean num2Pressed;\n\n    GamePanel gp;\n\n    // Constructor: Initializes with game panel reference\n    public KeyHandler(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    // Handles key press events\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int code = e.getKeyCode();\n        if(code==KeyEvent.VK_P){\n            if(isPaused){\n                gp.GameState=gp.PauseState;\n                isPaused=false;}\n            else\n                isPaused=true;\n        }\n        if(code==KeyEvent.VK_2){\n            num2Pressed=true;\n        }\n\n        if (code == KeyEvent.VK_W){\n            upPressed = true;\n        }\n        if (code == KeyEvent.VK_A){\n            leftPressed = true;\n        }\n        if (code == KeyEvent.VK_D){\n            rightPressed = true;\n        }\n        if (code == KeyEvent.VK_S){\n            downPressed = true;\n        }\n        if (code == KeyEvent.VK_E){\n            takeItem = true;\n        }\n        if (code == KeyEvent.VK_Q) {\n            gp.index++;\n            gp.index %= gp.p.gunList.size(); // Cycle through weapons\n            gp.p.currentGun = gp.p.gunList.get(gp.index);\n        }\n        if (code == KeyEvent.VK_R) {\n            reloading = true;\n        }\n    }\n\n    // Handles key release events\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int code = e.getKeyCode();\n\n        if (code == KeyEvent.VK_W){\n            upPressed = false;\n        }\n        if (code == KeyEvent.VK_A){\n            leftPressed = false;}\n        if (code == KeyEvent.VK_D){\n            rightPressed = false;\n        }\n        if (code == KeyEvent.VK_S){\n            downPressed = false;\n        }\n        if (code == KeyEvent.VK_E){\n            takeItem = false;\n        }\n        if (code == KeyEvent.VK_R){\n            reloading = false;\n        }\n    }\n\n    // Not used\n    @Override\n    public void keyTyped(KeyEvent e) {\n        // Kullanılmıyor.\n    }\n}",
      "Game.java": "//This game was made by Efe Selim Surekli.\npackage main;\n\npublic class Game {\n\n    public static void main(String[] args) {\n        // Show the main menu when game starts\n        UI.showMenu();\n    }\n}",
      "mouseHandler.java": "//This game was made by Efe Selim Surekli.\npackage main;\n\nimport javax.swing.*;\nimport java.awt.event.*;\n\n// Handles mouse input for shooting and aiming\npublic class mouseHandler extends JFrame implements MouseListener {\n\n    public int mouseX,mouseY;\n    public boolean isPressed;\n\n    // Constructor\n    public mouseHandler() {}\n\n    // Not used\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        // kullanılmıyor\n    }\n\n    // Handles mouse button press (for shooting)\n    @Override\n    public void mousePressed(MouseEvent e) {\n        if (e.getButton() == MouseEvent.BUTTON1) { // Left mouse button\n            isPressed = true;\n            this.mouseX=e.getX();\n            this.mouseY=e.getY();\n            System.out.println(\"Mouse basıldı\");\n        }\n    }\n\n    // Handles mouse button release\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        if (e.getButton() == MouseEvent.BUTTON1) { // Left mouse button\n            isPressed = false;\n        }\n    }\n\n    // Returns mouse pressed state\n    public boolean isPressed() {\n        System.out.println(\"is pressed çalışıyor\");\n        return isPressed;\n    }\n\n    // Not used\n    @Override\n    public void mouseEntered(MouseEvent e) {\n        // kullanılmıyor.\n    }\n\n    // Not used\n    @Override\n    public void mouseExited(MouseEvent e) {\n        // kullanılmıyor.\n    }\n}",
      "collisionChechker.java": "//This game was made by Efe Selim Surekli.\npackage main;\n\nimport entity.player;\nimport entity.zombies;\nimport java.awt.*;\n\n// Handles collision detection between game entities\npublic class collisionChechker {\n    GamePanel GP; // Reference to game panel\n\n    // Constructor: Initializes with game panel reference\n    public collisionChechker(GamePanel GP) {\n        this.GP = GP;\n    }\n\n    /**\n     * Checks tile collisions for player movement\n     * @param player The player entity to check collisions for\n     */\n    public void checkTile(player player) {\n        // Calculate player's collision box boundaries in world coordinates\n        int playerLeftWorldX = (player.worldX + player.solidArea.x);\n        int playerRightWorldX = (player.worldX + player.solidArea.x + player.solidArea.width);\n        int playerTopWorldY = (player.worldY + player.solidArea.y);\n        int playerBottomWorldY = (player.worldY + player.solidArea.y + player.solidArea.height);\n\n        // Convert to tile coordinates\n        int playerLeftCol = playerLeftWorldX / GP.tileSize;\n        int playerRightCol = playerRightWorldX / GP.tileSize;\n        int playerTopRow = playerTopWorldY / GP.tileSize;\n        int playerBottomRow = playerBottomWorldY / GP.tileSize;\n\n        int tileNum1, tileNum2;\n\n        // Check collision based on movement direction\n        switch (player.direction) {\n            case \"down\":\n                // Check tiles below player\n                playerBottomRow = (playerBottomWorldY + entity.player.speed) / GP.tileSize;\n                tileNum1 = GP.tm.mapTileNum[playerLeftCol][playerBottomRow];\n                tileNum2 = GP.tm.mapTileNum[playerRightCol][playerBottomRow];\n                if (GP.tm.tiles[tileNum1].collision || GP.tm.tiles[tileNum2].collision) {\n                    player.collisionOn = true;\n                }\n                break;\n            // ... other direction cases ...\n        }\n    }\n\n    /**\n     * Checks and resolves collisions between two zombies\n     * @param zombie1 First zombie to check\n     * @param zombie2 Second zombie to check\n     */\n    public void checkZombieCollision(zombies zombie1, zombies zombie2) {\n        // Create collision rectangles for both zombies\n        Rectangle z1 = new Rectangle(zombie1.worldX, zombie1.worldY, GP.tileSize, GP.tileSize);\n        Rectangle z2 = new Rectangle(zombie2.worldX, zombie2.worldY, GP.tileSize, GP.tileSize);\n\n        if (z1.intersects(z2)) {\n            // Calculate overlap amounts\n            double overlapX = Math.min(z1.getMaxX() - z2.getX(), z2.getMaxX() - z1.getX());\n            double overlapY = Math.min(z1.getMaxY() - z2.getY(), z2.getMaxY() - z1.getY());\n\n            // Push zombies apart based on smallest overlap\n            if (overlapX < overlapY) {\n                // Horizontal push\n                if (z1.getCenterX() < z2.getCenterX()) {\n                    zombie1.worldX -= overlapX / 2;\n                    zombie2.worldX += overlapX / 2;\n                } else {\n                    zombie1.worldX += overlapX / 2;\n                    zombie2.worldX -= overlapX / 2;\n                }\n            } else {\n                // Vertical push\n                if (z1.getCenterY() < z2.getCenterY()) {\n                    zombie1.worldY -= overlapY / 2;\n                    zombie2.worldY += overlapY / 2;\n                } else {\n                    zombie1.worldY += overlapY / 2;\n                    zombie2.worldY -= overlapY / 2;\n                }\n            }\n        }\n    }\n}",
      "TileManager.java": "//This game was made by Efe Selim Surekli.\npackage main;\n\nimport javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\n// Manages game tiles and map loading\npublic class TileManager {\n    public Tiles[] tiles;\n    GamePanel gp;\n    public int[][] mapTileNum;\n\n    // Tile class definition\n    public static class Tiles {\n        public boolean collision = false;\n        BufferedImage image;\n    }\n\n    // Constructor: Initializes with game panel reference\n    public TileManager(GamePanel gp) {\n        this.gp = gp;\n        tiles = new Tiles[4];\n        mapTileNum = new int[gp.maxWorldCol][gp.maxWorldRow];\n\n        getTileImage();\n        loadMap(\"/maps/worldMap\");\n    }\n\n    // Loads tile images from resources\n    public void getTileImage() {\n        try {\n            tiles[0] = new Tiles();\n            tiles[0].image = ImageIO.read(getClass().getResourceAsStream(\"/tiles/wall.png\"));\n            tiles[0].collision=true;\n\n            tiles[1] = new Tiles();\n            tiles[1].image = ImageIO.read(getClass().getResourceAsStream(\"/tiles/grass.png\"));\n\n        } catch (IOException e) {\n            e.printStackTrace();\n            e.getMessage();\n        }\n    }\n\n    // Loads map data from file\n    public void loadMap(String filePath) {\n        try {\n            InputStream stream = getClass().getResourceAsStream(filePath);\n            BufferedReader br = new BufferedReader(new InputStreamReader(stream));\n\n            int row = 0;\n            while (row < 60) {\n                String line = br.readLine();\n                if (line == null) break;  // Exit if line is empty\n\n                String[] numbers = line.split(\" \");\n                for (int col = 0; col < 60; col++) {\n                    if (col < numbers.length) {\n                        mapTileNum[col][row] = Integer.parseInt(numbers[col]);\n                    } else {\n                        mapTileNum[col][row] = 0;  // Default to 0\n                    }\n                }\n                row++;\n            }\n\n            br.close();\n        } catch (Exception e) {\n            System.out.println(\"filepath bulunamadı\");\n            e.printStackTrace();\n        }\n    }\n\n    // Draws tiles on screen\n    public void draw(Graphics2D g2) {\n        int worldCol = 0;\n        int worldRow = 0;\n\n        while (worldCol < gp.maxWorldCol && worldRow < gp.maxWorldRow) {\n            int tileNum = mapTileNum[worldCol][worldRow];\n\n            // Check if tile number is within bounds\n            if (tileNum >= 0 && tileNum < tiles.length) {\n                int worldX = worldCol * gp.tileSize;\n                int worldY = worldRow * gp.tileSize;\n                double ScreenX = worldX - gp.p.worldX + gp.p.screenX;\n                double ScreenY = worldY - gp.p.worldY + gp.p.screenY;\n\n                // Only draw tiles that are visible on screen\n                if (worldX + gp.tileSize > gp.p.worldX - gp.p.screenX &&\n                        worldX - gp.tileSize < gp.p.worldX + gp.p.screenX &&\n                        worldY + gp.tileSize > gp.p.worldY - gp.p.screenY &&\n                        worldY - gp.tileSize < gp.p.worldY + gp.p.screenY) {\n\n                    g2.drawImage(tiles[tileNum].image, (int) ScreenX, (int) ScreenY, gp.tileSize, gp.tileSize, null);\n                }\n            }\n            worldCol++;\n\n            if (worldCol == gp.maxWorldCol) {\n                worldCol = 0;\n                worldRow++;\n            }\n        }\n    }\n}",
      "rifle.java": "//This game was made by Efe Selim Surekli.\npackage objects;\n\n\npublic class rifle extends guns {\n    public rifle() {\n        super(50,30, 2, 600,  \"rifle\",\"/player/rifle.png\"); // 30 mermi, 2 şarjör, 600 RPM\n\n    }\n\n\n}",
      "shotgun.java": "//This game was made by Efe Selim Surekli.\npackage objects;\npublic class shotgun extends guns {\n    public shotgun() {\n        super(50, 5, 2, 60, \"shotgun\", \"/player/shotgun.png\"); // 5 mermi, 2 şarjör, 60 RPM\n    }\n}",
      "rocket.java": "//This game was made by Efe Selim Surekli.\npackage objects;\n\npublic class rocket extends guns {\n    public rocket() {\n        super(1000,1, 2, 10, \"rocket\",\"/player/rocket.png\"); // 1 mermi, 2 şarjör, 10 RPM\n\n    }\n\n}",
      "bulletObjects.java": "//This game was made by Efe Selim Surekli.\npackage objects;\n\nimport main.GamePanel;\nimport entity.zombies;\nimport java.awt.Rectangle;\nimport javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\n// Represents a bullet/projectile in the game with movement and collision logic\npublic class bulletObjects {\n    public BufferedImage image;\n    public int worldX, worldY; // Bullet's world position\n    public double targetX;\n    public double targetY; // Target position for bullet trajectory\n    public double directionX;\n    public double directionY; // Movement direction vector\n    public int speed = 5; // Movement speed\n    public boolean active = false; // Whether bullet is active/flying\n    private GamePanel gp;\n\n    // Constructor: Initializes bullet with start position, target, and game reference\n    public bulletObjects(int startX, int startY, double targetX, double targetY, GamePanel gp) {\n        this.worldX = startX;\n        this.worldY = startY;\n        this.targetX = targetX;\n        this.targetY = targetY;\n        this.gp = gp;\n\n        // Calculate initial trajectory\n        calculateDirection();\n\n        // Load appropriate bullet image\n        loadImage();\n    }\n\n    // Calculates movement direction based on target position\n    private void calculateDirection() {\n        double angle = Math.atan2(targetY - worldY, targetX - worldX); // Angle to target\n        this.directionX = Math.cos(angle); // X component of direction\n        this.directionY = Math.sin(angle); // Y component of direction\n    }\n\n    // Loads bullet image based on current weapon type\n    private void loadImage() {\n        try {\n            if (gp.p.currentGun instanceof pistol) {\n                image = ImageIO.read(getClass().getResourceAsStream(\"/ammos/pistolBullet.png\"));\n            } else if (gp.p.currentGun instanceof rifle) {\n                image = ImageIO.read(getClass().getResourceAsStream(\"/ammos/rifleBullet.png\"));\n            } else if (gp.p.currentGun instanceof shotgun) {\n                image = ImageIO.read(getClass().getResourceAsStream(\"/ammos/shotgunBullet.png\"));\n            } else if (gp.p.currentGun instanceof sniper) {\n                image = ImageIO.read(getClass().getResourceAsStream(\"/ammos/sniperBullet.png\"));\n            } else if (gp.p.currentGun instanceof rocket) {\n                image = ImageIO.read(getClass().getResourceAsStream(\"/ammos/rocketBullet.png\"));\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Updates bullet position and handles weapon-specific behavior\n    public void update() {\n        // Activate bullet on mouse click\n        if (gp.mouseHandler.isPressed && !active) {\n            // Rifle-specific behavior (bullet spread)\n            if (gp.p.currentGun instanceof rifle) {\n                active = true;\n                int mouseX = gp.mouseHandler.mouseX;\n                int mouseY = gp.mouseHandler.mouseY;\n                int playerScreenX = gp.p.screenX;\n                int playerScreenY = gp.p.screenY;\n\n                worldX = gp.p.worldX;\n                worldY = gp.p.worldY;\n                targetX = mouseX - playerScreenX + gp.p.worldX;\n                targetY = mouseY - playerScreenY + gp.p.worldY;\n\n                double angle = Math.atan2(targetY - worldY, targetX - worldX);\n                // Add random spread for rifle bullets\n                double spreadAngle = Math.toRadians(30);\n                double randomSpread = (Math.random() - 0.5) * spreadAngle;\n                angle += randomSpread;\n\n                directionX = Math.cos(angle);\n                directionY = Math.sin(angle);\n            }\n            // Shotgun-specific behavior (wider spread)\n            else if (gp.p.currentGun instanceof shotgun) {\n                active = true;\n                int mouseX = gp.mouseHandler.mouseX;\n                int mouseY = gp.mouseHandler.mouseY;\n                int playerScreenX = gp.p.screenX;\n                int playerScreenY = gp.p.screenY;\n\n                worldX = gp.p.worldX;\n                worldY = gp.p.worldY;\n                targetX = mouseX - playerScreenX + gp.p.worldX;\n                targetY = mouseY - playerScreenY + gp.p.worldY;\n\n                double mainAngle = Math.atan2(targetY - worldY, targetX - worldX);\n                double spreadAngle = Math.toRadians(90);\n                double randomSpread = (Math.random() - 0.5) * spreadAngle;\n                double angle = mainAngle + randomSpread;\n\n                directionX = Math.cos(angle);\n                directionY = Math.sin(angle);\n            }\n            // Default bullet behavior (no spread)\n            else  {\n                active = true;\n                int mouseX = gp.mouseHandler.mouseX;\n                int mouseY = gp.mouseHandler.mouseY;\n                int playerScreenX = gp.p.screenX;\n                int playerScreenY = gp.p.screenY;\n\n                worldX = gp.p.worldX;\n                worldY = gp.p.worldY;\n                targetX = mouseX - playerScreenX + gp.p.worldX;\n                targetY = mouseY - playerScreenY + gp.p.worldY;\n\n                double angle = Math.atan2(targetY - worldY, targetX - worldX);\n                directionX = Math.cos(angle);\n                directionY = Math.sin(angle);\n            }\n        }\n\n        // Move active bullet\n        if (active) {\n            worldX += directionX * speed;\n            worldY += directionY * speed;\n        }\n    }\n\n    // Draws bullet on screen with camera offset\n    public void draw(Graphics2D g2) {\n        if (active && image != null) {\n            int screenX = worldX - gp.p.worldX + gp.p.screenX;\n            int screenY = worldY - gp.p.worldY + gp.p.screenY;\n\n            if (screenX >= 0 && screenX <= gp.screenWidth && screenY >= 0 && screenY <= gp.screenHeight) {\n                g2.drawImage(image, screenX, screenY, null);\n            }\n        } else {\n            System.out.println(\"Mermi görseli null!\");\n        }\n    }\n\n    // Checks collision with zombies and applies damage\n    public boolean checkCollision(zombies zombie) {\n        Rectangle bulletRect = new Rectangle(worldX, worldY, 10, 10);\n        Rectangle zombieRect = new Rectangle(zombie.worldX, zombie.worldY, gp.tileSize, gp.tileSize);\n\n        if (bulletRect.intersects(zombieRect)) {\n            zombie.takeDamage(gp.p.currentGun.damage);\n            return true;\n        }\n        return false;\n    }\n}",
      "guns.java": "//This game was made by Efe Selim Surekli.\npackage objects;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\n// Base class for all weapon types with common properties and behaviors\npublic class guns {\n public int damage;\n public int magazine;\n public int bulletCapacity; // Max bullets per magazine\n public int bullets; // Current bullets in magazine\n public int fireRate; // Rounds per minute\n public String name; // Weapon name\n public BufferedImage image; // Weapon sprite\n public String imagePath; // Path to sprite image\n\n // Constructor: Initializes weapon properties\n public guns(int damage,int bulletCapacity, int magazine, int fireRate, String name,String imagePath) {\n  this.damage=damage;\n  this.bulletCapacity = bulletCapacity;\n  this.magazine = magazine;\n  this.fireRate = fireRate;\n  this.name = name;\n  this.bullets = bulletCapacity;\n  this.imagePath = imagePath;\n  loadImage();\n }\n\n // Loads weapon image from resources\n public void loadImage() {\n  try {\n   image = ImageIO.read(getClass().getResourceAsStream(imagePath));\n  } catch (IOException e) {\n   e.printStackTrace();\n  }\n }\n\n // Returns image path for saving/loading\n public String getImagePath() {\n  return imagePath;\n }\n\n // Returns current bullet count\n public int getBullets() {\n  return bullets;\n }\n\n // Sets bullet count (with validation)\n public void setBullets(int bullets) {\n  this.bullets = bullets;\n }\n\n // Returns magazine count\n public int getMagazine() {\n  return magazine;\n }\n\n // Checks if weapon can be reloaded\n public boolean canReload() {\n  return magazine > 0;\n }\n\n // Reloads weapon by filling magazine\n public void reload() {\n  if (magazine > 0) {\n   int neededBullets = bulletCapacity - bullets;\n   int bulletsToAdd = Math.min(neededBullets, bulletCapacity);\n\n   if (bulletsToAdd > 0) {\n    bullets += bulletsToAdd;\n    magazine--;\n   }\n  }\n }\n\n // Returns weapon image\n public BufferedImage getImage() {\n  return image;\n }\n\n // Checks if weapon can shoot\n public boolean canShoot() {\n  return bullets > 0;\n }\n}",
      "pistol.java": "//This game was made by Efe Selim Surekli.\npackage objects;\npublic class pistol extends guns {\n    public pistol() {\n        super(50, 12, 1000, 120, \"pistol\", \"/player/pistol.png\"); // 30 mermi, 2 şarjör, 600 RPM\n\n    }\n}",
      "sniper.java": "//This game was made by Efe Selim Surekli.\npackage objects;\npublic class sniper extends guns {\n    public sniper() {\n        super(100,5, 2, 30,  \"sniper\",\"/player/sniper.png\"); // 5 mermi, 2 şarjör, 30 RPM\n    }\n}"
    },
    {
      "id": "9905145",
      "Projectile.java": "package entity;\n\nimport main.GamePanel;\n\npublic class Projectile extends Entity {\n\n    Entity user;\n    public double angle;\n\n    public Projectile(GamePanel gp) {\n        super(gp);\n    }\n\n    public void set(int worldX, int worldY, double angle, boolean alive, Entity user) {\n\n        this.angle = angle;\n        this.alive = alive;\n        this.user = user;\n        this.life = this.maxLife;\n\n        this.worldX = worldX;\n        this.worldY = worldY;\n    }\n\n    public void update() {\n\n        if(user != gp.player) {\n            boolean contactPlayer = gp.cChecker.checkPlayer(this);\n            if(gp.player.invincible == false && contactPlayer == true) {\n                damagePlayer(attack);\n                alive = false;\n            }\n        }\n\n        if (user == gp.player) {\n            int monsterIndex = gp.cChecker.checkEntity(this, gp.monster);\n            if (monsterIndex != 999) {\n                gp.player.damageMonster(monsterIndex,attack);\n                alive = false;\n            }\n        }\n\n        worldX += (int) (Math.cos(angle) * speed);\n        worldY += (int) (Math.sin(angle) * speed);\n\n        life--;\n        if (life <= 0) {\n            alive = false;\n        }\n    }\n}\n",
      "Entity.java": "package entity;\n\nimport main.*;\nimport monster.*;\n\nimport javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.Random;\n\npublic class Entity {\n\n    public int cooldownTime = 0;\n    public long lastFiredTime = 0;\n    public boolean spawnDelayActive = false;\n    public long spawnStartTime = 0;\n    public final long spawnDelay = 1000;\n\n    public int fireRate;\n    public int currentAmmo;\n    public int score = 0;\n\n    public GamePanel gp;\n    public int worldX,worldY;\n    public int speed;\n    public String direction = \"down\";\n    public double angle;\n    public Rectangle solidArea = new Rectangle(0,0,48,48);\n    public Rectangle attackArea = new Rectangle(0,0,0,0);\n    public boolean collisionOn = false;\n    public int solidAreaDefaultX, solidAreaDefaultY;\n    public int actionLockCounter = 0;\n    public boolean invincible = false;\n    public int invincibleCounter = 0;\n    public boolean attacking = false;\n    public int attackCounter = 0;\n    public boolean alive = true;\n    public boolean dying = false;\n    public int dyingCounter = 0;\n    public boolean hpBarOn = false;\n    public int hpBarCounter = 0;\n\n    public int ammoValue;\n    public int type; // 0 = player, 1 = monster\n    public int value;\n    public int attackValue;\n    public String description = \"\";\n    public int attack = 0;\n    public BufferedImage image;\n    public String name;\n    public boolean collision = false;\n    public boolean onPath = false;\n\n    public int shotAvailableCounter = 0;\n    public int asitCounter = 0;\n    public Projectile projectile;\n    public Entity currentWeapon;\n    public int maxLife;\n    public int life;\n    public BufferedImage playerimage;\n    public BufferedImage playerimage2;\n    public BufferedImage playerimage3;\n    public BufferedImage playerAttackImage;\n\n    public Entity(GamePanel gp) {\n        this.gp = gp;\n    }\n    public void setAction() {}\n    public void use (Entity entity) {}\n    public void checkDrop() {}\n    public void dropItem (Entity droppedItem) {\n\n        for (int i = 0; i < gp.ammo.length; i++) {\n\n            if (gp.ammo[i] == null) {\n                gp.ammo[i] = droppedItem;\n                gp.ammo[i].worldX = worldX;\n                gp.ammo[i].worldY = worldY;\n                break;\n            }\n        }\n    }\n\n    public void checkCollision () {\n\n        collisionOn = false;\n        gp.cChecker.checkTile(this);\n        gp.cChecker.checkObject(this,false);\n        gp.cChecker.checkEntity(this,gp.monster);\n        boolean contactPlayer = gp.cChecker.checkPlayer(this);\n\n        if(this.type == 1 &&  contactPlayer == true) {\n            damagePlayer(attack);\n        }\n    }\n\n    public void update() {\n\n        if (spawnDelayActive) {\n            long elapsed = System.currentTimeMillis() - spawnStartTime;\n            if (elapsed < spawnDelay) {\n                return;\n            } else {\n                spawnDelayActive = false;\n            }\n        }\n\n        setAction();\n        checkCollision();\n\n        if(attacking == true) {\n            attacking();\n        }\n\n        if (collisionOn == false) {\n\n            switch (direction) {\n                case \"up\": worldY -= speed; break;\n                case \"down\": worldY += speed; break;\n                case \"left\": worldX -= speed; break;\n                case \"right\": worldX += speed; break;\n            }\n        }\n\n        if(invincible == true) {\n            invincibleCounter++;\n            if(invincibleCounter > 30) {\n                invincible = false;\n                invincibleCounter = 0;\n            }\n        }\n\n        if(shotAvailableCounter < 60) {\n            shotAvailableCounter++;\n        }\n    }\n\n    public void attacking() {\n        attackCounter++;\n\n        if(attackCounter > 5 && attackCounter >= 25){\n            int currentWorldX = worldX;\n            int currentWorldY = worldY;\n            int solidAreaWidth = solidArea.width;\n            int solidAreaHeight = solidArea.height;\n\n            switch (direction) {\n                case \"up\": worldY -= attackArea.height; break;\n                case \"down\": worldY += attackArea.height; break;\n                case \"left\": worldX -= attackArea.width; break;\n                case \"right\": worldX += attackArea.width; break;\n            }\n\n            solidArea.width = attackArea.width;\n            solidArea.height = attackArea.height;\n\n            if(type == 1) {\n                if(gp.cChecker.checkPlayer(this) == true) {\n                    damagePlayer(attack);\n                }\n            }\n            else{\n                int monsterIndex = gp.cChecker.checkEntity(this, gp.monster);\n                gp.player.damageMonster(monsterIndex, attack);\n            }\n\n            worldX = currentWorldX;\n            worldY = currentWorldY;\n            solidArea.width = solidAreaWidth;\n            solidArea.height = solidAreaHeight;\n        }\n        if(attackCounter > 25) {\n            attackCounter = 0;\n            attacking = false;\n        }\n    }\n\n    public void damagePlayer(int attack) {\n        if(gp.player.invincible == false) {\n            gp.player.life -= attack;\n            gp.player.invincible = true;\n        }\n    }\n\n    public void checkAttackOrNot (int rate, int straight, int horizontal) {\n\n        boolean targetInRange = false;\n        int xDis = gp.player.worldX;\n        int yDis = gp.player.worldY;\n\n        switch (direction) {\n            case \"up\":\n                if(gp.player.worldY < worldY && yDis < straight && xDis < horizontal) {\n                    targetInRange = true;\n                }\n                break;\n            case \"down\":\n                if(gp.player.worldY > worldY && yDis < straight && xDis < horizontal) {\n                    targetInRange = true;\n                }\n                break;\n            case \"left\":\n                if(gp.player.worldY < worldY && xDis < straight && yDis < horizontal) {\n                    targetInRange = true;\n                }\n                break;\n            case \"right\":\n                if(gp.player.worldY > worldY && xDis < straight && yDis < horizontal) {\n                    targetInRange = true;\n                }\n                break;\n        }\n\n        if(targetInRange == true) {\n            int i = new Random().nextInt(rate);\n            if (i == 0) {\n                attacking = true;\n                shotAvailableCounter = 0;\n            }\n        }\n\n    }\n\n    public void draw(Graphics2D g2) {\n\n        int screenX = worldX - gp.player.worldX + gp.player.screenX;\n        int screenY = worldY - gp.player.worldY + gp.player.screenY;\n\n        if(worldX + gp.tileSize > gp.player.worldX - gp.player.screenX &&\n                worldX - gp.tileSize < gp.player.worldX + gp.player.screenX &&\n                worldY + gp.tileSize > gp.player.worldY - gp.player.screenY &&\n                worldY - gp.tileSize < gp.player.worldY + gp.player.screenY) {\n\n            if(this instanceof AsitTukurenZombi || this instanceof NormalZombi\n                || this instanceof SurungeZombi || this instanceof TankZombi) {\n\n                g2.translate(screenX + gp.tileSize / 2, screenY + gp.tileSize / 2);\n                g2.rotate(angle + Math.PI * 3 / 2);\n                g2.drawImage(image, -gp.tileSize / 2, -gp.tileSize / 2, gp.tileSize, gp.tileSize, null);\n                g2.rotate(-angle - Math.PI * 3 / 2);\n                g2.translate(-screenX - gp.tileSize / 2, -screenY - gp.tileSize / 2);\n            }\n            else {\n                g2.drawImage(image,screenX,screenY,gp.tileSize,gp.tileSize,null);\n            }\n        }\n\n        //monster hp bar\n        if(hpBarOn == true && type == 1) {\n\n            double oneScale = (double) gp.tileSize / maxLife;\n            double hpBarValue = oneScale * life;\n\n            g2.setColor(new Color(35, 35, 35));\n            g2.fillRect(screenX - 1, screenY - 16, gp.tileSize + 2, 12);\n            g2.setColor(new Color(255, 0, 30));\n            g2.fillRect(screenX, screenY - 15, (int) hpBarValue, 10);\n\n            hpBarCounter++;\n            if(hpBarCounter > 600) {\n                hpBarCounter = 0;\n                hpBarOn = false;\n            }\n        }\n\n        if(invincible == true) {\n            hpBarOn = true;\n            hpBarCounter = 0;\n            changeAlpha(g2,0.4f);\n        }\n\n        if(dying == true) {\n            dyingAnimation(g2);\n        }\n\n        changeAlpha(g2,1F);\n    }\n\n    public void dyingAnimation(Graphics2D g2) {\n\n        dyingCounter++;\n\n        if (collisionOn) {\n            collisionOn = false;\n            solidArea = new Rectangle(0, 0, 0, 0);\n        }\n\n        int i = 5;\n\n        if(dyingCounter <= i) {changeAlpha(g2,0f);}\n        if(dyingCounter > i && dyingCounter <= i*2) {changeAlpha(g2,1f);}\n        if(dyingCounter > i*2 && dyingCounter <= i*3) {changeAlpha(g2,0f);}\n        if(dyingCounter > i*3 && dyingCounter <= i*4) {changeAlpha(g2,1f);}\n        if(dyingCounter > i*4 && dyingCounter <= i*5) {changeAlpha(g2,0f);}\n        if(dyingCounter > i*5 && dyingCounter <= i*6) {changeAlpha(g2,1f);}\n        if(dyingCounter > i*6 && dyingCounter <= i*7) {changeAlpha(g2,0f);}\n        if(dyingCounter > i*7 && dyingCounter <= i*8) {changeAlpha(g2,1f);}\n        if(dyingCounter > i*8) {\n            alive = false;\n        }\n    }\n\n    public void changeAlpha(Graphics2D g2, float alphaValue) {\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,alphaValue));\n    }\n\n    public BufferedImage setup(String imagePath) {\n        UtilityTool uTool = new UtilityTool();\n        BufferedImage image = null;\n\n        try {\n            image = ImageIO.read(getClass().getResourceAsStream(imagePath + \".png\"));\n            image = uTool.scaleImage(image,gp.tileSize,gp.tileSize);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return image;\n    }\n\n    public void fire(double angle,int i, int i1) {\n    }\n\n    public boolean canFire() {\n        return System.currentTimeMillis() - lastFiredTime >= cooldownTime;\n    }\n\n    public boolean willCollideAfterJump(int jumpX, int jumpY) {\n        Rectangle futureArea = new Rectangle(\n                worldX + solidArea.x + jumpX,\n                worldY + solidArea.y + jumpY,\n                solidArea.width,\n                solidArea.height\n        );\n\n        Rectangle playerArea = new Rectangle(\n                gp.player.worldX + gp.player.solidArea.x,\n                gp.player.worldY + gp.player.solidArea.y,\n                gp.player.solidArea.width,\n                gp.player.solidArea.height\n        );\n\n        return futureArea.intersects(playerArea);\n    }\n}\n",
      "Firing.java": "package entity;\n\nimport gun.*;\nimport main.GamePanel;\nimport entity.Player;\n\nimport java.awt.*;\n\nimport monster.AsitTukurenZombi;\n\npublic class Firing extends Projectile {\n\n    GamePanel gp;\n\n    public Firing(GamePanel gp,int attackValue) {\n        super(gp);\n        this.gp = gp;\n\n        speed = 5;\n        name = \"Mermi\";\n        alive = false;\n        maxLife = 80;\n        this.attack = attackValue;\n        getImage();\n    }\n\n    public void getImage() {\n        if(gp.player != null) {\n            if (gp.player.currentWeapon instanceof Tabanca) {\n                image = setup(\"/res/Guns/Firing_Tabanca\");\n            }\n            if (gp.player.currentWeapon instanceof Tufek) {\n                image = setup(\"/res/Guns/Firing_Tufek\");\n            }\n            if (gp.player.currentWeapon instanceof PompaliTufek) {\n                image = setup(\"/res/Guns/Firing_Pompali\");\n            }\n            if (gp.player.currentWeapon instanceof KeskinNisanciTufek) {\n                image = setup(\"/res/Guns/Firing_Sniper\");\n            }\n            if (gp.player.currentWeapon instanceof Roketatar) {\n                image = setup(\"/res/Guns/Firing_Rocket\");\n            }\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        int screenX = worldX - gp.player.worldX + gp.player.screenX;\n        int screenY = worldY - gp.player.worldY + gp.player.screenY;\n\n        if (alive) {\n            g2.translate(screenX + gp.tileSize / 2, screenY + gp.tileSize / 2);\n            g2.rotate(angle);\n            g2.drawImage(image, -gp.tileSize / 2, -gp.tileSize / 2, gp.tileSize, gp.tileSize, null);\n            g2.rotate(-angle);\n            g2.translate(-screenX - gp.tileSize / 2, -screenY - gp.tileSize / 2);\n        }\n    }\n\n\n    public void update() {\n        if (!alive) return;\n\n        worldX += Math.cos(angle) * speed;\n        worldY += Math.sin(angle) * speed;\n\n        for (int i = 0; i < gp.monster.length; i++) {\n            if (gp.monster[i] != null && gp.monster[i].alive) {\n                Rectangle bulletBounds = new Rectangle(worldX, worldY, gp.tileSize / 4, gp.tileSize / 4);\n                Rectangle monsterBounds = new Rectangle(\n                        gp.monster[i].worldX,\n                        gp.monster[i].worldY,\n                        gp.monster[i].solidArea.width,\n                        gp.monster[i].solidArea.height\n                );\n\n                if (bulletBounds.intersects(monsterBounds) && gp.monster[i] != user) {\n                    gp.monster[i].life -= attack;\n                    gp.player.damageMonster(i, attack);\n                    if (gp.monster[i].life <= 0) {\n                        gp.monster[i].dying = true;\n                    }\n                    if (user instanceof Roketatar) {\n                        ((Roketatar) user).explode(worldX, worldY);\n                    }\n                    if(!(user instanceof KeskinNisanciTufek)) {\n                        alive = false;\n                        return;\n                    }\n                }\n            }\n        }\n\n        life--;\n        if (life <= 0) {\n            alive = false;\n        }\n\n        if (user instanceof AsitTukurenZombi) {\n\n            boolean contactPlayer = gp.cChecker.checkPlayer(this);\n            if (!gp.player.invincible && contactPlayer) {\n                damagePlayer(attack);\n                alive = false;\n            }\n        }\n    }\n}",
      "Player.java": "package entity;\n\nimport main.*;\nimport gun.*;\nimport object.*;\nimport monster.*;\n\nimport javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\npublic class Player extends Entity {\n    GamePanel gp;\n    KeyHandler keyH;\n    MouseHandler mouseH;\n    public final int screenX;\n    public final int screenY;\n    public ArrayList<Entity> inventory = new ArrayList<>();\n    public final int maxInventorySize = 5;\n    public int hasTabancaAmmo = 12;\n    public int hasPiyadeAmmo = 90;\n    public int hasPompaliAmmo = 30;\n    public int hasSniperAmmo = 15;\n    public int hasRoketAmmo = 5;\n\n    public Player(GamePanel gp, KeyHandler keyH, MouseHandler mouseH) {\n\n        super(gp);\n        this.gp = gp;\n        this.keyH = keyH;\n        this.mouseH = mouseH;\n\n        screenX = gp.screenWidth/2 - (gp.tileSize/2);\n        screenY = gp.screenHeight/2 - (gp.tileSize/2);\n\n        solidArea = new Rectangle();\n        solidArea.x = 8;\n        solidArea.y = 16;\n        solidArea.width = 32;\n        solidArea.height = 32;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n\n        attackArea.width = 36;\n        attackArea.height = 36;\n\n        setDefaultValues();\n        getPlayerImage();\n        setItems();\n    }\n\n    public void setDefaultValues() {\n        worldX = gp.tileSize * 16;\n        worldY = gp.tileSize * 12;\n        direction = \"down\";\n        speed = 5;\n        angle = 0;\n        maxLife = 100;\n        life = maxLife;\n        projectile = new Firing(gp,attackValue);\n        currentWeapon = new Tabanca(gp);\n        attack = getAttack();\n    }\n\n    public void setDefaultPositions() {\n        worldX = gp.tileSize * 16;\n        worldY = gp.tileSize * 12;\n        direction = \"down\";\n    }\n\n    public void restoreLife() {\n        life = maxLife;\n        invincible = false;\n    }\n\n    public void setItems() {\n        inventory.clear();\n        inventory.add(currentWeapon);\n    }\n\n    public int getAttack() {\n        attackArea = currentWeapon.attackArea;\n        return attack = currentWeapon.attackValue;\n    }\n\n    public int getCurrentWeaponSlot() {\n        int currentWeaponSlot = 0;\n        for(int i = 0; i < inventory.size(); i++) {\n            if(inventory.get(i) == currentWeapon) {\n                currentWeaponSlot = i;\n            }\n        }\n        return currentWeaponSlot;\n    }\n\n    public void getPlayerImage() {\n\n        playerimage = setup(\"playerimage\");\n        playerimage2 = setup(\"playerimage2\");\n        playerimage3 = setup(\"playerimage3\");\n\n    }\n\n    public void getPlayerAttackImage() {\n\n        playerAttackImage = setup(\"playerimage\"); // attack image i buraya koy\n    }\n\n    public BufferedImage setup(String imageName){\n        UtilityTool uTool = new UtilityTool();\n        BufferedImage image = null;\n\n        try {\n            image = ImageIO.read(getClass().getResourceAsStream(\"/res/Player/\" + imageName + \".png\"));\n            image = uTool.scaleImage(image,gp.tileSize,gp.tileSize);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return image;\n    }\n\n    public void update() {\n\n        double moveX = 0;\n        double moveY = 0;\n\n        if (keyH.upPressed == true){\n            moveY -= 1;\n            direction = \"up\";\n        }\n        if (keyH.downPressed == true) {\n            moveY += 1;\n            direction = \"down\";\n        }\n        if (keyH.leftPressed == true) {\n            moveX -= 1;\n            direction = \"left\";\n        }\n        if (keyH.rightPressed == true) {\n            moveX += 1;\n            direction = \"right\";\n        }\n        if (mouseH.mousePressed == true) {\n            attacking = true;\n        }\n\n        collisionOn = false;\n        gp.cChecker.checkTile(this);\n\n        int ammoIndex = gp.cChecker.checkObject(this,true);\n        pickUpObject(ammoIndex);\n\n        int monsterIndex = gp.cChecker.checkEntity(this,gp.monster);\n        contactMonster(monsterIndex);\n\n        //çarpaz gitme hızını düşürme\n        if (moveX != 0 && moveY != 0) {\n            double length = Math.sqrt(moveX * moveX + moveY * moveY);\n            moveX = (moveX / length) * speed;\n            moveY = (moveY / length) * speed;\n        } else {\n            moveX *= speed;\n            moveY *= speed;\n        }\n\n        if (!collisionOn) {\n            worldX += moveX;\n            worldY += moveY;\n        }\n\n       /*if (moveX < 0 && !gp.cChecker.isBlockedInDirection(this, \"left\")) {\n            worldX += moveX;\n        }\n        if (moveX > 0 && !gp.cChecker.isBlockedInDirection(this, \"right\")) {\n            worldX += moveX;\n        }\n        if (moveY < 0 && !gp.cChecker.isBlockedInDirection(this, \"up\")) {\n            worldY += moveY;\n        }\n        if (moveY > 0 && !gp.cChecker.isBlockedInDirection(this, \"down\")) {\n            worldY += moveY;\n        }*/\n\n        // Mouse'a dönme\n        int dx = mouseH.mouseX - (screenX + gp.tileSize / 2);\n        int dy = mouseH.mouseY - (screenY + gp.tileSize / 2);\n        angle = Math.atan2(dy, dx);\n\n        // Mermi sıkma mekanizması\n        if (mouseH.mousePressed && shotAvailableCounter >= currentWeapon.fireRate) {\n            currentWeapon.fire(angle, worldX + solidArea.width / 2, worldY + solidArea.height / 2);\n            shotAvailableCounter = 0;\n        }\n\n        if(invincible == true) {\n            invincibleCounter++;\n            if(invincibleCounter > 60) {\n                invincible = false;\n                invincibleCounter = 0;\n            }\n        }\n\n        if(shotAvailableCounter < 60) {\n            shotAvailableCounter++;\n        }\n\n        if(life > maxLife) {\n            life = maxLife;\n        }\n\n        if(life <= 0) {\n            gp.gameState = gp.gameOverState;\n            gp.ui.commandNum = -1;\n            gp.stopMusic();\n            gp.playSE(3);\n        }\n    }\n\n    public void pickUpObject(int i) {\n\n        if(i != -1 && gp.ammo[i] != null) {\n\n            Entity pickedItem = gp.ammo[i];\n            if(pickedItem instanceof PompaliAmmo) {\n                hasPompaliAmmo += 5;\n                gp.ui.showMessage(\"Pompalı Tüfek Mermisi Alındı! +5\");\n                gp.ammo[i].use(this);\n            }\n            else if(pickedItem instanceof PiyadeAmmo) {\n                hasPiyadeAmmo += 30;\n                gp.ui.showMessage(\"Piyade Tüfeği Mermisi Alındı! +30\");\n                gp.ammo[i].use(this);\n            }\n            else if(pickedItem instanceof  Health) {\n                gp.player.life += 30;\n                gp.ui.showMessage(\"30 Can İyileştirildi!\");\n                gp.ammo[i].use(this);\n            }\n            else if (pickedItem instanceof SniperAmmo) {\n                hasSniperAmmo += 5; // Sniper için 3 mermi ekle\n                gp.ui.showMessage(\"Keskin Nişancı Mermisi Alındı! +5\");\n                gp.ammo[i].use(this);\n            } else if (pickedItem instanceof RoketAmmo) {\n                hasRoketAmmo += 1; // Roketatar için 1 mermi ekle\n                gp.ui.showMessage(\"Roketatar Mermisi Alındı! +1\");\n                gp.ammo[i].use(this);\n            }\n            gp.ammo[i] = null;\n        }\n    }\n\n    public void contactMonster (int i) {\n        if(i != -1) {\n            if(invincible == false && gp.monster[i].dying == false) {\n                life -= gp.monster[i].attack;\n                invincible = true;\n            }\n        }\n    }\n\n    public void damageMonster (int i,int attack) {\n        if(i != 999) {\n            if(gp.monster[i].invincible == false) {\n\n                gp.monster[i].life -= attack;\n                gp.monster[i].invincible = true;\n\n                if(gp.monster[i].life <= 0){\n                    if (gp.monster[i] instanceof AsitTukurenZombi) {\n                        ((AsitTukurenZombi) gp.monster[i]).die(); // Patlama efekti\n                    }\n                    gp.monster[i].dying = true;\n                    if(gp.monster[i] instanceof NormalZombi){\n                        score += 100;\n                    }\n                    else if(gp.monster[i] instanceof AsitTukurenZombi){\n                        score += 200;\n                    }\n                    else if(gp.monster[i] instanceof SurungeZombi){\n                        score += 300;\n                    }\n                    else if(gp.monster[i] instanceof TankZombi){\n                        score += 400;\n                    }\n                    gp.monster[i].dying = true;\n                    gp.monster[i].collisionOn = false;\n                    gp.monster[i].solidArea = new Rectangle(0, 0, 0, 0);\n                }\n            }\n        }\n        else {\n        }\n    }\n\n    public void selectItem () {\n\n        int itemIndex = gp.ui.getItemIndexOnSlot();\n\n        if(itemIndex < inventory.size()) {\n            Entity selectedItem = inventory.get(itemIndex);\n            currentWeapon = selectedItem;\n            attack = getAttack();\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        BufferedImage image = null;\n        //karakter görseli seçimi\n        if (currentWeapon instanceof Tabanca) {\n            image = playerimage;\n        }\n        else if (currentWeapon instanceof Tufek || currentWeapon instanceof KeskinNisanciTufek) {\n            image = playerimage2;\n        }\n        else if (currentWeapon instanceof PompaliTufek || currentWeapon instanceof Roketatar) {\n            image = playerimage3;\n        }\n        int tempScreenX = screenX;\n        int tempScreenY = screenY;\n\n        g2.translate(screenX + gp.tileSize / 2, screenY + gp.tileSize / 2);\n        g2.rotate(angle);\n        g2.drawImage(image, -gp.tileSize / 2, -gp.tileSize / 2,null);\n        g2.rotate(-angle);\n        g2.translate(-screenX - gp.tileSize / 2, -screenY - gp.tileSize / 2);\n    }\n\n    public void reload() {\n        if (currentWeapon instanceof Tabanca) {\n            gp.player.currentWeapon.currentAmmo = 12;\n        } else if (currentWeapon instanceof Tufek) {\n            if (gp.player.currentWeapon.currentAmmo < 30) {\n                int neededAmmo = 30 - gp.player.currentWeapon.currentAmmo;\n                if (gp.player.hasPiyadeAmmo >= neededAmmo) {\n                    gp.player.currentWeapon.currentAmmo += neededAmmo;\n                    gp.player.hasPiyadeAmmo -= neededAmmo;\n                } else {\n                    gp.player.currentWeapon.currentAmmo += gp.player.hasPiyadeAmmo;\n                    gp.player.hasPiyadeAmmo = 0;\n                }\n            }\n        } else if (currentWeapon instanceof PompaliTufek) {\n            if (gp.player.currentWeapon.currentAmmo < 5) {\n                int neededAmmo = 5 - gp.player.currentWeapon.currentAmmo;\n                if (gp.player.hasPompaliAmmo >= neededAmmo) {\n                    gp.player.currentWeapon.currentAmmo += neededAmmo;\n                    gp.player.hasPompaliAmmo -= neededAmmo;\n                } else {\n                    gp.player.currentWeapon.currentAmmo += gp.player.hasPompaliAmmo;\n                    gp.player.hasPompaliAmmo = 0;\n                }\n            }\n        } else if (currentWeapon instanceof KeskinNisanciTufek) {\n            if (gp.player.currentWeapon.currentAmmo < 5) {\n                int neededAmmo = 5 - gp.player.currentWeapon.currentAmmo;\n                if (gp.player.hasSniperAmmo >= neededAmmo) {\n                    gp.player.currentWeapon.currentAmmo += neededAmmo;\n                    gp.player.hasSniperAmmo -= neededAmmo;\n                } else {\n                    gp.player.currentWeapon.currentAmmo += gp.player.hasSniperAmmo;\n                    gp.player.hasSniperAmmo = 0;\n                }\n            }\n        } else if (currentWeapon instanceof Roketatar) {\n            if (gp.player.currentWeapon.currentAmmo == 0 && gp.player.hasRoketAmmo > 0) {\n                gp.player.currentWeapon.currentAmmo = 1;\n                gp.player.hasRoketAmmo--;\n            }\n        }\n    }\n\n\n    public int getTotalAmmo(Entity weapon) {\n        if (weapon instanceof Tabanca) {\n            return hasTabancaAmmo;\n        } else if (weapon instanceof Tufek) {\n            return hasPiyadeAmmo;\n        } else if (weapon instanceof PompaliTufek) {\n            return hasPompaliAmmo;\n        } else if (weapon instanceof KeskinNisanciTufek) {\n            return hasSniperAmmo;\n        } else if (weapon instanceof Roketatar) {\n            return hasRoketAmmo;\n        }\n        return 0;\n    }\n}",
      "Config.java": "package main;\n\nimport java.io.*;\n\npublic class Config {\n\n    GamePanel gp;\n\n    public Config(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    public void saveConfig () {\n\n        try {\n\n            BufferedWriter bw = new BufferedWriter(new FileWriter(\"config.txt\"));\n\n            //full screen\n            if(gp.fullScreenOn == true) {\n                bw.write(\"On\");\n            }\n            if(gp.fullScreenOn == false) {\n                bw.write(\"Off\");\n            }\n            bw.newLine();\n\n            //music volume\n            bw.write(String.valueOf(gp.music.volumeScale));\n            bw.newLine();\n\n            //Sound effect volume\n            bw.write(String.valueOf(gp.se.volumeScale));\n            bw.newLine();\n\n            bw.close();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public void loadConfig () {\n\n        try {\n\n            BufferedReader br = new BufferedReader(new FileReader(\"config.txt\"));\n\n            String s = br.readLine();\n\n            //full screen\n            if(s.equals(\"On\")) {\n                gp.fullScreenOn = true;\n            }\n            if(s.equals(\"Off\")) {\n                gp.fullScreenOn = false;\n            }\n\n            //music volume\n            s = br.readLine();\n            gp.music.volumeScale = Integer.parseInt(s);\n\n            //sound effect volume\n            s = br.readLine();\n            gp.se.volumeScale = Integer.parseInt(s);\n\n            br.close();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
      "Sound.java": "package main;\n\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport javax.sound.sampled.FloatControl;\nimport java.net.URL;\n\npublic class Sound {\n\n    Clip clip;\n    URL soundURL[] = new URL[30];\n    FloatControl fc;\n    int volumeScale = 3;\n    float volume;\n\n    public Sound () {\n        soundURL[0] = getClass().getResource(\"/res/sound/zombiee.wav\");\n        soundURL[1] = getClass().getResource(\"/res/sound/gameover.wav\");\n        soundURL[2] = getClass().getResource(\"/res/sound/cursor.wav\");\n        soundURL[3] = getClass().getResource(\"/res/sound/receivedamage.wav\");\n    }\n\n    public void setFile(int i) {\n        try {\n            AudioInputStream ais = AudioSystem.getAudioInputStream(soundURL[i]);\n            clip = AudioSystem.getClip();\n            clip.open(ais);\n            fc = (FloatControl)clip.getControl(FloatControl.Type.MASTER_GAIN);\n            checkVolume();\n\n        } catch (Exception e) {\n\n        }\n    }\n\n    public void play() {\n        clip.start();\n    }\n\n    public void loop() {\n        clip.loop(Clip.LOOP_CONTINUOUSLY);\n    }\n\n    public void stop() {\n        clip.stop();\n    }\n\n    public void checkVolume() {\n\n        switch (volumeScale) {\n            case 0: volume = -80f; break;\n            case 1: volume = -20f; break;\n            case 2: volume = -12f; break;\n            case 3: volume = -5f; break;\n            case 4: volume = 1f; break;\n            case 5: volume = 6f; break;\n        }\n        fc.setValue(volume);\n    }\n}\n",
      "UtilityTool.java": "package main;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class UtilityTool {\n    public BufferedImage scaleImage(BufferedImage original,int width, int height) {\n\n        BufferedImage scaledImage = new BufferedImage(width,height,original.getType());\n        Graphics2D g2 = scaledImage.createGraphics();\n        g2.drawImage(original,0,0,width,height,null);\n        g2.dispose();\n\n        return scaledImage;\n    }\n}\n",
      "GamePanel.java": "package main;\n\nimport data.*;\nimport environment.*;\nimport tile.*;\nimport entity.*;\nimport gun.*;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\npublic class GamePanel extends JPanel implements Runnable {\n\n    public int currentWave = 0;\n\n    //Screen Settings\n    final int originalTileSize = 16;\n    final int scale = 3;\n\n    public final int tileSize = originalTileSize * scale;\n    public final int maxScreenCol = 32;\n    public final int maxScreenRow = 24;\n    public final int screenWidth = tileSize * maxScreenCol;\n    public final int screenHeight = tileSize * maxScreenRow;\n\n    public final int maxWorldCol = 64;\n    public final int maxWorldRow = 64;\n\n    int FPS = 60;\n\n    //System\n    public TileManager tileM = new TileManager(this);\n    public KeyHandler keyH = new KeyHandler(this);\n    public MouseHandler mouseH = new MouseHandler(this);\n    public Sound music = new Sound();\n    public Sound se = new Sound();\n    public CollisionChecker cChecker = new CollisionChecker(this);\n    public AssetSetter aSetter = new AssetSetter(this);\n    public UI ui = new UI(this);\n    Config config = new Config(this);\n    public Map map = new Map(this);\n    public SaveLoad saveLoad = new SaveLoad(this);\n    public EnvironmentManager eManager = new EnvironmentManager(this);\n    Thread gameThread;\n\n    //for full screen\n    public boolean fullScreenOn = false;\n\n    //entity and object\n    public Player player = new Player(this,keyH,mouseH);\n    public Entity[] ammo = new Entity[50];\n    public Entity[] monster = new Entity[50];\n    public ArrayList<Entity> projectileList = new ArrayList<>();\n    public ArrayList<Entity> entityList = new ArrayList<>();\n\n    //game state\n    public int gameState;\n    public final int titleState = 0;\n    public final int playState = 1;\n    public final int pauseState = 2;\n    public final int inventoryState = 3;\n    public final int optionState = 4;\n    public final int gameOverState = 5;\n    public final int transitionState = 6;\n    public final int mapState = 7;\n\n    public GamePanel () {\n        this.setPreferredSize(new Dimension(screenWidth,screenHeight));\n        this.setBackground(Color.gray);\n        this.setDoubleBuffered(true);\n        this.addKeyListener(keyH);\n        this.addMouseListener(mouseH);\n        this.addMouseMotionListener(mouseH);\n        this.setFocusable(true);\n\n    }\n\n    public void setupGame() {\n        aSetter.setObject();\n        aSetter.setMonster();\n        eManager.setup();\n        //playMusic(0);\n        gameState = titleState;\n\n        if(fullScreenOn == true) {\n            setFullScreen();\n        }\n    }\n\n    public void restart() {\n\n        player.setDefaultValues();\n        player.setDefaultPositions();\n        player.restoreLife();\n        player.setItems();\n\n        for(int i = 0; i < ammo.length; i++) {\n            ammo[i] = null;\n        }\n        aSetter.setObject();\n        player.score = 0;\n\n        for (int i = 0; i < monster.length; i++) {\n            monster[i] = null;\n        }\n        currentWave = 0;\n        aSetter.setMonster();\n\n        eManager.lightning.dayState = 0;\n        eManager.lightning.dayCounter = 0;\n        eManager.lightning.filterAlpha = 0f;\n    }\n\n    public void setFullScreen() {\n\n    }\n\n    public void startGameThread() {\n        gameThread = new Thread(this);\n        gameThread.start();\n    }\n\n    @Override\n    public void run() {\n        double drawInterval = (double) 1000000000 /FPS;\n        double nextDrawTime = System.nanoTime() + drawInterval;\n\n        while(gameThread != null) {\n            update();\n            repaint();\n\n            try{\n                double remainingTime = nextDrawTime - System.nanoTime();\n                remainingTime = remainingTime / 1000000;\n\n                if(remainingTime < 0) {\n                    remainingTime = 0;\n                }\n\n                Thread.sleep((long) remainingTime);\n                nextDrawTime += drawInterval;\n\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void update() {\n\n        if (gameState == playState) {\n            player.update();\n            checkWaveCompletion();\n\n            for (int i = 0; i < monster.length; i++) {\n                if (monster[i] != null) {\n                    if (monster[i].alive == true && monster[i].dying == false) {\n                        monster[i].update();\n                    }\n                    if (monster[i].alive == false) {\n                        monster[i].checkDrop();\n                        monster[i] = null;\n                        i--;\n                    }\n                }\n            }\n\n            for (int i = 0; i < projectileList.size(); i++) {\n                if (projectileList.get(i) != null) {\n                    if (projectileList.get(i).alive == true) {\n                        projectileList.get(i).update();\n                    }\n                    if (projectileList.get(i).alive == false) {\n                        projectileList.remove(i);\n                        i--;\n                    }\n                }\n            }\n\n            if (gameState == pauseState) {\n                //nothing\n            }\n            if (gameState == inventoryState) {\n                return;\n            }\n        }\n    }\n\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2 = (Graphics2D) g;\n\n        //title screen\n        if(gameState == titleState) {\n            ui.draw(g2);\n        }\n        else if(gameState == mapState) {\n            map.drawFullMapScreen(g2);\n        }\n        else {\n            tileM.draw(g2);\n\n            entityList.add(player);\n            //player.draw(g2);\n\n            for(int i = 0; i < ammo.length; i++) {\n                if(ammo[i] != null) {\n                    entityList.add(ammo[i]);\n                }\n            }\n\n            for(int i = 0; i < monster.length; i++) {\n                if(monster[i] != null) {\n                    entityList.add(monster[i]);\n                }\n            }\n\n            for(int i = 0; i < projectileList.size(); i++) {\n                if(projectileList.get(i) != null) {\n                    entityList.add(projectileList.get(i));\n                }\n            }\n\n            //sort\n            Collections.sort(entityList, new Comparator<Entity>() {\n                @Override\n                public int compare(Entity o1, Entity o2) {\n                    int result = Integer.compare(o1.worldY,o2.worldY);\n                    return result;\n                }\n            });\n\n            //draw entity\n            for(int i = 0; i < entityList.size(); i++) {\n                entityList.get(i).draw(g2);\n            }\n            entityList.clear();\n\n            map.drawMiniMap(g2);\n\n            eManager.draw(g2);\n            eManager.update();\n\n            ui.draw(g2);\n\n            g2.dispose();\n        }\n    }\n\n    public void playMusic(int i) {\n        music.setFile(i);\n        music.play();\n        music.loop();\n    }\n\n    public void stopMusic() {\n        music.stop();\n    }\n\n    public void playSE (int i) {\n        se.setFile(i);\n        se.play();\n    }\n\n    public void checkWaveCompletion() {\n        boolean allZombiesDead = true;\n\n        for (Entity zombie : monster) {\n            if (zombie != null && zombie.alive) {\n                allZombiesDead = false;\n                break;\n            }\n        }\n\n        if (allZombiesDead) {\n            currentWave++;\n            aSetter.setMonster();\n\n\n            unlockNewWeapon();\n        }\n    }\n\n    public void unlockNewWeapon() {\n        switch (currentWave) {\n            case 3:\n                player.inventory.add(new Tufek(this));\n                ui.showMessage(\"Piyade Tüfeği Açıldı!\");\n                break;\n            case 5:\n                player.inventory.add(new PompaliTufek(this));\n                ui.showMessage(\"Pompalı Tüfek Açıldı!\");\n                break;\n            case 7:\n                player.inventory.add(new KeskinNisanciTufek(this));\n                ui.showMessage(\"Keskin Nişancı Tüfeği Açıldı!\");\n                break;\n            case 10:\n                player.inventory.add(new Roketatar(this));\n                ui.showMessage(\"Roketatar Açıldı!\");\n                break;\n        }\n    }\n}\n",
      "UI.java": "package main;\n\nimport object.PiyadeAmmo;\nimport entity.*;\nimport gun.*;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class UI {\n\n    GamePanel gp;\n    Graphics2D g2;\n    public Font arial_40;\n    BufferedImage PiyadeAmmoImage;\n    public int commandNum = 0;\n    public int slotCol = 0;\n    public int slotRow = 0;\n    public String currentDialogue = \"\";\n    int subState = 0;\n    public int messageTimer = 0;\n\n\n    public UI (GamePanel gp) {\n        this.gp = gp;\n        arial_40 = new Font(\"Arial\",Font.PLAIN,40);\n        PiyadeAmmo piyadeAmmo = new PiyadeAmmo(gp);\n        PiyadeAmmoImage = piyadeAmmo.image;\n    }\n\n    public void draw(Graphics2D g2) {\n        this.g2 = g2;\n        g2.setFont(arial_40);\n        g2.setColor(Color.white);\n\n        updateAmmoDisplay();\n\n        if(gp.gameState == gp.titleState) {\n            drawTitleScreen();\n        }\n\n        if(gp.gameState == gp.playState) {\n            // Do play state stuff later\n            drawPlayerStats();\n            drawWeaponInfo();\n        }\n        if(gp.gameState == gp.pauseState) {\n            drawPauseScreen();\n        }\n        if(gp.gameState == gp.inventoryState) {\n            drawInventoryState();\n            drawGunSelector();\n        }\n        if(gp.gameState == gp.optionState) {\n            drawOptionScreen();\n        }\n        if(gp.gameState == gp.gameOverState) {\n            drawGameOverScreen();\n        }\n\n        // yeni silah açılma mesajı\n        if (messageTimer > 0) {\n            int y = gp.screenHeight / 4;\n            int padding = 20;\n\n            int textWidth = (int) g2.getFontMetrics().getStringBounds(currentDialogue, g2).getWidth();\n            int boxWidth = textWidth + padding * 2;\n            int boxHeight = 60;\n\n            int x = gp.screenWidth / 2 - boxWidth / 2;\n\n            g2.setColor(new Color(0, 0, 0, 150));\n            g2.fillRoundRect(x, y - 40, boxWidth, boxHeight, 15, 15);\n\n            g2.setColor(Color.white);\n            g2.drawString(currentDialogue, x + padding, y);\n\n            messageTimer--;\n        }\n    }\n\n    private void drawTitleScreen() {\n\n        g2.setColor(new Color(0,0,0));\n        g2.fillRect(0,0,gp.screenWidth,gp.screenHeight);\n\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD,96F));\n        String text = \"Zombieee\";\n        int x = getXforCenteredText(text);\n        int y = gp.tileSize*3;\n\n        g2.setColor(Color.gray);\n        g2.drawString(text,x+5,y+5);\n        g2.setColor(Color.white);\n        g2.drawString(text,x,y);\n\n        x = gp.screenWidth/2 - (gp.tileSize*2)/2;\n        y += gp.tileSize*2;\n        g2.drawImage(gp.player.playerimage,x,y,gp.tileSize*2,gp.tileSize*2,null);\n\n        //menu\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD,32F));\n\n        text = \"NEW GAME\";\n        x = getXforCenteredText(text);\n        y += gp.tileSize*4;\n        g2.drawString(text,x,y);\n        if(commandNum == 0) {\n            g2.drawString(\">\",x- gp.tileSize,y);\n        }\n\n        text = \"LOAD GAME\";\n        x = getXforCenteredText(text);\n        y += gp.tileSize;\n        g2.drawString(text,x,y);\n        if(commandNum == 1) {\n            g2.drawString(\">\",x- gp.tileSize,y);\n        }\n\n        text = \"QUIT\";\n        x = getXforCenteredText(text);\n        y += gp.tileSize;\n        g2.drawString(text,x,y);\n        if(commandNum == 2) {\n            g2.drawString(\">\",x- gp.tileSize,y);\n        }\n    }\n\n    public void drawPauseScreen() {\n        String text = \"Paused\";\n        int x = getXforCenteredText(text);\n        int y = gp.screenHeight/2;\n\n        g2.drawString(text,x,y);\n    }\n\n    public void drawInventoryState() {\n\n        final int frameY = gp.tileSize*2;\n        final int frameX = gp.tileSize;\n        final int frameWidth = gp.tileSize*12;\n        final int frameHeight = gp.tileSize*15;\n        drawSubWindow(frameX,frameY,frameWidth,frameHeight);\n\n        g2.setColor(Color.white);\n        g2.setFont(g2.getFont().deriveFont(32F));\n\n        int textX = frameX + 20;\n        int textY = frameY + gp.tileSize;\n        final int lineHeight = 40;\n\n        g2.drawString(\"Tabanca: \",textX,textY);\n        textY += lineHeight + gp.tileSize/4;\n        g2.drawString(\"Tabanca Ammo: \",textX,textY);\n        textY += lineHeight*2;\n        g2.drawString(\"PiyadeTüfeği: \",textX,textY);\n        textY += lineHeight  + gp.tileSize/4;\n        g2.drawString(\"PiyadeTüfeği Ammo: \",textX,textY);\n        textY += lineHeight*2;\n        g2.drawString(\"Pompalı: \",textX,textY);\n        textY += lineHeight + gp.tileSize/4;\n        g2.drawString(\"Pompalı Ammo: \",textX,textY);\n        textY += lineHeight*2;\n        g2.drawString(\"Sniper: \",textX,textY);\n        textY += lineHeight + gp.tileSize/4;\n        g2.drawString(\"Sniper Ammo: \",textX,textY);\n        textY += lineHeight*2;\n        g2.drawString(\"RoketAtar: \",textX,textY);\n        textY += lineHeight + gp.tileSize/4;\n        g2.drawString(\"RoketAtar Ammo: \",textX,textY);\n\n        //values\n        int tailX = (frameX + frameWidth) - 30;\n        textY = frameY + 10;\n\n        //görsellerini çizmek için\n        g2.drawImage(gp.player.playerimage, tailX - gp.tileSize, textY, null);\n        textY += lineHeight + gp.tileSize/4;\n        g2.drawString(\n                gp.player.inventory.get(0).currentAmmo + \" / \" + gp.player.getTotalAmmo(gp.player.inventory.get(0)),\n                frameX + 450, textY + lineHeight\n        );\n        textY += lineHeight * 2;\n\n        g2.drawImage(gp.player.playerimage2, tailX - gp.tileSize, textY, null);\n        textY += lineHeight + gp.tileSize/4;\n        if (gp.player.inventory.size() >= 2) {\n            g2.drawString(\n                    gp.player.inventory.get(1).currentAmmo + \" / \" + gp.player.getTotalAmmo(gp.player.inventory.get(1)),\n                    frameX + 450, textY + lineHeight\n            );\n        }\n        textY += lineHeight * 2;\n\n        g2.drawImage(gp.player.playerimage3, tailX - gp.tileSize, textY, null);\n        textY += lineHeight + gp.tileSize/4;\n        if (gp.player.inventory.size() >= 3) {\n            g2.drawString(\n                    gp.player.inventory.get(2).currentAmmo + \" / \" + gp.player.getTotalAmmo(gp.player.inventory.get(2)),\n                    frameX + 450, textY + lineHeight\n            );\n        }\n        textY += lineHeight * 2;\n\n        g2.drawImage(gp.player.playerimage2, tailX - gp.tileSize, textY, null);\n        textY += lineHeight + gp.tileSize/4;\n        if (gp.player.inventory.size() >= 4) {\n            g2.drawString(\n                    gp.player.inventory.get(3).currentAmmo + \" / \" + gp.player.getTotalAmmo(gp.player.inventory.get(3)),\n                    frameX + 450, textY + lineHeight\n            );\n        }\n        textY += lineHeight * 2;\n\n        g2.drawImage(gp.player.playerimage3, tailX - gp.tileSize, textY, null);\n        textY += lineHeight + gp.tileSize/4;\n        if (gp.player.inventory.size() >= 5) {\n            g2.drawString(\n                    gp.player.inventory.get(4).currentAmmo + \" / \" + gp.player.getTotalAmmo(gp.player.inventory.get(4)),\n                    frameX + 450, textY + lineHeight\n            );\n        }\n    }\n\n    public void drawGunSelector() {\n        int frameX = gp.tileSize * 15;\n        int frameY = gp.tileSize * 2;\n        int frameWidth = gp.tileSize * 6;\n        int frameHeight = gp.tileSize * 2;\n        drawSubWindow(frameX, frameY, frameWidth, frameHeight);\n\n        // Slot başlangıç noktaları\n        final int slotXstart = frameX + 20;\n        final int slotYstart = frameY + 20;\n        int slotX = slotXstart;\n        int slotY = slotYstart;\n        int slotSize = gp.tileSize + 3;\n        int maxSlotsPerRow = 5;\n\n        // Envanterdeki öğeleri çiz\n        for (int i = 0; i < gp.player.inventory.size(); i++) {\n            if (gp.player.inventory.get(i) != null) {\n                if (gp.player.inventory.get(i) == gp.player.currentWeapon) {\n                    g2.setColor(new Color(240, 190, 90));\n                    g2.fillRoundRect(slotX, slotY, gp.tileSize, gp.tileSize, 10, 10);\n                }\n\n                Entity gun = gp.player.inventory.get(i);\n                if (gun != null && gun.image != null) {\n                    g2.drawImage(gun.image, slotX, slotY, null);\n                }\n                slotX += slotSize;\n            }\n        }\n\n        // Cursor pozisyonu\n        if (slotCol < 0) slotCol = 0;\n        if (slotCol >= gp.player.inventory.size()) slotCol = gp.player.inventory.size() - 1;\n\n        int cursorX = slotXstart + (slotSize * slotCol);\n        int cursorY = slotYstart;\n        g2.setColor(Color.white);\n        g2.setStroke(new BasicStroke(3));\n        g2.drawRoundRect(cursorX, cursorY, gp.tileSize, gp.tileSize, 10, 10);\n\n        // Açıklama çerçevesi\n        int dFrameX = frameX;\n        int dFrameY = frameY + frameHeight + gp.tileSize;\n        int dFrameWidth = frameWidth;\n        int dFrameHeight = gp.tileSize * 2;\n\n        int textX = dFrameX + 20;\n        int textY = dFrameY + gp.tileSize;\n        g2.setFont(g2.getFont().deriveFont(28F));\n\n        int itemIndex = getItemIndexOnSlot();\n        if (itemIndex >= 0 && itemIndex < gp.player.inventory.size()) {\n            Entity gun = gp.player.inventory.get(itemIndex);\n            if (gun != null && gun.description != null) {\n                drawSubWindow(dFrameX, dFrameY, dFrameWidth, dFrameHeight);\n                for (String line : gun.description.split(\"\\n\")) {\n                    g2.drawString(line, textX, textY);\n                    textY += 32;\n                }\n            }\n        }\n    }\n\n    public void drawGameOverScreen() {\n\n        g2.setColor(new Color(0,0,0,150));\n        g2.fillRect(0,0,gp.screenWidth,gp.screenHeight);\n\n        int x;\n        int y;\n        String text;\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD,110f));\n\n        text = \"Game Over\";\n        //shadow\n        g2.setColor(Color.black);\n        x = getXforCenteredText(text);\n        y = gp.tileSize*4;\n        g2.drawString(text,x,y);\n        //main\n        g2.setColor(Color.white);\n        g2.drawString(text,x-4,y-4);\n\n        //retry\n        g2.setFont(g2.getFont().deriveFont(50f));\n        text = \"Retry\";\n        x = getXforCenteredText(text);\n        y += gp.tileSize*4;\n        g2.drawString(text,x,y);\n        if(commandNum == 0) {\n            g2.drawString(\">\",x-40,y);\n        }\n\n        //back to the title screen\n        text = \"Quit\";\n        x = getXforCenteredText(text);\n        y += 55;\n        g2.drawString(text,x,y);\n        if(commandNum == 1) {\n            g2.drawString(\">\",x-40,y);\n        }\n    }\n\n    public void drawOptionScreen() {\n\n        g2.setColor(Color.white);\n        g2.setFont(g2.getFont().deriveFont(32F));\n\n        int frameX = gp.tileSize*11;\n        int frameY = gp.tileSize*2;\n        int frameWidth = gp.tileSize*10;\n        int frameHeight = gp.tileSize*16;\n        drawSubWindow(frameX,frameY,frameWidth,frameHeight);\n\n        switch (subState) {\n            case 0: option_top(frameX,frameY); break;\n            case 1: options_fullScreenNotification(frameX,frameY); break;\n            case 2: options_control(frameX,frameY); break;\n            case 3: options_endGameConfirmation(frameX,frameY); break;\n        }\n\n        gp.keyH.enterPressed = false;\n    }\n\n    public void option_top(int frameX, int frameY) {\n\n        int textX;\n        int textY;\n\n        //title\n        String text = \"Options\";\n        textX = getXforCenteredText(text);\n        textY = frameY + gp.tileSize;\n        g2.drawString(text,textX,textY);\n\n        //full screen on/off\n        textX = frameX + gp.tileSize;\n        textY += gp.tileSize*2;\n        g2.drawString(\"Full Screen\",textX,textY);\n        if(commandNum == 0) {\n            g2.drawString(\">\",textX-25,textY);\n            if(gp.keyH.enterPressed == true) {\n                if(gp.fullScreenOn == false) {\n                    gp.fullScreenOn = true;\n                }\n                else if(gp.fullScreenOn == true) {\n                    gp.fullScreenOn = false;\n                }\n                subState = 1;\n            }\n        }\n\n        //music\n        textY += gp.tileSize*2;\n        g2.drawString(\"Music\",textX,textY);\n        if(commandNum == 1) {\n            g2.drawString(\">\",textX-25,textY);\n        }\n\n        //sound effect\n        textY += gp.tileSize*2;\n        g2.drawString(\"Sound Effects\",textX,textY);\n        if(commandNum == 2) {\n            g2.drawString(\">\",textX-25,textY);\n        }\n\n        //Control\n        textY += gp.tileSize*2;\n        g2.drawString(\"Control\",textX,textY);\n        if(commandNum == 3) {\n            g2.drawString(\">\",textX-25,textY);\n            if(gp.keyH.enterPressed == true) {\n                subState = 2;\n                commandNum = 0;\n            }\n        }\n\n        //quit game\n        textY += gp.tileSize*2;\n        g2.drawString(\"End Game\",textX,textY);\n        if(commandNum == 4) {\n            g2.drawString(\">\",textX-25,textY);\n            if(gp.keyH.enterPressed == true) {\n                subState = 3;\n                commandNum = 0;\n            }\n        }\n\n        //go back\n        textY += gp.tileSize*3;\n        g2.drawString(\"Back\",textX,textY);\n        if(commandNum == 5) {\n            g2.drawString(\">\",textX-25,textY);\n            if(gp.keyH.enterPressed == true) {\n                gp.gameState = gp.playState;\n                commandNum = 0;\n            }\n        }\n\n        //full screen check box\n        textX = frameX + gp.tileSize*5+32;\n        textY = frameY + gp.tileSize*2+20;\n        g2.setStroke(new BasicStroke(3));\n        g2.drawRect(textX,textY,32,32);\n        if(gp.fullScreenOn == true) {\n            g2.fillRect(textX,textY,32,32);\n        }\n\n        //music volume\n        textY += gp.tileSize*2;\n        g2.drawRect(textX,textY,160,32);\n        int volumeWidth = 32 * gp.music.volumeScale;\n        g2.fillRect(textX,textY,volumeWidth,32);\n\n        //sound effect volume\n        textY += gp.tileSize*2;\n        g2.drawRect(textX,textY,160,32);\n        volumeWidth = 32 * gp.se.volumeScale;\n        g2.fillRect(textX,textY,volumeWidth,32);\n\n        gp.config.saveConfig();\n    }\n\n    public void options_fullScreenNotification(int frameX, int frameY) {\n\n        int textX = frameX + gp.tileSize;\n        int textY = frameY + gp.tileSize*3;\n\n        currentDialogue = \"The change will take \\neffect after restarting \\n the game\";\n\n        for(String line: currentDialogue.split(\"\\n\")) {\n            g2.drawString(line,textX,textY);\n            textY += 40;\n        }\n\n        //back\n        textY += frameY;\n        g2.drawString(\"Back\",textX,textY);\n        if(commandNum == 0) {\n            g2.drawString(\">\",textX-25,textY);\n            if(gp.keyH.enterPressed == true) {\n                subState = 0;\n            }\n        }\n    }\n\n    public void options_control (int frameX, int frameY) {\n\n        int textX;\n        int textY;\n\n        //title\n        String text = \"Control\";\n        textX = getXforCenteredText(text);\n        textY = frameY + gp.tileSize;\n        g2.drawString(text,textX,textY);\n\n        textX = frameX + gp.tileSize;\n        textY += gp.tileSize;\n        g2.drawString(\"Move\",textX,textY); textY+=gp.tileSize;\n        g2.drawString(\"Confirm/Attack\",textX,textY); textY+=gp.tileSize;\n        g2.drawString(\"Shoot\",textX,textY); textY+=gp.tileSize;\n        g2.drawString(\"Open Inventory\",textX,textY); textY+=gp.tileSize;\n        g2.drawString(\"Pause\",textX,textY); textY+=gp.tileSize;\n        g2.drawString(\"Options\",textX,textY); textY+=gp.tileSize;\n\n        textX = frameX + gp.tileSize*6;\n        textY = frameY + gp.tileSize*2;\n        g2.drawString(\"W-A-S-D\",textX,textY); textY+=gp.tileSize;\n        g2.drawString(\"Enter\",textX,textY); textY+=gp.tileSize;\n        g2.drawString(\"Left Click\",textX,textY); textY+=gp.tileSize;\n        g2.drawString(\"E\",textX,textY); textY+=gp.tileSize;\n        g2.drawString(\"P\",textX,textY); textY+=gp.tileSize;\n        g2.drawString(\"Esc\",textX,textY); textY+=gp.tileSize;\n\n        //back\n        textX = frameX + gp.tileSize;\n        textY = frameY + gp.tileSize*9;\n        g2.drawString(\"Back\",textX,textY);\n        if(commandNum == 0) {\n            g2.drawString(\">\",textX-25,textY);\n            if(gp.keyH.enterPressed == true) {\n                subState = 0;\n                commandNum = 3;\n            }\n        }\n    }\n\n    public void options_endGameConfirmation (int frameX, int frameY) {\n\n        int textX = frameX + gp.tileSize + 20;\n        int textY = frameY + gp.tileSize*3;\n\n        currentDialogue = \"Save & Quit the game? \";\n\n        for(String line: currentDialogue.split(\"\\n\")) {\n            g2.drawString(line,textX,textY);\n            textY += 40;\n        }\n\n        // yes\n        String text = \"Yes\";\n        textX = getXforCenteredText(text);\n        textY += gp.tileSize*3;\n        g2.drawString(text,textX,textY);\n        if(commandNum == 0) {\n            g2.drawString(\">\",textX-25,textY);\n            if(gp.keyH.enterPressed == true) {\n                gp.saveLoad.save();\n                subState = 0;\n                System.exit(0);\n            }\n        }\n\n        // no\n        text = \"No\";\n        textX = getXforCenteredText(text);\n        textY += gp.tileSize;\n        g2.drawString(text,textX,textY);\n        if(commandNum == 1) {\n            g2.drawString(\">\",textX-25,textY);\n            if(gp.keyH.enterPressed == true) {\n                subState = 0;\n                commandNum = 4;\n            }\n        }\n    }\n\n    public int getItemIndexOnSlot() {\n        int itemIndex = slotCol + (slotRow);\n        return itemIndex;\n    }\n\n    public void drawSubWindow (int x, int y, int width, int height) {\n\n        Color c = new Color(0,0,0,210);\n        g2.setColor(c);\n        g2.fillRoundRect(x,y,width,height,35,35);\n\n        c = new Color(255,255,255);\n        g2.setColor(c);\n        g2.setStroke(new BasicStroke(5));\n        g2.drawRoundRect(x+5,y+5,width-10,height-10,25,25);\n    }\n\n    public int getXforCenteredText (String text) {\n        int length = (int)g2.getFontMetrics().getStringBounds(text,g2).getWidth();\n        int x = gp.screenWidth/2 - length/2;\n        return x;\n    }\n\n    public int getXforAlingToRightText (String text, int tailX) {\n        int length = (int)g2.getFontMetrics().getStringBounds(text,g2).getWidth();\n        int x = tailX - length;\n        return x;\n    }\n\n    public void updateAmmoDisplay() {\n        String weaponName = gp.player.currentWeapon.name;\n        int currentAmmo = gp.player.currentWeapon.currentAmmo;\n        int totalAmmo = gp.player.getTotalAmmo(gp.player.currentWeapon);\n\n        if (gp.player.currentWeapon instanceof Tabanca) {\n            totalAmmo = gp.player.currentAmmo;\n        } else if (gp.player.currentWeapon instanceof Tufek) {\n            totalAmmo = gp.player.currentAmmo;\n        } else if (gp.player.currentWeapon instanceof PompaliTufek) {\n            totalAmmo = gp.player.currentAmmo;\n        } else if (gp.player.currentWeapon instanceof KeskinNisanciTufek) {\n            totalAmmo = gp.player.currentAmmo;\n        } else if (gp.player.currentWeapon instanceof Roketatar) {\n            totalAmmo = gp.player.currentAmmo;\n        }\n    }\n\n    public void showMessage(String text) {\n        currentDialogue = text;\n        messageTimer = 120;\n    }\n\n    public void drawPlayerStats () {\n\n        int x = gp.screenWidth - 250;\n        int y = 50;\n\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 30));\n        g2.setColor(Color.white);\n\n        //can barı\n        g2.drawString(\"Can: \" + gp.player.life, x, y);\n\n        //toplam skor\n        g2.drawString(\"Skor: \" + gp.player.score, x, y + 40);\n    }\n\n    public void drawWeaponInfo () {\n\n        int x = 20;\n        int y = 50;\n\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 30));\n        g2.setColor(Color.white);\n\n        g2.drawString(\"Silah: \" + gp.player.currentWeapon.name, x, y);\n        int currentAmmo = gp.player.currentWeapon.currentAmmo;\n        int totalAmmo = gp.player.getTotalAmmo(gp.player.currentWeapon);\n\n        g2.drawString(\"Mermi: \" + currentAmmo + \" / \" + totalAmmo, x, y + 40);\n    }\n}\n",
      "AssetSetter.java": "package main;\n\nimport monster.*;\nimport object.Health;\n\npublic class AssetSetter {\n\n    GamePanel gp;\n\n    public AssetSetter(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    public void setObject() {\n        gp.ammo[0] = new Health(gp);\n        gp.ammo[0].worldX = 31 * gp.tileSize + 32;\n        gp.ammo[0].worldY = 31 * gp.tileSize + 32;\n    }\n\n    public void setMonster() {\n\n        int waveNumber = gp.currentWave;\n        int maxMonsters = gp.monster.length;\n\n        for (int i = 0; i < waveNumber * 2 && i < maxMonsters; i++) {\n            int spawnX, spawnY;\n            boolean tooClose;\n\n            do {\n                tooClose = false;\n\n                int margin = gp.tileSize * 2;\n\n                spawnX = margin + (int)(Math.random() * (gp.maxWorldCol * gp.tileSize - 2 * margin));\n                spawnY = margin + (int)(Math.random() * (gp.maxWorldRow * gp.tileSize - 2 * margin));\n\n                double distance = Math.sqrt(Math.pow(gp.player.worldX - spawnX, 2) + Math.pow(gp.player.worldY - spawnY, 2));\n\n                if (distance < gp.tileSize * 5) {\n                    tooClose = true;\n                }\n\n            } while (tooClose);\n\n            if (i % 4 == 0) {\n                gp.monster[i] = new NormalZombi(gp);\n            } else if (i % 4 == 1) {\n                gp.monster[i] = new SurungeZombi(gp);\n            } else if (i % 4 == 2) {\n                gp.monster[i] = new AsitTukurenZombi(gp);\n            } else {\n                gp.monster[i] = new TankZombi(gp);\n            }\n\n            gp.monster[i].worldX = spawnX;\n            gp.monster[i].worldY = spawnY;\n        }\n    }\n}\n",
      "KeyHandler.java": "package main;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\npublic class KeyHandler implements KeyListener {\n\n    GamePanel gp;\n    public boolean upPressed, downPressed, leftPressed, rightPressed;\n    public boolean enterPressed;\n\n    public KeyHandler(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {}\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int code = e.getKeyCode();\n\n        if(gp.gameState == gp.titleState){\n            if (code == KeyEvent.VK_W) {\n                gp.ui.commandNum--;\n                gp.playSE(2);\n                if(gp.ui.commandNum < 0) {\n                    gp.ui.commandNum = 2;\n                }\n            }\n            if (code == KeyEvent.VK_S) {\n                gp.ui.commandNum++;\n                gp.playSE(2);\n                if(gp.ui.commandNum > 2) {\n                    gp.ui.commandNum = 0;\n                }\n            }\n            if (code == KeyEvent.VK_ENTER) {\n                if(gp.ui.commandNum == 0) {\n                    gp.gameState = gp.playState;\n                    gp.restart();\n                    gp.playMusic(0);\n                }\n                if(gp.ui.commandNum == 1) {\n                    gp.saveLoad.load();\n                    gp.gameState = gp.playState;\n                    gp.playMusic(0);\n                }\n                if(gp.ui.commandNum == 2) {\n                    System.exit(0);\n                }\n            }\n        }\n        else if(gp.gameState == gp.playState) {\n            if (code == KeyEvent.VK_W) {\n                upPressed = true;\n            }\n            if (code == KeyEvent.VK_S) {\n                downPressed = true;\n            }\n            if (code == KeyEvent.VK_A) {\n                leftPressed = true;\n            }\n            if (code == KeyEvent.VK_D) {\n                rightPressed = true;\n            }\n            if (code == KeyEvent.VK_E) {\n                gp.gameState = gp.inventoryState;\n            }\n            if (code == KeyEvent.VK_ESCAPE) {\n                gp.gameState = gp.optionState;\n            }\n            if (code == KeyEvent.VK_R) {\n                gp.player.reload();\n            }\n            if (code == KeyEvent.VK_M) {\n                gp.gameState = gp.mapState;\n            }\n            if (code == KeyEvent.VK_X) {\n                if(gp.map.miniMapOn == false) {\n                    gp.map.miniMapOn = true;\n                }\n                else {\n                    gp.map.miniMapOn = false;\n                }\n            }\n        }\n        else if(gp.gameState == gp.inventoryState) {\n            if(code == KeyEvent.VK_E) {\n               gp.gameState = gp.playState;\n            }\n            if (code == KeyEvent.VK_A) {\n                if(gp.ui.slotCol != 0) {\n                    gp.ui.slotCol--;\n                    gp.playSE(2);\n                }\n            }\n            if (code == KeyEvent.VK_D) {\n                if(gp.ui.slotCol != 4) {\n                    gp.ui.slotCol++;\n                    gp.playSE(2);\n                }\n            }\n            if (code == KeyEvent.VK_ENTER) {\n                gp.player.selectItem();\n            }\n\n        }\n        else if(gp.gameState == gp.optionState) {\n\n            if (code == KeyEvent.VK_ESCAPE) {\n                gp.gameState = gp.playState;\n            }\n            if (code == KeyEvent.VK_ENTER) {\n                enterPressed = true;\n            }\n\n            int maxCommandNum = 0;\n            switch (gp.ui.subState) {\n                case 0: maxCommandNum = 5; break;\n                case 3: maxCommandNum = 1; break;\n            }\n            if(code == KeyEvent.VK_W) {\n                gp.ui.commandNum--;\n                gp.playSE(2);\n                if(gp.ui.commandNum < 0) {\n                    gp.ui.commandNum = maxCommandNum;\n                }\n            }\n            if(code == KeyEvent.VK_S) {\n                gp.ui.commandNum++;\n                gp.playSE(2);\n                if(gp.ui.commandNum > maxCommandNum) {\n                    gp.ui.commandNum = 0;\n                }\n            }\n            if(code == KeyEvent.VK_A) {\n                if(gp.ui.subState == 0) {\n                    if(gp.ui.commandNum == 1 && gp.music.volumeScale > 0) {\n                        gp.music.volumeScale--;\n                        gp.playSE(2);\n                        gp.music.checkVolume();\n                    }\n                    if(gp.ui.commandNum == 2 && gp.se.volumeScale > 0) {\n                        gp.se.volumeScale--;\n                        gp.playSE(2);\n                    }\n                }\n            }\n            if(code == KeyEvent.VK_D) {\n                if(gp.ui.subState == 0) {\n                    if(gp.ui.commandNum == 1 && gp.music.volumeScale < 5) {\n                        gp.music.volumeScale++;\n                        gp.playSE(2);\n                        gp.music.checkVolume();\n                    }\n                    if(gp.ui.commandNum == 2 && gp.se.volumeScale < 5) {\n                        gp.se.volumeScale++;\n                        gp.playSE(2);\n                    }\n                }\n            }\n        }\n        else if(gp.gameState == gp.gameOverState) {\n            if (code == KeyEvent.VK_W) {\n                gp.ui.commandNum--;\n                gp.playSE(2);\n                if(gp.ui.commandNum < 0) {\n                    gp.ui.commandNum = 1;\n                }\n            }\n            if (code == KeyEvent.VK_S) {\n                gp.ui.commandNum++;\n                gp.playSE(2);\n                if(gp.ui.commandNum > 1) {\n                    gp.ui.commandNum = 0;\n                }\n            }\n            if (code == KeyEvent.VK_ENTER) {\n                if(gp.ui.commandNum == 0) {\n                    gp.gameState = gp.playState;\n                    gp.restart();\n                    gp.playMusic(0);\n                }\n                else if(gp.ui.commandNum == 1) {\n                    gp.gameState = gp.titleState;\n                    gp.restart();\n                }\n            }\n        }\n        else if(gp.gameState == gp.mapState) {\n            if(code == KeyEvent.VK_M) {\n                gp.gameState = gp.playState;\n            }\n        }\n\n        if (code == KeyEvent.VK_P) {\n            if (gp.gameState == gp.playState) {\n                gp.gameState = gp.pauseState;\n            }\n            else if (gp.gameState == gp.pauseState) {\n                gp.gameState = gp.playState;\n            }\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int code = e.getKeyCode();\n        if (code == KeyEvent.VK_W) {\n            upPressed = false;\n        }\n        if (code == KeyEvent.VK_S) {\n            downPressed = false;\n        }\n        if (code == KeyEvent.VK_A) {\n            leftPressed = false;\n        }\n        if (code == KeyEvent.VK_D) {\n            rightPressed = false;\n        }\n    }\n}\n",
      "Game.java": "package main;\n\nimport javax.swing.*;\n\npublic class Game {\n    public static void main(String[] args) {\n        JFrame window = new JFrame();\n        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        window.setResizable(false);\n        window.setTitle(\"2D-TopDownShooter\");\n\n        GamePanel gamePanel = new GamePanel();\n        window.add(gamePanel);\n\n        gamePanel.config.loadConfig();\n        if(gamePanel.fullScreenOn == true) {\n            window.setUndecorated(true);\n        }\n\n        window.pack();\n\n        window.setLocationRelativeTo(null);\n        window.setVisible(true);\n\n        gamePanel.setupGame();\n        gamePanel.startGameThread();\n    }\n}\n",
      "CollisionChecker.java": "package main;\n\nimport java.awt.*;\n\nimport entity.*;\n\npublic class CollisionChecker {\n\n    GamePanel gp;\n\n    public CollisionChecker(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    public void checkTile(Entity entity) {\n\n        int entityLeftWorldX = entity.worldX + entity.solidArea.x;\n        int entityRightWorldX = entity.worldX + entity.solidArea.x + entity.solidArea.width;\n        int entityTopWorldY = entity.worldY + entity.solidArea.y;\n        int entityBottomWorldY = entity.worldY + entity.solidArea.y + entity.solidArea.height;\n\n        int entityLeftCol = entityLeftWorldX/gp.tileSize;\n        int entityRightCol = entityRightWorldX/gp.tileSize;\n        int entityTopRow = entityTopWorldY/gp.tileSize;\n        int entityBottomRow = entityBottomWorldY/gp.tileSize;\n\n        int tileNum1, tileNum2;\n\n        int maxCol = gp.maxWorldCol;\n        int maxRow = gp.maxWorldRow;\n\n        if (entityLeftWorldX < 0 || entityTopWorldY < 0 ||\n                entityRightWorldX >= maxCol * gp.tileSize || entityBottomWorldY >= maxRow * gp.tileSize) {\n            entity.collisionOn = true;\n            return;\n        }\n\n        switch (entity.direction) {\n            case \"up\":\n                entityTopRow = (entityTopWorldY - entity.speed)/gp.tileSize;\n                tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];\n                tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];\n                if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true){\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"down\":\n                entityBottomRow = (entityBottomWorldY + entity.speed)/gp.tileSize;\n                tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];\n                tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];\n                if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true){\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"left\":\n                entityLeftCol = (entityLeftWorldX - entity.speed)/gp.tileSize;\n                tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];\n                tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];\n                if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true){\n                    entity.collisionOn = true;\n                }\n                break;\n            case \"right\":\n                entityRightCol = (entityRightWorldX + entity.speed)/gp.tileSize;\n                tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];\n                tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];\n                if(gp.tileM.tile[tileNum1].collision == true || gp.tileM.tile[tileNum2].collision == true){\n                    entity.collisionOn = true;\n                }\n                break;\n        }\n    }\n\n    public int checkObject(Entity entity, boolean player) {\n        int index = -1;\n\n        for(int i = 0; i < gp.ammo.length; i++) {\n\n            if(gp.ammo[i] != null) {\n                entity.solidArea.x = entity.worldX + entity.solidArea.x;\n                entity.solidArea.y = entity.worldY + entity.solidArea.y;\n\n                gp.ammo[i].solidArea.x = gp.ammo[i].worldX + gp.ammo[i].solidArea.x;\n                gp.ammo[i].solidArea.y = gp.ammo[i].worldY + gp.ammo[i].solidArea.y;\n\n                switch (entity.direction) {\n                    case \"up\":\n                        entity.solidArea.y -= entity.speed;\n                        break;\n                    case \"down\":\n                        entity.solidArea.y += entity.speed;\n                        break;\n                    case \"left\":\n                        entity.solidArea.x -= entity.speed;\n                        break;\n                    case \"right\":\n                        entity.solidArea.x += entity.speed;\n                        break;\n                }\n                if(entity.solidArea.intersects(gp.ammo[i].solidArea)){\n                    if(gp.ammo[i].collision == true) {\n                        entity.collisionOn = true;\n                    }\n                    if(player == true) {\n                        index = i;\n                    }\n                }\n                entity.solidArea.x = entity.solidAreaDefaultX;\n                entity.solidArea.y = entity.solidAreaDefaultY;\n                gp.ammo[i].solidArea.x = gp.ammo[i].solidAreaDefaultX;\n                gp.ammo[i].solidArea.y = gp.ammo[i].solidAreaDefaultY;\n            }\n        }\n        return index;\n    }\n\n    public int checkEntity(Entity entity, Entity[] target) {\n        int index = -1;\n\n        for(int i = 0; i < target.length; i++) {\n\n            if(target[i] != null && target[i].alive) {\n                entity.solidArea.x = entity.worldX + entity.solidArea.x;\n                entity.solidArea.y = entity.worldY + entity.solidArea.y;\n\n                target[i].solidArea.x = target[i].worldX + target[i].solidArea.x;\n                target[i].solidArea.y = target[i].worldY + target[i].solidArea.y;\n\n                switch (entity.direction) {\n                    case \"up\":\n                        entity.solidArea.y -= entity.speed;\n                        break;\n                    case \"down\":\n                        entity.solidArea.y += entity.speed;\n                        break;\n                    case \"left\":\n                        entity.solidArea.x -= entity.speed;\n                        break;\n                    case \"right\":\n                        entity.solidArea.x += entity.speed;\n                        break;\n                }\n                if(entity.solidArea.intersects(target[i].solidArea)) {\n                    if(target[i] != entity) {\n                        entity.collisionOn = true;\n                        index = i;\n                    }\n                }\n                entity.solidArea.x = entity.solidAreaDefaultX;\n                entity.solidArea.y = entity.solidAreaDefaultY;\n                target[i].solidArea.x = target[i].solidAreaDefaultX;\n                target[i].solidArea.y = target[i].solidAreaDefaultY;\n            }\n        }\n        return index;\n    }\n\n    public boolean checkPlayer(Entity entity) {\n\n        boolean contactPlayer = false;\n\n        entity.solidArea.x = entity.worldX + entity.solidArea.x;\n        entity.solidArea.y = entity.worldY + entity.solidArea.y;\n\n        gp.player.solidArea.x = gp.player.worldX + gp.player.solidArea.x;\n        gp.player.solidArea.y = gp.player.worldY + gp.player.solidArea.y;\n\n        switch (entity.direction) {\n            case \"up\":\n                entity.solidArea.y -= entity.speed;\n                break;\n            case \"down\":\n                entity.solidArea.y += entity.speed;\n                break;\n            case \"left\":\n                entity.solidArea.x -= entity.speed;\n                break;\n            case \"right\":\n                entity.solidArea.x += entity.speed;\n                break;\n        }\n        if(entity.solidArea.intersects(gp.player.solidArea)){\n            entity.collisionOn = true;\n            contactPlayer = true;\n        }\n        entity.solidArea.x = entity.solidAreaDefaultX;\n        entity.solidArea.y = entity.solidAreaDefaultY;\n        gp.player.solidArea.x = gp.player.solidAreaDefaultX;\n        gp.player.solidArea.y = gp.player.solidAreaDefaultY;\n        return  contactPlayer;\n    }\n\n    public boolean  isBlockedInDirection(Entity entity, String direction) {\n\n        boolean blocked = false;\n\n        int nextX = entity.worldX;\n        int nextY = entity.worldY;\n\n        switch (direction) {\n            case \"up\": nextY -= entity.speed; break;\n            case \"down\": nextY += entity.speed; break;\n            case \"left\": nextX -= entity.speed; break;\n            case \"right\": nextX += entity.speed; break;\n        }\n\n        Rectangle futureHitbox = new Rectangle(\n                nextX + entity.solidArea.x,\n                nextY + entity.solidArea.y,\n                entity.solidArea.width,\n                entity.solidArea.height\n        );\n\n        for (Entity monster : gp.monster) {\n            if (monster != null && monster.alive && monster != entity) {\n                Rectangle monsterHitbox = new Rectangle(\n                        monster.worldX + monster.solidArea.x,\n                        monster.worldY + monster.solidArea.y,\n                        monster.solidArea.width,\n                        monster.solidArea.height\n                );\n                if (futureHitbox.intersects(monsterHitbox)) {\n                    blocked = true;\n                    break;\n                }\n            }\n        }\n\n        return blocked;\n    }\n}\n",
      "MouseHandler.java": "package main;\n\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\n\npublic class MouseHandler implements MouseListener, MouseMotionListener {\n\n    GamePanel gp;\n    public int mouseX, mouseY;\n    public boolean mousePressed;\n    public boolean mouseClicked;\n\n    MouseHandler(GamePanel gp) {this.gp = gp;}\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        if (e.getButton() == MouseEvent.BUTTON1) {\n            mousePressed = true;\n        }\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        if (e.getButton() == MouseEvent.BUTTON1) {\n            mousePressed = false;\n        }\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {}\n    @Override public void mouseEntered(MouseEvent e) {}\n    @Override public void mouseExited(MouseEvent e) {}\n    @Override public void mouseDragged(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n}",
      "EnvironmentManager.java": "package environment;\n\nimport main.GamePanel;\n\nimport java.awt.*;\n\npublic class EnvironmentManager {\n\n    GamePanel gp;\n    public Lightning lightning;\n\n    public EnvironmentManager(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    public void setup() {\n\n        lightning = new Lightning(gp,700);\n    }\n\n    public void update() {\n        lightning.update();\n    }\n\n    public void draw(Graphics2D g2) {\n        lightning.draw(g2);\n    }\n}\n",
      "Lightning.java": "package environment;\n\nimport main.GamePanel;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class Lightning {\n\n    GamePanel gp;\n    int circleSize;\n    BufferedImage darknessFilter;\n    public int dayCounter;\n    public float filterAlpha = 0f;\n\n    final int day = 0;\n    final int dusk = 1;\n    final int night = 2;\n    final int dawn = 3;\n    public int dayState = day;\n\n    public Lightning(GamePanel gp, int circleSize) {\n        this.gp = gp;\n        this.circleSize = circleSize;\n        setLightSource();\n    }\n\n    public void setLightSource() {\n\n        darknessFilter = new BufferedImage(gp.screenWidth,gp.screenHeight,BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2 = (Graphics2D)darknessFilter.getGraphics();\n\n        int centerX = gp.player.screenX + (gp.tileSize)/2;\n        int centerY = gp.player.screenY + (gp.tileSize)/2;\n\n        Color color[] = new Color[5];\n        float fraction[] = new float[5];\n\n        color[0] = new Color(0,0,0,0f);\n        color[1] = new Color(0,0,0,0.25f);\n        color[2] = new Color(0,0,0,0.50f);\n        color[3] = new Color(0,0,0,0.75f);\n        color[4] = new Color(0,0,0,0.98f);\n\n        fraction[0] = 0f;\n        fraction[1] = 0.25f;\n        fraction[2] = 0.50f;\n        fraction[3] = 0.75f;\n        fraction[4] = 1f;\n\n        RadialGradientPaint gPaint = new RadialGradientPaint(centerX,centerY,(circleSize/2),fraction,color);\n\n        g2.setPaint(gPaint);\n        g2.fillRect(0,0,gp.screenWidth,gp.screenHeight);\n        g2.dispose();\n    }\n\n    public void update() {\n\n        if(gp.gameState == gp.playState) {\n            setLightSource();\n\n            if (dayState == day) {\n                dayCounter++;\n                if (dayCounter > 600) {\n                    dayState = dusk;\n                    dayCounter = 0;\n                }\n            }\n            if (dayState == dusk) {\n                filterAlpha += 0.001f;\n                if (filterAlpha > 1f) {\n                    filterAlpha = 1f;\n                    dayState = night;\n                }\n            }\n            if (dayState == night) {\n                dayCounter++;\n                if (dayCounter > 600) {\n                    dayState = dawn;\n                    dayCounter = 0;\n                }\n            }\n            if (dayState == dawn) {\n                filterAlpha -= 0.001f;\n                if (filterAlpha < 0f) {\n                    filterAlpha = 0;\n                    dayState = day;\n                }\n            }\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,filterAlpha));\n        g2.drawImage(darknessFilter,0,0,null);\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,1f));\n    }\n}\n",
      "NormalZombi.java": "package monster;\n\nimport main.GamePanel;\nimport entity.*;\nimport object.*;\n\nimport java.awt.*;\nimport java.util.Random;\n\npublic class NormalZombi extends Entity {\n\n    public NormalZombi(GamePanel gp) {\n        super(gp);\n        this.solidArea = new Rectangle(150, 210, 200, 180);\n        spawnDelayActive = true;\n        spawnStartTime = System.currentTimeMillis();\n\n        type = 1;\n        name = \"Normal Zombi\";\n        speed = 2;\n        maxLife = 8;\n        attack = 8;\n        life = maxLife;\n\n        solidArea.x = 4;\n        solidArea.y = 4;\n        solidArea.width = 40;\n        solidArea.height = 44;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        attackArea.width = 48;\n        attackArea.height = 48;\n\n        projectile = new Firing(gp,attackValue);\n\n        getImage();\n        onPath = true;\n    }\n\n    public void getImage() {\n        image = setup(\"/res/Zombies/zombie1\");\n    }\n\n    public void setAction() {\n\n        int playerX = gp.player.worldX + gp.player.solidArea.width / 2;\n        int playerY = gp.player.worldY + gp.player.solidArea.height / 2;\n\n        int zombieX = this.worldX + this.solidArea.width / 2;\n        int zombieY = this.worldY + this.solidArea.height / 2;\n\n        double diffX = playerX - zombieX;\n        double diffY = playerY - zombieY;\n        double distance = Math.sqrt(diffX * diffX + diffY * diffY);\n\n        if (distance > 4) {\n            double moveX = (diffX / distance) * speed;\n            double moveY = (diffY / distance) * speed;\n\n            if (!collisionOn) {\n                worldX += moveX;\n                worldY += moveY;\n            }\n\n            angle = Math.atan2(diffY, diffX);\n        }\n\n        if (Math.abs(diffX) > Math.abs(diffY)) {\n            direction = diffX > 0 ? \"right\" : \"left\";\n        } else {\n            direction = diffY > 0 ? \"down\" : \"up\";\n        }\n\n        if(attacking == false) {\n            checkAttackOrNot(30,gp.tileSize*4,gp.tileSize);\n        }\n    }\n\n    public void checkDrop() {\n\n        int i = new Random().nextInt(200)+1;\n\n        if (i < 20) {\n            dropItem(new PiyadeAmmo(gp));\n        }\n        else if (i >= 20 && i < 40) {\n            dropItem(new PompaliAmmo(gp));\n        }\n        else if (i >= 40 && i < 60) {\n            dropItem(new SniperAmmo(gp));\n        }\n        else if (i >= 60 && i < 80) {\n            dropItem(new RoketAmmo(gp));\n        }\n        else if (i >= 80 && i < 100) {\n            dropItem(new Health(gp));\n        }\n    }\n}",
      "SurungeZombi.java": "package monster;\n\nimport main.GamePanel;\nimport entity.*;\nimport object.*;\n\nimport java.awt.*;\nimport java.util.Random;\n\npublic class SurungeZombi extends Entity {\n\n    public boolean canJump = true;\n    public long lastJumpTime = 0;\n\n    public SurungeZombi(GamePanel gp) {\n        super(gp);\n        this.solidArea = new Rectangle(160, 220, 200, 180);\n        spawnDelayActive = true;\n        spawnStartTime = System.currentTimeMillis();\n\n        type = 1;\n        name = \"Sürüngen Zombi\";\n        speed = 3;\n        maxLife = 4;\n        attack = 8;\n        life = maxLife;\n\n        solidArea.x = 4;\n        solidArea.y = 4;\n        solidArea.width = 40;\n        solidArea.height = 44;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        attackArea.width = 48;\n        attackArea.height = 48;\n\n        projectile = new Firing(gp,attackValue);\n\n        getImage();\n        onPath = true;\n    }\n\n    public void getImage() {\n        image = setup(\"/res/Zombies/zombie4\");\n    }\n\n    public void setAction() {\n\n        int playerX = gp.player.worldX + gp.player.solidArea.width / 2;\n        int playerY = gp.player.worldY + gp.player.solidArea.height / 2;\n\n        int zombieX = this.worldX + this.solidArea.width / 2;\n        int zombieY = this.worldY + this.solidArea.height / 2;\n\n        double diffX = playerX - zombieX;\n        double diffY = playerY - zombieY;\n        double distance = Math.sqrt(diffX * diffX + diffY * diffY);\n\n        if (distance > 4) {\n            double moveX = (diffX / distance) * speed;\n            double moveY = (diffY / distance) * speed;\n\n            if (!collisionOn) {\n                worldX += moveX;\n                worldY += moveY;\n            }\n\n            angle = Math.atan2(diffY, diffX);\n        }\n\n        if (Math.abs(diffX) > Math.abs(diffY)) {\n            direction = diffX > 0 ? \"right\" : \"left\";\n        } else {\n            direction = diffY > 0 ? \"down\" : \"up\";\n        }\n\n        if (distance < gp.tileSize*3) {\n            zipla();\n        }\n\n        if(attacking == false) {\n            checkAttackOrNot(30,gp.tileSize*4,gp.tileSize);\n        }\n    }\n\n    public void zipla() {\n\n        long now = System.currentTimeMillis();\n        if (canJump && now - lastJumpTime > 2000) {\n            int jumpX = (int) (Math.cos(angle) * speed * 6);\n            int jumpY = (int) (Math.sin(angle) * speed * 6);\n            lastJumpTime = now;\n\n            if (!willCollideAfterJump(jumpX, jumpY)) {\n                worldX += jumpX;\n                worldY += jumpY;\n            }\n        }\n    }\n\n    public void checkDrop() {\n\n        int i = new Random().nextInt(200)+1;\n\n        if (i < 20) {\n            dropItem(new PiyadeAmmo(gp));\n        }\n        else if (i >= 20 && i < 40) {\n            dropItem(new PompaliAmmo(gp));\n        }\n        else if (i >= 40 && i < 60) {\n            dropItem(new SniperAmmo(gp));\n        }\n        else if (i >= 60 && i < 80) {\n            dropItem(new RoketAmmo(gp));\n        }\n        else if (i >= 80 && i < 100) {\n            dropItem(new Health(gp));\n        }\n    }\n}\n\n",
      "TankZombi.java": "package monster;\n\nimport main.GamePanel;\nimport entity.*;\nimport object.*;\n\nimport java.awt.*;\nimport java.util.Random;\n\npublic class TankZombi extends Entity {\n\n    public TankZombi(GamePanel gp) {\n\n        super(gp);\n        this.solidArea = new Rectangle(140, 200, 200, 190);\n        spawnDelayActive = true;\n        spawnStartTime = System.currentTimeMillis();\n\n        type = 1;\n        name = \"Normal Zombi\";\n        speed = 1;\n        maxLife = 12;\n        attack = 12;\n        life = maxLife;\n\n        solidArea.x = 4;\n        solidArea.y = 4;\n        solidArea.width = 40;\n        solidArea.height = 44;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        attackArea.width = 48;\n        attackArea.height = 48;\n\n        projectile = new Firing(gp,attackValue);\n\n        getImage();\n        onPath = true;\n    }\n\n    public void getImage() {\n        image = setup(\"/res/Zombies/zombie5\");\n    }\n\n    public void setAction() {\n\n        int playerX = gp.player.worldX + gp.player.solidArea.width / 2;\n        int playerY = gp.player.worldY + gp.player.solidArea.height / 2;\n\n        int zombieX = this.worldX + this.solidArea.width / 2;\n        int zombieY = this.worldY + this.solidArea.height / 2;\n\n        double diffX = playerX - zombieX;\n        double diffY = playerY - zombieY;\n        double distance = Math.sqrt(diffX * diffX + diffY * diffY);\n\n        if (distance > 4) {\n            double moveX = (diffX / distance) * speed;\n            double moveY = (diffY / distance) * speed;\n\n            if (!collisionOn) {\n                worldX += moveX;\n                worldY += moveY;\n            }\n\n            angle = Math.atan2(diffY, diffX);\n        }\n\n        if (Math.abs(diffX) > Math.abs(diffY)) {\n            direction = diffX > 0 ? \"right\" : \"left\";\n        } else {\n            direction = diffY > 0 ? \"down\" : \"up\";\n        }\n\n        if(attacking == false) {\n            checkAttackOrNot(30,gp.tileSize*4,gp.tileSize);\n        }\n    }\n\n    public void checkDrop() {\n\n        int i = new Random().nextInt(200)+1;\n\n        if (i < 20) {\n            dropItem(new PiyadeAmmo(gp));\n        }\n        else if (i >= 20 && i < 40) {\n            dropItem(new PompaliAmmo(gp));\n        }\n        else if (i >= 40 && i < 60) {\n            dropItem(new SniperAmmo(gp));\n        }\n        else if (i >= 60 && i < 80) {\n            dropItem(new RoketAmmo(gp));\n        }\n        else if (i >= 80 && i < 100) {\n            dropItem(new Health(gp));\n        }\n    }\n}\n",
      "AsitTukurenZombi.java": "package monster;\n\nimport main.GamePanel;\nimport entity.*;\nimport object.*;\n\nimport java.awt.*;\nimport java.util.Random;\n\npublic class AsitTukurenZombi extends Entity {\n\n    public AsitTukurenZombi(GamePanel gp) {\n        super(gp);\n        this.solidArea = new Rectangle(150, 210, 210, 190);\n        spawnDelayActive = true;\n        spawnStartTime = System.currentTimeMillis();\n\n        type = 1;\n        name = \"AsitAtar Zombi\";\n        speed = 2;\n        maxLife = 5;\n        attack = 8;\n        life = maxLife;\n\n        solidArea.x = 4;\n        solidArea.y = 4;\n        solidArea.width = 40;\n        solidArea.height = 44;\n        solidAreaDefaultX = solidArea.x;\n        solidAreaDefaultY = solidArea.y;\n        attackArea.width = 48;\n        attackArea.height = 48;\n\n        projectile = new Firing(gp,attackValue);\n\n        getImage();\n        onPath = true;\n    }\n\n    public void getImage() {\n        image = setup(\"/res/Zombies/zombie6\");\n    }\n\n    public void setAction() {\n\n        int playerX = gp.player.worldX + gp.player.solidArea.width / 2;\n        int playerY = gp.player.worldY + gp.player.solidArea.height / 2;\n\n        int zombieX = this.worldX + this.solidArea.width / 2;\n        int zombieY = this.worldY + this.solidArea.height / 2;\n\n        double diffX = playerX - zombieX;\n        double diffY = playerY - zombieY;\n        double distance = Math.sqrt(diffX * diffX + diffY * diffY);\n\n        if (distance > 4) {\n            double moveX = (diffX / distance) * speed;\n            double moveY = (diffY / distance) * speed;\n\n            if (!collisionOn) {\n                worldX += moveX;\n                worldY += moveY;\n            }\n\n            angle = Math.atan2(diffY, diffX);\n        }\n\n        if (Math.abs(diffX) > Math.abs(diffY)) {\n            direction = diffX > 0 ? \"right\" : \"left\";\n        } else {\n            direction = diffY > 0 ? \"down\" : \"up\";\n        }\n\n        if(attacking == false) {\n            checkAttackOrNot(30,gp.tileSize*4,gp.tileSize);\n        }\n\n        if (projectile.alive == false && asitCounter >= 180) {\n            projectile = new Firing(gp, this.attack);\n            projectile.image = setup(\"/Guns/AsitTopu\");\n            projectile.set(worldX + solidArea.width / 2, worldY + solidArea.height / 2, angle, true, this);\n            gp.projectileList.add(projectile);\n            asitCounter = 0;\n        }\n\n        if(asitCounter <= 180) {\n            asitCounter++;\n        }\n    }\n\n    //patlama hasarı\n    public void die() {\n        int explosionRadius = gp.tileSize * 2;\n\n        for (Entity entity : gp.monster) {\n            if (entity != null && entity != this) {\n                int distance = Math.abs(entity.worldX - this.worldX) + Math.abs(entity.worldY - this.worldY);\n                if (distance < explosionRadius) {\n                    entity.life -= 10;\n                }\n            }\n        }\n\n        //oyuncuya hasar\n        int playerDistance = Math.abs(gp.player.worldX - this.worldX) + Math.abs(gp.player.worldY - this.worldY);\n        if (playerDistance < explosionRadius) {\n            gp.player.life -= 15;\n            gp.player.invincible = true;\n            this.alive = false;\n        }\n    }\n\n    public void checkDrop() {\n\n        int i = new Random().nextInt(200)+1;\n\n        if (i < 20) {\n            dropItem(new PiyadeAmmo(gp));\n        }\n        else if (i >= 20 && i < 40) {\n            dropItem(new PompaliAmmo(gp));\n        }\n        else if (i >= 40 && i < 60) {\n            dropItem(new SniperAmmo(gp));\n        }\n        else if (i >= 60 && i < 80) {\n            dropItem(new RoketAmmo(gp));\n        }\n        else if (i >= 80 && i < 100) {\n            dropItem(new Health(gp));\n        }\n    }\n}\n",
      "DataStorage.java": "package data;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\n\npublic class DataStorage implements Serializable {\n\n    int playerWorldX;\n    int playerWorldY;\n    int maxLife;\n    int life;\n    int TabancaAmmo;\n    int PiyadeAmmo;\n    int PompaliAmmo;\n    int SniperAmmo;\n    int RoketAmmo;\n    int Skor;\n    int currentWave;\n    int currentAmmo;\n    int currentWeaponAmmo;\n    int currentFireRate;\n    String currentWeaponName;\n    int counterOfDay;\n    float filterOfAlpha;\n\n    //inventory\n    ArrayList<String> itemNames = new ArrayList<>();\n    int currentWeaponSlot;\n\n    //objects on map\n    String mapObjectNames[];\n    int mapObjectWorldX[];\n    int mapObjectWorldY[];\n\n    String[] monsterNames;\n    int[] monsterWorldX;\n    int[] monsterWorldY;\n    int[] monsterLife;\n}\n",
      "SaveLoad.java": "package data;\n\nimport entity.Entity;\nimport environment.EnvironmentManager;\nimport environment.Lightning;\nimport gun.*;\nimport main.*;\nimport object.*;\nimport monster.*;\n\nimport java.io.*;\n\npublic class SaveLoad {\n\n    GamePanel gp;\n\n    public SaveLoad(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    public Entity getObject(String itemName) {\n        Entity obj = null;\n        switch (itemName) {\n            case \"Tabanca\": obj = new Tabanca(gp); break;\n            case \"Piyade Tüfeği\": obj = new Tufek(gp); break;\n            case \"Pompalı Tüfek\": obj = new PompaliTufek(gp); break;\n            case \"Keskin Nişancı Tüfeği\": obj = new KeskinNisanciTufek(gp); break;\n            case \"Roketatar\": obj = new Roketatar(gp); break;\n            case \"PiyadeAmmo\": obj = new PiyadeAmmo(gp); break;\n            case \"PompalıAmmo\": obj = new PompaliAmmo(gp); break;\n            case \"Sniper Ammo\": obj = new SniperAmmo(gp); break;\n            case \"Roket Ammo\": obj = new RoketAmmo(gp); break;\n            case \"Health\": obj = new Health(gp); break;\n        }\n        return obj;\n    }\n\n    public Entity getMonster(String name) {\n        Entity monster = null;\n        switch (name) {\n            case \"NormalZombi\": monster = new NormalZombi(gp); break;\n            case \"TankZombi\": monster = new TankZombi(gp); break;\n            case \"AsitTukurenZombi\": monster = new AsitTukurenZombi(gp); break;\n            case \"SurungeZombi\": monster = new SurungeZombi(gp); break;\n        }\n        return monster;\n    }\n\n    public void save() {\n        try {\n            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(\"save.dat\")));\n            DataStorage ds = new DataStorage();\n            ds.playerWorldX = gp.player.worldX;\n            ds.playerWorldY = gp.player.worldY;\n            ds.maxLife = gp.player.maxLife;\n            ds.life = gp.player.life;\n            ds.TabancaAmmo = gp.player.hasTabancaAmmo;\n            ds.PiyadeAmmo = gp.player.hasPiyadeAmmo;\n            ds.PompaliAmmo = gp.player.hasPompaliAmmo;\n            ds.SniperAmmo = gp.player.hasSniperAmmo;\n            ds.RoketAmmo = gp.player.hasRoketAmmo;\n            ds.Skor = gp.player.score;\n            ds.currentWave = gp.currentWave;\n            ds.currentAmmo = gp.player.currentWeapon.currentAmmo;\n            ds.currentFireRate = gp.player.currentWeapon.fireRate;\n            ds.currentWeaponName = gp.player.currentWeapon.name;\n            ds.counterOfDay = gp.eManager.lightning.dayCounter;\n            ds.filterOfAlpha = gp.eManager.lightning.filterAlpha;\n\n            for (int i = 0; i < gp.player.inventory.size(); i++) {\n                ds.itemNames.add(gp.player.inventory.get(i).name);\n            }\n            ds.currentWeaponSlot = gp.player.getCurrentWeaponSlot();\n\n            ds.mapObjectNames = new String[gp.ammo.length];\n            ds.mapObjectWorldX = new int[gp.ammo.length];\n            ds.mapObjectWorldY = new int[gp.ammo.length];\n\n            for (int i = 0; i < gp.ammo.length; i++) {\n                if (gp.ammo[i] == null) {\n                    ds.mapObjectNames[i] = \"NA\";\n                } else {\n                    ds.mapObjectNames[i] = gp.ammo[i].name;\n                    ds.mapObjectWorldX[i] = gp.ammo[i].worldX;\n                    ds.mapObjectWorldY[i] = gp.ammo[i].worldY;\n                }\n            }\n\n            int monsterCount = 0;\n            for (int i = 0; i < gp.monster.length; i++) {\n                if (gp.monster[i] != null) monsterCount++;\n            }\n\n            ds.monsterNames = new String[monsterCount];\n            ds.monsterWorldX = new int[monsterCount];\n            ds.monsterWorldY = new int[monsterCount];\n            ds.monsterLife = new int[monsterCount];\n\n            int mIndex = 0;\n            for (int i = 0; i < gp.monster.length; i++) {\n                if (gp.monster[i] != null) {\n                    ds.monsterNames[mIndex] = gp.monster[i].getClass().getSimpleName();\n                    ds.monsterWorldX[mIndex] = gp.monster[i].worldX;\n                    ds.monsterWorldY[mIndex] = gp.monster[i].worldY;\n                    ds.monsterLife[mIndex] = gp.monster[i].life;\n                    mIndex++;\n                }\n            }\n\n            oos.writeObject(ds);\n\n        } catch (Exception e) {\n            System.out.println(\"Error for save\");\n        }\n    }\n\n    public void load() {\n        try {\n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\"save.dat\")));\n            DataStorage ds = (DataStorage) ois.readObject();\n            gp.player.worldX = ds.playerWorldX;\n            gp.player.worldY = ds.playerWorldY;\n            gp.player.maxLife = ds.maxLife;\n            gp.player.life = ds.life;\n            gp.player.hasTabancaAmmo = ds.TabancaAmmo;\n            gp.player.hasPiyadeAmmo = ds.PiyadeAmmo;\n            gp.player.hasPompaliAmmo = ds.PompaliAmmo;\n            gp.player.hasSniperAmmo = ds.SniperAmmo;\n            gp.player.hasRoketAmmo = ds.RoketAmmo;\n            gp.player.score = ds.Skor;\n            gp.currentWave = ds.currentWave;\n            gp.eManager.lightning.dayCounter = ds.counterOfDay;\n            gp.eManager.lightning.filterAlpha = ds.filterOfAlpha;\n\n            gp.player.inventory.clear();\n            for (int i = 0; i < ds.itemNames.size(); i++) {\n                gp.player.inventory.add(getObject(ds.itemNames.get(i)));\n            }\n            gp.player.currentWeapon = gp.player.inventory.get(ds.currentWeaponSlot);\n            gp.player.getAttack();\n            gp.player.getPlayerAttackImage();\n            gp.player.currentWeapon.currentAmmo = ds.currentAmmo;\n            gp.player.currentWeapon.fireRate = ds.currentFireRate;\n\n            for (int i = 0; i < ds.mapObjectNames.length; i++) {\n                if (ds.mapObjectNames[i].equals(\"NA\")) {\n                    gp.ammo[i] = null;\n                } else {\n                    gp.ammo[i] = getObject(ds.mapObjectNames[i]);\n                    gp.ammo[i].worldX = ds.mapObjectWorldX[i];\n                    gp.ammo[i].worldY = ds.mapObjectWorldY[i];\n                }\n            }\n\n            for (int i = 0; i < ds.monsterNames.length; i++) {\n                Entity monster = getMonster(ds.monsterNames[i]);\n                monster.worldX = ds.monsterWorldX[i];\n                monster.worldY = ds.monsterWorldY[i];\n                monster.life = ds.monsterLife[i];\n                monster.maxLife = monster.life;\n                gp.monster[i] = monster;\n            }\n\n        } catch (Exception e) {\n            System.out.println(\"Error for load\");\n        }\n    }\n}",
      "PompaliAmmo.java": "package object;\n\nimport main.GamePanel;\nimport entity.Entity;\n\npublic class PompaliAmmo extends Entity {\n\n    GamePanel gp;\n\n    public PompaliAmmo(GamePanel gp) {\n        super(gp);\n        this.gp = gp;\n\n        name = \"PompalıAmmo\";\n        image = setup(\"/res/Ammo/ammo_shotgun\");\n        ammoValue = 10;\n    }\n}\n",
      "SniperAmmo.java": "package object;\n\nimport main.GamePanel;\nimport entity.Entity;\n\npublic class SniperAmmo extends Entity {\n    GamePanel gp;\n\n    public SniperAmmo(GamePanel gp) {\n        super(gp);\n        this.gp = gp;\n\n        name = \"Sniper Ammo\";\n        image = setup(\"/res/Ammo/ammo_sniper\");\n        ammoValue = 10;\n    }\n}",
      "PiyadeAmmo.java": "package object;\n\nimport main.GamePanel;\nimport entity.Entity;\n\npublic class PiyadeAmmo extends Entity {\n\n    GamePanel gp;\n\n    public PiyadeAmmo(GamePanel gp) {\n        super(gp);\n        this.gp = gp;\n\n        name = \"PiyadeAmmo\";\n        image = setup(\"/res/Ammo/ammo_rifle\");\n        ammoValue = 10;\n    }\n}\n",
      "Health.java": "package object;\n\nimport main.GamePanel;\nimport entity.Entity;\n\npublic class Health extends Entity {\n\n    GamePanel gp;\n\n    public Health(GamePanel gp) {\n        super(gp);\n        this.gp = gp;\n\n        name = \"Health\";\n        image = setup(\"/res/Ammo/health_red\");\n        value = 5;\n    }\n\n    public void use(Entity entity) {\n        if(gp.player.life > gp.player.maxLife) {\n            gp.player.life = gp.player.maxLife;\n        }\n    }\n}\n\n\n",
      "RoketAmmo.java": "package object;\n\nimport main.GamePanel;\nimport entity.Entity;\n\npublic class RoketAmmo extends Entity {\n    GamePanel gp;\n\n    public RoketAmmo(GamePanel gp) {\n        super(gp);\n        this.gp = gp;\n\n        name = \"Roket Ammo\";\n        image = setup(\"/res/Ammo/ammo_rocket\");\n        ammoValue = 10;\n    }\n}",
      "Map.java": "package tile;\n\nimport entity.Entity;\nimport main.GamePanel;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class Map extends TileManager {\n\n    GamePanel gp;\n    BufferedImage worldMap;\n    public boolean miniMapOn = false;\n\n    public Map(GamePanel gp) {\n        super(gp);\n        this.gp = gp;\n        createWorldMap();\n    }\n\n    public void createWorldMap() {\n\n        int worldMapWidth = gp.tileSize * gp.maxWorldCol;\n        int worldMapHeight = gp.tileSize * gp.maxWorldRow;\n\n        worldMap = new BufferedImage(worldMapWidth,worldMapHeight,BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2 = (Graphics2D)worldMap.createGraphics();\n\n        int col = 0;\n        int row = 0;\n\n        while(col < gp.maxWorldCol && row < gp.maxWorldRow) {\n\n            int tileNum = mapTileNum[col][row];\n            int x = gp.tileSize * col;\n            int y = gp.tileSize * row;\n            g2.drawImage(tile[tileNum].image,x,y,null);\n\n            col++;\n            if(col == gp.maxWorldCol) {\n                col = 0;\n                row++;\n            }\n        }\n        g2.dispose();\n    }\n\n    public void drawFullMapScreen (Graphics2D g2) {\n\n        //background\n        g2.setColor(Color.black);\n        g2.fillRect(0,0, gp.screenWidth, gp.screenHeight);\n\n        //draw map\n        int width = 1200;\n        int height = 800;\n        int x = gp.screenWidth/2 - width/2;\n        int y = gp.screenHeight/2 - height/2 - 75;\n        g2.drawImage(worldMap,x,y,width,height,null);\n\n        //oyuncunun çizimi\n        double scaleX = (double)(gp.tileSize * gp.maxWorldCol) / width;   // 3072 / 1200\n        double scaleY = (double)(gp.tileSize * gp.maxWorldRow) / height;  // 3072 / 800\n\n        int playerX = (int)(x + gp.player.worldX / scaleX);\n        int playerY = (int)(y + gp.player.worldY / scaleY);\n        int playerSize = gp.tileSize;\n\n        double angle = gp.player.angle;\n        int centerX = playerX + playerSize / 2;\n        int centerY = playerY + playerSize / 2;\n\n        g2.translate(centerX, centerY);\n        g2.rotate(angle);\n        g2.drawImage(gp.player.playerimage, -playerSize / 2, -playerSize / 2, playerSize, playerSize, null);\n        g2.rotate(-angle);\n        g2.translate(-centerX, -centerY);\n\n        g2.setFont(gp.ui.arial_40.deriveFont(32f));\n        g2.setColor(Color.white);\n        g2.drawString(\"Press M to close\",1200,950);\n\n        //zombilerin çizimi\n        int tileSizeMini = gp.tileSize;\n\n        for (Entity zombie : gp.monster) {\n            if (zombie != null && zombie.alive) {\n                int miniX = (int) (x + zombie.worldX / scaleX);\n                int miniY = (int) (y + zombie.worldY / scaleY);\n\n                centerX = miniX + tileSizeMini / 2;\n                centerY = miniY + tileSizeMini / 2;\n\n                g2.translate(centerX, centerY);\n                g2.rotate(zombie.angle - Math.PI / 2);\n\n                g2.drawImage(zombie.image, -tileSizeMini / 2, -tileSizeMini / 2, tileSizeMini, tileSizeMini, null);\n\n                g2.rotate(-zombie.angle + Math.PI / 2);\n                g2.translate(-centerX, -centerY);\n            }\n        }\n    }\n\n    public void drawMiniMap (Graphics2D g2) {\n\n        if(miniMapOn == true) {\n            int width = 300;\n            int height = 300;\n            int x = gp.screenWidth - width - 50;\n            int y = 120;\n\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,0.8f));\n            g2.drawImage(worldMap,x,y,width,height,null);\n\n            double scale = (double) (gp.tileSize * gp.maxWorldCol)/width;\n            int playerX = (int) (x + gp.player.worldX/scale);\n            int playerY = (int) (y + gp.player.worldY/scale);\n            int playerSize = (int) (gp.tileSize/3);\n\n            //oyuncunun çizimi\n            double angle = gp.player.angle;\n            int centerX = playerX + playerSize / 2;\n            int centerY = playerY + playerSize / 2;\n\n            g2.translate(centerX, centerY);\n            g2.rotate(angle);\n            g2.drawImage(gp.player.playerimage, -playerSize / 2, -playerSize / 2, playerSize, playerSize, null);\n            g2.rotate(-angle);\n            g2.translate(-centerX, -centerY);\n\n            //zombilerin çizimi\n            int tileSizeMini = gp.tileSize/3;\n\n            for (Entity zombie : gp.monster) {\n                if (zombie != null && zombie.alive) {\n                    int miniX = (int) (x + zombie.worldX / scale);\n                    int miniY = (int) (y + zombie.worldY / scale);\n\n                    centerX = miniX + tileSizeMini / 2;\n                    centerY = miniY + tileSizeMini / 2;\n\n                    g2.translate(centerX, centerY);\n                    g2.rotate(zombie.angle - Math.PI / 2);\n\n                    g2.drawImage(zombie.image, -tileSizeMini / 2, -tileSizeMini / 2, tileSizeMini, tileSizeMini, null);\n\n                    g2.rotate(-zombie.angle + Math.PI / 2);\n                    g2.translate(-centerX, -centerY);\n                }\n            }\n\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,1f));\n        }\n    }\n}\n",
      "Tile.java": "package tile;\n\nimport java.awt.image.BufferedImage;\n\npublic class Tile {\n    public BufferedImage image;\n    public boolean collision = false;\n}\n",
      "TileManager.java": "package tile;\n\nimport main.GamePanel;\nimport main.UtilityTool;\n\nimport javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class TileManager {\n    GamePanel gp;\n    public Tile[] tile;\n    public int[][] mapTileNum;\n\n    public TileManager(GamePanel gp) {\n        this.gp = gp;\n        tile = new Tile[10];\n        mapTileNum = new int[gp.maxWorldCol][gp.maxWorldRow];\n        getTileImage();\n        loadMap(\"/Map/map1.txt\");\n    }\n\n    public void getTileImage() {\n\n        setup(0,\"grass\",false);\n        setup(1,\"walltile\",true);\n        setup(2,\"earth\",false);\n        setup(3,\"sand\",false);\n        setup(4,\"tree\",false);\n    }\n\n    public void setup (int index,String imagePath,boolean collision) {\n        UtilityTool uTool = new UtilityTool();\n\n        try {\n\n            tile[index] = new Tile();\n            tile[index].image = ImageIO.read(getClass().getResourceAsStream(\"/res/Tile/\" + imagePath + \".png\"));\n            tile[index].image = uTool.scaleImage(tile[index].image,gp.tileSize,gp.tileSize);\n            tile[index].collision = collision;\n\n        } catch (IOException e){\n            e.printStackTrace();\n        }\n    }\n\n    public void loadMap (String filepath) {\n        try {\n            InputStream is = getClass().getResourceAsStream(filepath);\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            int col = 0;\n            int row = 0;\n\n            while(col < gp.maxWorldCol && row < gp.maxWorldRow) {\n\n                String line = br.readLine();\n\n                while (col < gp.maxWorldCol) {\n\n                    String numbers[] = line.split(\" \");\n                    int num = Integer.parseInt(numbers[col]);\n                    mapTileNum[col][row] = num;\n                    col++;\n                }\n                if(col == gp.maxWorldCol) {\n                    col = 0;\n                    row++;\n                }\n            }\n            br.close();\n\n        } catch (Exception e) {\n\n        }\n    }\n\n    public void draw(Graphics2D g2){\n\n        int worldCol = 0;\n        int worldRow = 0;\n\n        while(worldCol < gp.maxWorldCol && worldRow < gp.maxWorldRow) {\n\n            int tileNum = mapTileNum[worldCol][worldRow];\n\n            int worldX = worldCol * gp.tileSize;\n            int worldY = worldRow * gp.tileSize;\n            int screenX = worldX - gp.player.worldX + gp.player.screenX;\n            int screenY = worldY - gp.player.worldY + gp.player.screenY;\n\n            if(worldX + gp.tileSize > gp.player.worldX - gp.player.screenX &&\n                    worldX - gp.tileSize < gp.player.worldX + gp.player.screenX &&\n                    worldY + gp.tileSize > gp.player.worldY - gp.player.screenY &&\n                    worldY - gp.tileSize < gp.player.worldY + gp.player.screenY) {\n                g2.drawImage(tile[tileNum].image, screenX, screenY,null);\n            }\n\n            worldCol++;\n\n            if(worldCol == gp.maxWorldCol) {\n                worldCol = 0;\n                worldRow++;\n            }\n        }\n    }\n}\n",
      "PompaliTufek.java": "package gun;\n\nimport entity.Firing;\nimport main.GamePanel;\nimport entity.Entity;\n\npublic class PompaliTufek extends Entity {\n\n    public PompaliTufek(GamePanel gp) {\n\n        super(gp);\n        name = \"Pompalı Tüfek\";\n        fireRate = 30;\n        currentAmmo = 5;\n        image = setup(\"/res/Guns/Pompali_Tufek\");\n        description = \"[\" + name + \"]\\nPompalı Tüfek.\";\n        attackValue = 4;\n    }\n\n    public void fire(double angle, int startX, int startY) {\n        if (gp.player.currentWeapon.currentAmmo > 0) {\n            double spread = Math.toRadians(45);\n            double angleStep = spread / 8.0;\n\n            double startAngle = angle - (spread / 2.0);\n\n            for (int i = 0; i < 9; i++) {\n                double bulletAngle = startAngle + (i * angleStep);\n\n                int offsetDistance = 10;\n                int offsetX = (int) (Math.cos(bulletAngle) * offsetDistance);\n                int offsetY = (int) (Math.sin(bulletAngle) * offsetDistance);\n\n                Firing newBullet = new Firing(gp, this.attackValue);\n                newBullet.set(startX + offsetX, startY + offsetY, bulletAngle, true, this);\n\n                newBullet.speed = 10;\n                newBullet.life = 15;\n\n                gp.projectileList.add(newBullet);\n            }\n            gp.player.currentWeapon.currentAmmo--;\n        }\n    }\n}\n",
      "Tabanca.java": "package gun;\n\nimport entity.Firing;\nimport main.GamePanel;\nimport entity.Entity;\n\npublic class Tabanca extends Entity {\n\n    public Tabanca(GamePanel gp) {\n        super(gp);\n        name = \"Tabanca\";\n        fireRate = 15;\n        currentAmmo = 12; // Sınırsız mermi\n        image = setup(\"/res/Guns/Tabanca\");\n        description = \"[\" + name + \"]\\nTabanca.\";\n        attackValue = 2;\n    }\n\n    public void fire(double angle,int startX,int startY) {\n        if (gp.player.currentWeapon.currentAmmo > 0) {\n            Firing newBullet = new Firing(gp,this.attackValue);\n            newBullet.set(startX, startY, angle, true, this);\n            gp.projectileList.add(newBullet);\n            gp.player.currentWeapon.currentAmmo--;\n        }\n    }\n}\n",
      "Roketatar.java": "package gun;\n\nimport entity.Firing;\nimport main.GamePanel;\nimport entity.Entity;\n\npublic class Roketatar extends Entity {\n\n    public Roketatar(GamePanel gp) {\n\n        super(gp);\n        name = \"Roketatar\";\n        cooldownTime = 6000;\n        fireRate = 60;\n        currentAmmo = 1;\n        image = setup(\"/res/Guns/Roketatar\");\n        description = \"[\" + name + \"]\\nRoketatar.\";\n        attackValue = 10;\n    }\n\n    public void fire(double angle,int startX,int startY) {\n        if (gp.player.currentWeapon.currentAmmo > 0 && canFire()) {\n            Firing newBullet = new Firing(gp,this.attackValue);\n            newBullet.set(startX, startY, angle, true, this);\n            gp.projectileList.add(newBullet);\n            gp.player.currentWeapon.currentAmmo--;\n\n            lastFiredTime = System.currentTimeMillis();\n        }\n    }\n\n    public void explode(int x, int y) {\n        int explosionRadius = gp.tileSize * 3;\n\n        for (Entity monster : gp.monster) {\n            if (monster != null && monster.alive) {\n                int monsterCenterX = monster.worldX + monster.solidArea.width / 2;\n                int monsterCenterY = monster.worldY + monster.solidArea.height / 2;\n\n                double distance = Math.sqrt(Math.pow(monsterCenterX - x, 2) + Math.pow(monsterCenterY - y, 2));\n                if (distance < explosionRadius) {\n                    monster.life -= 20;\n\n                    if (monster.life <= 0) {\n                        monster.dying = true;\n                    }\n                    monster.invincible = true;\n                }\n            }\n        }\n    }\n}\n",
      "KeskinNisanciTufek.java": "package gun;\n\nimport entity.Firing;\nimport main.GamePanel;\nimport entity.Entity;\n\npublic class KeskinNisanciTufek extends Entity {\n\n    public KeskinNisanciTufek(GamePanel gp) {\n\n        super(gp);\n        name = \"Keskin Nişancı Tüfeği\";\n        fireRate = 40;\n        currentAmmo = 5;\n        image = setup(\"/res/Guns/Keskin_Nisanci_Tufegi\");\n        description = \"[\" + name + \"]\\nKeskin Nişancı Tüfeği.\";\n        attackValue = 5;\n    }\n\n    public void update() {\n\n        for (Entity monster : gp.monster) {\n\n            if (monster != null && monster.alive) {\n\n                if (gp.cChecker.checkEntity(this, new Entity[]{monster}) != 999) {\n                    gp.player.damageMonster(gp.cChecker.checkEntity(this, new Entity[]{monster}), gp.player.attack);\n                }\n            }\n        }\n    }\n\n    public void fire(double angle,int startX,int startY) {\n        if (gp.player.currentWeapon.currentAmmo > 0) {\n            Firing newBullet = new Firing(gp,this.attackValue);\n            newBullet.set(startX, startY, angle, true, this);\n            gp.projectileList.add(newBullet);\n            gp.player.currentWeapon.currentAmmo--;\n        }\n    }\n}\n",
      "Tufek.java": "package gun;\n\nimport entity.Firing;\nimport main.GamePanel;\nimport entity.Entity;\n\npublic class Tufek extends Entity {\n\n    public Tufek(GamePanel gp) {\n\n        super(gp);\n        name = \"Piyade Tüfeği\";\n        fireRate = 5;\n        currentAmmo = 30;\n        image = setup(\"/res/Guns/Piyade_Tufek\");\n        description = \"[\" + name + \"]\\nA Rifle.\";\n        attackValue = 3;\n    }\n\n    public void fire(double angle, int startX, int startY) {\n        if (gp.player.currentWeapon.currentAmmo > 0) {\n\n            double spreadAngleDeg = (Math.random() * 30) - 15;\n            double spreadAngleRad = Math.toRadians(spreadAngleDeg);\n\n            double finalAngle = angle + spreadAngleRad;\n\n            Firing newBullet = new Firing(gp, this.attackValue);\n            newBullet.set(startX, startY, finalAngle, true, this);\n            newBullet.angle = finalAngle;\n\n            gp.projectileList.add(newBullet);\n            gp.player.currentWeapon.currentAmmo--;\n        }\n    }\n}\n"
    },
    {
      "id": "2384475",
      "GameWindow.java": "import javax.swing.*;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.*;\nimport java.util.Hashtable;\n\npublic class GameWindow extends JFrame {\n    private GamePanel gamePanel;\n    private JMenuBar menuBar;\n    private JMenu gameMenu;\n    private JMenuItem pauseMenuItem;\n    private JMenuItem saveMenuItem;\n    private JMenuItem loadMenuItem;\n    private JMenuItem exitMenuItem;\n    private SettingsManager settingsManager;\n\n    public GameWindow() {\n        setTitle(\"Deadpool vs Zombies\");\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setSize(800, 600);\n        setLocationRelativeTo(null);\n\n        settingsManager = SettingsManager.getInstance();\n\n        createMenuBar();\n\n        showMainMenu();\n\n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                if (gamePanel != null) {\n                    gamePanel.keyPressed(e);\n                }\n            }\n\n            @Override\n            public void keyReleased(KeyEvent e) {\n                if (gamePanel != null) {\n                    gamePanel.keyReleased(e);\n                }\n            }\n        });\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (gamePanel != null) {\n                    gamePanel.mousePressed(e);\n                }\n            }\n\n            @Override\n            public void mouseReleased(MouseEvent e) {\n                if (gamePanel != null) {\n                    gamePanel.mouseReleased(e);\n                }\n            }\n        });\n\n        addMouseMotionListener(new MouseMotionAdapter() {\n            @Override\n            public void mouseMoved(MouseEvent e) {\n                if (gamePanel != null) {\n                    gamePanel.mouseMoved(e);\n                }\n            }\n        });\n\n        addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                if (gamePanel != null) {\n                    gamePanel.cleanup();\n                }\n                settingsManager.saveSettings();\n            }\n        });\n\n        setFocusable(true);\n        requestFocus();\n    }\n\n    private void createMenuBar() {\n        menuBar = new JMenuBar();\n        gameMenu = new JMenu(\"Oyun\");\n\n        pauseMenuItem = new JMenuItem(\"Duraklat (P)\");\n        pauseMenuItem.addActionListener(e -> {\n            if (gamePanel != null) {\n                gamePanel.togglePause();\n            }\n        });\n\n        saveMenuItem = new JMenuItem(\"Kaydet\");\n        saveMenuItem.addActionListener(e -> {\n            JFileChooser fileChooser = new JFileChooser();\n            if (fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {\n                File file = fileChooser.getSelectedFile();\n                if (gamePanel != null) {\n                    gamePanel.saveGame(file);\n                }\n            }\n        });\n\n        loadMenuItem = new JMenuItem(\"Yükle\");\n        loadMenuItem.addActionListener(e -> {\n            JFileChooser fileChooser = new JFileChooser();\n            if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {\n                File file = fileChooser.getSelectedFile();\n                if (gamePanel != null) {\n                    gamePanel.loadGame(file);\n                }\n            }\n        });\n\n        exitMenuItem = new JMenuItem(\"Çıkış\");\n        exitMenuItem.addActionListener(e -> System.exit(0));\n\n        gameMenu.add(pauseMenuItem);\n        gameMenu.add(saveMenuItem);\n        gameMenu.add(loadMenuItem);\n        gameMenu.addSeparator();\n        gameMenu.add(exitMenuItem);\n\n        menuBar.add(gameMenu);\n        setJMenuBar(menuBar);\n    }\n\n    public void showMainMenu() {\n        if (gamePanel != null) {\n            gamePanel.cleanup();\n            remove(gamePanel);\n            gamePanel = null;\n        }\n\n        getContentPane().removeAll();\n\n        JPanel mainMenuPanel = new JPanel();\n        mainMenuPanel.setLayout(new BoxLayout(mainMenuPanel, BoxLayout.Y_AXIS));\n        mainMenuPanel.setBackground(Color.DARK_GRAY);\n\n        JLabel titleLabel = new JLabel(\"Deadpool vs Zombies\");\n        titleLabel.setFont(new Font(\"Arial\", Font.BOLD, 28));\n        titleLabel.setForeground(Color.RED);\n        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);\n        mainMenuPanel.add(Box.createVerticalStrut(100));\n        mainMenuPanel.add(titleLabel);\n        mainMenuPanel.add(Box.createVerticalStrut(50));\n\n        JButton startButton = createMenuButton(\"Yeni Oyun\");\n        startButton.addActionListener(e -> startNewGame());\n\n        JButton settingsButton = createMenuButton(\"Ayarlar\");\n        settingsButton.addActionListener(e -> showSettingsMenu());\n\n        JButton exitButton = createMenuButton(\"Çıkış\");\n        exitButton.addActionListener(e -> {\n            settingsManager.saveSettings();\n            System.exit(0);\n        });\n\n        mainMenuPanel.add(startButton);\n        mainMenuPanel.add(Box.createVerticalStrut(20));\n        mainMenuPanel.add(settingsButton);\n        mainMenuPanel.add(Box.createVerticalStrut(20));\n        mainMenuPanel.add(exitButton);\n\n        add(mainMenuPanel);\n        validate();\n        repaint();\n    }\n\n    private JButton createMenuButton(String text) {\n        JButton button = new JButton(text);\n        button.setAlignmentX(Component.CENTER_ALIGNMENT);\n        button.setMaximumSize(new Dimension(200, 50));\n        button.setFont(new Font(\"Arial\", Font.BOLD, 16));\n        return button;\n    }\n\n    private void startNewGame() {\n        getContentPane().removeAll();\n\n        gamePanel = new GamePanel(this);\n        add(gamePanel);\n\n        if (gamePanel.soundManager != null) {\n            settingsManager.applySettings(gamePanel.soundManager);\n        }\n\n        gamePanel.requestFocusInWindow();\n\n        validate();\n        repaint();\n    }\n\n    private void showSettingsMenu() {\n        getContentPane().removeAll();\n\n        JPanel settingsPanel = new JPanel();\n        settingsPanel.setLayout(new BoxLayout(settingsPanel, BoxLayout.Y_AXIS));\n        settingsPanel.setBackground(Color.DARK_GRAY);\n\n        JLabel titleLabel = new JLabel(\"AYARLAR\");\n        titleLabel.setFont(new Font(\"Arial\", Font.BOLD, 24));\n        titleLabel.setForeground(Color.WHITE);\n        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);\n        settingsPanel.add(Box.createVerticalStrut(50));\n        settingsPanel.add(titleLabel);\n        settingsPanel.add(Box.createVerticalStrut(50));\n\n        boolean sfxEnabled = settingsManager.isSfxEnabled();\n        boolean musicEnabled = settingsManager.isMusicEnabled();\n        int sfxValue = (int) (settingsManager.getSfxVolume() * 100);\n        int musicValue = (int) (settingsManager.getMusicVolume() * 100);\n\n        JCheckBox sfxToggleBox = new JCheckBox(\"Ses Efektleri Aktif\", sfxEnabled);\n        sfxToggleBox.setFont(new Font(\"Arial\", Font.BOLD, 16));\n        sfxToggleBox.setForeground(Color.WHITE);\n        sfxToggleBox.setBackground(Color.DARK_GRAY);\n        sfxToggleBox.setAlignmentX(Component.CENTER_ALIGNMENT);\n        settingsPanel.add(sfxToggleBox);\n        settingsPanel.add(Box.createVerticalStrut(10));\n\n        JLabel sfxLabel = new JLabel(\"Ses Efektleri Seviyesi\");\n        sfxLabel.setFont(new Font(\"Arial\", Font.BOLD, 18));\n        sfxLabel.setForeground(Color.WHITE);\n        sfxLabel.setAlignmentX(Component.CENTER_ALIGNMENT);\n        settingsPanel.add(sfxLabel);\n\n        JSlider sfxSlider = new JSlider(JSlider.HORIZONTAL, 0, 100, sfxValue);\n        setupSlider(sfxSlider);\n        settingsPanel.add(sfxSlider);\n        settingsPanel.add(Box.createVerticalStrut(30));\n\n        JCheckBox musicToggleBox = new JCheckBox(\"Müzik Aktif\", musicEnabled);\n        musicToggleBox.setFont(new Font(\"Arial\", Font.BOLD, 16));\n        musicToggleBox.setForeground(Color.WHITE);\n        musicToggleBox.setBackground(Color.DARK_GRAY);\n        musicToggleBox.setAlignmentX(Component.CENTER_ALIGNMENT);\n        settingsPanel.add(musicToggleBox);\n        settingsPanel.add(Box.createVerticalStrut(10));\n\n        JLabel musicLabel = new JLabel(\"Müzik Seviyesi\");\n        musicLabel.setFont(new Font(\"Arial\", Font.BOLD, 18));\n        musicLabel.setForeground(Color.WHITE);\n        musicLabel.setAlignmentX(Component.CENTER_ALIGNMENT);\n        settingsPanel.add(musicLabel);\n\n        JSlider musicSlider = new JSlider(JSlider.HORIZONTAL, 0, 100, musicValue);\n        setupSlider(musicSlider);\n        settingsPanel.add(musicSlider);\n        settingsPanel.add(Box.createVerticalStrut(30));\n\n        // Save button\n        JButton saveButton = createMenuButton(\"Kaydet\");\n        saveButton.addActionListener(e -> {\n            settingsManager.setSfxEnabled(sfxToggleBox.isSelected());\n            settingsManager.setMusicEnabled(musicToggleBox.isSelected());\n            settingsManager.setSfxVolume(sfxSlider.getValue() / 100.0f);\n            settingsManager.setMusicVolume(musicSlider.getValue() / 100.0f);\n\n            settingsManager.saveSettings();\n\n            if (gamePanel != null && gamePanel.soundManager != null) {\n                settingsManager.applySettings(gamePanel.soundManager);\n            }\n\n            System.out.println(\"Ayarlar kaydedildi\");\n\n            showMainMenu();\n        });\n        settingsPanel.add(saveButton);\n        settingsPanel.add(Box.createVerticalStrut(20));\n\n        JButton backButton = createMenuButton(\"Geri\");\n        backButton.addActionListener(e -> showMainMenu());\n        settingsPanel.add(backButton);\n\n        add(settingsPanel);\n        validate();\n        repaint();\n    }\n\n    private void setupSlider(JSlider slider) {\n        slider.setMajorTickSpacing(25);\n        slider.setMinorTickSpacing(5);\n        slider.setPaintTicks(true);\n        slider.setPaintLabels(true);\n        slider.setAlignmentX(Component.CENTER_ALIGNMENT);\n        slider.setMaximumSize(new Dimension(300, 50));\n        slider.setPreferredSize(new Dimension(300, 50));\n\n        // Add custom labels\n        Hashtable<Integer, JLabel> labelTable = new Hashtable<>();\n        labelTable.put(0, createSliderLabel(\"Kapalı\"));\n        labelTable.put(50, createSliderLabel(\"Orta\"));\n        labelTable.put(100, createSliderLabel(\"Yüksek\"));\n        slider.setLabelTable(labelTable);\n    }\n\n    private JLabel createSliderLabel(String text) {\n        JLabel label = new JLabel(text);\n        label.setForeground(Color.WHITE);\n        return label;\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> new GameWindow());\n    }\n}\n",
      "GamePanel.java": "import javax.swing.*;\n\nimport entitys.*;\nimport entitys.zombie.*;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\nimport silah.*;\nimport mermi.*;\n\npublic class GamePanel extends JPanel implements Runnable, MouseListener, KeyListener {\n    private GameWindow gameWindow;\n    private Thread gameThread;\n    private boolean running = false;\n    private boolean paused = false;\n\n    private Player player;\n    private List<Zombie> zombies;\n    private List<Bullet> bullets;\n    private List<Weapon> playerWeapons;\n    private List<AmmoPickup> ammoPickups;\n\n    private int currentWave = 0;\n    private int zombiesKilled = 0;\n    private int totalScore = 0;\n\n    private Random random;\n\n    private String currentMessage = \"\";\n    private long messageDisplayTime = 0;\n\n    private boolean gameOverMenuShown = false;\n\n    private static final int MAP_WIDTH = 1600;\n    private static final int MAP_HEIGHT = 1200;\n\n    private double cameraX = 0;\n    private double cameraY = 0;\n\n    // UI bilgileri\n    private Font uiFont = new Font(\"Arial\", Font.BOLD, 14);\n\n    public SoundManager soundManager;\n\n    public GamePanel(GameWindow gameWindow) {\n        this.gameWindow = gameWindow;\n        setPreferredSize(new Dimension(MAP_WIDTH, MAP_HEIGHT));\n        setBackground(Color.DARK_GRAY);\n        setFocusable(true);\n\n        this.addMouseListener(this);\n\n        random = new Random();\n\n        initializeGame();\n\n        // oyun döngüsünü başlatma\n        startGameLoop();\n    }\n\n    public void initializeGame() {\n\n        ImageUtils.ensureImageFolderExists();\n\n        currentWave = 0;\n        zombiesKilled = 0;\n        totalScore = 0;\n\n        player = new Player(400, 300);\n        zombies = new ArrayList<>();\n        bullets = new ArrayList<>();\n        ammoPickups = new ArrayList<>();\n\n        // sadece başlangıç tabancasını oluştur\n        playerWeapons = new ArrayList<Weapon>();\n        Weapon pistol = new Pistol();\n        playerWeapons.add(pistol);\n        player.setCurrentWeapon(playerWeapons.get(0));\n\n        // keyListener ekleme\n        this.addKeyListener(this);\n\n        // ilk dalgayı başlatma\n        startNextWave();\n\n        // soundmanager başlatma\n        soundManager = new SoundManager();\n\n        // Ses efektlerini yükleme\n        soundManager.loadSoundEffect(\"wave_start\", \"sounds\\\\newwave.wav\");\n        soundManager.loadSoundEffect(\"gameover\", \"sounds\\\\gameover.wav\");\n\n        // Oyun müziğini yükleme\n        try {\n            soundManager.loadBackgroundMusic(\"sounds\\\\gamebackground.wav\");\n            System.out.println(\"Müzik başarıyla yüklendi\");\n        } catch (Exception e) {\n            System.err.println(\"Müzik yüklenirken hata: \" + e.getMessage());\n            e.printStackTrace();\n        }\n\n        // Ses ayarlarını uygula\n        soundManager.toggleSoundEffects(true);\n\n        // Oyun başladığında müziği çal\n        startGameMusic();\n        System.out.println(\"Müzik başladı\");\n    }\n\n    public void startGameMusic() {\n        if (soundManager != null) {\n            System.out.println(\"Müzik başlatılıyor...\");\n            soundManager.toggleMusic(true);\n        } else {\n            System.out.println(\"soundManager null.\");\n        }\n    }\n\n    public void stopGameMusic() {\n        if (soundManager != null) {\n            soundManager.toggleMusic(false);\n        }\n    }\n\n    private void startGameLoop() {\n        if (gameThread != null && gameThread.isAlive()) {\n            running = false;\n            try {\n                gameThread.join(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        running = true;\n        gameThread = new Thread(this);\n        gameThread.start();\n    }\n\n    @Override\n    public void run() {\n        // Oyun döngüsü\n        long lastTime = System.nanoTime();\n        double amountOfTicks = 60.0;\n        double ns = 1000000000 / amountOfTicks;\n        double delta = 0;\n\n        while (running) {\n            long now = System.nanoTime();\n            delta += (now - lastTime) / ns;\n            lastTime = now;\n\n            while (delta >= 1) {\n                if (!paused) {\n                    update();\n                }\n                delta--;\n            }\n\n            repaint();\n\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void update() {\n        // player güncellemesi\n        player.update();\n\n        // zombi güncellemeleri\n        for (int i = zombies.size() - 1; i >= 0; i--) {\n            Zombie zombie = zombies.get(i);\n            zombie.update(player);\n\n            // player ile çarpışma kontrolü\n            if (zombie.intersects(player)) {\n                player.takeDamage(zombie.getDamage());\n\n                double centerPlayerX = player.getX() + player.getWidth() / 2;\n                double centerPlayerY = player.getY() + player.getHeight() / 2;\n                double centerZombieX = zombie.getX() + zombie.getWidth() / 2;\n                double centerZombieY = zombie.getY() + zombie.getHeight() / 2;\n\n                double angle = Math.atan2(centerZombieY - centerPlayerY, centerZombieX - centerPlayerX);\n\n                // zombiyi geri it\n                zombie.x += Math.cos(angle) * 10;\n                zombie.y += Math.sin(angle) * 10;\n\n                // Hasar sonrası kontrol etme\n                if (player.getHealth() <= 0) {\n                    gameOver();\n                    break;\n                }\n            }\n        }\n\n        // mermi güncellemeleri\n        for (int i = bullets.size() - 1; i >= 0; i--) {\n            Bullet bullet = bullets.get(i);\n            bullet.update();\n\n            // merminin ekran dışına çıkma kontrolü\n            if (bullet.isOutOfBounds()) {\n                bullets.remove(i);\n                continue;\n            }\n\n            // zombiler ile çarpışma kontrolü\n            for (int j = zombies.size() - 1; j >= 0; j--) {\n                Zombie zombie = zombies.get(j);\n                if (bullet.intersects(zombie)) {\n                    zombie.takeDamage(bullet.getDamage());\n\n                    // keskin nişancı tüfeği ile merminin zombileri delmesi\n                    if (!(bullet.getWeaponType() == WeaponType.SniperRifle)) {\n                        bullets.remove(i);\n                        break;\n                    }\n\n                    // zombi ölü mü\n                    if (zombie.getHealth() <= 0) {\n                        handleZombieDeath(zombie);\n                        zombiesKilled++;\n                        totalScore += (currentWave * 10); // Dalga numarasına göre puan ver\n\n                        // tüm zombiler öldü mü\n                        if (zombies.isEmpty()) {\n                            startNextWave();\n                        }\n                    }\n                }\n            }\n        }\n\n        // Cephane toplama güncellemeleri\n        for (int i = ammoPickups.size() - 1; i >= 0; i--) {\n            AmmoPickup ammo = ammoPickups.get(i);\n            if (player.intersects(ammo)) {\n                player.collectAmmo(ammo);\n                ammoPickups.remove(i);\n            }\n        }\n        updateZombies();\n    }\n\n    private void handleZombieDeath(Zombie zombie) {\n        zombies.remove(zombie);\n\n        // asit tüküren zombi için özel efekt(diger zombilere hasar)\n        if (zombie instanceof AcidZombie) {\n            for (Zombie nearZombie : zombies) {\n                if (zombie.getDistance(nearZombie) < 50) {\n                    nearZombie.takeDamage(20);\n                }\n            }\n        }\n\n        if (random.nextDouble() < 0.3) {\n            AmmoPickup ammo = new AmmoPickup(zombie.getX(), zombie.getY(),\n                    WeaponType.values()[random.nextInt(WeaponType.values().length)]);\n            ammoPickups.add(ammo);\n        }\n    }\n\n    private void startNextWave() {\n        currentWave++;\n\n        player.setHealth(100);\n\n        playSoundEffect(\"wave_start\");\n\n        // her dalga sonunda yeni silah verme\n        if (currentWave == 1) {\n            // ilk dalgada sadece başlangıç tabancası olsun\n            showMessage(\"Dalga \" + currentWave + \" başladı!\");\n        } else if (currentWave == 2) {\n            playerWeapons.add(new AssaultRifle());\n            showMessage(\"Piyade Tüfeği kazandınız!\");\n        } else if (currentWave == 3) {\n            playerWeapons.add(new Shotgun());\n            showMessage(\"Pompalı Tüfek kazandınız!\");\n        } else if (currentWave == 4) {\n            playerWeapons.add(new SniperRifle());\n            showMessage(\"Keskin Nişancı Tüfeği kazandınız!\");\n        } else if (currentWave == 5) {\n            playerWeapons.add(new RocketLauncher());\n            showMessage(\"Roketatar kazandınız!\");\n        } else if (currentWave > 5) {\n            showMessage(\"Dalga \" + currentWave + \" başladı!\");\n        }\n\n        // dalgaya göre zombileri oluştur\n        createZombiesForWave();\n    }\n\n    private void createZombiesForWave() {\n        int baseZombieCount = 5;\n        int zombieCount = baseZombieCount + (currentWave * 2);\n\n        for (int i = 0; i < zombieCount; i++) {\n            // geniş harita için spawn\n            int x = random.nextInt(MAP_WIDTH);\n            int y = random.nextInt(MAP_HEIGHT);\n\n            // playerdan belirli bir mesafede spawn ol\n            while (Math.abs(x - player.getX()) < 300 && Math.abs(y - player.getY()) < 300) {\n                x = random.nextInt(MAP_WIDTH);\n                y = random.nextInt(MAP_HEIGHT);\n            }\n\n            Zombie zombie = createZombieBasedOnWave(x, y);\n            zombies.add(zombie);\n        }\n\n    }\n\n    private Zombie createZombieBasedOnWave(int x, int y) {\n        double zombieType = random.nextDouble();\n\n        if (currentWave >= 7 && zombieType < 0.2) {\n            return new AcidZombie((double) x, (double) y);\n        } else if (currentWave >= 5 && zombieType < 0.4) {\n            return new TankZombie((double) x, (double) y);\n        } else if (currentWave >= 3 && zombieType < 0.6) {\n            return new CrawlerZombie((double) x, (double) y);\n        } else {\n            return new NormalZombie((double) x, (double) y);\n        }\n    }\n\n    private void showMessage(String message) {\n        currentMessage = message;\n        messageDisplayTime = System.currentTimeMillis() + 3000;\n\n        this.requestFocusInWindow();\n    }\n\n    private void gameOver() {\n        running = false;\n        gameOverMenuShown = true;\n\n        if (soundManager != null) {\n            soundManager.stopMusic();\n            soundManager.playSoundEffect(\"gameover\");\n            System.out.println(\"Gameover sound played\");\n        }\n\n        repaint();\n    }\n\n    public void keyPressed(KeyEvent e) {\n        if (gameOverMenuShown) {\n            if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {\n                gameWindow.showMainMenu();\n            }\n            return;\n        }\n\n        if (e.getKeyCode() == KeyEvent.VK_ESCAPE || e.getKeyCode() == KeyEvent.VK_P) {\n            togglePause();\n            return;\n        }\n\n        if (paused) {\n            if (e.getKeyCode() == KeyEvent.VK_ESCAPE || e.getKeyCode() == KeyEvent.VK_P) {\n                togglePause();\n            }\n            return;\n        }\n\n        // Silah değiştirme tuşları (1-5 arası rakamlar)\n        if (e.getKeyCode() >= KeyEvent.VK_1 && e.getKeyCode() <= KeyEvent.VK_5) {\n            int weaponIndex = e.getKeyCode() - KeyEvent.VK_1;\n            if (weaponIndex < playerWeapons.size()) {\n                player.setCurrentWeapon(playerWeapons.get(weaponIndex));\n                showMessage(playerWeapons.get(weaponIndex).getName() + \" seçildi!\");\n            }\n        }\n\n        // R tuşu ile yeniden doldurma\n        if (e.getKeyCode() == KeyEvent.VK_R) {\n            if (player.getCurrentWeapon() != null) {\n                Weapon currentWeapon = player.getCurrentWeapon();\n\n                int ammoNeeded = currentWeapon.getsarjorSize() - currentWeapon.getCurrentAmmo();\n\n                if (ammoNeeded > 0 && currentWeapon.getTotalAmmo() > 0) {\n                    if (currentWeapon.getTotalAmmo() >= ammoNeeded) {\n                        currentWeapon.setCurrentAmmo(currentWeapon.getsarjorSize());\n                        currentWeapon.setTotalAmmo(currentWeapon.getTotalAmmo() - ammoNeeded);\n                    } else {\n                        currentWeapon.setCurrentAmmo(currentWeapon.getCurrentAmmo() + currentWeapon.getTotalAmmo());\n                        currentWeapon.setTotalAmmo(0);\n                    }\n\n                    showMessage(currentWeapon.getName() + \" yeniden dolduruldu!\");\n                }\n            }\n        }\n\n        player.keyPressed(e);\n    }\n\n    public void keyReleased(KeyEvent e) {\n        player.keyReleased(e);\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        if (!gameOverMenuShown) {\n            player.mousePressed(e, bullets);\n        }\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        if (!gameOverMenuShown) {\n            player.mouseReleased(e);\n        }\n    }\n\n    public void mouseMoved(MouseEvent e) {\n        player.mouseMoved(e);\n    }\n\n    public void togglePause() {\n        paused = !paused;\n\n        if (soundManager != null) {\n            if (paused) {\n                soundManager.pauseMusic();\n                showMessage(\"Oyun Duraklatıldı\");\n            } else {\n                if (soundManager.isMusicEnabled()) {\n                    soundManager.resumeMusic();\n                }\n                showMessage(\"Oyun Devam Ediyor\");\n            }\n        }\n    }\n\n    public void saveGame(File file) {\n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file))) {\n            GameState gameState = new GameState(\n                    player, zombies, bullets, playerWeapons,\n                    ammoPickups, currentWave, zombiesKilled, totalScore);\n            oos.writeObject(gameState);\n            showMessage(\"Oyun kaydedildi!\");\n        } catch (IOException e) {\n            e.printStackTrace();\n            showMessage(\"Oyun kaydedilemedi!\");\n        }\n    }\n\n    public void loadGame(File file) {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file))) {\n            GameState gameState = (GameState) ois.readObject();\n\n            player = gameState.getPlayer();\n            zombies = gameState.getZombies();\n            bullets = gameState.getBullets();\n            playerWeapons = gameState.getPlayerWeapons();\n            ammoPickups = gameState.getAmmoPickups();\n            currentWave = gameState.getCurrentWave();\n            zombiesKilled = gameState.getZombiesKilled();\n            totalScore = gameState.getTotalScore();\n\n            for (Weapon weapon : playerWeapons) {\n                weapon.setBulletList(bullets);\n            }\n\n            if (player.getCurrentWeapon() == null && !playerWeapons.isEmpty()) {\n                player.setCurrentWeapon(playerWeapons.get(0));\n            }\n\n            if (!player.isImageLoaded()) {\n                player.loadPlayerImage();\n            }\n\n            showMessage(\"Oyun yüklendi!\");\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n            showMessage(\"Oyun yüklenemedi!\");\n        }\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2d = (Graphics2D) g;\n\n        g2d.translate(-cameraX, -cameraY);\n\n        g2d.setColor(Color.DARK_GRAY);\n        g2d.fillRect(0, 0, getWidth(), getHeight());\n\n        // Zombileri çiz\n        for (Zombie zombie : zombies) {\n            zombie.draw(g2d);\n        }\n\n        // Mermileri çiz\n        for (Bullet bullet : bullets) {\n            bullet.draw(g2d);\n        }\n\n        for (AmmoPickup ammo : ammoPickups) {\n            ammo.draw(g2d);\n        }\n\n        // Oyuncuyu çiz\n        player.draw(g2d);\n\n        // UI bilgilerini çiz\n        g2d.translate(cameraX, cameraY);\n        drawUI(g2d);\n\n        // Mini haritayı çiz (UI elemanlarının üzerine)\n        drawMiniMap(g2d);\n\n        if (!currentMessage.isEmpty() && System.currentTimeMillis() < messageDisplayTime) {\n            g2d.setColor(new Color(0, 0, 0, 150));\n            g2d.fillRect(getWidth() / 4, getHeight() / 3, getWidth() / 2, 40);\n            g2d.setColor(Color.WHITE);\n            g2d.setFont(new Font(\"Arial\", Font.BOLD, 18));\n            int textWidth = g2d.getFontMetrics().stringWidth(currentMessage);\n            g2d.drawString(currentMessage, (getWidth() - textWidth) / 2, getHeight() / 3 + 28);\n        }\n\n        // Duraklatma\n        if (paused) {\n            g2d.setColor(new Color(0, 0, 0, 150));\n            g2d.fillRect(0, 0, getWidth(), getHeight());\n            g2d.setColor(Color.WHITE);\n            g2d.setFont(new Font(\"Arial\", Font.BOLD, 36));\n            String pauseText = \"DURAKLATILDI\";\n            int textWidth = g2d.getFontMetrics().stringWidth(pauseText);\n            g2d.drawString(pauseText, (getWidth() - textWidth) / 2, getHeight() / 2);\n        }\n\n        if (gameOverMenuShown) {\n            g2d.setColor(new Color(0, 0, 0, 180));\n            g2d.fillRect(0, 0, getWidth(), getHeight());\n\n            g2d.setColor(Color.WHITE);\n            g2d.setFont(new Font(\"Arial\", Font.BOLD, 36));\n            String gameOverText = \"OYUN BİTTİ\";\n            String scoreText = \"Toplam Puan: \" + totalScore;\n\n            int gameOverWidth = g2d.getFontMetrics().stringWidth(gameOverText);\n            int scoreWidth = g2d.getFontMetrics(g2d.getFont()).stringWidth(scoreText);\n\n            g2d.drawString(gameOverText, (getWidth() - gameOverWidth) / 2, getHeight() / 2 - 30);\n            g2d.setFont(new Font(\"Arial\", Font.BOLD, 24));\n            g2d.drawString(scoreText, (getWidth() - scoreWidth) / 2 + 50, getHeight() / 2 + 20);\n\n            drawButton(g2d, \"Yeniden Başla\", getWidth() / 2 - 100, getHeight() / 2 + 70, 200, 50);\n            drawButton(g2d, \"Ana Menü\", getWidth() / 2 - 100, getHeight() / 2 + 140, 200, 50);\n        }\n    }\n\n    private void drawUI(Graphics2D g2d) {\n        g2d.setFont(uiFont);\n\n        // Sol üst köşe ve silah bilgisi\n        g2d.setColor(Color.WHITE);\n        g2d.drawString(\"Silah: \" + player.getCurrentWeapon().getName(), 10, 20);\n        g2d.drawString(\"Şarjör: \" + player.getCurrentWeapon().getCurrentAmmo() +\n                \" / \" + player.getCurrentWeapon().getsarjorSize(), 10, 40);\n        g2d.drawString(\"Toplam Mermi: \" + player.getCurrentWeapon().getTotalAmmo(), 10, 60);\n\n        // envanterdeki silahları göster\n        g2d.drawString(\"Silahlar:\", 10, 80);\n        for (int i = 0; i < playerWeapons.size(); i++) {\n            Weapon weapon = playerWeapons.get(i);\n            g2d.drawString((i + 1) + \": \" + weapon.getName(), 10, 100 + (i * 20));\n        }\n\n        // Sağ üst köşe ve player bilgisi\n        String healthText = \"Can: \" + player.getHealth();\n        String scoreText = \"Puan: \" + totalScore;\n        String waveText = \"Dalga: \" + currentWave;\n\n        int healthWidth = g2d.getFontMetrics().stringWidth(healthText);\n        int scoreWidth = g2d.getFontMetrics().stringWidth(scoreText);\n        int waveWidth = g2d.getFontMetrics().stringWidth(waveText);\n\n        g2d.drawString(healthText, getWidth() - healthWidth - 10, 20);\n        g2d.drawString(scoreText, getWidth() - scoreWidth - 10, 40);\n        g2d.drawString(waveText, getWidth() - waveWidth - 10, 60);\n    }\n\n    private void updateZombies() {\n        List<Zombie> zombiesToRemove = new ArrayList<>();\n\n        for (Zombie zombie : zombies) {\n            zombie.update(player);\n\n            if (zombie.getHealth() <= 0) {\n                zombiesToRemove.add(zombie);\n                zombiesKilled++;\n                totalScore += (currentWave * 10);\n            }\n        }\n\n        zombies.removeAll(zombiesToRemove);\n\n        if (!zombiesToRemove.isEmpty() && zombies.isEmpty()) {\n            startNextWave();\n        }\n\n        if (!zombiesToRemove.isEmpty()) {\n            System.out.println(zombiesToRemove.size() + \" zombi öldürüldü. Kalan zombi: \" + zombies.size());\n        }\n    }\n\n    private void drawButton(Graphics2D g2d, String text, int x, int y, int width, int height) {\n        g2d.setColor(new Color(80, 80, 80));\n        g2d.fillRect(x, y, width, height);\n        g2d.setColor(Color.BLACK);\n        g2d.drawRect(x, y, width, height);\n\n        g2d.setColor(Color.WHITE);\n        g2d.setFont(new Font(\"Arial\", Font.BOLD, 18));\n        int textWidth = g2d.getFontMetrics().stringWidth(text);\n        g2d.drawString(text, x + (width - textWidth) / 2, y + height / 2 + 5);\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        if (gameOverMenuShown) {\n            int mouseX = e.getX();\n            int mouseY = e.getY();\n\n            if (mouseX >= getWidth() / 2 - 100 && mouseX <= getWidth() / 2 + 100 &&\n                    mouseY >= getHeight() / 2 + 70 && mouseY <= getHeight() / 2 + 120) {\n\n                System.out.println(\"Yeniden başla clicked\");\n                gameOverMenuShown = false;\n                initializeGame();\n                startGameLoop();\n                this.requestFocusInWindow();\n            }\n\n            if (mouseX >= getWidth() / 2 - 100 && mouseX <= getWidth() / 2 + 100 &&\n                    mouseY >= getHeight() / 2 + 140 && mouseY <= getHeight() / 2 + 190) {\n\n                System.out.println(\"Ana menü clicked\");\n                gameOverMenuShown = false;\n                gameWindow.showMainMenu();\n            }\n        }\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e) {\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n    }\n\n    // MİNİMAP\n    private void drawMiniMap(Graphics2D g2d) {\n        int miniMapWidth = 150;\n        int miniMapHeight = 100;\n\n        g2d.setColor(new Color(0, 0, 0, 150));\n        g2d.fillRect(205, 10, miniMapWidth, miniMapHeight);\n\n        g2d.setColor(Color.GREEN);\n        int playerMiniX = 205 + (int) ((player.getX() / MAP_WIDTH) * miniMapWidth);\n        int playerMiniY = 10 + (int) ((player.getY() / MAP_HEIGHT) * miniMapHeight);\n        g2d.fillOval(playerMiniX, playerMiniY, 5, 5);\n\n        g2d.setColor(Color.RED);\n        for (Zombie zombie : zombies) {\n            int zombieMiniX = 205 + (int) ((zombie.getX() / MAP_WIDTH) * miniMapWidth);\n            int zombieMiniY = 10 + (int) ((zombie.getY() / MAP_HEIGHT) * miniMapHeight);\n            g2d.fillOval(zombieMiniX, zombieMiniY, 3, 3);\n        }\n    }\n\n    public void playSoundEffect(String name) {\n        if (soundManager != null) {\n            soundManager.playSoundEffect(name);\n        }\n    }\n\n    public void cleanup() {\n        stopGameMusic();\n        if (soundManager != null) {\n            soundManager.cleanup();\n        }\n    }\n\n}\n",
      "SettingsManager.java": "import java.io.*;\nimport java.util.Properties;\n\npublic class SettingsManager {\n    private static final String SETTINGS_FILE = \"gamesettings.properties\";\n\n    // Default settings\n    private static final boolean DEFAULT_SFX_ENABLED = true;\n    private static final boolean DEFAULT_MUSIC_ENABLED = true;\n    private static final float DEFAULT_SFX_VOLUME = 0.6f;\n    private static final float DEFAULT_MUSIC_VOLUME = 0.3f;\n\n    private boolean sfxEnabled;\n    private boolean musicEnabled;\n    private float sfxVolume;\n    private float musicVolume;\n\n    private static SettingsManager instance;\n\n    public static SettingsManager getInstance() {\n        if (instance == null) {\n            instance = new SettingsManager();\n        }\n        return instance;\n    }\n\n    private SettingsManager() {\n        loadSettings();\n    }\n\n    public void loadSettings() {\n        Properties props = new Properties();\n        File settingsFile = new File(SETTINGS_FILE);\n\n        if (settingsFile.exists()) {\n            try (FileInputStream in = new FileInputStream(settingsFile)) {\n                props.load(in);\n\n                sfxEnabled = Boolean\n                        .parseBoolean(props.getProperty(\"sfx_enabled\", String.valueOf(DEFAULT_SFX_ENABLED)));\n                musicEnabled = Boolean\n                        .parseBoolean(props.getProperty(\"music_enabled\", String.valueOf(DEFAULT_MUSIC_ENABLED)));\n\n                sfxVolume = Float.parseFloat(props.getProperty(\"sfx_volume\", String.valueOf(DEFAULT_SFX_VOLUME)));\n                musicVolume = Float.parseFloat(props.getProperty(\"music_volume\", String.valueOf(DEFAULT_MUSIC_VOLUME)));\n\n                System.out.println(\"Settings loaded: \" +\n                        \"SFX=\" + sfxEnabled +\n                        \", SFX Volume=\" + sfxVolume +\n                        \", Music=\" + musicEnabled +\n                        \", Music Volume=\" + musicVolume);\n            } catch (IOException e) {\n                System.err.println(\"Error loading settings: \" + e.getMessage());\n                useDefaultSettings();\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid number in settings file: \" + e.getMessage());\n                useDefaultSettings();\n            }\n        } else {\n            useDefaultSettings();\n            saveSettings();\n        }\n    }\n\n    public void saveSettings() {\n        Properties props = new Properties();\n\n        props.setProperty(\"sfx_enabled\", String.valueOf(sfxEnabled));\n        props.setProperty(\"music_enabled\", String.valueOf(musicEnabled));\n        props.setProperty(\"sfx_volume\", String.valueOf(sfxVolume));\n        props.setProperty(\"music_volume\", String.valueOf(musicVolume));\n\n        try (FileOutputStream out = new FileOutputStream(SETTINGS_FILE)) {\n            props.store(out, \"Game Settings\");\n            System.out.println(\"Settings saved successfully!\");\n        } catch (IOException e) {\n            System.err.println(\"Error saving settings: \" + e.getMessage());\n        }\n    }\n\n    private void useDefaultSettings() {\n        sfxEnabled = DEFAULT_SFX_ENABLED;\n        musicEnabled = DEFAULT_MUSIC_ENABLED;\n        sfxVolume = DEFAULT_SFX_VOLUME;\n        musicVolume = DEFAULT_MUSIC_VOLUME;\n        System.out.println(\"Using default settings\");\n    }\n\n    public void applySettings(SoundManager soundManager) {\n        if (soundManager != null) {\n            soundManager.toggleSoundEffects(sfxEnabled);\n            soundManager.toggleMusic(musicEnabled);\n            soundManager.setEffectsVolume(sfxVolume);\n            soundManager.setMusicVolume(musicVolume);\n        }\n    }\n\n    public boolean isSfxEnabled() {\n        return sfxEnabled;\n    }\n\n    public void setSfxEnabled(boolean sfxEnabled) {\n        this.sfxEnabled = sfxEnabled;\n    }\n\n    public boolean isMusicEnabled() {\n        return musicEnabled;\n    }\n\n    public void setMusicEnabled(boolean musicEnabled) {\n        this.musicEnabled = musicEnabled;\n    }\n\n    public float getSfxVolume() {\n        return sfxVolume;\n    }\n\n    public void setSfxVolume(float sfxVolume) {\n        if (sfxVolume < 0f)\n            sfxVolume = 0f;\n        if (sfxVolume > 1.0f)\n            sfxVolume = 1.0f;\n        this.sfxVolume = sfxVolume;\n    }\n\n    public float getMusicVolume() {\n        return musicVolume;\n    }\n\n    public void setMusicVolume(float musicVolume) {\n        if (musicVolume < 0f)\n            musicVolume = 0f;\n        if (musicVolume > 1.0f)\n            musicVolume = 1.0f;\n        this.musicVolume = musicVolume;\n    }\n}\n",
      "Game.java": "public class Game {\n    public static void main(String[] args) {\n        // Oyunu başlatma\n        GameWindow gameWindow = new GameWindow();\n        gameWindow.setVisible(true);\n    }\n}\n",
      "SoundManager.java": "import javax.sound.sampled.*;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SoundManager {\n    private Clip backgroundMusic;\n    private Map<String, Clip> soundEffects;\n    private boolean musicEnabled = true;\n    private boolean soundEffectsEnabled = true;\n    private float musicVolume = 1.0f; // 1.0 = 100%\n    private float effectsVolume = 1.0f;\n\n    private boolean wasMusicPlaying = false;\n\n    public SoundManager() {\n        soundEffects = new HashMap<>();\n    }\n\n    public void loadBackgroundMusic(String filePath) {\n        try {\n            if (backgroundMusic != null) {\n                backgroundMusic.close();\n            }\n\n            System.out.println(\"Müzik dosyası yükleniyor: \" + filePath);\n            File musicFile = new File(filePath);\n            if (!musicFile.exists()) {\n                System.err.println(\"Müzik dosyası bulunamadı: \" + musicFile.getAbsolutePath());\n                return;\n            }\n\n            AudioInputStream audioStream = AudioSystem.getAudioInputStream(musicFile);\n\n            backgroundMusic = AudioSystem.getClip();\n            backgroundMusic.open(audioStream);\n\n            backgroundMusic.loop(Clip.LOOP_CONTINUOUSLY);\n\n            setMusicVolume(musicVolume);\n\n            System.out.println(\"Müzik dosyası başarıyla yüklendi!\");\n\n        } catch (UnsupportedAudioFileException | IOException | LineUnavailableException e) {\n            System.err.println(\"Müzik yüklenirken hata: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public void loadSoundEffect(String name, String filePath) {\n        try {\n            File soundFile = new File(filePath);\n            AudioInputStream audioStream = AudioSystem.getAudioInputStream(soundFile);\n\n            Clip clip = AudioSystem.getClip();\n            clip.open(audioStream);\n\n            soundEffects.put(name, clip);\n        } catch (UnsupportedAudioFileException | IOException | LineUnavailableException e) {\n            System.err.println(\"Error loading sound effect: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public void playSoundEffect(String name) {\n        if (!soundEffectsEnabled)\n            return;\n\n        Clip clip = soundEffects.get(name);\n        if (clip != null) {\n            clip.stop();\n            clip.setFramePosition(0);\n\n            setClipVolume(clip, effectsVolume);\n\n            clip.start();\n        }\n    }\n\n    public void toggleMusic(boolean enabled) {\n        musicEnabled = enabled;\n\n        if (backgroundMusic != null) {\n            if (musicEnabled) {\n                try {\n                    backgroundMusic.setFramePosition(0);\n                    backgroundMusic.start();\n                    wasMusicPlaying = true;\n                    setMusicVolume(musicVolume);\n                    System.out.println(\"Müzik başlatıldı, ses seviyesi: \" + musicVolume);\n                } catch (Exception e) {\n                    System.err.println(\"Müzik başlatılırken hata: \" + e.getMessage());\n                    e.printStackTrace();\n                }\n            } else {\n                backgroundMusic.stop();\n                wasMusicPlaying = false;\n                System.out.println(\"Müzik durduruldu\");\n            }\n        } else {\n            System.out.println(\"backgroundMusic null - müzik çalınamıyor!\");\n        }\n    }\n\n    public void toggleSoundEffects(boolean enabled) {\n        soundEffectsEnabled = enabled;\n        System.out.println(\"Ses efektleri \" + (enabled ? \"açıldı\" : \"kapatıldı\"));\n    }\n\n    public void setMusicVolume(float volume) {\n        if (volume < 0f)\n            volume = 0f;\n        if (volume > 1.0f)\n            volume = 1.0f;\n\n        this.musicVolume = volume;\n        System.out.println(\"Müzik ses seviyesi ayarlandı: \" + volume);\n\n        if (backgroundMusic != null) {\n            setClipVolume(backgroundMusic, volume);\n        }\n    }\n\n    public void setEffectsVolume(float volume) {\n        if (volume < 0f)\n            volume = 0f;\n        if (volume > 1.0f)\n            volume = 1.0f;\n\n        this.effectsVolume = volume;\n        System.out.println(\"Efekt ses seviyesi ayarlandı: \" + volume);\n\n        for (Clip clip : soundEffects.values()) {\n            if (clip != null) {\n                setClipVolume(clip, volume);\n            }\n        }\n    }\n\n    public void setAllVolumes(float volume) {\n        setMusicVolume(volume);\n        setEffectsVolume(volume);\n    }\n\n    private void setClipVolume(Clip clip, float volume) {\n        try {\n            if (clip.isControlSupported(FloatControl.Type.MASTER_GAIN)) {\n                FloatControl gainControl = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);\n\n                float dB = (volume > 0) ? 20f * (float) Math.log10(volume) : -80.0f;\n\n                float min = gainControl.getMinimum();\n                float max = gainControl.getMaximum();\n                dB = Math.max(min, Math.min(max, dB));\n\n                gainControl.setValue(dB);\n                System.out.println(\"Clip ses seviyesi ayarlandı: \" + volume + \" (\" + dB + \" dB)\");\n            } else {\n                System.out.println(\"Bu clip için ses kontrolü desteklenmiyor!\");\n            }\n        } catch (Exception e) {\n            System.err.println(\"Ses seviyesi ayarlanırken hata: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public boolean isMusicEnabled() {\n        return musicEnabled;\n    }\n\n    public boolean isSoundEffectsEnabled() {\n        return soundEffectsEnabled;\n    }\n\n    public float getMusicVolume() {\n        return musicVolume;\n    }\n\n    public float getEffectsVolume() {\n        return effectsVolume;\n    }\n\n    public void cleanup() {\n        if (backgroundMusic != null) {\n            backgroundMusic.stop();\n            backgroundMusic.close();\n        }\n\n        for (Clip clip : soundEffects.values()) {\n            if (clip != null) {\n                clip.stop();\n                clip.close();\n            }\n        }\n    }\n\n    public void pauseMusic() {\n        if (backgroundMusic != null && backgroundMusic.isRunning()) {\n            wasMusicPlaying = true;\n            backgroundMusic.stop();\n            System.out.println(\"Müzik duraklatıldı\");\n        } else {\n            wasMusicPlaying = false;\n        }\n    }\n\n    public void resumeMusic() {\n        if (backgroundMusic != null && wasMusicPlaying && musicEnabled) {\n            backgroundMusic.start();\n            System.out.println(\"Müzik devam ediyor\");\n        }\n    }\n\n    public void stopMusic() {\n        if (backgroundMusic != null) {\n            backgroundMusic.stop();\n            backgroundMusic.setFramePosition(0);\n            wasMusicPlaying = false;\n            System.out.println(\"Müzik durduruldu ve sıfırlandı\");\n        }\n    }\n}\n",
      "ImageUtils.java": "import java.io.File;\n\npublic class ImageUtils {\n\n    public static boolean ensureImageFolderExists() {\n        File imageFolder = new File(\"images\");\n\n        if (!imageFolder.exists()) {\n            boolean created = imageFolder.mkdir();\n            if (created) {\n                System.out.println(\"images klasörü oluşturuldu.\");\n                return true;\n            } else {\n                System.err.println(\"images klasörü oluşturulamadı!\");\n                return false;\n            }\n        } else {\n            File playerImage = new File(\"images/player.png\");\n            if (!playerImage.exists()) {\n                System.out.println(\n                        \"Uyarı: images/player.png bulunamadı. Oyuncu resim olarak varsayılan oval kullanılacak.\");\n            }\n            return true;\n        }\n    }\n}\n",
      "GameState.java": "import java.io.Serializable;\nimport java.util.List;\n\nimport entitys.*;\nimport entitys.zombie.*;\nimport silah.*;\nimport mermi.*;\n\npublic class GameState implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private Player player;\n    private List<Zombie> zombies;\n    private List<Bullet> bullets;\n    private List<Weapon> playerWeapons;\n    private List<AmmoPickup> ammoPickups;\n    private int currentWave;\n    private int zombiesKilled;\n    private int totalScore;\n\n    public GameState(Player player, List<Zombie> zombies, List<Bullet> bullets,\n            List<Weapon> playerWeapons, List<AmmoPickup> ammoPickups,\n            int currentWave, int zombiesKilled, int totalScore) {\n        this.player = player;\n        this.zombies = zombies;\n        this.bullets = bullets;\n        this.playerWeapons = playerWeapons;\n        this.ammoPickups = ammoPickups;\n        this.currentWave = currentWave;\n        this.zombiesKilled = zombiesKilled;\n        this.totalScore = totalScore;\n    }\n\n    public Player getPlayer() {\n        return player;\n    }\n\n    public List<Zombie> getZombies() {\n        return zombies;\n    }\n\n    public List<Bullet> getBullets() {\n        return bullets;\n    }\n\n    public List<Weapon> getPlayerWeapons() {\n        return playerWeapons;\n    }\n\n    public List<AmmoPickup> getAmmoPickups() {\n        return ammoPickups;\n    }\n\n    public int getCurrentWave() {\n        return currentWave;\n    }\n\n    public int getZombiesKilled() {\n        return zombiesKilled;\n    }\n\n    public int getTotalScore() {\n        return totalScore;\n    }\n\n    public void resolveReferences() {\n        for (Weapon weapon : playerWeapons) {\n            weapon.setBulletList(bullets);\n        }\n        if (!playerWeapons.isEmpty()) {\n            player.setCurrentWeapon(playerWeapons.get(0));\n        }\n    }\n}\n",
      "Bullet.java": "package mermi;\n\nimport java.awt.*;\n\nimport entitys.*;\nimport silah.*;\n\npublic class Bullet implements Entity {\n    private static final long serialVersionUID = 1L;\n\n    protected double x, y;\n    protected double veloX, veloY;\n    protected double angle;\n    protected double speed = 10.0;\n    protected int width = 4;\n    protected int height = 4;\n    protected int damage;\n    protected WeaponType weaponType;\n    protected boolean isPenetrating = false; // keskin nişancı tüfeği\n    private static final int MAP_WIDTH = 1600;\n    private static final int MAP_HEIGHT = 1200;\n\n    public Bullet(double x, double y, double angle, int damage, WeaponType weaponType) {\n        this.x = x;\n        this.y = y;\n        this.angle = angle;\n        this.damage = damage;\n        this.weaponType = weaponType;\n\n        veloX = Math.cos(angle) * speed;\n        veloY = Math.sin(angle) * speed;\n    }\n\n    @Override\n    public void update() {\n        x += veloX;\n        y += veloY;\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        g2d.setColor(getBulletColor());\n        g2d.fillOval((int) x - width / 2, (int) y - height / 2, width, height);\n    }\n\n    public boolean isOutOfBounds() {\n        return x < 0 || x > MAP_WIDTH || y < 0 || y > MAP_HEIGHT;\n    }\n\n    private Color getBulletColor() {\n        switch (weaponType) {\n            case Pistol:\n                return Color.YELLOW;\n            case AssaultRifle:\n                return Color.ORANGE;\n            case Shotgun:\n                return Color.RED;\n            case SniperRifle:\n                return Color.WHITE;\n            case RocketLauncher:\n                return Color.RED;\n            default:\n                return Color.WHITE;\n        }\n    }\n\n    @Override\n    public double getX() {\n        return x;\n    }\n\n    @Override\n    public double getY() {\n        return y;\n    }\n\n    @Override\n    public int getWidth() {\n        return width;\n    }\n\n    @Override\n    public int getHeight() {\n        return height;\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public WeaponType getWeaponType() {\n        return weaponType;\n    }\n\n    public boolean isPenetrating() {\n        return isPenetrating;\n    }\n\n    public void setPenetrating(boolean penetrating) {\n        this.isPenetrating = penetrating;\n    }\n\n    @Override\n    public boolean intersects(Entity other) {\n        return x - width / 2 < other.getX() + other.getWidth() &&\n                x + width / 2 > other.getX() &&\n                y - height / 2 < other.getY() + other.getHeight() &&\n                y + height / 2 > other.getY();\n    }\n\n    @Override\n    public double getDistance(Entity other) {\n        double centerX = x;\n        double centerY = y;\n        double otherCenterX = other.getX() + other.getWidth() / 2;\n        double otherCenterY = other.getY() + other.getHeight() / 2;\n\n        return Math.sqrt(Math.pow(centerX - otherCenterX, 2) + Math.pow(centerY - otherCenterY, 2));\n    }\n}",
      "Rocket.java": "package mermi;\n\nimport java.awt.*;\nimport java.util.List;\n\nimport entitys.*;\nimport entitys.zombie.*;\nimport silah.*;\n\npublic class Rocket extends Bullet {\n    private static final long serialVersionUID = 1L;\n\n    private int explosionRadius = 100;\n    private Color trailColor = new Color(255, 140, 0, 150);\n\n    public Rocket(double x, double y, double angle, int damage, WeaponType weaponType) {\n        super(x, y, angle, damage, weaponType);\n        this.speed = 5.0;\n        this.width = 8;\n        this.height = 8;\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        g2d.setColor(Color.RED);\n        g2d.fillOval((int) x - width / 2, (int) y - height / 2, width, height);\n\n        // efekt bırakma\n        g2d.setColor(trailColor);\n        double trailLength = 20.0;\n        double trailX = x - Math.cos(angle) * trailLength;\n        double trailY = y - Math.sin(angle) * trailLength;\n        g2d.drawLine((int) x, (int) y, (int) trailX, (int) trailY);\n    }\n\n    public void explode(List<Zombie> zombies) {\n        for (Zombie zombie : zombies) {\n            double distance = getDistance(zombie);\n            if (distance <= explosionRadius) {\n                double damageMultiplier = 1.0 - (distance / explosionRadius);\n                int explosionDamage = (int) (damage * damageMultiplier);\n                zombie.takeDamage(explosionDamage);\n            }\n        }\n    }\n}\n",
      "AmmoPickup.java": "package mermi;\n\nimport java.awt.*;\n\nimport entitys.*;\nimport silah.*;\n\npublic class AmmoPickup implements Entity {\n    private static final long serialVersionUID = 1L;\n\n    private double x, y;\n    private int width = 15;\n    private int height = 15;\n    private WeaponType weaponType;\n    private int amount;\n\n    public AmmoPickup(double x, double y, WeaponType weaponType) {\n        this.x = x;\n        this.y = y;\n        this.weaponType = weaponType;\n\n        switch (weaponType) {\n            case Pistol:\n                amount = 12;\n                break;\n            case AssaultRifle:\n                amount = 30;\n                break;\n            case Shotgun:\n                amount = 5;\n                break;\n            case SniperRifle:\n                amount = 5;\n                break;\n            case RocketLauncher:\n                amount = 1;\n                break;\n            default:\n                amount = 10;\n        }\n    }\n\n    @Override\n    public void update() {\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        g2d.setColor(getAmmoColor());\n        g2d.fillRect((int) x, (int) y, width, height);\n        g2d.setColor(Color.BLACK);\n        g2d.drawRect((int) x, (int) y, width, height);\n    }\n\n    private Color getAmmoColor() {\n        switch (weaponType) {\n            case Pistol:\n                return Color.YELLOW;\n            case AssaultRifle:\n                return Color.ORANGE;\n            case Shotgun:\n                return Color.RED;\n            case SniperRifle:\n                return Color.WHITE;\n            case RocketLauncher:\n                return new Color(128, 0, 0);\n            default:\n                return Color.GRAY;\n        }\n    }\n\n    @Override\n    public double getX() {\n        return x;\n    }\n\n    @Override\n    public double getY() {\n        return y;\n    }\n\n    @Override\n    public int getWidth() {\n        return width;\n    }\n\n    @Override\n    public int getHeight() {\n        return height;\n    }\n\n    public WeaponType getWeaponType() {\n        return weaponType;\n    }\n\n    public int getAmount() {\n        return amount;\n    }\n\n    @Override\n    public boolean intersects(Entity other) {\n        return x < other.getX() + other.getWidth() &&\n                x + width > other.getX() &&\n                y < other.getY() + other.getHeight() &&\n                y + height > other.getY();\n    }\n\n    @Override\n    public double getDistance(Entity other) {\n        double centerX = x + width / 2;\n        double centerY = y + height / 2;\n        double otherCenterX = other.getX() + other.getWidth() / 2;\n        double otherCenterY = other.getY() + other.getHeight() / 2;\n\n        return Math.sqrt(Math.pow(centerX - otherCenterX, 2) + Math.pow(centerY - otherCenterY, 2));\n    }\n}\n",
      "Entity.java": "package entitys;\n\nimport java.awt.Graphics2D;\nimport java.io.Serializable;\n\npublic interface Entity extends Serializable {\n    void update();\n\n    void draw(Graphics2D g2d);\n\n    double getX();\n\n    double getY();\n\n    int getWidth();\n\n    int getHeight();\n\n    boolean intersects(Entity other);\n\n    double getDistance(Entity other);\n}\n",
      "Player.java": "package entitys;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\nimport java.awt.image.BufferedImage;\n\nimport javax.imageio.ImageIO;\n\nimport entitys.zombie.*;\nimport silah.*;\nimport mermi.*;\n\npublic class Player implements Entity {\n    private static final long serialVersionUID = 1L;\n\n    private double x, y;\n    private double veloX, veloY;\n    private int width = 20, height = 20;\n    private int health = 100;\n    private double angle = 0;\n\n    private boolean moveUp, moveDown, moveLeft, moveRight;\n    private boolean isShooting;\n\n    private Weapon currentWeapon;\n    private long lastShotTime;\n\n    private static final int MAP_WIDTH = 1600;\n    private static final int MAP_HEIGHT = 1200;\n\n    private transient BufferedImage playerImage;\n    private boolean imageLoaded = false;\n\n    // Ölçeklendirme faktörü - görüntüyü küçültmek için\n    private double scaleCarpan = 0.7; // Görüntüyü %70 boyutuna küçültür\n\n    public Player(double x, double y) {\n        this.x = x;\n        this.y = y;\n\n        loadPlayerImage();\n    }\n\n    public void loadPlayerImage() {\n        try {\n\n            playerImage = ImageIO.read(new File(\"images\\\\dp_player.png\"));\n\n            width = (int) (playerImage.getWidth() * scaleCarpan);\n            height = (int) (playerImage.getHeight() * scaleCarpan);\n\n            imageLoaded = true;\n            System.out.println(\"Oyuncu görüntüsü başarıyla yüklendi.\");\n        } catch (IOException e) {\n            System.err.println(\"Oyuncu görüntüsü yüklenirken hata: \" + e.getMessage());\n            // default değerler\n            width = 30;\n            height = 30;\n            imageLoaded = false;\n        }\n    }\n\n    @Override\n    public void update() {\n        // hareket işlemi\n        veloX = 0;\n        veloY = 0;\n\n        double speed = 3.0;\n\n        if (moveUp)\n            veloY -= speed;\n        if (moveDown)\n            veloY += speed;\n        if (moveLeft)\n            veloX -= speed;\n        if (moveRight)\n            veloX += speed;\n\n        if ((moveUp || moveDown) && (moveLeft || moveRight)) {\n            double diagonal = Math.sqrt(2);\n            veloX /= diagonal;\n            veloY /= diagonal;\n        }\n\n        // yeni konum\n        double newX = x + veloX;\n        double newY = y + veloY;\n\n        setPosition(newX, newY);\n\n        // ateş etme\n        if (isShooting && currentWeapon != null) {\n            long currentTime = System.currentTimeMillis();\n            long fireRate = (long) (60000 / currentWeapon.getFireRate()); // dakikada mermi ms cinsinden\n\n            if (currentTime - lastShotTime >= fireRate && currentWeapon.getCurrentAmmo() > 0) {\n                shoot();\n                lastShotTime = currentTime;\n            }\n        }\n    }\n\n    private void shoot() {\n        if (currentWeapon != null && currentWeapon.getCurrentAmmo() > 0) {\n            currentWeapon.fire(this, angle);\n        }\n    }\n\n    public void reloadWeapon() {\n        if (currentWeapon != null) {\n            currentWeapon.reload();\n        }\n    }\n\n    public void takeDamage(int damage) {\n        health -= damage;\n        if (health < 0)\n            health = 0;\n    }\n\n    public void collectAmmo(AmmoPickup ammo) {\n        if (currentWeapon != null && currentWeapon.getType() == ammo.getWeaponType()) {\n            currentWeapon.addAmmo(ammo.getAmount());\n        }\n    }\n\n    public void keyPressed(KeyEvent e) {\n        switch (e.getKeyCode()) {\n            case KeyEvent.VK_W:\n                moveUp = true;\n                break;\n            case KeyEvent.VK_S:\n                moveDown = true;\n                break;\n            case KeyEvent.VK_A:\n                moveLeft = true;\n                break;\n            case KeyEvent.VK_D:\n                moveRight = true;\n                break;\n        }\n    }\n\n    public void keyReleased(KeyEvent e) {\n        switch (e.getKeyCode()) {\n            case KeyEvent.VK_W:\n                moveUp = false;\n                break;\n            case KeyEvent.VK_S:\n                moveDown = false;\n                break;\n            case KeyEvent.VK_A:\n                moveLeft = false;\n                break;\n            case KeyEvent.VK_D:\n                moveRight = false;\n                break;\n        }\n    }\n\n    public void mousePressed(MouseEvent e, List<Bullet> bullets) {\n        isShooting = true;\n\n        double mouseX = e.getX();\n        double mouseY = e.getY();\n        updateAngle(mouseX, mouseY);\n\n        if (currentWeapon != null) {\n            currentWeapon.setBulletList(bullets);\n        }\n\n    }\n\n    public void mouseReleased(MouseEvent e) {\n        isShooting = false;\n    }\n\n    public void mouseMoved(MouseEvent e) {\n        double mouseX = e.getX();\n        double mouseY = e.getY();\n        updateAngle(mouseX, mouseY);\n    }\n\n    private void updateAngle(double mouseX, double mouseY) {\n        // karakterin merkezi\n        double centerX = x + width / 2;\n        double centerY = y + height / 2;\n\n        // fare ile karakter merkezi arasındaki açıyı hesapla\n        angle = Math.atan2(mouseY - centerY, mouseX - centerX);\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        // Oyuncuyu çiz - görüntü veya varsayılan oval\n        if (imageLoaded) {\n\n            g2d.drawImage(playerImage, (int) x, (int) y, width, height, null);\n\n            // karakterin baktığı yönü gösteren ve silahı temsil eden çizgi\n            double centerX = x + width / 2;\n            double centerY = y + height / 2;\n            double lineLength = 20;\n            double endX = centerX + Math.cos(angle) * lineLength;\n            double endY = centerY + Math.sin(angle) * lineLength;\n            g2d.setColor(Color.WHITE);\n            g2d.drawLine((int) centerX, (int) centerY, (int) endX, (int) endY);\n\n        } else {\n            // image yüklenemezse default mavi daire çiz\n            g2d.setColor(Color.BLUE);\n            g2d.fillOval((int) x, (int) y, width, height);\n\n            // karakterin baktığı yönü gösteren ve silahı temsil eden çizgi\n            double centerX = x + width / 2;\n            double centerY = y + height / 2;\n            double lineLength = 20;\n            double endX = centerX + Math.cos(angle) * lineLength;\n            double endY = centerY + Math.sin(angle) * lineLength;\n            g2d.setColor(Color.WHITE);\n            g2d.drawLine((int) centerX, (int) centerY, (int) endX, (int) endY);\n        }\n    }\n\n    @Override\n    public double getX() {\n        return x;\n    }\n\n    @Override\n    public double getY() {\n        return y;\n    }\n\n    @Override\n    public int getWidth() {\n        return width;\n    }\n\n    @Override\n    public int getHeight() {\n        return height;\n    }\n\n    public void setHealth(int health) {\n        this.health = health;\n    }\n\n    public double getAngle() {\n        return angle;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public Weapon getCurrentWeapon() {\n        return currentWeapon;\n    }\n\n    public void setCurrentWeapon(Weapon weapon) {\n        this.currentWeapon = weapon;\n    }\n\n    @Override\n    public boolean intersects(Entity other) {\n        return x < other.getX() + other.getWidth() &&\n                x + width > other.getX() &&\n                y < other.getY() + other.getHeight() &&\n                y + height > other.getY();\n    }\n\n    @Override\n    public double getDistance(Entity other) {\n        double centerX = x + width / 2;\n        double centerY = y + height / 2;\n        double otherCenterX = other.getX() + other.getWidth() / 2;\n        double otherCenterY = other.getY() + other.getHeight() / 2;\n\n        return Math.sqrt(Math.pow(centerX - otherCenterX, 2) + Math.pow(centerY - otherCenterY, 2));\n    }\n\n    public void setPosition(double x, double y) {\n        this.x = Math.max(0, Math.min(x, MAP_WIDTH - width));\n        this.y = Math.max(0, Math.min(y, MAP_HEIGHT - height));\n    }\n\n    // Görüntü değiştirme metodu - farklı karakterler veya durumlar için\n    public void changePlayerImage(String imagePath) {\n        try {\n            playerImage = ImageIO.read(new File(imagePath));\n            imageLoaded = true;\n            System.out.println(\"Oyuncu görüntüsü değiştirildi: \" + imagePath);\n        } catch (IOException e) {\n            System.err.println(\"Görüntü değiştirilirken hata: \" + e.getMessage());\n            imageLoaded = false;\n        }\n    }\n\n    // harita sınırları içinde hareket kontrolü\n    public boolean isWithinMapBounds(double newX, double newY) {\n        return newX >= 0 && newX <= MAP_WIDTH - width &&\n                newY >= 0 && newY <= MAP_HEIGHT - height;\n    }\n\n    public String getMapPosition() {\n        return String.format(\"Konum: (%.2f, %.2f) - Harita Boyutu: %dx%d\",\n                x, y, MAP_WIDTH, MAP_HEIGHT);\n    }\n\n    private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        loadPlayerImage();\n    }\n\n    public boolean isImageLoaded() {\n        return imageLoaded;\n    }\n\n}",
      "Zombie.java": "package entitys.zombie;\n\nimport java.awt.*;\nimport java.io.Serializable;\n\nimport entitys.*;\n\npublic abstract class Zombie implements Entity, Serializable {\n    private static final long serialVersionUID = 1L;\n\n    public double x, y;\n    protected double veloX, veloY;\n    protected int width = 25;\n    protected int height = 25;\n    protected int health;\n    protected int damage;\n    protected double speed;\n    protected Color color;\n\n    public Zombie(double x, double y, int health, int damage, double speed, Color color) {\n        this.x = x;\n        this.y = y;\n        this.health = health;\n        this.damage = damage;\n        this.speed = speed;\n        this.color = color;\n    }\n\n    public void update(Player player) {\n        // oyuncuya doğru hareket etme\n        double playerX = player.getX() + player.getWidth() / 2;\n        double playerY = player.getY() + player.getHeight() / 2;\n\n        double centerX = x + width / 2;\n        double centerY = y + height / 2;\n\n        double angle = Math.atan2(playerY - centerY, playerX - centerX);\n\n        veloX = Math.cos(angle) * speed;\n        veloY = Math.sin(angle) * speed;\n\n        x += veloX;\n        y += veloY;\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        g2d.setColor(color);\n        g2d.fillOval((int) x, (int) y, width, height);\n\n        // can barı\n        int healthBarWidth = width;\n        int healthBarHeight = 5;\n        int healthPercentage = (int) ((double) health / getMaxHealth() * healthBarWidth);\n\n        g2d.setColor(Color.RED);\n        g2d.fillRect((int) x, (int) y - healthBarHeight - 2, healthBarWidth, healthBarHeight);\n        g2d.setColor(Color.GREEN);\n        g2d.fillRect((int) x, (int) y - healthBarHeight - 2, healthPercentage, healthBarHeight);\n    }\n\n    public void takeDamage(int damage) {\n        health -= damage;\n        if (health < 0)\n            health = 0;\n    }\n\n    public abstract int getMaxHealth();\n\n    @Override\n    public double getX() {\n        return x;\n    }\n\n    @Override\n    public double getY() {\n        return y;\n    }\n\n    @Override\n    public int getWidth() {\n        return width;\n    }\n\n    @Override\n    public int getHeight() {\n        return height;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    @Override\n    public boolean intersects(Entity other) {\n        return x < other.getX() + other.getWidth() &&\n                x + width > other.getX() &&\n                y < other.getY() + other.getHeight() &&\n                y + height > other.getY();\n    }\n\n    @Override\n    public double getDistance(Entity other) {\n        double centerX = x + width / 2;\n        double centerY = y + height / 2;\n        double otherCenterX = other.getX() + other.getWidth() / 2;\n        double otherCenterY = other.getY() + other.getHeight() / 2;\n\n        return Math.sqrt(Math.pow(centerX - otherCenterX, 2) + Math.pow(centerY - otherCenterY, 2));\n    }\n}\n",
      "AcidZombie.java": "package entitys.zombie;\n\nimport java.awt.Color;\nimport java.util.Random;\n\nimport entitys.*;\n\npublic class AcidZombie extends Zombie {\n    private static final long serialVersionUID = 1L;\n    private static final int MAX_HEALTH = 40;\n\n    private int tukCooldown = 0;\n    private static final int TUK_COOLDOWN_MAX = 120; // sıklık\n    private int spitRange = 200; // Tükürme menzili\n    private int spitDamage = 5; // Tükürme hasarı\n\n    private Random random;\n\n    public AcidZombie(double x, double y) {\n        super(x, y, MAX_HEALTH, 10, 0.48, new Color(0, 100, 0)); // Koyu yeşil\n        this.random = new Random();\n    }\n\n    @Override\n    public void update(Player player) {\n        super.update(player);\n\n        // Asit tükürme mekanizması\n        if (tukCooldown <= 0) {\n            double distance = getDistance(player);\n            if (distance <= spitRange) {\n                tukAcid(player);\n                tukCooldown = TUK_COOLDOWN_MAX;\n                ;\n            }\n        } else {\n            tukCooldown--;\n        }\n    }\n\n    private void tukAcid(Player player) {\n\n        double distance = getDistance(player);\n\n        double hitChance = 1.0 - (distance / spitRange);\n\n        if (random.nextDouble() < hitChance) {\n            player.takeDamage(spitDamage);\n        }\n    }\n\n    @Override\n    public int getMaxHealth() {\n        return MAX_HEALTH;\n    }\n\n    @Override\n    public void update() {\n    }\n}\n",
      "NormalZombie.java": "package entitys.zombie;\n\nimport java.awt.Color;\n\npublic class NormalZombie extends Zombie {\n    private static final long serialVersionUID = 1L;\n    private static final int MAX_HEALTH = 50;\n\n    public NormalZombie(double x, double y) {\n        super(x, y, MAX_HEALTH, 10, 0.6, Color.GREEN);\n    }\n\n    @Override\n    public int getMaxHealth() {\n        return MAX_HEALTH;\n    }\n\n    @Override\n    public void update() {\n    }\n}\n",
      "CrawlerZombie.java": "package entitys.zombie;\n\nimport java.awt.Color;\n\nimport entitys.*;\n\npublic class CrawlerZombie extends Zombie {\n    private static final long serialVersionUID = 1L;\n    private static final int MAX_HEALTH = 30;\n\n    private boolean isJumping = false;\n    private int jumpCooldown = 0;\n    private static final int JUMP_COOLDOWN_MAX = 60; // sıklık\n\n    public CrawlerZombie(double x, double y) {\n        super(x, y, MAX_HEALTH, 10, 0.9, Color.YELLOW);\n    }\n\n    @Override\n    public void update(Player player) {\n        double distance = getDistance(player);\n\n        // yakında olduğunda atlama\n        if (distance < 50 && jumpCooldown <= 0 && !isJumping) {\n            isJumping = true;\n            jumpCooldown = JUMP_COOLDOWN_MAX;\n            speed *= 2;\n        }\n\n        if (isJumping) {\n            jumpCooldown--;\n            if (jumpCooldown <= 0) {\n                isJumping = false;\n                speed = 0.9;\n            }\n        } else if (jumpCooldown > 0) {\n            jumpCooldown--;\n        }\n\n        super.update(player);\n    }\n\n    @Override\n    public int getMaxHealth() {\n        return MAX_HEALTH;\n    }\n\n    @Override\n    public void update() {\n    }\n}\n",
      "TankZombie.java": "package entitys.zombie;\n\nimport java.awt.Color;\n\npublic class TankZombie extends Zombie {\n    private static final long serialVersionUID = 1L;\n    private static final int MAX_HEALTH = 150;\n\n    public TankZombie(double x, double y) {\n        super(x, y, MAX_HEALTH, 20, 0.3, Color.GRAY);\n\n        this.width = 35;\n        this.height = 35;\n    }\n\n    @Override\n    public int getMaxHealth() {\n        return MAX_HEALTH;\n    }\n\n    @Override\n    public void update() {\n    }\n}\n",
      "Weapon.java": "package silah;\n\nimport java.io.Serializable;\nimport java.util.List;\n\nimport entitys.*;\n\nimport mermi.*;\n\npublic abstract class Weapon implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    protected String name;\n    protected int sarjorSize;\n    protected int currentAmmo;\n    protected int totalAmmo;\n    protected double fireRate; // dakikada atış sayısı\n    protected int damage;\n    protected WeaponType type;\n\n    protected List<Bullet> bulletList;\n\n    public Weapon(String name, int sarjorSize, double fireRate, int damage, WeaponType type) {\n        this.name = name;\n        this.sarjorSize = sarjorSize;\n        this.currentAmmo = sarjorSize;\n        this.totalAmmo = 10000;// Başlangıç yedek mermi sayısı\n        this.fireRate = fireRate;\n        this.damage = damage;\n        this.type = type;\n    }\n\n    public abstract void fire(Player player, double angle);\n\n    public void reload() {\n        if (totalAmmo > 0) {\n            int ammoNeeded = sarjorSize - currentAmmo;\n            int ammoToLoad = Math.min(ammoNeeded, totalAmmo);\n\n            currentAmmo += ammoToLoad;\n            totalAmmo -= ammoToLoad;\n        }\n    }\n\n    public void addAmmo(int amount) {\n        totalAmmo += amount;\n    }\n\n    // Getter ve setter metodları\n    public String getName() {\n        return name;\n    }\n\n    public int getsarjorSize() {\n        return sarjorSize;\n    }\n\n    public int getCurrentAmmo() {\n        return currentAmmo;\n    }\n\n    public int getTotalAmmo() {\n        return totalAmmo;\n    }\n\n    public double getFireRate() {\n        return fireRate;\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public WeaponType getType() {\n        return type;\n    }\n\n    public void setBulletList(List<Bullet> bulletList) {\n        this.bulletList = bulletList;\n    }\n\n    public void setCurrentAmmo(int currentAmmo) {\n        // Negatif değer olmaması için kontrol\n        if (currentAmmo < 0) {\n            this.currentAmmo = 0;\n        } else if (currentAmmo > sarjorSize) {\n            // Şarjör kapasitesini aşmaması için kontrol\n            this.currentAmmo = sarjorSize;\n        } else {\n            this.currentAmmo = currentAmmo;\n        }\n    }\n\n    public void setTotalAmmo(int totalAmmo) {\n        // Negatif değer olmaması için kontrol\n        if (totalAmmo < 0) {\n            this.totalAmmo = 0;\n        } else {\n            this.totalAmmo = totalAmmo;\n        }\n    }\n}\n",
      "Shotgun.java": "package silah;\n\nimport entitys.*;\nimport mermi.*;\n\npublic class Shotgun extends Weapon {\n    private static final long serialVersionUID = 1L;\n\n    public Shotgun() {\n        super(\"Pompalı Tüfek\", 5, 60, 8, WeaponType.Shotgun);\n    }\n\n    @Override\n    public void fire(Player player, double angle) {\n        if (currentAmmo > 0) {\n            double bulletX = player.getX() + player.getWidth() / 2;\n            double bulletY = player.getY() + player.getHeight() / 2;\n\n            // 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi\n            double yayılmaAngle = Math.toRadians(45);\n            double tekSacmaAngle = yayılmaAngle / 8; // 8 aralık 9 mermi\n\n            for (int i = 0; i < 9; i++) {\n                double currentAngle = angle - (yayılmaAngle / 2) + (i * tekSacmaAngle);\n                Bullet bullet = new Bullet(bulletX, bulletY, currentAngle, damage, type);\n                bulletList.add(bullet);\n            }\n\n            currentAmmo--;\n        }\n    }\n}\n",
      "WeaponType.java": "package silah;\n\npublic enum WeaponType {\n    Pistol,\n    AssaultRifle,\n    Shotgun,\n    SniperRifle,\n    RocketLauncher\n}",
      "SniperRifle.java": "package silah;\n\nimport entitys.*;\nimport mermi.*;\n\npublic class SniperRifle extends Weapon {\n    private static final long serialVersionUID = 1L;\n\n    public SniperRifle() {\n        super(\"Keskin Nişancı Tüfeği\", 5, 30, 50, WeaponType.SniperRifle);\n    }\n\n    @Override\n    public void fire(Player player, double angle) {\n        if (currentAmmo > 0) {\n            double bulletX = player.getX() + player.getWidth() / 2;\n            double bulletY = player.getY() + player.getHeight() / 2;\n\n            // mermi zombileri delip geçer\n            Bullet bullet = new Bullet(bulletX, bulletY, angle, damage, type);\n            bullet.setPenetrating(true);\n            bulletList.add(bullet);\n\n            currentAmmo--;\n        }\n    }\n}\n",
      "Pistol.java": "package silah;\n\nimport entitys.*;\nimport mermi.*;\n\npublic class Pistol extends Weapon {\n    private static final long serialVersionUID = 1L;\n\n    public Pistol() {\n        super(\"Tabanca\", 12, 120, 15, WeaponType.Pistol);\n        this.totalAmmo = Integer.MAX_VALUE; // Sınırsız yedek şarjör\n    }\n\n    @Override\n    public void fire(Player player, double angle) {\n        if (currentAmmo > 0) {\n            double bulletX = player.getX() + player.getWidth() / 2;\n            double bulletY = player.getY() + player.getHeight() / 2;\n\n            Bullet bullet = new Bullet(bulletX, bulletY, angle, damage, type);\n            bulletList.add(bullet);\n\n            currentAmmo--;\n        }\n    }\n}\n",
      "AssaultRifle.java": "package silah;\n\nimport java.util.Random;\n\nimport entitys.*;\nimport mermi.*;\n\npublic class AssaultRifle extends Weapon {\n    private static final long serialVersionUID = 1L;\n    private Random random;\n\n    public AssaultRifle() {\n        super(\"Piyade Tüfeği\", 30, 600, 10, WeaponType.AssaultRifle);\n        this.random = new Random();\n    }\n\n    @Override\n    public void fire(Player player, double angle) {\n        if (currentAmmo > 0) {\n            double bulletX = player.getX() + player.getWidth() / 2;\n            double bulletY = player.getY() + player.getHeight() / 2;\n\n            // 30 derece sapma\n            double sapma = Math.toRadians(30);\n            double randomsapma = (random.nextDouble() - 0.5) * sapma;\n\n            Bullet bullet = new Bullet(bulletX, bulletY, angle + randomsapma, damage, type);\n            bulletList.add(bullet);\n\n            currentAmmo--;\n        }\n    }\n}\n",
      "RocketLauncher.java": "package silah;\n\nimport entitys.*;\nimport mermi.*;\n\npublic class RocketLauncher extends Weapon {\n    private static final long serialVersionUID = 1L;\n\n    public RocketLauncher() {\n        super(\"Roketatar\", 1, 10, 100, WeaponType.RocketLauncher);\n    }\n\n    @Override\n    public void fire(Player player, double angle) {\n        if (currentAmmo > 0) {\n            double bulletX = player.getX() + player.getWidth() / 2;\n            double bulletY = player.getY() + player.getHeight() / 2;\n\n            Rocket rocket = new Rocket(bulletX, bulletY, angle, damage, type);\n            bulletList.add(rocket);\n\n            currentAmmo--;\n        }\n    }\n}\n"
    },
    {
      "id": "5281670",
      "Zombie.java": "\n\nimport java.awt.*;\n\n/**\n * hiz\n * can\n * hasar\n */\npublic abstract class Zombie {\n\n    protected String name;\n    protected double x, y;\n    protected int health;\n    protected double speed;\n    protected int damage;\n    protected Color color;\n\n    public Zombie(String name, double x, double y, int health, double speed, int damage, Color color) {\n\n        this.name = name;\n        this.x = x;\n        this.y = y;\n        this.health = health;\n        this.speed = speed;\n        this.damage = damage;\n        this.color = color;\n    }\n\n    // Zombilerin oyuncuya dogru hareket etmesi icin oyuncunun konumlarını alıp zombiyi ona gore guncellicez\n    // Burada zombimiz surunge mi diye kontrol etmeliyiz oyle ise yaklasinca ziplayacak (yani hizlanacak)\n    public void update(double px, double py) {\n\n\n        double distanceX = px - x;\n        double distanceY = py - y;\n        double dist = distanceX*distanceX + distanceY*distanceY;\n        double angle = Math.atan2(py - y, px - x); // Once aralarindaki aciyi radyan cinsinden bulcaz\n\n        if(this.name.equals(\"CrawlerZombie \")){\n\n            if(dist < (150*150)){\n                x += (1.10)*speed * Math.cos(angle); // X bileseni\n                y += (1.10)*speed * Math.sin(angle); // Y bileseni\n            }\n        }\n        x += speed * Math.cos(angle); // X bileseni\n        y += speed * Math.sin(angle); // Y bilesini\n  \n    }\n\n    public void draw(Graphics g) {\n\n        g.setColor(color);\n        g.fillOval((int)x - 15, (int)y - 15, 30, 30);\n    }\n\n    // Oyuncu ile collision oldu mu\n    public boolean collidesWith(Player p) {\n\n        double distanceX = p.x - x;\n        double distanceY = p.y - y;\n        double dist = distanceX*distanceX + distanceY*distanceY; // Aralarındaki mesafenin kareleri toplamı\n        // Eger 35 unitten kucukse demekki artık collision oldu \n        return dist < (35*35); // 40 iken tam uc uca degme oluyordu o yuzden 35 yaptim\n    }\n\n    // Mermi ile collison oldu mu oyuncu ile ayni mantik\n    public boolean isHitByBullet(Bullet b) {\n\n        // Eger bir roketatar ise BU KISIM GAME PANELDE HANDLE ETTIN UNUTMA\n        /* if (b.getExplosionRadius() > 0) {\n            double dx = (x - b.x);\n            double dy = (y - b.y);\n            double distSq = dx*dx + dy*dy;\n            if (distSq < (b.getExplosionRadius()*b.getExplosionRadius())) {\n                return true;\n            }\n        }*/\n\n        double dx = (x - b.x);\n        double dy = (y - b.y);\n        double dist = dx*dx + dy*dy;\n        return dist < (15*15); \n    }\n\n    public void takeDamage(int dmg) {\n        health -= dmg;\n    }\n\n    public boolean isAlive() {\n        return health > 0;\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    // Zombilerin ozelliklerini txt dosyasina kaydedebilmek icin override edicez\n    public abstract String toSave();\n\n    public static Zombie fromSave(String line) {\n\n        // Kaydettigimiz sira ile geri okuyacagiz\n        // \"tur\" + x + \" \" + y + \" \" + health;\n        try {\n            String[] arr = line.split(\" \");\n            String type = arr[0];\n            double zx = Double.parseDouble(arr[1]);\n            double zy = Double.parseDouble(arr[2]);\n            int zh = Integer.parseInt(arr[3]);\n\n            switch(type) {\n                case \"NormalZombie\": {\n                    NormalZombie nz = new NormalZombie(zx, zy);\n                    nz.health = zh;\n                    return nz;\n                }\n                case \"CrawlerZombie\": {\n                    CrawlerZombie cz = new CrawlerZombie(zx, zy);\n                    cz.health = zh;\n                    return cz;\n                }\n                case \"TankZombie\": {\n                    TankZombie tz = new TankZombie(zx, zy);\n                    tz.health = zh;\n                    return tz;\n                }\n                case \"SpitterZombie\": {\n                    SpitterZombie sz = new SpitterZombie(zx, zy);\n                    sz.health = zh;\n                    return sz;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n",
      "AmmoDrop.java": "\n\nimport java.awt.*;\n/*\n * Zombi olunce arkasinda mermi kutusu bırakır icinde random sayida mermi olan\n */\npublic class AmmoDrop {\n    double x, y;\n    int amount;\n    boolean isCollected = false;\n\n    public AmmoDrop(double x, double y, int amount) {\n        this.x = x;\n        this.y = y;\n        this.amount = amount;\n\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.YELLOW);\n        g.fillRect((int)x - 5, (int)y - 5, 10, 10);\n    }\n\n    public boolean collidesWith(Player player) {\n        double dx = player.x - x;\n        double dy = player.y - y;\n        return dx*dx + dy*dy < (20*20);\n    }\n}\n",
      "GameMap.java": "\n\nimport javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GameMap {\n    private int[][] mapData;\n    private int rows, cols;\n    private final int tileSize = 16; \n    private Image grassImage;\n\n    public GameMap(String mapFilePath) {\n        loadMap(mapFilePath);\n        loadImages();\n    }\n\n    private void loadMap(String mapFilePath) {\n\n        List<String> lines = new ArrayList<>();\n\n        // Haritadan bilgileri okumak\n        try (InputStream is = getClass().getResourceAsStream(\"map.txt\");\n             BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {\n            \n            String line;\n            while ((line = reader.readLine()) != null) {\n                \n                //\n                if (!line.trim().isEmpty()) {\n                    lines.add(line);\n                }\n            }\n            \n            rows = lines.size();\n            if (rows > 0) {\n            \n                // Bosuk ile ayirdigimiz icin\n                String[] tokens = lines.get(0).split(\"\\\\s+\");\n                cols = tokens.length;\n            }\n            \n            mapData = new int[rows][cols];\n            for (int i = 0; i < rows; i++) {\n                String[] tokens = lines.get(i).split(\"\\\\s+\");\n                for (int j = 0; j < cols; j++) {\n                    mapData[i][j] = Integer.parseInt(tokens[j]);\n                }\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private void loadImages() {\n        try {\n\n            grassImage = ImageIO.read(getClass().getResource(\"grass.png\"));\n\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    public void draw(Graphics g) {\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                int x = col * tileSize;\n                int y = row * tileSize;\n                            \n                g.drawImage(grassImage, x, y, tileSize, tileSize, null);\n               \n            }\n        }\n    }\n\n    /*\n     * Oyuncu sinirlar ile collide edecek mi kontrolü yapar bunun icin map e 1 degerleri ekledik \n     */\n    public boolean checkCollision(Rectangle rect) {\n\n        int startCol = rect.x / tileSize;\n        int endCol = (rect.x + rect.width) / tileSize;\n        int startRow = rect.y / tileSize;\n        int endRow = (rect.y + rect.height) / tileSize;\n\n        for (int row = startRow; row <= endRow; row++) {\n\n            for (int col = startCol; col <= endCol; col++) {\n\n                if (row >= 0 && row < rows && col >= 0 && col < cols && mapData[row][col] == 1) {\n\n                    Rectangle tileRect = new Rectangle(col * tileSize, row * tileSize, tileSize, tileSize);\n                    if (rect.intersects(tileRect)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    public int getTileSize() {\n        return tileSize;\n    }\n}\n",
      "Weapon.java": "\nimport java.util.List;\n\n/* sarjor kapasitesi\n * ates hizi\n * toplam mermi sayisi (bazilari sonsuz)\n */\npublic abstract class Weapon {\n\n    protected String name;\n    protected int magazineCapacity; //sarjor kapasitesi\n    protected int currentMagazine; \n    protected int totalAmmo;    // Toplam mermi sayisi\n    protected int fireRate;     // Ates hizi\n    protected long lastFireTime;\n\n    public Weapon(String name, int capacity, int totalAmmo, int fireRate) {\n\n        this.name = name;\n        this.magazineCapacity = capacity; // baslangicta full\n        this.currentMagazine = capacity; \n        this.totalAmmo = totalAmmo;\n        this.fireRate = fireRate;\n        this.lastFireTime = 0;\n    }\n\n    /*\n     *  (sx, sy) den (tx, ty) ye ates edilecek\n     * bu metod list of bullets donecek cunku her silah sadece bir adet mermi ateslemiyor\n     */\n    public abstract List<Bullet> fire(double sx, double sy, double tx, double ty);\n\n    // Getterlar\n    public void setCurrentMagazine(int cm) { currentMagazine = cm; }\n    public String getName() {\n        return name;\n    }\n\n    public int getMagazineCapacity() {\n        return magazineCapacity;\n    }\n\n    public int getCurrentMagazine() {\n        return currentMagazine;\n    }\n\n    public int getTotalAmmo() {\n        return totalAmmo;\n    }\n\n\n    public void setTotalAmmo(int ta) { totalAmmo = ta; }\n\n    public void reload() {\n        // keyHandle yaparken R tusuna basilirsa bu metotu cagir\n        int need = magazineCapacity - currentMagazine;\n        if (totalAmmo >= need) {\n            totalAmmo -= need;\n            currentMagazine = magazineCapacity;\n        } else {\n            currentMagazine += totalAmmo;\n            totalAmmo = 0;\n        }\n    }\n\n    public void addAmmo(int amount) {\n        totalAmmo += amount;\n    }    \n\n    protected boolean canFire() {\n        \n        long msBetweenShots = 60000 / fireRate; // mermi/dakika\n\n        long now = System.currentTimeMillis();\n        long timeSinceLastShot = now - lastFireTime;\n        \n        if (timeSinceLastShot < msBetweenShots) {// Yeteri kadar sure gecti mi\n            return false; \n        } else {\n            return true; \n        }\n       \n    }\n}\n",
      "Bullet.java": "\nimport java.awt.*;\n\npublic class Bullet {\n    public double x, y;\n    public double angle;\n    public double speed;\n    public int damage;\n    private boolean canPassThrough;\n    private double explosionRadius; \n    private boolean isEnemyBullet = false;\n\n    public Bullet(double sx, double sy, double angle, double speed, int dmg, boolean canPassThrough,  boolean isEnemyBullet) {\n\n        this.x = sx;\n        this.y = sy;\n        this.angle = angle;\n        this.speed = speed;\n        this.damage = dmg;\n        this.canPassThrough = canPassThrough;\n        this.explosionRadius = 0;\n        this.isEnemyBullet = isEnemyBullet;\n    }\n\n    public boolean isEnemyBullet() {\n        return isEnemyBullet;\n    }\n\n    public void update() {\n        x += speed * Math.cos(angle);\n        y += speed * Math.sin(angle);\n    }\n\n    public void draw(Graphics g) {\n        if (isEnemyBullet) {\n            g.setColor(Color.GREEN); // Asit tukuren zombinin\n        } else {\n            g.setColor(Color.YELLOW); // Oyuncu mermisi\n        }\n        g.fillOval((int)x - 3, (int)y - 3, 6, 6);\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public boolean canPassThrough() {\n        return canPassThrough;\n    }\n\n    public void setExplosionRadius(double r) {\n        explosionRadius = r;\n    }\n\n    \n    public double getExplosionRadius() {\n        return explosionRadius;\n    }\n}\n",
      "Shotgun.java": "\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Pompalı Tüfek\n * fire rate 60 \n */\npublic class Shotgun extends Weapon {\n\n    public Shotgun() {\n        super(\"Pompalı Tüfek\", 5, 30, 60);\n    }\n\n    @Override\n    public List<Bullet> fire(double sx, double sy, double tx, double ty) {\n\n        if (!canFire()) return Collections.emptyList();\n        if (currentMagazine <= 0) return Collections.emptyList();\n\n        lastFireTime = System.currentTimeMillis();\n        currentMagazine--;\n\n        List<Bullet> bullets = new ArrayList<>();\n        double baseAngle = Math.atan2(ty - sy, tx - sx); // once her zaman duz bulunur\n\n        double totalSpread = Math.toRadians(45);\n        double ith = totalSpread / 8; // 9 mermi 8 aralik\n        double start = baseAngle - (totalSpread / 2);\n\n        for (int i = 0; i < 9; i++) {\n            \n            double angle = start + i * ith; // 45 derece (radyan cinsinden) / 8 ile aradaki her bir mesafeyi bulmus gibi olduk\n            Bullet bullet = new Bullet(sx, sy, angle, 10, 10, false,false); \n            bullets.add(bullet);\n        }\n        return bullets;\n    }\n}\n",
      "Spit.java": "\n\nimport java.awt.Color;\nimport java.awt.Graphics;\n\npublic class Spit {\n\n    public double x, y;         \n    private double angle;       \n    private double speed;       \n    private int damage;        \n    private int size = 8;      \n    \n    public Spit(double x, double y, double angle, double speed, int damage) {\n        \n        this.x = x;\n        this.y = y;\n        this.angle = angle;\n        this.speed = speed;\n        this.damage = damage;\n    }\n\n    public void update() {\n\n        x += speed * Math.cos(angle);\n        y += speed * Math.sin(angle);\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.GREEN);    \n        g.fillOval((int) (x - size / 2), (int) (y - size / 2), size, size);\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n\n    // Oyuncuya dogru hareket \n    public boolean collidesWith(Player player) {\n\n        double dx = player.x - x;\n        double dy = player.y - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n        \n        return distance < (35);\n    }\n}\n",
      "GameWindow.java": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class GameWindow extends JFrame {\n    private GamePanel gamePanel;\n\n    public GameWindow() {\n\n        setTitle(\"Zombastik\"); // Isme karar ver unutma !!\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setSize(1024, 768);\n        setLocationRelativeTo(null);\n\n        gamePanel = new GamePanel();\n        add(gamePanel, BorderLayout.CENTER);\n\n        MenuBar();\n\n        setVisible(true);\n\n        //Oyunu baslat\n        gamePanel.startGame();\n    }\n\n    private void MenuBar() {\n        \n        JMenuBar menuBar = new JMenuBar();\n        JMenu gameMenu = new JMenu(\"Menu\");\n        JMenuItem pauseItem = new JMenuItem(\"Pause\");\n        JMenuItem resumeItem = new JMenuItem(\"Resume\");\n        JMenuItem saveItem = new JMenuItem(\"Save\");\n        JMenuItem loadItem = new JMenuItem(\"Load\");\n\n        pauseItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                gamePanel.pauseGame();\n            }\n        });\n\n        resumeItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                gamePanel.resumeGame();\n            }\n        });\n\n        saveItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                gamePanel.saveGame();\n            }\n        });\n\n        loadItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                gamePanel.loadGame();\n            }\n        });\n\n        gameMenu.add(pauseItem);\n        gameMenu.add(resumeItem);\n        gameMenu.add(saveItem);\n        gameMenu.add(loadItem);\n\n        menuBar.add(gameMenu);\n        setJMenuBar(menuBar);\n    }\n} ",
      "NormalZombie.java": "\n\nimport java.awt.Color;\n\n/*\n* Normal Zombi \n* Can: Orta- Hız: Yavaş- Hasar: Orta\n*/\npublic class NormalZombie extends Zombie {\n    public NormalZombie(double x, double y) {\n        super(\"NormalZombie \", x, y, 50, 1.0, 10, Color.GREEN);\n    }\n\n    @Override\n    public String toSave() {\n        return \"NormalZombie \" + x + \" \" + y + \" \" + health;\n    }\n}\n",
      "SniperRifle.java": "\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Keskin Nişancı Tüfeği\n * fire rate 30\n * bu can pass through\n */\npublic class SniperRifle extends Weapon {\n\n    public SniperRifle() {\n        super(\"Keskin Nişancı Tüfeği\", 5, 20, 30);\n    }\n\n    @Override\n    public List<Bullet> fire(double sx, double sy, double tx, double ty) {\n\n        if (!canFire()) return Collections.emptyList();\n        if (currentMagazine <= 0) return Collections.emptyList();\n\n        lastFireTime = System.currentTimeMillis();\n        currentMagazine--;\n\n        double angle = Math.atan2(ty - sy, tx - sx); // duz ates\n        Bullet bullet = new Bullet(sx, sy, angle, 15, 25, true,false); \n        \n        List<Bullet> bullets = new ArrayList<>();\n        bullets.add(bullet);\n        return bullets;\n    }\n}\n",
      "Pistol.java": "\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/* Tabanca : default silah bu\n * sinirsiz ammo\n * atan2 methodu : Returns the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta)\n * Bu methodu cok kullanicaz\n */\npublic class Pistol extends Weapon {\n\n    public Pistol() {\n        super(\"Tabanca\", 12, 99999, 120);\n    }\n\n    @Override\n    public List<Bullet> fire(double sx, double sy, double tx, double ty) {\n        if (!canFire()) return new ArrayList<>();\n        if (currentMagazine <= 0) return new ArrayList<>();\n\n        lastFireTime = System.currentTimeMillis();\n        currentMagazine--;\n\n        double angle = Math.atan2(ty - sy, tx - sx); // Duz atis yapar\n        Bullet bullet = new Bullet(sx, sy, angle, 10, 10, false,false);\n\n        List<Bullet> bullets = new ArrayList<>();\n        bullets.add(bullet);\n        return bullets;\n    }\n}\n",
      "GamePanel.java": "\nimport javax.swing.JLabel;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JWindow;\nimport javax.swing.SwingConstants;\nimport javax.swing.SwingUtilities;\nimport javax.swing.Timer;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class GamePanel extends JPanel implements ActionListener, KeyListener, MouseListener, MouseMotionListener {\n\n    // Timing\n    private Timer timer;            \n    private final int DELAY = 16;   // ~60 FPS (16 ms per frame) 60 FPS saglayacak\n\n    // Game state\n    private boolean isPaused;\n    private Player player;\n    private java.util.List<Zombie> zombies;\n    private java.util.List<Bullet> bullets;\n    private List<Spit> spits;\n    private List<AmmoDrop> ammoDrops = new ArrayList<>();\n    private int waveNumber;\n    private int score;\n    private Random random;\n\n    private GameMap gameMap;\n\n    // Nisan almak icin\n    private Point mousePos = new Point(0, 0);\n    \n\n    public GamePanel() {\n        setBackground(Color.DARK_GRAY);\n        setFocusable(true);\n\n        // Listeners\n        addKeyListener(this);\n        addMouseListener(this);\n        addMouseMotionListener(this);\n\n        // Initialize baslat\n        timer = new Timer(DELAY, this);  //her 16 msda actionPerformed() methodu cagrilir \n        isPaused = false;\n        random = new Random();\n    }\n\n    public void startGame() {\n        // Yeni oyuncu yarat\n        player = new Player(512, 384);\n\n        // Zombi ve mermi listlerini yarat\n        zombies = new ArrayList<>();\n        bullets = new ArrayList<>();\n        spits = new ArrayList<>();\n\n        // Harita\n        gameMap = new GameMap(\"map.txt\");\n\n        waveNumber = 0;  // 1 oldugunda piyade tufegi hemen geliyor dikkat et\n        score = 0;\n\n        spawnWave(waveNumber);\n\n        // Start timer\n        timer.start(); // java tanim : Starts the Timer, causing it to start sending action events to its listeners.\n        // her 16 msnde bir actionPerformed() cagrilir DELAY = 16\n    }\n\n    \n    // Oyun yüklendiginde ya da kaydedilginde kisa sureli mesaj gostermek icin\n    private void showTempMsg(String message) {\n\n        JWindow window = new JWindow();\n        JLabel label = new JLabel(message);\n        label.setFont(new Font(\"Arial\", Font.BOLD, 22));\n        \n        JPanel panel = new JPanel(new BorderLayout());\n        panel.add(label, BorderLayout.CENTER);\n        window.getContentPane().add(panel);\n        \n        window.setSize(200, 150);\n        window.setLocationRelativeTo(null); \n        window.setVisible(true);\n        \n        new Timer(1000, e -> window.dispose()).start(); // 1 saniye sonra kendi kapanir\n    }\n\n    private void spawnWave(int wave) {\n\n        // Her dalgada daha fazla ve cesitli zombiler gelir \n        int zombieCount = 3 + (wave * 2);\n\n        int w = Math.max(1, getWidth()); // eger component henuz cagrilmadiysa sikinti cikmasin diye max kullandik \n        int h = Math.max(1, getHeight() / 2); // getler 0 ise 1 degeri alir ve negative bound olmaz\n\n\n        // Hesapladigimiz width(w) ve height(h) noktalari kullanilarak rastgele bir yerde zombiler olusturulur\n        // Dalga arttikca daha zor olmasını ve zombi cesitliligini saglamak icin random.nextInt(100) kullandik\n        for (int i = 0; i < zombieCount; i++) {\n\n            Zombie z;\n            if (wave >= 3 && random.nextInt(100) < 30) {\n                z = new SpitterZombie(random.nextInt(w),random.nextInt(h));\n            } \n            else if (wave >= 2 && random.nextInt(100) < 20) {\n                z = new TankZombie(random.nextInt(w),random.nextInt(h));\n            } \n            else if (wave >= 1 && random.nextInt(100) < 30) {\n                z = new CrawlerZombie(random.nextInt(w),random.nextInt(h));\n            } \n            else {\n                z = new NormalZombie(random.nextInt(w),random.nextInt(h));\n            }\n            zombies.add(z);\n        }\n\n        // Belirli zombi dalgalari temzilendikten sonra odul olarak yeni silah verir\n        // Silahların eklenme sirasi ile sayi tuslarındaki sirasi aynidir\n        // 1-> tabanca 2-> piyade tufegi gibi...\n        if (wave == 1) { // 1. dalgadan sonra piyade tufegi\n            player.addWeapon(new AssaultRifle());\n        } \n        else if (wave == 3) { // 3. dalgadan sonra pompali tufek\n            player.addWeapon(new Shotgun());\n        } \n        else if (wave == 5) { // 5. dalgadan sonra keskin nisanci\n            player.addWeapon(new SniperRifle());\n        } \n        else if (wave == 10) { // 10. dalgadan sonra roketatar\n            player.addWeapon(new RocketLauncher());\n        }\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        if (!isPaused) {\n            updateGame();\n            repaint();\n        }\n    }\n\n    private void updateGame() {\n\n        // player\n        double prevX = player.x;\n        double prevY = player.y;\n\n        player.update();\n        Rectangle playerBounds = new Rectangle((int) player.x, (int) player.y, player.getWidth(), player.getHeight());\n    \n        // Tile ile collision var mi\n        if (gameMap.checkCollision(playerBounds)) {\n\n            player.x = prevX;\n            player.y = prevY;\n        }\n\n        // bullets\n        for (int i = bullets.size() - 1; i >= 0; i--) {\n            Bullet b = bullets.get(i);\n            b.update();\n            // Ekran disina ciktiysa remove\n            if (!isOnScreen(b.x, b.y)) {\n                bullets.remove(i);\n            }\n        }\n\n        // zombies\n        List<Zombie> zombiesEffected = new ArrayList<>();\n\n        for (int i = zombies.size() - 1; i >= 0; i--) {\n\n            Zombie z = zombies.get(i);\n            z.update(player.x, player.y);\n\n            if (z instanceof SpitterZombie) {\n                SpitterZombie spitter = (SpitterZombie) z;\n                Spit spit = spitter.maySpit(player);\n                if (spit != null) {\n                    spits.add(spit);\n                }\n            }\n        \n            for (int j = bullets.size() - 1; j >= 0; j--) {\n\n                Bullet b = bullets.get(j);\n        \n                if (z.isHitByBullet(b)) {\n\n                    // Oncelikle roketatar mi geldi kontrol etmeliyiz\n                    if (b.getExplosionRadius() > 0) {\n\n                        // Eger roketatar ise belli bir mesafe içersinde etkilenecek zombileri kaydetmeliyiz\n                        for (int k = zombies.size() - 1; k >= 0; k--) {\n\n                            Zombie other = zombies.get(k);\n                            double dx = other.x - b.x;\n                            double dy = other.y - b.y;\n                            double dist = Math.sqrt(dx * dx + dy * dy); // Burada zombinin mermiden ne kadar uzak oldugunu hesapladık\n        \n                            if (dist <= b.getExplosionRadius()) {\n\n                                zombiesEffected.add(other);\n                                score += 10;\n\n                                \n                                // Eger olduyse arkasinde random sayida mermi bulunduran bir kutu birakmali\n                                int ammoAmount = 5 + random.nextInt(10); // Random sayida mermi dusursun olunce\n                                ammoDrops.add(new AmmoDrop(z.x, z.y, ammoAmount));\n                            }\n                        }\n                    } \n                    // Roketatar degilse\n                    else {\n\n                        z.takeDamage(b.getDamage());\n\n                        if (!z.isAlive()) {                           \n\n                            zombiesEffected.add(z);\n                            score += 10;\n\n                            // Eger olen zombi asit tukuren ise belli bir cevresindeki zombiler de olmeli\n                            // burada roketatar yaparken kullandigin mantiktan ilerle !!\n\n                            if(z instanceof SpitterZombie){\n                                List<Zombie> zombiesEffectedBySpit = new ArrayList<>();\n                                for (Zombie other : zombies) {\n                                    if (other != z) {\n                                        double dx = other.x - z.x;\n                                        double dy = other.y - z.y;\n                                        double dist = Math.sqrt(dx * dx + dy * dy);\n                            \n                                        if (dist < 100) { \n                                            zombiesEffectedBySpit.add(other);\n                                        }\n                                    }\n                                }\n                            \n                                for (Zombie victim : zombiesEffectedBySpit) {\n                                    victim.takeDamage(101);\n                                    if (!zombiesEffected.contains(victim)) {\n                                        zombiesEffected.add(victim);\n                                    }\n                                }\n                            }\n            \n                            \n                            // Eger olduyse arkasinde random sayida mermi bulunduran bir kutu birakmali\n                            int ammoAmount = 5 + random.nextInt(10); \n                            ammoDrops.add(new AmmoDrop(z.x, z.y, ammoAmount));\n                        }\n                    }\n        \n                    if (!b.canPassThrough()) bullets.remove(j);\n                    break;\n                }\n            }\n\n\n            if(i < zombies.size()){\n\n                if(z.collidesWith(player)){\n                    player.takeDamage(z.getDamage());\n                }\n            }\n\n            if(!player.isAlive()){\n                gameOver();\n                return;\n            }\n        }\n        \n        // Bos list hatasi olmamasi icin en son listeden cikardik\n        zombies.removeAll(zombiesEffected);\n        \n        \n        // spits\n        for (int i = spits.size() - 1; i >= 0; i--) {\n            Spit s = spits.get(i);\n            s.update();\n\n            // Ekran disina ciktiysa remove\n            if (!isOnScreen(s.x, s.y)) {\n                spits.remove(i);\n                continue;\n            }\n\n            // Oyuncu ile collision oldu mu\n            if (s.collidesWith(player)) {\n\n                // Oyuncunun canını azalt\n                player.takeDamage(s.getDamage());\n                \n                \n                spits.remove(i);\n\n                // Oyuncu oldu mu\n                if (!player.isAlive()) {\n                    gameOver();\n                    return;\n                }\n            }\n        }\n\n\n        // Dusen mermileri topla\n        for (int i = ammoDrops.size() - 1; i>= 0; i--) {\n\n            AmmoDrop drop = ammoDrops.get(i);\n            if (!drop.isCollected && drop.collidesWith(player)) {\n                drop.isCollected = true;\n                player.getCurrentWeapon().addAmmo(drop.amount); \n                ammoDrops.remove(i);\n            }\n        }\n\n        // Dalgadaki zombiler bitti mi\n        if (zombies.isEmpty()) {\n            waveNumber++;\n            spawnWave(waveNumber); // Bittiyse yeni wave spawn\n        }\n    }\n\n    private boolean isOnScreen(double x, double y) {\n        return (x >= 0 && x < getWidth() && y >= 0 && y < getHeight());\n    }\n\n    private void gameOver() {\n        timer.stop();\n        JOptionPane.showMessageDialog(this, \"Oyun bitti! Toplam Skor: \" + score);\n        // oyun bitince tekrar mi baslasin kontrol et !!!\n        startGame(); \n        //System.exit(0);\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n        // Haritayi ciz\n        if (gameMap != null) {\n            gameMap.draw(g);\n        }\n\n        // Oyuncu ciz\n        if (player != null) {\n            player.draw(g);\n        }\n\n        // Mermileri ciz\n        for (Bullet b : bullets) {\n            b.draw(g);\n        }\n\n        for (Spit s : spits) {\n            s.draw(g);\n        }\n\n        // Zombileri ciz\n        for (Zombie z : zombies) {\n            z.draw(g);\n        }\n\n        // Zombilerin olunce biraktıkları mermi kutusu\n        for (AmmoDrop drop : ammoDrops) {\n            drop.draw(g);\n        }\n\n\n        // Sol ust koseye bilgiler yazilir\n        g.setColor(Color.PINK);\n        if (player != null && player.getCurrentWeapon() != null) {\n            g.drawString(\n                \"Silah: \" + player.getCurrentWeapon().getName() +\n                \" | Şarjör: \" + player.getCurrentWeapon().getCurrentMagazine() +\n                \"/\" + player.getCurrentWeapon().getMagazineCapacity() +\n                \" | Mermi Sayısı: \" + player.getCurrentWeapon().getTotalAmmo() +\n                \" | Dalga: \" + (waveNumber + 1),\n                10, 20\n            );\n        }\n\n        // Sag ust koseye can ve skor yazilir\n        g.drawString(\"Kalan Can: \" + player.health + \" | Puan: \" + score, getWidth() - 150, 20);\n\n    }\n\n    // FileIO ile oyun kaydetme, durdurma ve yükleme\n    public void saveGame() {\n\n        // Dokumasyonda istedigi gibi bir fileda kaydedilen oyunun bilgilerini tutacagız load secilince buradan bigileri okuyacagız\n        try (PrintWriter pw = new PrintWriter(new FileWriter(\"saved.txt\"))) {\n\n            pw.println(waveNumber); // Hangi dalgadayiz\n            pw.println(score); // Skor\n\n            // Oyuncu bilgileri\n            pw.println(player.x + \" \" + player.y + \" \" + player.health); // Regex \" \" \n\n            // Silah bilgileri\n            pw.println(player.getWeapons().indexOf(player.getCurrentWeapon()));\n\n            for (Weapon w : player.getWeapons()) {\n                pw.print(w.getName() + \" \");\n                pw.print(w.getCurrentMagazine() + \" \");\n                pw.print(w.getTotalAmmo() + \"\\n\");\n            }\n\n            // Zombie bilgileri\n            pw.println(zombies.size());\n            for (Zombie z : zombies) {\n                pw.println(z.toSave());\n            }\n\n            showTempMsg(\" Oyun Kaydedildi!\");\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n\n    // Yazdigimiz sirayla okuyalim\n    public void loadGame() {\n        try (BufferedReader br = new BufferedReader(new FileReader(\"saved.txt\"))) {\n\n            waveNumber = Integer.parseInt(br.readLine());\n            score = Integer.parseInt(br.readLine());\n    \n            // Oyuncu bilgileri\n            String[] playerData = br.readLine().split(\" \");\n            player.x = Double.parseDouble(playerData[0]);\n            player.y = Double.parseDouble(playerData[1]);\n            player.health = Integer.parseInt(playerData[2]);\n    \n            int currentWeaponIndex = Integer.parseInt(br.readLine());\n    \n            // Silahlar\n            player.getWeapons().clear();\n            List<Weapon> loadedWeapons = new ArrayList<>();\n    \n            String line;\n            while ((line = br.readLine()) != null) {\n                String[] weaponData = line.split(\" \");\n                if (weaponData.length == 1) { \n                    break;\n                }\n                String wName = weaponData[0];\n                int currMag = Integer.parseInt(weaponData[1]);\n                int totalAmmo = Integer.parseInt(weaponData[2]);\n                Weapon w = createWeaponByName(wName);\n                if (w != null) {\n                    w.setCurrentMagazine(currMag);\n                    w.setTotalAmmo(totalAmmo);\n                    loadedWeapons.add(w);\n                }\n            }\n    \n            player.getWeapons().addAll(loadedWeapons);\n            if (!player.getWeapons().isEmpty() && currentWeaponIndex >= 0 && currentWeaponIndex < player.getWeapons().size()) {\n                player.setCurrentWeapon(player.getWeapons().get(currentWeaponIndex));\n            }\n    \n            // Zombiler \n            zombies.clear();\n            int zombieCount = Integer.parseInt(line);\n            for (int i = 0; i < zombieCount; i++) {\n\n                String zLine = br.readLine();\n                Zombie z = Zombie.fromSave(zLine);\n                if (z != null) {\n                    zombies.add(z);\n                }\n            }\n\n            showTempMsg(\"   Oyun Yüklendi!\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n\n    private Weapon createWeaponByName(String name) {\n\n        switch(name) {\n\n            case \"Tabanca\": return new Pistol();\n            case \"Piyade Tüfeği\": return new AssaultRifle();\n            case \"Pompalı Tüfek\": return new Shotgun();\n            case \"Keskin Nişancı Tüfeği\": return new SniperRifle();\n            case \"Roketatar\": return new RocketLauncher();\n            default: return null;\n        }\n    }\n\n    // Pause ve resume\n    public void pauseGame() {\n        isPaused = true;\n    }\n    public void resumeGame() {\n        isPaused = false;\n    }\n\n    // Klavyeden ve mousedan input\n    @Override\n    public void keyPressed(KeyEvent e) {\n        \n        if (player != null) {\n            player.KeyPressHandler(e.getKeyCode());\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n\n        if (player != null) {\n            player.KeyReleaseHandler(e.getKeyCode());\n\n            // R ye basildiginda silahlarin mermisi reload\n            if (e.getKeyCode() == KeyEvent.VK_R) {\n                player.reload();\n            }\n        }\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {}\n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        \n        // Sol veya sag tik ile mermi ateslensin\n        if (SwingUtilities.isLeftMouseButton(e) && !isPaused && player != null || SwingUtilities.isRightMouseButton(e) && !isPaused && player != null) {\n            java.util.List<Bullet> newBullets = player.fireToward(e.getX(), e.getY());\n            bullets.addAll(newBullets);\n        }\n    }\n    @Override\n    public void mousePressed(MouseEvent e) {}\n    @Override\n    public void mouseReleased(MouseEvent e) {}\n    @Override\n    public void mouseEntered(MouseEvent e) {}\n    @Override\n    public void mouseExited(MouseEvent e) {}\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        mousePos = e.getPoint();\n    }\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        mousePos = e.getPoint();\n    }\n}\n",
      "AssaultRifle.java": "\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n\n/** Piyade Tüfeği\n * fire rate 600\n * 1.dalgadan sonra elde edilir\n */\npublic class AssaultRifle extends Weapon {\n    private Random rand;\n\n    public AssaultRifle() {\n        super(\"Piyade Tüfeği\", 30, 600, 600);\n        this.rand = new Random();\n    }\n\n    @Override\n    public List<Bullet> fire(double sx, double sy, double tx, double ty) {\n\n        if (!canFire()) return Collections.emptyList();\n        if (currentMagazine <= 0) return Collections.emptyList();\n\n        lastFireTime = System.currentTimeMillis();\n        currentMagazine--;\n\n        double baseAngle = Math.atan2(ty - sy, tx - sx); // duz ates etme buna -+ 15 eklicez random\n        double spread = Math.toRadians(15);  // aciyi sayiyya cevirdik\n        double offset = (rand.nextDouble() * (spread * 2)) - spread; // -15 derece ve +15 derece arasi bir sayi degeri verecek o yuzden radyan kullandık\n        double angle = baseAngle + offset;\n\n        Bullet bullet = new Bullet(sx, sy, angle, 10, 20, false, false); // damage=8 olsun mu bak\n        List<Bullet> bullets = new ArrayList<>();\n        bullets.add(bullet);\n        return bullets;\n    }\n}\n",
      "SpitterZombie.java": "\nimport java.awt.Color;\n\n/*\n* Asit Tüküren Zombi\n* Can: Düşük- Hız: Yavaş- Hasar: Orta (uzaktan asit tükürebilir)- Özellik: Öldürüldüğünde yanındaki birimlere zarar verir\n*/\npublic class SpitterZombie extends Zombie {\n\n    private long lastSpit = 0;\n    private final long spitRepeat = 3000; // 3 saniyede 1 asit firlatsin\n\n    public SpitterZombie(double x, double y) {\n        super(\"SpitterZombie \", x, y, 35, 0.8, 10, Color.YELLOW);\n    }\n\n    @Override\n    public String toSave() {\n        return \"SpitterZombie \" + x + \" \" + y + \" \" + health;\n    }\n\n   \n    public Spit maySpit(Player player) {\n\n        long now = System.currentTimeMillis();\n        if (now - lastSpit >= spitRepeat) {\n\n            lastSpit = now;\n            double angle = Math.atan2(player.y - y, player.x - x); // Oyuncu ile arasindaki mesafe icin\n            return new Spit(x, y, angle, 3.0, 7);\n        }\n        return null;\n    }\n\n}\n\n\n",
      "CrawlerZombie.java": "\n\nimport java.awt.Color;\n\n/*\n* Sürünge Zombi\n* Can: Düşük- Hız: Hızlı- Hasar: Orta - Özellik: Oyuncunun yakınına geldiğinde zıplar.\n*/\npublic class CrawlerZombie extends Zombie {\n    public CrawlerZombie(double x, double y) {\n        super( \"CrawlerZombie \", x, y, 35, 1.6, 10, Color.MAGENTA);\n    }\n\n    @Override\n    public String toSave() {\n        return \"CrawlerZombie \" + x + \" \" + y + \" \" + health;\n    }\n}\n",
      "TankZombie.java": "\n\nimport java.awt.Color;\n\n/*\n* Tank Zombi\n* Can: Yüksek- Hız: Çok yavaş- Hasar: Yüksek\n*/\npublic class TankZombie extends Zombie {\n    public TankZombie(double x, double y) {\n        super(\"TankZombie \", x, y, 100, 0.5, 20, Color.RED);\n    }\n\n    @Override\n    public String toSave() {\n        return \"TankZombie \" + x + \" \" + y + \" \" + health;\n    }\n}\n",
      "Game.java": "\n\n\n/*\n   java topdown.Game\n   main\n */\npublic class Game {\n    public static void main(String[] args) {\n\n        /*SwingUtilities.invokeLater(() -> { // bu thread safemis \n            GameWindow window = new GameWindow();\n            window.setVisible(true);\n        });*/\n\n        GameWindow window = new GameWindow();\n        window.setVisible(true);\n    }\n}\n",
      "RocketLauncher.java": "\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Roketatar\n * fire rate 10\n */\npublic class RocketLauncher extends Weapon {\n\n    public RocketLauncher() {\n        super(\"Roketatar\", 1, 5, 10);\n    }\n\n    @Override\n    public List<Bullet> fire(double sx, double sy, double tx, double ty) {\n        if (!canFire()) return Collections.emptyList();\n        if (currentMagazine <= 0) return Collections.emptyList();\n\n        lastFireTime = System.currentTimeMillis();\n        currentMagazine--;\n\n        double angle = Math.atan2(ty - sy, tx - sx);\n        \n        // Yine tek bir mermi gibi gozukur ama etrafindakileri yok eder\n        Bullet rocket = new Bullet(sx, sy, angle, 8, 100, false,false);\n\n        // rocket is a bullet o yuzden explosionRadius kullandık\n        rocket.setExplosionRadius(50); // Collision oldugunda 50 derece etrafindaki tum zombiler yok olsun\n        List<Bullet> bullets = new ArrayList<>();\n        bullets.add(rocket);\n        return bullets;\n    }\n}\n",
      "Player.java": "\n\nimport java.awt.*;\nimport java.awt.event.KeyEvent;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Player {\n    public double x, y;\n    public int health;\n    public final double speed = 4.0;\n\n    // Hareket flags\n    private boolean up, down, left, right;\n\n    // Weapons\n    private List<Weapon> weapons;\n    private Weapon currentWeapon;\n\n    public Player(double x, double y) {\n\n        this.x = x;\n        this.y = y;\n        this.health = 100;\n        weapons = new ArrayList<>();\n\n        // Default olarak tabancası olacak\n        Weapon pistol = new Pistol();\n        weapons.add(pistol);\n        currentWeapon = pistol;\n    }\n\n    public void update() {\n        if (up)    y -= speed;\n        if (down)  y += speed;\n        if (left)  x -= speed;\n        if (right) x += speed;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.BLUE);\n        g.fillRect((int)x - 15, (int)y - 15, 30, 30); \n    }\n\n    public void KeyPressHandler(int keyCode) {\n\n        if (keyCode == KeyEvent.VK_W || keyCode == KeyEvent.VK_UP) up = true;\n        if (keyCode == KeyEvent.VK_S || keyCode == KeyEvent.VK_DOWN) down = true;\n        if (keyCode == KeyEvent.VK_A || keyCode == KeyEvent.VK_LEFT) left = true;\n        if (keyCode == KeyEvent.VK_D || keyCode == KeyEvent.VK_RIGHT) right = true;\n\n        // Sayi tuslari ile silahlar degisimi handle edilir\n        if (keyCode >= KeyEvent.VK_1 && keyCode <= KeyEvent.VK_9) {\n            int idx = keyCode - KeyEvent.VK_1;\n            if (idx >= 0 && idx < weapons.size()) {\n                currentWeapon = weapons.get(idx);\n            }\n        }\n    }\n\n    public void KeyReleaseHandler(int keyCode) {\n\n        if (keyCode == KeyEvent.VK_W || keyCode == KeyEvent.VK_UP) up = false;\n        if (keyCode == KeyEvent.VK_S || keyCode == KeyEvent.VK_DOWN) down = false;\n        if (keyCode == KeyEvent.VK_A || keyCode == KeyEvent.VK_LEFT) left = false;\n        if (keyCode == KeyEvent.VK_D || keyCode == KeyEvent.VK_RIGHT) right = false;\n    }\n\n    public void reload() {\n        if (currentWeapon != null) {\n            currentWeapon.reload();\n        }\n    }\n\n    public boolean isAlive() {\n        return health > 0;\n    }\n\n    public void takeDamage(int dmg) {\n        health -= dmg;\n    }\n\n    public Weapon getCurrentWeapon() {\n        return currentWeapon;\n    }\n\n    public void setCurrentWeapon(Weapon w) {\n        currentWeapon = w;\n    }\n\n    public void addWeapon(Weapon w) {\n\n        for (Weapon existing : weapons) {\n            if (existing.getClass() == w.getClass()) {\n                return; \n            }\n        }\n        weapons.add(w);\n    }\n\n    public List<Weapon> getWeapons() {\n        return weapons;\n    }\n\n    /*\n     * Mouse yonunda ates edecek bir mermi list dondurur\n     */\n    public List<Bullet> fireToward(int targetX, int targetY) {\n        if (currentWeapon == null) return new ArrayList<>();\n        return currentWeapon.fire(x, y, targetX, targetY);\n    }\n\n    public int getWidth() {\n        return 30;\n    }\n\n    public int getHeight() {\n        return 30;\n    }\n}\n"
    },
    {
      "id": "9164612",
      "SurungenZombie.java": "import java.awt.*;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class SurungenZombie extends Zombie {\n    private static Image babyZombieImage;\n\n    static {\n        try {\n            // \"bebek gibi emekleyen\" zombi resmi\n            babyZombieImage = ImageIO.read(new File(\"/Users/omerefeozturk/Downloads/baby-zombie/flto_k6gy_140717.jpg\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public SurungenZombie(double x, double y) {\n        // can=20, hız=4.0, hasar=10\n        super(x, y, 20, 4.0, 10);\n    }\n\n    @Override\n    public void update(Player player) {\n        double px = player.x + player.width/2.0;\n        double py = player.y + player.height/2.0;\n        double zx = x + width/2.0;\n        double zy = y + height/2.0;\n        double dx = px - zx;\n        double dy = py - zy;\n        double dist = Math.sqrt(dx*dx + dy*dy);\n        if (dist > 0) {\n            x += (speed * dx / dist);\n            y += (speed * dy / dist);\n        }\n        if (getBounds().intersects(player.getBounds())) {\n            long now = System.currentTimeMillis();\n            if (now - lastAttackTime >= attackInterval) {\n                player.takeDamage(damage);\n                lastAttackTime = now;\n            }\n        }\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        // Resim varsa onu çiz, yoksa turuncu beşgen fallback\n        if (babyZombieImage != null) {\n            g.drawImage(babyZombieImage, (int)x, (int)y, width, height, null);\n        } else {\n            Polygon pentagon = createPentagon((int)x, (int)y, width, height);\n            g.setColor(Color.ORANGE);\n            g.fillPolygon(pentagon);\n        }\n        drawHealthBar(g);\n    }\n\n    private Polygon createPentagon(int x, int y, int w, int h) {\n        int[] xPoints = new int[5];\n        int[] yPoints = new int[5];\n        xPoints[0] = x + w / 2;   yPoints[0] = y;\n        xPoints[1] = x + (int)(w * 0.8);  yPoints[1] = y + (int)(h * 0.4);\n        xPoints[2] = x + (int)(w * 0.9);  yPoints[2] = y + h;\n        xPoints[3] = x + (int)(w * 0.1);  yPoints[3] = y + h;\n        xPoints[4] = x + (int)(w * 0.2);  yPoints[4] = y + (int)(h * 0.4);\n        return new Polygon(xPoints, yPoints, 5);\n    }\n}\n",
      "PompaliTufek.java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PompaliTufek extends Weapon {\n    private int magazineCapacity = 5;\n\n    public PompaliTufek() {\n        this.name = \"Pompalı Tüfek\";\n        this.damage = 8;\n        this.fireRate = 1000; // 60 RPM\n        this.ammo = magazineCapacity;\n        this.reserveAmmo = magazineCapacity;\n        this.unlockRound = 4;\n    }\n\n    @Override\n    public Object fireWithTarget(int startX, int startY, double targetX, double targetY) {\n        long now = System.currentTimeMillis();\n        if (now - lastFiredTime >= fireRate && ammo > 0) {\n            lastFiredTime = now;\n            ammo--;\n            double dx = targetX - startX;\n            double dy = targetY - startY;\n            double dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < 1) dist = 1;\n            double baseSpeed = 10.0;\n            double mainAngle = Math.atan2(dy, dx);\n            List<ProjectileDouble> pellets = new ArrayList<>();\n            double startAngle = mainAngle - Math.toRadians(22.5);\n            double step = Math.toRadians(5);\n            for (int i = 0; i < 9; i++) {\n                double angle = startAngle + i * step;\n                double vx = baseSpeed * Math.cos(angle);\n                double vy = baseSpeed * Math.sin(angle);\n                pellets.add(new ProjectileDouble(startX, startY, vx, vy, damage));\n            }\n            return pellets;\n        }\n        return null;\n    }\n\n    @Override\n    public void reload() {\n        int needed = magazineCapacity - ammo;\n        if (needed > 0) {\n            if (reserveAmmo <= 0) {\n                System.out.println(\"Yedek mermi yok, reload başarısız.\");\n                return;\n            }\n            if (reserveAmmo >= needed) {\n                ammo += needed;\n                reserveAmmo -= needed;\n            } else {\n                ammo += reserveAmmo;\n                reserveAmmo = 0;\n            }\n        }\n    }\n\n    @Override\n    public String getAmmoDisplay() {\n        return ammo + \"/\" + (ammo + reserveAmmo);\n    }\n}\n",
      "Projectile.java": "import java.awt.*;\n\npublic class Projectile {\n    int x, y;\n    int velX, velY;\n    int damage;\n    int size = 5;\n\n    public Projectile(int x, int y, int velX, int velY, int damage) {\n        this.x = x;\n        this.y = y;\n        this.velX = velX;\n        this.velY = velY;\n        this.damage = damage;\n    }\n\n    public void update() {\n        x += velX;\n        y += velY;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.yellow);\n        g.fillOval(x, y, size, size);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, size, size);\n    }\n}\n",
      "Zombie.java": "import java.awt.*;\n\npublic abstract class Zombie {\n    // Konum\n    public double x, y;\n    // Boyut\n    public int width, height;\n    // Can, hız, hasar\n    public int health;\n    public double speed;\n    public int damage;\n    public int maxHealth;\n\n    // Saldırı cooldown\n    protected long lastAttackTime = 0;\n    protected long attackInterval = 1000; // 1sn\n\n    /**\n     * @param x zombinin X\n     * @param y zombinin Y\n     * @param health can\n     * @param speed hız\n     * @param damage saldırı gücü\n     */\n    public Zombie(double x, double y, int health, double speed, int damage) {\n        this.x = x;\n        this.y = y;\n        this.health = health;\n        this.speed = speed;\n        this.damage = damage;\n        this.width = 40;\n        this.height = 40;\n        this.maxHealth = health;\n    }\n\n    /**\n     * Her frame çağrılır.\n     * Varsayılan olarak alt sınıf override edebilir.\n     */\n    public abstract void update(Player player);\n\n    /**\n     * Zombi ekranda nasıl çizilecek, alt sınıf override eder.\n     */\n    public abstract void draw(Graphics g);\n\n    /**\n     * Hasar alır\n     */\n    public void takeDamage(int dmg) {\n        health -= dmg;\n    }\n\n    /**\n     * Can 0 altına inince ölü\n     */\n    public boolean isDead() {\n        return health <= 0;\n    }\n\n    /**\n     * Çarpışma kutusu\n     */\n    public Rectangle getBounds() {\n        return new Rectangle((int)x, (int)y, width, height);\n    }\n\n    /**\n     * Ölüm anında ek davranış\n     */\n    public void onDeath(Player player) {\n        // Örneğin asit patlaması alt sınıfta\n    }\n\n    /**\n     * Basit bir moveTowardsPlayer örneği\n     */\n    protected void moveTowardsPlayer(Player player) {\n        double px = player.x + player.width/2.0;\n        double py = player.y + player.height/2.0;\n        double zx = x + width/2.0;\n        double zy = y + height/2.0;\n        double dx = px - zx;\n        double dy = py - zy;\n        double dist = Math.sqrt(dx*dx + dy*dy);\n        if (dist > 0) {\n            x += (speed * dx / dist);\n            y += (speed * dy / dist);\n        }\n    }\n\n    /**\n     * Oyuncuya saldırı (cooldown)\n     */\n    protected void attackPlayer(Player player) {\n        long now = System.currentTimeMillis();\n        if (now - lastAttackTime >= attackInterval) {\n            player.takeDamage(damage);\n            lastAttackTime = now;\n        }\n    }\n    public void drawHealthBar(Graphics g) {\n        int barWidth = width;\n        int barHeight = 5;\n        int barX = (int)x;\n        int barY = (int)(y + height);\n\n        // Arka plan (kırmızı)\n        g.setColor(Color.red);\n        g.fillRect(barX, barY, barWidth, barHeight);\n\n        double ratio = (double)health / maxHealth;\n        if (ratio < 0) ratio = 0; // can 0 altına inerse\n\n        int greenWidth = (int)(barWidth * ratio);\n        g.setColor(Color.green);\n        g.fillRect(barX, barY, greenWidth, barHeight);\n    }\n}\n",
      "Roketatar.java": "public class Roketatar extends Weapon {\n    private int magazineCapacity = 1;\n\n    public Roketatar() {\n        this.name = \"Roketatar\";\n        this.damage = 40;\n        this.fireRate = 6000; // 10 roket/dakika\n        this.ammo = magazineCapacity;\n        this.reserveAmmo = 2; // 1 şarjör + 2 yedek = 1/3 şeklinde gösterilir\n        this.unlockRound = 11;\n    }\n\n    @Override\n    public Object fireWithTarget(int startX, int startY, double targetX, double targetY) {\n        long now = System.currentTimeMillis();\n        if (now - lastFiredTime >= fireRate && ammo > 0) {\n            lastFiredTime = now;\n            ammo--;\n            double dx = targetX - startX;\n            double dy = targetY - startY;\n            double dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < 1) dist = 1;\n            double speed = 8.0;\n            double vx = speed * dx / dist;\n            double vy = speed * dy / dist;\n            return new RocketProjectile(startX, startY, vx, vy, damage);\n        }\n        return null;\n    }\n\n    @Override\n    public void reload() {\n        int needed = magazineCapacity - ammo;\n        if (needed > 0) {\n            if (reserveAmmo <= 0) {\n                System.out.println(\"Yedek mermi yok, reload başarısız.\");\n                return;\n            }\n            if (reserveAmmo >= needed) {\n                ammo += needed;\n                reserveAmmo -= needed;\n            } else {\n                ammo += reserveAmmo;\n                reserveAmmo = 0;\n            }\n        }\n    }\n\n    @Override\n    public String getAmmoDisplay() {\n        return ammo + \"/\" + (ammo + reserveAmmo);\n    }\n}\n",
      "TopDownShooterGame.java": "import javax.swing.*;\n\npublic class TopDownShooterGame extends JFrame {\n    public TopDownShooterGame() {\n        setTitle(\"Top-Down Shooter Game\");\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setResizable(false);\n\n        GamePanel panel = new GamePanel();\n        add(panel);\n        pack();\n        setLocationRelativeTo(null);\n        setVisible(true);\n\n        panel.startGame();\n    }\n\n\n}\n",
      "GameMap.java": "import java.awt.*;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GameMap {\n    // Tek bir arkaplan resmi\n    private Image background;\n\n    // Kırpma değerleri (daha fazla kesiyoruz)\n    // Örneğin sol üstteki gri alan büyükse cropLeft=100, cropTop=100 gibi\n    // Aşağıda tahmini değerleri artırdım:\n    private int cropLeft = 100;\n    private int cropTop = 100;\n    private int cropRight = 20;\n    private int cropBottom = 20;\n\n    // Arkaplan resmin boyutu\n    private int mapWidth;\n    private int mapHeight;\n\n    // (Opsiyonel) Eski tile verisi:\n    private static final int TILE_SIZE = 32;\n    private static final int[][] MAP_DATA = {\n            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},\n            {1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,4,1},\n            {1,0,0,2,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,1},\n            {1,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,2,0,0,1},\n            {1,0,2,0,0,2,0,0,0,2,2,0,0,0,0,0,0,0,0,1},\n            {1,0,0,0,0,0,2,0,0,0,0,0,0,2,2,0,0,0,0,1},\n            {1,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,1},\n            {1,0,2,0,2,0,0,0,0,0,0,0,0,2,2,0,0,0,0,1},\n            {1,0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,2,0,0,1},\n            {1,0,0,0,0,2,2,0,0,0,0,0,0,2,2,0,0,0,0,1},\n            {1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1},\n            {1,0,0,0,2,0,0,0,0,0,0,2,0,2,0,0,2,0,0,1},\n            {1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},\n            {1,3,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,4,1},\n            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},\n    };\n\n    public GameMap() {\n        try {\n            // Harita resmi yolunu düzenleyin\n            background = ImageIO.read(new File(\"/Users/omerefeozturk/IdeaProjects/Proje2/src/fd4c62e8-aa0c-4e66-b798-6dfb51c3d123.JPG\"));\n            if (background != null) {\n                mapWidth = background.getWidth(null);\n                mapHeight = background.getHeight(null);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public List<Rectangle> getObstacles() {\n        // Artık engel yok, boş liste döndürüyoruz\n        return new ArrayList<>();\n    }\n\n\n    public void drawMap(Graphics g) {\n        if (background != null) {\n            // Panel boyutu\n            int panelWidth = ((Graphics2D)g).getDeviceConfiguration().getBounds().width;\n            int panelHeight = ((Graphics2D)g).getDeviceConfiguration().getBounds().height;\n\n            // Kaynak resimdeki kırpma\n            int srcX1 = cropLeft;\n            int srcY1 = cropTop;\n            int srcX2 = mapWidth - cropRight;\n            int srcY2 = mapHeight - cropBottom;\n\n            // Hedef dikdörtgen: paneli doldur\n            int destX1 = 0;\n            int destY1 = 0;\n            int destX2 = panelWidth;\n            int destY2 = panelHeight;\n\n            // Çiz\n            g.drawImage(background,\n                    destX1, destY1, destX2, destY2,\n                    srcX1, srcY1, srcX2, srcY2,\n                    null);\n        } else {\n            // Resim yoksa, isterseniz tile-based fallback\n            for (int row = 0; row < MAP_DATA.length; row++) {\n                for (int col = 0; col < MAP_DATA[row].length; col++) {\n                    int tile = MAP_DATA[row][col];\n                    int x = col * TILE_SIZE;\n                    int y = row * TILE_SIZE;\n                    switch(tile) {\n                        case 0:\n                            g.setColor(Color.LIGHT_GRAY);\n                            g.fillRect(x, y, TILE_SIZE, TILE_SIZE);\n                            break;\n                        case 1:\n                            g.setColor(Color.DARK_GRAY);\n                            g.fillRect(x, y, TILE_SIZE, TILE_SIZE);\n                            break;\n                        case 2:\n                            g.setColor(new Color(139,69,19));\n                            g.fillRect(x, y, TILE_SIZE, TILE_SIZE);\n                            break;\n                        case 3:\n                        case 4:\n                            g.setColor(Color.LIGHT_GRAY);\n                            g.fillRect(x, y, TILE_SIZE, TILE_SIZE);\n                            g.setColor(tile==3 ? Color.BLUE : Color.RED);\n                            g.drawString(tile==3?\"P\":\"Z\", x + TILE_SIZE/3, y + (int)(TILE_SIZE*0.7));\n                            break;\n                        default:\n                            g.setColor(Color.MAGENTA);\n                            g.fillRect(x, y, TILE_SIZE, TILE_SIZE);\n                            break;\n                    }\n                    g.setColor(Color.GRAY);\n                    g.drawRect(x, y, TILE_SIZE, TILE_SIZE);\n                }\n            }\n        }\n    }\n\n    public Point getPlayerSpawn() {\n        // Eski tile-based spawn\n        for (int row = 0; row < MAP_DATA.length; row++) {\n            for (int col = 0; col < MAP_DATA[row].length; col++) {\n                if (MAP_DATA[row][col] == 3) {\n                    return new Point(col*TILE_SIZE, row*TILE_SIZE);\n                }\n            }\n        }\n        return new Point(64,64);\n    }\n\n    public List<Point> getZombieSpawns() {\n        List<Point> spawns = new ArrayList<>();\n        for (int row = 0; row < MAP_DATA.length; row++) {\n            for (int col = 0; col < MAP_DATA[row].length; col++) {\n                if (MAP_DATA[row][col] == 4) {\n                    spawns.add(new Point(col*TILE_SIZE, row*TILE_SIZE));\n                }\n            }\n        }\n        return spawns;\n    }\n}\n",
      "Weapon.java": "public abstract class Weapon {\n    protected String name;\n    protected int damage;\n    protected int fireRate;\n    protected long lastFiredTime = 0;\n\n    // Şarjördeki mermi\n    public int ammo;\n    // Yedek mermi\n    public int reserveAmmo;\n    protected int unlockRound;\n\n    // Ateş\n    public abstract Object fireWithTarget(int startX, int startY, double targetX, double targetY);\n\n    // Şarjör doldurma\n    public abstract void reload();\n\n    // Pickup (zombiden düşen mermi vs.)\n    public void addReserveAmmo(int amount) {\n        reserveAmmo += amount;\n    }\n\n    // Silah adı\n    public String getName() {\n        return name;\n    }\n    public int getUnlockRound() {\n        return unlockRound;\n    }\n\n    // Şarjördeki mermi\n    public int getAmmo() {\n        return ammo;\n    }\n\n    // HUD gösterimi: \"ammo/(ammo + reserveAmmo)\"\n    public String getAmmoDisplay() {\n        return ammo + \"/\" + (ammo + reserveAmmo);\n    }\n}\n",
      "NormalZombie.java": "import java.awt.*;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class NormalZombie extends Zombie {\n    // Tek ayak üstünde kalan resim\n    private static Image normalZombieImage;\n\n    static {\n        try {\n            normalZombieImage = ImageIO.read(new File(\"/Users/omerefeozturk/Downloads/scary-male-zombie/39443.jpg\"));\n            System.out.println(\"NormalZombie resmi yüklendi.\");\n        } catch (IOException e) {\n            System.out.println(\"NormalZombie resmi yüklenemedi: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n\n    public NormalZombie(double x, double y) {\n        super(x, y, 40, 1.5, 10);\n    }\n\n    @Override\n    public void update(Player player) {\n        double px = player.x + player.width / 2.0;\n        double py = player.y + player.height / 2.0;\n        double zx = x + width / 2.0;\n        double zy = y + height / 2.0;\n        double dx = px - zx;\n        double dy = py - zy;\n        double dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist > 0) {\n            x += (speed * dx / dist);\n            y += (speed * dy / dist);\n        }\n        // Saldırı\n        if (getBounds().intersects(player.getBounds())) {\n            long now = System.currentTimeMillis();\n            if (now - lastAttackTime >= attackInterval) {\n                player.takeDamage(damage);\n                lastAttackTime = now;\n            }\n        }\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        // Resim varsa onu çiz, yoksa yeşil oval fallback\n        if (normalZombieImage != null) {\n            g.drawImage(normalZombieImage, (int)x, (int)y, width, height, null);\n        } else {\n            g.setColor(Color.GREEN);\n            g.fillOval((int)x, (int)y, width, height);\n        }\n        // Can barı\n        drawHealthBar(g);\n    }\n}\n",
      "AcidProjectile.java": "import java.awt.*;\n\npublic class AcidProjectile extends ProjectileBase {\n    public AcidProjectile(double x, double y, double vx, double vy, int damage) {\n        super(x, y, vx, vy, damage);\n        this.size = 15;\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        g.setColor(Color.green);\n        g.fillOval((int)x, (int)y, size, size);\n    }\n}\n",
      "GameSaveManager.java": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GameSaveManager {\n    private static final String SAVE_FILE = \"savegame.dat\";\n\n    public static void saveGame(Player player, List<Zombie> zombies, int waveNumber) {\n        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(SAVE_FILE))) {\n            // Oyuncu konumu, can, skor\n            out.writeInt(player.x);\n            out.writeInt(player.y);\n            out.writeInt(player.health);\n            out.writeInt(player.getScore());\n\n            // Silah\n            out.writeUTF(player.getCurrentWeaponName()); // \"Tabanca\", \"Piyade Tüfeği\" vs.\n            Weapon w = player.getWeapon();\n            // Kaydetme: ammo, reserveAmmo (int) olarak\n            out.writeInt(w.ammo);\n            out.writeInt(w.reserveAmmo);\n\n            // Dalga\n            out.writeInt(waveNumber);\n\n            // Zombiler\n            out.writeInt(zombies.size());\n            for (Zombie z : zombies) {\n                out.writeUTF(z.getClass().getSimpleName());\n                out.writeDouble(z.x);\n                out.writeDouble(z.y);\n                out.writeInt(z.health);\n            }\n            System.out.println(\"Oyun kaydedildi.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static GameState loadGame() {\n        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(SAVE_FILE))) {\n            // Oyuncu\n            int px = in.readInt();\n            int py = in.readInt();\n            int pHealth = in.readInt();\n            int pScore = in.readInt();\n\n            // Silah\n            String weaponName = in.readUTF();\n            int loadedAmmo = in.readInt();\n            int loadedReserve = in.readInt();\n\n            // Dalga\n            int waveNumber = in.readInt();\n\n            // Oyuncu oluştur\n            Player player = new Player(px, py);\n            player.health = pHealth;\n            while (player.getScore() < pScore) {\n                player.addScore(1);\n            }\n\n            // Silahı geri yükle\n            Weapon w = createWeaponByName(weaponName);\n            w.ammo = loadedAmmo;\n            w.reserveAmmo = loadedReserve;\n            player.setWeapon(w);\n\n            // Zombiler\n            int zombieCount = in.readInt();\n            List<Zombie> zombies = new ArrayList<>();\n            for (int i = 0; i < zombieCount; i++) {\n                String type = in.readUTF();\n                double zx = in.readDouble();\n                double zy = in.readDouble();\n                int zHealth = in.readInt();\n\n                Zombie z = createZombieByType(type, zx, zy, zHealth);\n                if (z != null) {\n                    zombies.add(z);\n                }\n            }\n\n            System.out.println(\"Oyun yüklendi.\");\n            return new GameState(player, zombies, waveNumber);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private static Weapon createWeaponByName(String name) {\n        switch (name) {\n            case \"Piyade Tüfeği\":\n                return new PiyadeTufegi();\n            case \"Pompalı Tüfek\":\n                return new PompaliTufek();\n            case \"Keskin Nişancı Tüfeği\":\n                return new KeskinNisanTufegi();\n            case \"Roketatar\":\n                return new Roketatar();\n            case \"Tabanca\":\n            default:\n                return new Pistol();\n        }\n    }\n\n    private static Zombie createZombieByType(String type, double x, double y, int health) {\n        Zombie z = null;\n        switch (type) {\n            case \"NormalZombie\":\n                z = new NormalZombie(x,y);\n                break;\n            case \"TankZombie\":\n                z = new TankZombie(x,y);\n                break;\n            case \"SurungenZombie\":\n                z = new SurungenZombie(x,y);\n                break;\n            case \"AsitTukurenZombie\":\n                z = new AsitTukurenZombie(x,y);\n                break;\n        }\n        if (z != null) {\n            z.health = health;\n        }\n        return z;\n    }\n}\n",
      "Pistol.java": "public class Pistol extends Weapon {\n    public Pistol() {\n        this.name = \"Tabanca\";\n        this.damage = 10;\n        this.fireRate = 500; // 0.5 sn\n        this.ammo = 12;\n        this.reserveAmmo = 0; // Pistol için yedek sınırsız kabul edilebilir\n        this.unlockRound = 1;\n    }\n\n    @Override\n    public Object fireWithTarget(int startX, int startY, double targetX, double targetY) {\n        long now = System.currentTimeMillis();\n        if (now - lastFiredTime >= fireRate && ammo > 0) {\n            lastFiredTime = now;\n            ammo--;\n            double dx = targetX - startX;\n            double dy = targetY - startY;\n            double dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < 1) dist = 1;\n            double speed = 10.0;\n            double vx = speed * dx / dist;\n            double vy = speed * dy / dist;\n            return new ProjectileDouble(startX, startY, vx, vy, damage);\n        }\n        return null;\n    }\n\n    @Override\n    public void reload() {\n        // Her zaman tam şarjör sağlar\n        this.ammo = 12;\n    }\n\n    @Override\n    public String getAmmoDisplay() {\n        return ammo + \"/∞\";\n    }\n}\n",
      "PiyadeTufegi.java": "public class PiyadeTufegi extends Weapon {\n    private int magazineCapacity = 30;\n\n    public PiyadeTufegi() {\n        this.name = \"Piyade Tüfeği\";\n        this.damage = 10;\n        this.fireRate = 100; // 600 RPM\n        this.ammo = magazineCapacity;\n        this.reserveAmmo = magazineCapacity; // Başlangıçta 1 şarjör yedek\n        this.unlockRound = 2;\n    }\n\n    @Override\n    public Object fireWithTarget(int startX, int startY, double targetX, double targetY) {\n        long now = System.currentTimeMillis();\n        if (now - lastFiredTime >= fireRate && ammo > 0) {\n            lastFiredTime = now;\n            ammo--;\n            double dx = targetX - startX;\n            double dy = targetY - startY;\n            double dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < 1) dist = 1;\n            double speed = 10.0;\n            double vx = speed * dx / dist;\n            double vy = speed * dy / dist;\n            return new ProjectileDouble(startX, startY, vx, vy, damage);\n        }\n        return null;\n    }\n\n    @Override\n    public void reload() {\n        int needed = magazineCapacity - ammo;\n        if (needed > 0) {\n            if (reserveAmmo <= 0) {\n                System.out.println(\"Yedek mermi yok, reload başarısız.\");\n                return;\n            }\n            if (reserveAmmo >= needed) {\n                ammo += needed;\n                reserveAmmo -= needed;\n            } else {\n                ammo += reserveAmmo;\n                reserveAmmo = 0;\n            }\n        }\n    }\n\n    @Override\n    public String getAmmoDisplay() {\n        return ammo + \"/\" + (ammo + reserveAmmo);\n    }\n}\n",
      "GamePanel.java": "import javax.swing.*;\nimport javax.swing.Timer;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class GamePanel extends JPanel implements ActionListener, KeyListener, MouseListener, MouseMotionListener {\n    private Timer timer;\n    private Player player;\n    private List<Zombie> zombies;\n    private List<ProjectileBase> projectiles;\n    private List<AmmoPickup> ammoPickups;\n    private Set<Integer> keysPressed;\n\n    private final int PANEL_WIDTH = 800;\n    private final int PANEL_HEIGHT = 600;\n\n    private int waveNumber = 1;\n    private boolean waveInProgress = false;\n    private boolean paused = false;\n    private boolean gameOver = false;\n\n    private GameMap gameMap;\n    private int mouseX, mouseY;\n    private long waveEndTime = 0;\n\n    public GamePanel() {\n        setPreferredSize(new Dimension(PANEL_WIDTH, PANEL_HEIGHT));\n        setBackground(Color.black);\n        setFocusable(true);\n        addKeyListener(this);\n        addMouseListener(this);\n        addMouseMotionListener(this);\n\n        keysPressed = new HashSet<>();\n        projectiles = new ArrayList<>();\n        zombies = new ArrayList<>();\n        ammoPickups = new ArrayList<>();\n\n        gameMap = new GameMap();\n        loadPlayer();\n        spawnZombiesForWave(waveNumber);\n\n        timer = new Timer(16, this); // ~60 FPS\n    }\n\n    public void startGame() {\n        timer.start();\n    }\n\n    private void loadPlayer() {\n        Point spawn = gameMap.getPlayerSpawn();\n        player = new Player(spawn.x, spawn.y);\n    }\n\n    private void spawnZombiesForWave(int wave) {\n        waveInProgress = true;\n        int count = 3 + (wave * 2);\n        List<Point> spawns = gameMap.getZombieSpawns();\n        Random rand = new Random();\n        for (int i = 0; i < count; i++) {\n            Point p = spawns.get(rand.nextInt(spawns.size()));\n            int t = rand.nextInt(4); // 0=Normal, 1=Tank, 2=Surungen, 3=AsitTukuren\n            switch(t) {\n                case 0: zombies.add(new NormalZombie(p.x, p.y)); break;\n                case 1: zombies.add(new TankZombie(p.x, p.y)); break;\n                case 2: zombies.add(new SurungenZombie(p.x, p.y)); break;\n                case 3: zombies.add(new AsitTukurenZombie(p.x, p.y)); break;\n            }\n        }\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        if (!paused && !gameOver) updateGame();\n        repaint();\n    }\n\n    private void updateGame() {\n        player.update(keysPressed, PANEL_WIDTH, PANEL_HEIGHT);\n        if (player.health <= 0) {\n            gameOver = true;\n            return;\n        }\n\n        for (Zombie z : zombies) {\n            z.update(player);\n        }\n\n        for (Zombie z : zombies) {\n            if (z instanceof AsitTukurenZombie) {\n                ProjectileBase acid = ((AsitTukurenZombie) z).getAcidProjectile(player);\n                if (acid != null) projectiles.add(acid);\n            }\n        }\n\n        Iterator<ProjectileBase> projIter = projectiles.iterator();\n        while (projIter.hasNext()) {\n            ProjectileBase proj = projIter.next();\n            proj.update();\n            if (proj.isOutOfBounds(PANEL_WIDTH, PANEL_HEIGHT)) {\n                projIter.remove();\n                continue;\n            }\n            for (Zombie z : zombies) {\n                if (proj.getBounds().intersects(z.getBounds())) {\n                    z.takeDamage(proj.damage);\n                    if (!(proj instanceof SniperProjectile)) {\n                        projIter.remove();\n                    }\n                    if (z.isDead()) {\n                        player.addScore(10);\n                        z.onDeath(player);\n                        if (Math.random() < 0.3) {\n                            ammoPickups.add(new AmmoPickup((int)z.x, (int)z.y, getDefaultMagazineCapacityForWave()));\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        zombies.removeIf(Zombie::isDead);\n\n        Iterator<AmmoPickup> ammoIter = ammoPickups.iterator();\n        while (ammoIter.hasNext()) {\n            AmmoPickup ap = ammoIter.next();\n            if (player.getBounds().intersects(ap.getBounds())) {\n                player.pickupAmmo(ap.ammoAmount);\n                ammoIter.remove();\n            }\n        }\n\n        if (zombies.isEmpty() && waveInProgress) {\n            waveEndTime = System.currentTimeMillis();\n            waveInProgress = false;\n            List<Point> spawns = gameMap.getZombieSpawns();\n            Random rand = new Random();\n            for (int i = 0; i < 5; i++) {\n                Point p = spawns.get(rand.nextInt(spawns.size()));\n                ammoPickups.add(new AmmoPickup(p.x, p.y, getDefaultMagazineCapacityForWave()));\n            }\n        }\n        if (!waveInProgress && waveEndTime != 0 && System.currentTimeMillis() >= waveEndTime + 5000) {\n            waveNumber++;\n            grantWeaponByWave(waveNumber);\n            spawnZombiesForWave(waveNumber);\n            waveEndTime = 0;\n        }\n    }\n\n    private int getDefaultMagazineCapacityForWave() {\n        if (waveNumber == 2) return 30; // Piyade\n        else if (waveNumber == 4) return 5; // Pompalı\n        else if (waveNumber == 6) return 5; // Keskin\n        else if (waveNumber == 11) return 1; // Roketatar\n        return 10;\n    }\n\n    // Yeni dalga başladıkça yeni silahlar envantere eklenir.\n    private void grantWeaponByWave(int wave) {\n        if (wave == 2) {\n            player.addWeapon(new PiyadeTufegi());\n            System.out.println(\"Piyade Tüfeği eklendi!\");\n        } else if (wave == 4) {\n            player.addWeapon(new PompaliTufek());\n            System.out.println(\"Pompalı Tüfek eklendi!\");\n        } else if (wave == 6) {\n            player.addWeapon(new KeskinNisanTufegi());\n            System.out.println(\"Keskin Nişancı Tüfeği eklendi!\");\n        } else if (wave == 11) {\n            player.addWeapon(new Roketatar());\n            System.out.println(\"Roketatar eklendi!\");\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        gameMap.drawMap(g);\n        player.draw(g);\n        for (Zombie z : zombies) {\n            z.draw(g);\n            z.drawHealthBar(g);\n        }\n        for (ProjectileBase p : projectiles) {\n            p.draw(g);\n        }\n        for (AmmoPickup ap : ammoPickups) {\n            ap.draw(g);\n        }\n        g.setColor(Color.white);\n        g.drawString(\"Silah: \" + player.getCurrentWeaponName(), 10, 20);\n        g.drawString(\"Mermi: \" + player.getCurrentWeaponAmmo(), 10, 40);\n        String healthText = \"Can: \" + player.health;\n        String scoreText = \"Puan: \" + player.getScore();\n        FontMetrics fm = g.getFontMetrics();\n        int hW = fm.stringWidth(healthText);\n        int sW = fm.stringWidth(scoreText);\n        g.drawString(healthText, getWidth() - hW - 10, 20);\n        g.drawString(scoreText, getWidth() - sW - 10, 40);\n        String waveText = \"Dalga: \" + waveNumber;\n        int waveW = fm.stringWidth(waveText);\n        g.drawString(waveText, (getWidth() - waveW) / 2, 20);\n\n        if (paused && !gameOver) {\n            String pauseMsg = \"Oyun Duraklatıldı - ESC ile Menü\";\n            int pw = fm.stringWidth(pauseMsg);\n            g.drawString(pauseMsg, (getWidth()-pw)/2, getHeight()/2);\n        }\n        if (gameOver) {\n            String goMsg = \"GAME OVER!\";\n            int gow = fm.stringWidth(goMsg);\n            g.drawString(goMsg, (getWidth()-gow)/2, getHeight()/2);\n        }\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        if (gameOver) return;\n        keysPressed.add(e.getKeyCode());\n        if (e.getKeyCode() == KeyEvent.VK_R && !paused) {\n            player.reloadWeapon();\n        }\n        if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {\n            if (!paused) togglePause();\n            showPauseMenu();\n        }\n        // Silah değiştirme: 1,2,3,4 tuşları\n        int key = e.getKeyCode();\n        if (key >= KeyEvent.VK_1 && key <= KeyEvent.VK_9) {\n            int index = key - KeyEvent.VK_1;\n            player.switchWeapon(index);\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        keysPressed.remove(e.getKeyCode());\n    }\n    @Override\n    public void keyTyped(KeyEvent e) {}\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        if (paused || gameOver) return;\n        Object fireResult = player.fireAt(e.getX(), e.getY());\n        if (fireResult != null) {\n            if (fireResult instanceof List) {\n                projectiles.addAll((List<ProjectileBase>) fireResult);\n            } else if (fireResult instanceof ProjectileBase) {\n                projectiles.add((ProjectileBase) fireResult);\n            }\n        }\n    }\n    @Override public void mousePressed(MouseEvent e) {}\n    @Override public void mouseReleased(MouseEvent e) {}\n    @Override public void mouseEntered(MouseEvent e) {}\n    @Override public void mouseExited(MouseEvent e) {}\n\n    private void togglePause() {\n        paused = !paused;\n    }\n\n    private void showPauseMenu() {\n        if (gameOver) return;\n        Window parent = SwingUtilities.getWindowAncestor(this);\n        JDialog dialog = new JDialog(parent, \"Oyun Menüsü\", Dialog.ModalityType.APPLICATION_MODAL);\n        dialog.setSize(300,200);\n        dialog.setLocationRelativeTo(this);\n        dialog.setLayout(new GridLayout(4,1));\n\n        JButton resumeBtn = new JButton(\"Resume\");\n        resumeBtn.addActionListener(ev -> {\n            dialog.dispose();\n            togglePause();\n        });\n\n        JButton saveBtn = new JButton(\"Save\");\n        saveBtn.addActionListener(ev -> {\n            GameSaveManager.saveGame(player, zombies, waveNumber);\n            JOptionPane.showMessageDialog(dialog, \"Oyun kaydedildi.\");\n        });\n\n        JButton loadBtn = new JButton(\"Load\");\n        loadBtn.addActionListener(ev -> {\n            GameState state = GameSaveManager.loadGame();\n            if (state != null) {\n                this.player = state.player;\n                this.zombies = state.zombies;\n                this.waveNumber = state.waveNumber;\n                player.updateBounds(PANEL_WIDTH, PANEL_HEIGHT);\n                JOptionPane.showMessageDialog(dialog, \"Oyun yüklendi. Dalga: \" + waveNumber);\n            } else {\n                JOptionPane.showMessageDialog(dialog, \"Kayıt yüklenemedi!\");\n            }\n        });\n\n        JButton exitBtn = new JButton(\"Exit\");\n        exitBtn.addActionListener(ev -> System.exit(0));\n\n        dialog.add(resumeBtn);\n        dialog.add(saveBtn);\n        dialog.add(loadBtn);\n        dialog.add(exitBtn);\n        dialog.setVisible(true);\n    }\n}\n",
      "ProjectileBase.java": "import java.awt.*;\n\npublic abstract class ProjectileBase {\n    protected double x, y;\n    protected double velX, velY;\n    public int damage;\n    protected int size = 5;\n\n    public ProjectileBase(double x, double y, double vx, double vy, int damage) {\n        this.x = x;\n        this.y = y;\n        this.velX = vx;\n        this.velY = vy;\n        this.damage = damage;\n    }\n\n    public void update() {\n        x += velX;\n        y += velY;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.white);\n        g.fillOval((int)x, (int)y, size, size);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle((int)x, (int)y, size, size);\n    }\n\n    public boolean isOutOfBounds(int w, int h) {\n        return (x<0 || x>w || y<0 || y>h);\n    }\n}\n",
      "TankZombie.java": "import java.awt.*;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class TankZombie extends Zombie {\n    private static Image axeZombieImage;\n\n    static {\n        try {\n            // \"elinde balta olan\" zombi resmi\n            axeZombieImage = ImageIO.read(new File(\"/Users/omerefeozturk/Downloads/zombie-character/27175.jpg\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public TankZombie(double x, double y) {\n        // can=100, hız=0.5, hasar=20\n        super(x, y, 100, 0.5, 20);\n    }\n\n    @Override\n    public void update(Player player) {\n        double px = player.x + player.width / 2.0;\n        double py = player.y + player.height / 2.0;\n        double zx = x + width / 2.0;\n        double zy = y + height / 2.0;\n        double dx = px - zx;\n        double dy = py - zy;\n        double dist = Math.sqrt(dx*dx + dy*dy);\n        if (dist > 0) {\n            x += (speed * dx / dist);\n            y += (speed * dy / dist);\n        }\n        if (getBounds().intersects(player.getBounds())) {\n            long now = System.currentTimeMillis();\n            if (now - lastAttackTime >= attackInterval) {\n                player.takeDamage(damage);\n                lastAttackTime = now;\n            }\n        }\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        // Resim varsa onu çiz, yoksa kırmızı kare fallback\n        if (axeZombieImage != null) {\n            g.drawImage(axeZombieImage, (int)x, (int)y, width, height, null);\n        } else {\n            g.setColor(Color.RED);\n            g.fillRect((int)x, (int)y, width, height);\n        }\n        drawHealthBar(g);\n    }\n}\n",
      "Game.java": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\npublic class Game extends JFrame {\n    private GamePanel gamePanel;\n\n    // Normal pencere modunda oyunu başlatan constructor\n    public Game() {\n        setTitle(\"Top Down Shooter Game\");\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setResizable(false);\n\n        gamePanel = new GamePanel();\n        add(gamePanel);\n\n        pack();\n        setLocationRelativeTo(null);\n        setVisible(true);\n\n        gamePanel.startGame();\n    }\n\n    // Ana giriş noktası: Menü gösterip kullanıcı seçimine göre oyunu başlatır veya çıkış yapar\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            MainMenuDialog menu = new MainMenuDialog();\n            boolean startGame = menu.showMenu();  // Menü, true dönerse oyunu başlat\n            if (!startGame) {\n                System.exit(0);\n            } else {\n                countdownAndLaunch();\n            }\n        });\n    }\n\n    // Geri sayım ekranı: 3 saniyelik geri sayım yapar, ardından Game penceresini oluşturur.\n    private static void countdownAndLaunch() {\n        JFrame countdownFrame = new JFrame(\"Geri Sayım\");\n        countdownFrame.setSize(200, 150);\n        countdownFrame.setLocationRelativeTo(null);\n        countdownFrame.setUndecorated(true);\n        JLabel countdownLabel = new JLabel(\"\", SwingConstants.CENTER);\n        countdownLabel.setFont(new Font(\"Arial\", Font.BOLD, 48));\n        countdownFrame.add(countdownLabel);\n        countdownFrame.setVisible(true);\n\n        Timer timer = new Timer(1000, null);\n        timer.addActionListener(new ActionListener() {\n            int count = 3;\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                if (count > 0) {\n                    countdownLabel.setText(String.valueOf(count));\n                    count--;\n                } else {\n                    timer.stop();\n                    countdownFrame.dispose();\n                    new Game();  // Oyun penceresini oluşturup oyunu başlatır.\n                }\n            }\n        });\n        timer.start();\n    }\n}\n\n// Açılış menüsü: Modal bir JDialog şeklinde \"Oyunu Başlat\" ve \"Çık\" seçenekleri sunar.\nclass MainMenuDialog extends JDialog {\n    private boolean startSelected = false;\n\n    public MainMenuDialog() {\n        setTitle(\"Top Down Shooter Game\");\n        setModal(true);\n        setSize(400, 300);\n        setLocationRelativeTo(null);\n        setLayout(new BorderLayout());\n\n        JLabel titleLabel = new JLabel(\"Top Down Shooter Game\", SwingConstants.CENTER);\n        titleLabel.setFont(new Font(\"Arial\", Font.BOLD, 24));\n        add(titleLabel, BorderLayout.NORTH);\n\n        JPanel buttonPanel = new JPanel();\n        JButton startButton = new JButton(\"Oyunu Başlat\");\n        JButton exitButton = new JButton(\"Çık\");\n        buttonPanel.add(startButton);\n        buttonPanel.add(exitButton);\n        add(buttonPanel, BorderLayout.SOUTH);\n\n        startButton.addActionListener(e -> {\n            startSelected = true;\n            dispose();\n        });\n\n        exitButton.addActionListener(e -> {\n            startSelected = false;\n            dispose();\n        });\n    }\n\n    // Menü gösterildikten sonra seçilen değeri döndürür.\n    public boolean showMenu() {\n        setVisible(true);\n        return startSelected;\n    }\n}\n",
      "AmmoPickup.java": "import javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class AmmoPickup {\n    public int x, y;\n    public int width = 32, height = 32;\n    public int ammoAmount;\n\n    // Mermi resmi\n    private static Image bulletImage;\n\n    static {\n        // Resmi statik blokta bir kez yüklüyoruz\n        try {\n            // Kendi dosya yolunuza göre düzenleyin, örn: \"res/bullets.png\"\n            bulletImage = ImageIO.read(new File(\"/Users/omerefeozturk/Downloads/rifle-pistol-bullets-isolated (1)/42384.jpg\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public AmmoPickup(int x, int y, int ammoAmount) {\n        this.x = x;\n        this.y = y;\n        this.ammoAmount = ammoAmount;\n    }\n\n    public void draw(Graphics g) {\n        if (bulletImage != null) {\n            // Resim varsa, width x height boyutuna ölçekleyerek çiziyoruz\n            g.drawImage(bulletImage, x, y, width, height, null);\n        } else {\n            // Resim yüklenemediyse, fallback olarak turuncu kare\n            g.setColor(Color.orange);\n            g.fillRect(x, y, width, height);\n        }\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, width, height);\n    }\n}\n",
      "KeskinNisanTufegi.java": "public class KeskinNisanTufegi extends Weapon {\n    private int magazineCapacity = 5;\n\n    public KeskinNisanTufegi() {\n        this.name = \"Keskin Nişancı Tüfeği\";\n        this.damage = 20;\n        this.fireRate = 2000; // 30 RPM\n        this.ammo = magazineCapacity;\n        this.reserveAmmo = magazineCapacity;\n        this.unlockRound = 6;\n    }\n\n    @Override\n    public Object fireWithTarget(int startX, int startY, double targetX, double targetY) {\n        long now = System.currentTimeMillis();\n        if (now - lastFiredTime >= fireRate && ammo > 0) {\n            lastFiredTime = now;\n            ammo--;\n            double dx = targetX - startX;\n            double dy = targetY - startY;\n            double dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < 1) dist = 1;\n            double speed = 15.0;\n            double vx = speed * dx / dist;\n            double vy = speed * dy / dist;\n            return new SniperProjectile(startX, startY, vx, vy, damage);\n        }\n        return null;\n    }\n\n    @Override\n    public void reload() {\n        int needed = magazineCapacity - ammo;\n        if (needed > 0) {\n            if (reserveAmmo <= 0) {\n                System.out.println(\"Yedek mermi yok, reload başarısız.\");\n                return;\n            }\n            if (reserveAmmo >= needed) {\n                ammo += needed;\n                reserveAmmo -= needed;\n            } else {\n                ammo += reserveAmmo;\n                reserveAmmo = 0;\n            }\n        }\n    }\n\n    @Override\n    public String getAmmoDisplay() {\n        return ammo + \"/\" + (ammo + reserveAmmo);\n    }\n}\n",
      "AsitTukurenZombie.java": "import java.awt.*;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class AsitTukurenZombie extends Zombie {\n    private static Image acidZombieImage;\n    private long lastAcidTime = 0;\n    private long acidInterval = 2000; // 2 saniyede bir asit tükürsün\n\n    static {\n        try {\n            // Resim dosya yolunu kendi projenize göre düzenleyin\n            acidZombieImage = ImageIO.read(new File(\"/Users/omerefeozturk/Downloads/creepy-green-zombie-cartoon-style/s66z_0o2e_230405.jpg\"));\n        } catch (IOException e) {\n            System.out.println(\"AsitTukurenZombie resmi yüklenemedi: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public AsitTukurenZombie(double x, double y) {\n        // Örnek parametreler: can=20, hız=1.0, hasar=10\n        super(x, y, 20, 1.0, 10);\n    }\n\n    @Override\n    public void update(Player player) {\n        double px = player.x + player.width / 2.0;\n        double py = player.y + player.height / 2.0;\n        double zx = x + width / 2.0;\n        double zy = y + height / 2.0;\n        double dx = px - zx;\n        double dy = py - zy;\n        double dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist > 0) {\n            x += (speed * dx / dist);\n            y += (speed * dy / dist);\n        }\n        if (getBounds().intersects(player.getBounds())) {\n            long now = System.currentTimeMillis();\n            if (now - lastAttackTime >= attackInterval) {\n                player.takeDamage(damage);\n                lastAttackTime = now;\n            }\n        }\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        if (acidZombieImage != null) {\n            g.drawImage(acidZombieImage, (int)x, (int)y, width, height, null);\n        } else {\n            // Fallback: mor üçgen\n            Polygon triangle = createTriangle((int)x, (int)y, width, height);\n            g.setColor(Color.MAGENTA);\n            g.fillPolygon(triangle);\n        }\n        drawHealthBar(g);\n    }\n\n    private Polygon createTriangle(int x, int y, int w, int h) {\n        int[] xPoints = { x + w / 2, x, x + w };\n        int[] yPoints = { y, y + h, y + h };\n        return new Polygon(xPoints, yPoints, 3);\n    }\n\n    /**\n     * Belirli aralıklarla oyuncuya doğru asit mermisi fırlatır.\n     */\n    public ProjectileBase getAcidProjectile(Player player) {\n        long now = System.currentTimeMillis();\n        if (now - lastAcidTime >= acidInterval) {\n            lastAcidTime = now;\n            double zx = x + width / 2.0;\n            double zy = y + height / 2.0;\n            double px = player.x + player.width / 2.0;\n            double py = player.y + player.height / 2.0;\n            double dx = px - zx;\n            double dy = py - zy;\n            double dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < 1) dist = 1;\n            double speedAcid = 5.0;\n            double vx = speedAcid * dx / dist;\n            double vy = speedAcid * dy / dist;\n            // zombinin genişliği artı 10 piksel, böylece mermi zombieyle çakışmaz.\n            double offset = width + 10;\n            double spawnX = zx + (vx / speedAcid) * offset;\n            double spawnY = zy + (vy / speedAcid) * offset;\n            return new AcidProjectile(spawnX, spawnY, vx, vy, damage);\n        }\n        return null;\n    }\n\n    /**\n     * Zombie öldüğünde tetiklenen patlama özelliği.\n     * Etrafındaki oyuncuya belirli bir yarıçap içinde patlama hasarı verir.\n     */\n    @Override\n    public void onDeath(Player player) {\n        double explosionRadius = 100.0; // Patlama yarıçapı (piksel cinsinden)\n        double centerX = x + width / 2.0;\n        double centerY = y + height / 2.0;\n        double playerCenterX = player.x + player.width / 2.0;\n        double playerCenterY = player.y + player.height / 2.0;\n        double dx = playerCenterX - centerX;\n        double dy = playerCenterY - centerY;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        // Debug: Patlama merkezinden oyuncuya mesafe\n        System.out.println(\"AsitTukurenZombie patlaması: oyuncuya mesafe = \" + distance);\n\n        if (distance <= explosionRadius) {\n            System.out.println(\"AsitTukurenZombie patlaması oyuncuya hasar veriyor!\");\n            player.takeDamage(20);\n        }\n    }\n}\n",
      "ProjectileDouble.java": "import java.awt.*;\n\npublic class ProjectileDouble extends ProjectileBase {\n    public ProjectileDouble(double x, double y, double vx, double vy, int damage) {\n        super(x, y, vx, vy, damage);\n        this.size = 8;\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        g.setColor(Color.yellow);\n        g.fillOval((int)x, (int)y, size, size);\n    }\n}\n",
      "RocketProjectile.java": "import java.awt.*;\n\npublic class RocketProjectile extends ProjectileBase {\n    public RocketProjectile(double x, double y, double vx, double vy, int damage) {\n        super(x, y, vx, vy, damage);\n        this.size = 12;\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        g.setColor(Color.orange);\n        g.fillOval((int)x, (int)y, size, size);\n    }\n}\n",
      "SniperProjectile.java": "import java.awt.*;\n\npublic class SniperProjectile extends ProjectileBase {\n    public SniperProjectile(double x, double y, double vx, double vy, int damage) {\n        super(x, y, vx, vy, damage);\n        this.size = 6;\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        g.setColor(Color.cyan);\n        g.fillOval((int)x, (int)y, size, size);\n    }\n}\n",
      "ImageLoader.java": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class ImageLoader {\n    public static BufferedImage loadImage(String path) {\n        try {\n            return ImageIO.read(new File(path));\n        } catch (IOException e) {\n            System.err.println(\"Resim yüklenemedi: \" + path);\n            return null;\n        }\n    }\n}\n",
      "Player.java": "import javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.awt.event.KeyEvent;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\npublic class Player {\n    // Karakterin konumu ve boyutu\n    public int x, y;\n    public int width, height;\n\n    // Can ve maksimum can\n    public int health = 100;\n    public int maxHealth = 100;\n\n    // Hareket hızı\n    private int speed = 5;\n\n    // Skor\n    private int score = 0;\n\n    // Mevcut silah\n    private Weapon currentWeapon;\n\n    // Silah envanteri\n    private List<Weapon> inventory;\n\n    // Hasar alma cooldown\n    private long lastDamageTime = 0;\n    private long damageCooldown = 1000; // ms\n\n    // Oyuncu resmi\n    private static Image playerImage;\n\n    static {\n        try {\n            // Dosya yolunu ve uzantısını projenize göre ayarlayın\n            playerImage = ImageIO.read(new File(\"/Users/omerefeozturk/IdeaProjects/Proje2/src/10353790.jpg\"));\n        } catch (IOException e) {\n            System.out.println(\"Player resmi yüklenemedi: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public Player(int x, int y) {\n        this.x = x;\n        this.y = y;\n        this.width = 50;\n        this.height = 50;\n        this.health = 100;\n        this.maxHealth = 100;\n        inventory = new ArrayList<>();\n        // Başlangıçta sadece Pistol envantere eklenir.\n        Weapon pistol = new Pistol();\n        inventory.add(pistol);\n        currentWeapon = pistol;\n    }\n\n    public void update(Set<Integer> keys, int panelWidth, int panelHeight) {\n        if (keys.contains(KeyEvent.VK_W)) y -= speed;\n        if (keys.contains(KeyEvent.VK_S)) y += speed;\n        if (keys.contains(KeyEvent.VK_A)) x -= speed;\n        if (keys.contains(KeyEvent.VK_D)) x += speed;\n\n        // Panel sınır kontrolü\n        if (x < 0) x = 0;\n        if (y < 0) y = 0;\n        if (x + width > panelWidth) x = panelWidth - width;\n        if (y + height > panelHeight) y = panelHeight - height;\n    }\n\n    public void updateBounds(int panelWidth, int panelHeight) {\n        if (x + width > panelWidth) x = panelWidth - width;\n        if (y + height > panelHeight) y = panelHeight - height;\n    }\n\n    public void draw(Graphics g) {\n        if (playerImage != null) {\n            g.drawImage(playerImage, x, y, width, height, null);\n        } else {\n            g.setColor(Color.BLUE);\n            g.fillRect(x, y, width, height);\n        }\n        drawHealthBar(g);\n    }\n\n    private void drawHealthBar(Graphics g) {\n        int barWidth = width;\n        int barHeight = 5;\n        int barX = x;\n        int barY = y + height;\n        g.setColor(Color.RED);\n        g.fillRect(barX, barY, barWidth, barHeight);\n        double ratio = (double) health / maxHealth;\n        if (ratio < 0) ratio = 0;\n        int greenWidth = (int)(barWidth * ratio);\n        g.setColor(Color.GREEN);\n        g.fillRect(barX, barY, greenWidth, barHeight);\n    }\n\n    public Object fireAt(int mouseX, int mouseY) {\n        int startX = x + width / 2;\n        int startY = y + height / 2;\n        return currentWeapon.fireWithTarget(startX, startY, mouseX, mouseY);\n    }\n\n    public void reloadWeapon() {\n        currentWeapon.reload();\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, width, height);\n    }\n\n    public void addScore(int amount) {\n        score += amount;\n    }\n\n    public int getScore() {\n        return score;\n    }\n\n    public String getCurrentWeaponName() {\n        return currentWeapon.getName();\n    }\n\n    public String getCurrentWeaponAmmo() {\n        return currentWeapon.getAmmoDisplay();\n    }\n\n    public Weapon getWeapon() {\n        return currentWeapon;\n    }\n\n    public void setWeapon(Weapon w) {\n        currentWeapon = w;\n    }\n\n    public void takeDamage(int dmg) {\n        long now = System.currentTimeMillis();\n        if (now - lastDamageTime >= damageCooldown) {\n            health -= dmg;\n            lastDamageTime = now;\n            System.out.println(\"Oyuncu hasar aldı: \" + dmg + \", kalan can: \" + health);\n        }\n    }\n\n    public void pickupAmmo(int amount) {\n        if (!(currentWeapon instanceof Pistol)) {\n            currentWeapon.addReserveAmmo(amount);\n            System.out.println(\"Oyuncu ek mermi topladı: +\" + amount);\n        }\n    }\n\n    // Envantere yeni silah ekler (aynı türden silah eklenmez)\n    public void addWeapon(Weapon w) {\n        for (Weapon wep : inventory) {\n            if (wep.getClass().equals(w.getClass()))\n                return;\n        }\n        inventory.add(w);\n    }\n\n    // Inventory içindeki silahlar arasında geçiş yapar. Tuş 1,2,3,... olarak kullanılır (index 0,1,2,...)\n    public void switchWeapon(int index) {\n        if (index >= 0 && index < inventory.size()) {\n            currentWeapon = inventory.get(index);\n            System.out.println(\"Silah değiştirildi: \" + currentWeapon.getName());\n        }\n    }\n\n    public List<Weapon> getInventory() {\n        return inventory;\n    }\n}\n",
      "GameState.java": "import java.util.List;\n\npublic class GameState {\n    public Player player;\n    public List<Zombie> zombies;\n    public int waveNumber;\n\n    public GameState(Player player, List<Zombie> zombies, int waveNumber) {\n        this.player = player;\n        this.zombies = zombies;\n        this.waveNumber = waveNumber;\n    }\n}\n"
    },
    {
      "id": "9167236",
      "PauseMenu.java": "import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\n\npublic class PauseMenu {\n    private Game game;\n    public Rectangle resumeButton;\n    public Rectangle mainMenuButton;\n    public Rectangle resetButton;\n    public Rectangle saveButton;\n    public Rectangle loadButton;\n    private int WIDTH; \n    private int HEIGHT;\n\n    public PauseMenu(Game game) {\n        this.game = game;\n        this.WIDTH = (int) (game.ORIGINAL_WIDTH * game.scale); // 1000 * 1.7\n        this.HEIGHT = (int) (game.ORIGINAL_HEIGHT * game.scale); // 563 * 1.7\n        resumeButton = new Rectangle(WIDTH/2 - 185, (int)(150 * game.scale), 350, 50); \n        saveButton = new Rectangle(WIDTH/2 - 185, (int)(220 * game.scale), 350, 50); \n        loadButton = new Rectangle(WIDTH/2 - 185, (int)(290 * game.scale), 350, 50); \n        resetButton = new Rectangle(WIDTH/2 - 185, (int)(360 * game.scale), 350, 50); \n        mainMenuButton = new Rectangle(WIDTH/2 - 185, (int)(430 * game.scale), 350, 50); \n    }\n    \n    public void render(Graphics g) {\n        Graphics2D g2d = (Graphics2D) g;\n        \n        // Transparent BackGround\n        g.setColor(new Color(0, 0, 0, 150));\n        g.fillRect(0, 0, WIDTH, HEIGHT);\n        \n        // Title\n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 30));\n        g.drawString(\"Paused\", WIDTH/2 - 70, 130);\n        \n        // Resume Button\n        g2d.draw(resumeButton);\n        g.drawString(\"Resume\", resumeButton.x + 115, resumeButton.y + 35);\n        \n        // Main Menu Button\n        g2d.draw(mainMenuButton);\n        g.drawString(\"Main Menu\", mainMenuButton.x + 97, mainMenuButton.y + 35);\n\n        // Reset Button\n        g2d.draw(resetButton);\n        g.drawString(\"Reset\", resetButton.x + 135, resetButton.y + 35);\n\n        // Save Button\n        g2d.draw(saveButton);\n        g.drawString(\"Save\", saveButton.x + 135, saveButton.y + 35);\n\n        // Load Button\n        g2d.draw(loadButton);\n        g.drawString(\"Load From Checkpoint\", loadButton.x + 13, loadButton.y + 35);\n    }\n}\n",
      "Wall.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Wall extends GameObject {\n\n    private BufferedImage wallImage;\n    SpriteSheet sheet;\n    private String type;\n    Game game;\n\n    public Wall(int x, int y, ID id, String type, int num, Game game) {\n        super(x, y, id);\n        this.type = type;\n        this.game = game;\n        \n        BufferedImageLoader loader = new BufferedImageLoader();\n        sheet = new SpriteSheet(loader.loadImage(\"./Resources/levelAssets/ObstaclesAndObjects/Objects.png\"));\n\n        if(this.type.equals(\"Wall\")){\n            sheet = new SpriteSheet(loader.loadImage(\"./Resources/levelAssets/ObstaclesAndObjects/Ground_rocks.png\"));\n            wallImage = scaleImage(sheet.grabImageSpecific(11, 8, 58, 92), 32, 32);\n        }else if(this.type.equals(\"Invisible Wall\")){\n            wallImage = scaleImage(sheet.grabImageSpecific(192, 435, 48, 54), 32, 32);\n        }else if(this.type.equals(\"Tree\")){\n            wallImage = scaleImage(sheet.grabImageSpecific(241, 129, 64, 93), 32, 32);\n        }else if(this.type.equals(\"Rock\")){\n            wallImage = scaleImage(sheet.grabImageSpecific(0, 372, 60, 60), 32, 32);\n        }else if(this.type.equals(\"Horizontal Red Car\")){\n            sheet = new SpriteSheet(loader.loadImage(\"./Resources/levelAssets/ObstaclesAndObjects/obstacles-and-objects.png\"));\n            wallImage = scaleImage(sheet.grabImage(1, 7, 32, 27), 32, 32);\n        }else if(this.type.equals(\"Horizontal Blue Car\")){\n            sheet = new SpriteSheet(loader.loadImage(\"./Resources/levelAssets/ObstaclesAndObjects/obstacles-and-objects.png\"));\n            wallImage = scaleImage(sheet.grabImage(6, 7, 32, 27), 32, 32);\n        }else if(this.type.equals(\"Vertical Red Car\")){\n            sheet = new SpriteSheet(loader.loadImage(\"./Resources/levelAssets/ObstaclesAndObjects/obstacles-and-objects.png\"));\n            wallImage = scaleImage(sheet.grabImage(3, 7, 32, 27), 32, 32);\n        }else if(this.type.equals(\"Vertical Blue Car\")){\n            sheet = new SpriteSheet(loader.loadImage(\"./Resources/levelAssets/ObstaclesAndObjects/obstacles-and-objects.png\"));\n            wallImage = scaleImage(sheet.grabImage(8, 7, 32, 27), 32, 32);\n        }else if(this.type.equals(\"Stump\")){\n            wallImage = scaleImage(sheet.grabImageSpecific(64, 590, 45, 36), 32, 32);\n        }else if(this.type.equals(\"Skeleton Pile\")){\n            wallImage = scaleImage(sheet.grabImageSpecific(195, 372, 80, 60), 32, 32);\n        }else if(this.type.equals(\"Ruin Block\")){\n            wallImage = scaleImage(sheet.grabImageSpecific(242, 304, 62, 62), 32, 32);\n        }else if(this.type.equals(\"Lamp\")){\n            sheet = new SpriteSheet(loader.loadImage(\"./Resources/levelAssets/ObstaclesAndObjects/obstacles-and-objects.png\"));\n            wallImage = scaleImage(sheet.grabImage(1, 1, 32, 46), 32, 32);\n        }else{ // Ruins\n            if(this.type.equals(\"Big Ruins\")){\n                switch(num){\n                    case 1: wallImage = scaleImage(sheet.grabImageSpecific(0, 129, 80, 100), 32, 32); break;\n                    case 2: wallImage = scaleImage(sheet.grabImageSpecific(0, 304, 80, 64), 32, 32); break;\n                    case 3: wallImage = scaleImage(sheet.grabImageSpecific(242, 304, 64, 64), 32, 32); break;\n                    case 4: wallImage = scaleImage(sheet.grabImageSpecific(285, 495, 50, 50), 32, 32); break;\n                }\n            }else{ // Small Ruins\n                switch(num){\n                    case 1: wallImage = scaleImage(sheet.grabImageSpecific(0, 304, 80, 64), 32, 32); break;\n                    case 2: wallImage = scaleImage(sheet.grabImageSpecific(285, 495, 50, 50), 32, 32); break;\n                }\n            }\n        }\n\n       \n    }\n\n    public void tick() {\n    }\n\n    public void render(Graphics g) {\n        g.drawImage(wallImage, (int)x, (int)y, null);\n\n        if(game.isDebug()){\n            g.setColor(Color.red);\n            Rectangle bounds = getBounds();\n            g.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);\n        }\n    }\n\n    public Rectangle getBounds() {\n        if(this.type.equals(\"Lamp\")){\n            return new Rectangle((int)x+8, (int)y+8, 17, 25);\n        } else {\n            return new Rectangle((int)x, (int)y, 32, 32);\n        }\n    }\n    \n    private BufferedImage scaleImage(BufferedImage original, int width, int height) {\n        BufferedImage scaled = new BufferedImage(width, height, original.getType());\n        Graphics2D g2d = scaled.createGraphics();\n        g2d.drawImage(original, 0, 0, width, height, null);\n        g2d.dispose();\n        return scaled;\n    }\n}\n",
      "Bullet.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\n\npublic class Bullet extends GameObject{\n    \n    Game game;\n    private Handler handler;\n    private float speed = 20f;\n    private String bulletType;\n    private int hitCount = 0;\n    private boolean exploded = false;\n    String target;\n    BufferedImage bulletImage;\n\n    public Bullet(float x, float y, ID id, Handler handler, int mx, int my, String bulletType, Game game, String target) {\n        super(x, y, id);\n        this.game = game;\n        this.handler = handler;\n        this.bulletType = bulletType;\n        active = true;\n        this.target = target;\n        \n        float dx = mx - x;\n        float dy = my - y;\n        float distance = (float) Math.sqrt(dx * dx + dy * dy);\n\n        if (distance == 0) {\n            velX = 0;\n            velY = 0;\n        } else {\n            velX = (dx / distance) * speed; \n            velY = (dy / distance) * speed;\n        }\n\n        BufferedImageLoader loader = new BufferedImageLoader();\n        SpriteSheet bulletSheet = new SpriteSheet(loader.loadImage(\"./Resources/bulletAssets/All_Fire_Bullet_Pixel_16x16_00.png\"));\n\n        if(this.bulletType.equals(\"9mm\")){\n            bulletImage = bulletSheet.grabImage(22, 4, 16, 16);\n        } else if(this.bulletType.equals(\"7.62\")){\n            bulletImage = bulletSheet.grabImage(17, 9, 16, 16);\n        } else if(this.bulletType.equals(\"12gauge\")){\n            bulletImage = bulletSheet.grabImage(14, 16, 16, 16);\n        } else if(this.bulletType.equals(\"50cal.\")){\n            bulletImage = bulletSheet.grabImage(12, 17, 32, 16);\n        } else { // Rocket\n            bulletImage = bulletSheet.grabImage(11, 17, 32, 16);\n        }   \n\n    }\n    \n    public void tick() {\n        x += velX;\n        y += velY;\n        \n        for (int i = 0; i < handler.object.size(); i++) {\n            GameObject tempObject = handler.object.get(i);\n            \n            if (tempObject.getID() == ID.Block) {\n                if (getBounds().intersects(tempObject.getBounds())) {\n                    if(this.bulletType.equals(\"rocket\")){\n                        explode();\n                    }\n                    active = false;\n                    handler.removeObject(this);\n                }\n            }\n\n            if (tempObject.getID() == ID.Player && target.equals(\"Player\")) {\n                if (getBounds().intersects(tempObject.getBounds())) {\n                    active = false;\n                    handler.removeObject(this);\n                    ((Player)tempObject).takeDamage(Enemy.getBANDIT_SHOOTING_DAMAGE());\n                }\n            }\n        }\n    }\n    \n    public void render(Graphics g) {\n        if(active){\n            Graphics2D g2d = (Graphics2D) g;\n\n            AffineTransform oldTransform = g2d.getTransform();\n            \n            double angle = Math.atan2(velY, velX);\n            \n            int centerX = bulletImage.getWidth() / 2;\n            int centerY = bulletImage.getHeight() / 2;\n            \n            g2d.translate(x + centerX, y + centerY);\n            g2d.rotate(angle);\n            g2d.drawImage(bulletImage, -centerX, -centerY, null);\n            \n            g2d.setTransform(oldTransform);\n            \n            if(game.isDebug()) {\n                g.setColor(Color.blue);\n                Rectangle bounds = getBounds();\n                g.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);\n            }\n        }\n    }\n    \n    public void explode() {\n        if(!exploded && bulletType.equals(\"rocket\")) {\n            exploded = true;\n            handler.addObject(new Explosion(\n                (int)x, (int)y, \n                ID.Explosion, \n                game.getROCKET_RADIUS(),  \n                handler,\n                game,\n                game.getROCKET_DAMAGE()\n            ));\n            handler.removeObject(this);\n        }\n    }\n\n    public Rectangle getBounds() {\n        if(this.bulletType.equals(\"9mm\")){\n            return new Rectangle((int)x+4, (int)y+5, 8, 8);\n        } else if(this.bulletType.equals(\"7.62\")){\n            return new Rectangle((int)x+6, (int)y+5, 8, 8);\n        } else if(this.bulletType.equals(\"12gauge\")){\n            return new Rectangle((int)x+6, (int)y+5, 8, 8);\n        } else if(this.bulletType.equals(\"50cal.\")){\n            return new Rectangle((int)x+20, (int)y+5, 8, 8);\n        } else { // Rocket\n            return new Rectangle((int)x+20, (int)y+5, 8, 8);\n        }   \n    }\n\n    public String getBulletType() { return bulletType; }\n    public int getHitCount() { return hitCount; }\n    public void setHitCount(int hitCount) { this.hitCount = hitCount; }\n    \n}\n",
      "SaveAndLoad.java": "import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class SaveAndLoad implements Serializable {\n    private static final long serialVersionUID = 1L;\n    \n    public int wave;\n    public int hp;\n    public int score;\n    public int pistolAmmo;\n    public int rifleAmmo;\n    public int shotgunAmmo;\n    public int sniperAmmo;\n    public int rocketAmmo;\n    public int rifleAmmoBackup;\n    public int shotgunAmmoBackup;\n    public int sniperAmmoBackup;\n    public int rocketAmmoBackup;\n    public String weapon;\n\n    public void saveGame(String fileName, SaveAndLoad state) {\n        try (FileOutputStream fos = new FileOutputStream(fileName);\n             ObjectOutputStream oos = new ObjectOutputStream(fos)) {\n            oos.writeObject(state);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public SaveAndLoad loadGame(String fileName) {\n        try (FileInputStream fis = new FileInputStream(fileName);\n             ObjectInputStream ois = new ObjectInputStream(fis)) {\n            SaveAndLoad state = (SaveAndLoad) ois.readObject();\n            return state;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}",
      "Floor.java": "import java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Floor extends GameObject {\n\n    private BufferedImage floorImage;\n    SpriteSheet sheet;\n    private String type;\n\n    public Floor(int x, int y, ID id, String type) {\n        super(x, y, id);\n        this.type = type;\n        \n        BufferedImageLoader loader = new BufferedImageLoader();\n        sheet = new SpriteSheet(loader.loadImage(\"./Resources/levelAssets/Tileset/tileset_arranged.png\"));\n\n        if(this.type.equals(\"GUL\")){\n            floorImage = scaleImage(sheet.grabImage(7, 10, 16, 16), 32, 32);\n        }else if(this.type.equals(\"GUM\")){\n            floorImage = scaleImage(sheet.grabImage(8, 10, 16, 16), 32, 32);\n        }else if(this.type.equals(\"GUR\")){\n            floorImage = scaleImage(sheet.grabImage(9, 10, 16, 16), 32, 32);\n        }else if(this.type.equals(\"GML\")){\n            floorImage = scaleImage(sheet.grabImage(7, 11, 16, 16), 32, 32);\n        }else if(this.type.equals(\"GMM\")){\n            floorImage = scaleImage(sheet.grabImage(1, 10, 16, 16), 32, 32);\n        }else if(this.type.equals(\"GMR\")){\n            floorImage = scaleImage(sheet.grabImage(9, 11, 16, 16), 32, 32);\n        }else if(this.type.equals(\"GLL\")){\n            floorImage = scaleImage(sheet.grabImage(7, 12, 16, 16), 32, 32);\n        }else if(this.type.equals(\"GLM\")){\n            floorImage = scaleImage(sheet.grabImage(8, 12, 16, 16), 32, 32);\n        }else if(this.type.equals(\"GLR\")){\n            floorImage = scaleImage(sheet.grabImage(9, 12, 16, 16), 32, 32);\n        }else if(this.type.equals(\"HRU\")){\n            floorImage = scaleImage(sheet.grabImage(1, 7, 16, 16), 32, 32);\n        }else if(this.type.equals(\"HRD\")){\n            floorImage = scaleImage(sheet.grabImage(1, 8, 16, 16), 32, 32);\n        }else if(this.type.equals(\"VRR\")){\n            floorImage = scaleImage(sheet.grabImage(2, 7, 16, 16), 32, 32);\n        }else if(this.type.equals(\"VRL\")){\n            floorImage = scaleImage(sheet.grabImage(3, 7, 16, 16), 32, 32);\n        }else if(this.type.equals(\"TRRUL\")){\n            floorImage = scaleImage(sheet.grabImage(5, 6, 16, 16), 32, 32);\n        }else if(this.type.equals(\"TRRUR\")){\n            floorImage = scaleImage(sheet.grabImage(6, 6, 16, 16), 32, 32);\n        }else if(this.type.equals(\"TRRLL\")){\n            floorImage = scaleImage(sheet.grabImage(5, 7, 16, 16), 32, 32);\n        }else if(this.type.equals(\"TRRLR\")){\n            floorImage = scaleImage(sheet.grabImage(6, 7, 16, 16), 32, 32);\n        }\n    }\n\n    public void tick() {\n    }\n\n    public void render(Graphics g) {\n        g.drawImage(floorImage, (int)x, (int)y, null);\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle((int)x, (int)y, 32, 32);\n    }\n    \n    private BufferedImage scaleImage(BufferedImage original, int width, int height) {\n        BufferedImage scaled = new BufferedImage(width, height, original.getType());\n        Graphics2D g2d = scaled.createGraphics();\n        g2d.drawImage(original, 0, 0, width, height, null);\n        g2d.dispose();\n        return scaled;\n    }\n}\n",
      "Spawner.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.util.ArrayList;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class Spawner extends GameObject{\n\n    Game game;\n    Handler handler;\n    Player player;\n\n    private long lastSpawnTime = System.currentTimeMillis();\n    private final int SPAWN_INTERVAL_MS = 3_000; // 3 seconds = 3000 ms\n\n    private int ZOMBIE_COUNT;\n    private int GOLEM_COUNT;\n    private int SHADOW_COUNT;\n    private int BANDIT_COUNT;\n\n    public Spawner(float x, float y, ID id, Game game, Handler handler, Player player){\n        super(x, y, id);\n        this.game = game;\n        this.handler = handler;\n        this.player = player;\n    }\n\n    public void tick() {\n        if(game.GAME_STATE == 1){\n            long now = System.currentTimeMillis();\n            if (now - lastSpawnTime >= SPAWN_INTERVAL_MS) {\n                spawn();\n                lastSpawnTime = now; \n            }\n        }\n    }\n\n    public void render(Graphics g) {\n        \n        if(game.isDebug()) {\n            g.setColor(Color.red);\n            Rectangle bounds = getBounds();\n            g.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);\n        }\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle((int)x, (int)y, 32, 32);\n    }\n    \n    public void spawn(){\n        \n        boolean zombieIsAvailable = ZOMBIE_COUNT > 0 ? true : false;\n        boolean golemIsAvailable = GOLEM_COUNT > 0 ? true : false;\n        boolean shadowIsAvailable = SHADOW_COUNT > 0 ? true : false;\n        boolean banditIsAvailable = BANDIT_COUNT > 0 ? true : false;\n\n        ArrayList<Integer> entities = new ArrayList<>();\n        if(zombieIsAvailable){ entities.add(1); }\n        if(golemIsAvailable){ entities.add(2); }\n        if(shadowIsAvailable){ entities.add(3); }\n        if(banditIsAvailable){ entities.add(4); }\n\n        int r = 0;\n        if(!entities.isEmpty()){\n            r = entities.get(ThreadLocalRandom.current().nextInt(0, entities.size()));\n        }\n\n        if(entities.size() > 0){\n            switch(r){\n                case 1: handler.addObject(new Enemy(this.x, this.y, ID.Enemy, handler, player, game, \"Zombie\")); ZOMBIE_COUNT--; break;\n                case 2: handler.addObject(new Enemy(this.x, this.y, ID.Enemy, handler, player, game, \"Golem\")); GOLEM_COUNT--; break;\n                case 3: handler.addObject(new Enemy(this.x, this.y, ID.Enemy, handler, player, game, \"Shadow\")); SHADOW_COUNT--; break;\n                case 4: handler.addObject(new Enemy(this.x, this.y, ID.Enemy, handler, player, game, \"Bandit\")); BANDIT_COUNT--; break;\n            }\n        }\n    }\n\n    public void addZOMBIE(){ this.ZOMBIE_COUNT++; }\n    public void addGOLEM(){ this.GOLEM_COUNT++; }\n    public void addSHADOW(){ this.SHADOW_COUNT++; }\n    public void addBANDIT(){ this.BANDIT_COUNT++; }\n    \n}\n",
      "ID.java": "public enum ID {\n    Player(),\n    Block(),\n    Crate(),\n    Bullet(),\n    Explosion(),\n    Spawner(),\n    Floor(),\n    Enemy();\n}\n",
      "KeyInput.java": "import java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\npublic class KeyInput extends KeyAdapter{\n    \n    Handler handler;\n    Game game;\n\n    public KeyInput(Handler handler, Game game) {\n        this.handler = handler;\n        this.game = game;\n    }\n\n    public void keyPressed(KeyEvent e) { \n        if(game.GAME_STATE == 4) { return; }\n        \n        int key = e.getKeyCode();\n\n        for (int i = 0; i < handler.object.size(); i++) {\n            GameObject tempObject = handler.object.get(i);\n\n            if (tempObject.getID() == ID.Player) {\n                if (key == KeyEvent.VK_W) handler.setUp(true);\n                if (key == KeyEvent.VK_S) handler.setDown(true);\n                if (key == KeyEvent.VK_D) handler.setRight(true);\n                if (key == KeyEvent.VK_A) handler.setLeft(true);\n            }\n        }\n    }\n\n    public void keyReleased(KeyEvent e) {\n        if(game.GAME_STATE == 4) { return; }\n        \n        int key = e.getKeyCode();\n\n        for (int i = 0; i < handler.object.size(); i++) {\n            GameObject tempObject = handler.object.get(i);\n\n            if (tempObject.getID() == ID.Player) {\n                if (key == KeyEvent.VK_W) handler.setUp(false);\n                if (key == KeyEvent.VK_S) handler.setDown(false);\n                if (key == KeyEvent.VK_D) handler.setRight(false);\n                if (key == KeyEvent.VK_A) handler.setLeft(false);\n                if (key == KeyEvent.VK_ESCAPE) {\n                    if (game.GAME_STATE == 1) { game.GAME_STATE = 2; } \n                    else if (game.GAME_STATE == 2) { game.GAME_STATE = 1; }\n                }\n                if (key == KeyEvent.VK_R) { // RELOAD\n                    game.reloadAmmo();\n                }\n                if (key == KeyEvent.VK_1) { // SWITCH TO Pistol\n                    game.changeWeapon(\"Pistol\");\n                }\n                if (key == KeyEvent.VK_2) { // SWITCH TO ASSAULT RIFLE\n                    if(game.getWave() > game.getASSAULT_RIFLE_FIRST_WAVE() || (game.getWave() == game.getASSAULT_RIFLE_FIRST_WAVE() && game.isWaveFinished())){\n                        game.changeWeapon(\"Assault Rifle\");\n                    }\n                }\n                if (key == KeyEvent.VK_3) { // SWITCH TO SHOTGUN\n                    if(game.getWave() > game.getSHOTGUN_FIRST_WAVE() || (game.getWave() == game.getSHOTGUN_FIRST_WAVE() && game.isWaveFinished())){\n                        game.changeWeapon(\"Shotgun\");\n                    }\n                }\n                if (key == KeyEvent.VK_4) { // SWITCH TO SNIPER\n                    if(game.getWave() > game.getSNIPER_FIRST_WAVE() || (game.getWave() == game.getSNIPER_FIRST_WAVE() && game.isWaveFinished())){\n                        game.changeWeapon(\"Sniper\");\n                    }\n                }\n                if (key == KeyEvent.VK_5) { // SWITCH TO ROCKET LAUNCHER\n                    if(game.getWave() > game.getROCKET_LAUNCHER_FIRST_WAVE() || (game.getWave() == game.getROCKET_LAUNCHER_FIRST_WAVE() && game.isWaveFinished())){\n                        game.changeWeapon(\"Rocket Launcher\");\n                    }\n                }\n            }\n        }\n    }\n                   \n}\n",
      "Enemy.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class Enemy extends GameObject {\n\n    Animation zombieAnimUpWalk;\n    Animation zombieAnimDownWalk;\n    Animation zombieAnimRightWalk;\n    Animation zombieAnimLeftWalk;\n    Animation zombieAnimUpAttack;\n    Animation zombieAnimDownAttack;\n    Animation zombieAnimRightAttack;\n    Animation zombieAnimLeftAttack;\n    Animation zombieAnimUpDeath;\n    Animation zombieAnimDownDeath;\n    Animation zombieAnimRightDeath;\n    Animation zombieAnimLeftDeath;\n\n    Animation golemAnimUpWalk;\n    Animation golemAnimDownWalk;\n    Animation golemAnimRightWalk;\n    Animation golemAnimLeftWalk;\n    Animation golemAnimUpAttack;\n    Animation golemAnimDownAttack;\n    Animation golemAnimRightAttack;\n    Animation golemAnimLeftAttack;\n    Animation golemAnimUpDeath;\n    Animation golemAnimDownDeath;\n    Animation golemAnimRightDeath;\n    Animation golemAnimLeftDeath;\n\n    Animation banditAnimUpWalk;\n    Animation banditAnimDownWalk;\n    Animation banditAnimRightWalk;\n    Animation banditAnimLeftWalk;\n    Animation banditAnimUpDeath;\n    Animation banditAnimDownDeath;\n    Animation banditAnimRightDeath;\n    Animation banditAnimLeftDeath;\n    Animation banditAnimUpShoot;\n    Animation banditAnimDownShoot;\n    Animation banditAnimRightShoot;\n    Animation banditAnimLeftShoot;\n    Animation banditAnimUpStab;\n    Animation banditAnimDownStab;\n    Animation banditAnimRightStab;\n    Animation banditAnimLeftStab;\n    Animation banditAnimUpIdle;\n    Animation banditAnimDownIdle;\n    Animation banditAnimRightIdle;\n    Animation banditAnimLeftIdle;\n\n    Animation shadowAnimUpWalk;\n    Animation shadowAnimDownWalk;\n    Animation shadowAnimRightWalk;\n    Animation shadowAnimLeftWalk;\n    Animation shadowAnimUpDeath;\n    Animation shadowAnimDownDeath;\n    Animation shadowAnimRightDeath;\n    Animation shadowAnimLeftDeath;\n    Animation shadowAnimUpAttack;\n    Animation shadowAnimDownAttack;\n    Animation shadowAnimRightAttack;\n    Animation shadowAnimLeftAttack;\n    Animation shadowAnimUpJumpAttack;\n    Animation shadowAnimDownJumpAttack;\n    Animation shadowAnimRightJumpAttack;\n    Animation shadowAnimLeftJumpAttack;\n\n    Animation bloodEffect1;\n    Animation bloodEffect2;\n    Animation bloodEffect3;\n    Animation bloodEffect4;\n    Animation bloodEffect5;\n    Animation bloodEffect6;\n    Animation bloodEffect7;\n    Animation bloodEffect8;\n    Animation bloodEffect9;\n\n    private boolean wasHit = false;\n    private boolean effectChosen = false;\n    private int bloodEffectCounter = 0;\n    private final int BLOOD_EFFECT_DURATION = 40; \n    private int selectedBloodEffect = 1; \n\n    BufferedImage granade;\n\n    Game game;\n    Handler handler;\n    protected int HP;\n    protected float speed;\n    protected int damage;\n    protected int cooldownCounterSpecific;\n    String direction = \"down\";\n    Player player;\n    String type;\n    int centerX;\n    int centerY;\n    private boolean attacking;\n    private boolean dying;\n    private boolean dead = false;\n    private int deathFrameCounter = 0;\n    private boolean isCooldown;\n    private int cooldownCounter = 0;\n    private boolean shooting = false;\n    private boolean shootingCooldown = false;\n    private int shootingCooldownCounter = 0;\n    private int shootingFrameCounter = 0;\n    private boolean dropGranade = false;\n    private int granadeExplosionTime = 45;\n    private int granadeExplosionTimeCounter = 0;\n    private boolean jumpAttackPerformed = false;\n    private boolean jumpAttacking = false;\n    private boolean jumpAttackCooldown = false;\n    private int jumpAttackCooldownCounter = 0;\n    private int jumpAttackFrameCounter = 0;\n    \n    private final int ZOMBIE_HP = 100;\n    private final int ZOMBIE_DAMAGE = 8;\n    private final int ZOMBIE_ATTACK_COOLDOWN = 75;\n    private final float ZOMBIE_SPEED = 2;\n    private final int ZOMBIE_CENTER_X = 15;\n    private final int ZOMBIE_CENTER_Y = 16;\n    private final int ZOMBIE_SCORE = 100;\n    \n    private final int GOLEM_HP = 700;\n    private final int GOLEM_DAMAGE = 40;\n    private final int GOLEM_ATTACK_COOLDOWN = 120;\n    private final float GOLEM_SPEED = 0.6f;\n    private final int GOLEM_CENTER_X = 30;\n    private final int GOLEM_CENTER_Y = 33;\n    private final int GOLEM_SCORE = 500;\n\n    private final int SHADOW_HP = 75;\n    private final int SHADOW_DAMAGE = 5;\n    private final int SHADOW_ATTACK_COOLDOWN = 30;\n    private final float SHADOW_SPEED = 4.3f;\n    private final int SHADOW_CENTER_X = 23;\n    private final int SHADOW_CENTER_Y = 24;\n    private final int SHADOW_JUMP_ATTACK_DISTANCE = 180;\n    private final int SHADOW_JUMP_ATTACK_DAMAGE = 10;\n    private final int SHADOW_JUMP_ATTACK_COOLDOWN = 600;\n    private final int SHADOW_SCORE = 200;\n\n    private final int BANDIT_HP = 60;\n    private static final int BANDIT_SHOOTING_DAMAGE = 6;\n    private final int BANDIT_STAB_DAMAGE = 3;\n    private final int BANDIT_STAB_COOLDOWN = 50;\n    private final int BANDIT_SHOOTING_COOLDOWN = 120;\n    private final float BANDIT_SPEED = 2f;\n    private final int BANDIT_CENTER_X = 15;\n    private final int BANDIT_CENTER_Y = 16;\n    private final int BANDIT_CHASING_DISTANCE = 350;\n    private final int BANDIT_SCORE = 300;\n\n    public Enemy(float x, float y, ID id, Handler handler, Player player, Game game, String type) {\n        super(x, y, id);\n        this.game = game;\n        this.handler = handler;\n        this.player = player;\n        this.type = type;\n\n        if(this.type.equals(\"Zombie\")){\n            this.HP = ZOMBIE_HP;\n            this.speed = ZOMBIE_SPEED;\n            this.damage = ZOMBIE_DAMAGE;\n            this.cooldownCounterSpecific = ZOMBIE_ATTACK_COOLDOWN;\n        }else if(this.type.equals(\"Golem\")){\n            this.HP = GOLEM_HP;\n            this.speed = GOLEM_SPEED;\n            this.damage = GOLEM_DAMAGE;\n            this.cooldownCounterSpecific = GOLEM_ATTACK_COOLDOWN;\n        }\n        else if(this.type.equals(\"Shadow\")){\n            this.HP = SHADOW_HP;\n            this.speed = SHADOW_SPEED;\n            this.damage = SHADOW_DAMAGE;\n            this.cooldownCounterSpecific = SHADOW_ATTACK_COOLDOWN;\n        }else{ // Bandit\n            this.HP = BANDIT_HP;\n            this.speed = BANDIT_SPEED;\n            this.damage = BANDIT_STAB_DAMAGE;\n            this.cooldownCounterSpecific = BANDIT_STAB_COOLDOWN;\n        }\n\n        {// ANIMATIONS\n            BufferedImageLoader loader = new BufferedImageLoader();\n            \n            SpriteSheet weaponSheet = new SpriteSheet(loader.loadImage(\"./Resources/Weapones/weapones.png\"));\n            granade = scaleImage(weaponSheet.grabImage(3, 1, 16, 16), 18, 18);\n\n            SpriteSheet bloodEffectSheet = new SpriteSheet(loader.loadImage(\"./Resources/bloodEffect/blood-effect-sheet.png\"));\n            BufferedImage[] bloodEffectImage1 = new BufferedImage[8];\n            BufferedImage[] bloodEffectImage2 = new BufferedImage[9];\n            BufferedImage[] bloodEffectImage3 = new BufferedImage[5];\n            BufferedImage[] bloodEffectImage4 = new BufferedImage[10];\n            BufferedImage[] bloodEffectImage5 = new BufferedImage[8];\n            BufferedImage[] bloodEffectImage6 = new BufferedImage[8];\n            BufferedImage[] bloodEffectImage7 = new BufferedImage[14];\n            BufferedImage[] bloodEffectImage8 = new BufferedImage[7];\n            BufferedImage[] bloodEffectImage9 = new BufferedImage[10];\n\n            for (int i = 1; i < bloodEffectImage1.length+1; i++) {\n                bloodEffectImage1[i-1] = scaleImage(bloodEffectSheet.grabImage(1, i+1, 110, 93), 16, 16);\n            }\n            for (int i = 1; i < bloodEffectImage2.length; i++) {\n                bloodEffectImage2[i-1] = scaleImage(bloodEffectSheet.grabImage(2, i+1, 110, 93), 16, 16);\n            }\n            for (int i = 1; i < bloodEffectImage3.length; i++) {\n                bloodEffectImage3[i-1] = scaleImage(bloodEffectSheet.grabImage(3, i+1, 110, 93), 16, 16);\n            }\n            for (int i = 1; i < bloodEffectImage4.length; i++) {\n                bloodEffectImage4[i-1] = scaleImage(bloodEffectSheet.grabImage(4, i+1, 110, 93), 16, 16);\n            }\n            for (int i = 1; i < bloodEffectImage5.length; i++) {\n                bloodEffectImage5[i-1] = scaleImage(bloodEffectSheet.grabImage(5, i+1, 110, 93), 16, 16);\n            }\n            for (int i = 1; i < bloodEffectImage6.length; i++) {\n                bloodEffectImage6[i-1] = scaleImage(bloodEffectSheet.grabImage(6, i+1, 110, 93), 16, 16);\n            }\n            for (int i = 1; i < bloodEffectImage7.length; i++) {\n                bloodEffectImage7[i-1] = scaleImage(bloodEffectSheet.grabImage(7, i+1, 110, 93), 16, 16);\n            }\n            for (int i = 1; i < bloodEffectImage8.length; i++) {\n                bloodEffectImage8[i-1] = scaleImage(bloodEffectSheet.grabImage(8, i+1, 110, 93), 16, 16);\n            }\n            for (int i = 1; i < bloodEffectImage9.length; i++) {\n                bloodEffectImage9[i-1] =scaleImage(bloodEffectSheet.grabImage(9, i+1, 110, 93), 16, 16);\n            }\n\n            bloodEffect1 = new Animation(3, bloodEffectImage1[0], bloodEffectImage1[1], bloodEffectImage1[2], bloodEffectImage1[3], bloodEffectImage1[4], bloodEffectImage1[5], bloodEffectImage1[6], bloodEffectImage1[7]);\n            bloodEffect2 = new Animation(3, bloodEffectImage2[0], bloodEffectImage2[1], bloodEffectImage2[2], bloodEffectImage2[3], bloodEffectImage2[4], bloodEffectImage2[5], bloodEffectImage2[6], bloodEffectImage2[7], bloodEffectImage2[8]);\n            bloodEffect3 = new Animation(3, bloodEffectImage3[0], bloodEffectImage3[1], bloodEffectImage3[2], bloodEffectImage3[3], bloodEffectImage3[4]);\n            bloodEffect4 = new Animation(3, bloodEffectImage4[0], bloodEffectImage4[1], bloodEffectImage4[2], bloodEffectImage4[3], bloodEffectImage4[4], bloodEffectImage4[5], bloodEffectImage4[6], bloodEffectImage4[7], bloodEffectImage4[8], bloodEffectImage4[9]);\n            bloodEffect5 = new Animation(3, bloodEffectImage5[0], bloodEffectImage5[1], bloodEffectImage5[2], bloodEffectImage5[3], bloodEffectImage5[4], bloodEffectImage5[5], bloodEffectImage5[6], bloodEffectImage5[7]);\n            bloodEffect6 = new Animation(3, bloodEffectImage6[0], bloodEffectImage6[1], bloodEffectImage6[2], bloodEffectImage6[3], bloodEffectImage6[4], bloodEffectImage6[5], bloodEffectImage6[6], bloodEffectImage6[7]);\n            bloodEffect7 = new Animation(3, bloodEffectImage7[0], bloodEffectImage7[1], bloodEffectImage7[2], bloodEffectImage7[3], bloodEffectImage7[4], bloodEffectImage7[5], bloodEffectImage7[6], bloodEffectImage7[7], bloodEffectImage7[8], bloodEffectImage7[9], bloodEffectImage7[10], bloodEffectImage7[11], bloodEffectImage7[12], bloodEffectImage7[13]);\n            bloodEffect8 = new Animation(3, bloodEffectImage8[0], bloodEffectImage8[1], bloodEffectImage8[2], bloodEffectImage8[3], bloodEffectImage8[4], bloodEffectImage8[5], bloodEffectImage8[6]);\n            bloodEffect9 = new Animation(3, bloodEffectImage9[0], bloodEffectImage9[1], bloodEffectImage9[2], bloodEffectImage9[3], bloodEffectImage9[4], bloodEffectImage9[5], bloodEffectImage9[6], bloodEffectImage9[7], bloodEffectImage9[8], bloodEffectImage9[9]);\n\n            if(type.equals(\"Zombie\")){\n                BufferedImage[] zombieWalkImage = new BufferedImage[40];\n                SpriteSheet walkSpriteSheet = new SpriteSheet(loader.loadImage(\"./Resources/normalEnemy/Walk.png\"));\n                zombieWalkImage[0]  = walkSpriteSheet.grabImage(1, 1, 32, 32);\n                zombieWalkImage[1]  = walkSpriteSheet.grabImage(2, 1, 32, 32);\n                zombieWalkImage[2]  = walkSpriteSheet.grabImage(3, 1, 32, 32);\n                zombieWalkImage[3]  = walkSpriteSheet.grabImage(4, 1, 32, 32);\n                zombieWalkImage[4]  = walkSpriteSheet.grabImage(5, 1, 32, 32);\n                zombieWalkImage[5]  = walkSpriteSheet.grabImage(6, 1, 32, 32); // DOWN\n                zombieWalkImage[6]  = walkSpriteSheet.grabImage(7, 1, 32, 32);\n                zombieWalkImage[7]  = walkSpriteSheet.grabImage(8, 1, 32, 32);\n                zombieWalkImage[8]  = walkSpriteSheet.grabImage(9, 1, 32, 32);\n                zombieWalkImage[9]  = walkSpriteSheet.grabImage(10, 1, 32, 32);\n\n                zombieWalkImage[10] = walkSpriteSheet.grabImage(1, 2, 32, 32);\n                zombieWalkImage[11] = walkSpriteSheet.grabImage(2, 2, 32, 32);\n                zombieWalkImage[12] = walkSpriteSheet.grabImage(3, 2, 32, 32);\n                zombieWalkImage[13] = walkSpriteSheet.grabImage(4, 2, 32, 32);\n                zombieWalkImage[14] = walkSpriteSheet.grabImage(5, 2, 32, 32);\n                zombieWalkImage[15] = walkSpriteSheet.grabImage(6, 2, 32, 32); // UP\n                zombieWalkImage[16] = walkSpriteSheet.grabImage(7, 2, 32, 32);\n                zombieWalkImage[17] = walkSpriteSheet.grabImage(8, 2, 32, 32);\n                zombieWalkImage[18] = walkSpriteSheet.grabImage(9, 2, 32, 32);\n                zombieWalkImage[19] = walkSpriteSheet.grabImage(10, 2, 32, 32);\n\n                zombieWalkImage[20] = walkSpriteSheet.grabImage(1, 3, 32, 32);\n                zombieWalkImage[21] = walkSpriteSheet.grabImage(2, 3, 32, 32);\n                zombieWalkImage[22] = walkSpriteSheet.grabImage(3, 3, 32, 32);\n                zombieWalkImage[23] = walkSpriteSheet.grabImage(4, 3, 32, 32);\n                zombieWalkImage[24] = walkSpriteSheet.grabImage(5, 2, 32, 32);\n                zombieWalkImage[25] = walkSpriteSheet.grabImage(6, 3, 32, 32); // RIGHT\n                zombieWalkImage[26] = walkSpriteSheet.grabImage(7, 3, 32, 32);\n                zombieWalkImage[27] = walkSpriteSheet.grabImage(8, 3, 32, 32);\n                zombieWalkImage[28] = walkSpriteSheet.grabImage(9, 3, 32, 32);\n                zombieWalkImage[29] = walkSpriteSheet.grabImage(10, 3, 32, 32);\n\n                zombieWalkImage[30] = walkSpriteSheet.grabImage(1, 4, 32, 32);\n                zombieWalkImage[31] = walkSpriteSheet.grabImage(2, 4, 32, 32);\n                zombieWalkImage[32] = walkSpriteSheet.grabImage(3, 4, 32, 32);\n                zombieWalkImage[33] = walkSpriteSheet.grabImage(4, 4, 32, 32);\n                zombieWalkImage[34] = walkSpriteSheet.grabImage(5, 4, 32, 32);\n                zombieWalkImage[35] = walkSpriteSheet.grabImage(6, 4, 32, 32); // LEFT\n                zombieWalkImage[36] = walkSpriteSheet.grabImage(7, 4, 32, 32);\n                zombieWalkImage[37] = walkSpriteSheet.grabImage(8, 4, 32, 32);\n                zombieWalkImage[38] = walkSpriteSheet.grabImage(9, 4, 32, 32);\n                zombieWalkImage[39] = walkSpriteSheet.grabImage(10, 4, 32, 32);\n\n                BufferedImage[] zombieAttackImage = new BufferedImage[32];\n                SpriteSheet attackSpriteSheet = new SpriteSheet(loader.loadImage(\"./Resources/normalEnemy/Attack.png\"));\n                zombieAttackImage[0]  = attackSpriteSheet.grabImage(1, 1, 32, 32);\n                zombieAttackImage[1]  = attackSpriteSheet.grabImage(2, 1, 32, 32);\n                zombieAttackImage[2]  = attackSpriteSheet.grabImage(3, 1, 32, 32);\n                zombieAttackImage[3]  = attackSpriteSheet.grabImage(4, 1, 32, 32); // DOWN\n                zombieAttackImage[4]  = attackSpriteSheet.grabImage(5, 1, 32, 32);\n                zombieAttackImage[5]  = attackSpriteSheet.grabImage(6, 1, 32, 32); \n                zombieAttackImage[6]  = attackSpriteSheet.grabImage(7, 1, 32, 32);\n                zombieAttackImage[7]  = attackSpriteSheet.grabImage(8, 1, 32, 32);\n\n                zombieAttackImage[8] = attackSpriteSheet.grabImage(1, 2, 32, 32);\n                zombieAttackImage[9] = attackSpriteSheet.grabImage(2, 2, 32, 32);\n                zombieAttackImage[10] = attackSpriteSheet.grabImage(3, 2, 32, 32);\n                zombieAttackImage[11] = attackSpriteSheet.grabImage(4, 2, 32, 32); // UP \n                zombieAttackImage[12] = attackSpriteSheet.grabImage(5, 2, 32, 32);\n                zombieAttackImage[13] = attackSpriteSheet.grabImage(6, 2, 32, 32); \n                zombieAttackImage[14] = attackSpriteSheet.grabImage(7, 2, 32, 32);\n                zombieAttackImage[15] = attackSpriteSheet.grabImage(8, 2, 32, 32);\n\n                zombieAttackImage[16] = attackSpriteSheet.grabImage(1, 3, 32, 32);\n                zombieAttackImage[17] = attackSpriteSheet.grabImage(2, 3, 32, 32);\n                zombieAttackImage[18] = attackSpriteSheet.grabImage(3, 3, 32, 32);\n                zombieAttackImage[19] = attackSpriteSheet.grabImage(4, 3, 32, 32); // RIGHT\n                zombieAttackImage[20] = attackSpriteSheet.grabImage(5, 3, 32, 32);\n                zombieAttackImage[21] = attackSpriteSheet.grabImage(6, 3, 32, 32);\n                zombieAttackImage[22] = attackSpriteSheet.grabImage(7, 3, 32, 32);\n                zombieAttackImage[23] = attackSpriteSheet.grabImage(8, 3, 32, 32);\n\n                zombieAttackImage[24] = attackSpriteSheet.grabImage(1, 4, 32, 32);\n                zombieAttackImage[25] = attackSpriteSheet.grabImage(2, 4, 32, 32);\n                zombieAttackImage[26] = attackSpriteSheet.grabImage(3, 4, 32, 32);\n                zombieAttackImage[27] = attackSpriteSheet.grabImage(4, 4, 32, 32); // LEFT\n                zombieAttackImage[28] = attackSpriteSheet.grabImage(5, 4, 32, 32);\n                zombieAttackImage[29] = attackSpriteSheet.grabImage(6, 4, 32, 32); \n                zombieAttackImage[30] = attackSpriteSheet.grabImage(7, 4, 32, 32);\n                zombieAttackImage[31] = attackSpriteSheet.grabImage(8, 4, 32, 32);\n\n                BufferedImage[] zombieDeathImage = new BufferedImage[40];\n                SpriteSheet deathSpriteSheet = new SpriteSheet(loader.loadImage(\"./Resources/normalEnemy/Death.png\"));\n                zombieDeathImage[0]  = deathSpriteSheet.grabImage(1, 1, 32, 32);\n                zombieDeathImage[1]  = deathSpriteSheet.grabImage(2, 1, 32, 32);\n                zombieDeathImage[2]  = deathSpriteSheet.grabImage(3, 1, 32, 32);\n                zombieDeathImage[3]  = deathSpriteSheet.grabImage(4, 1, 32, 32); // DOWN\n                zombieDeathImage[4]  = deathSpriteSheet.grabImage(5, 1, 32, 32);\n                zombieDeathImage[5]  = deathSpriteSheet.grabImage(6, 1, 32, 32); \n                zombieDeathImage[6]  = deathSpriteSheet.grabImage(7, 1, 32, 32);\n\n                zombieDeathImage[7] = deathSpriteSheet.grabImage(1, 2, 32, 32);\n                zombieDeathImage[8] = deathSpriteSheet.grabImage(2, 2, 32, 32);\n                zombieDeathImage[9] = deathSpriteSheet.grabImage(3, 2, 32, 32);\n                zombieDeathImage[10] = deathSpriteSheet.grabImage(4, 2, 32, 32); // UP\n                zombieDeathImage[11] = deathSpriteSheet.grabImage(5, 2, 32, 32);\n                zombieDeathImage[12] = deathSpriteSheet.grabImage(6, 2, 32, 32); \n                zombieDeathImage[13] = deathSpriteSheet.grabImage(7, 2, 32, 32);\n\n                zombieDeathImage[14] = deathSpriteSheet.grabImage(1, 3, 32, 32);\n                zombieDeathImage[15] = deathSpriteSheet.grabImage(2, 3, 32, 32);\n                zombieDeathImage[16] = deathSpriteSheet.grabImage(3, 3, 32, 32);\n                zombieDeathImage[17] = deathSpriteSheet.grabImage(4, 3, 32, 32); // RIGHT   \n                zombieDeathImage[18] = deathSpriteSheet.grabImage(5, 3, 32, 32);\n                zombieDeathImage[19] = deathSpriteSheet.grabImage(6, 3, 32, 32); \n                zombieDeathImage[20] = deathSpriteSheet.grabImage(7, 3, 32, 32);\n\n                zombieDeathImage[21] = deathSpriteSheet.grabImage(1, 4, 32, 32);\n                zombieDeathImage[22] = deathSpriteSheet.grabImage(2, 4, 32, 32);\n                zombieDeathImage[23] = deathSpriteSheet.grabImage(3, 4, 32, 32);\n                zombieDeathImage[24] = deathSpriteSheet.grabImage(4, 4, 32, 32); // LEFT\n                zombieDeathImage[25] = deathSpriteSheet.grabImage(5, 4, 32, 32);\n                zombieDeathImage[26] = deathSpriteSheet.grabImage(6, 4, 32, 32); \n                zombieDeathImage[27] = deathSpriteSheet.grabImage(7, 4, 32, 32);\n                \n                zombieAnimDownWalk  = new Animation(5, zombieWalkImage[0],  zombieWalkImage[1],  zombieWalkImage[2],  zombieWalkImage[3], zombieWalkImage[4],  zombieWalkImage[5],  zombieWalkImage[6],  zombieWalkImage[7], zombieWalkImage[8],  zombieWalkImage[9]);\n                zombieAnimUpWalk    = new Animation(5, zombieWalkImage[10], zombieWalkImage[11], zombieWalkImage[12], zombieWalkImage[13], zombieWalkImage[14], zombieWalkImage[15], zombieWalkImage[16], zombieWalkImage[17], zombieWalkImage[18], zombieWalkImage[19]);\n                zombieAnimRightWalk = new Animation(5, zombieWalkImage[20], zombieWalkImage[21], zombieWalkImage[22], zombieWalkImage[23], zombieWalkImage[24], zombieWalkImage[25], zombieWalkImage[26], zombieWalkImage[27],zombieWalkImage[28], zombieWalkImage[29]);\n                zombieAnimLeftWalk  = new Animation(5, zombieWalkImage[30], zombieWalkImage[31], zombieWalkImage[32], zombieWalkImage[33], zombieWalkImage[34], zombieWalkImage[35], zombieWalkImage[36], zombieWalkImage[37], zombieWalkImage[38], zombieWalkImage[39]);\n                zombieAnimDownAttack = new Animation(7, zombieAttackImage[0],  zombieAttackImage[1],  zombieAttackImage[2],  zombieAttackImage[3], zombieAttackImage[4],  zombieAttackImage[5],  zombieAttackImage[6],  zombieAttackImage[7]);\n                zombieAnimUpAttack = new Animation(7, zombieAttackImage[8],  zombieAttackImage[9],  zombieAttackImage[10],  zombieAttackImage[11], zombieAttackImage[12],  zombieAttackImage[13],  zombieAttackImage[14],  zombieAttackImage[15]);\n                zombieAnimRightAttack = new Animation(7, zombieAttackImage[16],  zombieAttackImage[17],  zombieAttackImage[18],  zombieAttackImage[19], zombieAttackImage[20],  zombieAttackImage[21],  zombieAttackImage[22],  zombieAttackImage[23]);\n                zombieAnimLeftAttack = new Animation(7, zombieAttackImage[24],  zombieAttackImage[25],  zombieAttackImage[26],  zombieAttackImage[27], zombieAttackImage[28],  zombieAttackImage[29],  zombieAttackImage[30],  zombieAttackImage[31]);\n                zombieAnimUpDeath = new Animation(5, zombieDeathImage[0],  zombieDeathImage[1],  zombieDeathImage[2],  zombieDeathImage[3], zombieDeathImage[4],  zombieDeathImage[5],  zombieDeathImage[6]);\n                zombieAnimDownDeath = new Animation(5, zombieDeathImage[7],  zombieDeathImage[8],  zombieDeathImage[9],  zombieDeathImage[10], zombieDeathImage[11],  zombieDeathImage[12],  zombieDeathImage[13]);\n                zombieAnimRightDeath = new Animation(5, zombieDeathImage[14],  zombieDeathImage[15],  zombieDeathImage[16],  zombieDeathImage[17], zombieDeathImage[18],  zombieDeathImage[19],  zombieDeathImage[20]);\n                zombieAnimLeftDeath = new Animation(5, zombieDeathImage[21],  zombieDeathImage[22],  zombieDeathImage[23],  zombieDeathImage[24], zombieDeathImage[25],  zombieDeathImage[26],  zombieDeathImage[27]);\n            }\n            else if(type.equals(\"Golem\")){\n                BufferedImage[] golemWalkImage = new BufferedImage[40];\n                SpriteSheet walkSpriteSheet = new SpriteSheet(loader.loadImage(\"./Resources/tankEnemy/walk/BossEnemy_walk.png\"));\n                for (int i = 0; i < golemWalkImage.length; i++) {\n                    if(i < 10){ // UP\n                        golemWalkImage[i] = walkSpriteSheet.grabImage(((i % 10) + 1), 1, 64, 64);  \n                    }\n                    else if(i >= 10 && i < 20){ // LEFT\n                        golemWalkImage[i] = walkSpriteSheet.grabImage(((i % 10) + 1), 2, 64, 64);\n                    }\n                    else if(i >= 20 && i < 30){ // RIGHT\n                        golemWalkImage[i] = walkSpriteSheet.grabImage(((i % 10) + 1), 3, 64, 64);\n                    }\n                    else{ // DOWN\n                        golemWalkImage[i] = walkSpriteSheet.grabImage(((i % 10) + 1), 4, 64, 64);\n                    }\n                }\n                \n\n                BufferedImage[] golemAttackImage = new BufferedImage[40];\n                SpriteSheet attackSpriteSheet = new SpriteSheet(loader.loadImage(\"./Resources/tankEnemy/swipe/BossEnemy_swipe.png\"));\n                for (int i = 0; i < golemAttackImage.length; i++) {\n                    if(i < 10){ // DOWN\n                        golemAttackImage[i] = attackSpriteSheet.grabImage(((i % 10) + 1), 1, 64, 64); \n                    }\n                    else if(i >= 10 && i < 20){ // UP\n                        golemAttackImage[i] = attackSpriteSheet.grabImage(((i % 10) + 1), 2, 64, 64);\n                    }\n                    else if(i >= 20 && i < 30){ // LEFT\n                        golemAttackImage[i] = attackSpriteSheet.grabImage(((i % 10) + 1), 3, 64, 64);\n                    }\n                    else{ // RIGHT\n                        golemAttackImage[i] = attackSpriteSheet.grabImage(((i % 10) + 1), 4, 64, 64);\n                    }\n                }\n\n                BufferedImage[] golemDeathImage = new BufferedImage[52];\n                SpriteSheet deathSpriteSheet = new SpriteSheet(loader.loadImage(\"./Resources/tankEnemy/stomp/BossEnemy_stomp.png\"));\n                for (int i = 0; i < golemDeathImage.length; i++) {\n                    if(i < 13){ // UP\n                        golemDeathImage[i] = deathSpriteSheet.grabImage(((i % 13) + 1), 1, 64, 64);\n                    }\n                    else if(i >= 13 && i < 26){ // LEFT\n                        golemDeathImage[i] = deathSpriteSheet.grabImage(((i % 13) + 1), 2, 64, 64);\n                    }\n                    else if(i >= 26 && i < 39){ // RIGHT\n                        golemDeathImage[i] = deathSpriteSheet.grabImage(((i % 13) + 1), 3, 64, 64);\n                    }\n                    else{ // DOWN\n                        golemDeathImage[i] = deathSpriteSheet.grabImage(((i % 13) + 1), 4, 64, 64);\n                    }\n                }\n\n                golemAnimUpWalk  = new Animation(5, golemWalkImage[0],  golemWalkImage[1],  golemWalkImage[2],  golemWalkImage[3], golemWalkImage[4],  golemWalkImage[5],  golemWalkImage[6],  golemWalkImage[7], golemWalkImage[8],  golemWalkImage[9]);\n                golemAnimLeftWalk    = new Animation(5, golemWalkImage[10], golemWalkImage[11], golemWalkImage[12], golemWalkImage[13], golemWalkImage[14], golemWalkImage[15], golemWalkImage[16], golemWalkImage[17], golemWalkImage[18], golemWalkImage[19]);\n                golemAnimRightWalk = new Animation(5, golemWalkImage[20], golemWalkImage[21], golemWalkImage[22], golemWalkImage[23], golemWalkImage[24], golemWalkImage[25], golemWalkImage[26], golemWalkImage[27],golemWalkImage[28], golemWalkImage[29]);\n                golemAnimDownWalk  = new Animation(5, golemWalkImage[30], golemWalkImage[31], golemWalkImage[32], golemWalkImage[33], golemWalkImage[34], golemWalkImage[35], golemWalkImage[36], golemWalkImage[37], golemWalkImage[38], golemWalkImage[39]);\n                golemAnimDownAttack  = new Animation(6, golemAttackImage[0],  golemAttackImage[1],  golemAttackImage[2],  golemAttackImage[3], golemAttackImage[4],  golemAttackImage[5],  golemAttackImage[6],  golemAttackImage[7], golemAttackImage[8],  golemAttackImage[9]);\n                golemAnimUpAttack    = new Animation(6, golemAttackImage[10], golemAttackImage[11], golemAttackImage[12], golemAttackImage[13], golemAttackImage[14], golemAttackImage[15], golemAttackImage[16], golemAttackImage[17], golemAttackImage[18], golemAttackImage[19]);\n                golemAnimLeftAttack = new Animation(6, golemAttackImage[20], golemAttackImage[21], golemAttackImage[22], golemAttackImage[23], golemAttackImage[24], golemAttackImage[25], golemAttackImage[26], golemAttackImage[27],golemAttackImage[28], golemAttackImage[29]);\n                golemAnimRightAttack  = new Animation(6, golemAttackImage[30], golemAttackImage[31], golemAttackImage[32], golemAttackImage[33], golemAttackImage[34], golemAttackImage[35], golemAttackImage[36], golemAttackImage[37], golemAttackImage[38], golemAttackImage[39]);\n                golemAnimUpDeath  = new Animation(4, golemDeathImage[0],  golemDeathImage[1],  golemDeathImage[2],  golemDeathImage[3], golemDeathImage[4],  golemDeathImage[5],  golemDeathImage[6],  golemDeathImage[7], golemDeathImage[8],  golemDeathImage[9],  golemDeathImage[10],  golemDeathImage[11],  golemDeathImage[12]);\n                golemAnimLeftDeath    = new Animation(4, golemDeathImage[13], golemDeathImage[14], golemDeathImage[15], golemDeathImage[16], golemDeathImage[17], golemDeathImage[18], golemDeathImage[19], golemDeathImage[20], golemDeathImage[21], golemDeathImage[22],  golemDeathImage[23],  golemDeathImage[24],  golemDeathImage[25]);\n                golemAnimRightDeath = new Animation(4, golemDeathImage[26], golemDeathImage[27], golemDeathImage[28], golemDeathImage[29], golemDeathImage[30], golemDeathImage[31], golemDeathImage[32], golemDeathImage[33],golemDeathImage[34], golemDeathImage[35],  golemDeathImage[36],  golemDeathImage[37],  golemDeathImage[38]);\n                golemAnimDownDeath  = new Animation(4, golemDeathImage[39], golemDeathImage[40], golemDeathImage[41], golemDeathImage[42], golemDeathImage[43], golemDeathImage[44], golemDeathImage[45], golemDeathImage[46], golemDeathImage[47], golemDeathImage[48],  golemDeathImage[49],  golemDeathImage[50],  golemDeathImage[51]);\n\n            }\n            else if(type.equals(\"Shadow\")){\n\n                BufferedImage[] shadowWalkImage = new BufferedImage[32];\n                SpriteSheet walkSpriteSheetDown = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Down/WarriorDownWalk.png\"));\n                SpriteSheet walkSpriteSheetLeft = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Left/WarriorLeftWalk.png\"));\n                SpriteSheet walkSpriteSheetRight = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Right/WarriorRightWalk.png\"));\n                SpriteSheet walkSpriteSheetUp = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Up/WarriorUpWalk.png\"));\n                for (int i = 0; i < shadowWalkImage.length; i++) {\n                    if(i < 8){ // DOWN\n                        shadowWalkImage[i] = walkSpriteSheetDown.grabImage(((i % 8) + 1), 1, 48, 48);  \n                    }\n                    else if(i >= 8 && i < 16){ // LEFT\n                        shadowWalkImage[i] = walkSpriteSheetLeft.grabImage(((i % 8) + 1), 1, 48, 48);\n                    }\n                    else if(i >= 16 && i < 24){ // RIGHT\n                        shadowWalkImage[i] = walkSpriteSheetRight.grabImage(((i % 8) + 1), 1, 48, 48);\n                    }\n                    else{ // UP\n                        shadowWalkImage[i] = walkSpriteSheetUp.grabImage(((i % 8) + 1), 1, 48, 48);\n                    }\n                }\n\n                BufferedImage[] shadowDeathImage = new BufferedImage[21];\n                SpriteSheet deathSpriteSheetDown = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Down/WarriorDownDeath.png\"));\n                SpriteSheet deathSpriteSheetLeft = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Left/WarriorLeftDeath.png\"));\n                SpriteSheet deathSpriteSheetRight = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Right/WarriorRightDeath.png\"));\n                SpriteSheet deathSpriteSheetUp = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Up/WarriorUpDeath.png\"));\n                for (int i = 0; i < shadowDeathImage.length; i++) {\n                    if(i < 5){ // DOWN\n                        shadowDeathImage[i] = deathSpriteSheetDown.grabImage(((i % 5) + 1), 1, 48, 48);  \n                    }\n                    else if(i >= 5 && i < 10){ // LEFT\n                        shadowDeathImage[i] = deathSpriteSheetLeft.grabImage(((i % 5) + 1), 1, 48, 48);\n                    }\n                    else if(i >= 10 && i < 15){ // RIGHT\n                        shadowDeathImage[i] = deathSpriteSheetRight.grabImage(((i % 5) + 1), 1, 48, 48);\n                    }\n                    else{ // UP\n                        shadowDeathImage[i] = deathSpriteSheetUp.grabImage(((i % 6) + 1), 1, 48, 48);\n                    }\n                }\n\n                BufferedImage[] shadowAttackImage = new BufferedImage[24];\n                SpriteSheet attackSpriteSheetDown = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Down/WarriorDownAttack01.png\"));\n                SpriteSheet attackSpriteSheetLeft = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Left/WarriorLeftAttack01.png\"));\n                SpriteSheet attackSpriteSheetRight = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Right/WarriorRightAttack01.png\"));\n                SpriteSheet attackSpriteSheetUp = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Up/WarriorUpAttack01.png\"));\n                for (int i = 0; i < shadowAttackImage.length; i++) {\n                    if(i < 6){ // DOWN\n                        shadowAttackImage[i] = attackSpriteSheetDown.grabImage(((i % 6) + 1), 1, 48, 48);  \n                    }\n                    else if(i >= 6 && i < 12){ // LEFT\n                        shadowAttackImage[i] = attackSpriteSheetLeft.grabImage(((i % 6) + 1), 1, 48, 48);\n                    }\n                    else if(i >= 12 && i < 18){ // RIGHT\n                        shadowAttackImage[i] = attackSpriteSheetRight.grabImage(((i % 6) + 1), 1, 48, 48);\n                    }\n                    else{ // UP\n                        shadowAttackImage[i] = attackSpriteSheetUp.grabImage(((i % 6) + 1), 1, 48, 48);\n                    }\n                }\n\n                BufferedImage[] shadowJumpAttackImage = new BufferedImage[24];\n                SpriteSheet jumpAttackSpriteSheetDown = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Down/WarriorDownAttack02.png\"));\n                SpriteSheet jumpAttackSpriteSheetLeft = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Left/WarriorLeftAttack02.png\"));\n                SpriteSheet jumpAttackSpriteSheetRight = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Right/WarriorRightAttack02.png\"));\n                SpriteSheet jumpAttackSpriteSheetUp = new SpriteSheet(loader.loadImage(\"./Resources/fastEnemy/Up/WarriorUpAttack02.png\"));\n                for (int i = 0; i < shadowJumpAttackImage.length; i++) {\n                    if(i < 6){ // DOWN\n                        shadowJumpAttackImage[i] = jumpAttackSpriteSheetDown.grabImage(((i % 6) + 1), 1, 48, 48);  \n                    }\n                    else if(i >= 6 && i < 12){ // LEFT\n                        shadowJumpAttackImage[i] = jumpAttackSpriteSheetLeft.grabImage(((i % 6) + 1), 1, 48, 48);\n                    }\n                    else if(i >= 12 && i < 18){ // RIGHT\n                        shadowJumpAttackImage[i] = jumpAttackSpriteSheetRight.grabImage(((i % 6) + 1), 1, 48, 48);\n                    }\n                    else{ // UP\n                        shadowJumpAttackImage[i] = jumpAttackSpriteSheetUp.grabImage(((i % 6) + 1), 1, 48, 48);\n                    }\n                }\n\n                shadowAnimDownWalk  = new Animation(2, shadowWalkImage[0],  shadowWalkImage[1],  shadowWalkImage[2],  shadowWalkImage[3], shadowWalkImage[4],  shadowWalkImage[5],  shadowWalkImage[6],  shadowWalkImage[7]);\n                shadowAnimLeftWalk    = new Animation(2, shadowWalkImage[8], shadowWalkImage[9], shadowWalkImage[10], shadowWalkImage[11], shadowWalkImage[12], shadowWalkImage[13], shadowWalkImage[14], shadowWalkImage[15]);\n                shadowAnimRightWalk = new Animation(2, shadowWalkImage[16], shadowWalkImage[17], shadowWalkImage[18], shadowWalkImage[19], shadowWalkImage[20], shadowWalkImage[21], shadowWalkImage[22], shadowWalkImage[23]);\n                shadowAnimUpWalk  = new Animation(2, shadowWalkImage[24], shadowWalkImage[25], shadowWalkImage[26], shadowWalkImage[27], shadowWalkImage[28], shadowWalkImage[29], shadowWalkImage[30], shadowWalkImage[31]);\n                shadowAnimDownDeath  = new Animation(5, shadowDeathImage[0],  shadowDeathImage[1],  shadowDeathImage[2],  shadowDeathImage[3], shadowDeathImage[4]);\n                shadowAnimLeftDeath    = new Animation(5, shadowDeathImage[5], shadowDeathImage[6], shadowDeathImage[7], shadowDeathImage[8], shadowDeathImage[9]);\n                shadowAnimRightDeath = new Animation(5, shadowDeathImage[10], shadowDeathImage[11], shadowDeathImage[12], shadowDeathImage[13], shadowDeathImage[14]);\n                shadowAnimUpDeath  = new Animation(5, shadowDeathImage[15], shadowDeathImage[16], shadowDeathImage[17], shadowDeathImage[18], shadowDeathImage[19], shadowDeathImage[20]);\n                shadowAnimDownAttack  = new Animation(3, shadowAttackImage[0],  shadowAttackImage[1],  shadowAttackImage[2],  shadowAttackImage[3], shadowAttackImage[4],  shadowAttackImage[5]);\n                shadowAnimLeftAttack    = new Animation(3, shadowAttackImage[6], shadowAttackImage[7], shadowAttackImage[8], shadowAttackImage[9], shadowAttackImage[10], shadowAttackImage[11]);\n                shadowAnimRightAttack = new Animation(3, shadowAttackImage[12], shadowAttackImage[13], shadowAttackImage[14], shadowAttackImage[15], shadowAttackImage[16], shadowAttackImage[17]);\n                shadowAnimUpAttack  = new Animation(3, shadowAttackImage[18], shadowAttackImage[19], shadowAttackImage[20], shadowAttackImage[21], shadowAttackImage[22], shadowAttackImage[23]);\n                shadowAnimDownJumpAttack  = new Animation(6, shadowJumpAttackImage[0],  shadowJumpAttackImage[1],  shadowJumpAttackImage[2],  shadowJumpAttackImage[3], shadowJumpAttackImage[4],  shadowJumpAttackImage[5]);\n                shadowAnimLeftJumpAttack    = new Animation(6, shadowJumpAttackImage[6], shadowJumpAttackImage[7], shadowJumpAttackImage[8], shadowJumpAttackImage[9], shadowJumpAttackImage[10], shadowJumpAttackImage[11]);\n                shadowAnimRightJumpAttack = new Animation(6, shadowJumpAttackImage[12], shadowJumpAttackImage[13], shadowJumpAttackImage[14], shadowJumpAttackImage[15], shadowJumpAttackImage[16], shadowJumpAttackImage[17]);\n                shadowAnimUpJumpAttack  = new Animation(6, shadowJumpAttackImage[18], shadowJumpAttackImage[19], shadowJumpAttackImage[20], shadowJumpAttackImage[21], shadowJumpAttackImage[22], shadowJumpAttackImage[23]);\n            }\n            else{ // Bandit\n                BufferedImage[] banditWalkImage = new BufferedImage[16];\n                SpriteSheet walkSpriteSheet = new SpriteSheet(loader.loadImage(\"./Resources/shooterEnemy/Walk.png\"));\n                banditWalkImage[0]  = walkSpriteSheet.grabImage(1, 1, 32, 32);\n                banditWalkImage[1]  = walkSpriteSheet.grabImage(2, 1, 32, 32);\n                banditWalkImage[2]  = walkSpriteSheet.grabImage(3, 1, 32, 32); // DOWN\n                banditWalkImage[3]  = walkSpriteSheet.grabImage(4, 1, 32, 32);\n\n                banditWalkImage[4]  = walkSpriteSheet.grabImage(1, 2, 32, 32);\n                banditWalkImage[5]  = walkSpriteSheet.grabImage(2, 2, 32, 32);\n                banditWalkImage[6]  = walkSpriteSheet.grabImage(3, 2, 32, 32); // UP\n                banditWalkImage[7]  = walkSpriteSheet.grabImage(4, 2, 32, 32);\n\n                banditWalkImage[8]  = walkSpriteSheet.grabImage(1, 3, 32, 32);\n                banditWalkImage[9]  = walkSpriteSheet.grabImage(2, 3, 32, 32);\n                banditWalkImage[10]  = walkSpriteSheet.grabImage(3, 3, 32, 32); // RIGHT\n                banditWalkImage[11]  = walkSpriteSheet.grabImage(4, 3, 32, 32);\n\n                banditWalkImage[12]  = walkSpriteSheet.grabImage(1, 4, 32, 32);\n                banditWalkImage[13]  = walkSpriteSheet.grabImage(2, 4, 32, 32);\n                banditWalkImage[14]  = walkSpriteSheet.grabImage(3, 4, 32, 32); // LEFT\n                banditWalkImage[15]  = walkSpriteSheet.grabImage(4, 4, 32, 32);\n\n                BufferedImage[] banditShootImage = new BufferedImage[16];\n                SpriteSheet shootSpriteSheet = new SpriteSheet(loader.loadImage(\"./Resources/shooterEnemy/Shoot.png\"));\n                banditShootImage[0]  = shootSpriteSheet.grabImage(1, 1, 32, 32);\n                banditShootImage[1]  = shootSpriteSheet.grabImage(2, 1, 32, 32);\n                banditShootImage[2]  = shootSpriteSheet.grabImage(3, 1, 32, 32); // DOWN\n                banditShootImage[3]  = shootSpriteSheet.grabImage(4, 1, 32, 32);\n\n                banditShootImage[4]  = shootSpriteSheet.grabImage(1, 2, 32, 32);\n                banditShootImage[5]  = shootSpriteSheet.grabImage(2, 2, 32, 32);\n                banditShootImage[6]  = shootSpriteSheet.grabImage(3, 2, 32, 32); // UP\n                banditShootImage[7]  = shootSpriteSheet.grabImage(4, 2, 32, 32);\n\n                banditShootImage[8]  = shootSpriteSheet.grabImage(1, 3, 32, 32);\n                banditShootImage[9]  = shootSpriteSheet.grabImage(2, 3, 32, 32);\n                banditShootImage[10]  = shootSpriteSheet.grabImage(3, 3, 32, 32); // RIGHT\n                banditShootImage[11]  = shootSpriteSheet.grabImage(4, 3, 32, 32);\n\n                banditShootImage[12]  = shootSpriteSheet.grabImage(1, 4, 32, 32);\n                banditShootImage[13]  = shootSpriteSheet.grabImage(2, 4, 32, 32);\n                banditShootImage[14]  = shootSpriteSheet.grabImage(3, 4, 32, 32); // LEFT\n                banditShootImage[15]  = shootSpriteSheet.grabImage(4, 4, 32, 32);\n                \n                BufferedImage[] banditDeathImage = new BufferedImage[16];\n                SpriteSheet deathSpriteSheet = new SpriteSheet(loader.loadImage(\"./Resources/shooterEnemy/Death.png\"));\n                banditDeathImage[0]  = deathSpriteSheet.grabImage(1, 1, 32, 32);\n                banditDeathImage[1]  = deathSpriteSheet.grabImage(2, 1, 32, 32);\n                banditDeathImage[2]  = deathSpriteSheet.grabImage(3, 1, 32, 32); // DOWN\n                banditDeathImage[3]  = deathSpriteSheet.grabImage(4, 1, 32, 32);\n\n                banditDeathImage[4]  = deathSpriteSheet.grabImage(1, 2, 32, 32);\n                banditDeathImage[5]  = deathSpriteSheet.grabImage(2, 2, 32, 32);\n                banditDeathImage[6]  = deathSpriteSheet.grabImage(3, 2, 32, 32); // UP\n                banditDeathImage[7]  = deathSpriteSheet.grabImage(4, 2, 32, 32);\n\n                banditDeathImage[8]  = deathSpriteSheet.grabImage(1, 3, 32, 32);\n                banditDeathImage[9]  = deathSpriteSheet.grabImage(2, 3, 32, 32);\n                banditDeathImage[10]  = deathSpriteSheet.grabImage(3, 3, 32, 32); // RIGHT\n                banditDeathImage[11]  = deathSpriteSheet.grabImage(4, 3, 32, 32);\n\n                banditDeathImage[12]  = deathSpriteSheet.grabImage(1, 4, 32, 32);\n                banditDeathImage[13]  = deathSpriteSheet.grabImage(2, 4, 32, 32);\n                banditDeathImage[14]  = deathSpriteSheet.grabImage(3, 4, 32, 32); // LEFT\n                banditDeathImage[15]  = deathSpriteSheet.grabImage(4, 4, 32, 32);\n\n                BufferedImage[] banditStabImage = new BufferedImage[16];\n                SpriteSheet stabSpriteSheet = new SpriteSheet(loader.loadImage(\"./Resources/shooterEnemy/Stab.png\"));\n                banditStabImage[0]  = stabSpriteSheet.grabImage(1, 1, 32, 32);\n                banditStabImage[1]  = stabSpriteSheet.grabImage(2, 1, 32, 32);\n                banditStabImage[2]  = stabSpriteSheet.grabImage(3, 1, 32, 32); // DOWN\n                banditStabImage[3]  = stabSpriteSheet.grabImage(4, 1, 32, 32);\n\n                banditStabImage[4]  = stabSpriteSheet.grabImage(1, 2, 32, 32);\n                banditStabImage[5]  = stabSpriteSheet.grabImage(2, 2, 32, 32);\n                banditStabImage[6]  = stabSpriteSheet.grabImage(3, 2, 32, 32); // UP\n                banditStabImage[7]  = stabSpriteSheet.grabImage(4, 2, 32, 32);\n\n                banditStabImage[8]  = stabSpriteSheet.grabImage(1, 3, 32, 32);\n                banditStabImage[9]  = stabSpriteSheet.grabImage(2, 3, 32, 32);\n                banditStabImage[10]  = stabSpriteSheet.grabImage(3, 3, 32, 32); // RIGHT\n                banditStabImage[11]  = stabSpriteSheet.grabImage(4, 3, 32, 32);\n\n                banditStabImage[12]  = stabSpriteSheet.grabImage(1, 4, 32, 32);\n                banditStabImage[13]  = stabSpriteSheet.grabImage(2, 4, 32, 32);\n                banditStabImage[14]  = stabSpriteSheet.grabImage(3, 4, 32, 32); // LEFT\n                banditStabImage[15]  = stabSpriteSheet.grabImage(4, 4, 32, 32);\n\n                BufferedImage[] banditIdleImage = new BufferedImage[16];\n                SpriteSheet idleSpriteSheet = new SpriteSheet(loader.loadImage(\"./Resources/shooterEnemy/Idle.png\"));\n                banditIdleImage[0]  = idleSpriteSheet.grabImage(1, 1, 32, 32);\n                banditIdleImage[1]  = idleSpriteSheet.grabImage(2, 1, 32, 32); // DOWN\n\n                banditIdleImage[2]  = idleSpriteSheet.grabImage(1, 2, 32, 32);\n                banditIdleImage[3]  = idleSpriteSheet.grabImage(2, 2, 32, 32); // UP\n\n                banditIdleImage[4]  = idleSpriteSheet.grabImage(1, 3, 32, 32);\n                banditIdleImage[5]  = idleSpriteSheet.grabImage(2, 3, 32, 32); // RIGHT\n\n                banditIdleImage[6]  = idleSpriteSheet.grabImage(1, 4, 32, 32);\n                banditIdleImage[7]  = idleSpriteSheet.grabImage(2, 4, 32, 32); // LEFT\n\n\n                banditAnimDownWalk = new Animation(4, banditWalkImage[0], banditWalkImage[1], banditWalkImage[2], banditWalkImage[3]);\n                banditAnimUpWalk = new Animation(4, banditWalkImage[4], banditWalkImage[5], banditWalkImage[6], banditWalkImage[7]);\n                banditAnimRightWalk = new Animation(4, banditWalkImage[8], banditWalkImage[9], banditWalkImage[10], banditWalkImage[11]);\n                banditAnimLeftWalk = new Animation(4, banditWalkImage[12], banditWalkImage[13], banditWalkImage[14], banditWalkImage[15]);\n                banditAnimDownShoot = new Animation(5, banditShootImage[0], banditShootImage[1], banditShootImage[2], banditShootImage[3]);\n                banditAnimUpShoot = new Animation(5, banditShootImage[4], banditShootImage[5], banditShootImage[6], banditShootImage[7]);\n                banditAnimRightShoot = new Animation(5, banditShootImage[8], banditShootImage[9], banditShootImage[10], banditShootImage[11]);\n                banditAnimLeftShoot = new Animation(5, banditShootImage[12], banditShootImage[13], banditShootImage[14], banditShootImage[15]);\n                banditAnimDownDeath = new Animation(6, banditDeathImage[0], banditDeathImage[1], banditDeathImage[2], banditDeathImage[3]);\n                banditAnimUpDeath = new Animation(6, banditDeathImage[4], banditDeathImage[5], banditDeathImage[6], banditDeathImage[7]);\n                banditAnimRightDeath = new Animation(6, banditDeathImage[8], banditDeathImage[9], banditDeathImage[10], banditDeathImage[11]);\n                banditAnimLeftDeath = new Animation(6, banditDeathImage[12], banditDeathImage[13], banditDeathImage[14], banditDeathImage[15]);\n                banditAnimDownStab = new Animation(4, banditStabImage[0], banditStabImage[1], banditStabImage[2], banditStabImage[3]);\n                banditAnimUpStab = new Animation(4, banditStabImage[4], banditStabImage[5], banditStabImage[6], banditStabImage[7]);\n                banditAnimRightStab = new Animation(4, banditStabImage[8], banditStabImage[9], banditStabImage[10], banditStabImage[11]);\n                banditAnimLeftStab = new Animation(4, banditStabImage[12], banditStabImage[13], banditStabImage[14], banditStabImage[15]);\n                banditAnimDownIdle = new Animation(7, banditIdleImage[0], banditIdleImage[1]);\n                banditAnimUpIdle = new Animation(7, banditIdleImage[2], banditIdleImage[3]);\n                banditAnimRightIdle = new Animation(7, banditIdleImage[4], banditIdleImage[5]);\n                banditAnimLeftIdle = new Animation(7, banditIdleImage[6], banditIdleImage[7]);\n            }\n        }\n    }\n\n    public void tick() {\n        if (dying) {\n            velX = 0;\n            velY = 0;\n            \n            if(this.type.equals(\"Zombie\")){\n                if(!dead) { game.gainScore(ZOMBIE_SCORE + ((game.getWave() - 1) * 100)); dead = true;}\n                switch(direction) {\n                    case \"up\":    zombieAnimUpDeath.runAnimation();    break;\n                    case \"down\":  zombieAnimDownDeath.runAnimation();  break;\n                    case \"right\": zombieAnimRightDeath.runAnimation(); break;\n                    case \"left\":  zombieAnimLeftDeath.runAnimation();  break;\n                }\n            }\n            else if(this.type.equals(\"Golem\")){\n                if(!dead) { game.gainScore(GOLEM_SCORE + ((game.getWave() - 1) * 100)); dead = true;}\n                switch(direction) {\n                    case \"up\":    golemAnimUpDeath.runAnimation();    break;\n                    case \"down\":  golemAnimDownDeath.runAnimation();  break;\n                    case \"right\": golemAnimRightDeath.runAnimation(); break;\n                    case \"left\":  golemAnimLeftDeath.runAnimation();  break;\n                }\n            }\n            else if(this.type.equals(\"Shadow\")){\n                if(!dead) { game.gainScore(SHADOW_SCORE + ((game.getWave() - 1) * 100)); dead = true;}\n                switch(direction) {\n                    case \"up\":    shadowAnimUpDeath.runAnimation();    break;\n                    case \"down\":  shadowAnimDownDeath.runAnimation();  break;\n                    case \"right\": shadowAnimRightDeath.runAnimation(); break;\n                    case \"left\":  shadowAnimLeftDeath.runAnimation();  break;\n                }\n            }\n            else{ // Bandit\n                if(!dead && !dropGranade) { game.gainScore(BANDIT_SCORE + ((game.getWave() - 1) * 100)); dead = true;}\n                switch(direction) {\n                    case \"up\":    banditAnimUpDeath.runAnimation();    break;\n                    case \"down\":  banditAnimDownDeath.runAnimation();  break;\n                    case \"right\": banditAnimRightDeath.runAnimation(); break;\n                    case \"left\":  banditAnimLeftDeath.runAnimation();  break;\n                }\n            }\n    \n            deathFrameCounter++;\n            if (deathFrameCounter >= 40) {\n                if(this.type.equals(\"Bandit\")){\n                    dropGranade = true;\n                    granadeExplosionTimeCounter++;\n                    if(granadeExplosionTimeCounter > granadeExplosionTime){\n                        handler.addObject(new Explosion(\n                            (int)x + BANDIT_CENTER_X, \n                            (int)y + BANDIT_CENTER_Y, \n                            ID.Explosion, \n                            game.getGRANADE_RADIUS(),  \n                            handler,\n                            game,\n                            game.getGRANADE_DAMAGE()\n                        ));\n                        handler.removeObject(this);\n                    }\n                }\n                else{\n                    handler.removeObject(this);\n                }\n            }\n            return; \n        }\n        \n        if(this.type.equals(\"Zombie\")){\n            centerX = (int)x + ZOMBIE_CENTER_X;\n            centerY = (int)y + ZOMBIE_CENTER_Y;\n        }\n        else if(this.type.equals(\"Golem\")){\n            centerX = (int)x + GOLEM_CENTER_X;\n            centerY = (int)y + GOLEM_CENTER_Y;\n        }\n        else if(this.type.equals(\"Shadow\")){\n            centerX = (int)x + SHADOW_CENTER_X;\n            centerY = (int)y + SHADOW_CENTER_Y;\n        }\n        else{ // Bandit\n            centerX = (int)x + BANDIT_CENTER_X;\n            centerY = (int)y + BANDIT_CENTER_Y;\n        }\n\n        if (this.type.equals(\"Shadow\")) {\n            if (jumpAttacking) {\n                velX = 0;\n                velY = 0;\n            } else {\n                chasePlayer();\n            }\n        }else if(this.type.equals(\"Bandit\")){\n            if(getDistance() < BANDIT_CHASING_DISTANCE){\n                velX = 0;\n                velY = 0;\n                if(!attacking){\n                    shoot();\n                }\n            }\n            else{\n                chasePlayer();\n            }\n        }else {\n            chasePlayer();\n        }   \n    \n        float oldX = x;\n        float oldY = y;\n    \n        float tempX = x + velX;\n        x = tempX;\n        if (collides()) {\n            x = oldX;\n        }\n    \n        float tempY = y + velY;\n        y = tempY;\n        if (collides()) {\n            y = oldY;\n        }\n    \n        gotShot();\n    \n        if(!attacking){\n            updateDirection();\n        }\n\n        if (attacking && !isContactBoundWithPlayer()) {\n            holster(); \n        }\n\n        if (wasHit) {\n            if(!effectChosen) { selectedBloodEffect = ThreadLocalRandom.current().nextInt(1, 10); effectChosen = true; }\n            switch (selectedBloodEffect) {\n                case 1: bloodEffect1.runAnimation(); break;\n                case 2: bloodEffect2.runAnimation(); break;\n                case 3: bloodEffect3.runAnimation(); break;\n                case 4: bloodEffect4.runAnimation(); break;\n                case 5: bloodEffect5.runAnimation(); break;\n                case 6: bloodEffect6.runAnimation(); break;\n                case 7: bloodEffect7.runAnimation(); break;\n                case 8: bloodEffect8.runAnimation(); break;\n                case 9: bloodEffect9.runAnimation(); break;\n            }\n            \n            bloodEffectCounter++;\n            if(bloodEffectCounter >= BLOOD_EFFECT_DURATION) {\n                wasHit = false;\n                bloodEffectCounter = 0;\n                effectChosen = false;\n            }\n        }\n        \n        if (HP <= 0 && !dying) {\n            dying = true;\n            velX = 0;\n            velY = 0;\n            game.enemyKilled();\n            int r = ThreadLocalRandom.current().nextInt(0, 101);\n            if(r >= (100 - game.getMAJOR_HEALTH_CRATE_DROP_CHANCE())){\n                r = ThreadLocalRandom.current().nextInt(0, 101);\n                int dropX = ThreadLocalRandom.current().nextInt(-10, 11);\n                int dropY = ThreadLocalRandom.current().nextInt(-10, 11);\n                handler.addObject(new Crate(x+dropX, y+dropY, ID.Crate, \"Major Health\", game));\n            }\n            r = ThreadLocalRandom.current().nextInt(0, 101);\n            if(r >= (100 - game.getMINOR_HEALTH_CRATE_DROP_CHANCE())){\n                int dropX = ThreadLocalRandom.current().nextInt(-10, 11);\n                int dropY = ThreadLocalRandom.current().nextInt(-10, 11);\n                handler.addObject(new Crate(x+dropX, y+dropY, ID.Crate, \"Minor Health\", game));\n            }\n            r = ThreadLocalRandom.current().nextInt(0, 101);\n            if(game.getWave() > game.getASSAULT_RIFLE_FIRST_WAVE() && r >= (100 - game.getRIFLE_AMMO_CRATE_DROP_CHANCE())){\n                int dropX = ThreadLocalRandom.current().nextInt(-10, 11);\n                int dropY = ThreadLocalRandom.current().nextInt(-10, 11);\n                handler.addObject(new Crate(x+dropX, y+dropY, ID.Crate, \"Rifle Ammo\", game));\n            }\n            r = ThreadLocalRandom.current().nextInt(0, 101);\n            if(game.getWave() > game.getSHOTGUN_FIRST_WAVE() && r >= (100 - game.getSHOTGUN_AMMO_CRATE_DROP_CHANCE())){\n                int dropX = ThreadLocalRandom.current().nextInt(-10, 11);\n                int dropY = ThreadLocalRandom.current().nextInt(-10, 11);\n                handler.addObject(new Crate(x+dropX, y+dropY, ID.Crate, \"Shotgun Ammo\", game));\n            }\n            r = ThreadLocalRandom.current().nextInt(0, 101);\n            if(game.getWave() > game.getSNIPER_FIRST_WAVE() && r >= (100 - game.getSNIPER_AMMO_CRATE_DROP_CHANCE())){\n                int dropX = ThreadLocalRandom.current().nextInt(-10, 11);\n                int dropY = ThreadLocalRandom.current().nextInt(-10, 11);\n                handler.addObject(new Crate(x+dropX, y+dropY, ID.Crate, \"Sniper Ammo\", game));\n            }\n            r = ThreadLocalRandom.current().nextInt(0, 101);\n            if(game.getWave() > game.getROCKET_LAUNCHER_FIRST_WAVE() && r >= (100 - game.getROCKET_CRATE_DROP_CHANCE())){\n                int dropX = ThreadLocalRandom.current().nextInt(-10, 11);\n                int dropY = ThreadLocalRandom.current().nextInt(-10, 11);\n                handler.addObject(new Crate(x+dropX, y+dropY, ID.Crate, \"Rocket Ammo\", game));\n            }\n            return; \n        }\n\n        if(isCooldown){\n            cooldownCounter++;\n            if(cooldownCounter >= this.cooldownCounterSpecific){\n                cooldownCounter = 0;\n                isCooldown = false;\n            }\n        }\n\n        if(shootingCooldown){\n            shootingCooldownCounter++;\n            if(shootingCooldownCounter >= this.BANDIT_SHOOTING_COOLDOWN){\n                shootingCooldownCounter = 0;\n                shootingCooldown = false;\n            }\n        }\n\n        if(jumpAttackCooldown){\n            jumpAttackCooldownCounter++;\n            if(jumpAttackCooldownCounter >= this.SHADOW_JUMP_ATTACK_COOLDOWN){\n                jumpAttackCooldownCounter = 0;\n                jumpAttackCooldown = false;\n            }\n        }\n\n\n\n        if (!dying && attacking && !isCooldown && player != null) {\n            performAttack();\n        }\n    \n        if(this.type.equals(\"Zombie\")){\n            if(attacking){\n                switch(direction) {\n                    case \"up\":    zombieAnimUpAttack.runAnimation();    break;\n                    case \"down\":  zombieAnimDownAttack.runAnimation();  break;\n                    case \"right\": zombieAnimRightAttack.runAnimation(); break;\n                    case \"left\":  zombieAnimLeftAttack.runAnimation();  break;\n                }\n            }\n            else {\n                switch(direction) {\n                    case \"up\":    zombieAnimUpWalk.runAnimation();    break;\n                    case \"down\":  zombieAnimDownWalk.runAnimation();  break;\n                    case \"right\": zombieAnimRightWalk.runAnimation(); break;\n                    case \"left\":  zombieAnimLeftWalk.runAnimation();  break;\n                }\n            }\n        }\n        else if(this.type.equals(\"Golem\")){\n            if(attacking){\n                switch(direction) {\n                    case \"up\":    golemAnimUpAttack.runAnimation();    break;\n                    case \"down\":  golemAnimDownAttack.runAnimation();  break;\n                    case \"right\": golemAnimRightAttack.runAnimation(); break;\n                    case \"left\":  golemAnimLeftAttack.runAnimation();  break;\n                }\n            }\n            else {\n                switch(direction) {\n                    case \"up\":    golemAnimUpWalk.runAnimation();    break;\n                    case \"down\":  golemAnimDownWalk.runAnimation();  break;\n                    case \"right\": golemAnimRightWalk.runAnimation(); break;\n                    case \"left\":  golemAnimLeftWalk.runAnimation();  break;\n                }\n            }\n        }\n        else if(this.type.equals(\"Shadow\")){\n            if(jumpAttacking){\n                jumpAttackFrameCounter++;\n                switch(direction){\n                    case \"up\":    shadowAnimUpJumpAttack.runAnimation();    break;\n                    case \"down\":  shadowAnimDownJumpAttack.runAnimation();  break;\n                    case \"right\": shadowAnimRightJumpAttack.runAnimation(); break;\n                    case \"left\":  shadowAnimLeftJumpAttack.runAnimation();  break;\n                }\n                if (jumpAttackFrameCounter >= 56) {\n                    jumpAttacking = false;\n                    jumpAttackCooldown = true;\n                    jumpAttackFrameCounter = 0;\n                }\n            } else{\n                if(attacking){\n                    switch(direction) {\n                        case \"up\":    shadowAnimUpAttack.runAnimation();    break;\n                        case \"down\":  shadowAnimDownAttack.runAnimation();  break;\n                        case \"right\": shadowAnimRightAttack.runAnimation(); break;\n                        case \"left\":  shadowAnimLeftAttack.runAnimation();  break;\n                    }\n                }\n                else {\n                    switch(direction) {\n                        case \"up\":    shadowAnimUpWalk.runAnimation();    break;\n                        case \"down\":  shadowAnimDownWalk.runAnimation();  break;\n                        case \"right\": shadowAnimRightWalk.runAnimation(); break;\n                        case \"left\":  shadowAnimLeftWalk.runAnimation();  break;\n                    }\n                }\n            }\n        }\n        else{ // Bandit\n            if(attacking){\n                switch(direction) {\n                    case \"up\":    banditAnimUpStab.runAnimation();    break;\n                    case \"down\":  banditAnimDownStab.runAnimation();  break;\n                    case \"right\": banditAnimRightStab.runAnimation(); break;\n                    case \"left\":  banditAnimLeftStab.runAnimation();  break;\n                }\n            }\n            else if(shooting){\n                shootingFrameCounter++;\n                switch(direction) {\n                    case \"up\":    banditAnimUpShoot.runAnimation();    break;\n                    case \"down\":  banditAnimDownShoot.runAnimation();  break;\n                    case \"right\": banditAnimRightShoot.runAnimation(); break;\n                    case \"left\":  banditAnimLeftShoot.runAnimation();  break;\n                }\n                if (shootingFrameCounter >= 40) {\n                    shooting = false;\n                    shootingCooldown = true;\n                    shootingFrameCounter = 0;\n                }\n            }\n            else if(velX != 0 || velY != 0){\n                switch(direction) {\n                    case \"up\":    banditAnimUpWalk.runAnimation();    break;\n                    case \"down\":  banditAnimDownWalk.runAnimation();  break;\n                    case \"right\": banditAnimRightWalk.runAnimation(); break;\n                    case \"left\":  banditAnimLeftWalk.runAnimation();  break;\n                }\n            }\n            else{\n                switch(direction) {\n                    case \"up\":    banditAnimUpIdle.runAnimation();    break;\n                    case \"down\":  banditAnimDownIdle.runAnimation();  break;\n                    case \"right\": banditAnimRightIdle.runAnimation(); break;\n                    case \"left\":  banditAnimLeftIdle.runAnimation();  break;\n                }\n            }\n        }\n    }\n    \n    private float getDeltaX(){\n        if(player.lookingDirection.equals(\"up\")){\n            return player.getX()+17 - centerX;\n        }else if(player.lookingDirection.equals(\"down\")){\n            return player.getX()+12 - centerX;\n        }else if(player.lookingDirection.equals(\"right\")){\n            return player.getX()+13 - centerX;\n        }else{ // left\n            return player.getX()+16 - centerX;\n        }\n    }\n\n    private float getDeltaY(){\n        if(player.lookingDirection.equals(\"up\")){\n            return player.getY()+26 - centerY;\n        }else if(player.lookingDirection.equals(\"down\")){\n            return player.getY()+20 - centerY;\n        }else if(player.lookingDirection.equals(\"right\")){\n            return player.getY()+24 - centerY;\n        }else{ // left\n            return player.getY()+21 - centerY;\n        }\n    }\n\n    private float getDistance(){\n        return (float) Math.sqrt(getDeltaX() * getDeltaX() + getDeltaY() * getDeltaY());\n    }\n\n    private void chasePlayer() {\n        float distance = getDistance();\n\n        if (distance > 0) {\n            velX = (getDeltaX() / distance) * this.speed;\n            velY = (getDeltaY() / distance) * this.speed;\n        } else {\n            velX = 0;\n            velY = 0;\n        }\n\n        if(distance >= SHADOW_JUMP_ATTACK_DISTANCE){\n            jumpAttackPerformed = false;\n        }\n\n        if(this.type.equals(\"Shadow\") && !jumpAttackPerformed && !jumpAttackCooldown){\n            if(distance < SHADOW_JUMP_ATTACK_DISTANCE){\n                shadowJumpAttack();\n                jumpAttackPerformed = true;\n            }\n        }\n    }\n\n    private boolean collides() {\n        if (dying) return false;\n    \n        for (GameObject tempObject : handler.object) {\n            if (tempObject.getID() == ID.Block) {\n                if (getBounds().intersects(tempObject.getBounds())) {\n                    return true;\n                }\n            }\n    \n            if (tempObject.getID() == ID.Player) {\n                Player temp = (Player) tempObject;\n                if (getBounds().intersects(temp.getBounds())) {\n                    return true;\n                }\n            }\n    \n            if (tempObject.getID() == ID.Enemy) {\n                Enemy other = (Enemy) tempObject;\n                if (other != this && !other.dying && contactBoundWithComrade().intersects(other.contactBoundWithComrade())) {\n                    avoidEnemyCollision(other);\n                    return true;\n                }\n            }\n        }     \n        return false;\n    }\n\n    private void avoidEnemyCollision(Enemy other) {\n        if(Math.abs(player.getX() - x) < 5){\n            y += (Math.random() > 0.5 ? 1 : -1);\n        }\n        else{\n            x += (Math.random() > 0.5 ? 1 : -1);\n        }\n    }\n\n    private void gotShot() {\n        for (int i = handler.object.size() - 1; i >= 0; i--){\n            GameObject tempObject = handler.object.get(i);\n            if (tempObject.getID() == ID.Bullet && ((Bullet)tempObject).target.equals(\"Enemy\")) { \n                if (getBounds().intersects(tempObject.getBounds())) {\n                    effectChosen = false;\n                    wasHit = true;\n                    Bullet temp = (Bullet) tempObject;\n                    if (tempObject.isActive()){\n                        if (temp.getBulletType().equals(\"9mm\")){\n                            HP -= game.getPISTOL_DAMAGE();\n                        }\n                        else if (temp.getBulletType().equals(\"7.62\")){\n                            HP -= game.getASSAULT_RIFLE_DAMAGE();\n                        }\n                        else if (temp.getBulletType().equals(\"12gauge\")){\n                            HP -= game.getSHOTGUN_DAMAGE();\n                        }\n                        else if (temp.getBulletType().equals(\"50cal.\")) { \n                            switch (temp.getHitCount()){\n                                case 0: HP -= game.getSNIPER_DAMAGE(); break;\n                                case 1: HP -= (game.getSNIPER_DAMAGE() - 40); break;\n                                case 2: HP -= (game.getSNIPER_DAMAGE() - (40 * 2)); break;\n                                case 3: HP -= (game.getSNIPER_DAMAGE() - (40 * 3)); break;\n                                case 4: HP -= (game.getSNIPER_DAMAGE() - (40 * 4)); break;\n                                case 5: HP -= 20; tempObject.setActive(false); break;\n                            }\n                            temp.setHitCount(temp.getHitCount() + 1);\n                        }\n                        else { // Rocket\n                            temp.explode(); \n                            return; \n                        }\n                    }\n                    if (!temp.getBulletType().equals(\"50cal.\")) {\n                        handler.removeObject(tempObject);\n                        tempObject.setActive(false);\n                    }\n                    break; \n                }\n            }\n        }\n    }\n\n    private void updateDirection() {\n        float dx = player.getX() - x;\n        float dy = player.getY() - y;\n    \n        if (Math.abs(dx) > Math.abs(dy)) {\n            if (dx > 0) {\n                direction = \"right\";\n            } else {\n                direction = \"left\";\n            }\n        } else {\n            if (dy > 0) {\n                direction = \"down\";\n            } else {\n                direction = \"up\";\n            }\n        }\n    }\n\n    public void render(Graphics g) {\n        \n        if (HP <= 0) {\n            if(this.type.equals(\"Zombie\")){\n                switch(direction) {\n                    case \"up\":    zombieAnimUpDeath.drawAnimation(g, (int)x, (int)y, 0);    break;\n                    case \"down\":  zombieAnimDownDeath.drawAnimation(g, (int)x, (int)y, 0);  break;\n                    case \"right\": zombieAnimRightDeath.drawAnimation(g, (int)x, (int)y, 0); break;\n                    case \"left\":  zombieAnimLeftDeath.drawAnimation(g, (int)x, (int)y, 0);  break;\n                }\n            }\n            else if(this.type.equals(\"Golem\")){\n                switch(direction) {\n                    case \"up\":    golemAnimUpDeath.drawAnimation(g, (int)x, (int)y, 0);    break;\n                    case \"down\":  golemAnimDownDeath.drawAnimation(g, (int)x, (int)y, 0);  break;\n                    case \"right\": golemAnimRightDeath.drawAnimation(g, (int)x, (int)y, 0); break;\n                    case \"left\":  golemAnimLeftDeath.drawAnimation(g, (int)x, (int)y, 0);  break;\n                }\n            }\n            else if(this.type.equals(\"Shadow\")){\n                switch(direction) {\n                    case \"up\":    shadowAnimUpDeath.drawAnimation(g, (int)x, (int)y, 0);    break;\n                    case \"down\":  shadowAnimDownDeath.drawAnimation(g, (int)x, (int)y, 0);  break;\n                    case \"right\": shadowAnimRightDeath.drawAnimation(g, (int)x, (int)y, 0); break;\n                    case \"left\":  shadowAnimLeftDeath.drawAnimation(g, (int)x, (int)y, 0);  break;\n                }\n            }\n            else{ // Bandit\n                if(!dropGranade){\n                    switch(direction) {\n                        case \"up\":    banditAnimUpDeath.drawAnimation(g, (int)x, (int)y, 0);    break;\n                        case \"down\":  banditAnimDownDeath.drawAnimation(g, (int)x, (int)y, 0);  break;\n                        case \"right\": banditAnimRightDeath.drawAnimation(g, (int)x, (int)y, 0); break;\n                        case \"left\":  banditAnimLeftDeath.drawAnimation(g, (int)x, (int)y, 0);  break;\n                    }\n                }\n            }\n        }\n        else{\n            if(this.type.equals(\"Zombie\")){\n                if(attacking){\n                    switch(direction) {\n                        case \"up\":    zombieAnimUpAttack.drawAnimation(g, (int)x, (int)y, 0);    break;\n                        case \"down\":  zombieAnimDownAttack.drawAnimation(g, (int)x, (int)y, 0);  break;\n                        case \"right\": zombieAnimRightAttack.drawAnimation(g, (int)x, (int)y, 0); break;\n                        case \"left\":  zombieAnimLeftAttack.drawAnimation(g, (int)x, (int)y, 0);  break;\n                    }\n                }\n                else {\n                    switch(direction) {\n                        case \"up\":    zombieAnimUpWalk.drawAnimation(g, (int)x, (int)y, 0);    break;\n                        case \"down\":  zombieAnimDownWalk.drawAnimation(g, (int)x, (int)y, 0);  break;\n                        case \"right\": zombieAnimRightWalk.drawAnimation(g, (int)x, (int)y, 0); break;\n                        case \"left\":  zombieAnimLeftWalk.drawAnimation(g, (int)x, (int)y, 0);  break;\n                    }\n                }\n            }\n            else if(this.type.equals(\"Golem\")){\n                if(attacking){\n                    switch(direction) {\n                        case \"up\":    golemAnimUpAttack.drawAnimation(g, (int)x, (int)y, 0);    break;\n                        case \"down\":  golemAnimDownAttack.drawAnimation(g, (int)x, (int)y, 0);  break;\n                        case \"right\": golemAnimRightAttack.drawAnimation(g, (int)x, (int)y, 0); break;\n                        case \"left\":  golemAnimLeftAttack.drawAnimation(g, (int)x, (int)y, 0);  break;\n                    }\n                }\n                else {\n                    switch(direction) {\n                        case \"up\":    golemAnimUpWalk.drawAnimation(g, (int)x, (int)y, 0);    break;\n                        case \"down\":  golemAnimDownWalk.drawAnimation(g, (int)x, (int)y, 0);  break;\n                        case \"right\": golemAnimRightWalk.drawAnimation(g, (int)x, (int)y, 0); break;\n                        case \"left\":  golemAnimLeftWalk.drawAnimation(g, (int)x, (int)y, 0);  break;\n                    }\n                }\n            }\n            else if(this.type.equals(\"Shadow\")){\n                if(jumpAttacking) {\n                    switch(direction) {\n                        case \"up\":    shadowAnimUpJumpAttack.drawAnimation(g, (int)x, (int)y, 0);    break;\n                        case \"down\":  shadowAnimDownJumpAttack.drawAnimation(g, (int)x, (int)y, 0);  break;\n                        case \"right\": shadowAnimRightJumpAttack.drawAnimation(g, (int)x, (int)y, 0); break;\n                        case \"left\":  shadowAnimLeftJumpAttack.drawAnimation(g, (int)x, (int)y, 0);  break;\n                    }\n                } else {\n                    if(attacking){\n                        switch(direction) {\n                            case \"up\":    shadowAnimUpAttack.drawAnimation(g, (int)x, (int)y, 0);    break;\n                            case \"down\":  shadowAnimDownAttack.drawAnimation(g, (int)x, (int)y, 0);  break;\n                            case \"right\": shadowAnimRightAttack.drawAnimation(g, (int)x, (int)y, 0); break;\n                            case \"left\":  shadowAnimLeftAttack.drawAnimation(g, (int)x, (int)y, 0);  break;\n                        }\n                    }\n                    else {\n                        switch(direction) {\n                            case \"up\":    shadowAnimUpWalk.drawAnimation(g, (int)x, (int)y, 0);    break;\n                            case \"down\":  shadowAnimDownWalk.drawAnimation(g, (int)x, (int)y, 0);  break;\n                            case \"right\": shadowAnimRightWalk.drawAnimation(g, (int)x, (int)y, 0); break;\n                            case \"left\":  shadowAnimLeftWalk.drawAnimation(g, (int)x, (int)y, 0);  break;\n                        }\n                    }\n                }\n            }\n            else{ // Bandit\n                if(attacking){\n                    switch(direction) {\n                        case \"up\":    banditAnimUpStab.drawAnimation(g, (int)x, (int)y, 0);    break;\n                        case \"down\":  banditAnimDownStab.drawAnimation(g, (int)x, (int)y, 0);  break;\n                        case \"right\": banditAnimRightStab.drawAnimation(g, (int)x, (int)y, 0); break;\n                        case \"left\":  banditAnimLeftStab.drawAnimation(g, (int)x, (int)y, 0);  break;\n                    }\n                }\n                else if(shooting){\n                    switch(direction) {\n                        case \"up\":    banditAnimUpShoot.drawAnimation(g, (int)x, (int)y, 0);    break;\n                        case \"down\":  banditAnimDownShoot.drawAnimation(g, (int)x, (int)y, 0);  break;\n                        case \"right\": banditAnimRightShoot.drawAnimation(g, (int)x, (int)y, 0); break;\n                        case \"left\":  banditAnimLeftShoot.drawAnimation(g, (int)x, (int)y, 0);  break;\n                    }\n                }\n                else if(velX != 0 || velY != 0){\n                    switch(direction) {\n                        case \"up\":    banditAnimUpWalk.drawAnimation(g, (int)x, (int)y, 0);    break;\n                        case \"down\":  banditAnimDownWalk.drawAnimation(g, (int)x, (int)y, 0);  break;\n                        case \"right\": banditAnimRightWalk.drawAnimation(g, (int)x, (int)y, 0); break;\n                        case \"left\":  banditAnimLeftWalk.drawAnimation(g, (int)x, (int)y, 0);  break;\n                    }\n                }\n                else{\n                    switch(direction) {\n                        case \"up\":    banditAnimUpIdle.drawAnimation(g, (int)x, (int)y, 0);    break;\n                        case \"down\":  banditAnimDownIdle.drawAnimation(g, (int)x, (int)y, 0);  break;\n                        case \"right\": banditAnimRightIdle.drawAnimation(g, (int)x, (int)y, 0); break;\n                        case \"left\":  banditAnimLeftIdle.drawAnimation(g, (int)x, (int)y, 0);  break;\n                    }\n                }\n            }\n        }\n\n        if(wasHit){\n            switch (selectedBloodEffect) {\n                case 1: bloodEffect1.drawAnimation(g, (int)x+10, (int)y+10, 0);  break;\n                case 2: bloodEffect2.drawAnimation(g, (int)x+10, (int)y+10, 0);  break;\n                case 3: bloodEffect3.drawAnimation(g, (int)x+10, (int)y+10, 0);  break;\n                case 4: bloodEffect4.drawAnimation(g, (int)x+10, (int)y+10, 0);  break;\n                case 5: bloodEffect5.drawAnimation(g, (int)x+10, (int)y+10, 0);  break;\n                case 6: bloodEffect6.drawAnimation(g, (int)x+10, (int)y+10, 0);  break;\n                case 7: bloodEffect7.drawAnimation(g, (int)x+10, (int)y+10, 0);  break;\n                case 8: bloodEffect8.drawAnimation(g, (int)x+10, (int)y+10, 0);  break;\n                case 9: bloodEffect9.drawAnimation(g, (int)x+10, (int)y+10, 0);  break;\n            }\n        }\n\n        if(dropGranade){\n            if(granadeExplosionTimeCounter < granadeExplosionTime){\n                g.drawImage(granade, (int)x + 6, (int)y + 5, null);\n            }\n        }\n\n        if(game.isDebug()) {\n\n            if(attacking){\n                g.setColor(Color.red);\n            }else{\n                g.setColor(Color.green);\n            }\n            Rectangle contactBoundWithPlayer = contactBoundWithPlayer();\n            g.drawRect(contactBoundWithPlayer.x, contactBoundWithPlayer.y, contactBoundWithPlayer.width, contactBoundWithPlayer.height);\n            \n            g.setColor(Color.orange);\n            Rectangle bound = getBounds();\n            g.drawRect(bound.x, bound.y, bound.width, bound.height);\n\n            g.setColor(Color.blue);\n            Rectangle contactRect = contactBoundWithComrade();\n            g.drawRect(contactRect.x, contactRect.y, contactRect.width, contactRect.height);\n\n            g.setColor(Color.magenta);\n            g.drawRect(centerX, centerY, 2, 2);\n\n        }\n    }\n\n    public void takeDamage(int damage) {\n        HP -= damage;\n    }\n\n    public Rectangle getBounds() {\n        if(this.type.equals(\"Zombie\")){\n            return new Rectangle((int)x + 6, (int)y + 8, 18, 19);\n        }\n        else if(this.type.equals(\"Golem\")){\n            return new Rectangle((int)x + 15, (int)y + 12, 34, 45);\n        }\n        else if(this.type.equals(\"Shadow\")){\n            return new Rectangle((int)x + 14, (int)y + 8, 20, 32);\n        }\n        else {\n            return new Rectangle((int)x + 6, (int)y + 8, 18, 19);\n        }\n    }\n\n    public Rectangle contactBoundWithPlayer() {\n        if(this.type.equals(\"Zombie\")){\n            return new Rectangle((int)x + 2, (int)y + 4, 26, 26);\n        }\n        else if(this.type.equals(\"Golem\")){\n            return new Rectangle((int)x + 8, (int)y + 6, 47, 57);\n        }\n        else if(this.type.equals(\"Shadow\")){\n            return new Rectangle((int)x + 8, (int)y + 2, 32, 44);\n        }\n        else {\n            return new Rectangle((int)x + 2, (int)y + 4, 26, 26);\n        }\n        \n    }\n\n    public boolean isContactBoundWithPlayer() {\n        if(player.getBounds().intersects(this.contactBoundWithPlayer())){\n            return true;\n        }\n        return false;\n    }\n\n    public Rectangle contactBoundWithComrade() {\n        if(this.type.equals(\"Zombie\")){\n            return new Rectangle((int)x + 16 - 5, (int)y + 16 - 5, 10, 10);\n        }\n        else if(this.type.equals(\"Golem\")){\n            return new Rectangle((int)x + 24, (int)y + 20, 16, 30);\n        }\n        else if(this.type.equals(\"Shadow\")){\n            return new Rectangle((int)x + 19, (int)y + 15, 10, 20);\n        }\n        else {\n            return new Rectangle((int)x + 16 - 5, (int)y + 16 - 5, 10, 10);\n        }\n    }\n\n    public void attack(){\n        if (!dying) {\n            this.attacking = true;\n        }\n    }\n\n    public void holster(){\n        this.attacking = false;\n    }\n\n    public void performAttack(){\n        if (!dying && !isCooldown && attacking && player != null) {\n            player.takeDamage(this.damage);\n            isCooldown = true;\n            holster(); \n        }\n    }\n\n    public void shadowJumpAttack() {\n        if (dying || jumpAttacking || jumpAttackCooldown) { return; }\n\n        jumpAttacking = true;\n        jumpAttackPerformed = true;\n        jumpAttackCooldown = true;\n    \n        float playerCenterX = player.getX() + player.getBounds().width / 2f;\n        float playerCenterY = player.getY() + player.getBounds().height / 2f;\n    \n        this.x = playerCenterX - (this.getBounds().width / 2f);\n        this.y = playerCenterY - (this.getBounds().height / 2f);\n    \n        player.takeDamage(SHADOW_JUMP_ATTACK_DAMAGE);\n    }\n\n    public void shoot(){\n        if (dying || shooting || shootingCooldown) { return; }\n        \n        handler.addObject(new Bullet(\n                (int)x + BANDIT_CENTER_X,\n                (int)y + BANDIT_CENTER_Y,\n                ID.Bullet,\n                handler,\n                player.centerX,\n                player.centerY,\n                \"9mm\",\n                game,\n                \"Player\"\n            ));\n\n        shootingCooldown = true;\n        shooting = true;\n    }\n\n    public boolean isDying(){\n        return dying;\n    }\n\n    public static int getBANDIT_SHOOTING_DAMAGE(){\n        return BANDIT_SHOOTING_DAMAGE;\n    }\n\n    private BufferedImage scaleImage(BufferedImage original, int width, int height) {\n        BufferedImage scaled = new BufferedImage(width, height, original.getType());\n        Graphics2D g2d = scaled.createGraphics();\n        g2d.drawImage(original, 0, 0, width, height, null);\n        g2d.dispose();\n        return scaled;\n    }\n}\n",
      "MainMenu.java": "import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.FontFormatException;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class MainMenu {\n    \n    private Game game;\n    BufferedImage playImage;\n    BufferedImage quitImage;\n    BufferedImage loadImage;\n    public Rectangle playButton;\n    public Rectangle quitButton;\n    public Rectangle loadButton;\n    private int WIDTH; \n    private int HEIGHT;\n    private Font customFont;\n    \n    public MainMenu(Game game) {\n        this.game = game;\n        this.WIDTH = (int) (game.ORIGINAL_WIDTH * game.scale); // 1000 * 1.7\n        this.HEIGHT = (int) (game.ORIGINAL_HEIGHT * game.scale); // 563 * 1.7\n\n        try {\n            customFont = Font.createFont(Font.TRUETYPE_FONT, new File(\"./Resources/UI/Font/cyberpunkFont.otf\")).deriveFont(50f);\n            GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n            ge.registerFont(customFont);\n        } catch (FontFormatException | IOException e) {\n            e.printStackTrace();\n            customFont = new Font(\"Arial\", Font.BOLD, 30);\n        }\n        \n        playButton = new Rectangle(WIDTH/2 - 55, (int)(150 * game.scale) + 200, 100, 50); \n        loadButton = new Rectangle(WIDTH/2 - 55, (int)(250 * game.scale) + 125, 100, 50); \n        quitButton = new Rectangle(WIDTH/2 - 55, (int)(350 * game.scale) + 50, 100, 50); \n        BufferedImageLoader loader = new BufferedImageLoader();\n        playImage = scaleImage(loader.loadImage(\"./Resources/UI/Menu/ColoredLargeButtons/Play.png\"), 100 ,50);\n        quitImage = scaleImage(loader.loadImage(\"./Resources/UI/Menu/ColoredLargeButtons/Quit.png\"), 100 ,50);\n        loadImage = scaleImage(loader.loadImage(\"./Resources/UI/Menu/ColoredLargeButtons/Load.png\"), 100 ,50);\n    }\n\n    public void render(Graphics g) {\n        Graphics2D g2d = (Graphics2D) g;\n        \n        // Background\n        g.setColor(Color.BLACK);\n        g.fillRect(0, 0, WIDTH, HEIGHT);\n        \n        // Title\n        g.setColor(Color.magenta);\n        g.setFont(customFont);\n        g.drawString(\"BULLET CARNAGE\", WIDTH/2 - 240, 250);\n        \n        // Play Button\n        g.drawImage(playImage, playButton.x, playButton.y, game); \n        \n        // Quit Button\n        g.drawImage(quitImage, quitButton.x, quitButton.y, game); \n\n        // Load Button\n        g.drawImage(loadImage, loadButton.x, loadButton.y, game); \n    }\n    \n    private BufferedImage scaleImage(BufferedImage original, int width, int height) {\n        BufferedImage scaled = new BufferedImage(width, height, original.getType());\n        Graphics2D g2d = scaled.createGraphics();\n        g2d.drawImage(original, 0, 0, width, height, null);\n        g2d.dispose();\n        return scaled;\n    }\n}\n",
      "Handler.java": "import java.awt.Graphics;\nimport java.util.LinkedList;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic class Handler {\n    \n    public final CopyOnWriteArrayList<GameObject> object = new CopyOnWriteArrayList<>();\n    private LinkedList<GameObject> objectsToAdd = new LinkedList<>();\n    private LinkedList<GameObject> objectsToRemove = new LinkedList<>();\n\n    private boolean up = false, down = false, right = false, left = false; \n    private boolean isShooting = false;\n    private boolean isAutoShooting = false;\n    private volatile int currentMX; \n    private volatile int currentMY;\n    private volatile int currentScreenMX; \n    private volatile int currentScreenMY;\n\n    public void tick() {\n        synchronized(this) {\n            processAddsAndRemoves();\n        }\n\n        for (GameObject tempObject : object) {\n            tempObject.tick();\n        }\n    }\n\n    public void render(Graphics g) {\n        for (GameObject tempObject : object) {\n            tempObject.render(g);\n        }\n    }\n\n    public synchronized void addObject(GameObject object) {\n        this.objectsToAdd.add(object);\n    }\n\n    public synchronized void removeObject(GameObject object) {\n        this.objectsToRemove.add(object);\n    }\n\n    private synchronized void processAddsAndRemoves() {\n        object.addAllAbsent(objectsToAdd);\n        objectsToAdd.clear();\n\n        object.removeAll(objectsToRemove);\n        objectsToRemove.clear();\n    }\n\n    public boolean isUp() { return up; }\n    public boolean isDown() { return down; }\n    public boolean isRight() { return right; }\n    public boolean isLeft() { return left; }\n    public boolean isShooting() { return isShooting; }\n    public boolean isAutoShooting() { return isAutoShooting; }\n    public int getCurrentMX() { return currentMX; }\n    public int getCurrentMY() { return currentMY; }\n    public void setUp(boolean up) { this.up = up;}\n    public void setDown(boolean down) { this.down = down; }\n    public void setRight(boolean right) { this.right = right; }\n    public void setLeft(boolean left) { this.left = left; }\n    public void setShooting(boolean isShooting) { this.isShooting = isShooting; }\n    public void setAutoShooting(boolean isAutoShooting) { this.isAutoShooting = isAutoShooting; }\n    public void setCurrentMX(int currentMX) { this.currentMX = currentMX; }\n    public void setCurrentMY(int currentMY) { this.currentMY = currentMY; }\n    public int getCurrentScreenMX() { return currentScreenMX; }\n    public int getCurrentScreenMY() { return currentScreenMY; }\n    public void setCurrentScreenMX(int currentScreenMX) { this.currentScreenMX = currentScreenMX; }\n    public void setCurrentScreenMY(int currentScreenMY) { this.currentScreenMY = currentScreenMY; }\n}",
      "Explosion.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Explosion extends GameObject {\n    private int radius;\n    private int damage;\n    private int currentFrame = 0;\n    private boolean hasDamagedPlayer = false;\n    private final int totalFrames = 35;\n    private Animation animation;\n    Handler handler;\n    Game game;\n\n    public Explosion(int x, int y, ID id, int radius, Handler handler, Game game, int damage) {\n        super(x, y, id);\n        this.radius = radius;\n        this.damage = damage;\n        this.handler = handler;\n        this.game = game;\n        BufferedImageLoader loader = new BufferedImageLoader();\n\n        BufferedImage[] sprites = new BufferedImage[7];\n        for (int i = 0; i < sprites.length; i++) {\n            BufferedImage original = loader.loadImage(\"./Resources/ExplosionAssets/Explosion_\" + (i + 1) + \".png\");\n            sprites[i] = scaleImage(original, radius * 2, radius * 2);\n        }\n\n        this.animation = new Animation(3, sprites[0], sprites[1], sprites[2], sprites[3], sprites[4], sprites[5], sprites[6]);\n    }\n\n    private BufferedImage scaleImage(BufferedImage original, int width, int height) {\n        BufferedImage scaled = new BufferedImage(width, height, original.getType());\n        Graphics2D g2d = scaled.createGraphics();\n        g2d.drawImage(original, 0, 0, width, height, null);\n        g2d.dispose();\n        return scaled;\n    }\n\n    public void tick() {\n        if (currentFrame < totalFrames) {\n            currentFrame++;\n            animation.runAnimation();\n        } else {\n            handler.removeObject(this);\n        }\n\n        for(GameObject obj : handler.object) {\n            if(obj.getID() == ID.Enemy) {\n                float dx = obj.getX() - x;\n                float dy = obj.getY() - y;\n                float distance = (float)Math.sqrt(dx*dx + dy*dy);\n                \n                if(distance < radius) { \n                    ((Enemy)obj).HP -= damage;\n                }\n            }\n            if(obj.getID() == ID.Player && !hasDamagedPlayer) {\n                float dx = obj.getX() - x;\n                float dy = obj.getY() - y;\n                float distance = (float)Math.sqrt(dx*dx + dy*dy);\n                if(distance < radius) { \n                    ((Player)obj).takeDamage(damage / 6); \n                    hasDamagedPlayer = true;\n                }\n            }\n        }\n    }\n\n    public void render(Graphics g) {\n        animation.drawAnimation(g, x - radius, y - radius, 0);\n\n        if(game.isDebug()){\n            g.setColor(Color.RED);\n            Rectangle bounds = getBounds();\n            g.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);\n        }\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle((int)x - radius, (int)y - radius, radius * 2, radius * 2);\n    }\n}",
      "Frame.java": "import java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.Point;\nimport java.awt.Toolkit;\nimport java.awt.image.BufferedImage;\n\nimport javax.swing.JFrame;\n\npublic class Frame {\n\n    private JFrame frame;  \n\n    public Frame(int width, int height, String title, Game game) {\n        frame = new JFrame(title);\n\n        frame.setPreferredSize(new Dimension(width, height));\n        frame.setMaximumSize(new Dimension(width, height));\n        frame.setMinimumSize(new Dimension(width, height));\n\n        frame.add(game);\n        frame.setResizable(false);  \n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setLocationRelativeTo(null);\n        \n        hideCursor(frame);\n        \n        frame.setVisible(true);\n    }\n\n    private void hideCursor(JFrame frame) {\n        BufferedImage cursorImg = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);\n        Cursor blankCursor = Toolkit.getDefaultToolkit().createCustomCursor(cursorImg, new Point(0, 0), \"blank cursor\");\n        frame.setCursor(blankCursor);\n    }\n    \n    public JFrame getFrame() { return frame; }\n}",
      "BufferedImageLoader.java": "import java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class BufferedImageLoader {\n    \n    private BufferedImage image;\n\n    public BufferedImage loadImage(String path) {\n        \n        try {\n            image = ImageIO.read(getClass().getResource(path));\n        } catch (IOException e) {\n            System.err.println(\"Error loading image: \" + path);\n            e.printStackTrace();\n        } catch (IllegalArgumentException e) {\n            System.err.println(\"Image not found: \" + path);\n            e.printStackTrace();\n        }\n        return image;\n    }\n}\n",
      "DeathMenu.java": "import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class DeathMenu {\n    private Game game;\n    public Rectangle mainMenuButton;\n    public Rectangle playAgainButton;\n    public Rectangle loadButton;\n    BufferedImage playAgainImage;\n    BufferedImage mainMenuImage;\n    BufferedImage loadImage;\n    BufferedImage deathIcon;\n    private int WIDTH; \n    private int HEIGHT;\n\n    public DeathMenu(Game game) {\n        this.game = game;\n        this.WIDTH = (int) (game.ORIGINAL_WIDTH * game.scale); // 1000 * 1.7\n        this.HEIGHT = (int) (game.ORIGINAL_HEIGHT * game.scale); // 563 * 1.7\n        playAgainButton = new Rectangle(WIDTH/2 - 185, (int)(150 * game.scale) + 300, 350, 50); \n        loadButton = new Rectangle(WIDTH/2 - 185, (int)(250 * game.scale) + 250, 350, 50); \n        mainMenuButton = new Rectangle(WIDTH/2 - 185, (int)(350 * game.scale) + 200, 350, 50); \n        BufferedImageLoader loader = new BufferedImageLoader();\n        playAgainImage = scaleImage(loader.loadImage(\"./Resources/UI/Menu/ColoredLargeButtons/NewGame.png\"), 350 ,50);\n        mainMenuImage = scaleImage(loader.loadImage(\"./Resources/UI/Menu/ColoredLargeButtons/Menu.png\"), 350 ,50);\n        loadImage = scaleImage(loader.loadImage(\"./Resources/UI/Menu/ColoredLargeButtons/Load.png\"), 350 ,50);\n        deathIcon = scaleImage(new SpriteSheet(loader.loadImage(\"./Resources/UI/Menu/FreeHorrorUi.png\")).grabImage(5, 3, 32, 32), 128 ,128);\n    }\n    \n    public void render(Graphics g) {\n        Graphics2D g2d = (Graphics2D) g;\n        \n        // BackGround\n        g.setColor(Color.BLACK);\n        g.fillRect(0, 0, WIDTH, HEIGHT);\n        \n        // Title\n        g.setColor(Color.RED);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 100));\n        g.drawString(\"YOU DIED\", WIDTH/2 - 250, 400);\n\n        // Main Menu Button\n        g.drawImage(mainMenuImage, mainMenuButton.x, mainMenuButton.y, game);\n\n        // Reset Button\n        g.drawImage(playAgainImage, playAgainButton.x, playAgainButton.y, game);\n\n        // Load Button\n        g.drawImage(loadImage, loadButton.x, loadButton.y, game);\n\n        // Death Icon\n        g.drawImage(deathIcon, WIDTH/2 - 88, 150, game);\n    }\n\n    private BufferedImage scaleImage(BufferedImage original, int width, int height) {\n        BufferedImage scaled = new BufferedImage(width, height, original.getType());\n        Graphics2D g2d = scaled.createGraphics();\n        g2d.drawImage(original, 0, 0, width, height, null);\n        g2d.dispose();\n        return scaled;\n    }\n}\n",
      "Game.java": "import java.awt.Canvas;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferStrategy;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.concurrent.ThreadLocalRandom;\n\n//******************************************************************\n//*------------------  [MAIN CLASS OF THE GAME]  ------------------*\n//******************************************************************\n\npublic class Game extends Canvas implements Runnable {\n    \n    // --------------------------------------------------------------------------------------------------------\n    // ********************************************* [ SETTINGS ] *********************************************\n    // --------------------------------------------------------------------------------------------------------\n\n    private boolean debug = false; // true = DEBUG MODE \n\n    public double scale = 1.7;\n\n    private final int WAVE_COOLDOWN = 10_000; // 10 Seconds\n\n    private final int ZOMBIE_FIRST_WAVE = 1;\n    private final int GOLEM_FIRST_WAVE = 9;\n    private final int SHADOW_FIRST_WAVE = 3;\n    private final int BANDIT_FIRST_WAVE = 6;\n\n    private final int ZOMBIE_INCREASE_AMOUNT_PER_WAVE = 2;\n    private final int GOLEM_INCREASE_AMOUNT_PER_WAVE = 1;\n    private final int SHADOW_INCREASE_AMOUNT_PER_WAVE = 1;\n    private final int BANDIT_INCREASE_AMOUNT_PER_WAVE = 1;\n\n    private final int ASSAULT_RIFLE_FIRST_WAVE = 1;\n    private final int SHOTGUN_FIRST_WAVE = 3;\n    private final int SNIPER_FIRST_WAVE = 5;\n    private final int ROCKET_LAUNCHER_FIRST_WAVE = 10;\n\n    private final int PISTOL_FIRE_RATE = 500; // 120 bullet per minute\n    private final int ASSAULT_RIFLE_FIRE_RATE = 100; // 600 bullet per minute\n    private final int SHOTGUN_FIRE_RATE = 1000; // 60 bullet per minute \n    private final int SNIPER_FIRE_RATE = 2000; // 30 bullet per minute\n    private final int ROCKET_LAUNCHER_FIRE_RATE = 0; // only one bullet per magazine\n    private final int MELEE_STRIKE_RATE = 600; // 100 strikes per minute\n    \n    private final int RIFLE_AMMO_DROP_CHANCE = 10;\n    private final int SHOTGUN_AMMO_DROP_CHANCE = 6;\n    private final int SNIPER_AMMO_DROP_CHANCE = 4;\n    private final int ROCKET_DROP_CHANCE = 2;\n    private final int MAJOR_HEALTH_CRATE_DROP_CHANCE = 3;\n    private final int MINOR_HEALTH_CRATE_DROP_CHANCE = 8;\n\n    private final int MAJOR_HEALTH = 80;\n    private final int MINOR_HEALTH = 40;\n    private final int PISTOL_DAMAGE = 35;\n    private final int ASSAULT_RIFLE_DAMAGE = 40;\n    private final int SHOTGUN_DAMAGE = 30;\n    private final int SNIPER_DAMAGE = 200;\n    private final int ROCKET_DAMAGE = 500;\n    private final int ROCKET_RADIUS = 65;\n    private final int GRANADE_DAMAGE = 300;\n    private final int GRANADE_RADIUS = 50;\n    private final int MELEE_DAMAGE = 100;\n\n    private final HashMap<String, Integer> reloadTimes = new HashMap<String, Integer>() {{\n        put(\"Pistol\", 900);       // 0.9 seconds\n        put(\"Assault Rifle\", 1800); // 1.8 seconds\n        put(\"Shotgun\", 2500);      // 2.5 seconds\n        put(\"Sniper\", 2000);       // 2 seconds\n        put(\"Rocket Launcher\", 6000); // 6 seconds\n    }};\n\n    // --------------------------------------------------------------------------------------------------------\n    // ********************************************************************************************************\n    // --------------------------------------------------------------------------------------------------------\n\n\n    private final double TICK_RATE = 60.0;\n    public final int ORIGINAL_WIDTH = 1000;\n    public final int ORIGINAL_HEIGHT = 563;\n    private final int TILE_SIZE = 64;\n    int[][] map = new int[TILE_SIZE][TILE_SIZE];\n    private boolean isRunning = false;\n    private Thread thread;\n    public MainMenu mainMenu;\n    public PauseMenu pauseMenu;\n    public DeathMenu deathMenu;\n    private Handler handler;\n    public int GAME_STATE = 4; // 0 = Main Menu, 1 = Started, 2 = Paused, 3 = Dead, 4 = Loading\n    private final int LOADING_TIME = 10_000; // 10 seconds\n    private long gameStartTime = System.currentTimeMillis(); \n    protected boolean restart = false;\n    private BufferedImage level = null;\n    private int wave = 0;\n    private boolean spawnersInitiated = true;\n    private boolean waveInProgress = false;\n    private int totalEnemy = 0;\n    private boolean waveFinished = true;\n    private long waveFinishTime = System.currentTimeMillis(); \n    private BufferedImage pistol = null;\n    private BufferedImage rifle = null;\n    private BufferedImage shotgun = null;\n    private BufferedImage sniper = null;\n    private BufferedImage rocketLauncher = null;\n    private SpriteSheet weaponesSs;\n    private SpriteSheet baseFloorSs;\n    private BufferedImage floor = null;\n    private Camera camera;\n    public int pistolAmmo = 12;\n    public int rifleAmmo = 30;\n    public int shotgunAmmo = 5;\n    public int sniperAmmo = 5;\n    public int rocketAmmo = 1;\n    public int rifleAmmoBackup = 60;\n    public int shotgunAmmoBackup = 10;\n    public int sniperAmmoBackup = 10;\n    public int rocketAmmoBackup = 2;\n    private Player player;\n    public int hp = 200;\n    private final int MAX_HEALTH = 200;\n    private String weapon = \"Pistol\";\n    private boolean reloading = false;\n    private long reloadStartTime = 0;\n    private String reloadWeapon;\n    private boolean meleeStrike = false;\n    private int score = 0;\n    BufferedImage cursor;\n    BufferedImage pistolCrosshair;\n    BufferedImage rifleCrosshair;\n    BufferedImage shotgunCrosshair;\n    BufferedImage sniperCrosshair;\n    BufferedImage rocketLauncherCrosshair;\n    private HashMap<String, Integer> checkpoint = new HashMap<String, Integer>() {{\n        put(\"wave\", 1);\n        put(\"hp\", 200);       \n        put(\"score\", 0); \n        put(\"pistolAmmo\", 12);     \n        put(\"rifleAmmo\", 30);       \n        put(\"shotgunAmmo\", 5); \n        put(\"sniperAmmo\", 5); \n        put(\"rocketAmmo\", 1);\n        put(\"rifleAmmoBackup\", 60); \n        put(\"shotgunAmmoBackup\", 10); \n        put(\"sniperAmmoBackup\", 10);\n        put(\"rocketAmmoBackup\", 2); \n        put(\"weapon\", 1); \n    }};\n\n\n    public Game() {\n        new Frame((int) (ORIGINAL_WIDTH * scale), (int) (ORIGINAL_HEIGHT * scale), \"Bullet Carnage\", this);\n        start();\n        \n        mainMenu = new MainMenu(this);\n        pauseMenu = new PauseMenu(this);\n        deathMenu = new DeathMenu(this);\n        \n        handler = new Handler();\n        camera = new Camera(0, 0);\n        \n        this.addKeyListener(new KeyInput(handler, this));\n        BufferedImageLoader loader = new BufferedImageLoader(); // Loading from level\n        level = loader.loadImage(\"./Resources/Levels/Level4.png\");\n        \n        //-------------------------------------------------------------------------------------------\n        // Sprites\n        baseFloorSs = new SpriteSheet(loader.loadImage(\"./Resources/levelAssets/Tileset/tileset_arranged.png\"));\n        floor = scaleImage(baseFloorSs.grabImage(1, 13, 16, 16), 32, 32);\n        cursor = scaleImage(loader.loadImage(\"./Resources/UI/Cursor/c5.png\"), 16, 16);\n        pistolCrosshair = scaleImage(loader.loadImage(\"./Resources/crosshairs/Crosses/Crosshair6.png\"), 20, 20);\n        rifleCrosshair = scaleImage(loader.loadImage(\"./Resources/crosshairs/Crosses/Crosshair7.png\"), 26, 26);\n        shotgunCrosshair = scaleImage(loader.loadImage(\"./Resources/crosshairs/Circle/Circle_Crosshair6.png\"), 35, 35);\n        sniperCrosshair = scaleImage(loader.loadImage(\"./Resources/crosshairs/Sniper/Sniper_Crosshair1.png\"), 96, 96);\n        rocketLauncherCrosshair = scaleImage(loader.loadImage(\"./Resources/crosshairs/Circle/Circle_Crosshair8.png\"), 32, 32);\n        weaponesSs = new SpriteSheet(loader.loadImage(\"./Resources/Weapones/weapones.png\"));\n        pistol = scaleImage(weaponesSs.grabImage( 1, 8, 16, 16), 64, 64);\n        rifle = scaleImage(weaponesSs.grabImage( 2, 6, 32, 16), 128, 64);\n        shotgun = scaleImage(weaponesSs.grabImage( 2, 4, 30, 16), 128, 64);\n        sniper = scaleImage(weaponesSs.grabImage( 4, 4, 52, 16), 176, 64);\n        rocketLauncher = scaleImage(weaponesSs.grabImage( 2, 5, 41, 16), 176, 64);\n\n        //-------------------------------------------------------------------------------------------\n        loadLevel(level);\n        if(player != null){\n            this.addMouseListener(new MouseInput(handler, camera, this, player));\n        }\n    }\n\n    public synchronized void start() {\n        isRunning = true;\n        thread = new Thread(this);\n        thread.start();\n    }\n\n    public synchronized void stop() {\n        isRunning = false;\n        try {\n            thread.join();\n        } catch (InterruptedException e) {\n            System.err.println(\"Thread interrupted: \" + e.getMessage());\n        }\n    }\n\n    public void run() {\n        \n        this.requestFocus();\n        long lastTime = System.nanoTime();\n        double amountOfTicks = TICK_RATE;\n        double ns = 1000000000 / amountOfTicks;\n        double delta = 0;\n        long timer = System.currentTimeMillis();\n        int frames = 0;\n        int updates = 0;\n        \n        while (isRunning) {\n            long now = System.nanoTime();\n            delta += (now - lastTime) / ns;\n            lastTime = now;\n            while (delta >= 1) {\n                tick();\n                updates++;\n                delta--;\n            }\n            render();\n            frames++;\n            \n            if (System.currentTimeMillis() - timer > 1000) {\n                timer += 1000;\n                System.out.println(\"FPS: \" + frames + \", TICKS: \" + updates);\n                frames = 0;\n                updates = 0;\n            }\n        }\n        stop();\n    }\n\n    private void tick() {\n        if(GAME_STATE == 4){\n            if (System.currentTimeMillis() - gameStartTime >= LOADING_TIME) {\n                if(restart){\n                    GAME_STATE = 1;\n                    restart = false;\n                } else {\n                    GAME_STATE = 0;\n                }\n            }\n        }\n\n        if (GAME_STATE == 1) { \n            for (int i = 0; i < handler.object.size(); i++) {\n                if (handler.object.get(i).getID() == ID.Player) {\n                    camera.tick(handler.object.get(i));\n                }\n            }\n            handler.tick();\n            if(reloading) {\n                if(!weapon.equals(reloadWeapon)) {\n                    reloading = false;\n                }\n                long currentTime = System.currentTimeMillis();\n                int reloadDuration = reloadTimes.getOrDefault(weapon, 1000);\n                \n                if(currentTime - reloadStartTime >= reloadDuration) {\n                    performReload();\n                    reloading = false;\n                }\n            }\n            \n            if(!spawnersInitiated){\n                initializeWave();\n            }\n\n            if (waveFinished) {\n                long currentTime = System.currentTimeMillis();\n                if (currentTime - waveFinishTime >= WAVE_COOLDOWN) {\n                    checkpoint.put(\"wave\", wave);\n                    checkpoint.put(\"hp\", hp);       \n                    checkpoint.put(\"score\", score); \n                    checkpoint.put(\"pistolAmmo\", pistolAmmo);     \n                    checkpoint.put(\"rifleAmmo\", rifleAmmo);       \n                    checkpoint.put(\"shotgunAmmo\", shotgunAmmo); \n                    checkpoint.put(\"sniperAmmo\", sniperAmmo); \n                    checkpoint.put(\"rocketAmmo\", rocketAmmo);\n                    checkpoint.put(\"rifleAmmoBackup\", rifleAmmoBackup); \n                    checkpoint.put(\"shotgunAmmoBackup\", shotgunAmmoBackup); \n                    checkpoint.put(\"sniperAmmoBackup\", sniperAmmoBackup);\n                    checkpoint.put(\"rocketAmmoBackup\", rocketAmmoBackup); \n                    int temp = 0;\n                    if(weapon.equals(\"Pistol\")){ temp = 1; }\n                    else if(weapon.equals(\"Assault Rifle\")){ temp = 2; }\n                    else if(weapon.equals(\"Shotgun\")){ temp = 3; }\n                    else if(weapon.equals(\"Sniper\")){ temp = 4; }\n                    else if(weapon.equals(\"Rocket Launcher\")){ temp = 5; }\n                    checkpoint.put(\"weapon\", temp); \n                    nextWave();\n                    waveFinished = false;  \n                }\n            }\n\n            if(getWeapon().equals(\"Pistol\")){\n                if(pistolAmmo <= 0) {\n                    reloadAmmo();\n                }\n            }else if(getWeapon().equals(\"Assault Rifle\")){\n                if(rifleAmmo <= 0) {\n                    reloadAmmo();\n                }\n            }else if(getWeapon().equals(\"Shotgun\")){\n                if(shotgunAmmo <= 0) {\n                    reloadAmmo();\n                }\n            }else if(getWeapon().equals(\"Sniper\")){\n                if(sniperAmmo <= 0) {\n                    reloadAmmo();\n                }\n            }else{ // Rocket Launcher\n                if(rocketAmmo <= 0) {\n                    reloadAmmo();\n                }\n            }\n        }\n        if(hp <= 0){\n            GAME_STATE = 3;\n        }\n    }\n\n    private void render() {\n        BufferStrategy bs = this.getBufferStrategy();\n        if (bs == null) {\n            this.createBufferStrategy(3);\n            return;\n        }\n\n        Graphics g = bs.getDrawGraphics();\n        Graphics2D g2d = (Graphics2D) g;\n\n        //--------------------------------------------------------------\n        // Game Renders\n        //--------------------------------------------------------------\n\n        if(GAME_STATE == 4){ // Loading Screen\n            g.setColor(Color.black);\n            g.fillRect(0, 0, (int)(ORIGINAL_WIDTH * scale), (int)(ORIGINAL_HEIGHT * scale)); \n            g.setColor(Color.white);\n            g.drawString(\"Loading\", 827, 784);\n            g.setColor(Color.white);\n            g.fillRect(650, 800, (int)((System.currentTimeMillis()-gameStartTime)/25), 24); \n            g.setColor(Color.black);\n            g.drawString(\"%\" + (int)((System.currentTimeMillis()-gameStartTime)/100), 837, 816);\n            g.setColor(Color.white);\n            g.drawRect(650, 800, 400, 24); \n        } else if (GAME_STATE == 0) { // Main menu\n            mainMenu.render(g);\n            int screenMX = handler.getCurrentScreenMX();\n            int screenMY = handler.getCurrentScreenMY();\n            g.drawImage(cursor, screenMX - cursor.getWidth()/2, screenMY - cursor.getHeight()/2, null);\n        } else if(GAME_STATE == 3) {\n            deathMenu.render(g);\n            g2d.setTransform(new AffineTransform());\n            int screenMX = handler.getCurrentScreenMX();\n            int screenMY = handler.getCurrentScreenMY();\n            g.drawImage(cursor, screenMX - cursor.getWidth()/2, screenMY - cursor.getHeight()/2, null);\n        } else { \n            g2d.scale(scale, scale);\n            g2d.translate(-camera.getX(), -camera.getY());\n\n            for (int xx = 0; xx < 30 * 72; xx += 32) {\n                for (int yy = 0; yy < 30 * 72; yy += 32) {\n                    g.drawImage(floor, xx, yy, null); // Floor\n                }\n            }\n            \n            handler.render(g);\n\n            g2d.translate(camera.getX(), camera.getY());\n            g2d.scale(1.0/scale, 1.0/scale); \n\n            g.setFont(new Font(\"Arial\", Font.BOLD, 20));\n            if(!waveFinished){\n                g.setColor(Color.GREEN);\n                g.drawString(\"Wave: \" + wave, 810, 37); // Wave \n                g.setColor(Color.CYAN);\n                g.setFont(new Font(\"Arial\", Font.BOLD, 20));\n                g.drawString(\"Enemy Remaining: \" + totalEnemy, 755, 65); // Remaining Enemies \n            }else{\n                long currentTime = System.currentTimeMillis();\n                g.setColor(Color.RED);\n                g.drawString(\"Next Wave Starts In: \" + ((WAVE_COOLDOWN - (currentTime - waveFinishTime)) / 1000), 755, 300); // Remaining time to next wave \n            }\n            g.setFont(new Font(\"Arial\", Font.BOLD, 36));\n            g.setColor(Color.YELLOW);\n            if(wave == ASSAULT_RIFLE_FIRST_WAVE){\n                if(waveFinished){ g.drawString(\"New Weapon Acquired: Assault Rifle\", 560, 150); }\n            }\n            if(wave == SHOTGUN_FIRST_WAVE){\n                if(waveFinished){ g.drawString(\"New Weapon Acquired: Shotgun\", 600, 150); }\n            }\n            if(wave == SNIPER_FIRST_WAVE){\n                if(waveFinished){ g.drawString(\"New Weapon Acquired: Sniper\", 600, 150); }\n            }\n            if(wave == ROCKET_LAUNCHER_FIRST_WAVE){\n                if(waveFinished){ g.drawString(\"New Weapon Acquired: Rocket Launcher\", 655, 150); }\n            }\n\n            g.setFont(new Font(\"Arial\", Font.BOLD, 18));\n            g.setColor(Color.gray);\n            g.fillRect(1455, 37, 200, 32); // Health bar background\n            g.setColor(Color.green);\n            if(hp > 0){\n                g.fillRect(1455, 37, hp, 32); // Health bar\n                g.setColor(Color.magenta);\n                g.drawString(\"HP: \" + hp, 1465, 59);\n            }\n            g.setColor(Color.black);\n            g.drawRect(1455, 37, 200, 32); // Health bar frame\n            \n            g.setColor(new Color(255, 215, 0));\n            g.drawString(\"Score: \" + this.score, 1500, 107); // Score \n\n            if(getWeapon().equals(\"Pistol\")){\n                if(this.pistol != null){\n                    g.drawImage(pistol, 10, 4, null);\n                }\n            }else if(getWeapon().equals(\"Assault Rifle\")){\n                if(this.rifle != null){\n                    g.drawImage(rifle, 10, 4, null);\n                }\n            }else if(getWeapon().equals(\"Shotgun\")){\n                if(this.shotgun != null){\n                    g.drawImage(shotgun, 6, 4, null);\n                }\n            }else if(getWeapon().equals(\"Sniper\")){\n                if(this.sniper != null){\n                    g.drawImage(sniper, 0, 4, null);\n                }\n            }else{ // Rocket Launcher\n                if(this.rocketLauncher != null){\n                    g.drawImage(rocketLauncher, -9, 4, null);\n                }\n            }\n\n            g.setColor(Color.white);\n            if(weapon.equals(\"Pistol\")){\n                g.drawString(\"Pistol Ammo: \" + pistolAmmo + \"/\" + \"∞\", 5, 90); \n            }\n            else if(weapon.equals(\"Assault Rifle\")){\n                g.drawString(\"Assault Rifle Ammo: \" + rifleAmmo + \"/\" + rifleAmmoBackup, 5, 92); \n            }\n            else if(weapon.equals(\"Shotgun\")){\n                g.drawString(\"Shotgun Ammo: \" + shotgunAmmo + \"/\" + shotgunAmmoBackup, 5, 92); \n            }\n            else if(weapon.equals(\"Sniper\")){\n                g.drawString(\"Sniper Ammo: \" + sniperAmmo + \"/\" + sniperAmmoBackup, 5, 92); \n            }\n            else {\n                g.drawString(\"Rockets: \" + rocketAmmo + \"/\" + rocketAmmoBackup, 5, 92); \n            }\n\n            if(reloading && GAME_STATE == 1) {\n                long elapsed = System.currentTimeMillis() - reloadStartTime;\n                int reloadDuration = reloadTimes.getOrDefault(weapon, 1000);\n                float progress = Math.min((float)elapsed / reloadDuration, 1.0f);\n                \n                int screenX = (int)((player.getX() - camera.getX()) * scale) + 10;\n                int screenY = (int)((player.getY() - camera.getY()) * scale) + 20;\n                \n                int barWidth = 40;\n                int barHeight = 7;\n                int barX = screenX + 16 - barWidth/2;\n                int barY = screenY + 40;\n                \n                g.setColor(new Color(30, 30, 30, 200));\n                g.fillRect(barX, barY, barWidth, barHeight);\n\n                g.setColor(Color.ORANGE);\n                g.fillRect(barX, barY, (int)(barWidth * progress), barHeight);\n                \n                g.setColor(Color.BLACK);\n                g.drawRect(barX, barY, barWidth, barHeight);\n            }\n\n            int screenMX = handler.getCurrentScreenMX();\n            int screenMY = handler.getCurrentScreenMY();\n            if (GAME_STATE == 2) {\n                pauseMenu.render(g);\n                g.drawImage(cursor, screenMX - cursor.getWidth()/2, screenMY - cursor.getHeight()/2, null);\n                g2d.setTransform(new AffineTransform());\n            } else {\n                screenMX = handler.getCurrentScreenMX();\n                screenMY = handler.getCurrentScreenMY();\n                if(weapon.equals(\"Pistol\")){\n                    g.drawImage(pistolCrosshair, screenMX - pistolCrosshair.getWidth()/2, screenMY - pistolCrosshair.getHeight()/2, null);\n                } else if(weapon.equals(\"Assault Rifle\")){\n                    g.drawImage(rifleCrosshair, screenMX - rifleCrosshair.getWidth()/2, screenMY - rifleCrosshair.getHeight()/2, null);\n                } else if(weapon.equals(\"Shotgun\")){\n                    g.drawImage(shotgunCrosshair, screenMX - shotgunCrosshair.getWidth()/2, screenMY - shotgunCrosshair.getHeight()/2, null);\n                } else if(weapon.equals(\"Sniper\")){\n                    g.drawImage(sniperCrosshair, screenMX - sniperCrosshair.getWidth()/2, screenMY - sniperCrosshair.getHeight()/2, null);\n                } else { // Rocket Launcher\n                    g.drawImage(rocketLauncherCrosshair, screenMX - rocketLauncherCrosshair.getWidth()/2, screenMY - rocketLauncherCrosshair.getHeight()/2, null);\n                }\n                g2d.setTransform(new AffineTransform());\n            }\n        }\n\n        //--------------------------------------------------------------\n        g.dispose();\n        bs.show();\n    }\n\n    private void loadLevel(BufferedImage image) { // Load the level\n        int w = image.getWidth();\n        int h = image.getHeight();\n\n        for (int xx = 0; xx < w; xx++) {\n            for (int yy = 0; yy < h; yy++) {\n                int pixel = image.getRGB(xx, yy);\n                int red = (pixel >> 16) & 0xff;\n                int green = (pixel >> 8) & 0xff;\n                int blue = (pixel) & 0xff;\n                if (red == 255 && green == 0 && blue == 0) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Wall\", 0, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 255 && green == 255 && blue == 255) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Invisible Wall\", 0, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 255 && green == 80 && blue == 0) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Tree\", 0, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 255 && green == 80 && blue == 40) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Rock\", 0, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 255 && green == 80 && blue == 80) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Horizontal Red Car\", 0, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 200 && green == 200 && blue == 200) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Horizontal Blue Car\", 0, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 150 && green == 150 && blue == 150) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Vertical Red Car\", 0, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 100 && green == 100 && blue == 100) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Vertical Blue Car\", 0, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 255 && green == 80 && blue == 120) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Stump\", 0, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 255 && green == 80 && blue == 160) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Skeleton Pile\", 0, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 255 && green == 80 && blue == 200) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Ruin Block\", 0, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 255 && green == 80 && blue == 240) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Lamp\", 0, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 0 && green == 0 && blue == 10) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"VRR\"));\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Big Ruins\", 1, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 0 && green == 0 && blue == 20) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"VRL\"));\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Big Ruins\", 2, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 0 && green == 0 && blue == 40) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"VRR\"));\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Big Ruins\", 3, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 0 && green == 0 && blue == 60) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"VRL\"));\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Big Ruins\", 4, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 0 && green == 125 && blue == 245) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Small Ruins\", 1, this));\n                    map[xx][yy] = 1;\n                }\n                if (red == 100 && green == 125 && blue == 245) {\n                    handler.addObject(new Wall(xx * 32, yy * 32, ID.Block, \"Small Ruins\", 2, this));\n                    map[xx][yy] = 1;\n                }\n                //-------------------------------------------------------------------------------------\n                if (red == 0 && green == 200 && blue == 255) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"GUL\"));\n                }\n                if (red == 10 && green == 190 && blue == 255) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"GUM\"));\n                }\n                if (red == 20 && green == 180 && blue == 255) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"GUR\"));\n                }\n                if (red == 30 && green == 170 && blue == 255) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"GML\"));\n                }\n                if (red == 40 && green == 160 && blue == 255) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"GMM\"));\n                }\n                if (red == 50 && green == 150 && blue == 255) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"GMR\"));\n                }\n                if (red == 60 && green == 140 && blue == 255) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"GLL\"));\n                }\n                if (red == 70 && green == 130 && blue == 255) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"GLM\"));\n                }\n                if (red == 80 && green == 120 && blue == 255) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"GLR\"));\n                }\n                if (red == 0 && green == 80 && blue == 100) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"HRU\"));\n                }\n                if (red == 10 && green == 10 && blue == 100) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"HRD\"));\n                }\n                if (red == 60 && green == 10 && blue == 100) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"VRR\"));\n                }\n                if (red == 60 && green == 80 && blue == 100) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"VRL\"));\n                }\n                if (red == 60 && green == 60 && blue == 100) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"TRRUL\"));\n                }\n                if (red == 50 && green == 60 && blue == 100) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"TRRUR\"));\n                }\n                if (red == 40 && green == 60 && blue == 100) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"TRRLL\"));\n                }\n                if (red == 30 && green == 60 && blue == 100) {\n                    handler.addObject(new Floor(xx * 32, yy * 32, ID.Floor, \"TRRLR\"));\n                }\n            }\n        }\n        for (int xx = 0; xx < w; xx++) {\n            for (int yy = 0; yy < h; yy++) {\n                int pixel = image.getRGB(xx, yy);\n                int red = (pixel >> 16) & 0xff;\n                int green = (pixel >> 8) & 0xff;\n                int blue = (pixel) & 0xff;\n\n                if (red == 0 && green == 0 && blue == 255) {\n                    handler.addObject(player = new Player(xx * 32, yy * 32, ID.Player, handler, this));\n                }\n            }\n        } \n        for (int xx = 0; xx < w; xx++) {\n            for (int yy = 0; yy < h; yy++) {\n                int pixel = image.getRGB(xx, yy);\n                int red = (pixel >> 16) & 0xff;\n                int green = (pixel >> 8) & 0xff;\n                int blue = (pixel) & 0xff;\n\n                if (red == 0 && green == 255 && blue == 0) {\n\n                    handler.addObject(new Spawner(xx * 32, yy * 32, ID.Spawner, this, handler, player));\n                }\n            }\n        } \n    }\n\n    public void initializeWave(){\n\n        int zombieCount = 0;\n        int golemCount = 0;\n        int shadowCount = 0;\n        int banditCount = 0;\n\n        if(wave >= ZOMBIE_FIRST_WAVE) { zombieCount = (wave - ZOMBIE_FIRST_WAVE + 1) * ZOMBIE_INCREASE_AMOUNT_PER_WAVE; }\n        if(wave >= GOLEM_FIRST_WAVE) { golemCount = (wave - GOLEM_FIRST_WAVE + 1) * GOLEM_INCREASE_AMOUNT_PER_WAVE; }\n        if(wave >= SHADOW_FIRST_WAVE) { shadowCount = (wave - SHADOW_FIRST_WAVE + 1) * SHADOW_INCREASE_AMOUNT_PER_WAVE; }\n        if(wave >= BANDIT_FIRST_WAVE) { banditCount = (wave - BANDIT_FIRST_WAVE + 1) * BANDIT_INCREASE_AMOUNT_PER_WAVE; }\n\n        totalEnemy = zombieCount + golemCount + shadowCount + banditCount;\n\n        ArrayList<Spawner> spawnerList = new ArrayList<>();\n        for (GameObject obj : handler.object) {\n            if(obj.getID() == ID.Spawner){\n                spawnerList.add((Spawner) obj);\n            }\n        }\n\n        if(spawnerList.isEmpty()){ System.err.println(\"SPAWNER ERROR!\"); return; }\n        spawnersInitiated = true;\n\n        int r;\n        for (int i = 0; i < zombieCount; i++) {\n            r = ThreadLocalRandom.current().nextInt(0, spawnerList.size());\n            if(!spawnerList.isEmpty()){\n                spawnerList.get(r).addZOMBIE();\n            }\n        }\n        for (int i = 0; i < golemCount; i++) {\n            r = ThreadLocalRandom.current().nextInt(0, spawnerList.size());\n            if(!spawnerList.isEmpty()){\n                spawnerList.get(r).addGOLEM();\n            }\n        }\n        for (int i = 0; i < shadowCount; i++) {\n            r = ThreadLocalRandom.current().nextInt(0, spawnerList.size());\n            if(!spawnerList.isEmpty()){\n                spawnerList.get(r).addSHADOW();\n            }\n        }\n        for (int i = 0; i < banditCount; i++) {\n            r = ThreadLocalRandom.current().nextInt(0, spawnerList.size());\n            if(!spawnerList.isEmpty()){\n                spawnerList.get(r).addBANDIT();\n            }\n        }\n        waveInProgress = true;\n    }\n\n    public void nextWave() {\n        wave++;\n        spawnersInitiated = false;\n        initializeWave();  \n    }\n\n    public void enemyKilled() {\n        if (waveInProgress) {\n            totalEnemy--;\n            if(totalEnemy <= 0) {\n                waveInProgress = false;\n                waveFinished = true;\n                waveFinishTime = System.currentTimeMillis(); \n            }\n        }\n    }\n\n    public void resetGame() {\n        gameStartTime = System.currentTimeMillis(); \n        GAME_STATE = 4;\n        handler.object.clear();\n        loadLevel(level);\n        hp = MAX_HEALTH;\n        totalEnemy = 0;\n        wave = 0;\n        score = 0;\n        weapon = \"Pistol\";\n        pistolAmmo = 12;\n        rifleAmmo = 30;\n        shotgunAmmo = 5;\n        sniperAmmo = 5;\n        rocketAmmo = 1;\n        rifleAmmoBackup = 60;\n        shotgunAmmoBackup = 10;\n        sniperAmmoBackup = 10;\n        rocketAmmoBackup = 2;\n        waveFinishTime = System.currentTimeMillis();\n        spawnersInitiated = true;\n        waveInProgress = false;\n        totalEnemy = 0;\n        waveFinished = true;\n\n        this.removeMouseListener(getMouseListeners()[0]);\n        this.addMouseListener(new MouseInput(handler, camera, this, player));\n    }\n\n    public void reloadAmmo(){\n        if(!reloading) {\n            if(isReloadable()){\n                reloading = true;\n                reloadStartTime = System.currentTimeMillis();\n                reloadWeapon = weapon;\n            }\n        }\n    }\n\n    public boolean isReloadable(){\n        switch(weapon){\n            case \"Pistol\": if(pistolAmmo < 12) { return true; } break;\n            case \"Assault Rifle\": if(rifleAmmo < 30 && rifleAmmoBackup > 0) { return true; } break;\n            case \"Shotgun\": if(shotgunAmmo < 5 && shotgunAmmoBackup > 0) { return true; } break;\n            case \"Sniper\": if(sniperAmmo < 5 && sniperAmmoBackup > 0) { return true; } break;\n            case \"Rocket Launcher\": if(rocketAmmo < 1 && rocketAmmoBackup > 0) { return true; } break;\n        }\n        return false;\n    }\n\n    private void performReload() {\n        switch(weapon) {\n            case \"Pistol\":\n                pistolAmmo = 12;\n                break;\n                \n            case \"Assault Rifle\":\n                if(rifleAmmoBackup > 0) {\n                    int needed = 30 - rifleAmmo;\n                    int reloadAmount = Math.min(needed, rifleAmmoBackup);\n                    rifleAmmo += reloadAmount;\n                    rifleAmmoBackup -= reloadAmount;\n                }\n                break;\n                \n            case \"Shotgun\":\n                if(shotgunAmmoBackup > 0) {\n                    int needed = 5 - shotgunAmmo;\n                    int reloadAmount = Math.min(needed, shotgunAmmoBackup);\n                    shotgunAmmo += reloadAmount;\n                    shotgunAmmoBackup -= reloadAmount;\n                }\n                break;\n                \n            case \"Sniper\":\n                if(sniperAmmoBackup > 0) {\n                    int needed = 5 - sniperAmmo;\n                    int reloadAmount = Math.min(needed, sniperAmmoBackup);\n                    sniperAmmo += reloadAmount;\n                    sniperAmmoBackup -= reloadAmount;\n                }\n                break;\n                \n            case \"Rocket Launcher\":\n                if(rocketAmmoBackup > 0) {\n                    int needed = 1 - rocketAmmo;\n                    int reloadAmount = Math.min(needed, rocketAmmoBackup);\n                    rocketAmmo += reloadAmount;\n                    rocketAmmoBackup -= reloadAmount;\n                }\n                break;\n        }\n    }\n\n    public void changeWeapon(String weapon){\n        if(reloading) {\n            reloading = false;\n            reloadStartTime = 0;\n        }\n        this.weapon = weapon;\n    }\n\n    public void meleeStrike(){\n        meleeStrike = true;\n        new Thread(() -> {\n            try {\n                Thread.sleep(500);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            meleeStrike = false;\n        }).start();\n    }\n\n    public boolean isMeleeStrike(){\n        return meleeStrike;\n    }\n\n    public void setMeleeStrike(boolean meleeStrike){\n        this.meleeStrike = meleeStrike;\n    }\n\n    private BufferedImage scaleImage(BufferedImage original, int width, int height) {\n        BufferedImage scaled = new BufferedImage(width, height, original.getType());\n        Graphics2D g2d = scaled.createGraphics();\n        g2d.drawImage(original, 0, 0, width, height, null);\n        g2d.dispose();\n        return scaled;\n    }\n\n    public void saveGameState() {\n        checkpoint.put(\"wave\", this.wave);\n        checkpoint.put(\"hp\", this.hp);\n        checkpoint.put(\"score\", this.score);\n        checkpoint.put(\"pistolAmmo\", this.pistolAmmo);\n        checkpoint.put(\"rifleAmmo\", this.rifleAmmo);\n        checkpoint.put(\"shotgunAmmo\", this.shotgunAmmo);\n        checkpoint.put(\"sniperAmmo\", this.sniperAmmo);\n        checkpoint.put(\"rocketAmmo\", this.rocketAmmo);\n        checkpoint.put(\"rifleAmmoBackup\", this.rifleAmmoBackup);\n        checkpoint.put(\"shotgunAmmoBackup\", this.shotgunAmmoBackup);\n        checkpoint.put(\"sniperAmmoBackup\", this.sniperAmmoBackup);\n        checkpoint.put(\"rocketAmmoBackup\", this.rocketAmmoBackup);\n        \n        int temp = 0;\n        switch(this.weapon) {\n            case \"Pistol\": temp = 1; break;\n            case \"Assault Rifle\": temp = 2; break;\n            case \"Shotgun\": temp = 3; break;\n            case \"Sniper\": temp = 4; break;\n            case \"Rocket Launcher\": temp = 5; break;\n        }\n        checkpoint.put(\"weapon\", temp);\n        \n        SaveAndLoad state = new SaveAndLoad();\n        state.wave = checkpoint.get(\"wave\");\n        state.hp = checkpoint.get(\"hp\");\n        state.score = checkpoint.get(\"score\");\n        state.pistolAmmo = checkpoint.get(\"pistolAmmo\");\n        state.rifleAmmo = checkpoint.get(\"rifleAmmo\");\n        state.shotgunAmmo = checkpoint.get(\"shotgunAmmo\");\n        state.sniperAmmo = checkpoint.get(\"sniperAmmo\");\n        state.rocketAmmo = checkpoint.get(\"rocketAmmo\");\n        state.rifleAmmoBackup = checkpoint.get(\"rifleAmmoBackup\");\n        \n        String tempWeapon = \"\";\n        switch (checkpoint.get(\"weapon\")) {\n            case 1: tempWeapon = \"Pistol\"; break;\n            case 2: tempWeapon = \"Assault Rifle\"; break;\n            case 3: tempWeapon = \"Shotgun\"; break;\n            case 4: tempWeapon = \"Sniper\"; break;\n            case 5: tempWeapon = \"Rocket Launcher\"; break;\n        }\n        state.weapon = tempWeapon;\n        state.saveGame(\"savegame.dat\", state);\n    }\n    \n    public void loadGameState() {\n        SaveAndLoad state = new SaveAndLoad().loadGame(\"savegame.dat\");\n        if(state != null) {\n            this.wave = state.wave;\n            this.hp = state.hp;\n            this.score = state.score;\n            this.pistolAmmo = state.pistolAmmo;\n            this.rifleAmmo = state.rifleAmmo;\n            this.shotgunAmmo = state.shotgunAmmo;\n            this.sniperAmmo = state.sniperAmmo;\n            this.rocketAmmo = state.rocketAmmo;\n            this.rifleAmmoBackup = state.rifleAmmoBackup;\n            this.weapon = state.weapon;\n        }\n    }\n    \n    public String getWeapon(){ return this.weapon; }\n    public boolean isReloading() { return reloading; }\n    public boolean isDebug() { return debug; }\n    public boolean isWaveFinished() { return waveFinished; }\n    public int getWave() { return wave; }\n    public int getASSAULT_RIFLE_FIRST_WAVE() { return ASSAULT_RIFLE_FIRST_WAVE; }\n    public int getSHOTGUN_FIRST_WAVE() { return SHOTGUN_FIRST_WAVE; }\n    public int getSNIPER_FIRST_WAVE() { return SNIPER_FIRST_WAVE; }\n    public int getROCKET_LAUNCHER_FIRST_WAVE() { return ROCKET_LAUNCHER_FIRST_WAVE; }\n    public int getMELEE_STRIKE_RATE() { return MELEE_STRIKE_RATE; }\n    public int getASSAULT_RIFLE_FIRE_RATE() { return ASSAULT_RIFLE_FIRE_RATE; }\n    public int getROCKET_LAUNCHER_FIRE_RATE() { return ROCKET_LAUNCHER_FIRE_RATE; }\n    public int getSHOTGUN_FIRE_RATE() { return SHOTGUN_FIRE_RATE; }\n    public int getSNIPER_FIRE_RATE() { return SNIPER_FIRE_RATE; }\n    public int getPISTOL_FIRE_RATE() { return PISTOL_FIRE_RATE; }\n    public int getPISTOL_DAMAGE() { return PISTOL_DAMAGE; }\n    public int getASSAULT_RIFLE_DAMAGE() { return ASSAULT_RIFLE_DAMAGE; }\n    public int getSHOTGUN_DAMAGE() { return SHOTGUN_DAMAGE; }\n    public int getSNIPER_DAMAGE() { return SNIPER_DAMAGE; }\n    public int getMELEE_DAMAGE() { return MELEE_DAMAGE; }\n    public int getRIFLE_AMMO_CRATE_DROP_CHANCE() { return RIFLE_AMMO_DROP_CHANCE; }\n    public int getSHOTGUN_AMMO_CRATE_DROP_CHANCE() { return SHOTGUN_AMMO_DROP_CHANCE; }\n    public int getSNIPER_AMMO_CRATE_DROP_CHANCE() { return SNIPER_AMMO_DROP_CHANCE; }\n    public int getROCKET_CRATE_DROP_CHANCE() { return ROCKET_DROP_CHANCE; }\n    public int getMAJOR_HEALTH_CRATE_DROP_CHANCE() { return MAJOR_HEALTH_CRATE_DROP_CHANCE; }\n    public int getMINOR_HEALTH_CRATE_DROP_CHANCE() { return MINOR_HEALTH_CRATE_DROP_CHANCE; }\n    public int getMAJOR_HEALTH() { return MAJOR_HEALTH; }\n    public int getMINOR_HEALTH() { return MINOR_HEALTH; }\n    public int getMAX_HEALTH() { return MAX_HEALTH; }\n    public int getROCKET_DAMAGE() { return ROCKET_DAMAGE; }\n    public int getROCKET_RADIUS() { return ROCKET_RADIUS; }\n    public int getGRANADE_DAMAGE() { return GRANADE_DAMAGE; }\n    public int getGRANADE_RADIUS() { return GRANADE_RADIUS; }\n    public void gainScore(int score){ this.score += score; }\n    public void setWaveFinishTime(long time) { this.waveFinishTime = time; }\n    public static void main(String[] args) { new Game(); }\n}",
      "MouseInput.java": "import java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseMotionListener;\nimport java.util.HashMap;\n\nimport javax.swing.SwingUtilities;\nimport javax.swing.Timer;\n\npublic class MouseInput extends MouseAdapter implements MouseMotionListener{\n    private Handler handler;\n    private Camera camera;\n    private Game game;\n    Player player;\n    private volatile boolean autoShooting = false;\n    private volatile int currentMX; \n    private volatile int currentMY; \n    private final HashMap<String, Long> weaponCooldowns = new HashMap<>();\n    private volatile String currentWeapon;\n\n    public MouseInput(Handler handler, Camera camera, Game game, Player player) {    \n        this.handler = handler;\n        this.camera = camera;\n        this.game = game;\n        this.player = player;\n\n        game.addMouseMotionListener(this);\n\n    }\n\n    public void mouseMoved(MouseEvent e) {\n        updateMousePosition(e);\n\n    }\n\n    public void mouseDragged(MouseEvent e) {\n        updateMousePosition(e);\n    }\n\n    private void updateMousePosition(MouseEvent e) {\n        if(game.GAME_STATE == 4) { return; }\n            \n        handler.setCurrentScreenMX(e.getX());\n        handler.setCurrentScreenMY(e.getY());\n\n        if(game.GAME_STATE == 1) {\n            currentMX = (int)(e.getX() / game.scale) + (int)camera.getX();\n            currentMY = (int)(e.getY() / game.scale) + (int)camera.getY();\n            handler.setCurrentMX(currentMX);\n            handler.setCurrentMY(currentMY);\n        }\n    }\n\n    public void mousePressed(MouseEvent e) {\n        if(game.GAME_STATE == 4) { return; }\n\n        if(game.isReloading()) return;\n        updateMousePosition(e);\n        currentWeapon = game.getWeapon();\n        \n        int mx, my;\n\n        if (game.GAME_STATE == 0 || game.GAME_STATE == 2 || game.GAME_STATE == 3) {\n            mx = e.getX();\n            my = e.getY();\n        } else {\n            mx = (int) ((e.getX() / game.scale) + camera.getX());\n            my = (int) ((e.getY() / game.scale) + camera.getY());\n        }\n\n        if(game.GAME_STATE == 4){\n            return;\n        } else {\n            if (game.GAME_STATE == 0) {\n                if (game.mainMenu.playButton.contains(mx, my)) {\n                    game.setWaveFinishTime(System.currentTimeMillis());\n                    game.GAME_STATE = 1;\n                } else if (game.mainMenu.quitButton.contains(mx, my)) {\n                    System.exit(0);\n                } else if (game.mainMenu.loadButton.contains(mx, my)) {\n                    game.loadGameState();\n                    game.GAME_STATE = 1;\n                }\n            } else if (game.GAME_STATE == 3) {\n                if (game.deathMenu.mainMenuButton.contains(mx, my)) {\n                    game.restart = false;\n                    game.resetGame();\n                } else if (game.deathMenu.playAgainButton.contains(mx, my)) {\n                    game.setWaveFinishTime(System.currentTimeMillis());\n                    game.restart = true;\n                    game.resetGame();\n                } else if (game.deathMenu.loadButton.contains(mx, my)) {\n                    game.restart = true;\n                    game.resetGame();\n                    game.loadGameState();\n                    game.GAME_STATE = 1;\n                }\n            } else if (game.GAME_STATE == 2) {\n                if (game.pauseMenu.resumeButton.contains(mx, my)) {\n                    game.GAME_STATE = 1;\n                } else if (game.pauseMenu.mainMenuButton.contains(mx, my)) {\n                    game.GAME_STATE = 0;\n                    game.restart = false;\n                    game.resetGame();\n                } else if (game.pauseMenu.resetButton.contains(mx, my)) {\n                    game.GAME_STATE = 1;\n                    game.restart = true;\n                    game.resetGame();\n                } else if (game.pauseMenu.saveButton.contains(mx, my)) {\n                    game.saveGameState();\n                } else if (game.pauseMenu.loadButton.contains(mx, my)) {\n                    game.restart = false;\n                    game.resetGame();\n                    game.loadGameState();\n                    game.GAME_STATE = 1;\n                }\n            } else if (game.GAME_STATE == 1) {\n                if(SwingUtilities.isLeftMouseButton(e)){\n                    if(currentWeapon.equals(\"Assault Rifle\") && game.rifleAmmo > 0) {\n                        handleAutomaticWeapon(game.getASSAULT_RIFLE_FIRE_RATE(), \"7.62\", \n                        () -> game.rifleAmmo--);\n                    } \n                    else if(currentWeapon.equals(\"Shotgun\") && game.shotgunAmmo > 0) {\n                        handleSemiAutoWeapon(game.getSHOTGUN_FIRE_RATE(), \"12gauge\", \n                        () -> game.shotgunAmmo--, currentWeapon);\n                    }\n                    else if(currentWeapon.equals(\"Sniper\") && game.sniperAmmo > 0) {\n                        handleSemiAutoWeapon(game.getSNIPER_FIRE_RATE(), \"50cal.\", \n                        () -> game.sniperAmmo--, \"\");\n                    }\n                    else if(currentWeapon.equals(\"Pistol\") && game.pistolAmmo > 0) {\n                        handleSemiAutoWeapon(game.getPISTOL_FIRE_RATE(), \"9mm\", \n                        () -> game.pistolAmmo--, \"\");\n                    }\n                    else { // Rocket Launcher\n                        if(currentWeapon.equals(\"Rocket Launcher\")) {\n                            if(game.rocketAmmo > 0){\n                                handleSemiAutoWeapon(game.getROCKET_LAUNCHER_FIRE_RATE(), \"rocket\", \n                                () -> game.rocketAmmo--, \"\");\n                            }\n                        }\n                    }\n                }\n                else if(SwingUtilities.isRightMouseButton(e)){\n                    long currentTime = System.currentTimeMillis();\n                    long lastMeleeTime = weaponCooldowns.getOrDefault(\"Melee\", 0L);\n    \n                    if (currentTime - lastMeleeTime >= game.getMELEE_STRIKE_RATE()) {\n                        game.meleeStrike();\n                        weaponCooldowns.put(\"Melee\", currentTime);\n                    }\n                }\n            }\n        }\n    }\n\n    private void handleAutomaticWeapon(int fireRate, String ammoType, Runnable ammoDecrement) {\n        if (!autoShooting) {\n            autoShooting = true; \n            handler.setAutoShooting(true); \n            new Thread(() -> { \n                while (autoShooting && currentWeapon.equals(game.getWeapon())) {\n                    if (game.rifleAmmo <= 0) break;\n                    SwingUtilities.invokeLater(() -> {\n                        fireBullet(ammoType, \"Assault Rifle\");\n                        ammoDecrement.run();\n                    });\n                    try {\n                        Thread.sleep(fireRate);\n                    } catch (InterruptedException ex) {\n                        Thread.currentThread().interrupt();\n                        break;\n                    }\n                }\n                autoShooting = false;\n                handler.setAutoShooting(false);\n            }).start();\n        }\n    }\n\n    private void handleSemiAutoWeapon(int fireRate, String ammoType, Runnable ammoDecrement, String currentWeapon) {\n        handler.setShooting(true);\n        long currentTime = System.currentTimeMillis();\n        long lastFire = weaponCooldowns.getOrDefault(currentWeapon, 0L);\n        \n        if (currentTime - lastFire >= fireRate) {\n            fireBullet(ammoType, currentWeapon); \n            ammoDecrement.run();\n            weaponCooldowns.put(currentWeapon, currentTime);\n    \n            Timer timer = new Timer(150, e -> {\n                handler.setShooting(false);\n            });\n            timer.setRepeats(false); \n            timer.start();\n        } else {\n            handler.setShooting(false);\n        }\n    }\n\n    private void fireBullet(String ammoType, String weaponType) {\n        int sourceX;\n        int sourceY;\n\n        if(player.lookingDirection.equals(\"up\")){\n            sourceX = player.centerX + 5;  \n            sourceY = player.centerY - 5;\n        }\n        else if(player.lookingDirection.equals(\"down\")){\n            sourceX = player.centerX - 8;  \n            sourceY = player.centerY + 5;\n        }\n        else if(player.lookingDirection.equals(\"right\")){\n            sourceX = player.centerX + 5;  \n            sourceY = player.centerY + 5;\n        }\n        else { // left\n            sourceX = player.centerX - 5;  \n            sourceY = player.centerY - 8;\n        }\n        \n        if(weaponType.equals(\"Shotgun\")) {\n            final int pelletCount = 9;\n            final double angleStep = Math.toRadians(5); \n            final double baseAngle = Math.atan2(currentMY - (player.getY() + 24), currentMX - (player.getX() + 16));\n            final double startAngle = baseAngle - ((pelletCount - 1) / 2.0) * angleStep;\n\n            for (int i = 0; i < pelletCount; i++) {\n                double angle = startAngle + i * angleStep;\n                int spread = 500; \n                int targetX = (int)(player.getX() + 16 + Math.cos(angle) * spread);\n                int targetY = (int)(player.getY() + 24 + Math.sin(angle) * spread);\n                handler.addObject(new Bullet(\n                    sourceX,\n                    sourceY,\n                    ID.Bullet,\n                    handler,\n                    targetX,\n                    targetY,\n                    ammoType,\n                    game,\n                    \"Enemy\"\n                ));\n            }\n        }else if(weaponType.equals(\"Assault Rifle\")){\n            final double spreadAngle = Math.toRadians(30); \n            final double baseAngle = Math.atan2(currentMY - (player.getY()+24), currentMX - (player.getX()+16));\n            double angle = baseAngle + (Math.random() - 0.5) * spreadAngle;\n            int spread = 500; \n            int targetX = (int)(player.getX()+16 + Math.cos(angle)*spread);\n            int targetY = (int)(player.getY()+24 + Math.sin(angle)*spread);\n            handler.addObject(new Bullet(\n                sourceX,\n                sourceY,\n                ID.Bullet,\n                handler,\n                targetX,\n                targetY,\n                ammoType,\n                game,\n                \"Enemy\"\n            ));\n        }\n        else{\n            handler.addObject(new Bullet(\n                sourceX,\n                sourceY,\n                ID.Bullet,\n                handler,\n                currentMX,\n                currentMY,\n                ammoType,\n                game,\n                \"Enemy\"\n            ));\n        }\n    }\n\n    public void mouseReleased(MouseEvent e) {\n        if(game.GAME_STATE == 4) { return; }\n        autoShooting = false;\n        handler.setAutoShooting(false);\n    }\n\n    public int getCurrentMX() { return currentMX; }\n    public int getCurrentMY() { return currentMY; }\n}\n",
      "Camera.java": "public class Camera {\n\n    private float x, y;\n\n    public Camera(float x, float y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void tick(GameObject object) {\n        x += ((object.getX() - x) - (1000 / 2)) * 0.05f;\n        y += ((object.getY() - y) - (563 / 2)) * 0.05f;\n\n        if (x <= 0) x = 0;\n        if (y <= 0) y = 0;\n        if (x >= 1032) x = 1032;\n        if (y >= 1448 + 48) y = 1448 + 48;\n    }\n\n    public float getX() { return x; }\n    public float getY() { return y; }\n    public void setX(float x) { this.x = x; }\n    public void setY(float y) { this.y = y; }\n}",
      "SpriteSheet.java": "\nimport java.awt.image.BufferedImage;\n\npublic class SpriteSheet {\n    \n    private BufferedImage image;\n\n    public SpriteSheet(BufferedImage image) {\n        this.image = image;\n    }\n\n    public BufferedImage grabImage(int col, int row, int width, int height) {\n        return image.getSubimage((col * width) - width, (row * height) - height, width, height);\n    }\n\n    public BufferedImage grabImageSpecific(int x, int y, int width, int height) {\n        return image.getSubimage(x, y, width, height);\n    }\n\n}\n",
      "Animation.java": "import java.awt.Graphics;\nimport java.awt.image.BufferedImage;\n\npublic class Animation {\n\n\tprivate int speed;\n\tprivate int frames;\n\tprivate int index = 0;\n\tprivate int count = 0;\n\t\n\tprivate BufferedImage img1;\n\tprivate BufferedImage img2;\n\tprivate BufferedImage img3;\n\tprivate BufferedImage img4;\n\tprivate BufferedImage img5;\n\tprivate BufferedImage img6;\n\tprivate BufferedImage img7;\n\tprivate BufferedImage img8;\n\tprivate BufferedImage img9;\n\tprivate BufferedImage img10;\n\tprivate BufferedImage img11;\n\tprivate BufferedImage img12;\n\tprivate BufferedImage img13;\n\tprivate BufferedImage img14;\n\tprivate BufferedImage img15;\n\tprivate BufferedImage img16;\n\tprivate BufferedImage img17;\n\tprivate BufferedImage img18;\n\tprivate BufferedImage img19;\n\tprivate BufferedImage img20;\n\t\n\tprivate BufferedImage currentImg;\n\t//20 frame animation\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3, BufferedImage img4, BufferedImage img5, BufferedImage img6, BufferedImage img7, BufferedImage img8, BufferedImage img9, BufferedImage img10, BufferedImage img11, BufferedImage img12, BufferedImage img13, BufferedImage img14, BufferedImage img15, BufferedImage img16, BufferedImage img17, BufferedImage img18, BufferedImage img19, BufferedImage img20){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tthis.img4 = img4;\n\t\tthis.img5 = img5;\n\t\tthis.img6 = img6;\n\t\tthis.img7 = img7;\n\t\tthis.img8 = img8;\n\t\tthis.img9 = img9;\n\t\tthis.img10 = img10;\n\t\tthis.img11 = img11;\n\t\tthis.img12 = img12;\n\t\tthis.img13 = img13;\n\t\tthis.img14 = img14;\n\t\tthis.img15 = img15;\n\t\tthis.img16 = img16;\n\t\tthis.img17 = img17;\n\t\tthis.img18 = img18;\n\t\tthis.img19 = img19;\n\t\tthis.img20 = img20;\n\t\tframes = 20;\n\t}\n\t//15 frame animation\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3, BufferedImage img4, BufferedImage img5, BufferedImage img6, BufferedImage img7, BufferedImage img8, BufferedImage img9, BufferedImage img10, BufferedImage img11, BufferedImage img12, BufferedImage img13, BufferedImage img14, BufferedImage img15){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tthis.img4 = img4;\n\t\tthis.img5 = img5;\n\t\tthis.img6 = img6;\n\t\tthis.img7 = img7;\n\t\tthis.img8 = img8;\n\t\tthis.img9 = img9;\n\t\tthis.img10 = img10;\n\t\tthis.img11 = img11;\n\t\tthis.img12 = img12;\n\t\tthis.img13 = img13;\n\t\tthis.img14 = img14;\n\t\tthis.img15 = img15;\n\t\tframes = 15;\n\t}\n\t//14 frame animation\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3, BufferedImage img4, BufferedImage img5, BufferedImage img6, BufferedImage img7, BufferedImage img8, BufferedImage img9, BufferedImage img10, BufferedImage img11, BufferedImage img12, BufferedImage img13, BufferedImage img14){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tthis.img4 = img4;\n\t\tthis.img5 = img5;\n\t\tthis.img6 = img6;\n\t\tthis.img7 = img7;\n\t\tthis.img8 = img8;\n\t\tthis.img9 = img9;\n\t\tthis.img10 = img10;\n\t\tthis.img11 = img11;\n\t\tthis.img12 = img12;\n\t\tthis.img13 = img13;\n\t\tthis.img14 = img14;\n\t\tframes = 14;\n\t}\n\t//13 frame animation\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3, BufferedImage img4, BufferedImage img5, BufferedImage img6, BufferedImage img7, BufferedImage img8, BufferedImage img9, BufferedImage img10, BufferedImage img11, BufferedImage img12, BufferedImage img13){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tthis.img4 = img4;\n\t\tthis.img5 = img5;\n\t\tthis.img6 = img6;\n\t\tthis.img7 = img7;\n\t\tthis.img8 = img8;\n\t\tthis.img9 = img9;\n\t\tthis.img10 = img10;\n\t\tthis.img11 = img11;\n\t\tthis.img12 = img12;\n\t\tthis.img13 = img13;\n\t\tframes = 13;\n\t\t}\n\t//12 frame animation\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3, BufferedImage img4, BufferedImage img5, BufferedImage img6, BufferedImage img7, BufferedImage img8, BufferedImage img9, BufferedImage img10, BufferedImage img11, BufferedImage img12){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tthis.img4 = img4;\n\t\tthis.img5 = img5;\n\t\tthis.img6 = img6;\n\t\tthis.img7 = img7;\n\t\tthis.img8 = img8;\n\t\tthis.img9 = img9;\n\t\tthis.img10 = img10;\n\t\tthis.img11 = img11;\n\t\tthis.img12 = img12;\n\t\tframes = 12;\n\t}\n\t//11 frame animation\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3, BufferedImage img4, BufferedImage img5, BufferedImage img6, BufferedImage img7, BufferedImage img8, BufferedImage img9, BufferedImage img10, BufferedImage img11){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tthis.img4 = img4;\n\t\tthis.img5 = img5;\n\t\tthis.img6 = img6;\n\t\tthis.img7 = img7;\n\t\tthis.img8 = img8;\n\t\tthis.img9 = img9;\n\t\tthis.img10 = img10;\n\t\tthis.img11 = img11;\n\t\tframes = 11;\n\t}\n\t//10 frame animation\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3, BufferedImage img4, BufferedImage img5, BufferedImage img6, BufferedImage img7, BufferedImage img8, BufferedImage img9, BufferedImage img10){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tthis.img4 = img4;\n\t\tthis.img5 = img5;\n\t\tthis.img6 = img6;\n\t\tthis.img7 = img7;\n\t\tthis.img8 = img8;\n\t\tthis.img9 = img9;\n\t\tthis.img10 = img10;\n\t\tframes = 10;\n\t}\n\t// 9 frame\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3, BufferedImage img4, BufferedImage img5, BufferedImage img6, BufferedImage img7, BufferedImage img8, BufferedImage img9){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tthis.img4 = img4;\n\t\tthis.img5 = img5;\n\t\tthis.img6 = img6;\n\t\tthis.img7 = img7;\n\t\tthis.img8 = img8;\n\t\tthis.img9 = img9;\n\t\tframes = 9;\n\t}\n\t//8 frame\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3, BufferedImage img4, BufferedImage img5, BufferedImage img6, BufferedImage img7, BufferedImage img8){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tthis.img4 = img4;\n\t\tthis.img5 = img5;\n\t\tthis.img6 = img6;\n\t\tthis.img7 = img7;\n\t\tthis.img8 = img8;\n\t\tframes = 8;\n\t}\n\t//7 frame\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3, BufferedImage img4, BufferedImage img5, BufferedImage img6, BufferedImage img7){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tthis.img4 = img4;\n\t\tthis.img5 = img5;\n\t\tthis.img6 = img6;\n\t\tthis.img7 = img7;\n\t\tframes = 7;\n\t}\n\t//6 frame\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3, BufferedImage img4, BufferedImage img5, BufferedImage img6){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tthis.img4 = img4;\n\t\tthis.img5 = img5;\n\t\tthis.img6 = img6;\n\t\tframes = 6;\n\t}\n\t//5 frame\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3, BufferedImage img4, BufferedImage img5){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tthis.img4 = img4;\n\t\tthis.img5 = img5;\n\t\tframes = 5;\n\t}\n\t//4 frame\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3, BufferedImage img4){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tthis.img4 = img4;\n\t\tframes = 4;\n\t}\n\t//3 frame\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2, BufferedImage img3){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tthis.img3 = img3;\n\t\tframes = 3;\n\t}\n\t//2 frame\n\tpublic Animation(int speed, BufferedImage img1, BufferedImage img2){\n\t\tthis.speed = speed;\n\t\tthis.img1 = img1;\n\t\tthis.img2 = img2;\n\t\tframes = 2;\n\t}\n\t\n\tpublic void runAnimation(){\n\t\tindex++;\n\t\tif(index > speed){\n\t\t\tindex = 0;\n\t\t\tnextFrame();\n\t\t}\t\n\t}\n\t\n\tpublic void nextFrame(){\n\t\t\n\t\t//switch statement\n\t\tswitch(frames){\n\t\tcase 2:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\t\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\tif(count == 3)\n\t\t\t\tcurrentImg = img4;\n\t\t\t\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\tif(count == 3)\n\t\t\t\tcurrentImg = img4;\n\t\t\tif(count == 4)\n\t\t\t\tcurrentImg = img5;\n\t\t\t\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\tif(count == 3)\n\t\t\t\tcurrentImg = img4;\n\t\t\tif(count == 4)\n\t\t\t\tcurrentImg = img5;\n\t\t\tif(count == 5)\n\t\t\t\tcurrentImg = img6;\n\t\t\t\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\tif(count == 3)\n\t\t\t\tcurrentImg = img4;\n\t\t\tif(count == 4)\n\t\t\t\tcurrentImg = img5;\n\t\t\tif(count == 5)\n\t\t\t\tcurrentImg = img6;\n\t\t\tif(count == 6)\n\t\t\t\tcurrentImg = img7;\n\t\t\t\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\tif(count == 3)\n\t\t\t\tcurrentImg = img4;\n\t\t\tif(count == 4)\n\t\t\t\tcurrentImg = img5;\n\t\t\tif(count == 5)\n\t\t\t\tcurrentImg = img6;\n\t\t\tif(count == 6)\n\t\t\t\tcurrentImg = img7;\n\t\t\tif(count == 7)\n\t\t\t\tcurrentImg = img8;\n\t\t\t\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\tif(count == 3)\n\t\t\t\tcurrentImg = img4;\n\t\t\tif(count == 4)\n\t\t\t\tcurrentImg = img5;\n\t\t\tif(count == 5)\n\t\t\t\tcurrentImg = img6;\n\t\t\tif(count == 6)\n\t\t\t\tcurrentImg = img7;\n\t\t\tif(count == 7)\n\t\t\t\tcurrentImg = img8;\n\t\t\tif(count == 8)\n\t\t\t\tcurrentImg = img9;\n\t\t\t\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\t\n\t\tcase 10:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\tif(count == 3)\n\t\t\t\tcurrentImg = img4;\n\t\t\tif(count == 4)\n\t\t\t\tcurrentImg = img5;\n\t\t\tif(count == 5)\n\t\t\t\tcurrentImg = img6;\n\t\t\tif(count == 6)\n\t\t\t\tcurrentImg = img7;\n\t\t\tif(count == 7)\n\t\t\t\tcurrentImg = img8;\n\t\t\tif(count == 8)\n\t\t\t\tcurrentImg = img9;\n\t\t\tif(count == 9)\n\t\t\t\tcurrentImg = img10;\n\t\t\t\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\tif(count == 3)\n\t\t\t\tcurrentImg = img4;\n\t\t\tif(count == 4)\n\t\t\t\tcurrentImg = img5;\n\t\t\tif(count == 5)\n\t\t\t\tcurrentImg = img6;\n\t\t\tif(count == 6)\n\t\t\t\tcurrentImg = img7;\n\t\t\tif(count == 7)\n\t\t\t\tcurrentImg = img8;\n\t\t\tif(count == 8)\n\t\t\t\tcurrentImg = img9;\n\t\t\tif(count == 9)\n\t\t\t\tcurrentImg = img10;\n\t\t\tif(count == 10)\n\t\t\t\tcurrentImg = img11;\n\t\t\t\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\tif(count == 3)\n\t\t\t\tcurrentImg = img4;\n\t\t\tif(count == 4)\n\t\t\t\tcurrentImg = img5;\n\t\t\tif(count == 5)\n\t\t\t\tcurrentImg = img6;\n\t\t\tif(count == 6)\n\t\t\t\tcurrentImg = img7;\n\t\t\tif(count == 7)\n\t\t\t\tcurrentImg = img8;\n\t\t\tif(count == 8)\n\t\t\t\tcurrentImg = img9;\n\t\t\tif(count == 9)\n\t\t\t\tcurrentImg = img10;\n\t\t\tif(count == 10)\n\t\t\t\tcurrentImg = img11;\n\t\t\tif(count == 11)\n\t\t\t\tcurrentImg = img12;\n\t\t\t\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\tif(count == 3)\n\t\t\t\tcurrentImg = img4;\n\t\t\tif(count == 4)\n\t\t\t\tcurrentImg = img5;\n\t\t\tif(count == 5)\n\t\t\t\tcurrentImg = img6;\n\t\t\tif(count == 6)\n\t\t\t\tcurrentImg = img7;\n\t\t\tif(count == 7)\n\t\t\t\tcurrentImg = img8;\n\t\t\tif(count == 8)\n\t\t\t\tcurrentImg = img9;\n\t\t\tif(count == 9)\n\t\t\t\tcurrentImg = img10;\n\t\t\tif(count == 10)\n\t\t\t\tcurrentImg = img11;\n\t\t\tif(count == 11)\n\t\t\t\tcurrentImg = img12;\n\t\t\tif(count == 12)\n\t\t\t\tcurrentImg = img13;\n\t\t\t\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\tif(count == 3)\n\t\t\t\tcurrentImg = img4;\n\t\t\tif(count == 4)\n\t\t\t\tcurrentImg = img5;\n\t\t\tif(count == 5)\n\t\t\t\tcurrentImg = img6;\n\t\t\tif(count == 6)\n\t\t\t\tcurrentImg = img7;\n\t\t\tif(count == 7)\n\t\t\t\tcurrentImg = img8;\n\t\t\tif(count == 8)\n\t\t\t\tcurrentImg = img9;\n\t\t\tif(count == 9)\n\t\t\t\tcurrentImg = img10;\n\t\t\tif(count == 10)\n\t\t\t\tcurrentImg = img11;\n\t\t\tif(count == 11)\n\t\t\t\tcurrentImg = img12;\n\t\t\tif(count == 12)\n\t\t\t\tcurrentImg = img13;\n\t\t\tif(count == 13)\n\t\t\t\tcurrentImg = img14;\n\t\t\t\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\tif(count == 3)\n\t\t\t\tcurrentImg = img4;\n\t\t\tif(count == 4)\n\t\t\t\tcurrentImg = img5;\n\t\t\tif(count == 5)\n\t\t\t\tcurrentImg = img6;\n\t\t\tif(count == 6)\n\t\t\t\tcurrentImg = img7;\n\t\t\tif(count == 7)\n\t\t\t\tcurrentImg = img8;\n\t\t\tif(count == 8)\n\t\t\t\tcurrentImg = img9;\n\t\t\tif(count == 9)\n\t\t\t\tcurrentImg = img10;\n\t\t\tif(count == 10)\n\t\t\t\tcurrentImg = img11;\n\t\t\tif(count == 11)\n\t\t\t\tcurrentImg = img12;\n\t\t\tif(count == 12)\n\t\t\t\tcurrentImg = img13;\n\t\t\tif(count == 13)\n\t\t\t\tcurrentImg = img14;\n\t\t\tif(count == 14)\n\t\t\t\tcurrentImg = img15;\n\t\t\t\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tif(count == 0)\n\t\t\t\tcurrentImg = img1;\n\t\t\tif(count == 1)\n\t\t\t\tcurrentImg = img2;\n\t\t\tif(count == 2)\n\t\t\t\tcurrentImg = img3;\n\t\t\tif(count == 3)\n\t\t\t\tcurrentImg = img4;\n\t\t\tif(count == 4)\n\t\t\t\tcurrentImg = img5;\n\t\t\tif(count == 5)\n\t\t\t\tcurrentImg = img6;\n\t\t\tif(count == 6)\n\t\t\t\tcurrentImg = img7;\n\t\t\tif(count == 7)\n\t\t\t\tcurrentImg = img8;\n\t\t\tif(count == 8)\n\t\t\t\tcurrentImg = img9;\n\t\t\tif(count == 9)\n\t\t\t\tcurrentImg = img10;\n\t\t\tif(count == 10)\n\t\t\t\tcurrentImg = img11;\n\t\t\tif(count == 11)\n\t\t\t\tcurrentImg = img12;\n\t\t\tif(count == 12)\n\t\t\t\tcurrentImg = img13;\n\t\t\tif(count == 13)\n\t\t\t\tcurrentImg = img14;\n\t\t\tif(count == 14)\n\t\t\t\tcurrentImg = img15;\n\t\t\tif(count == 15)\n\t\t\t\tcurrentImg = img16;\t\n\t\t\tif(count == 16)\n\t\t\t\tcurrentImg = img17;\n\t\t\tif(count == 17)\n\t\t\t\tcurrentImg = img18;\n\t\t\tif(count == 18)\n\t\t\t\tcurrentImg = img19;\n\t\t\tif(count == 19)\n\t\t\t\tcurrentImg = img20;\n\n\t\t\tcount++;\n\t\t\t\n\t\t\tif(count > frames)\n\t\t\t\tcount = 0;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tpublic void drawAnimation(Graphics g, double x, double y, int offset){\n\t\tg.drawImage(currentImg, (int)x - offset, (int)y, null);\n\t}\n\t\n\tpublic void setCount(int count){\n\t\tthis.count = count;\n\t}\n\tpublic int getCount(){\n\t\treturn count;\n\t}\n\tpublic int getSpeed(){\n\t\treturn speed;\n\t}\n\tpublic void setSpeed(int speed){\n\t\tthis.speed = speed;\n\t}\n\t\n}\n\n\n",
      "Crate.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Crate extends GameObject {\n\n    Game game;\n    private BufferedImage crateImage;\n    private String type;\n    \n\n    public Crate(float x, float y, ID id, String type, Game game) {\n        super(x, y, id);\n        this.type = type;\n        this.game = game;\n\n        BufferedImageLoader loader = new BufferedImageLoader();\n        if(this.type.equals(\"Rifle Ammo\")){\n            SpriteSheet weapones = new SpriteSheet(loader.loadImage(\"./Resources/Weapones/weapones.png\"));\n            crateImage = scaleImage(weapones.grabImage(2, 3, 32, 17), 28, 20);\n        }else if(this.type.equals(\"Shotgun Ammo\")){\n            crateImage = scaleImage(loader.loadImage(\"./Resources/healthandammo/32px/ammo-shotgun.png\"), 20, 20);\n        }else if(this.type.equals(\"Sniper Ammo\")){\n            crateImage = scaleImage(loader.loadImage(\"./Resources/healthandammo/32px/ammo-sniper.png\"), 20, 20);\n        }else if(this.type.equals(\"Rocket Ammo\")){\n            SpriteSheet weapones = new SpriteSheet(loader.loadImage(\"./Resources/Weapones/weapones.png\"));\n            crateImage = scaleImage(weapones.grabImage(4, 5, 28, 16), 30, 20);\n        }else if(this.type.equals(\"Major Health\")){\n            crateImage = scaleImage(loader.loadImage(\"./Resources/healthandammo/32px/health-red.png\"), 20, 20);\n        }else{ // Minor Health\n            crateImage = scaleImage(loader.loadImage(\"./Resources/healthandammo/32px/health-green.png\"), 20, 20);\n        }\n\n    }\n\n    public void tick() {}\n\n    public void render(Graphics g) {\n        g.drawImage(crateImage, (int)x, (int)y, null);\n\n        if(game.isDebug()) {\n            g.setColor(Color.red);\n            Rectangle bounds = getBounds();\n            g.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);\n        }\n    }\n\n    public Rectangle getBounds() {\n        if(this.type.equals(\"Rifle Ammo\")){\n            return new Rectangle((int)x, (int)y+1, 20, 15);\n        }else if(this.type.equals(\"Shotgun Ammo\")){\n            return new Rectangle((int)x+4, (int)y+4, 12, 13);\n        }else if(this.type.equals(\"Sniper Ammo\")){\n            return new Rectangle((int)x+4, (int)y+4, 12, 13);\n        }else if(this.type.equals(\"Rocket Ammo\")){\n            return new Rectangle((int)x, (int)y+4, 22, 10);\n        }else if(this.type.equals(\"Major Health\")){\n            return new Rectangle((int)x+5, (int)y+5, 11, 11);\n        }else { // Minor Health\n            return new Rectangle((int)x+5, (int)y+5, 11, 11);\n        }\n    }\n\n    private BufferedImage scaleImage(BufferedImage original, int width, int height) {\n        BufferedImage scaled = new BufferedImage(width, height, original.getType());\n        Graphics2D g2d = scaled.createGraphics();\n        g2d.drawImage(original, 0, 0, width, height, null);\n        g2d.dispose();\n        return scaled;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n}\n",
      "Player.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.util.Iterator;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class Player extends GameObject {\n\n    Handler handler;\n    Game game;\n    Animation feetForward;\n    Animation feetBackward;\n    Animation feetLeft;\n    Animation feetRight;\n    Animation meleeStrike;\n    Animation pistolShoot;\n    Animation pistolReload;\n    Animation pistolMove;\n    Animation pistolIdle;\n    Animation rifleShoot;\n    Animation rifleReload;\n    Animation rifleMove;\n    Animation rifleIdle;\n    Animation shotgunShoot;\n    Animation shotgunReload;\n    Animation shotgunMove;\n    Animation shotgunIdle;\n    BufferedImage feetIdle;\n    String movingDirection = \"down\";\n    String lookingDirection = \"down\";\n    private long lastMeleeStrikeTime = 0;\n    Rectangle meleeHitbox; \n    protected int centerX = (int)x + 16;\n    protected int centerY = (int)y + 24;\n\n    public Player(float x, float y, ID id, Handler handler, Game game) {\n        super(x, y, id);\n        this.handler = handler;\n        this.game = game;\n        \n        { // ANIMATIONS\n            BufferedImageLoader loader = new BufferedImageLoader();\n\n            BufferedImage[] feetForward = new BufferedImage[20];\n            for (int i = 0; i < feetForward.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/feet/run/survivor-run_\" + (i) + \".png\");\n                feetForward[i] = scaleImage(original, 24, 24);\n            }\n\n            BufferedImage[] feetBackward = new BufferedImage[20];\n            for (int i = 0; i < feetBackward.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/feet/run/survivor-run_\" + (19 - i) + \".png\");\n                feetBackward[i] = scaleImage(original, 24, 24);\n            }\n\n            BufferedImage[] feetLeft = new BufferedImage[20];\n            for (int i = 0; i < feetLeft.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/feet/strafe_left/survivor-strafe_left_\" + (i) + \".png\");\n                feetLeft[i] = scaleImage(original, 24, 24);\n            }\n\n            BufferedImage[] feetRight = new BufferedImage[20];\n            for (int i = 0; i < feetRight.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/feet/strafe_right/survivor-strafe_right_\" + (i) + \".png\");\n                feetRight[i] = scaleImage(original, 24, 24);\n            }\n\n            BufferedImage[] meleeStrike = new BufferedImage[15];\n            for (int i = 0; i < meleeStrike.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/knife/meleeattack/survivor-meleeattack_knife_\" + (i) + \".png\");\n                meleeStrike[i] = scaleImage(original, 42, 42);\n            }\n\n            BufferedImage[] pistolMove = new BufferedImage[20];\n            for (int i = 0; i < pistolMove.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/handgun/move/survivor-move_handgun_\" + (i) + \".png\");\n                pistolMove[i] = scaleImage(original, 32, 32);\n            }\n\n            BufferedImage[] pistolReload = new BufferedImage[15];\n            for (int i = 0; i < pistolReload.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/handgun/reload/survivor-reload_handgun_\" + (i) + \".png\");\n                pistolReload[i] = scaleImage(original, 32, 32);\n            }\n\n            BufferedImage[] pistolShoot = new BufferedImage[3];\n            for (int i = 0; i < pistolShoot.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/handgun/shoot/survivor-shoot_handgun_\" + (i) + \".png\");\n                pistolShoot[i] = scaleImage(original, 32, 32);\n            }\n\n            BufferedImage[] pistolIdle = new BufferedImage[20];\n            for (int i = 0; i < pistolIdle.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/handgun/idle/survivor-idle_handgun_\" + (i) + \".png\");\n                pistolIdle[i] = scaleImage(original, 32, 32);\n            }\n\n            BufferedImage[] rifleMove = new BufferedImage[20];\n            for (int i = 0; i < rifleMove.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/rifle/move/survivor-move_rifle_\" + (i) + \".png\");\n                rifleMove[i] = scaleImage(original, 32, 32);\n            }\n\n            BufferedImage[] rifleReload = new BufferedImage[15];\n            for (int i = 0; i < rifleReload.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/rifle/reload/survivor-reload_rifle_\" + (i) + \".png\");\n                rifleReload[i] = scaleImage(original, 32, 32);\n            }\n\n            BufferedImage[] rifleShoot = new BufferedImage[3];\n            for (int i = 0; i < rifleShoot.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/rifle/shoot/survivor-shoot_rifle_\" + (i) + \".png\");\n                rifleShoot[i] = scaleImage(original, 32, 32);\n            }\n\n            BufferedImage[] rifleIdle = new BufferedImage[20];\n            for (int i = 0; i < rifleIdle.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/rifle/idle/survivor-idle_rifle_\" + (i) + \".png\");\n                rifleIdle[i] = scaleImage(original, 32, 32);\n            }\n\n            BufferedImage[] shotgunMove = new BufferedImage[20];\n            for (int i = 0; i < shotgunMove.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/shotgun/move/survivor-move_shotgun_\" + (i) + \".png\");\n                shotgunMove[i] = scaleImage(original, 32, 32);\n            }\n\n            BufferedImage[] shotgunReload = new BufferedImage[15];\n            for (int i = 0; i < shotgunReload.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/shotgun/reload/survivor-reload_shotgun_\" + (i) + \".png\");\n                shotgunReload[i] = scaleImage(original, 32, 32);\n            }\n\n            BufferedImage[] shotgunShoot = new BufferedImage[3];\n            for (int i = 0; i < shotgunShoot.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/shotgun/shoot/survivor-shoot_shotgun_\" + (i) + \".png\");\n                shotgunShoot[i] = scaleImage(original, 32, 32);\n            }\n\n            BufferedImage[] shotgunIdle = new BufferedImage[20];\n            for (int i = 0; i < shotgunIdle.length; i++) {\n                BufferedImage original = loader.loadImage(\"./Resources/playerAssets/shotgun/idle/survivor-idle_shotgun_\" + (i) + \".png\");\n                shotgunIdle[i] = scaleImage(original, 32, 32);\n            }\n\n            feetIdle = loader.loadImage(\"./Resources/playerAssets/feet/idle/survivor-idle_0.png\");\n            feetIdle = scaleImage(feetIdle, 24, 24);\n\n            this.feetForward = new Animation(3, feetForward[0], feetForward[1], feetForward[2], feetForward[3], feetForward[4], feetForward[5], feetForward[6], feetForward[7], feetForward[8], feetForward[9], feetForward[10], feetForward[11], feetForward[12], feetForward[13], feetForward[14], feetForward[15], feetForward[16], feetForward[17], feetForward[18], feetForward[19]);\n            this.feetBackward = new Animation(3, feetBackward[0], feetBackward[1], feetBackward[2], feetBackward[3], feetBackward[4], feetBackward[5], feetBackward[6], feetBackward[7], feetBackward[8], feetBackward[9], feetBackward[10], feetBackward[11], feetBackward[12], feetBackward[13], feetBackward[14], feetBackward[15], feetBackward[16], feetBackward[17], feetBackward[18], feetBackward[19]);\n            this.feetLeft = new Animation(3, feetLeft[0], feetLeft[1], feetLeft[2], feetLeft[3], feetLeft[4], feetLeft[5], feetLeft[6], feetLeft[7], feetLeft[8], feetLeft[9], feetLeft[10], feetLeft[11], feetLeft[12], feetLeft[13], feetLeft[14], feetLeft[15], feetLeft[16], feetLeft[17], feetLeft[18], feetLeft[19]);\n            this.feetRight = new Animation(3, feetRight[0], feetRight[1], feetRight[2], feetRight[3], feetRight[4], feetRight[5], feetRight[6], feetRight[7], feetRight[8], feetRight[9], feetRight[10], feetRight[11], feetRight[12], feetRight[13], feetRight[14], feetRight[15], feetRight[16], feetRight[17], feetRight[18], feetRight[19]);\n            this.pistolMove = new Animation(3, pistolMove[0], pistolMove[1], pistolMove[2], pistolMove[3], pistolMove[4], pistolMove[5], pistolMove[6], pistolMove[7], pistolMove[8], pistolMove[9], pistolMove[10], pistolMove[11], pistolMove[12], pistolMove[13], pistolMove[14], pistolMove[15], pistolMove[16], pistolMove[17], pistolMove[18], pistolMove[19]);\n            this.pistolReload = new Animation(3, pistolReload[0], pistolReload[1], pistolReload[2], pistolReload[3], pistolReload[4], pistolReload[5], pistolReload[6], pistolReload[7], pistolReload[8], pistolReload[9], pistolReload[10], pistolReload[11], pistolReload[12], pistolReload[13], pistolReload[14]);\n            this.pistolShoot = new Animation(2, pistolShoot[0], pistolShoot[1], pistolShoot[2]);\n            this.pistolIdle = new Animation(3, pistolIdle[0], pistolIdle[1], pistolIdle[2], pistolIdle[3], pistolIdle[4], pistolIdle[5], pistolIdle[6], pistolIdle[7], pistolIdle[8], pistolIdle[9], pistolIdle[10], pistolIdle[11], pistolIdle[12], pistolIdle[13], pistolIdle[14], pistolIdle[15], pistolIdle[16], pistolIdle[17], pistolIdle[18], pistolIdle[19]);\n            this.rifleMove = new Animation(3, rifleMove[0], rifleMove[1], rifleMove[2], rifleMove[3], rifleMove[4], rifleMove[5], rifleMove[6], rifleMove[7], rifleMove[8], rifleMove[9], rifleMove[10], rifleMove[11], rifleMove[12], rifleMove[13], rifleMove[14], rifleMove[15], rifleMove[16], rifleMove[17], rifleMove[18], rifleMove[19]);\n            this.rifleReload = new Animation(5, rifleReload[0], rifleReload[1], rifleReload[2], rifleReload[3], rifleReload[4], rifleReload[5], rifleReload[6], rifleReload[7], rifleReload[8], rifleReload[9], rifleReload[10], rifleReload[11], rifleReload[12], rifleReload[13], rifleReload[14]);\n            this.rifleShoot = new Animation(2, rifleShoot[0], rifleShoot[1], rifleShoot[2]);\n            this.rifleIdle = new Animation(3, rifleIdle[0], rifleIdle[1], rifleIdle[2], rifleIdle[3], rifleIdle[4], rifleIdle[5], rifleIdle[6], rifleIdle[7], rifleIdle[8], rifleIdle[9], rifleIdle[10], rifleIdle[11], rifleIdle[12], rifleIdle[13], rifleIdle[14], rifleIdle[15], rifleIdle[16], rifleIdle[17], rifleIdle[18], rifleIdle[19]);\n            this.shotgunMove = new Animation(3, shotgunMove[0], shotgunMove[1], shotgunMove[2], shotgunMove[3], shotgunMove[4], shotgunMove[5], shotgunMove[6], shotgunMove[7], shotgunMove[8], shotgunMove[9], shotgunMove[10], shotgunMove[11], shotgunMove[12], shotgunMove[13], shotgunMove[14], shotgunMove[15], shotgunMove[16], shotgunMove[17], shotgunMove[18], shotgunMove[19]);\n            this.shotgunReload = new Animation(6, shotgunReload[0], shotgunReload[1], shotgunReload[2], shotgunReload[3], shotgunReload[4], shotgunReload[5], shotgunReload[6], shotgunReload[7], shotgunReload[8], shotgunReload[9], shotgunReload[10], shotgunReload[11], shotgunReload[12], shotgunReload[13], shotgunReload[14]);\n            this.shotgunShoot = new Animation(2, shotgunShoot[0], shotgunShoot[1], shotgunShoot[2]);\n            this.shotgunIdle = new Animation(3, shotgunIdle[0], shotgunIdle[1], shotgunIdle[2], shotgunIdle[3], shotgunIdle[4], shotgunIdle[5], shotgunIdle[6], shotgunIdle[7], shotgunIdle[8], shotgunIdle[9], shotgunIdle[10], shotgunIdle[11], shotgunIdle[12], shotgunIdle[13], shotgunIdle[14], shotgunIdle[15], shotgunIdle[16], shotgunIdle[17], shotgunIdle[18], shotgunIdle[19]);\n            this.meleeStrike = new Animation(1, meleeStrike[0], meleeStrike[1], meleeStrike[2], meleeStrike[3], meleeStrike[4], meleeStrike[5], meleeStrike[6], meleeStrike[7], meleeStrike[8], meleeStrike[9], meleeStrike[10], meleeStrike[11], meleeStrike[12], meleeStrike[13], meleeStrike[14]);\n        }\n    }\n    \n    public void tick() {\n        int speed = 5;\n        velX = 0;\n        velY = 0;\n\n        if (handler.isUp())    velY = -speed;\n        if (handler.isDown())  velY =  speed;\n        if (handler.isLeft())  velX = -speed;\n        if (handler.isRight()) velX =  speed;\n        if(handler.isUp() && handler.isDown()) velY = 0;\n        if(handler.isLeft() && handler.isRight()) velX = 0;\n\n        float oldX = x;\n        x += velX;\n\n        if (collides()) {\n            x = oldX;\n        }\n\n        float oldY = y;\n        y += velY;\n\n        if (collides()) {\n            y = oldY;\n        }\n\n        handleCrateAndEnemyCollision();\n\n        if (velX > 0) {\n            movingDirection = \"right\";\n        } else if (velX < 0) {\n            movingDirection = \"left\";\n        } else if (velY > 0) {\n            movingDirection = \"down\";\n        } else if (velY < 0) {\n            movingDirection = \"up\";\n        }\n        \n        // ---------------------- ANIMATIONS ----------------------\n        \n        // ************************** Feet\n        int centerX = (int)x + 16;\n        int centerY = (int)y + 24;\n        \n        int mx = handler.getCurrentMX();\n        int my = handler.getCurrentMY();\n\n        double angle = Math.atan2(my - centerY, mx - centerX); \n        double angleDeg = Math.toDegrees(angle);               \n        if (angleDeg < 0) {\n            angleDeg += 360;                                  \n        }\n\n        if (angleDeg >= 315 || angleDeg < 45) { // Looking right\n            lookingDirection = \"right\";\n            switch (movingDirection) {\n                case \"right\": feetForward.runAnimation(); break;\n                case \"left\": feetBackward.runAnimation(); break;\n                case \"up\": feetLeft.runAnimation(); break;\n                case \"down\": feetRight.runAnimation(); break;\n            }\n        } \n        else if (angleDeg < 135) { // Looking up\n            lookingDirection = \"down\";\n            switch (movingDirection) {\n                case \"right\": feetRight.runAnimation(); break;\n                case \"left\": feetLeft.runAnimation(); break;\n                case \"up\": feetForward.runAnimation(); break;\n                case \"down\": feetBackward.runAnimation(); break;\n            }\n        } \n        else if (angleDeg < 225) { // Looking left\n            lookingDirection = \"left\";\n            switch (movingDirection) {\n                case \"right\": feetBackward.runAnimation(); break;\n                case \"left\": feetForward.runAnimation(); break;\n                case \"up\": feetRight.runAnimation(); break;\n                case \"down\": feetLeft.runAnimation(); break;\n            }\n        } \n        else { // Looking down\n            lookingDirection = \"up\";\n            switch (movingDirection) {\n                case \"right\": feetLeft.runAnimation(); break;\n                case \"left\": feetRight.runAnimation(); break;\n                case \"up\": feetBackward.runAnimation(); break;\n                case \"down\": feetForward.runAnimation(); break;\n            }\n        }\n        // **************************\n        \n        // ************************** Arms\n        if(game.isMeleeStrike()){\n            meleeStrike.runAnimation();\n            meleeAttack();\n        }\n        else {\n            if(velX == 0 && velY == 0){\n                if(game.getWeapon().equals(\"Pistol\")){\n                    if(handler.isShooting()){\n                        pistolShoot.runAnimation();\n                    }\n                    else if(game.isReloading()){\n                        pistolReload.runAnimation();\n                    }\n                    else{\n                        pistolIdle.runAnimation();\n                    }\n                }\n                if(game.getWeapon().equals(\"Assault Rifle\")|| game.getWeapon().equals(\"Sniper\")){\n                    if (handler.isAutoShooting()) {\n                        rifleShoot.runAnimation();   \n                    }\n                    else if(game.isReloading()){\n                        rifleReload.runAnimation();\n                    }\n                    else{\n                        rifleIdle.runAnimation();\n                    }\n                }\n                if(game.getWeapon().equals(\"Shotgun\") || game.getWeapon().equals(\"Rocket Launcher\")){\n                    if(handler.isShooting()){\n                        shotgunShoot.runAnimation();\n                    }\n                    else if(game.isReloading()){\n                        shotgunReload.runAnimation();\n                    }\n                    else{\n                        shotgunIdle.runAnimation();\n                    }\n                }\n            }else{\n                if(game.getWeapon().equals(\"Pistol\")){\n                    if(handler.isShooting()){\n                        pistolShoot.runAnimation();\n                    }\n                    else if(game.isReloading()){\n                        pistolReload.runAnimation();\n                    }\n                    else{\n                        pistolMove.runAnimation();\n                    }\n                }\n                if(game.getWeapon().equals(\"Assault Rifle\")|| game.getWeapon().equals(\"Sniper\")){\n                    if (handler.isAutoShooting()) {\n                        rifleShoot.runAnimation(); \n                    }\n                    else if(game.isReloading()){\n                        rifleReload.runAnimation();\n                    }\n                    else{\n                        rifleMove.runAnimation();\n                    }\n                }\n                if(game.getWeapon().equals(\"Shotgun\") || game.getWeapon().equals(\"Rocket Launcher\")){\n                    if(handler.isShooting()){\n                        shotgunShoot.runAnimation();\n                    }\n                    else if(game.isReloading()){\n                        shotgunReload.runAnimation();\n                    }\n                    else{\n                        shotgunMove.runAnimation();\n                    }\n                }\n            }\n        }\n        // **************************\n        // --------------------------------------------------------\n\n        if(game.hp <= 0) {\n            handler.removeObject(this);\n        }\n    }\n\n    private boolean collides() {\n        for (GameObject tempObject : handler.object) {\n            if (tempObject.getID() == ID.Block) {\n                if (getBounds().intersects(tempObject.getBounds())) {\n                    return true;\n                }\n            }\n        }\n        for (GameObject tempObject : handler.object) {\n            if (tempObject.getID() == ID.Bullet && ((Bullet)tempObject).target.equals(\"Player\")) {\n                if (getBounds().intersects(tempObject.getBounds())) {\n                    handler.removeObject(tempObject);\n                    takeDamage(Enemy.getBANDIT_SHOOTING_DAMAGE());\n                }\n            }\n        }\n        return false;\n    }\n\n    private void handleCrateAndEnemyCollision() {\n        Iterator<GameObject> iterator = handler.object.iterator();\n        while (iterator.hasNext()) {\n            GameObject tempObject = iterator.next();\n            if (tempObject.getID() == ID.Crate && getBounds().intersects(tempObject.getBounds())) {\n                \n                if(((Crate)tempObject).getType().equals(\"Major Health\")){\n                    game.hp += game.getMAJOR_HEALTH();\n                    if(game.hp > game.getMAX_HEALTH()) { game.hp = game.getMAX_HEALTH(); }\n                }else if(((Crate)tempObject).getType().equals(\"Minor Health\")){\n                    game.hp += game.getMINOR_HEALTH();\n                    if(game.hp > game.getMAX_HEALTH()) { game.hp = game.getMAX_HEALTH(); }\n                }else if(((Crate)tempObject).getType().equals(\"Rifle Ammo\")){\n                    int randomNum = ThreadLocalRandom.current().nextInt(0, 101);\n                    game.rifleAmmoBackup += randomNum;\n                }else if(((Crate)tempObject).getType().equals(\"Shotgun Ammo\")){\n                    int randomNum = ThreadLocalRandom.current().nextInt(0, 26);\n                    game.shotgunAmmoBackup += randomNum;\n                }else if(((Crate)tempObject).getType().equals(\"Sniper Ammo\")){\n                    int randomNum = ThreadLocalRandom.current().nextInt(0, 26);\n                    game.sniperAmmoBackup += randomNum;\n                }else{ // Rocket Ammo\n                    int randomNum = ThreadLocalRandom.current().nextInt(0, 6);\n                    game.rocketAmmoBackup += randomNum;\n                }\n\n                handler.removeObject(tempObject); \n            }\n            else if (tempObject.getID() == ID.Enemy) {\n                if (!((Enemy)tempObject).isDying()) {\n                    if (getBounds().intersects(((Enemy)tempObject).contactBoundWithPlayer())) {\n                        ((Enemy)tempObject).attack();\n                    }\n                }\n            }\n        }\n    }\n\n    public void render(Graphics g) {\n        drawFeet(g);\n        drawArms(g);\n\n        if(game.isDebug()) {\n            g.setColor(Color.red);\n            Rectangle bounds = getBounds();\n            g.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);\n\n            if(meleeHitbox != null){\n                g.setColor(Color.cyan);\n                g.drawRect(meleeHitbox.x, meleeHitbox.y, meleeHitbox.width, meleeHitbox.height);\n            }\n\n            g.setColor(Color.blue);\n            if(lookingDirection.equals(\"up\")){\n                g.drawRect((int)x + 17, (int)y + 26, 2, 2);\n            }else if(lookingDirection.equals(\"down\")){\n                g.drawRect((int)x + 12, (int)y + 20, 2, 2);\n            }else if(lookingDirection.equals(\"right\")){\n                g.drawRect((int)x + 13, (int)y + 24, 2, 2);\n            }else{ // left\n                g.drawRect((int)x + 16, (int)y + 21, 2, 2);\n            }\n        }\n    }\n    \n    private void drawFeet(Graphics g) {\n        Graphics2D g2d = (Graphics2D) g.create();\n        \n        int centerX = (int)x + 16;\n        int centerY = (int)y + 24;\n        \n        int mx = handler.getCurrentMX();\n        int my = handler.getCurrentMY();\n\n        double angle = Math.atan2(my - centerY, mx - centerX); \n        double angleDeg = Math.toDegrees(angle);               \n        if (angleDeg < 0) {\n            angleDeg += 360;                                  \n        }\n        \n        g2d.translate(centerX, centerY);\n        if (angleDeg >= 315 || angleDeg < 45) { // Looking right\n            g2d.rotate(Math.toRadians(0));\n        } \n        else if (angleDeg < 135) { // Looking up\n            g2d.rotate(Math.toRadians(90));\n        } \n        else if (angleDeg < 225) { // Looking left\n            g2d.rotate(Math.toRadians(180));\n        } \n        else { // Looking down\n            g2d.rotate(Math.toRadians(270));\n        }\n\n        if (velX == 0 && velY == 0) {\n            g2d.drawImage(feetIdle, -16, -10, null);\n            g2d.dispose();\n            return;\n        }\n\n        if (angleDeg >= 315 || angleDeg < 45) { // Looking right\n            switch (movingDirection) {\n                case \"right\": feetForward.drawAnimation(g2d, -16, -10, 0); break;\n                case \"left\": feetBackward.drawAnimation(g2d, -16, -10, 0); break;\n                case \"up\": feetLeft.drawAnimation(g2d, -16, -10, 0); break;\n                case \"down\": feetRight.drawAnimation(g2d, -16, -10, 0); break;\n            }\n        } \n        else if (angleDeg < 135) { // Looking up\n            switch (movingDirection) {\n                case \"right\": feetRight.drawAnimation(g2d, -16, -10, 0); break;\n                case \"left\": feetLeft.drawAnimation(g2d, -16, -10, 0); break;\n                case \"up\": feetForward.drawAnimation(g2d, -16, -10, 0); break;\n                case \"down\": feetBackward.drawAnimation(g2d, -16, -10, 0); break;\n            }\n        } \n        else if (angleDeg < 225) { // Looking left\n            switch (movingDirection) {\n                case \"right\": feetBackward.drawAnimation(g2d, -16, -10, 0); break;\n                case \"left\": feetForward.drawAnimation(g2d, -16, -10, 0); break;\n                case \"up\": feetRight.drawAnimation(g2d, -16, -10, 0); break;\n                case \"down\": feetLeft.drawAnimation(g2d, -16, -10, 0); break;\n            }\n        } \n        else { // Looking down\n            switch (movingDirection) {\n                case \"right\": feetLeft.drawAnimation(g2d, -16, -10, 0); break;\n                case \"left\": feetRight.drawAnimation(g2d, -16, -10, 0); break;\n                case \"up\": feetBackward.drawAnimation(g2d, -16, -10, 0); break;\n                case \"down\": feetForward.drawAnimation(g2d, -16, -10, 0); break;\n            }\n        }\n        g2d.dispose();\n    }\n\n    private void drawArms(Graphics g) {\n        Graphics2D g2d = (Graphics2D) g.create();\n        \n        centerX = (int)x + 16;\n        centerY = (int)y + 24;\n    \n        int mx = handler.getCurrentMX(); \n        int my = handler.getCurrentMY(); \n\n        double angle = Math.atan2(my - centerY, mx - centerX);\n    \n        g2d.translate(centerX, centerY);\n        g2d.rotate(angle);\n    \n        if(game.isMeleeStrike()){\n            meleeStrike.drawAnimation(g2d, -16, -16, 0);\n        }\n        else {\n            if (game.getWeapon().equals(\"Pistol\")) {\n                if (handler.isShooting()) {\n                    pistolShoot.drawAnimation(g2d, -16, -16, 0);\n                } else if (game.isReloading()) {\n                    pistolReload.drawAnimation(g2d, -16, -16, 0);\n                } else {\n                    pistolIdle.drawAnimation(g2d, -16, -16, 0);\n                }\n            }\n            else if(game.getWeapon().equals(\"Assault Rifle\") || game.getWeapon().equals(\"Sniper\")) {\n                if (handler.isAutoShooting()) {\n                    rifleShoot.drawAnimation(g2d, -16, -16, 0);\n                } else if (game.isReloading()) {\n                    rifleReload.drawAnimation(g2d, -16, -16, 0);\n                } else {\n                    rifleIdle.drawAnimation(g2d, -16, -16, 0);\n                }\n            }\n            else if(game.getWeapon().equals(\"Shotgun\") || game.getWeapon().equals(\"Rocket Launcher\")) {\n                if (handler.isShooting()) {\n                    shotgunShoot.drawAnimation(g2d, -16, -16, 0);\n                } else if (game.isReloading()) {\n                    shotgunReload.drawAnimation(g2d, -16, -16, 0);\n                } else {\n                    shotgunIdle.drawAnimation(g2d, -16, -16, 0);\n                }\n            }\n        }\n    \n        g2d.dispose();\n    }\n\n    public Rectangle getBounds() {\n        if(this.lookingDirection.equals(\"up\")){\n            return new Rectangle((int)x + 9, (int)y + 18, 20, 20);\n        }\n        else if(this.lookingDirection.equals(\"down\")){\n            return new Rectangle((int)x + 3, (int)y + 10, 20, 20);\n        }\n        else if(this.lookingDirection.equals(\"right\")){\n            return new Rectangle((int)x + 4, (int)y + 15, 20, 20);\n        }\n        else { // left\n            return new Rectangle((int)x + 8, (int)y + 11, 20, 20);\n        }\n    }  \n\n    private void meleeAttack() {\n        int attackWidth = 20; \n        int centerX;\n        int centerY;\n        switch (this.lookingDirection) {\n            case \"up\": centerX = (int)x + 19; centerY = (int)y + 28; break;\n            case \"down\": centerX = (int)x + 13; centerY = (int)y + 20; break;\n            case \"right\": centerX = (int)x + 14; centerY = (int)y + 25; break;\n            default: centerX = (int)x + 18; centerY = (int)y + 21; break; // left\n        }\n\n        int offset = 10;\n\n        int mx = handler.getCurrentMX();\n\n        if(this.lookingDirection.equals(\"up\")){\n            if(centerX + offset - mx < 0){ // RIGHT\n                this.meleeHitbox = new Rectangle(centerX+10, centerY-30, attackWidth, attackWidth);\n            }else if(centerX - offset - mx > 0){ // LEFT\n                this.meleeHitbox = new Rectangle(centerX-30, centerY-30, attackWidth, attackWidth);\n            }else{\n                this.meleeHitbox = new Rectangle(centerX-20, centerY-30, attackWidth+20, attackWidth);\n            }\n        }\n        else if(this.lookingDirection.equals(\"down\")){\n            if(centerX + offset - mx < 0){ // RIGHT\n                this.meleeHitbox = new Rectangle(centerX+10, centerY+10, attackWidth, attackWidth);\n            }else if(centerX - offset - mx > 0){ // LEFT\n                this.meleeHitbox = new Rectangle(centerX-30, centerY+10, attackWidth, attackWidth);\n            }else{\n                this.meleeHitbox = new Rectangle(centerX-20, centerY+10, attackWidth+20, attackWidth);\n            }\n        }\n        else if(this.lookingDirection.equals(\"right\")){\n            this.meleeHitbox = new Rectangle(centerX+10, centerY-20, attackWidth, attackWidth+20);\n        }\n        else { // left\n            this.meleeHitbox = new Rectangle(centerX-30, centerY-20, attackWidth, attackWidth+20);\n        }\n\n        long currentTime = System.currentTimeMillis();\n        if (currentTime - lastMeleeStrikeTime < game.getMELEE_STRIKE_RATE()) { \n            return; \n        }\n        lastMeleeStrikeTime = currentTime; \n\n        boolean hasHitEnemy = false;\n\n        for (GameObject obj : handler.object) {\n            if (obj.getID() == ID.Enemy && !hasHitEnemy) {\n                if (meleeHitbox.intersects(obj.getBounds())) {\n                    ((Enemy) obj).takeDamage(game.getMELEE_DAMAGE());\n                    hasHitEnemy = true;\n                }\n            }\n        }\n    }\n\n    public void takeDamage(int damage){\n        game.hp -= damage;\n    }\n\n    private BufferedImage scaleImage(BufferedImage original, int width, int height) {\n        BufferedImage scaled = new BufferedImage(width, height, original.getType());\n        Graphics2D g2d = scaled.createGraphics();\n        g2d.drawImage(original, 0, 0, width, height, null);\n        g2d.dispose();\n        return scaled;\n    }\n}\n\n\n\n",
      "GameObject.java": "import java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic abstract class GameObject {\n    \n    protected float x, y;\n    protected float velX = 0, velY = 0;\n    protected ID id;\n    protected boolean active;\n    \n    public GameObject(float x, float y, ID id) {\n        this.x = x;\n        this.y = y;\n        this.id = id;\n    }\n    \n    public abstract void tick();\n    public abstract void render(Graphics g);\n    public abstract Rectangle getBounds();\n    \n    public ID getID() { return id; }\n    public float getX() { return x; }\n    public float getY() { return y; }\n    public boolean isActive() { return active; }\n    public void setX(float x) { this.x = x; }\n    public void setY(float y) { this.y = y; }\n    public void setID(ID id) { this.id = id; }\n    public void setActive(boolean active) { this.active = active; }\n\n}\n",
      "._PauseMenu.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._PauseMenu.java",
      "._Enemy.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._Enemy.java",
      "._DeathMenu.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._DeathMenu.java",
      "._BufferedImageLoader.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._BufferedImageLoader.java",
      "._Animation.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._Animation.java",
      "._Explosion.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._Explosion.java",
      "._ID.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._ID.java",
      "._Camera.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._Camera.java",
      "._Frame.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._Frame.java",
      "._MainMenu.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._MainMenu.java",
      "._Bullet.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._Bullet.java",
      "._KeyInput.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._KeyInput.java",
      "._Spawner.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._Spawner.java",
      "._Game.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._Game.java",
      "._Player.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._Player.java",
      "._Crate.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._Crate.java",
      "._MouseInput.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._MouseInput.java",
      "._Wall.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._Wall.java",
      "._SaveAndLoad.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._SaveAndLoad.java",
      "._GameObject.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._GameObject.java",
      "._Handler.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._Handler.java",
      "._SpriteSheet.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._SpriteSheet.java",
      "._Floor.java": "Dosya okunamadı: Raw Data/Projects/BİL 211.2-2024Bahar-Proje-135083/İBRAHİM EREN YILMAZ_887643_assignsubmission_file_/__MACOSX/Files/._Floor.java"
    },
    {
      "id": "2112376",
      "Projectile.java": "\nimport java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class Projectile implements GameObject {\n    protected double x, y;\n    protected double velocityX, velocityY;\n    protected double speed;\n    protected int size;\n    protected int damage;\n    protected boolean active;\n    protected Color color;\n    \n    public Projectile(double x, double y, double angle, double speed, int size, int damage, Color color) {\n        this.x = x;\n        this.y = y;\n        this.speed = speed;\n        this.size = size;\n        this.damage = damage;\n        this.active = true;\n        this.color = color;\n        \n        \n        this.velocityX = Math.cos(angle) * speed;\n        this.velocityY = Math.sin(angle) * speed;\n    }\n    \n    @Override\n    public void update(double deltaTime) {\n        \n        x += velocityX * deltaTime;\n        y += velocityY * deltaTime;\n        \n        \n        if (x < -size || x > 800 + size || y < -size || y > 600 + size) {\n            active = false;\n        }\n    }\n    \n    @Override\n    public void render(Graphics2D g) {\n        if (!active) return;\n        \n        g.setColor(color);\n        g.fillOval((int)(x - size/2), (int)(y - size/2), size, size);\n    }\n    \n    public boolean isActive() {\n        return active;\n    }\n    \n    public void setActive(boolean active) {\n        this.active = active;\n    }\n    \n    public int getDamage() {\n        return damage;\n    }\n    \n    public java.awt.Rectangle getBounds() {\n        return new java.awt.Rectangle((int)(x - size/2), (int)(y - size/2), size, size);\n    }\n    \n    public double getX() {\n        return x;\n    }\n    \n    public double getY() {\n        return y;\n    }\n}\n\n",
      "Zombie.java": "\nimport java.awt.Graphics2D;\nimport java.util.List;\n\npublic abstract class Zombie extends Entity {\n    \n    protected double speed; \n    protected int damage; \n    protected Player target; \n    protected double attackCooldown = 0; \n    protected static final double ATTACK_COOLDOWN_TIME = 1.0; \n    protected GameState gameState; \n    \n    public Zombie(double x, double y, int width, int height, int health, double speed, int damage, GameState gameState) {\n        super(x, y, width, height, health);\n        this.speed = speed;\n        this.damage = damage;\n        this.gameState = gameState;\n        this.target = gameState.getPlayer();\n    }\n    \n    \n    public void setGameState(GameState gameState) {\n        this.gameState = gameState;\n        this.target = gameState.getPlayer();\n    }\n    \n    @Override\n    public void update(double deltaTime) {\n        if (!alive) return;\n        \n        \n        if (attackCooldown > 0) {\n            attackCooldown -= deltaTime;\n        }\n        \n        \n        if (target != null && target.isAlive()) {\n            moveTowardsTarget(deltaTime);\n        }\n        \n        \n        updateHitBox();\n        \n        \n        if (target != null && target.isAlive() && collidesWith(target)) {\n            if (attackCooldown <= 0) {\n                attackPlayer();\n                attackCooldown = ATTACK_COOLDOWN_TIME;\n            }\n        }\n    }\n    \n    protected void moveTowardsTarget(double deltaTime) {\n        moveTowardsTarget(deltaTime, 1.0);\n    }\n    \n    protected void moveTowardsTarget(double deltaTime, double speedMultiplier) {\n        \n        double dx = target.getX() + target.getWidth() / 2 - (x + width / 2);\n        double dy = target.getY() + target.getHeight() / 2 - (y + height / 2);\n        \n        \n        double length = Math.sqrt(dx * dx + dy * dy);\n        if (length > 0) {\n            dx = dx / length;\n            dy = dy / length;\n        }\n        \n        \n        velocityX = dx * speed * speedMultiplier;\n        velocityY = dy * speed * speedMultiplier;\n        \n        \n        double newX = x + velocityX * deltaTime;\n        double newY = y + velocityY * deltaTime;\n        \n        \n        if (target != null && target.getGameState() != null) {\n            List<Zombie> zombies = target.getGameState().getZombies();\n            boolean collisionX = false;\n            boolean collisionY = false;\n            \n            for (Zombie other : zombies) {\n                if (other != this && other.isAlive()) {\n                    \n                    if (wouldCollideWith(other, newX, y)) {\n                        collisionX = true;\n                    }\n                    if (wouldCollideWith(other, x, newY)) {\n                        collisionY = true;\n                    }\n                }\n            }\n            \n            \n            if (!collisionX) {\n                x = newX;\n            }\n            if (!collisionY) {\n                y = newY;\n            }\n        } else {\n            \n            x = newX;\n            y = newY;\n        }\n        \n        \n        if (x < -2000) x = -2000;\n        if (x > 2000 - width) x = 2000 - width;\n        if (y < -2000) y = -2000;\n        if (y > 2000 - height) y = 2000 - height;\n    }\n    \n    \n    protected boolean wouldCollideWith(Entity other, double testX, double testY) {\n        return testX < other.getX() + other.getWidth() &&\n               testX + width > other.getX() &&\n               testY < other.getY() + other.getHeight() &&\n               testY + height > other.getY();\n    }\n    \n    protected void attackPlayer() {\n        \n        target.takeDamage(damage);\n        System.out.println(this.getClass().getSimpleName() + \" attacked player for \" + damage + \" damage!\");\n    }\n    \n    \n    public abstract ZombieType getType();\n    \n    \n    public abstract void onDeath();\n    \n    \n    public double getSpeed() {\n        return speed;\n    }\n    \n    public int getDamage() {\n        return damage;\n    }\n    \n    \n    public void render(Graphics2D g) {\n        \n    }\n}\n\n",
      "Entity.java": "\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\n\npublic abstract class Entity implements GameObject {\n    \n    protected double x, y; \n    protected double velocityX, velocityY; \n    protected int width, height; \n    protected int health; \n    protected boolean alive; \n    protected Rectangle hitBox; \n    \n    public Entity(double x, double y, int width, int height, int health) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.health = health;\n        this.alive = true;\n        this.velocityX = 0;\n        this.velocityY = 0;\n        this.hitBox = new Rectangle((int)x, (int)y, width, height);\n    }\n    \n    \n    public abstract void update(double deltaTime);\n    \n    \n    public abstract void render(Graphics2D g);\n    \n    \n    public void takeDamage(int damage) {\n        health -= damage;\n        if (health <= 0) {\n            health = 0;\n            alive = false;\n        }\n    }\n    \n    \n    protected void updateHitBox() {\n        hitBox.x = (int)x;\n        hitBox.y = (int)y;\n    }\n    \n    \n    public boolean collidesWith(Entity other) {\n        return hitBox.intersects(other.getHitBox());\n    }\n    \n    \n    public double getX() {\n        return x;\n    }\n    \n    public void setX(double x) {\n        this.x = x;\n        updateHitBox();\n    }\n    \n    public double getY() {\n        return y;\n    }\n    \n    public void setY(double y) {\n        this.y = y;\n        updateHitBox();\n    }\n    \n    public double getVelocityX() {\n        return velocityX;\n    }\n    \n    public void setVelocityX(double velocityX) {\n        this.velocityX = velocityX;\n    }\n    \n    public double getVelocityY() {\n        return velocityY;\n    }\n    \n    public void setVelocityY(double velocityY) {\n        this.velocityY = velocityY;\n    }\n    \n    public int getWidth() {\n        return width;\n    }\n    \n    public int getHeight() {\n        return height;\n    }\n    \n    public int getHealth() {\n        return health;\n    }\n    \n    public void setHealth(int health) {\n        this.health = health;\n    }\n    \n    public boolean isAlive() {\n        return alive;\n    }\n    \n    public Rectangle getHitBox() {\n        return hitBox;\n    }\n}\n\n",
      "AcidZombie.java": "\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.util.List;\n\npublic class AcidZombie extends Zombie {\n    \n    private static final int ZOMBIE_WIDTH = 30;\n    private static final int ZOMBIE_HEIGHT = 30;\n    private static final int ZOMBIE_HEALTH = 100;\n    private static final double ZOMBIE_SPEED = 70.0; \n    private static final int ZOMBIE_DAMAGE = 20;\n    \n    \n    private static final double ACID_SPIT_RANGE = 300.0; \n    private static final double ACID_SPIT_COOLDOWN = 2.0; \n    private static final int ACID_SPIT_DAMAGE = 15; \n    private static final double ACID_EXPLOSION_RADIUS = 50.0; \n    private static final int ACID_EXPLOSION_DAMAGE = 20; \n    \n    private double acidSpitTimer = 0; \n    private GameState gameState; \n    \n    public AcidZombie(double x, double y, GameState gameState) {\n        super(x, y, ZOMBIE_WIDTH, ZOMBIE_HEIGHT, ZOMBIE_HEALTH, ZOMBIE_SPEED, ZOMBIE_DAMAGE, gameState);\n        this.gameState = gameState;\n    }\n    \n    @Override\n    public void setGameState(GameState gameState) {\n        super.setGameState(gameState);\n        this.gameState = gameState;\n    }\n    \n    @Override\n    public void update(double deltaTime) {\n        if (!alive) return;\n        \n        \n        if (attackCooldown > 0) {\n            attackCooldown -= deltaTime;\n        }\n        \n        \n        if (acidSpitTimer > 0) {\n            acidSpitTimer -= deltaTime;\n        }\n        \n        \n        if (target != null && target.isAlive()) {\n            \n            double dx = target.getX() + target.getWidth() / 2 - (x + width / 2);\n            double dy = target.getY() + target.getHeight() / 2 - (y + height / 2);\n            double distance = Math.sqrt(dx * dx + dy * dy);\n            \n            \n            if (distance <= ACID_SPIT_RANGE && acidSpitTimer <= 0) {\n                spitAcid();\n                acidSpitTimer = ACID_SPIT_COOLDOWN;\n            }\n            \n            \n            if (distance > ACID_SPIT_RANGE / 2) {\n                moveTowardsTarget(deltaTime);\n            }\n        } else {\n            moveTowardsTarget(deltaTime);\n        }\n        \n        \n        updateHitBox();\n        \n        \n        if (target != null && target.isAlive() && collidesWith(target)) {\n            if (attackCooldown <= 0) {\n                attackPlayer();\n                attackCooldown = ATTACK_COOLDOWN_TIME;\n            }\n        }\n    }\n    \n    private void spitAcid() {\n        if (gameState == null || target == null) return;\n        \n        \n        double centerX = x + width / 2;\n        double centerY = y + height / 2;\n        double targetX = target.getX() + target.getWidth() / 2;\n        double targetY = target.getY() + target.getHeight() / 2;\n        \n        double dx = targetX - centerX;\n        double dy = targetY - centerY;\n        double angle = Math.atan2(dy, dx);\n        \n        \n        angle += (Math.random() - 0.5) * 0.2;\n        \n        \n        Bullet acid = new Bullet(centerX, centerY, angle, 300, 15, ACID_SPIT_DAMAGE, new Color(0, 255, 0));\n        acid.setOwner(this); \n        \n        if (gameState != null) {\n            gameState.addBullet(acid);\n            System.out.println(\"Acid zombie spit acid!\");\n        } else {\n            System.out.println(\"GameState is null, can't add acid projectile\");\n        }\n    }\n    \n    @Override\n    protected void moveTowardsTarget(double deltaTime) {\n        \n        double dx = target.getX() + target.getWidth() / 2 - (x + width / 2);\n        double dy = target.getY() + target.getHeight() / 2 - (y + height / 2);\n        \n        \n        double length = Math.sqrt(dx * dx + dy * dy);\n        if (length > 0) {\n            dx = dx / length;\n            dy = dy / length;\n        }\n        \n        \n        velocityX = dx * speed;\n        velocityY = dy * speed;\n        \n        \n        double newX = x + velocityX * deltaTime;\n        double newY = y + velocityY * deltaTime;\n        \n        \n        if (target != null && target.getGameState() != null) {\n            List<Zombie> zombies = target.getGameState().getZombies();\n            boolean collisionX = false;\n            boolean collisionY = false;\n            \n            for (Zombie other : zombies) {\n                if (other != this && other.isAlive()) {\n                    \n                    if (wouldCollideWith(other, newX, y)) {\n                        collisionX = true;\n                    }\n                    if (wouldCollideWith(other, x, newY)) {\n                        collisionY = true;\n                    }\n                }\n            }\n            \n            \n            if (!collisionX) {\n                x = newX;\n            }\n            if (!collisionY) {\n                y = newY;\n            }\n        } else {\n            \n            x = newX;\n            y = newY;\n        }\n        \n        \n        if (x < -2000) x = -2000;\n        if (x > 2000 - width) x = 2000 - width;\n        if (y < -2000) y = -2000;\n        if (y > 2000 - height) y = 2000 - height;\n    }\n    \n    @Override\n    public void render(Graphics2D g) {\n        if (!alive) return;\n        \n        \n        g.setColor(new Color(0, 180, 0)); \n        g.fillOval((int)x, (int)y, width, height);\n        \n        \n        g.setColor(new Color(0, 255, 0, 150)); \n        for (int i = 0; i < 4; i++) {\n            double angle = i * Math.PI / 2;\n            int indicatorX = (int)(x + width/2 + Math.cos(angle) * (width/2 + 5));\n            int indicatorY = (int)(y + height/2 + Math.sin(angle) * (height/2 + 5));\n            g.fillOval(indicatorX - 3, indicatorY - 3, 6, 6);\n        }\n        \n        \n        if (acidSpitTimer > 0) {\n            g.setColor(new Color(255, 255, 255, 100)); \n            g.fillArc((int)x, (int)y, width, height, 0, (int)(360 * (acidSpitTimer / ACID_SPIT_COOLDOWN)));\n        }\n        \n        \n        int healthBarWidth = width;\n        int healthBarHeight = 5;\n        int healthBarY = (int)y - healthBarHeight - 2;\n        \n        \n        g.setColor(Color.RED);\n        g.fillRect((int)x, healthBarY, healthBarWidth, healthBarHeight);\n        \n        \n        g.setColor(Color.GREEN);\n        int currentHealthWidth = (int)((health / (double)ZOMBIE_HEALTH) * healthBarWidth);\n        g.fillRect((int)x, healthBarY, currentHealthWidth, healthBarHeight);\n    }\n    \n    @Override\n    public ZombieType getType() {\n        return ZombieType.ACID;\n    }\n    \n    @Override\n    public void onDeath() {\n        \n        createAcidExplosionEffect();\n    }\n    \n    \n    private void createAcidExplosionEffect() {\n        \n        if (gameState == null) return;\n        \n        \n        double centerX = x + width / 2;\n        double centerY = y + height / 2;\n        \n        \n        for (int i = 0; i < 8; i++) {\n            double angle = i * Math.PI / 4; \n            \n            \n            Bullet acidParticle = new Bullet(\n                centerX, \n                centerY, \n                angle, \n                150, \n                8,   \n                10,   \n                new Color(0, 255, 0) \n            );\n            \n            \n            new Thread(() -> {\n                try {\n                    Thread.sleep(1000); \n                    acidParticle.setActive(false);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n            \n            gameState.addBullet(acidParticle);\n        }\n        \n        \n        damageNearbyEntities();\n    }\n    \n    \n    private void damageNearbyEntities() {\n        if (gameState == null) return;\n        \n        \n        double centerX = x + width / 2;\n        double centerY = y + height / 2;\n        \n        \n        Player player = gameState.getPlayer();\n        if (player != null && player.isAlive()) {\n            double distance = Math.sqrt(\n                Math.pow(player.getX() + player.getWidth()/2 - centerX, 2) + \n                Math.pow(player.getY() + player.getHeight()/2 - centerY, 2)\n            );\n            \n            if (distance <= ACID_EXPLOSION_RADIUS) {\n                player.takeDamage(ACID_EXPLOSION_DAMAGE);\n                System.out.println(\"Player damaged by acid explosion for \" + ACID_EXPLOSION_DAMAGE + \" damage!\");\n            }\n        }\n        \n        \n        for (Zombie zombie : gameState.getZombies()) {\n            if (zombie != this && zombie.isAlive()) {\n                double distance = Math.sqrt(\n                    Math.pow(zombie.getX() + zombie.getWidth()/2 - centerX, 2) + \n                    Math.pow(zombie.getY() + zombie.getHeight()/2 - centerY, 2)\n                );\n                \n                if (distance <= ACID_EXPLOSION_RADIUS) {\n                    zombie.takeDamage(ACID_EXPLOSION_DAMAGE);\n                    System.out.println(\"Zombie damaged by acid explosion!\");\n                }\n            }\n        }\n    }\n}\n\n",
      "Weapon.java": "\nimport java.awt.Graphics2D;\n\npublic interface Weapon {\n    \n    void update(double deltaTime);\n    \n    \n    void render(Graphics2D g, double x, double y, double angle);\n    \n    \n    void shoot(double x, double y, double angle);\n    \n    \n    void reload();\n    \n    \n    int getCurrentAmmo();\n    \n    \n    int getTotalAmmo();\n    \n    \n    String getName();\n    \n    \n    int getMagazineSize();\n}\n\n",
      "Bullet.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\n\npublic class Bullet implements GameObject {\n    \n    protected double x, y;\n    protected double velocityX, velocityY;\n    protected double speed;\n    protected double angle;\n    \n    \n    protected int damage;\n    protected boolean active;\n    protected Color color;\n    protected int size;\n    protected boolean penetration; \n    protected Rectangle hitBox;\n    protected Entity owner; \n    \n    public Bullet(double x, double y, double angle, int damage, Color color, int size, double speed, boolean penetration) {\n        this.x = x;\n        this.y = y;\n        this.angle = angle;\n        this.damage = damage;\n        this.active = true;\n        this.color = color;\n        this.size = size;\n        this.speed = speed;\n        this.penetration = penetration;\n        \n        \n        this.velocityX = Math.cos(angle) * speed;\n        this.velocityY = Math.sin(angle) * speed;\n        \n        \n        this.hitBox = new Rectangle((int)x - size/2, (int)y - size/2, size, size);\n    }\n    \n    \n    public Bullet(double x, double y, double angle, double speed, int size, int damage, Color color) {\n        this.x = x;\n        this.y = y;\n        this.angle = angle;\n        this.damage = damage;\n        this.active = true;\n        this.color = color;\n        this.size = size;\n        this.speed = speed;\n        this.penetration = false; \n        \n        \n        this.velocityX = Math.cos(angle) * speed;\n        this.velocityY = Math.sin(angle) * speed;\n        \n        \n        this.hitBox = new Rectangle((int)x - size/2, (int)y - size/2, size, size);\n    }\n    \n    @Override\n    public void update(double deltaTime) {\n        \n        x += velocityX * deltaTime;\n        y += velocityY * deltaTime;\n        \n        \n        hitBox.x = (int)x - size/2;\n        hitBox.y = (int)y - size/2;\n        \n        \n        if (x < -2000 || x > 2000 || y < -2000 || y > 2000) {\n            active = false;\n        }\n    }\n    \n    @Override\n    public void render(Graphics2D g) {\n        if (!active) return;\n        \n        g.setColor(color);\n        g.fillOval((int)x - size/2, (int)y - size/2, size, size);\n    }\n    \n    public boolean collidesWith(Rectangle otherHitBox) {\n        return hitBox.intersects(otherHitBox);\n    }\n    \n    public boolean isActive() {\n        return active;\n    }\n    \n    public void setActive(boolean active) {\n        this.active = active;\n    }\n    \n    public int getDamage() {\n        return damage;\n    }\n    \n    public boolean hasPenetration() {\n        return penetration;\n    }\n    \n    public Color getColor() {\n        return color;\n    }\n    \n    public double getX() {\n        return x;\n    }\n    \n    public double getY() {\n        return y;\n    }\n    \n    public void setOwner(Entity owner) {\n        this.owner = owner;\n    }\n    \n    public Entity getOwner() {\n        return owner;\n    }\n}\n\n",
      "Shotgun.java": "\nimport java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class Shotgun extends AbstractWeapon {\n    \n    private static final int MAGAZINE_SIZE = 5; \n    private static final int INITIAL_TOTAL_AMMO = 20;\n    private static final double FIRE_RATE = 1.0; \n    private static final double RELOAD_TIME = 3.0; \n    private static final int DAMAGE = 10; \n    private static final int PELLET_COUNT = 9; \n    private static final double SPREAD_ARC = Math.toRadians(45); \n    private static final double BULLET_SPEED = 500.0; \n    \n    \n    private GameState gameState;\n    \n    public Shotgun(GameState gameState) {\n        super(\"Shotgun\", MAGAZINE_SIZE, INITIAL_TOTAL_AMMO, FIRE_RATE, RELOAD_TIME, Color.RED);\n        this.gameState = gameState;\n    }\n    \n    @Override\n    protected void performShoot(double x, double y, double angle) {\n        \n        System.out.println(\"Shotgun fired at angle: \" + angle);\n        \n        \n        double startAngle = angle - SPREAD_ARC / 2;\n        double angleStep = SPREAD_ARC / (PELLET_COUNT - 1);\n        \n        \n        for (int i = 0; i < PELLET_COUNT; i++) {\n            \n            double pelletAngle = startAngle + (angleStep * i);\n            \n            \n            Bullet pellet = new Bullet(\n                x, y, \n                pelletAngle, \n                DAMAGE, \n                Color.RED, \n                3, \n                BULLET_SPEED, \n                false \n            );\n            \n            \n            if (getPlayer() != null) {\n                pellet.setOwner(getPlayer());\n            }\n            \n            \n            gameState.addBullet(pellet);\n        }\n    }\n    \n    @Override\n    public void render(Graphics2D g, double x, double y, double angle) {\n        \n        var originalTransform = g.getTransform();\n        \n        \n        g.translate(x, y);\n        g.rotate(angle);\n        \n        \n        g.setColor(weaponColor);\n        g.fillRect(0, -4, 25, 8);  \n        g.fillRect(-8, -5, 12, 10); \n        g.setColor(weaponColor.darker());\n        g.fillRect(-3, -2, 15, 4);  \n        \n        \n        g.setTransform(originalTransform);\n    }\n}\n\n",
      "GameWindow.java": "\nimport javax.swing.JFrame;\n\npublic class GameWindow extends JFrame {\n    \n    private static final String TITLE = \"Top-Down Shooter Game\";\n    private static final int DEFAULT_WIDTH = 800;\n    private static final int DEFAULT_HEIGHT = 600;\n    \n    private GamePanel gamePanel;\n    \n    public GameWindow() {\n        setTitle(TITLE);\n        setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setResizable(false);\n        setLocationRelativeTo(null); \n        \n        gamePanel = new GamePanel();\n        add(gamePanel);\n        \n        setVisible(true);\n    }\n    \n    public GamePanel getGamePanel() {\n        return gamePanel;\n    }\n}\n\n",
      "NormalZombie.java": "\nimport java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class NormalZombie extends Zombie {\n    \n    private static final int ZOMBIE_WIDTH = 30;\n    private static final int ZOMBIE_HEIGHT = 30;\n    private static final int ZOMBIE_HEALTH = 80;\n    private static final double ZOMBIE_SPEED = 90.0; \n    private static final int ZOMBIE_DAMAGE = 10;\n    \n    public NormalZombie(double x, double y, GameState gameState) {\n        super(x, y, ZOMBIE_WIDTH, ZOMBIE_HEIGHT, ZOMBIE_HEALTH, ZOMBIE_SPEED, ZOMBIE_DAMAGE, gameState);\n    }\n    \n    @Override\n    public void render(Graphics2D g) {\n        if (!alive) return;\n        \n        \n        g.setColor(Color.GREEN);\n        g.fillOval((int)x, (int)y, width, height);\n        \n        \n        int healthBarWidth = width;\n        int healthBarHeight = 5;\n        int healthBarY = (int)y - healthBarHeight - 2;\n        \n        \n        g.setColor(Color.RED);\n        g.fillRect((int)x, healthBarY, healthBarWidth, healthBarHeight);\n        \n        \n        g.setColor(Color.GREEN);\n        int currentHealthWidth = (int)((health / (double)ZOMBIE_HEALTH) * healthBarWidth);\n        g.fillRect((int)x, healthBarY, currentHealthWidth, healthBarHeight);\n    }\n    \n    @Override\n    public void onDeath() {\n        \n    }\n    \n    @Override\n    public ZombieType getType() {\n        return ZombieType.NORMAL;\n    }\n}\n\n",
      "HUDRenderer.java": "import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class HUDRenderer {\n    private GameState gameState;\n    private List<GameMessage> messages;\n    \n    private static final double MESSAGE_DURATION = 3.0;\n    private static final int MESSAGE_Y_OFFSET = 50;\n    private static final int MESSAGE_Y_SPACING = 30;\n    \n    private String waveTransitionMessage = null;\n    private double waveMessageTimer = 0;\n    private static final double WAVE_MESSAGE_DURATION = 3.0;\n    \n    private String newWeaponMessage = null;\n    private double weaponMessageTimer = 0;\n    private static final double WEAPON_MESSAGE_DURATION = 3.0;\n    \n    public HUDRenderer(GameState gameState) {\n        this.gameState = gameState;\n        this.messages = new ArrayList<>();\n    }\n    \n    \n    public class GameMessage {\n        String text;\n        Color color;\n        double timeRemaining;\n        \n        public GameMessage(String text, Color color, double duration) {\n            this.text = text;\n            this.color = color;\n            this.timeRemaining = duration;\n        }\n    }\n    \n    \n    public void update(double deltaTime) {\n        \n        Iterator<GameMessage> iterator = messages.iterator();\n        while (iterator.hasNext()) {\n            GameMessage message = iterator.next();\n            message.timeRemaining -= deltaTime;\n            \n            if (message.timeRemaining <= 0) {\n                iterator.remove();\n            }\n        }\n        \n        \n        if (waveTransitionMessage != null) {\n            waveMessageTimer -= deltaTime;\n            \n            if (waveMessageTimer <= 0) {\n                waveTransitionMessage = null;\n            }\n        }\n        \n        \n        if (newWeaponMessage != null) {\n            weaponMessageTimer -= deltaTime;\n            \n            if (weaponMessageTimer <= 0) {\n                newWeaponMessage = null;\n            }\n        }\n    }\n    \n    \n    public void render(Graphics2D g, int screenWidth, int screenHeight) {\n        Player player = gameState.getPlayer();\n        \n        if (player != null) {\n            renderHealthBar(g, player, screenWidth, screenHeight);\n            renderWeaponInfo(g, player, screenWidth, screenHeight);\n        }\n        \n        renderWaveInfo(g, screenWidth, screenHeight);\n        renderMessages(g, screenWidth);\n        \n        \n        if (gameState.getCurrentState() == GameState.State.PLAYING) {\n            \n            if (waveTransitionMessage != null) {\n                g.setColor(Color.YELLOW);\n                g.setFont(new Font(\"Arial\", Font.BOLD, 36));\n                int textWidth = g.getFontMetrics().stringWidth(waveTransitionMessage);\n                g.drawString(waveTransitionMessage, (screenWidth - textWidth) / 2, screenHeight / 2 - 50);\n            }\n            \n            \n            if (newWeaponMessage != null) {\n                g.setColor(Color.WHITE);\n                g.setFont(new Font(\"Arial\", Font.BOLD, 24));\n                int textWidth = g.getFontMetrics().stringWidth(newWeaponMessage);\n                g.drawString(newWeaponMessage, (screenWidth - textWidth) / 2, MESSAGE_Y_OFFSET + MESSAGE_Y_SPACING);\n            }\n        }\n    }\n    \n    \n    public void renderHealthBar(Graphics2D g, Player player, int screenWidth, int screenHeight) {\n        \n        g.setColor(Color.GRAY);\n        g.fillRect(600, 60, 150, 15);\n        \n        \n        g.setColor(Color.RED);\n        int healthWidth = (int)((player.getHealth() / (double)player.getMaxHealth()) * 150);\n        g.fillRect(600, 60, healthWidth, 15);\n        \n        \n        g.setColor(Color.WHITE);\n        g.drawString(player.getHealth() + \"/\" + player.getMaxHealth(), 650, 90);\n    }\n    \n    \n    public void renderWeaponInfo(Graphics2D g, Player player, int screenWidth, int screenHeight) {\n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 16));\n        g.drawString(\"Weapon: \" + player.getCurrentWeaponName(), 20, 30);\n        g.drawString(\"Ammo: \" + player.getCurrentAmmo() + \" / \" + player.getCurrentTotalAmmo(), 20, 50);\n    }\n    \n    \n    public void renderWaveInfo(Graphics2D g, int screenWidth, int screenHeight) {\n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 16));\n        g.drawString(\"Score: \" + gameState.getScore(), 650, 30);\n        g.drawString(\"Wave: \" + gameState.getCurrentWave(), 650, 50);\n    }\n    \n    \n    public void renderMessages(Graphics2D g, int screenWidth) {\n        g.setFont(new Font(\"Arial\", Font.PLAIN, 16));\n        \n        int y = MESSAGE_Y_OFFSET;\n        for (GameMessage message : messages) {\n            g.setColor(message.color);\n            int textWidth = g.getFontMetrics().stringWidth(message.text);\n            g.drawString(message.text, (screenWidth - textWidth) / 2, y);\n            y += MESSAGE_Y_SPACING;\n        }\n    }\n    \n    \n    public void renderGameStateMessages(Graphics2D g, int screenWidth, int screenHeight) {\n        if (gameState.getCurrentState() == GameState.State.PAUSED) {\n            g.setColor(new Color(0, 0, 0, 150));\n            g.fillRect(0, 0, screenWidth, screenHeight);\n            \n            g.setColor(Color.WHITE);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 36));\n            String pausedText = \"OYUN DURAKLATILDI\";\n            int textWidth = g.getFontMetrics().stringWidth(pausedText);\n            g.drawString(pausedText, (screenWidth - textWidth) / 2, screenHeight / 2);\n            \n            g.setFont(new Font(\"Arial\", Font.PLAIN, 18));\n            String resumeText = \"Devam etmek için P tuşuna basın\";\n            int resumeWidth = g.getFontMetrics().stringWidth(resumeText);\n            g.drawString(resumeText, (screenWidth - resumeWidth) / 2, screenHeight / 2 + 40);\n            \n            g.setFont(new Font(\"Arial\", Font.PLAIN, 18));\n            String saveText = \"Kaydetmek için S tuşuna basın\";\n            int saveWidth = g.getFontMetrics().stringWidth(saveText);\n            g.drawString(saveText, (screenWidth - saveWidth) / 2, screenHeight / 2 + 70);\n            \n            g.setFont(new Font(\"Arial\", Font.PLAIN, 18));\n            String menuText = \"Ana menüye dönmek için ESC tuşuna basın\";\n            int menuWidth = g.getFontMetrics().stringWidth(menuText);\n            g.drawString(menuText, (screenWidth - menuWidth) / 2, screenHeight / 2 + 100);\n        }\n        \n        if (gameState.getCurrentState() == GameState.State.GAME_OVER) {\n            g.setColor(new Color(0, 0, 0, 200));\n            g.fillRect(0, 0, screenWidth, screenHeight);\n            \n            g.setColor(Color.RED);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 48));\n            String gameOverText = \"OYUN BİTTİ\";\n            int textWidth = g.getFontMetrics().stringWidth(gameOverText);\n            g.drawString(gameOverText, (screenWidth - textWidth) / 2, screenHeight / 2);\n            \n            g.setColor(Color.WHITE);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 24));\n            String waveText = gameState.getCurrentWave() + \" dalga hayatta kaldınız\";\n            int waveWidth = g.getFontMetrics().stringWidth(waveText);\n            g.drawString(waveText, (screenWidth - waveWidth) / 2, screenHeight / 2 + 50);\n            \n            g.setFont(new Font(\"Arial\", Font.PLAIN, 18));\n            String restartText = \"Yeniden başlamak için N tuşuna basın\";\n            int restartWidth = g.getFontMetrics().stringWidth(restartText);\n            g.drawString(restartText, (screenWidth - restartWidth) / 2, screenHeight / 2 + 100);\n            \n            g.setFont(new Font(\"Arial\", Font.PLAIN, 18));\n            String menuText = \"Ana menüye dönmek için M tuşuna basın\";\n            int menuWidth = g.getFontMetrics().stringWidth(menuText);\n            g.drawString(menuText, (screenWidth - menuWidth) / 2, screenHeight / 2 + 130);\n            \n            g.setFont(new Font(\"Arial\", Font.PLAIN, 18));\n            String exitText = \"Çıkış yapmak için ESC tuşuna basın\";\n            int exitWidth = g.getFontMetrics().stringWidth(exitText);\n            g.drawString(exitText, (screenWidth - exitWidth) / 2, screenHeight / 2 + 160);\n        }\n    }\n    \n    \n    public void addMessage(String text, Color color) {\n        messages.add(new GameMessage(text, color, MESSAGE_DURATION));\n    }\n    \n    \n    public void clearMessages() {\n        messages.clear();\n    }\n    \n    \n    public void setWaveTransitionMessage(String message) {\n        this.waveTransitionMessage = message;\n        this.waveMessageTimer = WAVE_MESSAGE_DURATION;\n    }\n    \n    \n    public void setNewWeaponMessage(String message) {\n        this.newWeaponMessage = message;\n        this.weaponMessageTimer = WEAPON_MESSAGE_DURATION;\n    }\n    \n    \n    public String getWaveTransitionMessage() {\n        return waveTransitionMessage;\n    }\n    \n    \n    public String getNewWeaponMessage() {\n        return newWeaponMessage;\n    }\n}\n\n",
      "HealthPickup.java": "\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\n\npublic class HealthPickup implements GameObject {\n    private double x, y;\n    private int width, height;\n    private int healAmount; \n    private Rectangle bounds;\n    private boolean active;\n    \n    \n    public HealthPickup(double x, double y, int healAmount) {\n        this.x = x;\n        this.y = y;\n        this.width = 15;\n        this.height = 15;\n        this.healAmount = healAmount;\n        this.bounds = new Rectangle((int)x, (int)y, width, height);\n        this.active = true;\n    }\n    \n    @Override\n    public void update(double deltaTime) {\n        \n    }\n    \n    @Override\n    public void render(Graphics2D g) {\n        if (!active) return;\n        \n        \n        g.setColor(Color.RED);\n        \n        \n        int crossThickness = 3;\n        g.fillRect((int)x, (int)y + height/2 - crossThickness/2, width, crossThickness);\n        \n        \n        g.fillRect((int)x + width/2 - crossThickness/2, (int)y, crossThickness, height);\n        \n        \n        g.setColor(Color.WHITE);\n        g.drawRect((int)x, (int)y, width, height);\n    }\n    \n    public Rectangle getBounds() {\n        return bounds;\n    }\n    \n    public int getHealAmount() {\n        return healAmount;\n    }\n    \n    public void setActive(boolean active) {\n        this.active = active;\n    }\n    \n    public boolean isActive() {\n        return active;\n    }\n}\n\n",
      "AbstractWeapon.java": "\nimport java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic abstract class AbstractWeapon implements Weapon {\n    \n    protected String name;\n    protected int magazineSize;\n    protected int currentAmmo;\n    protected int totalAmmo;\n    protected double fireRate; \n    protected double lastShotTime;\n    protected boolean reloading;\n    protected double reloadTime; \n    protected double reloadTimer;\n    protected Player player; \n    protected GameState gameState;\n    protected Color weaponColor; \n    \n    public AbstractWeapon(String name, int magazineSize, int initialTotalAmmo, double fireRate, double reloadTime) {\n        this.name = name;\n        this.magazineSize = magazineSize;\n        this.currentAmmo = magazineSize;\n        this.totalAmmo = initialTotalAmmo;\n        this.fireRate = fireRate;\n        this.reloadTime = reloadTime;\n        this.lastShotTime = 0;\n        this.reloading = false;\n        this.reloadTimer = 0;\n        this.weaponColor = Color.DARK_GRAY; \n    }\n    \n    public AbstractWeapon(String name, int magazineSize, int initialTotalAmmo, double fireRate, double reloadTime, Color weaponColor) {\n        this(name, magazineSize, initialTotalAmmo, fireRate, reloadTime);\n        this.weaponColor = weaponColor;\n    }\n    \n    @Override\n    public void update(double deltaTime) {\n        \n        if (reloading) {\n            reloadTimer += deltaTime;\n            if (reloadTimer >= reloadTime) {\n                completeReload();\n            }\n        }\n        \n        \n        lastShotTime += deltaTime;\n    }\n    \n    @Override\n    public void shoot(double x, double y, double angle) {\n        if (reloading) return;\n        \n        \n        if (currentAmmo > 0 && lastShotTime >= 1.0 / fireRate) {\n            \n            lastShotTime = 0;\n            \n            \n            currentAmmo--;\n            \n            \n            performShoot(x, y, angle);\n            \n            \n            if (currentAmmo == 0 && totalAmmo > 0) {\n                reload();\n            }\n        }\n    }\n    \n    \n    protected abstract void performShoot(double x, double y, double angle);\n    \n    @Override\n    public void render(Graphics2D g, double x, double y, double angle) {\n        \n        \n    }\n    \n    @Override\n    public void reload() {\n        \n        if (reloading || currentAmmo == magazineSize || totalAmmo == 0) return;\n        \n        \n        reloading = true;\n        reloadTimer = 0;\n    }\n    \n    private void completeReload() {\n        \n        int bulletsToReload = Math.min(magazineSize - currentAmmo, totalAmmo);\n        \n        \n        currentAmmo += bulletsToReload;\n        totalAmmo -= bulletsToReload;\n        \n        \n        reloading = false;\n    }\n    \n    @Override\n    public int getCurrentAmmo() {\n        return currentAmmo;\n    }\n    \n    @Override\n    public int getTotalAmmo() {\n        return totalAmmo;\n    }\n    \n    @Override\n    public String getName() {\n        return name;\n    }\n    \n    \n    public void addAmmo(int amount) {\n        totalAmmo += amount;\n    }\n    \n    \n    public boolean isReloading() {\n        return reloading;\n    }\n    \n    \n    public void setCurrentAmmo(int amount) {\n        this.currentAmmo = Math.min(amount, magazineSize);\n    }\n    \n    public void setTotalAmmo(int amount) {\n        this.totalAmmo = Math.max(0, amount);\n    }\n    \n    \n    @Override\n    public int getMagazineSize() {\n        return magazineSize;\n    }\n    \n    \n    public void setPlayer(Player player) {\n        this.player = player;\n    }\n    \n    \n    public Player getPlayer() {\n        return player;\n    }\n    \n    \n    public void setGameState(GameState gameState) {\n        this.gameState = gameState;\n    }\n}\n\n",
      "SniperRifle.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class SniperRifle extends AbstractWeapon {\n    \n    private static final int MAGAZINE_SIZE = 5;\n    private static final int INITIAL_TOTAL_AMMO = 20;\n    private static final double FIRE_RATE = 0.5; \n    private static final double RELOAD_TIME = 2.5; \n    private static final int DAMAGE = 300; \n    private static final double BULLET_SPEED = 1000.0; \n    \n    \n    private GameState gameState;\n    \n    public SniperRifle(GameState gameState) {\n        super(\"Sniper Rifle\", MAGAZINE_SIZE, INITIAL_TOTAL_AMMO, FIRE_RATE, RELOAD_TIME, Color.CYAN);\n        this.gameState = gameState;\n    }\n    \n    @Override\n    protected void performShoot(double x, double y, double angle) {\n        \n        System.out.println(\"Sniper Rifle fired at angle: \" + angle);\n        \n        \n        double spreadAngle = angle + (Math.random() - 0.5) * 0.05;\n        \n        \n        Bullet bullet = new Bullet(\n            x, y, \n            spreadAngle, \n            DAMAGE, \n            Color.CYAN, \n            5, \n            BULLET_SPEED, \n            true \n        );\n        \n        \n        if (getPlayer() != null) {\n            bullet.setOwner(getPlayer());\n        }\n        \n        \n        gameState.addBullet(bullet);\n    }\n    \n    @Override\n    public void render(Graphics2D g, double x, double y, double angle) {\n        \n        var originalTransform = g.getTransform();\n        \n        \n        g.translate(x, y);\n        g.rotate(angle);\n        \n        \n        g.setColor(weaponColor);\n        g.fillRect(0, -2, 40, 4);  \n        g.fillRect(-10, -4, 15, 8); \n        \n        \n        g.setColor(weaponColor.darker().darker());\n        g.fillRect(10, -6, 8, 2);  \n        g.fillRect(10, 4, 8, 2);   \n        \n        \n        g.setTransform(originalTransform);\n    }\n}\n\n",
      "GameSaveManager.java": "\nimport java.io.*;\nimport java.util.*;\nimport java.text.SimpleDateFormat;\n\npublic class GameSaveManager {\n    \n    private static final String SAVE_DIRECTORY = \"saves\";\n    \n    public GameSaveManager() {\n        \n        File saveDir = new File(SAVE_DIRECTORY);\n        if (!saveDir.exists()) {\n            saveDir.mkdir();\n        }\n    }\n    \n    \n    public boolean saveGame(GameState gameState) {\n        \n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd_HH-mm-ss\");\n        String saveName = \"save_\" + dateFormat.format(new Date());\n        \n        return saveGame(gameState, saveName);\n    }\n    \n    \n    public boolean saveGame(GameState gameState, String saveName) {\n        try {\n            \n            if (saveName == null || saveName.isEmpty()) {\n                SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd_HH-mm-ss\");\n                saveName = \"save_\" + dateFormat.format(new Date());\n            }\n            \n            File saveFile = new File(SAVE_DIRECTORY + File.separator + saveName + \".sav\");\n            FileOutputStream fileOut = new FileOutputStream(saveFile);\n            ObjectOutputStream out = new ObjectOutputStream(fileOut);\n            \n            \n            SaveData saveData = new SaveData(gameState);\n            \n            \n            out.writeObject(saveData);\n            out.close();\n            fileOut.close();\n            \n            System.out.println(\"Game saved to \" + saveFile.getAbsolutePath());\n            return true;\n        } catch (IOException e) {\n            System.err.println(\"Error saving game: \" + e.getMessage());\n            e.printStackTrace();\n            return false;\n        }\n    }\n    \n    \n    public SaveData loadGame() {\n        try {\n            File saveDir = new File(SAVE_DIRECTORY);\n            File[] saveFiles = saveDir.listFiles((dir, name) -> name.endsWith(\".sav\"));\n            \n            if (saveFiles == null || saveFiles.length == 0) {\n                System.out.println(\"No save files found.\");\n                return null;\n            }\n            \n            \n            Arrays.sort(saveFiles, Comparator.comparingLong(File::lastModified).reversed());\n            \n            \n            String fileName = saveFiles[0].getName();\n            String saveName = fileName.substring(0, fileName.length() - 4); \n            \n            return loadGame(saveName);\n        } catch (Exception e) {\n            System.err.println(\"Error loading latest save: \" + e.getMessage());\n            e.printStackTrace();\n            return null;\n        }\n    }\n    \n    \n    public SaveData loadGame(String saveName) {\n        try {\n            File saveFile = new File(SAVE_DIRECTORY + File.separator + saveName + \".sav\");\n            if (!saveFile.exists()) {\n                System.err.println(\"Save file does not exist: \" + saveFile.getAbsolutePath());\n                return null;\n            }\n            \n            FileInputStream fileIn = new FileInputStream(saveFile);\n            ObjectInputStream in = new ObjectInputStream(fileIn);\n            \n            \n            SaveData saveData = (SaveData) in.readObject();\n            in.close();\n            fileIn.close();\n            \n            System.out.println(\"Game loaded from \" + saveFile.getAbsolutePath());\n            return saveData;\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error loading game: \" + e.getMessage());\n            e.printStackTrace();\n            return null;\n        }\n    }\n    \n    \n    public List<String> getSaveFiles() {\n        List<String> saveFiles = new ArrayList<>();\n        File saveDir = new File(SAVE_DIRECTORY);\n        \n        if (saveDir.exists() && saveDir.isDirectory()) {\n            File[] files = saveDir.listFiles((dir, name) -> name.endsWith(\".sav\"));\n            if (files != null) {\n                for (File file : files) {\n                    \n                    String fileName = file.getName();\n                    saveFiles.add(fileName.substring(0, fileName.length() - 4));\n                }\n            }\n        }\n        \n        return saveFiles;\n    }\n    \n    \n    public static class SaveData implements Serializable {\n        private static final long serialVersionUID = 1L;\n        \n        \n        private int playerHealth;\n        private double playerX;\n        private double playerY;\n        private int score;\n        private int currentWave;\n        \n        \n        private int[] weaponAmmo;\n        private int[] weaponTotalAmmo;\n        private boolean[] weaponUnlocked;\n        private int currentWeaponIndex;\n        \n        \n        private List<ZombieData> zombieDataList;\n        \n        public SaveData(GameState gameState) {\n            Player player = gameState.getPlayer();\n            \n            \n            this.playerHealth = player.getHealth();\n            this.playerX = player.getX();\n            this.playerY = player.getY();\n            this.score = gameState.getScore();\n            this.currentWave = gameState.getCurrentWave();\n            \n            \n            AbstractWeapon[] weapons = player.getWeapons();\n            this.weaponAmmo = new int[weapons.length];\n            this.weaponTotalAmmo = new int[weapons.length];\n            \n            for (int i = 0; i < weapons.length; i++) {\n                if (weapons[i] != null) {\n                    this.weaponAmmo[i] = weapons[i].getCurrentAmmo();\n                    this.weaponTotalAmmo[i] = weapons[i].getTotalAmmo();\n                }\n            }\n            \n            this.weaponUnlocked = player.getWeaponUnlocked();\n            this.currentWeaponIndex = player.getCurrentWeaponIndex();\n            \n            \n            this.zombieDataList = new ArrayList<>();\n            List<Zombie> zombies = gameState.getZombies();\n            \n            for (Zombie zombie : zombies) {\n                ZombieData zombieData = new ZombieData(\n                    zombie.getX(),\n                    zombie.getY(),\n                    zombie.getHealth(),\n                    zombie.getType()\n                );\n                zombieDataList.add(zombieData);\n            }\n        }\n        \n        \n        public int getPlayerHealth() {\n            return playerHealth;\n        }\n        \n        public double getPlayerX() {\n            return playerX;\n        }\n        \n        public double getPlayerY() {\n            return playerY;\n        }\n        \n        public int getScore() {\n            return score;\n        }\n        \n        public int getCurrentWave() {\n            return currentWave;\n        }\n        \n        public int[] getWeaponAmmo() {\n            return weaponAmmo;\n        }\n        \n        public int[] getWeaponTotalAmmo() {\n            return weaponTotalAmmo;\n        }\n        \n        public boolean[] getWeaponUnlocked() {\n            return weaponUnlocked;\n        }\n        \n        public int getCurrentWeaponIndex() {\n            return currentWeaponIndex;\n        }\n        \n        public List<ZombieData> getZombieDataList() {\n            return zombieDataList;\n        }\n    }\n    \n    \n    public static class ZombieData implements Serializable {\n        private static final long serialVersionUID = 1L;\n        \n        private double x;\n        private double y;\n        private int health;\n        private ZombieType type;\n        \n        public ZombieData(double x, double y, int health, ZombieType type) {\n            this.x = x;\n            this.y = y;\n            this.health = health;\n            this.type = type;\n        }\n        \n        public double getX() {\n            return x;\n        }\n        \n        public double getY() {\n            return y;\n        }\n        \n        public int getHealth() {\n            return health;\n        }\n        \n        public ZombieType getType() {\n            return type;\n        }\n    }\n}\n\n",
      "Rocket.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class Rocket extends Bullet {\n    private GameState gameState;\n    private double explosionRadius;\n    private double lifetime = 0;\n    private static final double MAX_LIFETIME = 10.0; \n    \n    public Rocket(double x, double y, double angle, int damage, Color color, int size, \n                 double speed, double explosionRadius, GameState gameState) {\n        super(x, y, angle, damage, color, size, speed, false);\n        this.explosionRadius = explosionRadius;\n        this.gameState = gameState;\n    }\n    \n    @Override\n    public void update(double deltaTime) {\n        \n        x += velocityX * deltaTime;\n        y += velocityY * deltaTime;\n        \n        \n        hitBox.x = (int)x - size/2;\n        hitBox.y = (int)y - size/2;\n        \n        \n        lifetime += deltaTime;\n        if (lifetime >= MAX_LIFETIME) {\n            active = false;\n            \n            if (gameState != null) {\n                System.out.println(\"Rocket auto-exploded after reaching maximum lifetime\");\n                createExplosion();\n            }\n        }\n        \n        \n        if (x < -2000 || x > 2000 || y < -2000 || y > 2000) {\n            active = false;\n            \n            if (gameState != null) {\n                System.out.println(\"Rocket exploded at world boundary\");\n                createExplosion();\n            }\n        }\n    }\n    \n    @Override\n    public void render(Graphics2D g) {\n        if (!active) return;\n        \n        \n        g.setColor(color);\n        g.fillOval((int)x - size/2, (int)y - size/2, size, size);\n        \n        \n        g.setColor(new Color(255, 128, 0)); \n        double trailLength = 20;\n        double trailX = x - Math.cos(angle) * trailLength;\n        double trailY = y - Math.sin(angle) * trailLength;\n        g.drawLine((int)x, (int)y, (int)trailX, (int)trailY);\n    }\n    \n    public double getExplosionRadius() {\n        return explosionRadius;\n    }\n    \n    \n    public void createExplosion() {\n        if (gameState == null) return;\n        \n        \n        for (Zombie zombie : gameState.getZombies()) {\n            double dx = zombie.getX() + zombie.getWidth() / 2 - x;\n            double dy = zombie.getY() + zombie.getHeight() / 2 - y;\n            double distance = Math.sqrt(dx * dx + dy * dy);\n            \n            if (distance <= explosionRadius) {\n                \n                double damageMultiplier = 1.0 - (distance / explosionRadius);\n                int explosionDamage = (int)(damage * damageMultiplier);\n                \n                \n                if (zombie != getOwner()) {\n                    zombie.takeDamage(explosionDamage);\n                    System.out.println(\"Rocket explosion dealt \" + explosionDamage + \" damage to zombie at distance \" + distance);\n                }\n            }\n        }\n        \n        \n        Player player = gameState.getPlayer();\n        if (player != null) {\n            double dx = player.getX() + player.getWidth() / 2 - x;\n            double dy = player.getY() + player.getHeight() / 2 - y;\n            double distance = Math.sqrt(dx * dx + dy * dy);\n            \n            if (distance <= explosionRadius) {\n                \n                double damageMultiplier;\n                if (player == getOwner()) {\n                    damageMultiplier = (1.0 - (distance / explosionRadius)) * 0.25; \n                } else {\n                    damageMultiplier = (1.0 - (distance / explosionRadius)) * 0.5; \n                }\n                \n                int explosionDamage = (int)(damage * damageMultiplier);\n                player.takeDamage(explosionDamage);\n                System.out.println(\"Rocket explosion dealt \" + explosionDamage + \" damage to player at distance \" + distance);\n            }\n        }\n        \n        \n        createExplosionEffect();\n    }\n    \n    \n    private void createExplosionEffect() {\n        \n        \n        System.out.println(\"Explosion effect created at \" + x + \", \" + y);\n        \n        \n        System.out.println(\"BOOM! Rocket exploded with radius \" + explosionRadius);\n    }\n}\n\n",
      "Pistol.java": "\nimport java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class Pistol extends AbstractWeapon {\n    \n    private static final int MAGAZINE_SIZE = 12;\n    private static final int INITIAL_TOTAL_AMMO = 48;\n    private static final double FIRE_RATE = 2.0; \n    private static final double RELOAD_TIME = 1.5; \n    private static final int DAMAGE = 25;\n    private static final double BULLET_SPEED = 600.0; \n    \n    \n    private GameState gameState;\n    \n    public Pistol(GameState gameState) {\n        super(\"Pistol\", MAGAZINE_SIZE, INITIAL_TOTAL_AMMO, FIRE_RATE, RELOAD_TIME, Color.YELLOW);\n        this.gameState = gameState;\n    }\n    \n    @Override\n    protected void performShoot(double x, double y, double angle) {\n        \n        System.out.println(\"Pistol fired at angle: \" + angle);\n        \n        \n        Bullet bullet = new Bullet(\n            x, y, \n            angle, \n            DAMAGE, \n            Color.YELLOW, \n            6, \n            BULLET_SPEED, \n            false \n        );\n        \n        \n        if (getPlayer() != null) {\n            bullet.setOwner(getPlayer());\n        }\n        \n        \n        gameState.addBullet(bullet);\n    }\n    \n    @Override\n    public void render(Graphics2D g, double x, double y, double angle) {\n        \n        var originalTransform = g.getTransform();\n        \n        \n        g.translate(x, y);\n        g.rotate(angle);\n        \n        \n        g.setColor(weaponColor);\n        g.fillRect(0, -3, 20, 6);\n        \n        \n        g.setTransform(originalTransform);\n    }\n}\n\n",
      "GamePanel.java": "\nimport javax.swing.JPanel;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.RenderingHints;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\n\npublic class GamePanel extends JPanel implements Runnable {\n    \n    private static final int FPS = 60;\n    private static final long OPTIMAL_TIME = 1000000000 / FPS;\n    \n    private Thread gameThread;\n    private boolean running = false;\n    private GameState gameState;\n    \n    \n    private double cameraX = 0;\n    private double cameraY = 0;\n    \n    public GamePanel() {\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.BLACK);\n        setDoubleBuffered(true);\n        setFocusable(true);\n        \n        gameState = new GameState();\n        \n        \n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                handleKeyPress(e);\n            }\n        });\n        \n        \n        setupInputHandlers();\n        \n        \n        requestFocus();\n    }\n    \n    private void setupInputHandlers() {\n        \n        KeyListener[] keyListeners = getKeyListeners();\n        for (KeyListener listener : keyListeners) {\n            if (listener != this.getKeyListeners()[0]) { \n                removeKeyListener(listener);\n            }\n        }\n        \n        \n        MouseListener[] mouseListeners = getMouseListeners();\n        for (MouseListener listener : mouseListeners) {\n            removeMouseListener(listener);\n        }\n        \n        MouseMotionListener[] motionListeners = getMouseMotionListeners();\n        for (MouseMotionListener listener : motionListeners) {\n            removeMouseMotionListener(listener);\n        }\n        \n        \n        if (gameState.getPlayer() != null) {\n            \n            addKeyListener(gameState.getPlayer());\n            \n            \n            addMouseListener(gameState.getPlayer());\n            addMouseMotionListener(gameState.getPlayer());\n        }\n    }\n    \n    private void handleKeyPress(KeyEvent e) {\n        int key = e.getKeyCode();\n        \n        switch (gameState.getCurrentState()) {\n            case MENU:\n                if (key == KeyEvent.VK_N) {\n                    \n                    gameState = new GameState();\n                    setupInputHandlers();\n                    gameState.startGame();\n                    setupInputHandlers(); \n                } else if (key == KeyEvent.VK_L) {\n                    \n                    GameSaveManager saveManager = new GameSaveManager();\n                    GameSaveManager.SaveData saveData = saveManager.loadGame();\n                    \n                    if (saveData != null) {\n                        \n                        gameState = new GameState();\n                        gameState.initFromSaveData(saveData);\n                        setupInputHandlers();\n                        setupInputHandlers(); \n                        System.out.println(\"Game loaded successfully!\");\n                    } else {\n                        System.out.println(\"No saved game found or error loading game.\");\n                    }\n                } else if (key == KeyEvent.VK_ESCAPE) {\n                    System.exit(0);\n                }\n                break;\n                \n            case PLAYING:\n                if (key == KeyEvent.VK_P || key == KeyEvent.VK_ESCAPE) {\n                    gameState.setCurrentState(GameState.State.PAUSED);\n                }\n                break;\n                \n            case PAUSED:\n                if (key == KeyEvent.VK_P) {\n                    gameState.setCurrentState(GameState.State.PLAYING);\n                } else if (key == KeyEvent.VK_S) {\n                    \n                    GameSaveManager saveManager = new GameSaveManager();\n                    boolean saved = saveManager.saveGame(gameState);\n                    \n                    if (saved) {\n                        System.out.println(\"Game saved successfully!\");\n                    } else {\n                        System.out.println(\"Error saving game.\");\n                    }\n                } else if (key == KeyEvent.VK_ESCAPE) {\n                    \n                    gameState = new GameState();\n                    setupInputHandlers();\n                    System.out.println(\"Returning to main menu from pause screen\");\n                }\n                break;\n                \n            case GAME_OVER:\n                if (key == KeyEvent.VK_N) {\n                    \n                    gameState = new GameState();\n                    setupInputHandlers();\n                    gameState.startGame();\n                    System.out.println(\"Starting new game from game over screen\");\n                } else if (key == KeyEvent.VK_M) {\n                    \n                    gameState = new GameState();\n                    setupInputHandlers();\n                    System.out.println(\"Returning to main menu from game over screen\");\n                } else if (key == KeyEvent.VK_ESCAPE) {\n                    System.exit(0);\n                }\n                break;\n        }\n    }\n    \n    public void startGameThread() {\n        gameThread = new Thread(this);\n        running = true;\n        gameThread.start();\n    }\n    \n    @Override\n    public void run() {\n        long lastTime = System.nanoTime();\n        long timer = System.currentTimeMillis();\n        int frames = 0;\n        \n        while (running) {\n            long now = System.nanoTime();\n            long delta = now - lastTime;\n            lastTime = now;\n            \n            update(delta / 1000000000.0); \n            repaint();\n            frames++;\n            \n            try {\n                long sleepTime = (lastTime - System.nanoTime() + OPTIMAL_TIME) / 1000000;\n                if (sleepTime > 0) {\n                    Thread.sleep(sleepTime);\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            \n            if (System.currentTimeMillis() - timer > 1000) {\n                timer += 1000;\n                System.out.println(\"FPS: \" + frames);\n                frames = 0;\n            }\n        }\n    }\n    \n    private void update(double deltaTime) {\n        \n        gameState.update(deltaTime);\n        \n        \n        updateCamera();\n    }\n    \n    private void updateCamera() {\n        if (gameState.getPlayer() != null && gameState.getCurrentState() == GameState.State.PLAYING) {\n            Player player = gameState.getPlayer();\n            \n            \n            cameraX = player.getX() - 400 + (player.getWidth() / 2);\n            cameraY = player.getY() - 300 + (player.getHeight() / 2);\n            \n            \n            gameState.setCameraX(cameraX);\n            gameState.setCameraY(cameraY);\n        }\n    }\n    \n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        \n        Graphics2D g2d = (Graphics2D) g;\n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        \n        \n        switch (gameState.getCurrentState()) {\n            case MENU:\n                \n                gameState.renderMenu(g2d);\n                break;\n                \n            case PLAYING:\n                \n                g2d.translate(-cameraX, -cameraY);\n                \n                \n                gameState.render(g2d);\n                \n                \n                g2d.translate(cameraX, cameraY);\n                \n                \n                renderHUD(g2d);\n                break;\n                \n            case PAUSED:\n                \n                g2d.translate(-cameraX, -cameraY);\n                \n                \n                gameState.renderPlaying(g2d);\n                \n                \n                g2d.translate(cameraX, cameraY);\n                \n                \n                gameState.getHudRenderer().renderGameStateMessages(g2d, getWidth(), getHeight());\n                break;\n                \n            case GAME_OVER:\n                \n                g2d.translate(-cameraX, -cameraY);\n                \n                \n                gameState.renderPlaying(g2d);\n                \n                \n                g2d.translate(cameraX, cameraY);\n                \n                \n                gameState.getHudRenderer().renderGameStateMessages(g2d, getWidth(), getHeight());\n                break;\n        }\n        \n        g2d.dispose();\n    }\n    \n    \n    private void renderHUD(Graphics2D g) {\n        \n        Player player = gameState.getPlayer();\n        \n        \n        if (player != null) {\n            g.setColor(Color.WHITE);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 16));\n            g.drawString(\"Weapon: \" + player.getCurrentWeaponName(), 20, 30);\n            g.drawString(\"Ammo: \" + player.getCurrentAmmo() + \" / \" + player.getCurrentTotalAmmo(), 20, 50);\n        }\n        \n        \n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 16));\n        g.drawString(\"Score: \" + gameState.getScore(), 650, 30);\n        g.drawString(\"Wave: \" + gameState.getCurrentWave(), 650, 50);\n        \n        \n        if (player != null) {\n            \n            g.setColor(Color.GRAY);\n            g.fillRect(600, 60, 150, 15);\n            \n            \n            g.setColor(Color.RED);\n            int healthWidth = (int)((player.getHealth() / (double)player.getMaxHealth()) * 150);\n            g.fillRect(600, 60, healthWidth, 15);\n            \n            \n            g.setColor(Color.WHITE);\n            g.drawString(player.getHealth() + \"/\" + player.getMaxHealth(), 650, 90);\n        }\n        \n        \n        String waveMessage = gameState.getWaveTransitionMessage();\n        if (waveMessage != null) {\n            g.setColor(Color.YELLOW);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 36));\n            g.drawString(waveMessage, 200, 300);\n        }\n        \n        \n        String weaponMessage = gameState.getNewWeaponMessage();\n        if (weaponMessage != null) {\n            g.setColor(Color.WHITE);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 24));\n            g.drawString(weaponMessage, 250, 200);\n        }\n    }\n}\n\n",
      "AssaultRifle.java": "\nimport java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class AssaultRifle extends AbstractWeapon {\n    \n    private static final int MAGAZINE_SIZE = 30;\n    private static final int INITIAL_TOTAL_AMMO = 120;\n    private static final double FIRE_RATE = 10.0; \n    private static final double RELOAD_TIME = 2.0; \n    private static final int DAMAGE = 15;\n    private static final double BULLET_SPEED = 700.0; \n    private static final double SPREAD_ANGLE = Math.toRadians(30); \n    \n    \n    private GameState gameState;\n    \n    public AssaultRifle(GameState gameState) {\n        super(\"Assault Rifle\", MAGAZINE_SIZE, INITIAL_TOTAL_AMMO, FIRE_RATE, RELOAD_TIME, new Color(139, 69, 19)); \n        this.gameState = gameState;\n    }\n    \n    @Override\n    protected void performShoot(double x, double y, double angle) {\n        \n        System.out.println(\"Assault Rifle fired at angle: \" + angle);\n        \n        \n        double spreadAngle = angle + (Math.random() - 0.5) * SPREAD_ANGLE;\n        \n        \n        Bullet bullet = new Bullet(\n            x, y, \n            spreadAngle, \n            DAMAGE, \n            Color.ORANGE, \n            4, \n            BULLET_SPEED, \n            false \n        );\n        \n        \n        if (getPlayer() != null) {\n            bullet.setOwner(getPlayer());\n        }\n        \n        \n        gameState.addBullet(bullet);\n    }\n    \n    @Override\n    public void render(Graphics2D g, double x, double y, double angle) {\n        \n        var originalTransform = g.getTransform();\n        \n        \n        g.translate(x, y);\n        g.rotate(angle);\n        \n        \n        g.setColor(weaponColor);\n        g.fillRect(0, -3, 30, 6);  \n        g.fillRect(-10, -5, 15, 10); \n        \n        \n        g.setTransform(originalTransform);\n    }\n}\n\n",
      "CrawlerZombie.java": "\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.util.List;\n\npublic class CrawlerZombie extends Zombie {\n    \n    private static final int ZOMBIE_WIDTH = 25;\n    private static final int ZOMBIE_HEIGHT = 25;\n    private static final int ZOMBIE_HEALTH = 60;\n    private static final double ZOMBIE_SPEED = 120.0; \n    private static final int ZOMBIE_DAMAGE = 15;\n    private static final double JUMP_DISTANCE = 100.0; \n    private static final double JUMP_SPEED_MULTIPLIER = 1.8; \n    \n    private boolean isJumping = false;\n    private double jumpTimer = 0;\n    private static final double JUMP_DURATION = 0.5; \n    private static final double JUMP_COOLDOWN = 3.0; \n    private double jumpCooldownTimer = 0;\n    \n    public CrawlerZombie(double x, double y, GameState gameState) {\n        super(x, y, ZOMBIE_WIDTH, ZOMBIE_HEIGHT, ZOMBIE_HEALTH, ZOMBIE_SPEED, ZOMBIE_DAMAGE, gameState);\n    }\n    \n    @Override\n    public void update(double deltaTime) {\n        if (!alive) return;\n        \n        \n        if (attackCooldown > 0) {\n            attackCooldown -= deltaTime;\n        }\n        \n        \n        if (jumpCooldownTimer > 0) {\n            jumpCooldownTimer -= deltaTime;\n        }\n        \n        \n        if (target != null && target.isAlive()) {\n            \n            double dx = target.getX() + target.getWidth() / 2 - (x + width / 2);\n            double dy = target.getY() + target.getHeight() / 2 - (y + height / 2);\n            double distance = Math.sqrt(dx * dx + dy * dy);\n            \n            \n            if (distance < JUMP_DISTANCE && !isJumping && jumpCooldownTimer <= 0) {\n                isJumping = true;\n                jumpTimer = 0;\n                System.out.println(\"Crawler zombie jumping!\");\n            }\n            \n            \n            if (isJumping) {\n                jumpTimer += deltaTime;\n                if (jumpTimer >= JUMP_DURATION) {\n                    isJumping = false;\n                    jumpCooldownTimer = JUMP_COOLDOWN; \n                }\n                moveTowardsTarget(deltaTime, JUMP_SPEED_MULTIPLIER);\n            } else {\n                moveTowardsTarget(deltaTime, 1.0);\n            }\n        }\n        \n        \n        updateHitBox();\n        \n        \n        if (target != null && target.isAlive() && collidesWith(target)) {\n            if (attackCooldown <= 0) {\n                attackPlayer();\n                attackCooldown = ATTACK_COOLDOWN_TIME;\n            }\n        }\n    }\n    \n    \n    protected void moveTowardsTarget(double deltaTime, double speedMultiplier) {\n        \n        double dx = target.getX() + target.getWidth() / 2 - (x + width / 2);\n        double dy = target.getY() + target.getHeight() / 2 - (y + height / 2);\n        \n        \n        double length = Math.sqrt(dx * dx + dy * dy);\n        if (length > 0) {\n            dx = dx / length;\n            dy = dy / length;\n        }\n        \n        \n        velocityX = dx * speed * speedMultiplier;\n        velocityY = dy * speed * speedMultiplier;\n        \n        \n        double newX = x + velocityX * deltaTime;\n        double newY = y + velocityY * deltaTime;\n        \n        \n        if (target != null && target.getGameState() != null) {\n            List<Zombie> zombies = target.getGameState().getZombies();\n            boolean collisionX = false;\n            boolean collisionY = false;\n            \n            for (Zombie other : zombies) {\n                if (other != this && other.isAlive()) {\n                    \n                    if (wouldCollideWith(other, newX, y)) {\n                        collisionX = true;\n                    }\n                    if (wouldCollideWith(other, x, newY)) {\n                        collisionY = true;\n                    }\n                }\n            }\n            \n            \n            if (!collisionX) {\n                x = newX;\n            }\n            if (!collisionY) {\n                y = newY;\n            }\n        } else {\n            \n            x = newX;\n            y = newY;\n        }\n        \n        \n        if (x < -2000) x = -2000;\n        if (x > 2000 - width) x = 2000 - width;\n        if (y < -2000) y = -2000;\n        if (y > 2000 - height) y = 2000 - height;\n    }\n    \n    @Override\n    public void render(Graphics2D g) {\n        if (!alive) return;\n        \n        \n        if (isJumping) {\n            g.setColor(new Color(200, 200, 0)); \n        } else {\n            g.setColor(new Color(150, 150, 0)); \n        }\n        g.fillOval((int)x, (int)y, width, height);\n        \n        \n        int healthBarWidth = width;\n        int healthBarHeight = 5;\n        int healthBarY = (int)y - healthBarHeight - 2;\n        \n        \n        g.setColor(Color.RED);\n        g.fillRect((int)x, healthBarY, healthBarWidth, healthBarHeight);\n        \n        \n        g.setColor(Color.GREEN);\n        int currentHealthWidth = (int)((health / (double)ZOMBIE_HEALTH) * healthBarWidth);\n        g.fillRect((int)x, healthBarY, currentHealthWidth, healthBarHeight);\n    }\n    \n    @Override\n    public ZombieType getType() {\n        return ZombieType.CRAWLER;\n    }\n    \n    @Override\n    public void onDeath() {\n        \n        System.out.println(\"Crawler zombie died\");\n    }\n}\n\n",
      "TankZombie.java": "\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.util.List;\n\npublic class TankZombie extends Zombie {\n    \n    private static final int ZOMBIE_WIDTH = 45;\n    private static final int ZOMBIE_HEIGHT = 45;\n    private static final int ZOMBIE_HEALTH = 300;\n    private static final double ZOMBIE_SPEED = 60.0; \n    private static final int ZOMBIE_DAMAGE = 25;\n    \n    \n    private static final double DAMAGE_REDUCTION = 0.3; \n    \n    public TankZombie(double x, double y, GameState gameState) {\n        super(x, y, ZOMBIE_WIDTH, ZOMBIE_HEIGHT, ZOMBIE_HEALTH, ZOMBIE_SPEED, ZOMBIE_DAMAGE, gameState);\n    }\n    \n    @Override\n    public void takeDamage(int amount) {\n        \n        int reducedDamage = (int)(amount * (1 - DAMAGE_REDUCTION));\n        super.takeDamage(reducedDamage);\n        \n        if (reducedDamage < amount) {\n            System.out.println(\"Tank zombie reduced damage from \" + amount + \" to \" + reducedDamage);\n        }\n    }\n    \n    @Override\n    protected void moveTowardsTarget(double deltaTime) {\n        \n        double dx = target.getX() + target.getWidth() / 2 - (x + width / 2);\n        double dy = target.getY() + target.getHeight() / 2 - (y + height / 2);\n        \n        \n        double length = Math.sqrt(dx * dx + dy * dy);\n        if (length > 0) {\n            dx = dx / length;\n            dy = dy / length;\n        }\n        \n        \n        velocityX = dx * speed;\n        velocityY = dy * speed;\n        \n        \n        double newX = x + velocityX * deltaTime;\n        double newY = y + velocityY * deltaTime;\n        \n        \n        if (target != null && target.getGameState() != null) {\n            List<Zombie> zombies = target.getGameState().getZombies();\n            boolean collisionX = false;\n            boolean collisionY = false;\n            \n            for (Zombie other : zombies) {\n                if (other != this && other.isAlive()) {\n                    \n                    if (wouldCollideWith(other, newX, y)) {\n                        collisionX = true;\n                    }\n                    if (wouldCollideWith(other, x, newY)) {\n                        collisionY = true;\n                    }\n                }\n            }\n            \n            \n            if (!collisionX) {\n                x = newX;\n            }\n            if (!collisionY) {\n                y = newY;\n            }\n        } else {\n            \n            x = newX;\n            y = newY;\n        }\n        \n        \n        if (x < -2000) x = -2000;\n        if (x > 2000 - width) x = 2000 - width;\n        if (y < -2000) y = -2000;\n        if (y > 2000 - height) y = 2000 - height;\n    }\n    \n    @Override\n    public void render(Graphics2D g) {\n        if (!alive) return;\n        \n        \n        g.setColor(new Color(100, 100, 100)); \n        g.fillOval((int)x, (int)y, width, height);\n        \n        \n        g.setColor(new Color(200, 200, 200, 150)); \n        int armorWidth = 5;\n        g.drawOval((int)x - armorWidth/2, (int)y - armorWidth/2, \n                   width + armorWidth, height + armorWidth);\n        \n        \n        int healthBarWidth = width;\n        int healthBarHeight = 5;\n        int healthBarY = (int)y - healthBarHeight - 2;\n        \n        \n        g.setColor(Color.RED);\n        g.fillRect((int)x, healthBarY, healthBarWidth, healthBarHeight);\n        \n        \n        g.setColor(Color.GREEN);\n        int currentHealthWidth = (int)((health / (double)ZOMBIE_HEALTH) * healthBarWidth);\n        g.fillRect((int)x, healthBarY, currentHealthWidth, healthBarHeight);\n    }\n    \n    @Override\n    public ZombieType getType() {\n        return ZombieType.TANK;\n    }\n    \n    @Override\n    public void onDeath() {\n        \n        System.out.println(\"Tank zombie died\");\n    }\n}\n\n",
      "Game.java": "\npublic class Game {\n    \n    private GameWindow gameWindow;\n    \n    public Game() {\n        gameWindow = new GameWindow();\n        gameWindow.getGamePanel().startGameThread();\n    }\n    \n    public static void main(String[] args) {\n        new Game();\n    }\n    \n}\n\n",
      "RocketLauncher.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class RocketLauncher extends AbstractWeapon {\n    \n    private static final int MAGAZINE_SIZE = 1;\n    private static final int INITIAL_TOTAL_AMMO = 5;\n    private static final double FIRE_RATE = 0.167; \n    private static final double RELOAD_TIME = 4.0; \n    private static final int DAMAGE = 500; \n    private static final double EXPLOSION_RADIUS = 200.0; \n    private static final double BULLET_SPEED = 400.0; \n    \n    \n    private GameState gameState;\n    \n    public RocketLauncher(GameState gameState) {\n        super(\"Rocket Launcher\", MAGAZINE_SIZE, INITIAL_TOTAL_AMMO, FIRE_RATE, RELOAD_TIME, Color.GREEN);\n        this.gameState = gameState;\n    }\n    \n    @Override\n    protected void performShoot(double x, double y, double angle) {\n        \n        System.out.println(\"Rocket Launcher fired at angle: \" + angle);\n        \n        \n        double spreadAngle = angle + (Math.random() - 0.5) * 0.05;\n        \n        \n        Rocket rocket = new Rocket(\n            x, y, \n            spreadAngle, \n            DAMAGE, \n            Color.RED, \n            15, \n            BULLET_SPEED, \n            EXPLOSION_RADIUS,\n            gameState\n        );\n        \n        \n        if (getPlayer() != null) {\n            rocket.setOwner(getPlayer());\n        }\n        \n        \n        gameState.addRocket(rocket);\n    }\n    \n    @Override\n    public void render(Graphics2D g, double x, double y, double angle) {\n        \n        var originalTransform = g.getTransform();\n        \n        \n        g.translate(x, y);\n        g.rotate(angle);\n        \n        \n        g.setColor(weaponColor); \n        g.fillRect(0, -5, 35, 10);  \n        \n        \n        g.setColor(Color.RED);\n        g.fillRect(35, -3, 5, 6);  \n        \n        \n        g.setColor(weaponColor.darker());\n        g.fillRect(-10, -3, 10, 6); \n        \n        \n        g.setTransform(originalTransform);\n    }\n}\n\n",
      "Player.java": "\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\n\npublic class Player extends Entity implements KeyListener, MouseListener, MouseMotionListener {\n    \n    private static final int PLAYER_WIDTH = 30;\n    private static final int PLAYER_HEIGHT = 30;\n    private static final int PLAYER_HEALTH = 100;\n    private static final double PLAYER_SPEED = 200.0; \n    \n    private double angle; \n    private boolean moveUp, moveDown, moveLeft, moveRight;\n    private int mouseX, mouseY; \n    \n    \n    private AbstractWeapon currentWeapon;\n    private AbstractWeapon[] weapons;\n    private int currentWeaponIndex;\n    private boolean shooting;\n    \n    \n    private boolean[] weaponUnlocked;\n    \n    private GameState gameState;\n    \n    public Player(double x, double y, GameState gameState) {\n        super(x, y, PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_HEALTH);\n        this.angle = 0;\n        this.moveUp = false;\n        this.moveDown = false;\n        this.moveLeft = false;\n        this.moveRight = false;\n        this.mouseX = 0;\n        this.mouseY = 0;\n        this.shooting = false;\n        this.gameState = gameState;\n        \n        \n        initializeWeapons();\n    }\n    \n    private void initializeWeapons() {\n        \n        weapons = new AbstractWeapon[5];\n        weapons[0] = new Pistol(gameState);\n        weapons[1] = new AssaultRifle(gameState);\n        weapons[2] = new Shotgun(gameState);\n        weapons[3] = new SniperRifle(gameState);\n        weapons[4] = new RocketLauncher(gameState);\n        \n        \n        for (AbstractWeapon weapon : weapons) {\n            weapon.setPlayer(this);\n            weapon.setGameState(gameState);\n        }\n        \n        \n        weaponUnlocked = new boolean[5];\n        weaponUnlocked[0] = true; \n        \n        \n        currentWeaponIndex = 0;\n        currentWeapon = weapons[currentWeaponIndex];\n    }\n    \n    @Override\n    public void update(double deltaTime) {\n        \n        velocityX = 0;\n        velocityY = 0;\n        \n        if (moveUp) velocityY -= PLAYER_SPEED;\n        if (moveDown) velocityY += PLAYER_SPEED;\n        if (moveLeft) velocityX -= PLAYER_SPEED;\n        if (moveRight) velocityX += PLAYER_SPEED;\n        \n        \n        if (velocityX != 0 && velocityY != 0) {\n            double length = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n            velocityX = (velocityX / length) * PLAYER_SPEED;\n            velocityY = (velocityY / length) * PLAYER_SPEED;\n        }\n        \n        \n        x += velocityX * deltaTime;\n        y += velocityY * deltaTime;\n        \n        \n        if (x < -2000) x = -2000;\n        if (x > 2000) x = 2000;\n        if (y < -2000) y = -2000;\n        if (y > 2000) y = 2000;\n        \n        \n        updateHitBox();\n        \n        \n        updateAngle();\n        \n        \n        if (currentWeapon != null) {\n            currentWeapon.update(deltaTime);\n            \n            \n            if (shooting) {\n                shoot();\n            }\n        }\n    }\n    \n    private void updateAngle() {\n        \n        double adjustedMouseX = mouseX + gameState.getCameraX();\n        double adjustedMouseY = mouseY + gameState.getCameraY();\n        \n        \n        double dx = adjustedMouseX - (x + width / 2);\n        double dy = adjustedMouseY - (y + height / 2);\n        angle = Math.atan2(dy, dx);\n    }\n    \n    private void shoot() {\n        if (currentWeapon != null) {\n            currentWeapon.shoot(x + width / 2, y + height / 2, angle);\n        }\n    }\n    \n    \n    public void unlockWeapon(String weaponName) {\n        for (int i = 0; i < weapons.length; i++) {\n            if (weapons[i].getName().equals(weaponName)) {\n                weaponUnlocked[i] = true;\n                System.out.println(\"Unlocked weapon: \" + weaponName);\n                return;\n            }\n        }\n    }\n    \n    \n    public void addAmmo(String weaponType, int amount) {\n        \n        if (!weaponType.equalsIgnoreCase(\"current\")) {\n            for (int i = 0; i < weapons.length; i++) {\n                AbstractWeapon weapon = weapons[i];\n                if (weapon.getName().trim().equalsIgnoreCase(weaponType.trim())) {\n                    \n                    if (!weaponUnlocked[i]) {\n                        System.out.println(\"Cannot add ammo to \" + weaponType + \" - weapon not unlocked yet\");\n                        return;\n                    }\n                    \n                    weapon.addAmmo(amount);\n                    System.out.println(\"Added \" + amount + \" ammo to \" + weaponType);\n                    return;\n                }\n            }\n            System.out.println(\"No matching weapon found for: \" + weaponType);\n        } \n        \n        else {\n            if (currentWeapon != null) {\n                currentWeapon.addAmmo(amount);\n                System.out.println(\"Added \" + amount + \" ammo to \" + currentWeapon.getName());\n            }\n        }\n    }\n    \n    public void switchWeapon(int index) {\n        if (index >= 0 && index < weapons.length && weaponUnlocked[index]) {\n            currentWeaponIndex = index;\n            currentWeapon = weapons[currentWeaponIndex];\n            System.out.println(\"Switched to \" + currentWeapon.getName());\n        }\n    }\n    \n    public void nextWeapon() {\n        \n        int nextIndex = currentWeaponIndex;\n        do {\n            nextIndex = (nextIndex + 1) % weapons.length;\n        } while (!weaponUnlocked[nextIndex] && nextIndex != currentWeaponIndex);\n        \n        \n        if (nextIndex != currentWeaponIndex) {\n            currentWeaponIndex = nextIndex;\n            currentWeapon = weapons[currentWeaponIndex];\n            System.out.println(\"Switched to \" + currentWeapon.getName());\n        }\n    }\n    \n    @Override\n    public void render(Graphics2D g) {\n        \n        g.setColor(Color.BLUE);\n        g.fillOval((int)x, (int)y, width, height);\n        \n        \n        int centerX = (int)(x + width / 2);\n        int centerY = (int)(y + height / 2);\n        int lineEndX = (int)(centerX + Math.cos(angle) * 20);\n        int lineEndY = (int)(centerY + Math.sin(angle) * 20);\n        g.setColor(Color.WHITE);\n        g.drawLine(centerX, centerY, lineEndX, lineEndY);\n        \n        \n        if (currentWeapon != null) {\n            currentWeapon.render(g, centerX, centerY, angle);\n        }\n        \n        \n        g.setColor(Color.WHITE);\n        g.drawString(currentWeapon.getName() + \": \" + currentWeapon.getCurrentAmmo() + \"/\" + currentWeapon.getTotalAmmo(), \n                     (int)x - 30, (int)y - 10);\n    }\n    \n    \n    @Override\n    public void keyPressed(KeyEvent e) {\n        switch (e.getKeyCode()) {\n            case KeyEvent.VK_W:\n                moveUp = true;\n                break;\n            case KeyEvent.VK_S:\n                moveDown = true;\n                break;\n            case KeyEvent.VK_A:\n                moveLeft = true;\n                break;\n            case KeyEvent.VK_D:\n                moveRight = true;\n                break;\n            case KeyEvent.VK_SPACE:\n                \n                shooting = true;\n                shoot();\n                break;\n            case KeyEvent.VK_R:\n                \n                if (currentWeapon != null) {\n                    currentWeapon.reload();\n                }\n                break;\n            case KeyEvent.VK_1:\n                switchWeapon(0); \n                break;\n            case KeyEvent.VK_2:\n                switchWeapon(1); \n                break;\n            case KeyEvent.VK_3:\n                switchWeapon(2); \n                break;\n            case KeyEvent.VK_4:\n                switchWeapon(3); \n                break;\n            case KeyEvent.VK_5:\n                switchWeapon(4); \n                break;\n            case KeyEvent.VK_Q:\n                nextWeapon(); \n                break;\n        }\n    }\n    \n    @Override\n    public void keyReleased(KeyEvent e) {\n        switch (e.getKeyCode()) {\n            case KeyEvent.VK_W:\n                moveUp = false;\n                break;\n            case KeyEvent.VK_S:\n                moveDown = false;\n                break;\n            case KeyEvent.VK_A:\n                moveLeft = false;\n                break;\n            case KeyEvent.VK_D:\n                moveRight = false;\n                break;\n            case KeyEvent.VK_SPACE:\n                \n                shooting = false;\n                break;\n        }\n    }\n    \n    @Override\n    public void keyTyped(KeyEvent e) {\n        \n    }\n    \n    \n    @Override\n    public void mousePressed(MouseEvent e) {\n        if (e.getButton() == MouseEvent.BUTTON1) {\n            \n            shooting = true;\n            shoot();\n        }\n    }\n    \n    @Override\n    public void mouseReleased(MouseEvent e) {\n        if (e.getButton() == MouseEvent.BUTTON1) {\n            \n            shooting = false;\n        }\n    }\n    \n    @Override\n    public void mouseClicked(MouseEvent e) {\n        \n    }\n    \n    @Override\n    public void mouseEntered(MouseEvent e) {\n        \n    }\n    \n    @Override\n    public void mouseExited(MouseEvent e) {\n        \n    }\n    \n    \n    @Override\n    public void mouseMoved(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n    \n    @Override\n    public void mouseDragged(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n    \n    \n    public AbstractWeapon getCurrentWeapon() {\n        return currentWeapon;\n    }\n    \n    public void setCurrentWeapon(AbstractWeapon weapon) {\n        this.currentWeapon = weapon;\n    }\n    \n    public GameState getGameState() {\n        return gameState;\n    }\n    \n    public int getHealth() {\n        return health;\n    }\n    \n    public int getMaxHealth() {\n        return PLAYER_HEALTH;\n    }\n    \n    public void takeDamage(int amount) {\n        health -= amount;\n        if (health < 0) {\n            health = 0;\n            alive = false;\n        }\n    }\n    \n    public void heal(int amount) {\n        health += amount;\n        if (health > PLAYER_HEALTH) {\n            health = PLAYER_HEALTH;\n        }\n        System.out.println(\"Player healed to \" + health + \" health\");\n    }\n    \n    public void setHealth(int health) {\n        this.health = Math.min(health, PLAYER_HEALTH);\n        this.alive = this.health > 0;\n    }\n    \n    \n    public AbstractWeapon[] getWeapons() {\n        return weapons;\n    }\n    \n    public boolean[] getWeaponUnlocked() {\n        return weaponUnlocked;\n    }\n    \n    public int getCurrentWeaponIndex() {\n        return currentWeaponIndex;\n    }\n    \n    \n    public String getCurrentWeaponName() {\n        if (currentWeapon != null) {\n            return currentWeapon.getName();\n        }\n        return \"None\";\n    }\n    \n    public int getCurrentAmmo() {\n        if (currentWeapon != null) {\n            return currentWeapon.getCurrentAmmo();\n        }\n        return 0;\n    }\n    \n    public int getCurrentTotalAmmo() {\n        if (currentWeapon != null) {\n            return currentWeapon.getTotalAmmo();\n        }\n        return 0;\n    }\n    \n    \n    public void setWeaponData(int[] ammo, int[] totalAmmo, boolean[] unlocked, int currentIndex) {\n        if (ammo != null && ammo.length == weapons.length) {\n            for (int i = 0; i < weapons.length; i++) {\n                if (weapons[i] != null) {\n                    weapons[i].setCurrentAmmo(ammo[i]);\n                }\n            }\n        }\n        \n        if (totalAmmo != null && totalAmmo.length == weapons.length) {\n            for (int i = 0; i < weapons.length; i++) {\n                if (weapons[i] != null) {\n                    weapons[i].setTotalAmmo(totalAmmo[i]);\n                }\n            }\n        }\n        \n        if (unlocked != null && unlocked.length == weaponUnlocked.length) {\n            System.arraycopy(unlocked, 0, weaponUnlocked, 0, unlocked.length);\n        }\n        \n        \n        if (currentIndex >= 0 && currentIndex < weapons.length && weaponUnlocked[currentIndex]) {\n            currentWeaponIndex = currentIndex;\n            currentWeapon = weapons[currentWeaponIndex];\n        }\n    }\n}\n\n",
      "GameObject.java": "\nimport java.awt.Graphics2D;\n\npublic interface GameObject {\n    \n    void update(double deltaTime);\n    \n    \n    void render(Graphics2D g);\n}\n\n",
      "GameState.java": "\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Random;\n\npublic class GameState {\n    \n    \n    \n    public enum State {\n        MENU, PLAYING, PAUSED, GAME_OVER\n    }\n    \n    \n    private static final int INITIAL_ZOMBIES = 5;\n    private static final int ZOMBIES_PER_WAVE_INCREMENT = 2;\n    \n    \n    private static final int CRAWLER_ZOMBIE_SPAWN_WAVE = 2;\n    private static final int ACID_ZOMBIE_SPAWN_WAVE = 4;\n    private static final int TANK_ZOMBIE_SPAWN_WAVE = 6;\n    \n    \n    private static final int ASSAULT_RIFLE_UNLOCK_WAVE = 1;\n    private static final int SHOTGUN_UNLOCK_WAVE = 3;\n    private static final int SNIPER_RIFLE_UNLOCK_WAVE = 5;\n    private static final int ROCKET_LAUNCHER_UNLOCK_WAVE = 10;\n    \n    \n    private static final double AMMO_DROP_CHANCE = 0.15; \n    private static final double HEALTH_DROP_CHANCE = 0.1; \n    private static final int HEALTH_PICKUP_AMOUNT = 10; \n    \n    \n    \n    \n    \n    \n    private State currentState;\n    private int score;\n    private int currentWave;\n    private boolean gameStarted;\n    private boolean waveInProgress;\n    \n    \n    private double cameraX;\n    private double cameraY;\n    \n    \n    private Player player;\n    private List<Zombie> zombies;\n    private List<Bullet> bullets;\n    private List<Rocket> rockets;\n    private List<AmmoPickup> ammoPickups;\n    private List<HealthPickup> healthPickups;\n    \n    \n    private HUDRenderer hudRenderer;\n    \n    \n    private Random random;\n    \n    \n    private boolean isWaveTransitioning = false;\n    private double waveTransitionTimer = 0;\n    private static final double WAVE_TRANSITION_DURATION = 2.0; \n    private String waveTransitionMessage = null;\n    \n    \n    \n    \n    \n    \n    public GameState() {\n        this.currentState = State.MENU;\n        this.score = 0;\n        this.currentWave = 0;\n        this.gameStarted = false;\n        this.waveInProgress = false;\n        \n        this.cameraX = 0;\n        this.cameraY = 0;\n        \n        this.zombies = new ArrayList<>();\n        this.bullets = new ArrayList<>();\n        this.rockets = new ArrayList<>();\n        this.ammoPickups = new ArrayList<>();\n        this.healthPickups = new ArrayList<>();\n        \n        this.random = new Random();\n        \n        \n        this.hudRenderer = new HUDRenderer(this);\n        \n        \n        player = new Player(400 - 15, 300 - 15, this);\n    }\n    \n    \n    public void initFromSaveData(GameSaveManager.SaveData saveData) {\n        \n        currentState = State.PLAYING;\n        score = saveData.getScore();\n        currentWave = saveData.getCurrentWave();\n        gameStarted = true;\n        waveInProgress = true; \n        \n        \n        zombies = new ArrayList<>();\n        bullets = new ArrayList<>();\n        rockets = new ArrayList<>();\n        ammoPickups = new ArrayList<>();\n        healthPickups = new ArrayList<>();\n        random = new Random();\n        \n        \n        player = new Player(saveData.getPlayerX(), saveData.getPlayerY(), this);\n        player.setHealth(saveData.getPlayerHealth());\n        \n        \n        player.setWeaponData(\n            saveData.getWeaponAmmo(),\n            saveData.getWeaponTotalAmmo(),\n            saveData.getWeaponUnlocked(),\n            saveData.getCurrentWeaponIndex()\n        );\n        \n        \n        List<GameSaveManager.ZombieData> zombieDataList = saveData.getZombieDataList();\n        if (zombieDataList != null) {\n            for (GameSaveManager.ZombieData zombieData : zombieDataList) {\n                Zombie zombie = null;\n                \n                \n                switch (zombieData.getType()) {\n                    case NORMAL:\n                        zombie = new NormalZombie(zombieData.getX(), zombieData.getY(), this);\n                        break;\n                    case CRAWLER:\n                        zombie = new CrawlerZombie(zombieData.getX(), zombieData.getY(), this);\n                        break;\n                    case ACID:\n                        zombie = new AcidZombie(zombieData.getX(), zombieData.getY(), this);\n                        break;\n                    case TANK:\n                        zombie = new TankZombie(zombieData.getX(), zombieData.getY(), this);\n                        break;\n                }\n                \n                \n                if (zombie != null) {\n                    zombie.setHealth(zombieData.getHealth());\n                    zombies.add(zombie);\n                }\n            }\n            \n            System.out.println(\"Restored \" + zombies.size() + \" zombies from save data\");\n        }\n        \n        \n        checkWeaponUnlocks();\n    }\n    \n    public void startGame() {\n        \n        score = 0;\n        currentWave = 0;\n        gameStarted = false;\n        \n        \n        zombies.clear();\n        bullets.clear();\n        rockets.clear();\n        ammoPickups.clear();\n        healthPickups.clear();\n        \n        \n        player = new Player(400, 300, this);\n        \n        \n        currentState = State.PLAYING;\n        \n        \n        spawnZombieWave();\n    }\n    \n    \n    \n    \n    \n    public void update(double deltaTime) {\n        switch (currentState) {\n            case PLAYING:\n                updatePlaying(deltaTime);\n                break;\n                \n            case MENU:\n            case PAUSED:\n            case GAME_OVER:\n                \n                break;\n        }\n    }\n    \n    \n    private void updatePlaying(double deltaTime) {\n        \n        if (player != null) {\n            player.update(deltaTime);\n            \n            \n            \n        }\n        \n        \n        if (isWaveTransitioning) {\n            waveTransitionTimer -= deltaTime;\n            if (waveTransitionTimer <= 0) {\n                isWaveTransitioning = false;\n                waveTransitionMessage = null;\n                spawnZombieWave();\n            }\n            \n        }\n        \n        \n        updateZombies(deltaTime);\n        \n        \n        updateBullets(deltaTime);\n        \n        \n        updateRockets(deltaTime);\n        \n        \n        checkBulletZombieCollisions();\n        \n        \n        checkPlayerAmmoCollisions();\n        \n        \n        checkPlayerHealthCollisions();\n        \n        \n        if (player != null && !player.isAlive()) {\n            currentState = State.GAME_OVER;\n        }\n        \n        \n        checkWaveCompletion();\n        \n        \n        if (newWeaponMessage != null) {\n            newWeaponMessageTimer -= deltaTime;\n            if (newWeaponMessageTimer <= 0) {\n                newWeaponMessage = null;\n            }\n        }\n    }\n    \n    private void checkWaveCompletion() {\n        if (zombies.isEmpty() && waveInProgress) {\n            waveInProgress = false;\n            if (gameStarted) {\n                currentWave++;\n                System.out.println(\"Wave \" + currentWave + \" completed!\");\n                waveTransitionMessage = \"Wave \" + currentWave + \" starting...\";\n            } else {\n                gameStarted = true;\n                currentWave = 1;\n                waveTransitionMessage = \"Wave \" + currentWave + \" starting...\";\n            }\n            \n            \n            isWaveTransitioning = true;\n            waveTransitionTimer = WAVE_TRANSITION_DURATION;\n            \n            \n            checkWeaponUnlocks();\n        }\n    }\n    \n    public void render(Graphics2D g) {\n        switch (currentState) {\n            case PLAYING:\n                renderPlaying(g);\n                break;\n                \n            case MENU:\n                renderMenu(g);\n                break;\n                \n            case PAUSED:\n                renderPaused(g);\n                break;\n                \n            case GAME_OVER:\n                renderGameOver(g);\n                break;\n        }\n    }\n    \n    \n    \n    \n    \n    public void renderPlaying(Graphics2D g) {\n        \n        g.setColor(Color.DARK_GRAY);\n        g.fillRect(-2000, -2000, 4000, 4000);\n        \n        \n        g.setColor(Color.DARK_GRAY.darker());\n        \n        for (int y = -2000; y <= 2000; y += 100) {\n            g.drawLine(-2000, y, 2000, y);\n        }\n        \n        for (int x = -2000; x <= 2000; x += 100) {\n            g.drawLine(x, -2000, x, 2000);\n        }\n        \n        \n        g.setColor(Color.RED);\n        g.drawRect(-2000, -2000, 4000, 4000);\n        \n        \n        if (player != null) {\n            player.render(g);\n        }\n        \n        \n        for (Bullet bullet : bullets) {\n            bullet.render(g);\n        }\n        \n        \n        for (Rocket rocket : rockets) {\n            rocket.render(g);\n        }\n        \n        \n        for (Zombie zombie : zombies) {\n            zombie.render(g);\n        }\n        \n        \n        for (AmmoPickup ammo : ammoPickups) {\n            ammo.render(g);\n        }\n        \n        \n        for (HealthPickup health : healthPickups) {\n            health.render(g);\n        }\n    }\n    \n    public void renderMenu(Graphics2D g) {\n        \n        g.setColor(Color.BLACK);\n        g.fillRect(0, 0, 800, 600);\n        \n        \n        g.setColor(Color.RED);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 48));\n        g.drawString(\"ZOMBIE SHOOTER\", 200, 150);\n        \n        \n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        g.drawString(\"Yeni oyun başlatmak için N tuşuna basın\", 200, 300);\n        g.drawString(\"Kayıtlı oyunu yüklemek için L tuşuna basın\", 200, 350);\n        g.drawString(\"Çıkış yapmak için ESC tuşuna basın\", 200, 400);\n    }\n    \n    private void renderPaused(Graphics2D g) {\n        \n        renderPlaying(g);\n        \n        \n        g.setColor(new Color(0, 0, 0, 150)); \n        g.fillRect(0, 0, 800, 600);\n        \n        \n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 48));\n        g.drawString(\"PAUSED\", 300, 200);\n        \n        \n        g.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        g.drawString(\"Press P to resume\", 300, 300);\n        g.drawString(\"Press S to save game\", 300, 350);\n        g.drawString(\"Press M to return to menu\", 300, 400);\n    }\n    \n    private void renderGameOver(Graphics2D g) {\n        \n        renderPlaying(g);\n        \n        \n        g.setColor(new Color(0, 0, 0, 200)); \n        g.fillRect(0, 0, 800, 600);\n        \n        \n        g.setColor(Color.RED);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 48));\n        g.drawString(\"GAME OVER\", 250, 200);\n        \n        \n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        g.drawString(\"Score: \" + score, 350, 250);\n        g.drawString(\"Wave: \" + currentWave, 350, 300);\n        \n        \n        g.drawString(\"Press N to start a new game\", 250, 400);\n        g.drawString(\"Press M to return to menu\", 250, 450);\n    }\n    \n    \n    \n    \n    \n    private void updateZombies(double deltaTime) {\n        Iterator<Zombie> zombieIterator = zombies.iterator();\n        while (zombieIterator.hasNext()) {\n            Zombie zombie = zombieIterator.next();\n            zombie.update(deltaTime);\n            \n            \n            if (!zombie.isAlive()) {\n                \n                score += 10;\n                \n                \n                double zombieX = zombie.getX();\n                double zombieY = zombie.getY();\n                \n                \n                zombie.onDeath();\n                \n                \n                zombieIterator.remove();\n                \n                \n                if (random.nextDouble() < AMMO_DROP_CHANCE) {\n                    spawnAmmoPickup(zombieX, zombieY);\n                }\n                \n                \n                if (random.nextDouble() < HEALTH_DROP_CHANCE) {\n                    spawnHealthPickup(zombieX, zombieY);\n                }\n            }\n        }\n    }\n    \n    private void updateBullets(double deltaTime) {\n        \n        Iterator<Bullet> bulletIterator = bullets.iterator();\n        while (bulletIterator.hasNext()) {\n            Bullet bullet = bulletIterator.next();\n            bullet.update(deltaTime);\n            \n            \n            if (!bullet.isActive()) {\n                bulletIterator.remove();\n            }\n        }\n    }\n    \n    private void updateRockets(double deltaTime) {\n        \n        Iterator<Rocket> rocketIterator = rockets.iterator();\n        while (rocketIterator.hasNext()) {\n            Rocket rocket = rocketIterator.next();\n            rocket.update(deltaTime);\n            \n            \n            if (!rocket.isActive()) {\n                rocketIterator.remove();\n            }\n        }\n    }\n    \n    \n    \n    \n    \n    private void checkBulletZombieCollisions() {\n        if (player == null) return;\n        \n        \n        Iterator<Bullet> bulletIterator = bullets.iterator();\n        while (bulletIterator.hasNext()) {\n            Bullet bullet = bulletIterator.next();\n            boolean hitZombie = false;\n            \n            \n            \n            if (bullet.getOwner() instanceof Zombie && bullet.collidesWith(player.getHitBox())) {\n                \n                player.takeDamage(bullet.getDamage());\n                \n                bullet.setActive(false);\n                \n                bulletIterator.remove();\n                continue;\n            }\n            \n            \n            Iterator<Zombie> zombieIterator = zombies.iterator();\n            while (zombieIterator.hasNext()) {\n                Zombie zombie = zombieIterator.next();\n                \n                \n                if (bullet.getOwner() != zombie && bullet.collidesWith(zombie.getHitBox())) {\n                    \n                    zombie.takeDamage(bullet.getDamage());\n                    hitZombie = true;\n                    \n                    \n                    if (zombie.getHealth() <= 0) {\n                        zombieIterator.remove();\n                        score += 10;\n                        \n                        \n                        double dropRoll = random.nextDouble();\n                        if (dropRoll < AMMO_DROP_CHANCE) {\n                            spawnAmmoPickup(zombie.getX(), zombie.getY());\n                        } else if (dropRoll < AMMO_DROP_CHANCE + HEALTH_DROP_CHANCE) {\n                            spawnHealthPickup(zombie.getX(), zombie.getY());\n                            System.out.println(\"Health pickup spawned!\");\n                        }\n                    }\n                    \n                    \n                    if (!bullet.hasPenetration()) {\n                        bullet.setActive(false);\n                        break;\n                    }\n                }\n            }\n            \n            \n            if (hitZombie && !bullet.isActive()) {\n                bulletIterator.remove();\n            }\n        }\n        \n        \n        Iterator<Rocket> rocketIterator = rockets.iterator();\n        while (rocketIterator.hasNext()) {\n            Rocket rocket = rocketIterator.next();\n            boolean hitZombie = false;\n            \n            \n            Iterator<Zombie> zombieIterator = zombies.iterator();\n            while (zombieIterator.hasNext()) {\n                Zombie zombie = zombieIterator.next();\n                \n                \n                if (rocket.getOwner() != zombie && rocket.collidesWith(zombie.getHitBox())) {\n                    \n                    rocket.createExplosion();\n                    hitZombie = true;\n                    \n                    \n                    rocket.setActive(false);\n                    break;\n                }\n            }\n            \n            \n            if (!rocket.isActive() && !hitZombie) {\n                \n                rocket.createExplosion();\n            }\n            \n            \n            if (!rocket.isActive()) {\n                rocketIterator.remove();\n            }\n        }\n    }\n    \n    private void checkPlayerAmmoCollisions() {\n        if (player == null) return;\n        \n        Rectangle playerBounds = player.getHitBox();\n        Iterator<AmmoPickup> ammoIterator = ammoPickups.iterator();\n        \n        while (ammoIterator.hasNext()) {\n            AmmoPickup ammo = ammoIterator.next();\n            \n            if (playerBounds.intersects(ammo.getBounds())) {\n                \n                AbstractWeapon currentWeapon = player.getCurrentWeapon();\n                \n                \n                int ammoToAdd;\n                if (currentWeapon.getClass().getSimpleName().equals(\"Pistol\")) {\n                    \n                    System.out.println(\"Pistol has infinite ammo, no ammo added.\");\n                } else {\n                    \n                    ammoToAdd = currentWeapon.getMagazineSize();\n                    player.addAmmo(\"current\", ammoToAdd);\n                    System.out.println(\"Added \" + ammoToAdd + \" ammo to \" + currentWeapon.getName());\n                }\n                \n                ammoIterator.remove();\n            }\n        }\n    }\n    \n    private void checkPlayerHealthCollisions() {\n        if (player == null) return;\n        \n        Rectangle playerBounds = player.getHitBox();\n        Iterator<HealthPickup> healthIterator = healthPickups.iterator();\n        \n        while (healthIterator.hasNext()) {\n            HealthPickup health = healthIterator.next();\n            \n            if (playerBounds.intersects(health.getBounds())) {\n                \n                player.heal(health.getHealAmount());\n                healthIterator.remove();\n                System.out.println(\"Player healed for \" + health.getHealAmount() + \" health!\");\n            }\n        }\n    }\n    \n    \n    \n    \n    \n    private void spawnZombieWave() {\n        waveInProgress = true;\n        currentWave++;\n        \n        int zombieCount = INITIAL_ZOMBIES + (currentWave - 1) * ZOMBIES_PER_WAVE_INCREMENT;\n        \n        \n        zombies.clear();\n        \n        \n        List<Rectangle> occupiedPositions = new ArrayList<>();\n        \n        for (int i = 0; i < zombieCount; i++) {\n            \n            double x, y;\n            Rectangle zombieRect = null;\n            boolean validPosition = false;\n            int attempts = 0;\n            \n            \n            while (!validPosition && attempts < 20) {\n                \n                int edge = random.nextInt(4);\n                \n                \n                double playerX = player.getX();\n                double playerY = player.getY();\n                int minSpawnDistance = 800; \n                int maxSpawnDistance = 1200; \n                int spawnVariation = maxSpawnDistance - minSpawnDistance;\n                \n                switch (edge) {\n                    case 0: \n                        x = playerX - 600 + random.nextInt(1200);\n                        y = playerY - (minSpawnDistance + random.nextInt(spawnVariation));\n                        break;\n                    case 1: \n                        x = playerX + (minSpawnDistance + random.nextInt(spawnVariation));\n                        y = playerY - 600 + random.nextInt(1200);\n                        break;\n                    case 2: \n                        x = playerX - 600 + random.nextInt(1200);\n                        y = playerY + (minSpawnDistance + random.nextInt(spawnVariation));\n                        break;\n                    case 3: \n                        x = playerX - (minSpawnDistance + random.nextInt(spawnVariation));\n                        y = playerY - 600 + random.nextInt(1200);\n                        break;\n                    default:\n                        x = 0;\n                        y = 0;\n                }\n                \n                \n                x = Math.max(-1900, Math.min(1900, x));\n                y = Math.max(-1900, Math.min(1900, y));\n                \n                \n                \n                zombieRect = new Rectangle((int)x, (int)y, 80, 80);\n                \n                \n                validPosition = true;\n                for (Rectangle occupied : occupiedPositions) {\n                    if (zombieRect.intersects(occupied)) {\n                        validPosition = false;\n                        break;\n                    }\n                }\n                \n                attempts++;\n            }\n            \n            if (validPosition) {\n                \n                occupiedPositions.add(zombieRect);\n                \n                \n                Zombie zombie;\n                \n                \n                if (currentWave >= TANK_ZOMBIE_SPAWN_WAVE && random.nextDouble() < 0.2) {\n                    \n                    zombie = new TankZombie(zombieRect.x, zombieRect.y, this);\n                    System.out.println(\"Spawned a Tank Zombie!\");\n                } else if (currentWave >= ACID_ZOMBIE_SPAWN_WAVE && random.nextDouble() < 0.3) {\n                    \n                    zombie = new AcidZombie(zombieRect.x, zombieRect.y, this);\n                    System.out.println(\"Spawned an Acid Zombie!\");\n                } else if (currentWave >= CRAWLER_ZOMBIE_SPAWN_WAVE && random.nextDouble() < 0.4) {\n                    \n                    zombie = new CrawlerZombie(zombieRect.x, zombieRect.y, this);\n                    System.out.println(\"Spawned a Crawler Zombie!\");\n                } else {\n                    \n                    zombie = new NormalZombie(zombieRect.x, zombieRect.y, this);\n                }\n                \n                \n                zombies.add(zombie);\n            }\n        }\n        \n        System.out.println(\"Wave \" + currentWave + \" started with \" + zombies.size() + \" zombies\");\n    }\n    \n    private void spawnAmmoPickup(double x, double y) {\n        \n        AbstractWeapon currentWeapon = player.getCurrentWeapon();\n        String weaponType = currentWeapon.getClass().getSimpleName();\n        \n        \n        if (weaponType.equals(\"Pistol\")) {\n            String[] weaponTypes = {\"Assault Rifle\", \"Shotgun\", \"Sniper Rifle\", \"Rocket Launcher\"};\n            weaponType = weaponTypes[random.nextInt(weaponTypes.length)];\n        } else {\n            \n            if (weaponType.equals(\"AssaultRifle\")) {\n                weaponType = \"Assault Rifle\";\n            } else if (weaponType.equals(\"SniperRifle\")) {\n                weaponType = \"Sniper Rifle\";\n            } else if (weaponType.equals(\"RocketLauncher\")) {\n                weaponType = \"Rocket Launcher\";\n            }\n            \n        }\n        \n        \n        int ammoAmount;\n        switch (weaponType) {\n            case \"Assault Rifle\":\n                ammoAmount = 30; \n                break;\n            case \"Shotgun\":\n                ammoAmount = 8; \n                break;\n            case \"Sniper Rifle\":\n                ammoAmount = 5; \n                break;\n            case \"Rocket Launcher\":\n                ammoAmount = 2; \n                break;\n            default:\n                ammoAmount = 10;\n        }\n        \n        \n        ammoPickups.add(new AmmoPickup(x, y, weaponType, ammoAmount));\n    }\n    \n    private void spawnHealthPickup(double x, double y) {\n        \n        HealthPickup healthPickup = new HealthPickup(x, y, HEALTH_PICKUP_AMOUNT);\n        healthPickups.add(healthPickup);\n        System.out.println(\"Health pickup spawned!\");\n    }\n    \n    \n    \n    \n    \n    \n    private void checkWeaponUnlocks() {\n        if (player == null) return;\n        \n        boolean[] weaponUnlocked = player.getWeaponUnlocked();\n        \n        \n        if (currentWave >= ASSAULT_RIFLE_UNLOCK_WAVE && !weaponUnlocked[1]) {\n            weaponUnlocked[1] = true;\n            player.unlockWeapon(\"Assault Rifle\");\n            showNewWeaponUnlockedMessage(\"Assault Rifle\");\n        }\n        if (currentWave >= SHOTGUN_UNLOCK_WAVE && !weaponUnlocked[2]) {\n            weaponUnlocked[2] = true;\n            player.unlockWeapon(\"Shotgun\");\n            showNewWeaponUnlockedMessage(\"Shotgun\");\n        }\n        if (currentWave >= SNIPER_RIFLE_UNLOCK_WAVE && !weaponUnlocked[3]) {\n            weaponUnlocked[3] = true;\n            player.unlockWeapon(\"Sniper Rifle\");\n            showNewWeaponUnlockedMessage(\"Sniper Rifle\");\n        }\n        if (currentWave >= ROCKET_LAUNCHER_UNLOCK_WAVE && !weaponUnlocked[4]) {\n            weaponUnlocked[4] = true;\n            player.unlockWeapon(\"Rocket Launcher\");\n            showNewWeaponUnlockedMessage(\"Rocket Launcher\");\n        }\n    }\n    \n    \n    private String newWeaponMessage = null;\n    private double newWeaponMessageTimer = 0;\n    private static final double NEW_WEAPON_MESSAGE_DURATION = 3.0; \n    \n    private void showNewWeaponUnlockedMessage(String weaponName) {\n        newWeaponMessage = \"New Weapon Unlocked: \" + weaponName;\n        newWeaponMessageTimer = NEW_WEAPON_MESSAGE_DURATION;\n        System.out.println(newWeaponMessage);\n    }\n    \n    \n    \n    \n    \n    public void addBullet(Bullet bullet) {\n        bullets.add(bullet);\n    }\n    \n    public void addRocket(Rocket rocket) {\n        rockets.add(rocket);\n    }\n    \n    public Player getPlayer() {\n        return player;\n    }\n    \n    public List<Zombie> getZombies() {\n        return zombies;\n    }\n    \n    public State getCurrentState() {\n        return currentState;\n    }\n    \n    public void setCurrentState(State currentState) {\n        this.currentState = currentState;\n    }\n    \n    public int getScore() {\n        return score;\n    }\n    \n    public int getCurrentWave() {\n        return currentWave;\n    }\n    \n    \n    public double getCameraX() {\n        return cameraX;\n    }\n    \n    public void setCameraX(double cameraX) {\n        this.cameraX = cameraX;\n    }\n    \n    public double getCameraY() {\n        return cameraY;\n    }\n    \n    public void setCameraY(double cameraY) {\n        this.cameraY = cameraY;\n    }\n    \n    \n    public String getWaveTransitionMessage() {\n        return waveTransitionMessage;\n    }\n    \n    public String getNewWeaponMessage() {\n        return newWeaponMessage;\n    }\n    \n    \n    public HUDRenderer getHudRenderer() {\n        return hudRenderer;\n    }\n    \n    \n    \n    \n    \n    \n    public class AmmoPickup {\n        private double x, y;\n        private String weaponType;\n        private int ammoAmount;\n        private Rectangle bounds;\n        \n        public AmmoPickup(double x, double y, String weaponType, int ammoAmount) {\n            this.x = x;\n            this.y = y;\n            this.weaponType = weaponType;\n            this.ammoAmount = ammoAmount;\n            this.bounds = new Rectangle((int)x - 15, (int)y - 5, 30, 10);\n        }\n        \n        public void render(Graphics2D g) {\n            \n            g.setColor(Color.RED);\n            g.fillRect((int)x - 15, (int)y - 5, 30, 10);\n            \n            \n            g.setColor(Color.BLACK);\n            g.drawRect((int)x - 15, (int)y - 5, 30, 10);\n        }\n        \n        public Rectangle getBounds() {\n            return bounds;\n        }\n        \n        public String getWeaponType() {\n            return weaponType;\n        }\n        \n        public int getAmmoAmount() {\n            return ammoAmount;\n        }\n    }\n    \n    \n    public class HealthPickup {\n        private double x, y;\n        private int healAmount;\n        private Rectangle bounds;\n        \n        public HealthPickup(double x, double y, int healAmount) {\n            this.x = x;\n            this.y = y;\n            this.healAmount = healAmount;\n            this.bounds = new Rectangle((int)x - 10, (int)y - 10, 20, 20);\n        }\n        \n        public void render(Graphics2D g) {\n            \n            g.setColor(Color.GREEN);\n            g.fillRect((int)x - 10, (int)y - 10, 20, 20);\n            \n            \n            g.setColor(Color.WHITE);\n            g.fillRect((int)x - 2, (int)y - 7, 4, 14); \n            g.fillRect((int)x - 7, (int)y - 2, 14, 4); \n        }\n        \n        public Rectangle getBounds() {\n            return bounds;\n        }\n        \n        public int getHealAmount() {\n            return healAmount;\n        }\n    }\n    \n    \n}\n\n",
      "ZombieType.java": "\npublic enum ZombieType {\n    NORMAL,\n    CRAWLER,\n    ACID,\n    TANK\n}\n\n"
    },
    {
      "id": "3688139",
      "Menu.java": "import java.awt.*;\nimport javax.swing.*;\n\npublic class Menu extends JPanel {\n    public Menu(JFrame gameFrame) {\n        setLayout(null);\n        setBackground(new Color(20, 20, 20));\n    \n        int panelWidth = (int) GamePanel.screenwid;\n        int panelHeight = (int) GamePanel.screenhei;\n    \n        JLabel title = new JLabel(\"ShooterZZ\", SwingConstants.CENTER);\n        title.setFont(new Font(\"Verdana\", Font.BOLD, 60));\n        title.setForeground(Color.GREEN);\n        title.setBounds(panelWidth / 2 - 250, panelHeight / 2 - 250, 500, 80);\n        add(title);\n    \n        Font buttonFont = new Font(\"Segoe UI\", Font.PLAIN, 26);\n        Color buttonColor = new Color(60, 60, 60);\n        Color textColor = Color.WHITE;\n    \n        JButton startButton = new JButton(\"Oyuna Başla\");\n        startButton.setFont(buttonFont);\n        startButton.setBounds(panelWidth / 2 - 180, panelHeight / 2 - 100, 360, 60);\n        startButton.setBackground(buttonColor);\n        startButton.setForeground(textColor);\n        startButton.setFocusPainted(false);\n        add(startButton);\n        \n    \n        JButton loadButton = new JButton(\"Yükle\");\n        loadButton.setFont(buttonFont);\n        loadButton.setBounds(panelWidth / 2 - 180, panelHeight / 2 - 20, 360, 60);\n        loadButton.setBackground(buttonColor);\n        loadButton.setForeground(textColor);\n        loadButton.setFocusPainted(false);\n        add(loadButton);\n    \n        JButton exitButton = new JButton(\"Çıkış\");\n        exitButton.setFont(buttonFont);\n        exitButton.setBounds(panelWidth / 2 - 180, panelHeight / 2 + 60, 360, 60);\n        exitButton.setBackground(buttonColor);\n        exitButton.setForeground(textColor);\n        exitButton.setFocusPainted(false);\n        add(exitButton);\n    \n        startButton.addActionListener(e -> {\n            gameFrame.getContentPane().removeAll();\n            GamePanel panel = new GamePanel();\n            gameFrame.setContentPane(panel);\n            gameFrame.revalidate();\n            panel.requestFocusInWindow();\n        });\n        loadButton.addActionListener(e -> {\n            GamePanel panel = new GamePanel();\n            panel.loadGame(\"savegame.txt\");\n            gameFrame.setContentPane(panel);\n            gameFrame.revalidate();\n            panel.requestFocusInWindow();\n        });\n        \n    \n        exitButton.addActionListener(e -> System.exit(0));\n    }\n    \n}",
      "WaveManager.java": "import java.util.ArrayList;\nimport java.util.Random;\n\npublic class WaveManager {\n    public int currentWave = 0;\n    public int zombiesRemaining = 0;\n    int totalZombiesKilled = 0;\n    Random random = new Random();\n\n    \n\n    public boolean isWaveOver() {\n        return zombiesRemaining <= 0;\n    }\n\n    public void zombiekill() {\n        zombiesRemaining--;\n        totalZombiesKilled++;\n    }\n    public int getTotalZombiesKilled() {\n        return totalZombiesKilled;\n    }\n\n    public int getCurrentWave() {\n        return currentWave;\n    }\n    public void startNextWave(ArrayList<Zombie> zombies) {\n        currentWave++;\n        int zombieCount = 5 + (currentWave * 3);\n    \n        for (int i = 0; i < zombieCount; i++) {\n            int spawnX = random.nextInt((int) GamePanel.screenwid);\n            int spawnY = random.nextInt((int) GamePanel.screenhei);\n    \n            Zombie z;\n            if (currentWave >= 6 && i % 5 == 0) {\n                z = new TankZombie(spawnX, spawnY);\n            } else if (currentWave >= 4 && i % 4 == 0) {\n                z = new AsitZombie(spawnX, spawnY);\n            } else if (currentWave >= 2 && i % 3 == 0) {\n                z = new SürüngenZombie(spawnX, spawnY);\n            } else {\n                z = new NormalZombie(spawnX, spawnY);\n            }\n    \n            zombies.add(z);\n        }\n    \n        zombiesRemaining = zombieCount;\n    }\n}\n",
      "PiyadeTüfeği.java": "\npublic class PiyadeTüfeği extends Weapon {\n    \n    public PiyadeTüfeği(int reloadTime) {\n        super(reloadTime);\n        type = \"Piyade Tüfeği\";\n        maxAmmo = 30;\n        fireRate = 600;\n        mag = 20;\n        currentAmmo = 30;\n        totalAmmo = mag * currentAmmo;\n    }\n\n    public Bullet shoot(int mouseX, int mouseY, Player player1) {\n        if (canshoot()) {\n            if (currentAmmo != 0) {\n                int bulletX = player1.posx;\n                int bulletY = player1.posy;\n                double a = Math.atan2(mouseY - bulletY, mouseX - bulletX);\n                double angle = Math.random() * ((a + Math.toRadians(20)) - (a - Math.toRadians(20)))\n                        + (a - Math.toRadians(20));\n                currentAmmo--;\n                return new Bullet(bulletX, bulletY, angle, false,70);\n            } else {\n                return new Bullet();\n            }\n        }\n        return new Bullet();\n\n    }\n\n    public void reload() {\n        currentAmmo = maxAmmo;\n        totalAmmo -= maxAmmo;\n        mag--;\n    }\n}\n",
      "bullets.java": "/*\n * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license\n * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template\n */\n\n\nclass bullets {\n\n}\n",
      "KeskinNişancı.java": "public class KeskinNişancı extends Weapon {\n    \n    public KeskinNişancı(int reloadTime) {\n        super(reloadTime);\n        type = \"Keskin Nişancı Tüfeği\";\n        maxAmmo = 5;\n        fireRate = 30;\n        currentAmmo = 5;\n        mag = 10;\n        totalAmmo = currentAmmo * mag;\n    }\n\n    public void reload() {\n        currentAmmo = 5;\n        totalAmmo -= 5;\n        mag--;\n    }\n\n    public Bullet shoot(int mouseX, int mouseY, Player player1) {\n        if (canshoot()) {\n            if (currentAmmo != 0) {\n                int bulletX = player1.posx;\n                int bulletY = player1.posy;\n                double angle = Math.atan2(mouseY - bulletY, mouseX - bulletX);\n                currentAmmo--;\n                lastshoot = System.currentTimeMillis();\n                return new Bullet(bulletX, bulletY, angle, false,100);\n            } else {\n                return new Bullet();\n            }\n        }\n        return new Bullet();\n    }\n\n}\n",
      "Tabanca.java": "public class Tabanca extends Weapon {\n    public Tabanca(int reloadTime) {\n        super(reloadTime);\n        type = \"Tabanca\";\n        maxAmmo = 12;\n        fireRate = 120;\n        currentAmmo = 12;\n        mag = 200;\n        totalAmmo = currentAmmo * mag;\n    }\n\n    public Bullet shoot(int mouseX, int mouseY, Player player1) {\n        if (canshoot()) {\n            if (currentAmmo != 0) {\n                int bulletX = player1.posx;\n                int bulletY = player1.posy;\n                double angle = Math.atan2(mouseY - bulletY, mouseX - bulletX);\n                currentAmmo--;\n                lastshoot = System.currentTimeMillis();\n                return new Bullet(bulletX, bulletY, angle, false,25);\n            } else {\n                return new Bullet();\n            }\n        }\n        return new Bullet();\n\n    }\n\n    public void reload() {\n        currentAmmo = 12;\n        totalAmmo -= 12;\n        mag--;\n    }\n\n}\n",
      "Zombie.java": "import java.awt.*;\nimport java.util.ArrayList;\n\npublic abstract class Zombie {\n    double posx;\n    double posy;\n    int health;\n    double speed;\n    int damage;\n    String type;\n\n    public Zombie(int posx, int posy) {\n        this.posx = posx;\n        this.posy = posy;\n    }\n    public void takedamage(int damage) {\n        if (this.health - damage <= 0) {\n            this.health = 0;\n        } else {\n            this.health -= damage;\n        }\n    }\n    public int gethealth() {\n        return health;\n    }\n\n    abstract void attack(Player player);\n\n    public void movetoplayer(int playerx, int playery) {\n        double arc = Math.atan2(playery - posy, playerx - posx);\n        double yspd = speed * Math.abs(Math.cos(arc));\n        double xspd = speed * Math.abs(Math.sin(arc));\n        if (posx < playerx)\n            posx += yspd;\n        if (posx > playerx)\n            posx -= yspd;\n        if (posy < playery)\n            posy += xspd;\n        if (posy > playery)\n            posy -= xspd;\n        \n    }\n    public abstract void update(Player player, ArrayList<Bullet> bullets);\n    \n    \n\n    public abstract void draw(Graphics g);\n\n    public abstract Rectangle bound();\n\n    \n}\n",
      "Roketatar.java": "\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\n\n\npublic class Roketatar extends Weapon {\n \n\n    long now;\n\n    public Roketatar(int reloadTime) {\n        super(reloadTime);\n        type = \"Roketatar\";\n        maxAmmo = 1;\n        fireRate = 10;\n        currentAmmo = 1;\n        mag = 10;\n        totalAmmo = currentAmmo * mag;\n    }\n\n    public void reload() {\n        currentAmmo = 1;\n        totalAmmo -= 1;\n        mag--;\n    }\n\n    public Bullet shoot(int mouseX, int mouseY, Player player1) {\n        if (canshoot()) {\n            if (currentAmmo != 0) {\n                int bulletX = player1.posx;\n                int bulletY = player1.posy;\n                double angle = Math.atan2(mouseY - bulletY, mouseX - bulletX);\n                currentAmmo--;\n                lastshoot = System.currentTimeMillis();\n                return new Bullet(bulletX, bulletY, angle, false,101);\n            } else {\n                return new Bullet();\n            }\n        }\n        return new Bullet();\n    }\n    @Override\npublic void rokethit(Graphics g, int posx, int posy) {\n    long currentTime = System.currentTimeMillis();\n    \n    if (rockethit && rocketHitStartTime == 0) {\n        rocketHitStartTime = currentTime;\n    }\n\n    if (rockethit && (currentTime - rocketHitStartTime <= 250)) {\n        Graphics2D g2 = (Graphics2D) g;\n        g2.setColor(new Color(255, 80, 0, 120)); \n        g2.fillOval(posx - 100, posy - 100, 200, 200);\n    } else if (rockethit) {\n        \n        rockethit = false;\n        rocketHitStartTime = 0;\n    }\n}\n\n\n\n}\n",
      "AmmoDrop.java": "import java.awt.*;\nimport javax.swing.*;\n\npublic class AmmoDrop extends Drop {\n    static final Image ammoImage = new ImageIcon(\"bullet.png\").getImage();\n    public AmmoDrop(int x, int y) {\n        super(x, y);\n    }\n\n    @Override\n    public void applyEffect(Player player) {\n        \n        if(player.currentWeapon.currentAmmo==player.currentWeapon.maxAmmo){\n            player.currentWeapon.mag++;\n        }\n        player.currentWeapon.setCurrentAmmo(player.currentWeapon.maxAmmo);\n        \n    }\n\n    @Override\n    public void draw(Graphics g) {\n        g.drawImage(ammoImage, x, y, 30, 30, null);\n    }\n}\n",
      "Weapon.java": "import java.awt.Graphics;\n\npublic abstract class Weapon {\n    int currentAmmo;\n    int maxAmmo;\n    int totalAmmo;\n    int fireRate;\n    int reloadTime;\n    int mag;\n    String type;\n    long lastshoot;\n    boolean rockethit;\n    long rocketHitStartTime = 0;\n\n    public Weapon(int reloadTime) {\n        this.reloadTime = reloadTime;\n    }\n\n    public abstract Bullet shoot(int mouseX, int mouseY, Player player1);\n\n    public abstract void reload();\n\n    public int getCurrentAmmo() {\n        return currentAmmo;\n    }\n\n    public int getMag() {\n        return mag;\n    }\n\n    public boolean canshoot() {\n        long now = System.currentTimeMillis();\n        int rate = 60000 / fireRate;\n        if (now - lastshoot >= rate) {\n            return true;\n        }\n        return false;\n    }\n\n\n    public void setCurrentAmmo(int currentAmmo) {\n        this.currentAmmo = currentAmmo;\n    }\n\n    void setMag(int mag) {\n        this.mag = mag;\n    }\n\n    public void rokethit(Graphics g, int posx, int posy) {\n        \n    }\n    \n    \n\n}\n",
      "Bullet.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Bullet {\n    double posx;\n    double posy;\n    int speed;\n    double dirx;\n    double diry;\n    int damage;\n    double angle;\n    boolean active;\n    boolean multishot;\n    boolean isAcid = false;\n    boolean isrocket= false;\n\n    public Bullet(int posx, int posy, double angle, boolean multishot,int damage) {\n        this.posx = posx;\n        this.posy = posy;\n        dirx = Math.cos(angle);\n        diry = Math.sin(angle);\n        this.angle = angle;\n        active = true;\n        this.multishot = multishot;\n        this.damage = damage;\n        if(damage == 20){\n            isAcid = true;\n        }\n        if(damage == 101){\n            isrocket = true;\n        }\n    }\n\n    public Bullet() {\n        multishot = false;\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.WHITE);\n        g.fillOval((int) posx, (int) posy, 5, 5);\n    }\n\n    public void move() {\n        if (active) {\n            posx += dirx * 15;\n            posy += diry * 15;\n\n            if (posx <= 0 || posx >= GamePanel.screenwid || posy <= 0 || posy >= GamePanel.screenhei - 100) {\n                active = false;\n            }\n        }\n    }\n\n    public Rectangle bound() {\n        return new Rectangle((int) posx, (int) posy, 5, 5);\n    }\n\n}\n",
      "PompalıTüfek.java": "public class PompalıTüfek extends Weapon {\n    \n    public PompalıTüfek(int reloadTime) {\n        super(reloadTime);\n        type = \"Pompalı Tüfek\";\n        maxAmmo = 6;\n        fireRate = 60;\n        currentAmmo = 6;\n        mag = 20;\n        totalAmmo = mag * currentAmmo;\n\n    }\n\n    public Bullet shoot(int mouseX, int mouseY, Player player1) {\n        if (currentAmmo != 0) {\n            int bulletX = player1.posx;\n            int bulletY = player1.posy;\n            double a = Math.atan2(mouseY - bulletY, mouseX - bulletX);\n            currentAmmo--;\n            return new Bullet(bulletX, bulletY, a, true,15);\n        } else {\n            return new Bullet();\n        }\n\n    }\n\n    public void reload() {\n        currentAmmo = 6;\n        totalAmmo -= 6;\n        mag--;\n    }\n\n}",
      "SürüngenZombie.java": "import java.awt.*;\nimport java.util.ArrayList;\nimport javax.swing.*;\n\npublic class SürüngenZombie extends Zombie {\n    long lastJumpTime = 0;\n    long jumpCooldown = 3000;\n    boolean isJumping = false;\n    boolean jumped = false;\n    Image image = new ImageIcon(\"surungen.png\").getImage(); \n    public SürüngenZombie(int posx, int posy) {\n        super(posx, posy);\n        type = \"Sürüngen Zombie\";\n        health = 50;\n        speed = 0.5; \n        damage = 30;\n    }\n    @Override\npublic void update(Player player, ArrayList<Bullet> bullets) {\n    long now = System.currentTimeMillis();\n    double distance = Math.hypot(player.posx - posx, player.posy - posy);\n\n    if (!isJumping && distance < 120 && now - lastJumpTime >= jumpCooldown) {\n        isJumping = true;\n        speed = 5;\n        lastJumpTime = now;\n    }\n\n    if (isJumping && now - lastJumpTime >= 500) {\n        isJumping = false;\n        speed = 0.5;\n    }\n\n    movetoplayer(player.posx, player.posy);\n}\n\n\n    @Override\n    public void attack(Player player) {\n       \n    }\n\n    @Override\n    public void draw(Graphics g) {\n        \n        if (isJumping) {\n            Image jumpImage = new ImageIcon(\"solayuru.png\").getImage(); \n            g.drawImage(jumpImage, (int) posx, (int) posy - 20, 30, 30, null); \n        }else{\n        g.drawImage(image, (int) posx, (int) posy, 30, 30, null);\n\n        // Can barı\n        g.setColor(Color.RED);\n        g.fillRect((int) posx-2 , (int) posy - 10, 50, 5);\n        g.setColor(Color.GREEN);\n        g.fillRect((int) posx-2 , (int) posy - 10, (int) ((health / 50.0) * 50), 5);\n        }\n    }\n\n    @Override\n    public Rectangle bound() {\n        return new Rectangle((int) posx, (int) posy, 30, 30);\n    }\n}",
      "NormalZombie.java": "import java.awt.*;\nimport java.util.ArrayList;\nimport javax.swing.*;\n\npublic class NormalZombie extends Zombie {\n    Image image = new ImageIcon(\"skeleton.png\").getImage();\n    public NormalZombie(int posx, int posy) {\n        super(posx, posy);\n        type = \"Normal Zombie\";\n        health = 40;\n        speed = 2;\n        damage = 15;\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        g.drawImage(image, (int) posx, (int) posy, 30, 30, null);\n        g.setColor(Color.RED);\n        g.fillRect((int) posx , (int) posy - 15, 30, 5);\n        g.setColor(Color.GREEN);\n        g.fillRect((int) posx , (int) posy - 15, (int)((health / 40.0) * 30), 5);\n    }\n\n    @Override\n    public void attack(Player player) {\n       \n    }\n\n    @Override\n    public Rectangle bound() {\n        return new Rectangle((int) posx, (int) posy, 30, 30);\n    }\n\n    @Override\n    public void update(Player player, ArrayList<Bullet> bullets) {\n        this.movetoplayer(player.posx, player.posy);\n    }\n}\n",
      "AsitZombie.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Image;\nimport java.awt.Rectangle;\nimport java.util.ArrayList;\nimport javax.swing.ImageIcon;\n\n\npublic class AsitZombie extends Zombie {\n    Image image = new ImageIcon(\"zombie111.png\").getImage();\n    long lastFireTime;\n    public AsitZombie(int posx, int posy) {\n        super(posx, posy);\n        type = \"Asit Tüküren Zombie\";\n        health = 30;\n        speed = 1;\n        damage = 30;\n    }\n    public void update(Player player, ArrayList<Bullet> bullets) {\n        movetoplayer(player.posx, player.posy);\n\n        long now = System.currentTimeMillis();\n        if (now - lastFireTime > 2000) {\n            double angle = Math.atan2(player.posy - posy, player.posx - posx);\n            bullets.add(new Bullet((int) posx, (int) posy, angle, false, 20));\n            lastFireTime = now;\n        }\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        \n        g.setColor(Color.GREEN);\n        g.drawImage(image, (int) posx, (int) posy, 30,30, null);\n        g.setColor(Color.RED);\n        g.fillRect((int) posx , (int) posy - 15, 30, 5);\n        g.setColor(Color.GREEN);\n        g.fillRect((int) posx , (int) posy - 15, (int)(( health / 30.0) * 30), 5);\n    }\n    \n\n    \n\n    public Rectangle bound() {\n        return new Rectangle((int) posx, (int) posy, 20, 20);\n    }\n\n    @Override\n    void attack(Player player) {\n        \n    }\n    \n}\n",
      "GamePanel.java": "\nimport java.awt.*;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Random;\nimport javax.swing.*;\n\npublic class GamePanel extends JPanel implements KeyListener, Runnable, MouseListener, MouseMotionListener {\n\n\n    Player player1;\n    Bullet bullet;\n    JButton resumeButton, mainMenuButton, exitButton, saveButton;\n    boolean fired = false;\n    boolean firing = false;\n    ArrayList<Weapon> unlockedWeapons = new ArrayList<>();\n    ArrayList<Zombie> zombies = new ArrayList<>();\n    ArrayList<Bullet> bullets = new ArrayList<>();\n    ArrayList<Drop> drops = new ArrayList<>();\n    Image backgroundImage;\n    public boolean testMode = false;\n    private boolean testPanelVisible = false;\n\n    static Dimension size = Toolkit.getDefaultToolkit().getScreenSize();\n    static double screenhei = size.getHeight();\n    static double screenwid = size.getWidth();\n    Thread hareket;\n    int mousex;\n    int mousey;\n    GameManager manager;\n    int ypos = 130;\n    private boolean godMode = false;\n    private boolean oneShotMode = false;\n\n\n    public GamePanel() {\n\n        setBackground(Color.BLACK);\n        addKeyListener(this);\n        addMouseListener(this);\n        addMouseMotionListener(this);\n        manager = new GameManager();\n        manager.startGameWithTransition();\n        backgroundImage = new ImageIcon(\"ground.jpg\").getImage();\n        player1 = new Player(250, 250, 1, 0);\n        \n\n\n        setFocusable(true);\n        requestFocusInWindow();\n        hareket = new Thread(this);\n        hareket.start();\n        unlockedWeapons.add(new Tabanca(0));\n\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            update();\n            repaint();\n            try {\n                Thread.sleep(16);\n            } catch (InterruptedException ex) {\n            }\n        }\n    }\n    public boolean hasWeapon(String type) {\n        for (Weapon w : unlockedWeapons) {\n            if (w.type.equals(type)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void update() {\n        manager.update(zombies, player1);\n        if (manager.getState() != GameManager.STATE_PLAYING){\n            return;\n        }\n        \n        int wave = manager.getWaveManager().getCurrentWave();\n        if (wave == 3 && !hasWeapon(\"Pompalı Tüfek\")) {\n            unlockedWeapons.add(new PompalıTüfek(0));\n        } else if (wave == 5 && !hasWeapon(\"Piyade Tüfeği\")) {\n            unlockedWeapons.add(new PiyadeTüfeği(0));\n        } else if (wave == 7 && !hasWeapon(\"Keskin Nişancı Tüfeği\")) {\n            unlockedWeapons.add(new KeskinNişancı(0));\n        } else if (wave == 10 && !hasWeapon(\"Roketatar\")) {\n            unlockedWeapons.add(new Roketatar(0));\n        }\n        if (player1.score >= player1.level * 100) {\n            player1.levelUp();\n        }\n        \n        for (Zombie z : zombies) {\n            z.update(player1, bullets);\n        }\n        player1.move();\n        for (int i = bullets.size() - 1; i >= 0; i--) {\n            Bullet b = bullets.get(i);\n            b.move();\n            if (!b.active) {\n                bullets.remove(i);\n            }\n        }\n        checkhit();\n        \n        \n\n    }\n\n    public void checkhit() {\n        \n        for (int i = bullets.size() - 1; i >= 0; i--) {\n            Rectangle b = bullets.get(i).bound();\n            if(bullets.get(i).isAcid){\n                break;\n            }\n            \n            for (int j = zombies.size() - 1; j >= 0; j--) {\n\n                Rectangle z = zombies.get(j).bound();\n                if (b.getBounds().intersects(z.getBounds())) {\n                    if (player1.currentWeapon.type.equals(\"Keskin Nişancı Tüfeği\")) {\n                        \n                        if (oneShotMode) {\n                        \n                            zombies.get(j).takedamage(9999); \n                        } else {\n                            zombies.get(j).takedamage(bullets.get(i).damage);\n                        }\n                        if (zombies.get(j).gethealth() <= 0) {\n                            \n                            if (new Random().nextInt(100) < 30) {\n                                drops.add(new AmmoDrop((int) zombies.get(j).posx, (int) zombies.get(j).posy));\n                            }\n                            if (new Random().nextInt(100) < 10) {\n                                drops.add(new HealDrop((int) zombies.get(j).posx, (int) zombies.get(j).posy));\n                            }\n                            player1.score += 10;\n\n                            zombies.remove(j);\n                            manager.getWaveManager().zombiekill();\n                        }\n                        \n                        break;\n\n                    }\n                    if(b.getBounds().intersects(player1.bound().getBounds())){\n                        player1.takedamage(10);\n                        bullets.get(i).active = false;\n                        break;\n                    }\n\n                    if (player1.currentWeapon.type.equals(\"Roketatar\")) {\n                        bullets.get(i).active = false;\n                    \n                        \n                        Roketatar rocketGun = (Roketatar) player1.currentWeapon;\n                        rocketGun.rockethit = true;\n                        rocketGun.rocketHitStartTime = System.currentTimeMillis();\n                        \n                        if (oneShotMode) {\n                            zombies.get(j).takedamage(9999);\n                        } else {\n                            zombies.get(j).takedamage(bullets.get(i).damage);\n                        }\n                    \n                        if (zombies.get(j).gethealth() <= 0) {\n                            player1.score += 10;\n                            manager.getWaveManager().zombiekill();\n                            zombies.remove(j);\n                        }\n                    \n                        break;\n                    } else {\n                        bullets.get(i).active = false;\n                        if (oneShotMode) {\n                            zombies.get(j).takedamage(9999);\n                        } else {\n                            zombies.get(j).takedamage(bullets.get(i).damage);\n                        }\n                        if (zombies.get(j).gethealth() <= 0) {\n                            \n                            if (new Random().nextInt(100) < 15) {\n                                drops.add(new AmmoDrop((int) zombies.get(j).posx, (int) zombies.get(j).posy));\n                            }\n                            if (new Random().nextInt(100) < 10) {\n                                drops.add(new HealDrop((int) zombies.get(j).posx, (int) zombies.get(j).posy));\n                            }\n                            \n                            zombies.remove(j);\n                            player1.score += 10;\n\n                            manager.getWaveManager().zombiekill();\n                        }\n                        \n                        break;\n                    }\n                    \n                }\n            }\n        }\n        for (int q = zombies.size() - 1; q >= 0; q--) {\n            if (player1.bound().intersects(zombies.get(q).bound())) {\n                if (!godMode) {\n                    player1.takedamage(zombies.get(q).damage);\n                }\n            }\n        }\n       \n        for (int i = drops.size() - 1; i >= 0; i--) {\n            Drop d = drops.get(i);\n            if (player1.bound().intersects(d.getBounds())) {\n                d.applyEffect(player1);\n                drops.remove(i);\n            }\n        }\n\n        if (player1.score >= player1.level * 100) {\n            player1.level++;\n            \n        }\n        for (int i = 0; i < bullets.size(); i++) {\n            if (player1.bound().intersects(bullets.get(i).bound())&& bullets.get(i).isAcid) {\n                if (!godMode) {\n                    player1.takedamage(20);\n                }\n                bullets.get(i).active = false;\n                bullets.remove(i);\n                \n            }\n        }\n        \n        \n\n    }\n    public void createPauseMenu() {\n        setLayout(null);\n    \n        int centerX = getWidth() / 2 - 150;\n        int startY = getHeight() / 2 - 140;\n    \n        Font buttonFont = new Font(\"Segoe UI\", Font.BOLD, 22);\n        Color buttonColor = new Color(45, 45, 45);\n        Color textColor = new Color(255, 255, 255);\n    \n        resumeButton = new JButton(\"Devam Et\");\n        resumeButton.setBounds(centerX, startY, 300, 50);\n        resumeButton.setFont(buttonFont);\n        resumeButton.setBackground(buttonColor);\n        resumeButton.setForeground(textColor);\n        resumeButton.setFocusPainted(false);\n        resumeButton.addActionListener(e -> {\n            manager.setState(GameManager.STATE_PLAYING);\n            removePauseMenu();\n        });\n    \n        mainMenuButton = new JButton(\"Ana Menüye Dön\");\n        mainMenuButton.setBounds(centerX, startY + 60, 300, 50);\n        mainMenuButton.setFont(buttonFont);\n        mainMenuButton.setBackground(buttonColor);\n        mainMenuButton.setForeground(textColor);\n        mainMenuButton.setFocusPainted(false);\n        mainMenuButton.addActionListener(e -> {\n            JFrame frame = (JFrame) SwingUtilities.getWindowAncestor(this);\n            frame.setContentPane(new Menu(frame));\n            frame.revalidate();\n        });\n    \n        saveButton = new JButton(\"Kaydet\");\n        saveButton.setBounds(centerX, startY + 120, 300, 50);\n        saveButton.setFont(buttonFont);\n        saveButton.setBackground(buttonColor);\n        saveButton.setForeground(textColor);\n        saveButton.setFocusPainted(false);\n        saveButton.addActionListener(e -> saveGame(\"savegame.txt\"));\n    \n        exitButton = new JButton(\"Çıkış\");\n        exitButton.setBounds(centerX, startY + 180, 300, 50);\n        exitButton.setFont(buttonFont);\n        exitButton.setBackground(buttonColor);\n        exitButton.setForeground(textColor);\n        exitButton.setFocusPainted(false);\n        exitButton.addActionListener(e -> System.exit(0));\n    \n        add(resumeButton);\n        add(mainMenuButton);\n        add(saveButton);\n        add(exitButton);\n        repaint();\n    }\n    \n    public void removePauseMenu() {\n        remove(resumeButton);\n        remove(mainMenuButton);\n        remove(exitButton);\n        remove(saveButton);\n        repaint();\n    }\n\n    @Override\n    \npublic void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    g.drawImage(backgroundImage, 0, 0, getWidth(), getHeight(), null);\n    Graphics2D g2d = (Graphics2D) g;\n\n    // HUD kutusu\n    g2d.setColor(new Color(0, 0, 0, 150));\n    g2d.fillRoundRect(10, 10, 240, 130, 15, 15);\n\n    g2d.setColor(Color.WHITE);\n    g2d.setFont(new Font(\"Segoe UI\", Font.PLAIN, 16));\n    g2d.drawString(\"Silah: \" + player1.currentWeapon.type, 20, 40);\n    g2d.drawString(\"Mermi: \" + player1.currentWeapon.getCurrentAmmo(), 20, 65);\n    g2d.drawString(\"Şarjör: \" + player1.currentWeapon.getMag(), 20, 90);\n    g2d.drawString(\"Can: \" + player1.health, 20, 115);\n    g2d.drawString(\"Dalga: \" + manager.getWaveManager().getCurrentWave(), 140, 65);\n    g2d.drawString(\"Zombi: \" + zombies.size(), 140, 90);\n    g2d.drawString(\"Kontroller için K tuşuna basın... \", 20, 170);\n    \n\n\n    \n    player1.draw(g);\n    player1.drawbar(g);\n    for (Bullet b : bullets) {\n        if (b.isrocket) {\n            player1.currentWeapon.rokethit(g, (int) b.posx, (int) b.posy);\n        }\n        b.draw(g);\n    }\n    for(Drop d : drops) {\n        d.draw(g);\n    }\n    if (testMode) {\n        g.setColor(Color.YELLOW);\n        g.setFont(new Font(\"Arial\", Font.PLAIN, 14));\n        g.drawString(\"TEST MODU AKTİF\", getWidth() - 150, 10);\n    }\n    g.setFont(new Font(\"Arial\", Font.BOLD, 18));\n    g.setColor(Color.WHITE);\n    g.drawString(\"Skor: \" + player1.score, getWidth() - 160, 30);\n    g.drawString(\"Seviye: \" + player1.level, getWidth() - 160, 50);\n    if (testPanelVisible) {\n        Graphics2D g2 = (Graphics2D) g;\n        g2.drawString(\"N - Hasar Alma: \" + (godMode ? \"AÇIK\" : \"KAPALI\"), getWidth() - 530, 160);\n        g2.drawString(\"M - Tek Atış: \" + (oneShotMode ? \"AÇIK\" : \"KAPALI\"), getWidth() - 530, 190);\n        g2.setColor(new Color(0, 0, 0, 180));\n        g2.fillRect(getWidth() - 250, 20, 230, 400);\n        g2.setColor(Color.WHITE);\n        g2.drawRect(getWidth() - 250, 20, 230, 400);\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 14));\n        g2.drawString(\"KONTROLLER\", getWidth() - 190, 40);\n        g2.setFont(new Font(\"Arial\", Font.PLAIN, 12));\n        g2.drawString(\"A - Sol\", getWidth() - 230, 70);\n        g2.drawString(\"D - Sağ\", getWidth() - 230, 100);\n        g2.drawString(\"W - Yukarı\", getWidth() - 230, 130);\n        g2.drawString(\"S - Aşağı\", getWidth() - 230, 160);\n        g2.drawString(\"R - Şarjör Değiştir\", getWidth() - 230, 190);\n\n        g2.drawString(\"U - Dalga +1\", getWidth() - 230, 370);\n        g2.drawString(\"I - Can +50\", getWidth() - 230, 250);\n        g2.drawString(\"O - Mermi +30\", getWidth() - 230, 280);\n        g2.drawString(\"N - Ölümsüz\", getWidth() - 230, 310);\n        g2.drawString(\"M - Tek Atma\", getWidth() - 230, 340);\n        g2.drawString(\"Y - Hile Modu\", getWidth() - 230, 220);\n        g2.drawString(\"1,2,3,4,5 - Silah Değiştirme\", getWidth() - 230, 400);\n    }\n    \n    if (manager.getState() == GameManager.STATE_GAME_OVER) {\n        Graphics2D g3d = (Graphics2D) g;\n        g3d.setColor(new Color(0, 0, 0, 180));\n        g3d.fillRect(0, 0, getWidth(), getHeight());\n    \n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 36));\n        g.drawString(\"OYUN BİTTİ\", getWidth() / 2 - 100, 200);\n    \n        g.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        g.drawString(\"Geçilen Dalga: \" + manager.getWaveManager().getCurrentWave(), getWidth() / 2 - 100, 280);\n        g.drawString(\"Toplam Skor: \" + player1.score, getWidth() / 2 - 100, 310);\n        g.drawString(\"Öldürülen Zombi: \" + manager.getWaveManager().getTotalZombiesKilled(), getWidth() / 2 - 100, 340);\n    \n        g.drawString(\"Ana menüye dönmek için ESC'ye basın\", getWidth() / 2 - 150, 400);\n    }\n    \n    \n\n\n\n\n    for (Zombie a : zombies) a.draw(g);\n    for (Bullet b : bullets) {\n        player1.currentWeapon.rokethit(g, (int) b.posx, (int) b.posy);\n        b.draw(g);\n    }\n    \n    \n    \n\n    player1.damaged(g);\n\n    \n    if (manager.getState() == GameManager.STATE_TRANSITION) {\n        g2d.setFont(new Font(\"Arial\", Font.BOLD, 36));\n        g2d.setColor(Color.YELLOW);\n        g2d.drawString(\"Dalga \" + (manager.getWaveManager().getCurrentWave() + 1) + \" geliyor...\",\n                getWidth() / 2 - 200, 100);\n    }\n\n    if (manager.getState() == GameManager.STATE_PAUSED) {\n        g2d.setColor(new Color(0, 0, 0, 180));\n        g2d.fillRect(0, 0, getWidth(), getHeight());\n\n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 36));\n        g.drawString(\"OYUN DURAKLATILDI\", getWidth() / 2 - 200, 200);\n        g.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        g.drawString(\"Devam etmek için ESC'ye bas\", getWidth() / 2 - 200, 260);\n    }\n}\n\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int key = e.getKeyCode();\n        if (key == KeyEvent.VK_A) {\n\n            player1.left = true;\n        }\n\n        if (key == KeyEvent.VK_D) {\n\n            player1.right = true;\n        }\n\n        if (key == KeyEvent.VK_S) {\n\n            player1.down = true;\n        }\n\n        if (key == KeyEvent.VK_W) {\n\n            player1.up = true;\n        }\n\n        if (key == KeyEvent.VK_R) {\n            player1.currentWeapon.reload();\n        }\n        if (key == KeyEvent.VK_T) {\n            zombies.add(new AsitZombie(79, 78));\n        }\n        if (key == KeyEvent.VK_ESCAPE) {\n            if (manager.getState() == GameManager.STATE_PLAYING) {\n                manager.setState(GameManager.STATE_PAUSED);\n                createPauseMenu();\n            } else if (manager.getState() == GameManager.STATE_PAUSED) {\n                manager.setState(GameManager.STATE_PLAYING);\n                removePauseMenu();\n            }\n        }\n        if (key == KeyEvent.VK_1 && unlockedWeapons.size() >= 1) {\n            player1.switchWeapon(unlockedWeapons.get(0));\n        }\n        if (key == KeyEvent.VK_2 && unlockedWeapons.size() >= 2) {\n            player1.switchWeapon(unlockedWeapons.get(1));\n        }\n        if (key == KeyEvent.VK_3 && unlockedWeapons.size() >= 3) {\n            player1.switchWeapon(unlockedWeapons.get(2));\n        }\n        if (key == KeyEvent.VK_4 && unlockedWeapons.size() >= 4) {\n            player1.switchWeapon(unlockedWeapons.get(3));\n        }\n        if (key == KeyEvent.VK_5 && unlockedWeapons.size() >= 5) {\n            player1.switchWeapon(unlockedWeapons.get(4));\n        }\n        if (manager.getState() == GameManager.STATE_GAME_OVER) {\n            if (key == KeyEvent.VK_M) {\n                JFrame frame = (JFrame) SwingUtilities.getWindowAncestor(this);\n                frame.setContentPane(new Menu(frame));\n                frame.revalidate();\n            } else if (key == KeyEvent.VK_ESCAPE) {\n                System.exit(0);\n            }\n        }\n        if (key == KeyEvent.VK_Y) {\n            testMode = !testMode; \n            \n        }\n        if (key == KeyEvent.VK_N) {\n            godMode = !godMode;\n        }\n        if (key == KeyEvent.VK_M) {\n            oneShotMode = !oneShotMode;\n        }\n        \n        \n        if (testMode) {\n            if (key == KeyEvent.VK_U) {\n                manager.getWaveManager().currentWave++;\n                manager.getWaveManager().startNextWave(zombies);\n                int wave = manager.getWaveManager().getCurrentWave();\n                if (wave == 3 && !hasWeapon(\"Pompalı Tüfek\")) {\n                    unlockedWeapons.add(new PompalıTüfek(0));\n                } else if (wave == 5 && !hasWeapon(\"Piyade Tüfeği\")) {\n                    unlockedWeapons.add(new PiyadeTüfeği(0));\n                } else if (wave == 7 && !hasWeapon(\"Keskin Nişancı Tüfeği\")) {\n                    unlockedWeapons.add(new KeskinNişancı(0));\n                } else if (wave == 10 && !hasWeapon(\"Roketatar\")) {\n                    unlockedWeapons.add(new Roketatar(0));\n                }\n            }\n            if (testPanelVisible && key == KeyEvent.VK_I) {\n                player1.health = Math.min(100, player1.health + 50);\n            }\n            if (testPanelVisible && key == KeyEvent.VK_O) {\n                player1.currentWeapon.setMag(player1.currentWeapon.getMag() + 30);\n            }\n\n        }\n        if (key == KeyEvent.VK_K) {\n            testPanelVisible = !testPanelVisible;\n        }\n        \n\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int key = e.getKeyCode();\n        if (key == KeyEvent.VK_A && (player1.posx) > 0) {\n\n            player1.left = false;\n\n        }\n        if (key == KeyEvent.VK_D && (player1.posx + 10) < screenwid) {\n            player1.right = false;\n\n        }\n        if (key == KeyEvent.VK_S && (player1.posy + 10) < screenhei) {\n            player1.down = false;\n\n        }\n        if (key == KeyEvent.VK_W && (player1.posy) > 0) {\n            player1.up = false;\n\n        }\n        repaint();\n    }\n\n    \n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        mousex = e.getX();\n        mousey = e.getY();\n        Bullet bull = player1.currentWeapon.shoot(mousex, mousey, player1);\n        if (bull.multishot) {\n            double a = bull.angle;\n            for (int i = -20; i <= 20; i += 5) {\n                double angle = a + Math.toRadians(i);\n                bullets.add(new Bullet((int) bull.posx, (int) bull.posy, angle, false,15));\n            }\n        } else {\n            bullets.add(bull);\n        }\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n    }\n    public void saveGame(String fileName) {\n        try (PrintWriter writer = new PrintWriter(fileName)) {\n            writer.println(player1.posx);\n            writer.println(player1.posy);\n            writer.println(player1.health);\n            writer.println(player1.score);\n            writer.println(player1.currentWeapon.type);\n            writer.println(player1.currentWeapon.getCurrentAmmo());\n            writer.println(player1.currentWeapon.getMag());\n            writer.println(manager.getWaveManager().getCurrentWave());\n    \n           \n            writer.println(unlockedWeapons.size());\n            for (Weapon w : unlockedWeapons) {\n                writer.println(w.type);\n            }\n    \n           \n            writer.println(zombies.size());\n            for (Zombie z : zombies) {\n                writer.println(z.getClass().getSimpleName() + \",\" + z.posx + \",\" + z.posy + \",\" + z.health);\n            }\n    \n            writer.flush();\n            \n    \n         \n            JFrame frame = (JFrame) SwingUtilities.getWindowAncestor(this);\n            frame.setContentPane(new Menu(frame));\n            frame.revalidate();\n    \n        } catch (Exception e) {\n            System.out.println(\"HATA - Kaydetme başarısız: \" + e.getMessage());\n        }\n    }\n    \n    public void loadGame(String fileName) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n            player1.posx = Integer.parseInt(reader.readLine());\n            player1.posy = Integer.parseInt(reader.readLine());\n            player1.health = Integer.parseInt(reader.readLine());\n            player1.score = Integer.parseInt(reader.readLine());\n            String weaponType = reader.readLine();\n            int currentAmmo = Integer.parseInt(reader.readLine());\n            int mag = Integer.parseInt(reader.readLine());\n    \n            switch (weaponType) {\n                case \"Tabanca\": player1.currentWeapon = new Tabanca(0); break;\n                case \"Pompalı Tüfek\": player1.currentWeapon = new PompalıTüfek(0); break;\n                case \"Piyade Tüfeği\": player1.currentWeapon = new PiyadeTüfeği(0); break;\n                case \"Keskin Nişancı Tüfeği\": player1.currentWeapon = new KeskinNişancı(0); break;\n                case \"Roketatar\": player1.currentWeapon = new Roketatar(0); break;\n            }\n    \n            player1.currentWeapon.setCurrentAmmo(currentAmmo);\n            player1.currentWeapon.setMag(mag);\n    \n            int wave = Integer.parseInt(reader.readLine());\n            manager.getWaveManager().currentWave = wave;\n    \n           \n            unlockedWeapons.clear();\n            int weaponCount = Integer.parseInt(reader.readLine());\n            for (int i = 0; i < weaponCount; i++) {\n                String w = reader.readLine();\n                switch (w) {\n                    case \"Tabanca\": unlockedWeapons.add(new Tabanca(0)); break;\n                    case \"Pompalı Tüfek\": unlockedWeapons.add(new PompalıTüfek(0)); break;\n                    case \"Piyade Tüfeği\": unlockedWeapons.add(new PiyadeTüfeği(0)); break;\n                    case \"Keskin Nişancı Tüfeği\": unlockedWeapons.add(new KeskinNişancı(0)); break;\n                    case \"Roketatar\": unlockedWeapons.add(new Roketatar(0)); break;\n                }\n            }\n    \n            \n            zombies.clear();\n            int zombieCount = Integer.parseInt(reader.readLine());\n            for (int i = 0; i < zombieCount; i++) {\n                String[] parts = reader.readLine().split(\",\");\n                String type = parts[0];\n                int zx = Integer.parseInt(parts[1]);\n                int zy = Integer.parseInt(parts[2]);\n                int zh = Integer.parseInt(parts[3]);\n    \n                Zombie z = null;\n                switch (type) {\n                    case \"AsitZombie\": z = new AsitZombie(zx, zy); break;\n                    case \"NormalZombie\": z = new NormalZombie(zx, zy); break;\n                    case \"SürüngenZombie\": z = new SürüngenZombie(zx, zy); break;\n                    case \"TankZombie\": z = new TankZombie(zx, zy); break;\n                }\n    \n                if (z != null) {\n                    z.health = zh;\n                    zombies.add(z);\n                \n                }\n                manager.setState(GameManager.STATE_PLAYING);\n                manager.waveStarted=true;\n            }\n    \n            \n            manager.setState(GameManager.STATE_PLAYING);\n            \n    \n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n\n}\n",
      "Drop.java": "import java.awt.*;\n\npublic abstract class Drop {\n    protected int x, y;\n\n    public Drop(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n \n    public abstract void applyEffect(Player player);\n\n   \n    public abstract void draw(Graphics g);\n\n  \n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 30, 30);\n    }\n}\n",
      "GameManager.java": "import java.util.ArrayList;\n\npublic class GameManager {\n    public static final int STATE_MENU = 0;\n    public static final int STATE_PLAYING = 1;\n    public static final int STATE_PAUSED = 2;\n    public static final int STATE_GAME_OVER = 3;\n    public static final int STATE_TRANSITION = 4;\n    int currentState = 0;\n    WaveManager waveManager;\n    long transitionStartTime = 0;\n    boolean waveStarted = false;\n    \n\n    public GameManager() {\n        waveManager = new WaveManager();\n    }\n\n    public int getState() {\n        return currentState;\n    }\n\n    public void setState(int state) {\n        currentState = state;\n        if (state == STATE_TRANSITION) {\n            transitionStartTime = System.currentTimeMillis();\n            waveStarted = false;\n        }\n    }\n\n    public WaveManager getWaveManager() {\n        return waveManager;\n    }\n\n    public void startGameWithTransition() {\n        setState(STATE_TRANSITION);\n        transitionStartTime = System.currentTimeMillis();\n        waveStarted = false;\n    }\n\n    public void update(ArrayList<Zombie> zombies, Player player) {\n        if (currentState == STATE_PLAYING) {\n            if (player.health <= 0) {\n                setState(STATE_GAME_OVER);\n            } else if (this.getWaveManager().isWaveOver()) {\n                int wave = waveManager.getCurrentWave();\n    \n             \n                if (wave == 2 && !(player.currentWeapon instanceof PiyadeTüfeği)) {\n                    player.switchWeapon(new PiyadeTüfeği(0));\n                    \n                } else if (wave == 4 && !(player.currentWeapon instanceof PompalıTüfek)) {\n                    player.switchWeapon(new PompalıTüfek(0));\n                    \n                } else if (wave == 6 && !(player.currentWeapon instanceof KeskinNişancı)) {\n                    player.switchWeapon(new KeskinNişancı(0));\n                    \n                } else if (wave == 8 && !(player.currentWeapon instanceof Roketatar)) {\n                    player.switchWeapon(new Roketatar(0));\n                    \n                }\n    \n                setState(STATE_TRANSITION);\n            }\n        }\n    \n        if (currentState == STATE_TRANSITION && !waveStarted) {\n            long now = System.currentTimeMillis();\n            if (now - transitionStartTime >= 2000) {\n                waveManager.startNextWave(zombies);\n                setState(STATE_PLAYING);\n                waveStarted = true;\n            }\n        }\n    }\n    \n    \n}",
      "HealDrop.java": "import java.awt.*;\nimport javax.swing.*;\n\npublic class HealDrop extends Drop {\n    static final Image healImage = new ImageIcon(\"regeneration.png\").getImage();\n    public HealDrop(int x, int y) {\n        super(x, y);\n    }\n\n    @Override\n    public void applyEffect(Player player) {\n        player.health += 35;\n        if (player.health > 100) player.health = 100;\n    }\n\n    @Override\n    public void draw(Graphics g) {\n        g.drawImage(healImage, x, y, 30, 30, null);\n    }\n}\n",
      "AsitBullet.java": "",
      "TankZombie.java": "import java.awt.*;\nimport java.util.ArrayList;\nimport javax.swing.*;\n\npublic class TankZombie extends Zombie {\n    Image image = new ImageIcon(\"tank.png\").getImage(); \n    public TankZombie(int posx, int posy) {\n        super(posx, posy);\n        type = \"Tank Zombie\";\n        health = 150;\n        speed = 0.3;\n        damage = 50;\n    }\n\n    @Override\n    public void attack(Player player) {\n        \n    }\n\n    @Override\n    public void draw(Graphics g) {\n        g.drawImage(image, (int) posx, (int) posy, 60, 70, null);\n\n        g.setColor(Color.RED);\n        g.fillRect((int) posx, (int) posy-3 , 70, 5);\n        g.setColor(Color.GREEN);\n        g.fillRect((int) posx, (int) posy-3 , (int) ((health / 150.0) * 70), 5);\n    }\n\n    @Override\n    public Rectangle bound() {\n        return new Rectangle((int) posx, (int) posy, 40, 40);\n    }\n\n    @Override\n    public void update(Player player, ArrayList<Bullet> bullets) {\n        this.movetoplayer(player.posx, player.posy);\n    }\n}\n",
      "Game.java": "import java.awt.Toolkit;\nimport javax.swing.JFrame;\n\npublic class Game {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"ShooterZZ\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(Toolkit.getDefaultToolkit().getScreenSize());\n        frame.setLocationRelativeTo(null);\n        Menu menu = new Menu(frame);\n        frame.setContentPane(menu);\n        frame.setVisible(true);\n    }\n}\n",
      "Player.java": "import java.awt.*;\nimport javax.swing.*;\n\npublic class Player {\n    int posx;\n    int posy;\n    int health;\n    int score;\n    int speed;\n    boolean damaged = false;\n    Weapon currentWeapon;\n    static int wid;\n    static int hei;\n    long lastDamageTime = 0;\n    int damageCooldown = 1000; \n    boolean up, down, right, left;\n    int maxHealth;\n    long lastDamagedTime = 0;\n    long damageEffectStartTime = 0;\n    long damageEffectDuration = 300; \n    int level = 1;\n    Image img=new ImageIcon(\"assayuru.png\").getImage();\n\n    \n\n\n    public Player(int posx, int posy, int health, int speed) {\n        this.posx = posx;\n        this.posy = posy;\n        this.health = 100;\n        this.speed = speed;\n        this.score = 0;\n        this.currentWeapon = new Tabanca(5);\n        this.maxHealth = health;\n\n    }\n\n    public void switchWeapon(Weapon newWeapon) {\n        currentWeapon = newWeapon;\n    }\n\n    public void shoot(int x, int y) {\n\n    }\n\n    public void reload() {\n\n    }\n    public void levelUp() {\n        level++;\n    \n        \n        health += 20;\n        if (health > 100) {\n            health = 100;\n        }\n    \n        \n        speed += 1;\n        if (speed > 10) {\n            speed = 10;\n        }\n    \n        \n    }\n    \n\n    public void move() {\n        if (up) {\n            if (posy - 4 <= 0) {\n                up = false;\n            } else {\n                posy -= 4;\n            }\n            img= new ImageIcon(\"yukaruyuru.png\").getImage();\n        }\n        if (down) {\n            if (posy + 4 + 30 + 50 >= GamePanel.screenhei) {\n                down = false;\n            } else {\n                posy += 4;\n            }\n            img= new ImageIcon(\"assayuru.png\").getImage();\n        }\n        if (right) {\n            if (posx + 4 + 30 >= GamePanel.screenwid) {\n                right = false;\n            } else {\n                posx += 4;\n            }\n            img= new ImageIcon(\"sagayuru.png\").getImage();\n        }\n        if (left) {\n            if (posx - 4 <= 0) {\n                left = false;\n            } else {\n                posx -=4;\n            }\n            img= new ImageIcon(\"solayuru.png\").getImage();\n        }\n\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.RED);\n        g.drawImage(img, posx, posy, 20, 40,null);\n    }\n    public void drawbar(Graphics g) {\n        int barWidth = 100;\n        int barHeight = 10;\n        int offsetX = 40;\n        int offsetY = 20;\n    \n        int currentWidth = (int) ((health / 100.0) * barWidth);\n    \n        g.setColor(Color.RED);\n        g.fillRect(posx - offsetX, posy - offsetY, barWidth, barHeight); \n    \n        g.setColor(Color.GREEN);\n        g.fillRect(posx - offsetX, posy - offsetY, currentWidth, barHeight); \n    \n        g.setColor(Color.BLACK);\n        g.drawRect(posx - offsetX, posy - offsetY, barWidth, barHeight);\n    }\n    \n    \n\n    public void damaged(Graphics g) {\n        if (damaged) {\n            long now = System.currentTimeMillis();\n            if (now - damageEffectStartTime <= damageEffectDuration) {\n                g.setColor(new Color(255, 0, 0, 100)); \n                g.fillRect(0, 0, (int) GamePanel.screenwid, (int) GamePanel.screenhei);\n            } else {\n                damaged = false; \n            }\n        }\n    }\n    \n    \n\n    public Rectangle bound() {\n        return new Rectangle((int) posx, (int) posy, 20, 40);\n    }\n\n   \n\n    public void takedamage(int damage) {\n        long now = System.currentTimeMillis();\n        if (now - lastDamageTime >= damageCooldown) {\n            health -= damage;\n            if (health < 0) health = 0;\n            damaged = true;\n            damageEffectStartTime = now;\n            lastDamageTime = now;\n        }\n    }\n    \n    \n\n    \n    \n\n}\n"
    },
    {
      "id": "5187413",
      "Sniper.java": "public class Sniper extends Weapon {\n    public static final int ammo = 5;\n    public static final double speedRate = 30;\n    public static final int waveNumber = 6;\n    private double lastFiredTime = 0;\n\n    Handler handler;\n\n    public Sniper() {\n        super(Sniper.class, ammo, speedRate, waveNumber);\n\n    }\n\n    public void reload() {\n        if (handler.sniperCharger > 0) {\n            if (currentAmmo != ammo) {\n                currentAmmo = ammo;\n\n            }\n\n        } else {\n            System.out.println(\"No Charger Left!!!\");\n        }\n\n    }\n\n    public void fire(int mouseX, int mouseY, int playerX, int playerY, Handler handler, SpriteSheet ss,\n            long currentTime) {\n        if (currentTime - lastFiredTime >= 1000 / speedRate) {\n            double angleToPlayer = Math.atan2(mouseY - playerY, mouseX - playerX);\n\n            // Create the sniper bullet (penetrating bullet)\n            Bullet sniperBullet = new Bullet(playerX + 16, playerY + 16, handler, mouseX, mouseY, ss);\n            sniperBullet.setSpeedX((float) (angleToPlayer));\n            sniperBullet.setSpeedY((float) (angleToPlayer));\n            sniperBullet.setPasser(true);\n\n            handler.addChar(sniperBullet);\n\n            lastFiredTime = currentTime;\n        }\n    }\n}\n",
      "Menu.java": "import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class Menu extends MouseAdapter {\n    private Game game;\n    private Handler handler;\n    private ZombieWave zombieWave;\n\n    public Menu(Game game, Handler handler) {\n        this.game = game;\n        this.handler = handler;\n    }\n\n    public void mousePressed(MouseEvent e) {\n        int mX = e.getX();\n        int mY = e.getY();\n        if (game.gameState == Game.State.Menu) {\n            if (mouseOver(mX, mY, 430, 150, 160, 63)) {\n                game.gameState = Game.State.Game;\n                zombieWave = new ZombieWave(handler);\n            }\n\n        }\n\n    }\n\n    public void mouseReleased(MouseEvent e) {\n\n    }\n\n    private boolean mouseOver(int mX, int mY, int x, int y, int width, int height) {\n        if (mX > x && mX < x + width) {\n            if (mY > y && mY < y + height) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    public void tick() {\n\n    }\n\n    public void render(Graphics g) {\n        Font f = new Font(\"arial\", 1, 45);\n        g.setFont(f);\n        g.setColor(Color.red);\n        g.drawString(\"START\", 434, 200);\n        g.drawRect(430, 150, 160, 63);\n        Font ft = new Font(\"arial\", 1, 12);\n        g.setFont(ft);\n        g.setColor(Color.DARK_GRAY);\n        g.drawString(\"Press \\\"P\\\" to PAUSE\", 449, 310);\n        g.drawString(\"Press \\\"R\\\" to Reload the ammo\", 428, 250);\n        g.drawString(\"Use W A S D for movement\", 437, 280);\n\n    }\n}\n",
      "PauseMenu.java": "import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class PauseMenu extends MouseAdapter {\n\n    private Game game;\n    private Handler handler;\n\n    public PauseMenu(Game game, Handler handler) {\n        this.game = game;\n        this.handler = handler;\n    }\n\n    public void mousePressed(MouseEvent e) {\n        int mX = e.getX();\n        int mY = e.getY();\n        if (game.gameState == Game.State.PauseMenu) {\n            if (mouseOver(mX, mY, 400, 150, 200, 63)) {\n                SaveManager.saveGame(game, \"saveGame.dat\");\n                System.out.println(\"Game has been saved\");\n            } else if (mouseOver(mX, mY, 450, 250, 100, 63)) {\n                LoadManager.loadGame(\"saveGame.dat\");\n                System.out.println(\"Game has been loaded\");\n            }\n        }\n\n    }\n\n    public void mouseReleased(MouseEvent e) {\n\n    }\n\n    private boolean mouseOver(int mX, int mY, int x, int y, int width, int height) {\n        if (mX > x && mX < x + width) {\n            if (mY > y && mY < y + height) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    public void tick() {\n\n    }\n\n    public void render(Graphics g) {\n        Font f = new Font(\"arial\", 1, 45);\n        g.setFont(f);\n        g.setColor(Color.red);\n        g.drawString(\"Save\", 445, 200);\n        g.drawRect(400, 150, 200, 63);\n        g.drawString(\"Load\", 445, 300);\n        g.drawRect(400, 250, 200, 63);\n        Font ft = new Font(\"arial\", 1, 15);\n        g.setFont(ft);\n        g.setColor(Color.DARK_GRAY);\n        g.drawString(\"Press \\\"P\\\" to CONTINUE\", 410, 350);\n\n    }\n}\n",
      "Weapon.java": "\npublic class Weapon {\n    Class<?> currentWeapon;\n    int ammo;\n    int currentAmmo;\n    int waveNumber;\n    double speedRate;\n    int leftCharger;\n\n    public Weapon(Class<?> currentWeapon, int ammo, double speedRate, int waveNumber) {\n\n        this.currentWeapon = currentWeapon;\n        this.ammo = ammo;\n        this.speedRate = speedRate;\n        this.waveNumber = waveNumber;\n        this.currentAmmo = ammo;\n\n    }\n\n    public void fire(int mouseX, int mouseY, int playerX, int playerY, Handler handler, SpriteSheet ss,\n            long currentTime) {\n\n    }\n\n    public int getLeftCharger() {\n        return leftCharger;\n    }\n\n    public void setLeftCharger(int leftCharger) {\n        this.leftCharger = leftCharger;\n    }\n\n    public int getAmmo() {\n        return ammo;\n    }\n\n    public int getWaveNumber() {\n        return waveNumber;\n    }\n\n    public double getSpeedRate() {\n        return speedRate;\n    }\n\n    public Class<?> getCurrentWeapon() {\n        return currentWeapon;\n    }\n\n    public Weapon getCurrWeapon() {\n        return this;\n    }\n\n    public void setCurrentWeapon(Class<?> currentWeapon) {\n        this.currentWeapon = currentWeapon;\n    }\n\n    public void setCurrentWeapon(Weapon weapon) {\n        this.ammo = weapon.ammo;\n        this.currentWeapon = weapon.currentWeapon;\n        this.speedRate = weapon.speedRate;\n        this.waveNumber = weapon.waveNumber;\n    }\n\n    public int getCurrentAmmo() {\n        return currentAmmo;\n    }\n\n    public void setCurrentAmmo(int consumed) {\n        currentAmmo = currentAmmo - consumed;\n    }\n\n    public void reload() {\n        if (currentAmmo != ammo)\n            currentAmmo = ammo;\n    }\n}\n",
      "Bullet.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Bullet extends GameObject {\n\n    private Handler handler;\n    private Game game;\n    private double angle;\n    private boolean isPasser = false;;\n\n    public void setPasser(boolean isPasser) {\n        this.isPasser = isPasser;\n    }\n\n    public boolean isPasser() {\n        return isPasser;\n    }\n\n    private double speed;\n    private double angleAdj;\n\n    public Bullet(int x, int y, Handler handler, int mX, int mY, SpriteSheet ss) {\n        super(x, y, ss);\n        this.handler = handler;\n\n        double disX = mX - x;\n        double disY = mY - y;\n        double distance = Math.sqrt(disX * disX + disY * disY);\n        double baseAngle = Math.PI + Math.atan2(disY, disX);\n        this.angle = baseAngle + angleAdj;\n        if (distance != 0) {\n\n            velX += (float) ((disX / distance) * 10.0);\n            velY += (float) ((disY / distance) * 10.0);\n\n        } else {\n            velX += 0;\n            velY += 0;\n        }\n    }\n\n    @Override\n    public void tick() {\n        x += velX;\n        y += velY;\n\n        for (int i = 0; i < handler.gameC.size(); i++) {\n            GameObject tempObject = handler.gameC.get(i);\n            if (tempObject.getClass() == Block.class) {\n                if (getBounds().intersects(tempObject.getBounds())) {\n\n                    handler.removeChar(this);\n                }\n            }\n\n        }\n\n    }\n\n    @Override\n    public void render(Graphics graphic) {\n        graphic.setColor(Color.black);\n        graphic.fillOval(x, y, 5, 5);\n\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 4, 4);\n    }\n\n}\n",
      "Shotgun.java": "public class Shotgun extends Weapon {\n    public static final int ammo = 5;\n    public static final double speedRate = 60;\n    public static final int waveNumber = 4;\n    private static final int bulletsPerShot = 9; // Shotgun fires 9 bullets per shot\n    private static final double angleAdj = Math.toRadians(45);\n    private static final double bulletSep = Math.toRadians(5); // 5-degree separation between each bullet\n\n    Handler handler;\n\n    private double lastFiredTime = 0;\n\n    public Shotgun() {\n        super(Shotgun.class, ammo, speedRate, waveNumber);\n\n    }\n\n    public void reload() {\n        if (handler.shotgunCharger > 0) {\n            if (currentAmmo != ammo) {\n                currentAmmo = ammo;\n\n            }\n\n        } else {\n            System.out.println(\"No Charger Left!!!\");\n        }\n\n    }\n\n    public void shoot(int mouseX, int mouseY, int playerX, int playerY, Handler handler, SpriteSheet ss,\n            long currentTime) {\n        if (currentTime - lastFiredTime >= 1000 / speedRate) {\n            double angleToPlayer = Math.atan2(mouseY - playerY, mouseX - playerX);\n\n            for (int i = 0; i < bulletsPerShot; i++) {\n                double angleOffset = -(angleAdj / 2) + (i * bulletSep); // Calculate angle offset for each bullet\n                Bullet bullet = new Bullet(playerX + 16, playerY + 16, handler, mouseX, mouseY, ss);\n                bullet.setSpeedX((float) (angleToPlayer + angleOffset));\n                bullet.setSpeedY((float) (angleToPlayer + angleOffset));\n\n                handler.addChar(bullet);\n            }\n\n            lastFiredTime = currentTime;\n        }\n    }\n\n}\n",
      "ReptileZombie.java": "public class ReptileZombie extends Enemies {\n\n    public ReptileZombie(int x, int y, Handler handler, SpriteSheet ss, Class<?> type, ZombieWave zombieWave) {\n        super(x, y, handler, ss, type, zombieWave);\n        setHealth();\n        setDamage();\n        setSpeed();\n    }\n\n    public void tick() {\n        super.tick();\n    }\n\n    public void setSpeed() {\n        this.speed = 3.0;\n    }\n\n    public void setDamage() {\n        this.damage = 0.25;\n    }\n\n    public double getDamage() {\n        return damage;\n    }\n\n    public void setHealth() {\n        this.health = 25;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public void setHealth(double damage) {\n        health -= damage;\n    }\n\n}\n",
      "NormalZombie.java": "public class NormalZombie extends Enemies {\n\n    public NormalZombie(int x, int y, Handler handler, SpriteSheet ss, Class<?> type, ZombieWave zombieWave) {\n        super(x, y, handler, ss, type, zombieWave);\n        setHealth();\n        setDamage();\n        setSpeed();\n    }\n\n    public void tick() {\n        super.tick();\n    }\n\n    public void setSpeed() {\n        this.speed = 2.5;\n    }\n\n    public void setDamage() {\n        this.damage = 0.25;\n    }\n\n    public double getDamage() {\n        return damage;\n    }\n\n    public void setHealth() {\n        this.health = 50;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public void setHealth(double damage) {\n        health -= damage;\n    }\n\n}\n",
      "ZombieWave.java": "\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Random;\n\npublic class ZombieWave implements Serializable {\n\n    private int waveNumber = 0;\n    Handler handler;\n\n    ArrayList<Enemies> zombies = new ArrayList<>();\n    private int waveInterval = 6000; // Time between waves (in milliseconds)\n    private int spawnInterval = 5000; // Time between enemy spawns in the wave (in milliseconds)\n    private long lastWaveTime = 0;\n    private long lastSpawnTime = 0;\n    private int enemiesToSpawn = 5;\n    private int enemiesSpawned = 0;\n    private long currentTime;\n    BufferedImageLoader loader = new BufferedImageLoader();\n\n    public ZombieWave(Handler handler) {\n\n        this.handler = handler;\n\n    }\n\n    public long getCurrentTime() {\n        return currentTime;\n    }\n\n    public void tick() {\n        currentTime = System.currentTimeMillis();\n\n        if (currentTime - lastWaveTime >= waveInterval) {\n            lastWaveTime = currentTime;\n            spawnWave();\n\n            handler.score += 5;\n        }\n\n        if (currentTime - lastSpawnTime >= spawnInterval && enemiesSpawned < enemiesToSpawn) {\n            lastSpawnTime = currentTime;\n\n            spawnEnemy();\n        }\n    }\n\n    private void spawnWave() {\n        enemiesSpawned = 0;\n        waveNumber++;\n        enemiesToSpawn = waveNumber * 5;\n        System.out.println(\"New wave spawned: Wave \" + waveNumber + \" with \" + enemiesToSpawn + \" enemies!\");\n        spawnInterval = Math.max(1500, 2000 - (waveNumber * 100)); // Decrease spawn interval as waves progress\n\n    }\n\n    private void spawnEnemy() {\n        Class<?> enemyType = selectRandomZombieType();\n        Class<?> enemyType1 = selectRandomZombieType1();\n        Class<?> enemyType2 = selectRandomZombieType2();\n        int spawnX, spawnY;\n        int coin = new Random().nextInt(2);\n        if (coin == 0) {\n            spawnX = 8;\n            spawnY = 8;\n        } else {\n            spawnX = 32;\n            spawnY = 32;\n        }\n        Enemies newEnemy = null;\n        if (waveNumber <= 2) {\n            newEnemy = new NormalZombie(spawnX * 32, spawnY * 32, handler,\n                    new SpriteSheet(loader.loadImage(\"image\\\\zombie movement.png\")), enemyType, this);\n        } else if (waveNumber > 2 && waveNumber <= 6) {\n            switch (enemyType1.getSimpleName()) {\n                case \"NormalZombie\":\n                    newEnemy = new NormalZombie(spawnX * 32, spawnY * 32, handler,\n                            new SpriteSheet(loader.loadImage(\"image\\\\zombie movement.png\")), enemyType, this);\n                    break;\n                case \"AcidicZombie\":\n                    newEnemy = new AcidicZombie(spawnX * 32, spawnY * 32, handler,\n                            new SpriteSheet(loader.loadImage(\"image\\\\zombie.png\")), enemyType, this);\n                    break;\n            }\n        } else if (waveNumber > 6 && waveNumber <= 9) {\n            switch (enemyType2.getSimpleName()) {\n                case \"NormalZombie\":\n                    newEnemy = new NormalZombie(spawnX * 32, spawnY * 32, handler,\n                            new SpriteSheet(loader.loadImage(\"image\\\\zombie movement.png\")), enemyType, this);\n                    break;\n                case \"AcidicZombie\":\n                    newEnemy = new AcidicZombie(spawnX * 32, spawnY * 32, handler,\n                            new SpriteSheet(loader.loadImage(\"image\\\\zombie.png\")), enemyType, this);\n                    break;\n                case \"ReptileZombie\":\n                    newEnemy = new ReptileZombie(spawnX * 32, spawnY * 32, handler,\n                            new SpriteSheet(loader.loadImage(\"image\\\\reptilezombie.png\")), enemyType, this);\n                    break;\n            }\n        } else if (waveNumber >= 10) {\n            switch (enemyType.getSimpleName()) {\n                case \"NormalZombie\":\n                    newEnemy = new NormalZombie(spawnX * 32, spawnY * 32, handler,\n                            new SpriteSheet(loader.loadImage(\"image\\\\zombie movement.png\")), enemyType, this);\n                    break;\n                case \"AcidicZombie\":\n                    newEnemy = new AcidicZombie(spawnX * 32, spawnY * 32, handler,\n                            new SpriteSheet(loader.loadImage(\"image\\\\zombie.png\")), enemyType, this);\n                    break;\n                case \"ReptileZombie\":\n                    newEnemy = new ReptileZombie(spawnX * 32, spawnY * 32, handler,\n                            new SpriteSheet(loader.loadImage(\"image\\\\reptilezombie.png\")), enemyType, this);\n                    break;\n                case \"TankZombie\":\n                    newEnemy = new TankZombie(spawnX * 32, spawnY * 32, handler,\n                            new SpriteSheet(loader.loadImage(\"image\\\\tankzombie.png\")), enemyType, this);\n                    break;\n            }\n        }\n\n        handler.addChar(newEnemy);\n        enemiesSpawned++;\n\n    }\n\n    private Class<?> selectRandomZombieType() {\n        Random random = new Random();\n        int randomChoice = random.nextInt(4);\n\n        switch (randomChoice) {\n            case 0:\n                return NormalZombie.class;\n            case 1:\n                return AcidicZombie.class;\n            case 2:\n                return ReptileZombie.class;\n            case 3:\n                return TankZombie.class;\n            default:\n                return NormalZombie.class;\n        }\n    }\n\n    private Class<?> selectRandomZombieType2() {\n        Random random = new Random();\n        int randomChoice = random.nextInt(3);\n\n        switch (randomChoice) {\n            case 0:\n                return NormalZombie.class;\n            case 1:\n                return AcidicZombie.class;\n            case 2:\n                return ReptileZombie.class;\n\n            default:\n                return NormalZombie.class;\n        }\n    }\n\n    private Class<?> selectRandomZombieType1() {\n        Random random = new Random();\n        int randomChoice = random.nextInt(2);\n\n        switch (randomChoice) {\n            case 0:\n                return NormalZombie.class;\n            case 1:\n                return AcidicZombie.class;\n\n            default:\n                return NormalZombie.class;\n        }\n    }\n\n    public int getWaveNumber() {\n        return waveNumber;\n    }\n\n    public int getWaveInterval() {\n        return waveInterval;\n    }\n\n    public int getSpawnInterval() {\n        return spawnInterval;\n    }\n\n    public long getLastWaveTime() {\n        return lastWaveTime;\n    }\n\n    public long getLastSpawnTime() {\n        return lastSpawnTime;\n    }\n\n    public int getEnemiesToSpawn() {\n        return enemiesToSpawn;\n    }\n\n    public int getEnemiesSpawned() {\n        return enemiesSpawned;\n    }\n}\n",
      "KeyInput.java": "import java.awt.event.*;\n\npublic class KeyInput extends KeyAdapter {\n\n    Handler handler; // yeni instance oluşturmayıp aynı handleri kullanıyoruz eğer yeni handler\n                     // oluşturursak yeni liste oluşturur.\n    private Game game;\n    private Weapon weapon;\n\n    public KeyInput(Handler handler, Game game, Weapon weapon) {\n        this.handler = handler;\n        this.game = game;\n        this.weapon = weapon;\n    }\n\n    public void keyPressed(KeyEvent e) {\n        int key = e.getKeyCode();\n\n        for (int i = 0; i < handler.gameC.size(); i++) {\n            GameObject gamechar = handler.gameC.get(i);\n            if (gamechar.getClass() == Player.class) {\n                if (key == KeyEvent.VK_W) {\n                    handler.setUp(true);\n                }\n                if (key == KeyEvent.VK_S) {\n                    handler.setDown(true);\n                }\n                if (key == KeyEvent.VK_A) {\n                    handler.setLeft(true);\n                }\n                if (key == KeyEvent.VK_D) {\n                    handler.setRight(true);\n                }\n            }\n        }\n        if (e.getKeyCode() == KeyEvent.VK_P) {\n            handler.togglePause();\n            if (handler.isPaused()) {\n                game.gameState = Game.State.PauseMenu;\n\n            } else if (!handler.isPaused()) {\n                game.gameState = Game.State.Game;\n            }\n\n        } else if (e.getKeyCode() == KeyEvent.VK_R) {\n\n            weapon.reload();\n\n        }\n        if (e.getKeyCode() == KeyEvent.VK_1) {\n            for (int i = 0; i < handler.weapons.size(); i++) {\n                if (handler.weapons.get(i).getCurrentWeapon().equals(Handgun.class)) {\n                    weapon.setCurrentWeapon(handler.weapons.get(i));\n                }\n\n            }\n        } else if (e.getKeyCode() == KeyEvent.VK_2) {\n            for (int i = 0; i < handler.weapons.size(); i++) {\n                if (handler.weapons.get(i).getCurrentWeapon().equals(Rifle.class)) {\n                    weapon.setCurrentWeapon(handler.weapons.get(i));\n                }\n\n            }\n\n        } else if (e.getKeyCode() == KeyEvent.VK_3) {\n            for (int i = 0; i < handler.weapons.size(); i++) {\n                if (handler.weapons.get(i).getCurrentWeapon().equals(Shotgun.class)) {\n                    weapon.setCurrentWeapon(handler.weapons.get(i));\n\n                }\n\n            }\n        } else if (e.getKeyCode() == KeyEvent.VK_4) {\n            for (int i = 0; i < handler.weapons.size(); i++) {\n                if (handler.weapons.get(i).getCurrentWeapon().equals(Sniper.class)) {\n                    weapon.setCurrentWeapon(handler.weapons.get(i));\n                }\n\n            }\n        } else if (e.getKeyCode() == KeyEvent.VK_5) {\n            for (int i = 0; i < handler.weapons.size(); i++) {\n                if (handler.weapons.get(i).getCurrentWeapon().equals(RocketLauncher.class)) {\n                    weapon.setCurrentWeapon(handler.weapons.get(i));\n                }\n\n            }\n        }\n    }\n\n    public void keyReleased(KeyEvent e) {\n        int key = e.getKeyCode();\n\n        for (int i = 0; i < handler.gameC.size(); i++) {\n            GameObject gamechar = handler.gameC.get(i);\n            if (gamechar.getClass() == Player.class) {\n                if (key == KeyEvent.VK_W) {\n                    handler.setUp(false);\n                }\n                if (key == KeyEvent.VK_S) {\n                    handler.setDown(false);\n                }\n                if (key == KeyEvent.VK_A) {\n                    handler.setLeft(false);\n                }\n                if (key == KeyEvent.VK_D) {\n                    handler.setRight(false);\n                }\n            }\n        }\n\n    }\n\n}\n",
      "Block.java": "\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Block extends GameObject {\n    private BufferedImage block1 = null;\n\n    public Block(int x, int y, SpriteSheet ss) {\n        super(x, y, ss);\n        block1 = ss.grabImage16(32, 5, 32, 32);// 13 20 32 32\n\n    }\n\n    @Override\n    public void tick() {\n\n    }\n\n    @Override\n    public void render(Graphics graphic) {\n        graphic.drawImage(block1, x, y, null);\n\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 32, 32);\n    }\n\n}\n",
      "Enemies.java": "import java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Enemies extends GameObject {\n\n    protected BufferedImage enemyImg = null;\n    private double rotationSpeed = 2.0;\n    private double direction;\n    ZombieWave zombieWave;\n    private Game game;\n\n    Handler handler;\n    private Class<?> type;\n    protected int health;\n    protected double damage;\n    protected int playerX, playerY;\n    protected double speed;\n\n    public double getDamage() {\n        return damage;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public void setHealth(double damage) {\n        health -= damage;\n    }\n\n    public Class<?> getType() {\n        return type;\n    }\n\n    public Enemies(int x, int y, Handler handler, SpriteSheet ss, Class<?> type, ZombieWave zombieWave) {\n        super(x, y, ss);\n        this.handler = handler;\n        this.zombieWave = zombieWave;\n        this.type = type;\n        enemyImg = ss.grabImage32(1, 1, 32, 32);\n\n    }\n\n    @Override\n    public void tick() {\n        x += velX;\n        y += velY;\n\n        for (int i = 0; i < handler.gameC.size(); i++) {\n            GameObject tempObject = handler.gameC.get(i);\n            if (tempObject.getClass() == Block.class) {\n                if (getBounds2().intersects(tempObject.getBounds())) {\n\n                    x += velX * -1;\n                    y += velY * -1;\n\n                }\n            }\n\n            if (tempObject.getClass() == Bullet.class) {\n                Bullet bullet = (Bullet) tempObject;\n\n                if (getBounds().intersects(tempObject.getBounds())) {\n                    health -= 25;\n\n                    if (health <= 0) {\n\n                        handler.removeChar(this);\n                        handler.zombieCounter++;\n\n                        if (this.getClass() == NormalZombie.class) {\n\n                            if (zombieWave.getWaveNumber() >= 1 && !handler.weapons.contains(handler.handgun)) {\n                                handler.weapons.add(handler.handgun);\n\n                            }\n\n                            if (zombieWave.getWaveNumber() >= 2 && !handler.weapons.contains(handler.rifle)) {\n                                handler.weapons.add(handler.rifle);\n                                System.out.println(\"Rifle added to inventory!\");\n\n                            }\n                            if (handler.zombieCounter % 5 == 0)\n                                handler.rifleCharger += 2;\n                            handler.score += 10;\n                        } else if (this.getClass() == AcidicZombie.class\n                                || this.getClass() == ReptileZombie.class) {\n\n                            if (zombieWave.getWaveNumber() >= 4 && !handler.weapons.contains(handler.shotgun)) {\n                                handler.weapons.add(handler.shotgun);\n                                System.out.println(\"Shotgun added to inventory!\");\n\n                            }\n                            if (handler.zombieCounter % 5 == 0)\n                                handler.rifleCharger += 2;\n                            if (zombieWave.getWaveNumber() >= 6 && !handler.weapons.contains(handler.sniper)) {\n                                handler.weapons.add(handler.sniper);\n                                System.out.println(\"Sniper added to inventory!\");\n\n                            }\n                            if (handler.zombieCounter % 9 == 0)\n                                handler.sniperCharger += 2;\n                            handler.score += 5;\n                        } else if (this.getClass() == TankZombie.class) {\n\n                            if (zombieWave.getWaveNumber() >= 11\n                                    && !handler.weapons.contains(handler.rocketLauncher)) {\n                                handler.weapons.add(handler.rocketLauncher);\n                                System.out.println(\"RocketLauncher added to inventory!\");\n\n                            }\n                            if (handler.zombieCounter % 11 == 0)\n                                handler.rocketCharger += 2;\n\n                            handler.score += 15;\n                        }\n\n                    }\n                    if (!bullet.isPasser()) {\n                        handler.removeChar(bullet);\n\n                    }\n\n                }\n\n            }\n            if (tempObject instanceof Enemies) {\n                if (getBounds2().intersects(tempObject.getBounds())) {\n                    velX += (velX * 2) * -1;\n                    velY += (velY * 2) * -1;\n\n                }\n            }\n            if (tempObject.getClass() == Player.class) {\n                if (getBounds2().intersects(tempObject.getBounds())) {\n                    if (this.getClass() == AcidicZombie.class) {\n                        AcidicZombie ac = (AcidicZombie) this;\n                        damage = ac.getDamage();\n                    }\n                } else if (getBounds().intersects(tempObject.getBounds())) {\n                    switch (this.getType().getSimpleName()) {\n                        case \"NormalZombie\":\n                            NormalZombie normZomb = (NormalZombie) this;\n                            damage = normZomb.getDamage();\n                            break;\n                        case \"AcidicZombie\":\n                            AcidicZombie acidZomb = (AcidicZombie) this;\n                            damage = acidZomb.getDamage();\n                            break;\n                        case \"ReptileZombie\":\n                            ReptileZombie repZomb = (ReptileZombie) this;\n                            damage = repZomb.getDamage();\n                            break;\n                        case \"TankZombie\":\n                            TankZombie tankZomb = (TankZombie) this;\n                            damage = tankZomb.getDamage();\n                            break;\n                        default:\n                            damage = 0.25;\n                            break;\n                    }\n                }\n            }\n\n        }\n        for (\n\n                int i = 0; i < handler.gameC.size(); i++) {\n            if (handler.gameC.get(i).getClass() == Player.class) {\n                playerX = handler.gameC.get(i).getX();\n                playerY = handler.gameC.get(i).getY();\n\n            }\n        }\n        for (int i = 0; i < handler.gameC.size(); i++) {\n            GameObject temp = handler.gameC.get(i);\n            if (temp.getClass() == Player.class) {\n                Player player = (Player) temp;\n                if (this.getClass() == ReptileZombie.class) {\n                    if (getBounds().intersects(player.getBounds2())) {\n                        this.x = playerX;\n                        this.y = playerY;\n                    }\n                }\n\n            }\n        }\n\n        int dx = playerX - x;\n        int dy = playerY - y;\n\n        double angle = Math.atan2(dy, dx);\n\n        velX = (int) (speed * Math.cos(angle));\n        velY = (int) (speed * Math.sin(angle));\n\n        x += velX;\n        y += velY;\n\n        double targetDirection = Math.atan2(playerY - (y + 24), playerX - (x + 24));\n\n        double angleDifference = targetDirection - direction;\n\n        if (angleDifference > Math.PI)\n            angleDifference -= 2 * Math.PI;\n        if (angleDifference < -Math.PI)\n            angleDifference += 2 * Math.PI;\n\n        if (Math.abs(angleDifference) > rotationSpeed) {\n            direction += rotationSpeed * Math.signum(angleDifference);\n        } else {\n            direction = targetDirection;\n        }\n\n    }\n\n    @Override\n    public void render(Graphics graphic) {\n\n        Graphics2D g2D = (Graphics2D) graphic;\n        g2D.rotate(direction, x + 24, y + 24);\n        g2D.drawImage(enemyImg, x, y, null);\n        g2D.rotate(-direction, x + 24, y + 24);\n\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 32, 32);\n    }\n\n    public Rectangle getBounds2() {\n        return new Rectangle(x - 16, y - 16, 64, 64);\n    }\n\n}\n",
      "Rocket.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Rocket extends GameObject {\n    private double angle;\n    private boolean isExploded = false;\n    private int explosionRadius = 50;\n    Handler handler;\n\n    public Rocket(int x, int y, Handler handler, int targetX, int targetY, SpriteSheet ss) {\n        super(x, y, ss);\n        this.handler = handler;\n        double disX = targetX - x;\n        double disY = targetY - y;\n        double distance = Math.sqrt(disX * disX + disY * disY);\n        this.angle = Math.atan2(disY, disX);\n\n        // Velocity of the rocket\n        velX = (float) ((disX / distance) * 5.0); // Adjust velocity as needed\n        velY = (float) ((disY / distance) * 5.0);\n\n    }\n\n    @Override\n    public void tick() {\n        if (!isExploded) {\n            x += velX;\n            y += velY;\n\n            // Check for collision with blocks or other objects\n            for (int i = 0; i < handler.gameC.size(); i++) {\n                GameObject tempObject = handler.gameC.get(i);\n                if (tempObject.getClass() == Block.class || tempObject.getClass() == Enemies.class) {\n                    // If the rocket hits a block or an enemy, trigger the explosion\n                    if (getBounds().intersects(tempObject.getBounds())) {\n                        triggerExplosion();\n                        handler.removeChar(this); // Remove rocket after explosion\n                        break;\n                    }\n                }\n            }\n        }\n\n    }\n\n    private void triggerExplosion() {\n        // Explosion effect: damage enemies in the explosion radius\n        for (int i = 0; i < handler.gameC.size(); i++) {\n            GameObject tempObject = handler.gameC.get(i);\n            if (tempObject instanceof Enemies) {\n                Enemies enemy = (Enemies) tempObject;\n\n                // Calculate the distance between the explosion and the enemy\n                double distance = Math.sqrt(Math.pow(enemy.getX() - x, 2) + Math.pow(enemy.getY() - y, 2));\n\n                // If the enemy is within the explosion radius, apply damage\n                if (distance <= explosionRadius) {\n                    enemy.setHealth(100); // Adjust damage as needed\n                }\n            }\n        }\n\n        // Mark the rocket as exploded\n        isExploded = true;\n    }\n\n    @Override\n    public void render(Graphics graphic) {\n        graphic.setColor(Color.RED);\n        graphic.fillOval(x, y, 10, 10);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 10, 10);\n    }\n\n}\n",
      "Handgun.java": "public class Handgun extends Weapon {\n    public static final int ammo = 12;\n    public static final double speedRate = 120;\n    public static final int waveNumber = 1;\n    private double lastFiredTime = 0;\n    Handler handler;\n\n    public Handgun() {\n        super(Handgun.class, ammo, speedRate, waveNumber);\n\n    }\n\n    public void fire(int mouseX, int mouseY, int playerX, int playerY, Handler handler, SpriteSheet ss,\n            long currentTime) {\n\n        if (currentTime - lastFiredTime >= 1000 / speedRate) {\n\n            Bullet bullet = new Bullet(playerX + 16, playerY + 16, handler, mouseX, mouseY, ss);\n\n            handler.addChar(bullet);\n\n            lastFiredTime = currentTime;\n        }\n\n    }\n}\n",
      "AcidicZombie.java": "public class AcidicZombie extends Enemies {\n\n    public AcidicZombie(int x, int y, Handler handler, SpriteSheet ss, Class<?> type, ZombieWave zombieWave) {\n        super(x, y, handler, ss, type, zombieWave);\n        setHealth();\n        setDamage();\n        setSpeed();\n    }\n\n    public void tick() {\n        super.tick();\n    }\n\n    public void setSpeed() {\n        this.speed = 2.5;\n    }\n\n    public void setDamage() {\n        this.damage = 0.5;\n    }\n\n    public double getDamage() {\n        return damage;\n    }\n\n    public void setHealth() {\n        this.health = 25;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public void setHealth(double damage) {\n        health -= damage;\n    }\n\n}\n",
      "Handler.java": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.awt.*;\nimport java.io.Serializable;\n\npublic class Handler implements Serializable {\n    private boolean up = false, down = false, left = false, right = false, isPaused = false;\n    int score;\n\n    LinkedList<GameObject> gameC = new LinkedList<GameObject>();\n    ArrayList<Weapon> weapons = new ArrayList<>();\n    Weapon handgun = new Handgun();\n    Weapon rifle = new Rifle();\n    Weapon shotgun = new Shotgun();\n    Weapon sniper = new Sniper();\n    Weapon rocketLauncher = new RocketLauncher();\n    int zombieCounter;\n    int rifleCharger = 1;\n    int shotgunCharger = 1;\n    int sniperCharger = 1;\n    int rocketCharger = 1;\n\n    public void tick() {\n        for (int i = 0; i < gameC.size(); i++) {\n            GameObject tempChar = gameC.get(i);\n            tempChar.tick();\n        }\n\n    }\n\n    public boolean isPaused() {\n        return isPaused;\n    }\n\n    public void togglePause() {\n        isPaused = !isPaused;\n    }\n\n    public boolean isUp() {\n        return up;\n    }\n\n    public void setUp(boolean up) {\n        this.up = up;\n    }\n\n    public boolean isDown() {\n        return down;\n    }\n\n    public void setDown(boolean down) {\n        this.down = down;\n    }\n\n    public boolean isLeft() {\n        return left;\n    }\n\n    public void setLeft(boolean left) {\n        this.left = left;\n    }\n\n    public boolean isRight() {\n        return right;\n    }\n\n    public void setRight(boolean right) {\n        this.right = right;\n    }\n\n    public void render(Graphics graphic) {\n        for (int i = 0; i < gameC.size(); i++) {\n            GameObject tempChar = gameC.get(i);\n            tempChar.render(graphic);\n        }\n    }\n\n    public void addChar(GameObject gameChar) {\n        gameC.add(gameChar);\n    }\n\n    public void removeChar(GameObject gameChar) {\n        gameC.remove(gameChar);\n    }\n\n    public boolean contains(Weapon weapon) {\n\n        for (int i = 0; i < weapons.size(); i++) {\n            Weapon temp = weapons.get(i);\n            if (temp.getClass() == weapon.getClass()) {\n                return true;\n            }\n\n        }\n        return false;\n    }\n\n}\n",
      "Rifle.java": "\nimport java.util.Random;\n\npublic class Rifle extends Weapon {\n    public static final int ammo = 30;\n    public static final double speedRate = 600;\n    public static final int waveNumber = 2;\n    private static final double angleAdj = Math.toRadians(30);\n    private double lastFiredTime = 0;\n    Handler handler;\n\n    public Rifle() {\n        super(Rifle.class, ammo, speedRate, waveNumber);\n\n    }\n\n    public void reload() {\n        if (handler.rifleCharger > 0) {\n            if (currentAmmo != ammo) {\n                currentAmmo = ammo;\n\n            }\n\n        } else {\n            System.out.println(\"No Charger Left!!!\");\n        }\n\n    }\n\n    public void fire(int mouseX, int mouseY, int playerX, int playerY, Handler handler, SpriteSheet ss,\n            long currentTime) {\n        if (currentTime - lastFiredTime >= 1000 / speedRate) {\n\n            Bullet bullet1 = new Bullet(playerX + 16, playerY + 16, handler, mouseX, mouseY, ss);\n            Bullet bullet2 = new Bullet(playerX + 16, playerY + 16, handler, mouseX, mouseY, ss);\n\n            bullet1.setSpeedX((float) (+getRandomDeviation()));\n            bullet1.setSpeedY((float) (+getRandomDeviation()));\n            bullet2.setSpeedX((float) (-getRandomDeviation()));\n            bullet2.setSpeedY((float) (-getRandomDeviation()));\n\n            handler.addChar(bullet1);\n            handler.addChar(bullet2);\n\n            lastFiredTime = currentTime;\n        }\n    }\n\n    private double getRandomDeviation() {\n        Random rand = new Random();\n        return rand.nextDouble() * angleAdj * 2 - angleAdj; // Random value between -angleAdj and +angleAdj\n    }\n\n}\n",
      "TankZombie.java": "public class TankZombie extends Enemies {\n\n    public TankZombie(int x, int y, Handler handler, SpriteSheet ss, Class<?> type, ZombieWave zombieWave) {\n        super(x, y, handler, ss, type, zombieWave);\n        setHealth();\n        setDamage();\n        setSpeed();\n    }\n\n    public void tick() {\n        super.tick();\n    }\n\n    public void setSpeed() {\n        this.speed = 2.0;\n    }\n\n    public void setDamage() {\n        this.damage = 0.5;\n    }\n\n    public double getDamage() {\n        return damage;\n    }\n\n    public void setHealth() {\n        this.health = 85;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public void setHealth(double damage) {\n        health -= damage;\n    }\n\n}\n",
      "SaveManager.java": "import java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\n\npublic class SaveManager {\n    public static void saveGame(Game game, String filename) {\n        ObjectOutputStream outSt;\n        try {\n            outSt = new ObjectOutputStream(new FileOutputStream(filename));\n            outSt.writeObject(game);\n            outSt.close();\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n        }\n\n    }\n}\n",
      "BufferedImageLoader.java": "import java.awt.image.*;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class BufferedImageLoader {\n\n    private BufferedImage image;\n\n    public BufferedImage loadImage(String path) {\n        try {\n            image = ImageIO.read(getClass().getResource(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n\n        }\n        return image;\n    }\n}\n",
      "GameOver.java": "import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\n\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class GameOver extends MouseAdapter {\n    private Game game;\n    private Handler handler;\n\n    public GameOver(Game game, Handler handler) {\n        this.game = game;\n        this.handler = handler;\n    }\n\n    public void mousePressed(MouseEvent e) {\n        int mX = e.getX();\n        int mY = e.getY();\n        if (mouseOver(mX, mY, 375, 200, 255, 63)) {\n            if (game.gameState == Game.State.GameOver)\n                System.exit(0);\n        }\n\n    }\n\n    public void mouseReleased(MouseEvent e) {\n\n    }\n\n    private boolean mouseOver(int mX, int mY, int x, int y, int width, int height) {\n        if (mX > x && mX < x + width) {\n            if (mY > y && mY < y + height) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    public void tick() {\n\n    }\n\n    public void render(Graphics g) {\n        Font f = new Font(\"arial\", 1, 40);\n        g.setFont(f);\n        g.setColor(Color.red);\n        g.drawString(\"GAME OVER\", 380, 250);\n        g.drawRect(375, 200, 255, 63);\n        Font ft = new Font(\"arial\", 1, 12);\n        g.setFont(ft);\n        g.setColor(Color.DARK_GRAY);\n        g.drawString(\"Enter to EXIT\", 465, 290);\n        g.drawString(\"SCORE : \" + handler.score, 470, 180);\n    }\n\n}\n",
      "Game.java": "import java.awt.Canvas;\nimport java.awt.Color;\nimport java.awt.*;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Graphics2D.*;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferStrategy;\nimport java.awt.image.BufferedImage;\n\npublic class Game extends Canvas implements Runnable {\n\n    private boolean isRunning = false;\n    private Thread thread;\n    private Handler handler;\n    private ZombieWave zombieWave;\n    private Weapon weapon;\n    AffineTransform transform;\n\n    private BufferedImage spriteSheet = null;\n    private BufferedImage spriteSheet2 = null;\n    private BufferedImage spriteSheet3 = null;\n    private BufferedImage spriteSheet4 = null;\n    private BufferedImage img = null;\n    private BufferedImage backGround = null;\n    private Camera camera;\n    private SpriteSheet ss;\n    private SpriteSheet ss2;\n    private SpriteSheet ss3;\n    private SpriteSheet ss4;\n    private Player player;\n    private Menu menu;\n    private GameOver gameOver;\n    private PauseMenu pauseMenu;\n\n    public enum State {\n        Menu,\n        Game,\n        GameOver,\n        PauseMenu\n    };\n\n    public State gameState = State.Menu;\n\n    public SpriteSheet getSs3() {\n        return ss3;\n    }\n\n    public Game() {\n        new Window(1000, 563, \"Top Down Shooter\", this);\n        start();\n        synchronized (this) {\n            handler = new Handler();\n            zombieWave = new ZombieWave(handler);\n            camera = new Camera(0, 0);\n            menu = new Menu(this, handler);\n            gameOver = new GameOver(this, handler);\n            pauseMenu = new PauseMenu(this, handler);\n            weapon = new Handgun();\n        }\n\n        this.addKeyListener(new KeyInput(handler, this, weapon));\n\n        BufferedImageLoader loader = new BufferedImageLoader();\n        img = loader.loadImage(\"image\\\\pixil-frame-0.png\");\n\n        spriteSheet = loader.loadImage(\"image\\\\apocalypse.png\");\n        ss = new SpriteSheet(spriteSheet);\n\n        spriteSheet2 = loader.loadImage(\"image\\\\tileset-grassland-grass.png\");\n        ss2 = new SpriteSheet(spriteSheet2);\n\n        spriteSheet3 = loader.loadImage(\"image\\\\zombie movement.png\");\n        ss3 = new SpriteSheet(spriteSheet3);\n\n        spriteSheet4 = loader.loadImage(\"image\\\\Ekran Görüntüsü (4).png\");\n        ss4 = new SpriteSheet(spriteSheet4);\n\n        backGround = ss2.grabImage160(1, 1, 160, 160);\n        this.addMouseListener(menu);\n        this.addMouseListener(gameOver);\n        this.addMouseListener(pauseMenu);\n        this.addMouseListener(new MouseInput(handler, camera, weapon, zombieWave, ss));\n        this.addMouseMotionListener(new MouseInput(handler, camera, weapon, zombieWave, ss));\n        loading(img);\n        if (gameState == State.Game) {\n\n            zombieWave = new ZombieWave(handler);\n\n        }\n\n    }\n\n    private void start() {\n        isRunning = true;\n        thread = new Thread(this);// by mean this, it is this classes run method\n        thread.start();\n    }\n\n    private void stop() {\n        isRunning = false;\n        try {\n            thread.join();\n        } catch (InterruptedException e) {\n\n            e.printStackTrace();\n        }\n\n    }\n\n    public void saveGame() {\n        SaveManager.saveGame(this, \"saveGame.dat\");\n    }\n\n    public void loadGame() {\n        Game loadedGame = LoadManager.loadGame(\"saveGame.dat\");\n        if (loadedGame != null) {\n            this.player = loadedGame.player;\n            this.handler = loadedGame.handler;\n            this.gameState = loadedGame.gameState;\n            this.weapon = loadedGame.weapon;\n            this.zombieWave = loadedGame.zombieWave;\n\n        }\n    }\n\n    public synchronized void tick() {\n        if (!handler.isPaused()) {\n            for (int i = 0; i < handler.gameC.size(); i++) {\n                if (handler.gameC.get(i).getClass() == Player.class) {\n                    camera.tick(handler.gameC.get(i));\n                }\n            }\n            handler.tick();\n            if (gameState == State.Game) {\n                zombieWave.tick();\n\n            } else if (gameState == State.Menu) {\n                if (menu != null) {\n                    menu.tick();\n                } else {\n                    System.out.println(\"Menu is null in tick()\");\n                }\n\n            } else if (gameState == State.GameOver) {\n                gameOver.tick();\n            }\n\n        } else {\n            pauseMenu.tick();\n        }\n\n    }\n\n    public void render() {\n        BufferStrategy bufferS = this.getBufferStrategy();// when it created it becames null\n        if (bufferS == null) {\n            this.createBufferStrategy(3);// its creates bufferS with 3 arguments, number of frames that loaded if we\n                                         // make it 30 it will slows our game\n            return;\n        }\n        Graphics graphic = bufferS.getDrawGraphics();\n        Graphics2D g2D = (Graphics2D) graphic;\n        if (!handler.isPaused()) {\n\n            //////////////////////////////////////////////////\n\n            g2D.translate(-camera.getX(), -camera.getY());\n            for (int xx = 0; xx < 30 * 72; xx += 160) {\n                for (int yy = 0; yy < 30 * 72; yy += 160) {\n                    graphic.drawImage(backGround, xx, yy, null);\n                }\n            }\n\n            handler.render(graphic);\n            g2D.translate(camera.getX(), camera.getY());\n\n            if (gameState == State.Game) {\n                Font f = new Font(\"arial\", 1, 9);\n                graphic.setFont(f);\n                graphic.drawString(\"AMMO : \" + weapon.getCurrentAmmo(), 10, 30);\n                graphic.drawString(\"CURRENT WEAPON : \" + weapon.getCurrentWeapon().getSimpleName(), 10, 50);\n                graphic.drawString(\"SCORE : \" + handler.score, 905, 30);\n                graphic.drawString(\"HEALTH : \" + player.getHealth(), 905, 50);\n            } else if (gameState == State.Menu) {\n                menu.render(graphic);\n            } else if (gameState == State.GameOver) {\n                gameOver.render(graphic);\n            }\n\n            ////////////////////////////////////////////////\n\n        } else {\n            pauseMenu.render(graphic);\n        }\n        graphic.dispose();\n        bufferS.show();\n\n    }\n\n    private void loading(BufferedImage image) {\n        int w = image.getWidth();\n        int h = image.getHeight();\n\n        for (int xx = 0; xx < w; xx++) {\n            for (int yy = 0; yy < h; yy++) {\n                int pixel = image.getRGB(xx, yy);\n                int red = (pixel >> 16) & 0xff;\n                int green = (pixel >> 8) & 0xff;\n                int blue = (pixel) & 0xff;\n\n                if (red == 255 && blue == 0 && green == 0) {\n                    handler.addChar(new Block(xx * 32, yy * 32, ss));\n                }\n\n                if (blue == 255 && red == 0 && green == 0) {\n                    player = new Player(xx * 32, yy * 32, handler, ss4, this);\n                    handler.addChar(player);\n                }\n\n            }\n        }\n    }\n\n    @Override\n    public void run() {\n        this.requestFocus();\n        long lastTime = System.nanoTime();\n        double amountOfTicks = 60.0;\n        double ns = 1000000000 / amountOfTicks;\n        double delta = 0;\n        long timer = System.currentTimeMillis();\n        int frames = 0;\n        while (isRunning) {\n            long now = System.nanoTime();\n            delta += (now - lastTime) / ns;\n            lastTime = now;\n            while (delta >= 1) {\n                tick();\n\n                delta--;\n            }\n            render();\n            frames++;\n            if (System.currentTimeMillis() - timer > 1000) {\n                timer += 1000;\n                frames = 0;\n\n            }\n        }\n        stop();\n\n    }\n\n    public static void main(String[] args) {\n        new Game();\n    }\n\n}\n",
      "MouseInput.java": "import java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class MouseInput extends MouseAdapter {\n    private Handler handler;\n    private Camera camera;\n    private Weapon weapon;\n    private SpriteSheet ss;\n    public static float x, y;\n    private ZombieWave zombieWave;\n\n    public MouseInput(Handler handler, Camera camera, Weapon weapon, ZombieWave zombieWave, SpriteSheet ss) {\n        this.handler = handler;\n        this.camera = camera;\n        this.weapon = weapon;\n        this.ss = ss;\n        this.zombieWave = zombieWave;\n    }\n\n    public void mouseMoved(MouseEvent e) {\n        // Update mouse position when moved\n        x = e.getX() + camera.getX();\n        y = e.getY() + camera.getY();\n    }\n\n    public void mousePressed(MouseEvent e) {\n        int mX = (int) (e.getX() + camera.getX());\n        int mY = (int) (e.getY() + camera.getY());\n\n        for (int i = 0; i < handler.gameC.size(); i++) {\n            GameObject tempObject = handler.gameC.get(i);\n            if (tempObject.getClass() == Player.class) {\n\n                // handler.addChar(new Bullet(tempObject.getX() + 16, tempObject.getY() + 24,\n                // handler, mX, mY, ss));\n                weapon.getCurrWeapon().fire(mX, mY, tempObject.getX(), tempObject.getY(), handler, ss,\n                        zombieWave.getCurrentTime());\n                weapon.setCurrentAmmo(1);\n\n            }\n            if (weapon.getCurrentAmmo() <= 0)\n                break;\n        }\n    }\n\n}\n",
      "Camera.java": "public class Camera {\n    private float x, y;\n\n    public Camera(float x, float y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void tick(GameObject gameObject) {\n        x += ((gameObject.getX() - x) - 1000 / 2) * 0.05f;\n        y += ((gameObject.getY() - y) - 563 / 2) * 0.05f;\n\n        if (x <= 0)\n            x = 0;\n        if (x >= 1032)\n            x = 1032;\n        if (y <= 0)\n            y = 0;\n        if (y >= 611)\n            y = 611;\n    }\n\n    public float getX() {\n        return x;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public float getY() {\n        return y;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n}\n",
      "SpriteSheet.java": "import java.awt.image.*;\n\npublic class SpriteSheet {\n    private BufferedImage img;\n\n    public SpriteSheet(BufferedImage img) {\n        this.img = img;\n\n    }\n\n    public BufferedImage grabImage16(int col, int row, int width, int height) {\n        return img.getSubimage((col * 16) - 16, (row * 16) - 16, width, height);\n\n    }\n\n    public BufferedImage grabImage32(int col, int row, int width, int height) {\n        return img.getSubimage((col * 32) - 32, (row * 32) - 32, width, height);\n\n    }\n\n    public BufferedImage grabImage48(int col, int row, int width, int height) {\n        return img.getSubimage((col * 48) - 48, (row * 48) - 48, width, height);\n\n    }\n\n    public BufferedImage grabImage160(int col, int row, int width, int height) {\n        return img.getSubimage((col * 160) - 160, (row * 160) - 160, width, height);\n    }\n\n}\n",
      "RocketLauncher.java": "public class RocketLauncher extends Weapon {\n    public static final int ammo = 1;\n    public static final double speedRate = 10;\n    public static final int waveNumber = 11;\n    Handler handler;\n\n    public RocketLauncher() {\n        super(RocketLauncher.class, ammo, speedRate, waveNumber);\n\n    }\n\n    public void reload() {\n        if (handler.rocketCharger > 0) {\n            if (currentAmmo != ammo) {\n                currentAmmo = ammo;\n\n            }\n\n        } else {\n            System.out.println(\"No Charger Left!!!\");\n        }\n\n    }\n\n    public void fire(int x, int y, int targetX, int targetY, SpriteSheet ss) {\n\n        Rocket rocket = new Rocket(x, y, handler, targetX, targetY, ss);\n        handler.addChar(rocket);\n\n    }\n\n}\n",
      "LoadManager.java": "import java.io.FileInputStream;\nimport java.io.ObjectInputStream;\n\npublic class LoadManager {\n    public static Game loadGame(String fileName) {\n        Game game = null;\n        ObjectInputStream inSt;\n        try {\n            inSt = new ObjectInputStream(new FileInputStream(fileName));\n            game = (Game) inSt.readObject();\n            inSt.close();\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n        }\n        return game;\n    }\n}\n",
      "Window.java": "import javax.swing.*;\nimport java.awt.*;\n\npublic class Window {\n    public Window(int width, int height, String title, Game game) {\n        JFrame window = new JFrame(title);\n\n        window.setPreferredSize(new Dimension(width, height));\n        window.setMaximumSize(new Dimension(width, height));\n        window.setMinimumSize(new Dimension(width, height));\n\n        window.add(game);\n        window.setResizable(false);\n        window.setLocationRelativeTo(null);\n\n        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        window.setVisible(true);\n    }\n\n}\n",
      "Player.java": "import java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Player extends GameObject {\n    Handler handler;\n    private Game game;\n    private BufferedImage playerImg = null;\n    private int health;\n    private double direction;\n    private double rotationSpeed = 0.2;\n    private double targetDirection;\n\n    public Player(int x, int y, Handler handler, SpriteSheet ss, Game game) {\n        super(x, y, ss);\n        this.handler = handler;\n        setHealth();\n        playerImg = ss.grabImage48(1, 1, 48, 48);\n        this.game = game;\n\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public void setHealth() {\n        this.health = 200;\n    }\n\n    public void setHealth(double damage) {\n        health -= damage;\n    }\n\n    @Override\n    public void tick() {\n        x += velX;\n        y += velY;\n\n        collision();\n\n        if (handler.isUp()) {\n            velY = -5;\n        } else if (!handler.isDown()) {\n            velY = 0;\n        }\n        if (handler.isDown()) {\n            velY = 5;\n        } else if (!handler.isUp()) {\n            velY = 0;\n        }\n        if (handler.isRight()) {\n            velX = 5;\n        } else if (!handler.isLeft()) {\n            velX = 0;\n        }\n        if (handler.isLeft()) {\n            velX = -5;\n        } else if (!handler.isRight()) {\n            velX = 0;\n        }\n\n        double mouseX = MouseInput.x;\n        double mouseY = MouseInput.y;\n\n        targetDirection = Math.atan2(mouseY - (y + 24), mouseX - (x + 24));\n\n        double angleDifference = targetDirection - direction;\n\n        if (angleDifference > Math.PI)\n            angleDifference -= 2 * Math.PI;\n        if (angleDifference < -Math.PI)\n            angleDifference += 2 * Math.PI;\n\n        if (Math.abs(angleDifference) > rotationSpeed) {\n            direction += rotationSpeed * Math.signum(angleDifference);\n        } else {\n            direction = targetDirection;\n        }\n\n    }\n\n    private void collision() {\n        for (int i = 0; i < handler.gameC.size(); i++) {\n            GameObject tempObject = handler.gameC.get(i);\n            if (tempObject.getClass() == Block.class) {\n                if (getBounds().intersects(tempObject.getBounds())) {\n                    x += velX * -1;\n                    y += velY * -1;\n                }\n            } else if (tempObject instanceof Enemies) {\n                if (getBounds().intersects(tempObject.getBounds())) {\n                    velX += (velX * 2) * -1;\n                    velY += (velY * 2) * -1;\n                    Enemies enemy = (Enemies) tempObject;\n                    double damage = enemy.getDamage();\n\n                    System.out.println(\n                            \"Player collided with \" + enemy.getClass().getSimpleName() + \" - Damage: \" + damage);\n                    health -= damage;\n\n                    if (health <= 0) {\n                        handler.removeChar(this);\n                        game.gameState = Game.State.GameOver;\n                    }\n\n                }\n            }\n        }\n    }\n\n    @Override\n    public void render(Graphics graphic) {\n        Graphics2D g2D = (Graphics2D) graphic;\n        g2D.rotate(direction, x + 24, y + 24);\n        g2D.drawImage(playerImg, x, y, null);\n        g2D.rotate(-direction, x + 24, y + 24);\n\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 48, 48);\n    }\n\n    public Rectangle getBounds2() {\n        return new Rectangle(x - 16, y - 16, 96, 96);\n    }\n\n}\n",
      "GameObject.java": "import java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.geom.AffineTransform;\nimport java.io.Serializable;\n\npublic abstract class GameObject implements Serializable {\n    protected int x;\n    protected int y;\n    protected float velX = 0;\n    protected float velY = 0;\n    protected SpriteSheet ss;\n    protected AffineTransform transform;\n\n    public GameObject(int x, int y, SpriteSheet ss) {\n        this.x = x;\n        this.y = y;\n        this.ss = ss;\n\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n    public float getSpeedX() {\n        return velX;\n    }\n\n    public void setSpeedX(float speedX) {\n        this.velX += speedX;\n    }\n\n    public float getSpeedY() {\n        return velY;\n    }\n\n    public void setSpeedY(float speedY) {\n        this.velY += speedY;\n    }\n\n    public abstract void tick();\n\n    public abstract void render(Graphics graphic);\n\n    public abstract Rectangle getBounds();\n\n}\n"
    },
    {
      "id": "7374887",
      "WaveManager.java": "package Source;\n\nimport java.awt.geom.Point2D;\nimport java.util.HashMap;\nimport java.util.Random;\nimport java.util.Set;\n\nimport Source.Player;\nimport Source.Zombies.ParentZombie;\n\npublic class WaveManager {\n    int wave;\n    Player player;\n    HashMap<Point2D, ParentZombie> zombies;\n\n    public WaveManager(Player player) {\n        this.player = player;\n        zombies = new HashMap<>();\n        wave = 0;\n    }\n\n    public void spawnWave() {\n        Random random = new Random();\n        int zombieCount = (wave + 1) * random.nextInt(10, 15 * (wave + 1));\n        String[] zombieTypes = { \"NormalZombie\", \"AcidSpitter\", \"TankZombie\", \"CrawlerZombie\" };\n        for (int i = 0; i < zombieCount; i++) {\n            int zombieTypeIndex = random.nextInt(zombieTypes.length);\n            if (zombieTypeIndex == 0) {\n\n            }\n        }\n    }\n\n    public Point2D findValidSpawnPoint() {\n        Random random = new Random();\n        int x = random.nextInt((int) player.center.x - 500, (int) player.center.x + 500);\n        int y = random.nextInt((int) player.center.y - 500, (int) player.center.y + 500);\n        Set<Point2D> positions = zombies.keySet();\n\n        Point2D point = new Point2D.Double(x, y);\n        // check if other zombies are in the same position\n        for (Point2D point2d : positions) {\n\n        }\n        return point;\n\n    }\n\n}\n",
      "Entity.java": "package Source;\n\nimport java.awt.geom.Point2D;\n\npublic class Entity {\n\n    public GamePanel gamePanel;\n\n    public Entity(GamePanel gamePanel) {\n        this.gamePanel = gamePanel;\n\n    }\n}\n",
      "GameFrame.java": "package Source;\n\nimport java.awt.BorderLayout;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class GameFrame extends JFrame {\n    public static final int WIDTH = 600;\n    public static final int HEIGHT = 400;\n    GamePanel gamePanel;\n    PausePanel pausePanel;\n\n    public GameFrame() {\n        super(\"Oyun\");\n        GamePanel gamePanel = new GamePanel();\n        this.setSize(gamePanel.WIDTH, gamePanel.HEIGHT);\n        this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n        this.setLayout(new BorderLayout());\n\n        this.add(gamePanel, BorderLayout.CENTER);\n        this.setVisible(true);\n\n    }\n\n}\n",
      "CollisionDetector.java": "package Source;\n\nimport java.awt.geom.Point2D;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport Source.Guns.Bullet;\nimport Source.Zombies.ParentZombie;\n\npublic class CollisionDetector {\n    GamePanel gamePanel;\n\n    public CollisionDetector(GamePanel gamePanel) {\n        this.gamePanel = gamePanel;\n    }\n\n    public void checkCollisions() {\n        checkBulletZombieCollisions();\n        // Add other collision checks here (e.g., player-zombie, player-wall)\n    }\n\n    private void checkBulletZombieCollisions() {\n        Iterator<Map.Entry<Point2D.Double, Bullet>> bulletIterator = gamePanel.bullets.entrySet().iterator();\n        List<ParentZombie> zombies = gamePanel.zombies;\n\n        while (bulletIterator.hasNext()) {\n            Map.Entry<Point2D.Double, Bullet> bulletEntry = bulletIterator.next();\n            Bullet bullet = bulletEntry.getValue();\n            Point2D.Double bulletPosition = bullet.getPosition();\n\n            for (Iterator<ParentZombie> zombieIterator = zombies.iterator(); zombieIterator.hasNext();) {\n                ParentZombie zombie = zombieIterator.next();\n                Point2D.Double zombiePosition = zombie.getPosition();\n                double zombieRadius = zombie.getWidth() / 2.0;\n\n                // Correct collision detection: check if the bullet is within the zombie's\n                // circular bounds\n                double distance = bulletPosition.distance(zombiePosition);\n                if (distance <= zombieRadius + bullet.size / 2.0) { // Include bullet size in the collision check\n                    // Handle collision: remove bullet and damage zombie\n                    bulletIterator.remove();\n                    zombie.takeDamage(bullet.getDamage());\n                    if (zombie.isDead()) {\n                        zombieIterator.remove();\n                    }\n                    break; // Exit the zombie loop since the bullet is removed\n                }\n            }\n        }\n    }\n}\n",
      "GamePanel.java": "package Source;\n\nimport java.awt.Graphics;\nimport java.awt.Image;\nimport java.awt.event.*;\nimport java.awt.geom.Point2D;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JPanel;\n\nimport Source.Guns.Bullet;\nimport Source.Tile.TileManager;\nimport Source.Zombies.ParentZombie;\n\npublic class GamePanel extends JPanel implements Runnable {\n    private Image backgroundImage;\n    public boolean keyPressed = false;\n    public final int originalTileSize = 16;\n    public final int scale = 3;\n    public final int tileSize = originalTileSize * scale;\n    public int tileCountX = 30;\n    public int tileCountY = 15;\n    public final int WIDTH = tileSize * tileCountX;\n    public final int HEIGHT = tileSize * tileCountY;\n    // world\n    public final int maxWorldCol = 150;\n    public final int maxWorldRow = 150;\n    public final int maxWorldHeight = tileSize * maxWorldCol;\n    public final int maxWorldWidth = tileSize * maxWorldRow;\n    Thread thread;\n    GameFrame frame;\n\n    ArrayList<ParentZombie> zombies = new ArrayList<>();\n    ArrayList<Bullet> bulletsList = new ArrayList<>();\n    public Map<Point2D.Double, Bullet> bullets;\n    public Player player;\n    public Key key;\n    int FPS = 60;\n    TileManager tileManager = new TileManager(this);\n    WaveManager waveManager = new WaveManager(player);\n\n    public GamePanel() {\n        this.setSize(WIDTH, HEIGHT);\n        setFocusable(true);\n        this.requestFocusInWindow();\n\n        key = new Key();\n        player = new Player(\"Player1\", 100, tileSize * 23, tileSize * 21, key, this);\n        bullets = new HashMap<>(); // Initialize the bullets map\n\n        try {\n            backgroundImage = ImageIO.read(new File(\"Source/images/backgroundImage.jpg\")); // Use relative path\n        } catch (Exception e) {\n            System.out.println(\"unable to find file\");\n        }\n        ParentZombie zombie = new ParentZombie(30, 5, 1, 100, 100, player, this);\n        zombies.add(zombie);\n        this.addKeyListener(key);\n        this.addMouseListener(key);\n        this.requestFocus();\n        this.repaint();\n        this.startThread();\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        tileManager.draw(g);\n        player.repaint(g);\n        for (ParentZombie zombie : zombies) {\n            zombie.repaint(g);\n        }\n\n        // Draw bullets\n        for (Map.Entry<Point2D.Double, Bullet> entry : bullets.entrySet()) {\n            Point2D.Double position = entry.getKey();\n            Bullet bullet = entry.getValue();\n            bullet.draw(g, position); // Ensure this matches the Bullet class's draw method\n        }\n    }\n\n    public class Key implements KeyListener, MouseListener {\n\n        public boolean upPressed = false, downPressed = false, leftPressed = false, rightPressed = false,\n                escPressed = false, mousePressed = false, relPressed = false;\n        Point2D.Double mousePosition = new Point2D.Double(0, 0);\n\n        @Override\n        public void keyTyped(KeyEvent e) {\n\n        }\n\n        @Override\n        public void keyPressed(KeyEvent e) {\n\n            if (e.getKeyCode() == KeyEvent.VK_W) {\n                upPressed = true;\n            }\n            if (e.getKeyCode() == KeyEvent.VK_S) {\n                downPressed = true;\n            }\n            if (e.getKeyCode() == KeyEvent.VK_D) {\n                rightPressed = true;\n            }\n            if (e.getKeyCode() == KeyEvent.VK_A) {\n                leftPressed = true;\n            }\n            if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {\n                // implement pause\n\n            }\n            if (e.getKeyCode() == KeyEvent.VK_R) {\n                // implement reload\n                player.gun.reload();\n            }\n            if (e.getKeyCode() == KeyEvent.VK_R) {\n                relPressed = true;\n\n            }\n\n        }\n\n        @Override\n        public void keyReleased(KeyEvent e) {\n            if (e.getKeyCode() == KeyEvent.VK_W) {\n                upPressed = false;\n            }\n            if (e.getKeyCode() == KeyEvent.VK_S) {\n                downPressed = false;\n            }\n            if (e.getKeyCode() == KeyEvent.VK_D) {\n                rightPressed = false;\n            }\n            if (e.getKeyCode() == KeyEvent.VK_A) {\n                leftPressed = false;\n            }\n            if (e.getKeyCode() == KeyEvent.VK_R) {\n                relPressed = false;\n\n            }\n        }\n\n        @Override\n        public void mouseClicked(MouseEvent e) {\n\n        }\n\n        @Override\n        public void mousePressed(MouseEvent e) {\n            mousePressed = true;\n            mousePosition.x = e.getX();\n            mousePosition.y = e.getY();\n\n        }\n\n        @Override\n        public void mouseReleased(MouseEvent e) {\n            mousePressed = false;\n        }\n\n        @Override\n        public void mouseEntered(MouseEvent e) {\n\n        }\n\n        @Override\n        public void mouseExited(MouseEvent e) {\n\n        }\n\n    }\n\n    public void switchPanelGtoP() {\n\n    }\n\n    public void switchPanelPtoG() {\n\n    }\n\n    public void startThread() {\n\n        thread = new Thread(this);\n        thread.start();\n    }\n\n    public void update() {\n        player.update();\n\n        // Update zombies and remove dead ones\n        zombies.removeIf(ParentZombie::isDead);\n\n        for (ParentZombie zombie : zombies) {\n            zombie.update();\n        }\n\n        // Update bullets\n        bullets.entrySet().removeIf(entry -> entry.getValue().update(entry.getKey())); // Ensure this matches the Bullet\n                                                                                       // class's update method\n    }\n\n    @Override\n    public void run() {\n\n        double interval = 1000000000 / FPS;\n        double delta = 0;\n        double lastTime = System.nanoTime();\n        double currentTime;\n        long timer = 0;\n        int drawCount = 0;\n\n        while (thread != null) {\n\n            currentTime = System.nanoTime();\n            delta += (currentTime - lastTime) / interval;\n            timer += currentTime - lastTime;\n            lastTime = currentTime;\n            if (delta >= 1) {\n                update();\n                repaint();\n                drawCount++;\n                delta--;\n            }\n\n            if (timer >= 1000000000) {\n                System.out.println(\"FPS: \" + drawCount);\n                drawCount = 0;\n                timer = 0;\n\n            }\n        }\n    }\n}\n",
      "PausePanel.java": "package Source;\n\nimport javax.swing.JPanel;\n\npublic class PausePanel extends JPanel {\n    GameFrame frame;\n\n    public PausePanel(GameFrame frame) {\n        this.frame = frame;\n    }\n\n}",
      "Game.java": "package Source;\n\npublic class Game {\n    public static void main(String[] args) {\n        GameFrame frame = new GameFrame();\n    }\n}\n",
      "Player.java": "package Source;\n\nimport java.awt.*;\nimport java.awt.event.KeyListener;\nimport java.awt.geom.Point2D;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JPanel;\n\nimport Source.GamePanel.Key;\nimport Source.Guns.ParentGun;\nimport Source.Guns.Pistol;\n\npublic class Player {\n    private String name;\n    private int maxHealth;\n    private int currentHealth;\n    private int points;\n    private int currentWave;\n    public int speed;\n    private static final int diameter = 24;\n    public Point2D.Double center;\n    public Point2D.Double direction;\n    private Image image;\n    ParentGun gun;\n    public Key key;\n    GamePanel gamePanel;\n    public final int screenCenterX;\n    public final int screenCenterY;\n    private boolean mouseClicked = false; // Fare tıklama durumu\n\n    Player(String name, int maxHealth, int startingPointX, int startingPointY, Key key, GamePanel gamePanel) {\n        screenCenterX = (gamePanel.WIDTH / 2) - (gamePanel.tileSize / 2);\n        screenCenterY = (gamePanel.HEIGHT / 2) - (gamePanel.tileSize / 2);\n        this.name = name;\n        this.gamePanel = gamePanel;\n        this.maxHealth = maxHealth;\n        this.key = key;\n        points = 0;\n        currentWave = 0;\n        currentHealth = maxHealth;\n        center = new Point2D.Double(screenCenterX, screenCenterY);\n        speed = 5;\n        gun = new Pistol(gamePanel);\n        try {\n            image = ImageIO.read(getClass().getResource(\"/Source/images/player.png\"));\n            if (image == null) {\n                throw new IllegalArgumentException(\"Resource not found: /images/player.png\");\n            }\n        } catch (IOException | IllegalArgumentException e) {\n            System.out.println(\"Error loading player image: \" + e.getMessage());\n            image = null; // Set to null if the image cannot be loaded\n        }\n    }\n\n    public void paint(Graphics g) {\n\n        g.drawImage(image, screenCenterX, screenCenterY, null);\n        displayHealth(g);\n    }\n\n    public void repaint(Graphics g) {\n        paint(g);\n    }\n\n    public void update() {\n        if (currentHealth <= 0) {\n            currentHealth = 0;\n            // player.death();\n            // gamePanel.gameOver();\n        }\n        if (key.upPressed) {\n            this.center.y -= this.speed;\n        }\n        if (key.downPressed) {\n            this.center.y += this.speed;\n        }\n        if (key.rightPressed) {\n            this.center.x += this.speed;\n        }\n        if (key.leftPressed) {\n            this.center.x -= this.speed;\n        }\n        if (key.mousePressed && !mouseClicked) {\n            // Sadece bir kez ateş et\n            shoot(key.mousePosition);\n            mouseClicked = true; // Tıklama durumunu güncelle\n        }\n        if (!key.mousePressed) {\n            mouseClicked = false; // Fare bırakıldığında durumu sıfırla\n        }\n        if (key.relPressed) {\n\n            gun.reload();\n\n        }\n    }\n\n    public void shoot(Point2D.Double mousePosition) {\n        Point2D.Double playerCenter = new Point2D.Double(center.x, center.y);\n        gun.shoot(playerCenter, mousePosition, gamePanel.bullets, gamePanel); // Updated to use Map\n    }\n\n    public void takeDamage(int damage) {\n        currentHealth -= damage;\n        if (currentHealth <= 0) {\n            currentHealth = 0;\n\n        }\n    }\n\n    public void displayHealth(Graphics g) {\n        g.setColor(Color.RED);\n        g.fillRect(10, 10, 200, 20);\n        g.setColor(Color.GREEN);\n        g.fillRect(10, 10, (int) ((currentHealth / (double) maxHealth) * 200), 20);\n    }\n\n    public int getDiameter() {\n        return diameter;\n    }\n}\n",
      "Sniper.java": "package Source.Guns;\n\nimport java.awt.geom.Point2D.Double;\n\npublic class Sniper extends ParentGun {\n\n    Sniper(int ammo, int damage, int range, int fireRate, double reloadTime) {\n        super(ammo, damage, range, fireRate, reloadTime);\n        // TODO Auto-generated constructor stub\n    }\n\n    @Override\n    public void reload() {\n        // TODO Auto-generated method stub\n        throw new UnsupportedOperationException(\"Unimplemented method 'reload'\");\n    }\n\n    @Override\n    public void shoot(int x, int y, Double playerPosition) {\n        // TODO Auto-generated method stub\n        throw new UnsupportedOperationException(\"Unimplemented method 'shoot'\");\n    }\n\n}\n",
      "Bullet.java": "package Source.Guns;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.geom.Point2D;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JPanel;\n\nimport Source.Entity;\nimport Source.GamePanel;\n\npublic class Bullet extends Entity {\n    public Point2D.Double position;\n    public double angle;\n    public int damage;\n    public final int size = 3;\n    public int speed = 3;\n    public Point2D.Double initalPosition;\n    public Point2D.Double dest;\n    public int range;\n    Color color = Color.MAGENTA;\n    BufferedImage image;\n\n    public Bullet(Point2D.Double dest, Point2D.Double playerPosition, int range, GamePanel gamePanel, ParentGun gun) {\n        super(gamePanel);\n        playerPosition.x += 24;\n        playerPosition.y += 24;\n        Point2D.Double dest1 = new Point2D.Double(dest.x, dest.y);\n        this.dest = dest1;\n        this.range = range;\n        initalPosition = playerPosition;\n        position = playerPosition;\n        damage = 5;\n\n        System.out.println(gun.currentAmmo);\n\n    }\n\n    public Point2D.Double getPosition() {\n        return position;\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public boolean update(Point2D.Double position) {\n        // Update the bullet's position and return true if it should be removed\n        if (initalPosition.distance(this.position) > range) {\n            return true; // Bullet should be removed\n        }\n\n        double dx = dest.x - this.position.x;\n        double dy = dest.y - this.position.y;\n\n        double distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance != 0) {\n            this.position.x += speed * dx / distance;\n            this.position.y += speed * dy / distance;\n        }\n        return false; // Bullet should not be removed\n    }\n\n    public void paint(Graphics g) {\n        int screenX = (int) position.x - ((int) gamePanel.player.center.x) + gamePanel.player.screenCenterX;\n        int screenY = (int) position.y - ((int) gamePanel.player.center.y) + gamePanel.player.screenCenterY;\n\n        if ((int) position.x + gamePanel.tileSize > gamePanel.player.center.x - gamePanel.player.screenCenterX &&\n                (int) position.x - gamePanel.tileSize < gamePanel.player.center.x + gamePanel.player.screenCenterX &&\n                (int) position.y + gamePanel.tileSize > gamePanel.player.center.y - gamePanel.player.screenCenterY &&\n                (int) position.y - gamePanel.tileSize < gamePanel.player.center.y + gamePanel.player.screenCenterY) {\n            if (image != null) {\n                g.drawImage(image, screenX, screenY, size, size, gamePanel);\n            } else {\n                g.setColor(color);\n                g.fillOval(screenX, screenY, size, size);\n            }\n        }\n    }\n\n    public void repaint(Graphics g) {\n        paint(g);\n    }\n\n    public void draw(Graphics g, Point2D.Double position) {\n        // Draw the bullet at the given position\n        g.setColor(color);\n        int screenX = (int) position.x - ((int) gamePanel.player.center.x) + gamePanel.player.screenCenterX;\n        int screenY = (int) position.y - ((int) gamePanel.player.center.y) + gamePanel.player.screenCenterY;\n\n        if ((int) position.x + gamePanel.tileSize > gamePanel.player.center.x - gamePanel.player.screenCenterX &&\n                (int) position.x - gamePanel.tileSize < gamePanel.player.center.x + gamePanel.player.screenCenterX &&\n                (int) position.y + gamePanel.tileSize > gamePanel.player.center.y - gamePanel.player.screenCenterY &&\n                (int) position.y - gamePanel.tileSize < gamePanel.player.center.y + gamePanel.player.screenCenterY) {\n            g.fillOval(screenX, screenY, size, size);\n        }\n    }\n}\n",
      "Shotgun.java": "package Source.Guns;\n\nimport java.awt.geom.Point2D.Double;\n\npublic class Shotgun extends ParentGun {\n\n    Shotgun(int ammo, int damage, int range, int fireRate, double reloadTime) {\n        super(ammo, damage, range, fireRate, reloadTime);\n        // TODO Auto-generated constructor stub\n    }\n\n    @Override\n    public void reload() {\n        // TODO Auto-generated method stub\n        throw new UnsupportedOperationException(\"Unimplemented method 'reload'\");\n    }\n\n    @Override\n    public void shoot(int x, int y, Double playerPosition) {\n        // TODO Auto-generated method stub\n        throw new UnsupportedOperationException(\"Unimplemented method 'shoot'\");\n    }\n\n}\n",
      "Pistol.java": "package Source.Guns;\n\nimport java.awt.geom.Point2D;\nimport java.util.Map;\n\nimport Source.GamePanel;\n\npublic class Pistol extends ParentGun {\n\n    public Pistol(GamePanel gamePanel) {\n        super(12, 5, 50, 2, 0.1, gamePanel);\n    }\n\n    @Override\n    public void reload() {\n        currentAmmo = maxAmmo;\n    }\n\n    @Override\n    public void shoot(Point2D.Double playerPosition, Point2D.Double mousePosition,\n            Map<Point2D.Double, Bullet> bullets, GamePanel gamePanel) {\n        if (currentAmmo > 0) {\n            Bullet bullet = new Bullet(mousePosition, playerPosition, range, gamePanel, this);\n            bullets.put(bullet.getPosition(), bullet);\n            currentAmmo--;\n        } else {\n            System.out.println(\"Out of ammo! Reload required.\");\n        }\n    }\n}\n",
      "ParentGun.java": "package Source.Guns;\n\nimport java.awt.geom.Point2D;\nimport java.util.Map;\n\nimport Source.GamePanel;\n\nabstract public class ParentGun {\n\n    int maxAmmo;\n    int damage;\n    int range;\n    int fireRate; // bullets per second\n    double reloadTime;\n    int currentAmmo;\n    GamePanel gamePanel;\n\n    ParentGun(int ammo, int damage, int range, int fireRate, double reloadTime, GamePanel gamePanel) {\n        this.gamePanel = gamePanel;\n        this.maxAmmo = ammo;\n        this.damage = damage;\n        this.range = range;\n        this.fireRate = fireRate;\n        this.reloadTime = reloadTime;\n        this.currentAmmo = maxAmmo;\n    }\n\n    public void reload() {\n        currentAmmo = maxAmmo;\n    }\n\n    public abstract void shoot(Point2D.Double center, Point2D.Double mousePosition,\n            Map<Point2D.Double, Bullet> bullets, GamePanel gamePanel);\n}\n",
      "Rifle.java": "package Source.Guns;\n\nimport java.awt.geom.Point2D.Double;\nimport java.util.ArrayList;\n\nimport Source.GamePanel;\n\npublic class Rifle extends ParentGun {\n\n    Rifle(int ammo, int damage, int range, int fireRate, double reloadTime, GamePanel gamePanel) {\n        super(ammo, damage, range, fireRate, reloadTime, gamePanel);\n        this.maxAmmo = ammo;\n        // TODO Auto-generated constructor stub\n    }\n\n    @Override\n    public void reload() {\n        // TODO Auto-generated method stub\n        throw new UnsupportedOperationException(\"Unimplemented method 'reload'\");\n    }\n\n    @Override\n    public void shoot(Double center, Double mousePosition, ArrayList<Bullet> bullets, GamePanel gamePanel) {\n        // TODO Auto-generated method stub\n        throw new UnsupportedOperationException(\"Unimplemented method 'shoot'\");\n    }\n\n}\n",
      "RocketLauncher.java": "package Source.Guns;\n\nimport java.awt.geom.Point2D.Double;\nimport java.util.ArrayList;\n\nimport Source.Game;\nimport Source.GamePanel;\n\npublic class RocketLauncher extends ParentGun {\n\n    RocketLauncher(int ammo, int damage, int range, int fireRate, double reloadTime, GamePanel gamePanel) {\n        super(ammo, damage, range, fireRate, reloadTime, gamePanel);\n        this.maxAmmo = ammo;\n\n        // TODO Auto-generated constructor stub\n    }\n\n    @Override\n    public void reload() {\n        // TODO Auto-generated method stub\n        throw new UnsupportedOperationException(\"Unimplemented method 'reload'\");\n    }\n\n    @Override\n    public void shoot(Double center, Double mousePosition, ArrayList<Bullet> bullets, GamePanel gamePanel) {\n        // TODO Auto-generated method stub\n        throw new UnsupportedOperationException(\"Unimplemented method 'shoot'\");\n    }\n\n}\n",
      "Tile.java": "package Source.Tile;\n\nimport java.awt.image.BufferedImage;\n\npublic class Tile {\n    public BufferedImage image;\n    public boolean collison = false;\n}\n",
      "TileManager.java": "package Source.Tile;\n\nimport java.awt.Graphics;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.ImageIcon;\n\nimport Source.GamePanel;\n\npublic class TileManager {\n    GamePanel gamePanel;\n    Tile[] tiles;\n    int[][] tileMap;\n\n    public TileManager(GamePanel gamePanel) {\n        this.gamePanel = gamePanel;\n        tiles = new Tile[10];\n        tileMap = new int[gamePanel.maxWorldCol][gamePanel.maxWorldRow];\n        TileImage();\n\n    }\n\n    public void getMap() {\n        try {\n            Scanner scanner = new Scanner(new File(\"Source/Tile/map.txt\"));\n            int colon = 0;\n            int row = 0;\n            while (colon < gamePanel.tileCountX && row < gamePanel.tileCountY) {\n                tileMap[colon][row] = scanner.nextInt();\n                colon++;\n                if (colon == gamePanel.tileCountX) {\n                    colon = 0;\n                    row++;\n                }\n\n            }\n            scanner.close();\n        } catch (Exception e) {\n\n        }\n    }\n\n    public void TileImage() {\n        tiles[0] = new Tile();\n        tiles[1] = new Tile();\n        tiles[2] = new Tile();\n        try {\n            tiles[0].image = ImageIO.read(getClass().getResourceAsStream(\"/Source/images/grass.png\"));\n            if (tiles[0].image == null) {\n                throw new IllegalArgumentException(\"Resource not found: /Source/images/grass.png\");\n            }\n        } catch (IOException | IllegalArgumentException e) {\n            System.out.println(\"Error loading tile image: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public void draw(Graphics g) {\n        int colon = 0;\n        int row = 0;\n        while (colon < gamePanel.maxWorldCol && row < gamePanel.maxWorldRow) {\n            int tilenum = tileMap[colon][row];\n\n            int worldX = colon * gamePanel.tileSize;\n            int worldY = row * gamePanel.tileSize;\n            int screenX = worldX - ((int) gamePanel.player.center.x) + gamePanel.player.screenCenterX;\n            int screenY = worldY - ((int) gamePanel.player.center.y) + gamePanel.player.screenCenterY;\n\n            if (worldX + gamePanel.tileSize > gamePanel.player.center.x - gamePanel.player.screenCenterX &&\n                    worldX - gamePanel.tileSize < gamePanel.player.center.x + gamePanel.player.screenCenterX &&\n                    worldY + gamePanel.tileSize > gamePanel.player.center.y - gamePanel.player.screenCenterY &&\n                    worldY - gamePanel.tileSize < gamePanel.player.center.y + gamePanel.player.screenCenterY) {\n                g.drawImage(tiles[tilenum].image, screenX, screenY, gamePanel.tileSize, gamePanel.tileSize, null);\n            }\n            colon++;\n\n            if (colon == gamePanel.maxWorldCol) {\n                colon = 0;\n                row++;\n            }\n        }\n    }\n}\n",
      "NormalZombie.java": "package Source.Zombies;\n\nimport Source.GamePanel;\nimport Source.Player;\n\npublic class NormalZombie extends ParentZombie {\n    public NormalZombie(int xCoordinate, int yCoordinate, Player player,\n            GamePanel gamePanel) {\n        super(100, 3, 5, xCoordinate, yCoordinate, player, gamePanel);\n        this.health = 100;\n        this.speed = 2.0;\n        this.damage = 5;\n\n    }\n}\n",
      "ParentZombie.java": "//general class for all zombies\n\npackage Source.Zombies;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Image;\nimport java.awt.geom.Point2D;\nimport java.io.File;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JPanel;\n\nimport Source.Game;\nimport Source.GamePanel;\nimport Source.Player;\n\npublic class ParentZombie {\n    private Point2D.Double position;\n    int health;\n    double speed;\n    protected static final int diameter = 24;\n    int damage;\n    public Point2D.Double center;\n    Color color;\n    private Image image;\n    Player player;\n    GamePanel gamePanel;\n\n    public ParentZombie(int health, double speed, int damage, int xCoordinate, int yCoordinate, Player player,\n            GamePanel gamePanel) {\n        this.center = new Point2D.Double(xCoordinate, yCoordinate);\n        this.position = center;\n        this.health = health;\n        this.speed = 1;\n        this.damage = damage;\n        this.center.x = xCoordinate;\n        this.center.y = yCoordinate;\n        this.player = player;\n        this.gamePanel = gamePanel;\n\n        // try {\n        // image = ImageIO.read(new File(\n        // \"C:\\\\Users\\\\osman\\\\OneDrive\\\\Desktop\\\\OsmanKuru_241101005_Bil211_Ödev\\\\Source\\\\images\\\\NormalZombie.png\"));\n        // } catch (Exception e) {\n        // System.out.println(e.getMessage());\n        // }\n    }\n\n    public void draw(Graphics g) {\n        // g.drawImage(image, (int) Math.floor(center.x), (int) Math.floor(center.y),\n        // new JPanel());\n        g.setColor(color);\n\n        //\n\n        int screenX = (int) center.x - ((int) gamePanel.player.center.x) + gamePanel.player.screenCenterX;\n        int screenY = (int) center.y - ((int) gamePanel.player.center.y) + gamePanel.player.screenCenterY;\n\n        if ((int) center.x + gamePanel.tileSize > gamePanel.player.center.x - gamePanel.player.screenCenterX &&\n                (int) center.x - gamePanel.tileSize < gamePanel.player.center.x + gamePanel.player.screenCenterX &&\n                (int) center.y + gamePanel.tileSize > gamePanel.player.center.y - gamePanel.player.screenCenterY &&\n                (int) center.y - gamePanel.tileSize < gamePanel.player.center.y + gamePanel.player.screenCenterY) {\n            g.fillOval(screenX, screenY, diameter, diameter);\n        }\n    }\n\n    public void repaint(Graphics g) {\n        draw(g);\n    }\n\n    public void update() {\n        if (isDead()) {\n            color = null;\n            return;\n\n        }\n\n        if (center.x > player.center.x) {\n\n            center.x -= speed;\n\n        }\n        if (center.x < player.center.x) {\n            center.x += speed;\n\n        }\n        if (center.y > player.center.y) {\n            center.y -= speed;\n\n        }\n        if (center.y < player.center.y) {\n            center.y += speed;\n\n        }\n        if (player.center.distance(center) < diameter / 2.0 + player.getDiameter() / 2.0) {\n            player.takeDamage(damage);\n\n        }\n    }\n\n    public int getDiameter() {\n        return diameter;\n    }\n\n    public Point2D.Double getPosition() {\n        return position;\n    }\n\n    public boolean isDead() {\n        return health <= 0;\n    }\n\n    public int getWidth() {\n        return diameter;\n    }\n\n    public void takeDamage(int damage) {\n        health -= damage;\n        System.out.println(\"Zombie health: \" + health); // Print the zombie's health\n    }\n}\n",
      "AcidSpitterZombie.java": "package Source.Zombies;\n\nimport Source.GamePanel;\nimport Source.Player;\n\npublic class AcidSpitterZombie extends ParentZombie {\n    public AcidSpitterZombie(int xCoordinate, int yCoordinate, Player player,\n            GamePanel gamePanel) {\n        super(100, 3, 5, xCoordinate, yCoordinate, player, gamePanel);\n        this.health = 100;\n        this.speed = 2.0;\n        this.damage = 5;\n    }\n\n    public void update() {\n\n    }\n}\n",
      "CrawlerZombie.java": "package Source.Zombies;\n\nimport java.awt.Color;\n\nimport Source.GamePanel;\nimport Source.Player;\n\npublic class CrawlerZombie extends ParentZombie {\n    public CrawlerZombie(int xCoordinate, int yCoordinate, Player player,\n            GamePanel gamePanel) {\n        super(100, 1, 2, xCoordinate, yCoordinate, player, gamePanel);\n        this.health = 100;\n        this.speed = 1.0;\n        this.damage = 2;\n        this.color = Color.BLUE;\n    }\n\n    public void update() {\n        if (isDead()) {\n            color = null;\n            return;\n\n        }\n        if (player.center.distance(center) < 20) {\n            speed = 2.0;\n        } else {\n            speed = 1.0;\n\n        }\n\n        if (center.x > player.center.x) {\n\n            center.x -= speed;\n\n        }\n        if (center.x < player.center.x) {\n            center.x += speed;\n\n        }\n        if (center.y > player.center.y) {\n            center.y -= speed;\n\n        }\n        if (center.y < player.center.y) {\n            center.y += speed;\n\n        }\n        if (player.center.distance(center) < diameter / 2.0 + player.getDiameter() / 2.0) {\n            player.takeDamage(damage);\n\n        }\n    }\n}\n",
      "TankZombie.java": "package Source.Zombies;\n\nimport static Source.Zombies.ParentZombie.diameter;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\n\nimport Source.GamePanel;\nimport Source.Player;\n\npublic class TankZombie extends ParentZombie {\n    public TankZombie(int xCoordinate, int yCoordinate, Player player,\n            GamePanel gamePanel) {\n        super(200, 1, 10, xCoordinate, yCoordinate, player, gamePanel);\n        this.health = 200;\n        this.speed = 0.5;\n        this.damage = 10;\n        this.color = Color.RED;\n\n    }\n\n    public void draw(Graphics g) {\n        // g.drawImage(image, (int) Math.floor(center.x), (int) Math.floor(center.y),\n        // new JPanel());\n        g.setColor(this.color);\n\n        //\n\n        int screenX = (int) center.x - ((int) gamePanel.player.center.x) + gamePanel.player.screenCenterX;\n        int screenY = (int) center.y - ((int) gamePanel.player.center.y) + gamePanel.player.screenCenterY;\n\n        if ((int) center.x + gamePanel.tileSize > gamePanel.player.center.x - gamePanel.player.screenCenterX &&\n                (int) center.x - gamePanel.tileSize < gamePanel.player.center.x + gamePanel.player.screenCenterX &&\n                (int) center.y + gamePanel.tileSize > gamePanel.player.center.y - gamePanel.player.screenCenterY &&\n                (int) center.y - gamePanel.tileSize < gamePanel.player.center.y + gamePanel.player.screenCenterY) {\n            g.fillOval(screenX, screenY, diameter, diameter);\n        }\n    }\n}\n",
      "CollisonDetector.java": "package Source.tools;\n\nimport java.awt.geom.Point2D;\nimport java.util.HashMap;\nimport java.util.Set;\n\nimport Source.Player;\nimport Source.Zombies.ParentZombie;\n\npublic class CollisonDetector {\n    public static boolean isColliding(Player player, HashMap<Point2D, ParentZombie> zombies) {\n        Set<Point2D> positions = zombies.keySet();\n        for (Point2D point2d : positions) {\n            if (player.center.distance(point2d) < player.getDiameter()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static boolean isColliding(ParentZombie z1, ParentZombie z2) {\n        double distance = z1.center.distance(z2.center);\n        if (distance < z1.getDiameter()) {\n            return true;\n        } else\n            return false;\n    }\n}\n"
    },
    {
      "id": "2103960",
      "Zombie.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic abstract class Zombie {\n    protected int x, y;\n    protected int health;\n    protected int speed;\n    protected int damage;\n    protected int size;\n\n    BufferedImage mapImage;\n\n    public Zombie(int x, int y) {\n        this.x = x;\n        this.y = y;\n        health = 50;\n        speed = 4;\n        damage = 20;\n        size = 30;\n\n        try {\n            mapImage = ImageIO.read(new File(\"../TopDownShooter/lib/background2.png\"));\n        } catch (IOException e) {\n            System.out.println(\"image not found\");\n        }\n    }\n\n    public boolean isObstacle(int x, int y) {\n        int color = mapImage.getRGB(x, y);\n        return (color & 0xFFFFFF) == 0xFFFFFF; // white\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.GREEN);\n        g.fillOval(x - size / 2, y - size / 2, size, size);\n    }\n\n    public boolean update(int playerX, int playerY) {\n        int newX = x;\n        int newY = y;\n        int dx = playerX - x;\n        int dy = playerY - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance > 0) {\n            newX = x + (int) (speed * (dx / distance));\n            newY = y + (int) (speed * (dy / distance));\n        }\n        if (!isObstacle(newX, newY)) {\n            x = newX;\n            y = newY;\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    public void takeDamage(int damage) {\n        health -= damage;\n    }\n\n    public boolean isDead() {\n        return health <= 0;\n    }\n\n    public boolean collidesWithPlayer(int playerX, int playerY) {\n        int playerSize = 40;\n\n        Rectangle zombieBounds = new Rectangle(x - size / 2, y - size / 2, size, size);\n        Rectangle playerBounds = new Rectangle(playerX - playerSize / 2, playerY - playerSize / 2, playerSize,\n                playerSize);\n\n        return zombieBounds.intersects(playerBounds);\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setSpeed(int newSpeed) {\n        this.speed = newSpeed;\n    }\n\n    public void setSize(int newSize) {\n        this.size = newSize;\n    }\n\n    public void setDamage(int newDamage) {\n        this.damage = newDamage;\n    }\n\n    public void setHealth(int newHealth) {\n        this.health = newHealth;\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n}\n",
      "Character.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.event.KeyEvent;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class Character implements moving {\n    private BufferedImage mapImage;\n    private int x, y;\n    private int size = 40;\n    private int speed = 15;\n    private int health = 500;\n    private boolean[] keys = new boolean[4];\n\n    public Character(int x, int y) {\n        this.x = x;\n        this.y = y;\n        try {\n            mapImage = ImageIO.read(new File(\"../TopDownShooter/lib/background2.png\"));\n        } catch (IOException e) {\n            System.out.println(\"image not found\");\n        }\n\n    }\n\n    public void draw(Graphics g) {\n        int playerSize = 40;\n        g.setColor(Color.BLUE);\n        g.fillOval(x - playerSize / 2, y - playerSize / 2, playerSize, playerSize);\n    }\n\n    @Override\n    public boolean move() {\n        int newx = x;\n        int newY = y;\n        if (keys[0])\n            newY -= speed;\n        if (keys[1])\n            newY += speed;\n        if (keys[2])\n            newx -= speed;\n        if (keys[3])\n            newx += speed;\n\n        if (!isObstacle(newx, newY)) {\n            x = newx;\n            y = newY;\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    public boolean isObstacle(int x, int y) {\n        int pixelColor = mapImage.getRGB(x, y);\n        return (pixelColor & 0xFFFFFF) != 0x000000;\n    }\n\n    public void setDirection(int key, boolean pressed) {\n        if (key == KeyEvent.VK_W)\n            keys[0] = pressed;\n        if (key == KeyEvent.VK_S)\n            keys[1] = pressed;\n        if (key == KeyEvent.VK_A)\n            keys[2] = pressed;\n        if (key == KeyEvent.VK_D)\n            keys[3] = pressed;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, size, size);\n    }\n\n    public boolean isDead() {\n        return health <= 0;\n    }\n\n    public void decHealth(int damage) {\n        health -= damage;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n}\n",
      "Bullet.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class Bullet implements moving {\n    int x, y;\n    private int width = 3, length = 5;\n    private double speed = 10.0;\n    private double angle;\n    private BufferedImage mapImage;\n    private boolean alive = true;\n\n    private int damage = 10;\n\n    public Bullet(int x, int y, int targetX, int targetY) {\n        this.x = x;\n        this.y = y;\n        this.angle = Math.atan2(targetY - y, targetX - x);\n        try {\n            mapImage = ImageIO.read(new File(\"../TopDownShooter/lib/background2.png\"));\n        } catch (IOException e) {\n            System.out.println(\"image not found\");\n        }\n\n    }\n\n    public boolean move() {\n        int newx = (int) (x + speed * Math.cos(angle));\n        int newy = (int) (y + speed * Math.sin(angle));\n        if (!isObstacle(newx, newy)) {\n            x = newx;\n            y = newy;\n        } else {\n            return false;\n        }\n        return true;\n\n    }\n\n    public boolean isObstacle(int x, int y) {\n        int pixelColor = mapImage.getRGB(x, y);\n        return (pixelColor & 0xFFFFFF) != 0x000000;\n    }\n\n    public boolean isAlive() {\n        return alive;\n    }\n\n    public void destroy() {\n        alive = false;\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x - 5, y - 5, 10, 10);\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.LIGHT_GRAY);\n        g.fillRect(x, y, width, length);\n    }\n\n    public int getWidth() {\n        return width;\n    }\n\n    public int getLength() {\n        return length;\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public void setDamage(int newDmg) {\n        this.damage = newDmg;\n    }\n\n}\n",
      "Acid.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.util.List;\n\npublic class Acid {\n    private int x, y;\n    private int speed = 4;\n    private double dx, dy;\n    private boolean active = true;\n    private static final int SIZE = 8;\n\n    public Acid(int x, int y, int targetX, int targetY) {\n        this.x = x;\n        this.y = y;\n\n        double angle = Math.atan2(targetY - y, targetX - x);\n        this.dx = speed * Math.cos(angle);\n        this.dy = speed * Math.sin(angle);\n\n    }\n\n    public void update(Character player, List<Zombie> zombies, BufferedImage mapImage) {\n        x += dx;\n        y += dy;\n\n        if (player.getBounds().intersects(getBounds())) {\n            player.decHealth(10);\n            active = false;\n        }\n\n        if (isObstacle(x, y, mapImage)) {\n            active = false;\n        }\n    }\n\n    public boolean isObstacle(int x, int y, BufferedImage mapImage) {\n        int color = mapImage.getRGB(x, y);\n        return (color & 0xFFFFFF) == 0xFFFFFF || color == Color.BLUE.getRGB();\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.RED);\n        g.fillOval(x, y, SIZE, SIZE);\n\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, SIZE, SIZE);\n    }\n\n    public boolean isActive() {\n        return active;\n    }\n\n}\n",
      "ReptileZombie.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class ReptileZombie extends Zombie {\n    private int jumpCooldown = 0;\n\n    public ReptileZombie(int x, int y) {\n        super(x, y);\n\n        super.setHealth(20);\n        super.setDamage(20);\n        super.setSpeed(7);\n\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.MAGENTA);\n        g.fillOval(x - size / 2, y - size / 2, size, size);\n    }\n\n    public boolean update(int playerX, int playerY) {\n        int newX = x;\n        int newY = y;\n        int dx = playerX - x;\n        int dy = playerY - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (jumpCooldown > 0) {\n            jumpCooldown--;\n        }\n\n        if (distance > 0) {\n            newX = x + (int) (speed * (dx / distance));\n            newY = y + (int) (speed * (dy / distance));\n\n            if (distance < 60 && jumpCooldown == 0) {\n\n                jumpCooldown = 100;\n                newX = x + dx / 2;\n                newY = y + dy / 2;\n\n            }\n        }\n        if (!isObstacle(newX, newY)) {\n            x = newX;\n            y = newY;\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    public void takeDamage(int damage) {\n        this.health -= damage;\n    }\n\n    public boolean isDead() {\n        return health <= 0;\n    }\n\n    public boolean isObstacle(int x, int y) {\n        int color = mapImage.getRGB(x, y);\n        return (color & 0xFFFFFF) == 0xFFFFFF; // white\n    }\n\n    public boolean collidesWithPlayer(int playerX, int playerY) {\n        int playerSize = 40;\n\n        Rectangle zombieBounds = new Rectangle(x - size / 2, y - size / 2, size, size);\n        Rectangle playerBounds = new Rectangle(playerX - playerSize / 2, playerY - playerSize / 2, playerSize,\n                playerSize);\n\n        return zombieBounds.intersects(playerBounds);\n    }\n\n}\n",
      "moving.java": "public interface moving {\n    boolean move();\n\n}\n",
      "GameWindow.java": "import javax.swing.JFrame;\n\npublic class GameWindow extends JFrame {\n    public GameWindow() {\n        setTitle(\"Top-Down Shooter\");\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        add(new GamePanel());\n        pack();\n        setLocationRelativeTo(null);\n        setVisible(true);\n    }\n}\n",
      "NormalZombie.java": "\npublic class NormalZombie extends Zombie {\n\n    public NormalZombie(int x, int y) {\n        super(x, y);\n\n    }\n\n}\n",
      "GamePanel.java": "import javax.imageio.ImageIO;\nimport javax.swing.JPanel;\n\nimport java.util.Iterator;\nimport javax.swing.Timer;\nimport java.awt.event.KeyListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.Dimension;\nimport java.awt.event.ActionEvent;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.Color;\n\nimport java.awt.event.MouseMotionListener;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\n\npublic class GamePanel extends JPanel implements ActionListener, KeyListener, MouseListener, MouseMotionListener {\n    private Character player;\n    private Timer timer;\n    private BufferedImage mapImage;\n\n    private List<Bullet> bullets;\n    private List<Zombie> zombies;\n    private List<Acid> acids;\n\n    private int waveNumber = 1;\n    private boolean waveActive = false;\n    private int zombiesToSpawn = 5;\n    private int zombiesRemaining;\n\n    private long lastDamageTime = 0;\n    private final int cooldown = 500;\n\n    public GamePanel() {\n        setPreferredSize(new Dimension(1920, 1080));\n        addMouseListener((MouseListener) this);\n        addKeyListener(this);\n        setFocusable(true);\n        try {\n            mapImage = ImageIO.read(new File(\"../TopDownShooter/lib/background2.png\"));\n        } catch (IOException e) {\n            System.out.println(\"image not found\");\n        }\n\n        bullets = new ArrayList<>();\n        zombies = new ArrayList<>();\n        acids = new ArrayList<>();\n\n        player = new Character(400, 300);\n\n        timer = new Timer(16, this);\n        timer.start();\n        startNewWave();\n\n    }\n\n    private void startNewWave() {\n        waveActive = true;\n        zombies.clear();\n        zombiesToSpawn = waveNumber * 5;\n        zombiesRemaining = zombiesToSpawn;\n\n        for (int i = 0; i < zombiesToSpawn; i++) {\n            int z_x = (int) (Math.random() * 500 + 200);\n            int z_y = (int) (Math.random() * 500 + 200);\n\n            double zSelect = Math.random();\n            if (waveNumber >= 10 && zSelect < 0.10) {\n                zombies.add(new TankZombie(z_x, z_y));\n            } else if (waveNumber >= 5 && zSelect < 0.2) {\n                zombies.add(new AcidSpittingZombie(z_x, z_y, this));\n            } else if (waveNumber >= 3 && zSelect < 0.3) {\n                zombies.add(new ReptileZombie(z_x, z_y));\n            } else {\n                zombies.add(new NormalZombie(z_x, z_y));\n            }\n\n        }\n\n        System.out.println(\"Wave: \" + waveNumber + \" Zombies: \" + zombiesToSpawn);\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n        if (mapImage != null) {\n            g.drawImage(mapImage, 0, 0, null);\n        }\n        player.draw(g);\n\n        for (Bullet bullet : bullets) {\n            bullet.draw(g);\n        }\n\n        for (Zombie z : zombies) {\n            z.draw(g);\n        }\n        for (Acid acid : acids) {\n            acid.draw(g);\n        }\n\n        g.setColor(Color.GREEN);\n        g.drawString(\"HP: \" + player.getHealth(), 10, 50);\n\n        g.setColor(Color.CYAN);\n        g.drawString(\"Wave: \" + waveNumber, 20, 30);\n\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        update();\n        repaint();\n    }\n\n    private void update() {\n        player.move();\n\n        Iterator<Bullet> bulletIterator = bullets.iterator();\n        while (bulletIterator.hasNext()) {\n            Bullet b = bulletIterator.next();\n            Rectangle bulletBounds = b.getBounds();\n\n            Iterator<Zombie> zombieIterator = zombies.iterator();\n            while (zombieIterator.hasNext()) {\n                Zombie z = zombieIterator.next();\n                Rectangle zombieBounds = new Rectangle(z.getX() - z.getSize() / 2, z.getY() - z.getSize() / 2,\n                        z.getSize(), z.getSize());\n\n                if (bulletBounds.intersects(zombieBounds)) {\n                    z.takeDamage(b.getDamage());\n                    bulletIterator.remove();\n                    if (z.isDead() && z instanceof AcidSpittingZombie) {\n                        AcidSpittingZombie z1 = (AcidSpittingZombie) z;\n                        z1.triggerExplosion();\n                        z1 = null;\n                        zombieIterator.remove();\n                        zombiesRemaining--;\n                    } else if (z.isDead()) {\n                        zombieIterator.remove();\n                        zombiesRemaining--;\n                    }\n                    break;\n                }\n            }\n\n            if (!b.move()) {\n                bulletIterator.remove();\n            }\n        }\n\n        Iterator<Acid> acidIterator = acids.iterator();\n        while (acidIterator.hasNext()) {\n            Acid acid = acidIterator.next();\n            acid.update(player, zombies, mapImage);\n            if (!acid.isActive()) {\n                acidIterator.remove();\n            }\n        }\n\n        for (Zombie z : zombies) {\n            z.update(player.getX(), player.getY());\n\n            if (z.collidesWithPlayer(player.getX(), player.getY())) {\n                long currentTime = System.currentTimeMillis();\n\n                if (currentTime - lastDamageTime >= cooldown) {\n                    player.decHealth(z.getDamage());\n                    lastDamageTime = currentTime;\n                    System.out.println(\"Player hit Health: \" + player.getHealth());\n                }\n            }\n        }\n\n        if (player.getHealth() <= 0) {\n            System.out.println(\"Game Over\");\n            System.exit(0);\n        }\n\n        if (waveActive && zombiesRemaining <= 0) {\n            waveActive = false;\n            waveNumber++;\n            startNewWave();\n        }\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        player.setDirection(e.getKeyCode(), true);\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        player.setDirection(e.getKeyCode(), false);\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        Bullet bullet = new Bullet(player.getX(), player.getY(), e.getX(), e.getY());\n        bullets.add(bullet);\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e) {\n\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e) {\n\n    }\n\n    public Character getChar() {\n        return this.player;\n    }\n\n    public List<Acid> getAcids() {\n        return acids;\n    }\n\n    public List<Zombie> getZombies() {\n        return zombies;\n    }\n\n}\n",
      "AcidSpittingZombie.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class AcidSpittingZombie extends Zombie {\n    private int shootCooldown = 50;\n    private GamePanel gamePanel;\n\n    public AcidSpittingZombie(int x, int y, GamePanel gamePanel) {\n        super(x, y);\n        super.setHealth(30);\n        super.setDamage(20);\n        super.setSpeed(3);\n        this.gamePanel = gamePanel;\n\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(Color.PINK);\n        g.fillOval(x - size / 2, y - size / 2, size, size);\n    }\n\n    public boolean isObstacle(int x, int y) {\n        int color = mapImage.getRGB(x, y);\n        return (color & 0xFFFFFF) == 0xFFFFFF; // white\n    }\n\n    public boolean update(int playerX, int playerY) {\n        int newX = x;\n        int newY = y;\n        int dx = playerX - x;\n        int dy = playerY - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance > 0) {\n            newX = x + (int) (speed * (dx / distance));\n            newY = y + (int) (speed * (dy / distance));\n        }\n\n        if (shootCooldown > 0) {\n            shootCooldown--;\n\n        } else {\n            gamePanel.getAcids().add(new Acid(x, y, playerX, playerY));\n            shootCooldown = 50;\n        }\n\n        if (!isObstacle(newX, newY)) {\n            x = newX;\n            y = newY;\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    public void triggerExplosion() {\n        int explosionRadius = 50;\n\n        Character player = gamePanel.getChar();\n        double distanceToPlayer = Math.sqrt(Math.pow(player.getX() - x, 2) + Math.pow(player.getY() - y, 2));\n        if (distanceToPlayer <= explosionRadius) {\n            player.decHealth(25);\n        }\n\n        for (Zombie z : gamePanel.getZombies()) {\n            if (z != this) {\n                double distanceToZombie = Math.sqrt(Math.pow(z.getX() - x, 2) + Math.pow(z.getY() - y, 2));\n                if (distanceToZombie <= explosionRadius) {\n                    z.takeDamage(10);\n                    System.out.println(\"explosion dmg...\");\n                }\n            }\n        }\n\n    }\n\n    public void takeDamage(int damage) {\n        health -= damage;\n    }\n\n    public boolean isDead() {//\n        return health <= 0;\n    }\n\n    public boolean collidesWithPlayer(int playerX, int playerY) {\n        int playerSize = 40;\n\n        Rectangle zombieBounds = new Rectangle(x - size / 2, y - size / 2, size, size);\n        Rectangle playerBounds = new Rectangle(playerX - playerSize / 2, playerY - playerSize / 2, playerSize,\n                playerSize);\n\n        return zombieBounds.intersects(playerBounds);\n    }\n\n}\n",
      "TankZombie.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class TankZombie extends Zombie {\n\n    public TankZombie(int x, int y) {\n        super(x, y);\n        super.setHealth(180);\n        super.setDamage(35);\n        super.setSpeed(2);\n    }\n\n    public void draw(Graphics g) {\n        g.setColor(new Color(0, 100, 0)); // Dark green\n        g.fillOval(x - size / 2, y - size / 2, size, size);\n    }\n\n    public boolean update(int playerX, int playerY) {\n        int newX = x;\n        int newY = y;\n        int dx = playerX - x;\n        int dy = playerY - y;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance > 0) {\n            newX = x + (int) (speed * (dx / distance));\n            newY = y + (int) (speed * (dy / distance));\n        }\n        if (!isObstacle(newX, newY)) {\n            x = newX;\n            y = newY;\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    public boolean isObstacle(int x, int y) {\n        int color = mapImage.getRGB(x, y);\n        return (color & 0xFFFFFF) == 0xFFFFFF; // white\n    }\n\n    public void takeDamage(int damage) {\n        this.health -= damage;\n\n    }\n\n    public boolean isDead() {\n        return health <= 0;\n    }\n\n    public boolean collidesWithPlayer(int playerX, int playerY) {\n        int playerSize = 40;\n\n        Rectangle zombieBounds = new Rectangle(x - size / 2, y - size / 2, size, size);\n        Rectangle playerBounds = new Rectangle(playerX - playerSize / 2, playerY - playerSize / 2, playerSize,\n                playerSize);\n\n        return zombieBounds.intersects(playerBounds);\n    }\n\n}\n",
      "Game.java": "\nimport javax.swing.SwingUtilities;\n\npublic class Game {\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> new GameWindow());\n    }\n}\n"
    },
    {
      "id": "5902250",
      "module-info.java": "/**\n * \n */\n/**\n * \n */\nmodule kino_der_toten {\n\trequires java.desktop;\n}",
      "Entity.java": "package entity;\n\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Entity \t{\n\tpublic int speed;\n\tpublic int maxLife, life;\n\tpublic int locationX, locationY; // Karakterimizin bulunduğu konum\n\tpublic BufferedImage up1, up2, down1, down2, left1, left2, right1, right2;\n\tpublic BufferedImage ul1, ul2, ur1, ur2, dl1, dl2, dr1, dr2; // up left, up right...\n\t\n\tpublic BufferedImage iup1, iup2, idown1, idown2, ileft1, ileft2, iright1, iright2;\n\tpublic BufferedImage iul1, iul2, iur1, iur2, idl1, idl2, idr1, idr2; // idle states' images\n\t\n\tpublic int direction = 4; // 0:up 1:ur 2:right 3:dr 4:down 5:dl 6:left 7:ul\n\t\n\tpublic int spriteCounter = 0;\n\tpublic boolean spriteState = true;\n\tpublic boolean moving = false;\n\t\n\tpublic Rectangle collisionArea; // Duvardan yürümeyi engelleyecek.\n\tpublic boolean collisionUp = false, collisionDown = false, collisionRight = false, collisionLeft = false;\n}\n",
      "Player.java": "package entity;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\nimport main.*;\n\npublic class Player extends Entity {\n\t\n\tGamePanel gp;\n\tKeyHandler kh;\n\t\n\tpublic int screenX, screenY; // Oyuncunun ekranda çizildiği konum.\n\t\n\tpublic Player(GamePanel gp, KeyHandler kh) {\n\t\tthis.gp = gp;\n\t\tthis.kh = kh;\n\t\tscreenX = gp.screenWidth/2 - gp.tileSize/2; // Oyuncu modelinin ekranın ortada olmasını sağlıyoruz. Kenarlara gidince kamera takibi bırakacak.\n\t\tscreenY = gp.screenHeight/2 - gp.tileSize/2;\n\t\tsetDefaultValues();\n\t\tgetPlayerImage();\n\t\tcollisionArea = new Rectangle();\n\t\tcollisionArea.x = 8;\n\t\tcollisionArea.y = 16;\n\t\tcollisionArea.width = 32;\n\t\tcollisionArea.height = 32;\n\t}\n\t\n\tprivate void setDefaultValues() {\n\t\tlocationX = gp.tileSize * 60; \n\t\tlocationY = gp.tileSize * 45;\n\t\tspeed = 4;\n\t}\n\t\n\tpublic void getPlayerImage() {\n\t\t\tBufferedImage[] upFrames = loadSprite(\"/player/Run_Up.png\");\n\t\t\tBufferedImage[] downFrames = loadSprite(\"/player/Run_Down.png\");\n\t\t\tBufferedImage[] leftFrames = loadSprite(\"/player/Run_Left.png\");\n\t\t\tBufferedImage[] rightFrames = loadSprite(\"/player/Run_Right.png\");\n\t\t\tBufferedImage[] urFrames = loadSprite(\"/player/Run_RightUp.png\");\n\t\t\tBufferedImage[] ulFrames = loadSprite(\"/player/Run_LeftUp.png\");\n\t\t\tBufferedImage[] drFrames = loadSprite(\"/player/Run_RightDown.png\");\n\t\t\tBufferedImage[] dlFrames = loadSprite(\"/player/Run_LeftDown.png\");\n\t\t\t\n\t\t\tBufferedImage[] iupFrames = loadSprite(\"/player/IdleBack.png\");\n\t\t\tBufferedImage[] idownFrames = loadSprite(\"/player/IdleFront.png\");\n\t\t\tBufferedImage[] ileftFrames = loadSprite(\"/player/IdleLeft.png\");\n\t\t\tBufferedImage[] irightFrames = loadSprite(\"/player/IdleRight.png\");\n\t\t\tBufferedImage[] iurFrames = loadSprite(\"/player/IdleRightBack.png\");\n\t\t\tBufferedImage[] iulFrames = loadSprite(\"/player/IdleLeftBack.png\");\n\t\t\tBufferedImage[] idrFrames = loadSprite(\"/player/IdleRightFront.png\");\n\t\t\tBufferedImage[] idlFrames = loadSprite(\"/player/IdleLeftFront.png\");\n\t\t\t\n\t\t\tup1 = upFrames[0];\n\t\t\tup2 = upFrames[1];\n\t\t\tdown1 = downFrames[0];\n\t\t\tdown2 = downFrames[1];\n\t\t\tleft1 = leftFrames[0];\n\t\t\tleft2 = leftFrames[1];\n\t\t\tright1 = rightFrames[0];\n\t\t\tright2 = rightFrames[1];\n\t\t\tur1 = urFrames[0];\n\t\t\tur2 = urFrames[1];\n\t\t\tul1 = ulFrames[0];\n\t\t\tul2 = ulFrames[1];\n\t\t\tdr1 = drFrames[0];\n\t\t\tdr2 = drFrames[1];\n\t\t\tdl1 = dlFrames[0];\n\t\t\tdl2 = dlFrames[1];\n\t\t\t\n\t\t\tiup1 = iupFrames[0];\n\t\t\tiup2 = iupFrames[1];\n\t\t\tidown1 = idownFrames[0];\n\t\t\tidown2 = idownFrames[1];\n\t\t\tileft1 = ileftFrames[0];\n\t\t\tileft2 = ileftFrames[1];\n\t\t\tiright1 = irightFrames[0];\n\t\t\tiright2 = irightFrames[1];\n\t\t\tiur1 = iurFrames[0];\n\t\t\tiur2 = iurFrames[1];\n\t\t\tiul1 = iulFrames[0];\n\t\t\tiul2 = iulFrames[1];\n\t\t\tidr1 = idrFrames[0];\n\t\t\tidr2 = idrFrames[1];\n\t\t\tidl1 = idlFrames[0];\n\t\t\tidl2 = idlFrames[1];\n\t}\n\t\n\tprivate BufferedImage[] loadSprite(String path) {\n\t    try {\n\t        BufferedImage spriteSheet = ImageIO.read(getClass().getResourceAsStream(path));\n\t        return new BufferedImage[]{\n\t            spriteSheet.getSubimage(0, 0, 16, 16),\n\t            spriteSheet.getSubimage(16, 0, 16, 16)\n\t        };\n\t    } catch (IOException e) {\n\t        e.printStackTrace();\n\t        return null;\n\t    }\n\t}\n\n\tpublic void update() {\n\t    int dx = 0, dy = 0;\n\t    if(kh.rightPressed || kh.leftPressed || kh.upPressed || kh.downPressed)  moving = true; else moving = false;\n\t    if(moving) {\n\t    if (kh.upPressed) direction = 0;  // Up\n\t    if (kh.downPressed) direction = 4;  // Down\n\t    if (kh.leftPressed) direction = 6;  // Left\n\t    if (kh.rightPressed) direction = 2;  // Right\n\t    // Çapraz gitme durumları\n\t    if (kh.upPressed && kh.rightPressed) direction = 1;    // UR\n\t    if (kh.downPressed && kh.rightPressed) direction = 3;  // DR\n\t    if (kh.downPressed && kh.leftPressed) direction = 5;   // DL\n\t    if (kh.upPressed && kh.leftPressed) direction = 7;     // UL\n\n\t    collisionUp = false;\n\t    collisionDown = false;\n\t    collisionLeft = false;\n\t    collisionRight = false;\n\t    gp.cc.checkTile(this);\n\t    // collisionOn hala false ise karakter yürüyebilir.\n\t    if(moving) {\n\t    \tif (kh.upPressed && kh.rightPressed && !collisionUp && !collisionRight) {\n\t    \t    dy -= 1;\n\t    \t    dx += 1;\n\t    \t}\n\t    \tif (kh.downPressed && kh.rightPressed && !collisionDown && !collisionRight) {\n\t    \t    dx += 1;\n\t    \t    dy += 1;\n\t    \t}\n\t    \tif (kh.downPressed && kh.leftPressed && !collisionDown && !collisionLeft) {\n\t    \t    dy += 1;\n\t    \t    dx -= 1;\n\t    \t}\n\t    \tif (kh.upPressed && kh.leftPressed && !collisionUp && !collisionLeft) {\n\t    \t    dx -= 1;\n\t    \t    dy -= 1;\n\t    \t}\n\t    \tif (kh.upPressed && !collisionUp) dy -= 1;\n\t    \tif (kh.downPressed && !collisionDown) dy += 1;\n\t    \tif (kh.leftPressed && !collisionLeft) dx -= 1;\n\t    \tif (kh.rightPressed && !collisionRight) dx += 1;\n\n\t\t    // Çaprazda kök 2 hızla gitmeyelim diye\n\t    \tdouble length = Math.sqrt(dx * dx + dy * dy);\n\t    \tif (length != 0) {\n\t    \t    dx = (int)((dx / length) * speed);\n\t    \t    dy = (int)((dy / length) * speed);\n\t    \t}\n\n\n\n\t\t    \n\t    \tlocationX += dx;\n\t    \tlocationY += dy;\n\t    }\n\t        spriteCounter++;\n\t        if (spriteCounter > 15) {\n\t            spriteState = !spriteState;\n\t            spriteCounter = 0; }\n\t        }\n\t}\n\tpublic void draw(Graphics2D g2) {\n\t    BufferedImage image = null;\n\t    if(moving) {\n\t    \tswitch(direction) {\n\t    \tcase 0: // Up\n\t    \t\timage = spriteState ? up1 : up2;\n\t    \t\tbreak;\n\t\t    case 1: // Up-Right\n\t\t        image = spriteState ? ur1 : ur2;\n\t\t        break;\n\t\t    case 2: // Right\n\t\t        image = spriteState ? right1 : right2;\n\t\t        break;\n\t\t    case 3: // Down-Right\n\t\t        image = spriteState ? dr1 : dr2;\n\t\t        break;\n\t\t    case 4: // Down\n\t\t        image = spriteState ? down1 : down2;\n\t\t        break;\n\t\t    case 5: // Down-Left\n\t\t        image = spriteState ? dl1 : dl2;\n\t\t        break;\n\t\t    case 6: // Left\n\t\t        image = spriteState ? left1 : left2;\n\t\t        break;\n\t\t    case 7: // Up-Left\n\t\t        image = spriteState ? ul1 : ul2;\n\t\t        break; // FIX THIS MOVING PART\n\t    \t}\n\t    } else {\n\t    \tswitch(direction) {\n\t    \tcase 0: // Up\n\t    \t\timage = spriteState ? iup1 : iup2;\n\t    \t\tbreak;\n\t\t    case 1: // Up-Right\n\t\t        image = spriteState ? iur1 : iur2;\n\t\t        break;\n\t\t    case 2: // Right\n\t\t        image = spriteState ? iright1 : iright2;\n\t\t        break;\n\t\t    case 3: // Down-Right\n\t\t        image = spriteState ? idr1 : idr2;\n\t\t        break;\n\t\t    case 4: // Down\n\t\t        image = spriteState ? idown1 : idown2;\n\t\t        break;\n\t\t    case 5: // Down-Left\n\t\t        image = spriteState ? idl1 : idl2;\n\t\t        break;\n\t\t    case 6: // Left\n\t\t        image = spriteState ? ileft1 : ileft2;\n\t\t        break;\n\t\t    case 7: // Up-Left\n\t\t        image = spriteState ? iul1 : iul2;\n\t\t        break;\n\t    \t}\n\t    }\n\t    \n\t // Define boundaries for the camera movement\n\t    int cameraX = locationX - screenX;\n\t    int cameraY = locationY - screenY;\n\n\t    // Clamp the camera so it doesn't reveal anything outside the map\n\t    if (cameraX < 0) cameraX = 0;\n\t    if (cameraY < 0) cameraY = 0;\n\t    if (cameraX > gp.worldWidth - gp.screenWidth) cameraX = (int)(gp.worldWidth - gp.screenWidth);\n\t    if (cameraY > gp.worldHeight - gp.screenHeight) cameraY = (int)(gp.worldHeight - gp.screenHeight);\n\n\t    // Define player's movement boundaries (prevents the player from leaving the map)\n\t    if (locationX < 0) locationX = 0;\n\t    if (locationY < 0) locationY = 0;\n\t    if (locationX > gp.worldWidth - gp.tileSize)  locationX = gp.worldWidth - gp.tileSize;\n\t    if (locationY > gp.worldHeight - gp.tileSize) locationY = gp.worldHeight - gp.tileSize;\n\t    \n\t    // Convert world coordinates to screen coordinates based on clamped camera position\n\t    screenX = gp.player.locationX - cameraX;\n\t    screenY = gp.player.locationY - cameraY;\n\n\t    // Draw the player\n\t    g2.drawImage(image, screenX, screenY, gp.tileSize, gp.tileSize, null);\n\n\t}\n}\n",
      "Main.java": "package main;\n\nimport javax.swing.JFrame;\n\npublic class Main {\n\t\n\t/*\n\t * Ödevde https://www.youtube.com/playlist?list=PL_QPQmz5C6WUF-pOQDsbsKbaBZqXj4qSq playlistinden bolca yardım aldım.\n\t * PDF'te de sonradan kodumu anlatacağım.\n\t*/\n\n\t\n\tpublic static void main(String[] args) {\n\t\tJFrame mainFrame = new JFrame(\"zombi oyunu\");\n\t\tmainFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tmainFrame.setResizable(false);\n\t\t\n\t\tGamePanel playPanel = new GamePanel();\n\t\tmainFrame.add(playPanel);\n\t\t\n\t\tmainFrame.pack();\n\t\tmainFrame.setLocationRelativeTo(null);\n\t\tplayPanel.startGameThread();\n\t\tmainFrame.setVisible(true);\n\t}\n}\n",
      "GamePanel.java": "package main;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\nimport javax.swing.JPanel;\n\nimport entity.Player;\nimport tile.TileManager;\n\npublic class GamePanel extends JPanel implements Runnable {\n\t\n\t// Temel Ekran Ayarları\n\t\n\t// Mermileri yarıçapı 1 olan dairelerle, roketatar mermilerini 3x2 modelle, bütün patlamaları da yarıçapı 24 pixel olacak şekilde modellemeyi düşünüyorum.\n\t// Oluşturacağımız modeller modern ekranlarda çok ufak kalacağından bütün modelleri 3 katına çıkaracağım.\n\tpublic final int scale = 3;\n\t\n\tfinal int base_tileSize = 16; // Zemin 16x16 sprite'lar ile yapılacak.\n\tfinal int base_bulletRadius = 1, base_rocketWidth = 3, base_rocketHeight = 2, base_explosionRadius = 24;\n\t// İnsan/Zombi karakterlerinin büyüklüğü tileSize'dan biraz daha küçük olsun\n\tfinal int base_humanWidth = 8, base_humanLength = 12;\n\t\n\tpublic final int tileSize  = base_tileSize * scale;\n\tfinal int bulletRadius = base_bulletRadius * scale;\n\tfinal int rocketWidth = base_rocketWidth * scale;\n\tfinal int rocketHeight = base_rocketHeight * scale;\n\tfinal int explosionRadius = base_explosionRadius * scale;\n\t//public final int humanWidth = base_humanWidth * scale;\n\t//public final int humanLength = base_humanLength * scale;\n\t// Ekranda gösterilecek maksimum satır-sütun tile sayıları. Bu değerler kullanılarak JPanel'imizin boyutlarını ayarlarız.\n\tpublic final int maxDispCol = 20, maxDispRow = 15;\n\tpublic final int screenWidth = maxDispCol * tileSize, screenHeight = maxDispRow * tileSize;\n\t\n\t//Map boyutu - değiştirilebilir olması ve farklı mapleri denemek için böyle yaptım.\n\tpublic final int maxWorldCol = 90;\n\tpublic final int maxWorldRow = 90;\n\tpublic final int worldWidth = tileSize * maxWorldCol;\n\tpublic final int worldHeight = tileSize * maxWorldRow;\n\t\n\t//FPS\n\tint FPS = 60;\n\t\n\tpublic TileManager tm = new TileManager(this);\n\tThread gameThread;\n\tKeyHandler kh = new KeyHandler();\n\tpublic CollisionChecker cc = new CollisionChecker(this);\n\t\n\tpublic Player player = new Player(this, kh);\n\t\n\tpublic GamePanel() {\n\t\tsetPreferredSize(new Dimension(screenWidth, screenHeight));\n\t\tsetBackground(Color.BLUE);\n\t\tsetDoubleBuffered(true);\n\t\taddKeyListener(kh);\n\t\tsetFocusable(true);\n\t}\n\n\tpublic void startGameThread() {\n\t\tgameThread = new Thread(this);\n\t\tgameThread.start();\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\t// FPS dahilinde güncelleme yapması için \"Delta\" metodunu kullandım\n\t\tdouble periyot = 1000000000/FPS;\n\t\tdouble delta = 0;\n\t\tlong lastTime = System.nanoTime();\n\t\tlong currentTime;\n\t\t\n\t\t// FPS'i göstermek için değişkenler\n\t\tlong timer = 0;\n\t\tint framesDrawn = 0;\n\t\t\n\t\twhile(gameThread != null) {\n\t\t\t\n\t\t\t\tcurrentTime = System.nanoTime();\n\t\t\t\tdelta += (currentTime - lastTime) / periyot;\n\t\t\t\ttimer += (currentTime - lastTime);\n\t\t\t\tlastTime = currentTime;\n\t\t\t\t\n\t\t\t\tif(delta >= 1) {\n\t\t\t\t\tupdate();\n\t\t\t\t\trepaint();\n\t\t\t\t\tdelta--;\n\t\t\t\t\tframesDrawn++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Alınan FPS'i konsola yazdır\n\t\t\t\tif(timer >= 1000000000) {\n\t\t\t\t\tif(framesDrawn < 55) System.out.println(\"low fps\");\n\t\t\t\t\tframesDrawn = 0;\n\t\t\t\t\ttimer = 0;\n\t\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic void update() {\n\t\t\n\t\tplayer.update(); // Temiz gözüksün diye Player class'ına taşıdım Player'in update() kısmını.\n\t}\n\n\t\n\tpublic void paintComponent(Graphics g) {\n\t\tsuper.paintComponent(g);\n\t\tGraphics2D g2 = (Graphics2D) g;\n\t\t\n\t\ttm.draw(g2);\n\t\t\n\t\tplayer.draw(g2); // Kod temiz gözüksün diye draw() methodları sınıflar içinde yapıldı.\n\t\t\n\t\tg2.dispose();\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "KeyHandler.java": "package main;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\npublic class KeyHandler implements KeyListener {\n\t\n\tpublic boolean upPressed, downPressed, leftPressed, rightPressed;\n\t\n\t@Override\n\tpublic void keyTyped(KeyEvent e) {}\n\n\t@Override\n\tpublic void keyPressed(KeyEvent e) {\n\t\t\n\t\tint code = e.getKeyCode();\n\t\t\n\t\tif(code == KeyEvent.VK_W) {\n\t\t\tupPressed = true;\n\t\t}\n\t\t\n\t\tif(code == KeyEvent.VK_S) {\n\t\t\tdownPressed = true;\n\t\t}\n\n\t\tif(code == KeyEvent.VK_A) {\n\t\t\tleftPressed = true;\n\t\t}\n\n\t\tif(code == KeyEvent.VK_D) {\n\t\t\trightPressed = true;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void keyReleased(KeyEvent e) {\n\n\t\tint code = e.getKeyCode();\n\t\t\n\t\tif(code == KeyEvent.VK_W) {\n\t\t\tupPressed = false;\n\t\t}\n\t\t\n\t\tif(code == KeyEvent.VK_S) {\n\t\t\tdownPressed = false;\n\t\t}\n\n\t\tif(code == KeyEvent.VK_A) {\n\t\t\tleftPressed = false;\n\t\t}\n\n\t\tif(code == KeyEvent.VK_D) {\n\t\t\trightPressed = false;\n\t\t}\n\t}\n\n}\n",
      "CollisionChecker.java": "package main;\n\nimport entity.Entity;\n\npublic class CollisionChecker {\n\t\n\tGamePanel gp;\n\t\n\tpublic CollisionChecker(GamePanel gp) {\n\t\tthis.gp = gp;\n\t}\n\t\n\tpublic void checkTile(Entity entity) { \n\t    int collisionAreaLeftX = entity.locationX + entity.collisionArea.x;\n\t    int collisionAreaRightX = entity.locationX + entity.collisionArea.x + entity.collisionArea.width;\n\t    int collisionAreaTopY = entity.locationY + entity.collisionArea.y;\n\t    int collisionAreaBottomY = entity.locationY + entity.collisionArea.y + entity.collisionArea.height;\n\n\t    int collisionAreaLeftCol = collisionAreaLeftX / gp.tileSize;\n\t    int collisionAreaRightCol = collisionAreaRightX / gp.tileSize;\n\t    int collisionAreaTopRow = collisionAreaTopY / gp.tileSize;\n\t    int collisionAreaBottomRow = collisionAreaBottomY / gp.tileSize;\n\n\t    // Reset collision flags before checking\n\t    entity.collisionUp = false;\n\t    entity.collisionDown = false;\n\t    entity.collisionLeft = false;\n\t    entity.collisionRight = false;\n\n\t    // Check UP\n\t    int tileNum1 = gp.tm.mapTileNum[collisionAreaLeftCol][(collisionAreaTopY - entity.speed) / gp.tileSize];\n\t    int tileNum2 = gp.tm.mapTileNum[collisionAreaRightCol][(collisionAreaTopY - entity.speed) / gp.tileSize];\n\t    if (!gp.tm.tiles[tileNum1].walkable || !gp.tm.tiles[tileNum2].walkable) {\n\t        entity.collisionUp = true;\n\t    }\n\n\t    // Check DOWN\n\t    tileNum1 = gp.tm.mapTileNum[collisionAreaLeftCol][(collisionAreaBottomY + entity.speed) / gp.tileSize];\n\t    tileNum2 = gp.tm.mapTileNum[collisionAreaRightCol][(collisionAreaBottomY + entity.speed) / gp.tileSize];\n\t    if (!gp.tm.tiles[tileNum1].walkable || !gp.tm.tiles[tileNum2].walkable) {\n\t        entity.collisionDown = true;\n\t    }\n\n\t    // Check LEFT\n\t    tileNum1 = gp.tm.mapTileNum[(collisionAreaLeftX - entity.speed) / gp.tileSize][collisionAreaTopRow];\n\t    tileNum2 = gp.tm.mapTileNum[(collisionAreaLeftX - entity.speed) / gp.tileSize][collisionAreaBottomRow];\n\t    if (!gp.tm.tiles[tileNum1].walkable || !gp.tm.tiles[tileNum2].walkable) {\n\t        entity.collisionLeft = true;\n\t    }\n\n\t    // Check RIGHT\n\t    tileNum1 = gp.tm.mapTileNum[(collisionAreaRightX + entity.speed) / gp.tileSize][collisionAreaTopRow];\n\t    tileNum2 = gp.tm.mapTileNum[(collisionAreaRightX + entity.speed) / gp.tileSize][collisionAreaBottomRow];\n\t    if (!gp.tm.tiles[tileNum1].walkable || !gp.tm.tiles[tileNum2].walkable) {\n\t        entity.collisionRight = true;\n\t    }\n\t}\n}\n",
      "Tile.java": "package tile;\n\nimport java.awt.image.BufferedImage;\n\npublic class Tile {\n\t// Bu sınıfta mekan elementlerini hazırlayacağız.\n\tpublic BufferedImage image;\n\tpublic boolean collision = false, walkable = true; // Çarpışmayı kontrol edecek. Duvarlardan ne mermi ne karakterler geçebilecek.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Fakat sudan mermi geçebilecek.\n}\n",
      "TileManager.java": "package tile;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\nimport javax.imageio.ImageIO;\n\nimport main.GamePanel;\n\npublic class TileManager {\n\t// Tile ile olan işleri yapsın.\n\t\n\tGamePanel gp;\n\tpublic Tile[] tiles;\n\tpublic int mapTileNum[][];\n\t\n\tpublic TileManager(GamePanel gp) {\n\t\t\n\t\tthis.gp = gp;\n\t\t\n\t\ttiles = new Tile[10];\n\t\tmapTileNum = new int[gp.maxWorldCol][gp.maxWorldRow];\n\t\tgetTileImage();\n\t\tloadMap();\n\t\t\n\t}\n\t\n\tpublic void getTileImage() {\n\t\ttry {\n\t\t\tBufferedImage AsinmisYer = ImageIO.read(getClass().getResourceAsStream(\"/tiles/AsinmisYer.png\")); //index = 0\n\t\t\tBufferedImage BeyazCicek = ImageIO.read(getClass().getResourceAsStream(\"/tiles/BeyazCicek.png\")); //index = 1...\n\t\t\tBufferedImage KanliYer = ImageIO.read(getClass().getResourceAsStream(\"/tiles/KanliYer.png\"));\n\t\t\tBufferedImage KirmiziCicek = ImageIO.read(getClass().getResourceAsStream(\"/tiles/KirmiziCicek.png\"));\n\t\t\tBufferedImage MezarTasi = ImageIO.read(getClass().getResourceAsStream(\"/tiles/MezarTasi.png\"));\n\t\t\tBufferedImage SagKenarDuvar = ImageIO.read(getClass().getResourceAsStream(\"/tiles/SagKenarDuvar.png\"));\n\t\t\tBufferedImage SolKenarDuvar = ImageIO.read(getClass().getResourceAsStream(\"/tiles/SolKenarDuvar.png\"));\n\t\t\tBufferedImage StandardYer = ImageIO.read(getClass().getResourceAsStream(\"/tiles/StandardYer.png\"));\n\t\t\tBufferedImage Su = ImageIO.read(getClass().getResourceAsStream(\"/tiles/Su.png\"));\n\t\t\tBufferedImage TekDuvar = ImageIO.read(getClass().getResourceAsStream(\"/tiles/TekDuvar.png\"));\n\t\t\t\n\t\t\ttiles[0] = new Tile();\n\t\t\ttiles[0].image = StandardYer;\n\t\t\t\n\t\t\ttiles[1] = new Tile();\n\t\t\ttiles[1].image = AsinmisYer;\n\t\t\t\n\t\t\ttiles[2] = new Tile();\n\t\t\ttiles[2].image = KanliYer;\n\t\t\t\n\t\t\ttiles[3] = new Tile();\n\t\t\ttiles[3].image = BeyazCicek;\n\t\t\t\n\t\t\ttiles[4] = new Tile();\n\t\t\ttiles[4].image = KirmiziCicek;\n\t\t\t\n\t\t\ttiles[5] = new Tile();\n\t\t\ttiles[5].image = Su;\n\t\t\ttiles[5].walkable = false;\n\t\t\t\n\t\t\ttiles[6] = new Tile();\n\t\t\ttiles[6].image = MezarTasi;\n\t\t\ttiles[6].walkable = false;\n\t\t\ttiles[6].collision = true;\n\t\t\t\n\t\t\ttiles[7] = new Tile();\n\t\t\ttiles[7].image = SagKenarDuvar;\n\t\t\ttiles[7].walkable = false;\n\t\t\ttiles[7].collision = true;\n\t\t\t\n\t\t\ttiles[8] = new Tile();\n\t\t\ttiles[8].image = SolKenarDuvar;\n\t\t\ttiles[8].walkable = false;\n\t\t\ttiles[8].collision = true;\n\t\t\t\n\t\t\ttiles[9] = new Tile();\n\t\t\ttiles[9].image = TekDuvar;\n\t\t\ttiles[9].walkable = false;\n\t\t\ttiles[9].collision = true;\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic void loadMap() {\n\t\ttry {\n\t\t\tInputStream is = getClass().getResourceAsStream(\"/map/zombie_shooter_formatted.txt\"); // Büyük bir dünya dosyası, 90x90 (90*16x90*16 piksel)\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(is));\n\t\t\t\n\t\t\tint col = 0, row = 0;\n\t\t\t\n\t\t\twhile(col < gp.maxWorldCol && row < gp.maxWorldRow) {\n\t\t\t\tString line = br.readLine();\n\t\t\t\twhile(col < gp.maxWorldCol) {\n\t\t\t\t\tString[] numbers = line.split(\" \");\n\t\t\t\t\tmapTileNum[col][row] = Integer.parseInt(numbers[col]);;\n\t\t\t\t\tcol++;\n\t\t\t\t}\n\t\t\t\tcol = 0;\n\t\t\t\trow++;\n\t\t\t}\n\t\t\t\n\t\t\tbr.close();\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic void draw(Graphics2D g2) {\n\t\tint worldCol = 0;\n\t\tint worldRow = 0;\n\t\twhile(worldCol < gp.maxWorldCol && worldRow < gp.maxWorldRow) {\n\t\t\t\n\t\t\tint tileNum = mapTileNum[worldCol][worldRow];\n\t\t\t\n\t\t\tint tileX = worldCol * gp.tileSize;\n\t\t\tint tileY = worldRow * gp.tileSize;\n\t\t\tint screenX = tileX - gp.player.locationX + gp.player.screenX;\n\t\t\tint screenY = tileY - gp.player.locationY + gp.player.screenY;\n\t\t\t\n\t\t\tif(tileX > gp.player.locationX - gp.player.screenX - gp.tileSize && \n\t\t\t   tileX < gp.player.locationX + gp.player.screenX + gp.tileSize && // Bu if bloğu, yalnızca ekranda gözükecek karelerin çizilmesini sağlayacak.\n\t\t\t   tileY > gp.player.locationY - gp.player.screenY - gp.tileSize && // Öbür türlü fps düşüyordu\n\t\t\t   tileY < gp.player.locationY + gp.player.screenY + gp.tileSize){\n\t\t\t\t\n\t\t\t\tg2.drawImage(tiles[tileNum].image, screenX, screenY, gp.tileSize, gp.tileSize, null);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tworldCol++;\n\t\t\t\n\t\t\tif(worldCol == gp.maxWorldCol) {\n\t\t\t\tworldCol = 0;\n\t\t\t\tworldRow++;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    {
      "id": "1280995",
      "Game.java": "import gameclasses.GameFrame;\nimport gameclasses.GameManager;\nimport gameclasses.GameThread;\nimport gamedata.scenes.*;\n\npublic class Game {\n    public static void main(String[] args){\n        GameManager.frame = new GameFrame();\n        // I tried to reference GameManager variables in class definitions bu that sometimes resulted in\n        // passing references while they were still null, breaking the whole thing. So it seems that the best\n        // approach is to only reference them only in methods, to have more control over what's going on.\n        GameFrame frame = GameManager.frame;\n        GameThread.setScene(new scenes1());\n        GameManager.runThreads();\n        // This panel is the main game screen. Everything is going to be printed on this.\n        frame.add(GameManager.panel);\n        frame.setVisible(true);\n    }\n}\n",
      "GameThread.java": "package gameclasses;\nimport javax.swing.JPanel;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\npublic class GameThread extends Thread {\n    // This is the screen that the graphics thread paints everything on.\n    public class GamePanel extends JPanel {\n\n        {\n            setBackground(Color.GRAY);\n        }\n\n        ArrayList<GameNode> copyNodes;\n        public void paintComponent(Graphics g) {\n            synchronized (GameManager.GameNodes) {\n                copyNodes = new ArrayList<GameNode>(GameManager.GameNodes);\n            }\n            Collections.sort(copyNodes, Comparator.comparingInt(node -> node.drawLayer));\n            super.paintComponent(g);\n            if (GameManager.cameraExists) {\n                for (GameNode node : copyNodes) {\n                    GameManager.gameCam.render(g, node);\n                }\n\n                for (GameNode node : copyNodes) {\n                    GameManager.gameCam.GUIRender(g, node);\n                }\n            }\n        }\n    }\n        // every setting the thread can work in.\n        static public enum ThreadType {\n        process,\n        physics,\n        graphics,\n    }\n\n    // defined in setScene because you can't draw without a scene.\n    ThreadType threadType = ThreadType.process;\n    {\n        GameManager.panel = new GamePanel();\n    }\n\n    public GameThread(ThreadType threadType) {\n        this.threadType = threadType;\n    }\n    public static void setScene(GameScene scene){\n        GameManager.GameNodes = scene.nodeList();\n    }\n\n    // updates the arrayList based on new node addition and removal calls during ends of the loops.\n    public static void ListUpdate() {\n        synchronized (GameManager.GameNodes) {\n            if (GameManager.isLocked()) {\n                GameManager.GameNodes.removeAll(GameManager.removeNodes);\n                GameManager.GameNodes.addAll(GameManager.addNodes);\n                GameManager.GameNodes.trimToSize();\n                GameManager.removeNodes = new ArrayList<GameNode>();\n                GameManager.addNodes = new ArrayList<GameNode>();\n                GameManager.updateCall = false;\n                \n            }\n        }\n    }\n    \n\n    @Override\n    public void run() {\n        long lastTime = System.nanoTime();\n        final long fpsInNano = 16_640_000;\n        while (true) {\n            long currentTime = System.nanoTime();\n            long deltaTime = currentTime - lastTime;\n            if (threadType == ThreadType.process) {\n                for (GameNode node : GameManager.GameNodes) {\n                    node.process();\n                }\n\n                while (GameManager.updateCall) {\n                    GameManager.threadLock = true;\n                    ListUpdate();\n                }\n                GameManager.threadLock = false;\n            }\n            else if (threadType == ThreadType.physics) {\n                if (deltaTime >= fpsInNano) {\n                    for (GameNode node : GameManager.GameNodes) {\n                        node.physicsProcess();\n                    }\n                    lastTime = currentTime;\n                    if (GameManager.threadLock) {\n                        GameManager.physicsLocked = true;\n                        while (GameManager.threadLock);\n                    }\n                    GameManager.physicsLocked = false;\n                }\n            }\n            else if (threadType == ThreadType.graphics) {\n                if (deltaTime >= fpsInNano) {\n                    GameManager.panel.repaint();\n\n                    if (GameManager.threadLock) {\n                        GameManager.graphicsLocked = true;\n                        while (GameManager.threadLock);\n                    }\n                    GameManager.graphicsLocked = false;\n                }\n            }\n            else {\n                try {\n                    sleep(1);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                } \n            }\n        }\n    }\n}\n",
      "GameFrame.java": "package gameclasses;\n\nimport java.awt.Color;\nimport javax.swing.JFrame;\n\npublic class GameFrame extends JFrame {\n\n    public GameFrame() {\n        super(\"tds game that sucks quite a lot\");\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setSize(GameManager.frameWidth, GameManager.frameHeight);\n        setBackground(Color.GRAY);\n        GameInput inputController = new GameInput();\n        addKeyListener(inputController);\n        addMouseMotionListener(inputController);\n        addMouseListener(inputController);\n    }\n}",
      "GameScene.java": "package gameclasses;\n\nimport java.util.ArrayList;\n\npublic abstract class GameScene {\n    //this'll refer to another \"subscene\" when needed. Which will allow you to use scenes as nodes.\n    // You have to define sceneNodes and childScenes in the constructor under classes you extend from this.\n    public GameScene(){};\n    public ArrayList<GameNode> childNodes = new ArrayList<GameNode>();\n\n    // if it's a node, add it and its childnodes.\n    // returns every node in the scene and the subscene in an array.\n    public ArrayList<GameNode> nodeList(){\n        ArrayList<GameNode> nodeList = new ArrayList<GameNode>();\n        for (GameNode node : childNodes) {\n            if (node.childNodes.size()!= 0) {\n                for (int i = 0; i < node.nodeList().size(); i++) {\n                    node.nodeList().get(i).parentNode = node;\n                    nodeList.add(node.nodeList().get(i));\n                }\n            }\n            node.parentNode = this;\n            nodeList.add(node);\n        }\n        return nodeList;\n    }\n}\n",
      "GameManager.java": "package gameclasses;\n\nimport java.util.ArrayList;\nimport gameclasses.GameThread.GamePanel;\nimport gameclasses.GameThread.ThreadType;\nimport gameclasses.defaultclass.Camera2D;\n\n// a class that stores static references to pretty much everything needed.\npublic class GameManager {\n        public static GameFrame frame; // static value so that it can be used by the camera.\n        public static GamePanel panel;\n        // the size of the actual frame.\n        public static int frameWidth = 1280;\n        public static int frameHeight = 720;\n        // used for camera rendering\n        public static int VirtualWidth = 1280;\n        public static int VirtualHeight = 720;\n        // Finds the game camera.\n        public static boolean cameraExists = false;\n        public static Camera2D gameCam;\n        // debugging tool.\n        public static boolean showShapes = false;\n\n        public static boolean isPaused = false;\n        public static int gameScore = 0; // game score.\n        // this is all the nodes the game will work with.\n        public static ArrayList<GameNode> GameNodes = new ArrayList<GameNode>();\n        public static ArrayList<GameNode> addNodes = new ArrayList<GameNode>();\n        public static ArrayList<GameNode> removeNodes = new ArrayList<GameNode>();\n        public static boolean updateCall = false; // calls for an update.\n        public static volatile boolean threadLock = false; // tries to lock the threads.\n        // becomes true when the threads are locked.\n        public static volatile boolean physicsLocked = false;\n        public static volatile boolean graphicsLocked = false;\n\n        private static boolean cameraExists() {\n                boolean doesIt = false;\n                for (GameNode camNode : GameNodes) {\n                        if (camNode instanceof Camera2D) {\n                            gameCam = (Camera2D) camNode;\n                            doesIt = true;\n                        }\n                }\n                return doesIt;\n        }\n\n        public static synchronized boolean isLocked() {\n                if (physicsLocked && graphicsLocked) return true;\n                else return false;\n        }\n\n        public static void updateAdd(GameNode node) {\n                addNodes.add(node);\n                updateCall = true;\n        }\n\n        public static void updateRemove(GameNode node) {\n                removeNodes.add(node);\n                updateCall = true;\n        }\n\n        public static GameNode getNode(Class<? extends GameNode> nodeClass) {\n                for (GameNode node : GameNodes) {\n                        if (node.getClass().equals(nodeClass)) {\n                                return node;\n                        }\n                }\n                return null;\n        }\n        \n        public static void runThreads() {\n                GameThread processThread = new GameThread(ThreadType.process);\n                GameThread physicsThread = new GameThread(ThreadType.physics);\n                GameThread graphicsThread = new GameThread(ThreadType.graphics);\n                cameraExists = cameraExists();\n                processThread.start();\n                physicsThread.start();\n                graphicsThread.start();\n        }\n}\n",
      "GameInput.java": "package gameclasses;\n\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseMotionListener;\nimport java.awt.geom.Point2D;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\n\npublic class GameInput implements KeyListener, MouseListener, MouseMotionListener {\n    // Basically you have to store the key bind, make a boolean for it and add it to the if cases below.\n    // Is it a little bothersome? Kind of. Do I care? No. I got like less than 2 weeks for this.\n\n    public static int Up = KeyEvent.VK_UP;\n    public static boolean isUp = false;\n    public static int Down = KeyEvent.VK_DOWN;\n    public static boolean isDown = false;\n    public static int Left = KeyEvent.VK_LEFT;\n    public static boolean isLeft = false;\n    public static int Right = KeyEvent.VK_RIGHT;\n    public static boolean isRight = false;\n    public static int Reload = KeyEvent.VK_R;\n    public static boolean isReload = false;\n    public static int Pause = KeyEvent.VK_P;\n    public static boolean isPause = false;\n    public static int WeaponSwitch = KeyEvent.VK_T;\n    public static boolean isWeaponSwitch = false;\n    public static int Fire = MouseEvent.BUTTON1;\n    public static boolean isFiring = false;\n    public static int LeftClick = MouseEvent.BUTTON1;\n    public static boolean isLeftClick = false;\n    public static boolean isMouseMoved = false;\n    public static Point2D cursorPosition = new Point2D.Double(0,0);\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int pressedKey = e.getKeyCode();\n        if (pressedKey == Up) {\n            isUp = true;\n        }\n        else if (pressedKey == Down) {\n            isDown = true;\n        }\n        else if (pressedKey == Left) {\n            isLeft = true;\n        }\n        else if (pressedKey == Right) {\n            isRight = true;\n        }\n        else if (pressedKey == Reload) {\n            isReload = true;\n        }\n        else if (pressedKey == Pause) {\n            isPause = true;\n        }\n        else if (pressedKey == WeaponSwitch) {\n            isWeaponSwitch = true;\n        }\n    }\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int releasedKey = e.getKeyCode();\n        if (releasedKey == Up) {\n            isUp = false;\n        }\n        else if (releasedKey == Down) {\n            isDown = false;\n        }\n        else if (releasedKey == Left) {\n            isLeft = false;\n        }\n        else if (releasedKey == Right) {\n            isRight = false;\n        }\n        else if (releasedKey == Reload) {\n            isReload = false;\n        }\n        else if (releasedKey == Pause) {\n            isPause = false;\n        }\n        else if (releasedKey == WeaponSwitch) {\n            isWeaponSwitch = false;\n        }\n    }\n\n    public static Point2D getRelativeMouse() {\n        double relativeX = getCursor().getX() - GameManager.frame.getWidth()/2;\n        double relativeY = getCursor().getY() - GameManager.frame.getHeight()/2;\n        return new Point2D.Double(relativeX, relativeY);\n    }\n\n    // This is to be able to use input booleans dynamically. Currently used for creating direction vectors out\n    // of booleans.\n    public static boolean getBool(boolean gameInBool) {\n        return gameInBool;\n    }\n    // Didn't really need this. Could be implemented when necessary.\n    @Override\n    public void keyTyped(KeyEvent e) {}\n\n    // for getting mouse input.\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        cursorPosition = new Point2D.Double(e.getX(), e.getY());\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        if (e.getButton() == Fire) {\n            isFiring = true;\n        }   \n        if (e.getButton() == LeftClick) {\n            isLeftClick = true;\n        }  \n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        if (e.getButton() == Fire) {\n            isFiring = false;\n        }\n        if (e.getButton() == LeftClick) {\n            isLeftClick = false;\n        }\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {}\n\n    @Override\n    public void mouseEntered(MouseEvent e) {}\n\n    @Override\n    public void mouseExited(MouseEvent e) {}\n\n    public static Point2D getCursor() {\n        return cursorPosition;\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        cursorPosition = new Point2D.Double(e.getX(), e.getY());\n    }\n}\n\n",
      "GameNode.java": "package gameclasses;\n\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\n\nimport gameclasses.defaultclass.Area2D;\nimport gameclasses.defaultclass.NodeAnim;\n\nimport java.lang.Math;\n\npublic abstract class GameNode extends GameScene {\n\n    public Point2D position = new Point2D.Double(0,0); // position on the game world.\n    protected double scale = 1; // sprite scale.\n    public boolean isVisible = true;\n    public ArrayList<NodeAnim> anims = new ArrayList<NodeAnim>(); // if the node needs a visual representation.\n    public int currentAnim = 0;\n    protected GameScene parentNode = null;\n    public int drawLayer = 0;\n    protected boolean GUIElement = false; // if this is set to be true, it'll be rendered on top, and independent from game position.\n    // custom Area2D class as collision. to set values, use the setShape method.\n    protected Area2D collisionShape = new Area2D(this); \n    protected Area2D hitboxShape = new Area2D(this);\n\n    public GameNode() {}; // for spawning nodes at (0,0).\n    public GameNode(double x, double y) {\n        position.setLocation(x,y);\n    }\n    public GameNode(GameNode node) {\n        parentNode = node;\n    }\n\n    // for dynamic access to these attributes.\n    public double spriteWidth() {\n        if (anims.size() != 0 && anims.get(0) != null) return anims.get(0).frame(0).getWidth();\n        else return 0;\n    }\n    public double spriteHeight() {\n        if (anims.size() != 0 && anims.get(0) != null) return anims.get(0).frame(0).getHeight();\n        else return 0;\n    }\n    public double getScale() {\n        return scale;\n    }\n\n    // below here are generic methods that can be used by anything that inherits this class.\n    public double moveToward(double target, double start, double amount) {\n        double delta = target - start;\n        if (Math.abs(delta) <= amount || delta == 0) {\n            return target;\n        }\n        double position = start + (Math.signum(delta) * Math.abs(amount));\n        return position;\n    }\n\n    public GameNode collidingWith() {\n        for (GameNode node : GameManager.GameNodes) {\n            // skip self check\n            if (!node.collExists() || !(node == this)) {\n                if (collisionShape.areaIntersecting(node.collisionShape)) {\n                    return node;\n                }\n            }\n        }\n        return null;\n    }\n\n    // this is for checking before spawning objects. It runs through addNodes.\n    public GameNode ghostCollidingWith() {\n        for (GameNode node : GameManager.addNodes) {\n            // skip self check\n            if (!node.collExists() || !(node == this)) {\n                if (collisionShape.areaIntersecting(node.collisionShape)) {\n                    return node;\n                }\n            }\n        }\n        return null;\n    }\n\n    public GameNode collidingWith(Class<? extends GameNode> class1) {\n        for (GameNode node : GameManager.GameNodes) {\n            // skip self check\n            if (!node.collExists() || !(node == this)) {\n                if (node.getClass().equals(class1) && collisionShape.areaIntersecting(node.collisionShape)) {\n                    return node;\n                }\n            }\n        }\n        return null;\n    }\n\n    public GameNode isHitting() {\n        for (GameNode node : GameManager.GameNodes) {\n            if (!node.hitboxExists() || !(node == this)) {\n                if (hitboxShape.areaIntersecting(node.hitboxShape)) {\n                    return node;\n                }\n            }\n        }\n        return null;\n    }\n\n    // this is for specifically checking if it's getting hit by a certain class.\n    public GameNode isHitting(Class<? extends GameNode> class1) {\n        for (GameNode node : GameManager.GameNodes) {\n            if (!node.hitboxExists() || !(node == this)) {\n                if (hitboxShape.areaIntersecting(node.hitboxShape) &&\n                    node.getClass().equals(class1) && hitboxShape.areaIntersecting(node.hitboxShape)) {\n                    return node;\n                }\n            }\n        }\n        return null;\n    }\n\n    public boolean collExists() {\n        if (collisionShape != null && collisionShape.areaShape != null) return true;\n        else return false;\n    }\n\n    public Area2D getCollision() {\n        return collisionShape;\n    }\n\n    public boolean hitboxExists() {\n        if (hitboxShape != null && hitboxShape.areaShape != null) return true;\n        else return false;\n    }\n\n    public Area2D getHitbox() {\n        return hitboxShape;\n    }\n\n    public synchronized void nodeAdd(GameNode node) {\n        GameManager.updateAdd(node);\n    }\n\n    public synchronized void nodeDispose(GameNode node) {\n        GameManager.updateRemove(node);\n    }\n\n    // this is where calculations unrelated to physics will be made. It runs as fast as possible.\n    public void process() {}\n    // this is where physics calculations that run in ticks will be handled.\n    public void physicsProcess() {}\n}\n",
      "Camera2D.java": "package gameclasses.defaultclass;\n\nimport gameclasses.GameThread.GamePanel;\nimport gameclasses.defaultclass.GUI.GUINode;\nimport gameclasses.defaultclass.GUI.TextNode;\nimport gameclasses.GameNode;\nimport java.awt.Graphics;\nimport gameclasses.GameManager;\nimport java.lang.Math;\nimport java.awt.Font;\n// this is a default node created from GameNode in order to process what's on the screen.\n// can also be used for process calculations just like the average node.\npublic class Camera2D extends GameNode {\n\n    // position is inherited.\n    // the inherited scale value is used as zoom.\n\n    public Camera2D() {\n        super();\n    }\n    public Camera2D(double x, double y) {\n        super(x, y);\n    }\n\n    public void render(Graphics g, GameNode node) {\n        GamePanel panel = GameManager.panel;\n        // Analytic geometry basically. The GameManager sizes are static, while \n        // the getWidth/Height commands return the dynamic value. \n        // (for panels, the sprite methods always return the dimensions of the image)\n        if (!(node instanceof GUINode)) {\n            int x = (int) Math.round((-position.getX() + node.position.getX() - (node.spriteWidth()*node.getScale())/2 + GameManager.VirtualWidth/2) \n            * panel.getWidth() * scale / GameManager.VirtualWidth);\n            int y = (int) Math.round((+position.getY() - node.position.getY() - (node.spriteHeight()*node.getScale())/2 + GameManager.VirtualHeight/2) \n            * panel.getHeight() * scale / GameManager.VirtualHeight);\n            int width = (int) Math.round(node.spriteWidth() * node.getScale() * scale * panel.getWidth() / GameManager.VirtualWidth);\n            int height = (int) Math.round(node.spriteHeight() * node.getScale() * scale * panel.getHeight() / GameManager.VirtualHeight);\n            boolean infield = true;\n            if ((x > panel.getWidth() || x + node.spriteWidth()*node.getScale() < 0) || (y > panel.getHeight() || y + node.spriteHeight()*node.getScale() < 0)) infield = false;\n            if (node.anims.size() != 0 && infield && node.isVisible) g.drawImage(node.anims.get(node.currentAnim).animatedFrame(), x, y, width, height, null);\n            \n            // draws collision shapes if there are any.\n            if (node.collExists() && GameManager.showShapes) {\n                int collisionX = (int) Math.round((-position.getX() + node.position.getX() + node.getCollision().areaShape.getX() - (node.getCollision().areaShape.getWidth()*node.getScale())/2 + GameManager.VirtualWidth/2) \n                * panel.getWidth() * scale / GameManager.VirtualWidth);\n                int collisionY = (int) Math.round((+position.getY() - node.position.getY() - node.getCollision().areaShape.getY() - (node.getCollision().areaShape.getHeight()*node.getScale())/2 + GameManager.VirtualHeight/2) \n                * panel.getHeight() * scale / GameManager.VirtualHeight);\n                int collisionWidth = (int) Math.round(node.getCollision().areaShape.getWidth() * node.getScale() * scale * panel.getWidth() / GameManager.VirtualWidth);\n                int collisionHeight = (int) Math.round(node.getCollision().areaShape.getHeight() * node.getScale() * scale * panel.getHeight() / GameManager.VirtualHeight);\n    \n                g.drawRect(collisionX, collisionY, collisionWidth, collisionHeight);\n            }\n    \n            // draws hitboxes if there are any.\n            if (node.hitboxExists() && GameManager.showShapes) {\n                int hitboxX = (int) Math.round((-position.getX() + node.position.getX() + node.getHitbox().areaShape.getX() - (node.getHitbox().areaShape.getWidth()*node.getScale())/2 + GameManager.VirtualWidth/2) \n                * panel.getWidth() * scale / GameManager.VirtualWidth);\n                int hitboxY = (int) Math.round((+position.getY() - node.position.getY() - node.getHitbox().areaShape.getY() - (node.getHitbox().areaShape.getHeight()*node.getScale())/2 + GameManager.VirtualHeight/2) \n                * panel.getHeight() * scale / GameManager.VirtualHeight);\n                int hitboxWidth = (int) Math.round(node.getHitbox().areaShape.getWidth() * node.getScale() * scale * panel.getWidth() / GameManager.VirtualWidth);\n                int hitboxHeight = (int) Math.round(node.getHitbox().areaShape.getHeight() * node.getScale() * scale * panel.getHeight() / GameManager.VirtualHeight);\n    \n                g.drawRect(hitboxX, hitboxY, hitboxWidth, hitboxHeight);\n            }\n        }\n    }\n\n    public void GUIRender(Graphics g, GameNode node) {\n        GamePanel panel = GameManager.panel;\n\n        if (node instanceof GUINode && node.isVisible) {\n            int x = (int) Math.round((node.position.getX() - (node.spriteWidth()*node.getScale())/2 + GameManager.VirtualWidth/2) \n            * panel.getWidth() / GameManager.VirtualWidth);\n            int y = (int) Math.round((-node.position.getY() - (node.spriteHeight()*node.getScale())/2 + GameManager.VirtualHeight/2) \n            * panel.getHeight() / GameManager.VirtualHeight);\n            int width = (int) Math.round(node.spriteWidth() * node.getScale() * panel.getWidth() / GameManager.VirtualWidth);\n            int height = (int) Math.round(node.spriteHeight() * node.getScale() * panel.getHeight() / GameManager.VirtualHeight);\n            if (node.anims.size() != 0) g.drawImage(node.anims.get(node.currentAnim).animatedFrame(), x, y, width, height, null);\n            if (node instanceof TextNode) {\n                TextNode nodeText = (TextNode) node;\n\n                if (nodeText.getFont() != null) {\n                    double frameArea = (double) GameManager.frame.getHeight() * GameManager.frame.getWidth();\n                    double virtualArea = (double) GameManager.VirtualWidth * GameManager.VirtualHeight;\n                    double scaleFactor = frameArea / virtualArea;\n                \n                    int fontSize = Math.max(1, (int) Math.round(nodeText.getFont().getSize() \n                                        * nodeText.getScale() * scaleFactor));\n                \n                    g.setFont(new Font(nodeText.getFont().getName(), nodeText.getFont().getStyle(), fontSize));\n                }\n                                \n                g.setColor(nodeText.getColor());\n                g.drawString(nodeText.getText(), (int) x, (int) y);\n            }             \n        }\n    }\n\n    public void followNode(GameNode node) {\n        Vector2D diff = new Vector2D(node.position.getX() - position.getX(),\n                                     node.position.getY() - position.getY());\n        Vector2D move = Vector2D.ZERO;\n        double distance = diff.length();\n        if (distance >= 50) {\n            move = diff.normalized().dot(8);\n        }\n        else if (distance >= 1) {\n            move = diff.normalized().dot(2);\n        }\n        position.setLocation(position.getX() + move.x, position.getY() + move.y);\n    }\n}",
      "Area2D.java": "package gameclasses.defaultclass;\n\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\n\nimport gameclasses.GameNode;\n\npublic class Area2D {\n    public Rectangle2D areaShape;\n    public GameNode node;\n\n    // We calculate it as if it is centered on the position variable.\n    // The margin values shift the position of the shape from the center.\n    public void setShape(double xMargin, double yMargin, double width, double height) {\n        areaShape = new Rectangle2D.Double(xMargin, yMargin, width, height);\n    }\n\n    public Area2D(GameNode node) {\n        this.node = node;\n    }\n    \n    public boolean exists() {\n        if (areaShape == null) return false;\n        else return true;\n    }\n\n    public boolean doesContain(Point2D point) {\n        if (exists()) {\n            double x = node.position.getX() + areaShape.getX();\n            double y = node.position.getY() + areaShape.getY();\n            double width = areaShape.getWidth() * node.getScale();\n            double height = areaShape.getHeight() * node.getScale();\n            \n            return point.getX() >= x - width/2 && point.getX() <= x + width/2 \n                && point.getY() >= - y - height/2 && point.getY() <=  - y + height/2;\n        }\n        else return false;\n    }\n\n    // does checks to see if the collision/hitboxes are intersecting. AABB collision.\n    public boolean areaIntersecting(Area2D other) {\n        if (exists() && other.exists()) {\n            double x = Math.round(node.position.getX() + areaShape.getX());\n            double y = Math.round(node.position.getY() + areaShape.getY());\n            double width = Math.round(areaShape.getWidth() * node.getScale());\n            double height = Math.round(areaShape.getHeight() * node.getScale());\n\n            double otherX = Math.round(other.node.position.getX() + other.areaShape.getX());\n            double otherY = Math.round(other.node.position.getY() + other.areaShape.getY());\n            double otherWidth = Math.round(other.areaShape.getWidth() * other.node.getScale());\n            double otherHeight = Math.round(other.areaShape.getHeight() * other.node.getScale());\n    \n            return x < otherX + otherWidth &&\n            x + width > otherX &&\n            y < otherY + otherHeight &&\n            y + height > otherY;\n        }\n        else return false;\n    }\n}\n",
      "NodeAnim.java": "package gameclasses.defaultclass;\n\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.util.Iterator;\nimport java.util.TimerTask;\nimport java.util.Timer;\nimport javax.imageio.ImageIO;\nimport javax.imageio.ImageReader;\nimport javax.imageio.metadata.IIOMetadata;\nimport javax.imageio.metadata.IIOMetadataNode;\nimport javax.imageio.stream.ImageInputStream;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.AffineTransformOp;\nimport java.lang.Math;\nimport org.w3c.dom.NodeList;\nimport java.awt.RenderingHints;\nimport java.awt.Graphics2D;\n\npublic class NodeAnim {\n    private BufferedImage[] animation;\n    private BufferedImage[] transformedAnim;\n    private int currentFrame = 0;\n    public int speed = 1; // when set to 1, every frame is visible for 0.1 seconds. When set to 0, it doesn't play.\n    public boolean flipX = false;\n    public boolean flipY = false;\n    private int length;\n    static Timer animTimer = new Timer();\n\n    public void runFrames() {\n        if (speed != 0) {\n            animTimer.scheduleAtFixedRate(new TimerTask() {\n                @Override\n                public void run() {\n                currentFrame = (currentFrame + 1) % length;\n                }\n            }, 0, 100/speed);\n        }\n    }\n\n    public NodeAnim(String filePath) {\n        File file = new File(filePath);\n        try (ImageInputStream stream = ImageIO.createImageInputStream(file)) {\n            Iterator<ImageReader> readers = ImageIO.getImageReaders(stream);\n            String fileFormat = readers.next().getFormatName();\n            if (fileFormat.equals(\"gif\")) {\n                try {\n                    animation = loadFrames(file);\n                    transformedAnim = animation.clone();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            else {\n                animation = new BufferedImage[1];\n                animation[0] = ImageIO.read(file);\n                length = 1;\n                transformedAnim = animation.clone();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        runFrames();\n    }\n\n    public NodeAnim(BufferedImage sheet, int tileSize) {\n        this.animation = splitSheet(sheet, tileSize);\n        speed = 0;\n    }\n\n    public BufferedImage frame(int index) {\n        return transformedAnim[index];\n    }\n    \n    public BufferedImage animatedFrame() {\n        return transformedAnim[currentFrame];\n    }\n\n    public void setCurrentFrame(int index) {\n        currentFrame = index;\n    }\n\n    public void transformAnim(boolean horizontal, boolean vertical, double radians) {\n        BufferedImage[] transformedAnimation = new BufferedImage[animation.length];\n            transformedAnimation = animation.clone();\n        for (int i = 0; i < animation.length; i++) {\n            transformedAnimation[i] = flip(transformedAnimation[i], horizontal, vertical);\n        }\n        if (radians != 0) {\n            for (int i = 0; i < animation.length; i++) {\n                transformedAnimation[i] = rotate(transformedAnimation[i], radians);\n            }\n        }\n        transformedAnim = transformedAnimation;\n    }\n\n    // uses affinetransform to flip the image if necessary.\n    public static BufferedImage flip(BufferedImage sprite, boolean horizontal, boolean vertical) {\n        AffineTransform transform = new AffineTransform();\n        int width = sprite.getWidth();\n        int height = sprite.getHeight();\n\n        if (horizontal) transform.scale(-1, 1); // Flip horizontally\n        if (vertical) transform.scale(1, -1); // Flip vertically\n\n        transform.translate(horizontal ? -width : 0, vertical ? -height : 0);\n        AffineTransformOp op = new AffineTransformOp(transform, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);\n        \n        return op.filter(sprite, null);\n    }\n\n    // uses affinetransform to rotate the image.\n    public static BufferedImage rotate(BufferedImage sprite, double radians) {\n        int width = sprite.getWidth();\n        int height = sprite.getHeight();\n    \n        double sin = Math.abs(Math.sin(radians));\n        double cos = Math.abs(Math.cos(radians));\n        int newWidth = (int) Math.ceil(width * cos + height * sin);\n        int newHeight = (int) Math.ceil(width * sin + height * cos);\n    \n        BufferedImage rotatedSprite = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2d = rotatedSprite.createGraphics();\n    \n        g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);\n    \n        AffineTransform transform = new AffineTransform();\n        transform.translate((newWidth - width) / 2.0, (newHeight - height) / 2.0);\n        transform.rotate(radians, width / 2.0, height / 2.0); // Rotate around center\n    \n        g2d.drawImage(sprite, transform, null);\n        g2d.dispose();\n    \n        return rotatedSprite;\n    }\n\n    //splits a gif file into an array.\n    private BufferedImage[] loadFrames(File file) throws Exception {\n        ImageInputStream stream = ImageIO.createImageInputStream(file);\n        Iterator<ImageReader> readers = ImageIO.getImageReadersByFormatName(\"gif\");\n        \n        if (!readers.hasNext()) throw new RuntimeException();\n        \n    ImageReader reader = readers.next();\n    reader.setInput(stream);\n\n    int numFrames = reader.getNumImages(true);\n    int width = reader.getWidth(0);\n    int height = reader.getHeight(0);\n\n    BufferedImage[] frames = new BufferedImage[numFrames];\n\n    for (int i = 0; i < numFrames; i++) {\n        BufferedImage rawFrame = reader.read(i); \n\n        // reads metadata to get the actual offset of the frame, if it's specified in the gif file.\n        IIOMetadata metadata = reader.getImageMetadata(i);\n        int xOffset = 0, yOffset = 0;\n\n        try {\n            String metaFormat = metadata.getNativeMetadataFormatName();\n            IIOMetadataNode root = (IIOMetadataNode) metadata.getAsTree(metaFormat);\n            NodeList imageDescriptor = root.getElementsByTagName(\"ImageDescriptor\");\n\n            if (imageDescriptor.getLength() > 0) {\n                IIOMetadataNode descriptor = (IIOMetadataNode) imageDescriptor.item(0);\n                xOffset = Integer.parseInt(descriptor.getAttribute(\"imageLeftPosition\"));\n                yOffset = Integer.parseInt(descriptor.getAttribute(\"imageTopPosition\"));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        BufferedImage fixedFrame = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2d = fixedFrame.createGraphics();\n        g2d.drawImage(rawFrame, xOffset, yOffset, null);\n        g2d.dispose();\n\n        frames[i] = fixedFrame;\n    }\n        length = numFrames;\n        return frames;\n    }\n\n    // takes subimages of each sprite sheet, and returns them as an array.\n    private static BufferedImage[] splitSheet(BufferedImage spriteSheet, int tileSize) {\n        int cols = spriteSheet.getWidth() / tileSize;\n        int rows = spriteSheet.getHeight() / tileSize;\n        BufferedImage[] frames = new BufferedImage[cols * rows];\n\n        for (int y = 0; y < rows; y++) {\n            for (int x = 0; x < cols; x++) {\n                frames[y * cols + x] = spriteSheet.getSubimage(x * tileSize, y * tileSize, tileSize, tileSize);\n            }\n        }\n        return frames;\n    }\n}\n\n\n",
      "Vector2D.java": "package gameclasses.defaultclass;\n\nimport java.lang.Math;\n\nimport gameclasses.GameInput;\n\npublic class Vector2D {\n    public double x = 0; // x direction.\n    public double y = 0; // y direction.\n\n    public static Vector2D ZERO = new Vector2D(0,0);\n\n    public Vector2D (double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n    // typically for control directions.\n    public Vector2D (boolean up, boolean down, boolean left, boolean right) {\n        x = - (GameInput.getBool(GameInput.isLeft) ? 1 : 0) + (GameInput.getBool(GameInput.isRight)  ? 1 : 0);\n        y = - (GameInput.getBool(GameInput.isDown) ? 1 : 0) + (GameInput.getBool(GameInput.isUp)  ? 1 : 0);\n    }\n\n    public double length() {\n        return Math.sqrt(x*x + y*y);\n    }\n\n    public Vector2D normalized() {\n        if (length() > 0) {\n            double newX = x/length();\n            double newY = y/length();\n            return new Vector2D(newX, newY);\n        }\n        else return Vector2D.ZERO; \n    }\n\n    public Vector2D dot(Vector2D vector) {\n        return new Vector2D(x * vector.x, y * vector.y);\n    }\n    public Vector2D dot(double a) {\n        return new Vector2D(x * a, y * a);\n    }\n\n    // move toward method for the vector class. Made just to make it easier to write controls.\n    public Vector2D moveToward(Vector2D vector, double amount) {\n        double dx = vector.x - x;\n        double dy = vector.y - y;\n        double delta = Math.sqrt(dx * dx + dy * dy);\n    \n        if (delta <= amount) {\n            return vector;\n        }\n        double newX = x + dx * (amount / delta);\n        double newY = y + dy * (amount / delta);\n        return new Vector2D(newX, newY);\n    }\n\n    // utilizes the standard rotation formulas to rotate the vector.\n    public Vector2D rotate(double radians) {\n        double newX = this.x * Math.cos(radians) - this.y * Math.sin(radians);\n        double newY = this.x * Math.sin(radians) + this.y * Math.cos(radians);\n        return new Vector2D(newX, newY);\n    }\n}\n",
      "GUINode.java": "package gameclasses.defaultclass.GUI;\n\nimport gameclasses.GameNode;\n\npublic abstract class GUINode extends GameNode {\n\n    public GUINode(double x, double y) {\n        super (x, y);\n        GUIElement = true;\n    }\n}\n",
      "TextNode.java": "package gameclasses.defaultclass.GUI;\nimport java.awt.Font;\nimport java.awt.Color;\n\npublic abstract class TextNode extends GUINode {\n    // create an anonymous class using this.\n    private String text; \n    private Font font;   \n    private Color color; \n\n    public TextNode(double x, double y) {\n        super(x, y);\n    }\n\n    public Color getColor() {\n        return color;\n    }\n\n    public Font getFont() {\n        return font;\n    }\n\n    public String getText() {\n        return text;\n    }\n\n    public void setColor(Color color) {\n        this.color = color;\n    }\n    \n    public void setFont(Font font) {\n        this.font = font;\n    }\n    \n    public void setText(String text) {\n        this.text = text;\n    }\n    \n    public void setScale(double scale) {\n        if (font != null) {\n            int newSize = (int) (font.getSize() * scale); // Scale the font size\n            this.font = new Font(font.getName(), font.getStyle(), newSize);\n        }\n    }\n}\n",
      "ButtonNode.java": "package gameclasses.defaultclass.GUI;\n\nimport java.awt.geom.Point2D;\n\nimport gameclasses.GameInput;\nimport gameclasses.GameManager;\nimport gameclasses.defaultclass.Area2D;\nimport gameclasses.defaultclass.NodeAnim;\n\npublic abstract class ButtonNode extends GUINode {\n    // use this for button hitboxes. We don't want to interact with game world nodes.\n    Area2D buttonArea = new Area2D(this);\n    \n    public ButtonNode(double x, double y, String filepath) {\n        super(x, y);\n        NodeAnim button1 = new NodeAnim(filepath);\n        anims.add(button1);\n        buttonArea.setShape(0, 0, button1.frame(0).getWidth(), button1.frame(0).getHeight());\n    }\n\n\n    public static boolean hasClicked = false;\n    @Override\n    public void process() {\n        double mousex = GameInput.getCursor().getX() - GameManager.frame.getWidth()/2; \n        double mousey = GameInput.getCursor().getY() - GameManager.frame.getHeight()/2;\n        Point2D mouseRelative = new Point2D.Double(mousex, mousey);\n        if (buttonArea.doesContain(mouseRelative) && GameInput.isLeftClick && !hasClicked) {\n            buttonFunc();\n            hasClicked = true;\n        }\n\n        if (!GameInput.isLeftClick) {\n            hasClicked = false;\n        }\n    }\n\n    public void buttonFunc() {}\n}\n",
      "GUI.java": "package gamedata.scenes;\n\nimport gameclasses.GameInput;\nimport gameclasses.GameManager;\nimport gameclasses.defaultclass.GUI.ButtonNode;\nimport gameclasses.defaultclass.GUI.GUINode;\nimport gameclasses.GameScene;\nimport gameclasses.GameThread;\nimport gameclasses.defaultclass.NodeAnim;\nimport gameclasses.defaultclass.GUI.TextNode;\nimport java.awt.Font;\nimport java.io.File;\nimport java.io.PrintWriter;\nimport java.awt.Color;\nimport gamedata.nodes.Player;\nimport gamedata.nodes.WaveManager;\nimport gamedata.nodes.Weapons;\nimport gamedata.nodes.weapons.bullets.Bullet;\nimport gamedata.nodes.weapons.gun.Pistol;\nimport java.util.Scanner;\n\npublic class GUI extends GameScene {\n\n    static GUINode PauseMenu = new GUINode(0, 0) {\n\n          ButtonNode newGame = new ButtonNode(0, 200, \"gamedata/images/menu/new.png\") {\n               {\n                    drawLayer = 1;\n                    isVisible = false;\n               }\n\n               public void process() {\n                    isVisible = GameManager.isPaused;\n                    super.process();\n               };\n\n               public void buttonFunc() {\n                    if (GameManager.isPaused) {\n                         GameThread.setScene(new scenes1());\n                         WaveManager.level = 0;\n                         WaveManager.zombieAmount = 0;\n                         WaveManager.isSpawning = true;\n                         Bullet.totalamount = 0;\n                         Weapons.rifleUnlocked = false;\n                         Weapons.rifleAdded = false;\n                         Weapons.shotgunUnlocked = false;\n                         Weapons.shotgunAdded = false;\n                         Weapons.sniperUnlocked = false;\n                         Weapons.sniperAdded = false;\n                         Weapons.rocketUnlocked = false;\n                         Weapons.rocketAdded = false;\n                         GameManager.gameScore = 0;\n                         GameManager.gameCam.position.setLocation(0, 0);\n                         GameManager.isPaused = false;\n                    }\n               };\n          };\n\n          ButtonNode save = new ButtonNode(0, 100, \"gamedata/images/menu/save.png\") {\n\n               File save = new File(\"save.sav\");\n\n               {\n                    drawLayer = 1;\n                    isVisible = false;\n               }\n \n               public void process() {\n                    isVisible = GameManager.isPaused;\n                    super.process();\n               };\n\n               public void buttonFunc() {\n                    if (GameManager.isPaused) {\n                         try {\n                              PrintWriter writer = new PrintWriter(save);\n                              writer.println(WaveManager.level);\n                              writer.println(Weapons.rifleUnlocked);\n                              writer.println(Weapons.shotgunUnlocked);\n                              writer.println(Weapons.sniperUnlocked);\n                              writer.println(Weapons.rocketUnlocked);\n                              writer.println(GameManager.gameScore);\n                              writer.println(((Player)GameManager.getNode(Player.class)).getHP());\n                              writer.close();\n                              GameManager.isPaused = false;\n                         } catch (Exception e) {\n                              e.printStackTrace();\n                              // failed to save!\n                         }\n                    }\n               };\n          };\n\n          ButtonNode load = new ButtonNode(0, 0, \"gamedata/images/menu/loadnt.png\") {\n\n               NodeAnim loadable = new NodeAnim(\"gamedata/images/menu/load.png\");\n               {\n                    anims.add(loadable);\n                    drawLayer = 1;\n                    isVisible = false;\n               }\n\n               File save = new File(\"save.sav\");\n \n               public void process() {\n                    isVisible = GameManager.isPaused;\n                    if (save.exists()) {\n                         currentAnim = 1;\n                         super.process();\n                    }\n                    else currentAnim = 0;\n               };\n\n               public void buttonFunc() {\n                    if (GameManager.isPaused) {\n                         try {\n                              GameThread.setScene(new scenes1());\n                              Scanner reader = new Scanner(save);\n                              WaveManager.level = Integer.parseInt(reader.nextLine());\n                              Weapons.rifleUnlocked = Boolean.parseBoolean(reader.nextLine());\n                              Weapons.shotgunUnlocked = Boolean.parseBoolean(reader.nextLine());\n                              Weapons.sniperUnlocked = Boolean.parseBoolean(reader.nextLine());\n                              Weapons.rocketUnlocked = Boolean.parseBoolean(reader.nextLine());\n                              GameManager.gameScore = Integer.parseInt(reader.nextLine());\n                              ((Player)GameManager.getNode(Player.class)).setHP(Integer.parseInt(reader.nextLine()));\n                              reader.close();\n                              WaveManager.zombieAmount = 0;\n                              WaveManager.isSpawning = true;\n                              Bullet.totalamount = 0;\n                              Weapons.rifleAdded = false;\n                              Weapons.shotgunAdded = false;\n                              Weapons.sniperAdded = false;\n                              Weapons.rocketAdded = false;\n                              GameManager.gameCam.position.setLocation(0, 0);\n                              GameManager.isPaused = false;\n                         } catch (Exception e) {\n                              e.printStackTrace();\n                              // failed to load!\n                         }\n                    }\n               };\n          };\n\n          ButtonNode quit = new ButtonNode(0, -100, \"gamedata/images/menu/quit.png\") {\n\n               {\n                    drawLayer = 1;\n                    isVisible = false;\n               }\n \n               public void process() {\n                    isVisible = GameManager.isPaused;\n                    super.process();\n               };\n\n               public void buttonFunc() {\n                    if (GameManager.isPaused) {\n                         System.exit(0);\n                    }\n               };\n          };\n          \n          NodeAnim tint = new NodeAnim(\"gamedata/images/menu/paused.png\");\n          {\n               isVisible = false;\n               anims.add(tint);\n               childNodes.add(newGame);\n               childNodes.add(save);\n               childNodes.add(load);\n               childNodes.add(quit);\n          }\n\n          boolean pauseTriggered = false; \n\n          public void process() {\n               isVisible = GameManager.isPaused;\n\n               if (GameInput.isPause && !pauseTriggered) { \n                  GameManager.isPaused = !GameManager.isPaused; \n                  pauseTriggered = true; \n               } \n              \n               if (!GameInput.isPause) { \n                  pauseTriggered = false;\n               }\n          }\n    };\n\n    TextNode Health = new TextNode(300, 300){\n       {\n            setFont(new Font(Font.SERIF, Font.PLAIN, 12));\n            setText(\"Health: 0\");\n            setColor(Color.WHITE);\n            scale = 5;\n       }\n       \n       public void physicsProcess() {\n          if (((Player) GameManager.getNode(Player.class)).getHP() > 0) setText(\"Health: \" + ((Player) GameManager.getNode(Player.class)).getHP());\n          else setText(\"Health: 0\");\n       };\n    };\n\n    TextNode Score = new TextNode(300, 250){\n        {\n             setFont(new Font(Font.SERIF, Font.PLAIN, 12));\n             setText(\"Score: 0\");\n             setColor(Color.WHITE);\n             scale = 5;\n        }\n        \n        public void physicsProcess() {\n             setText(\"Score: \" + GameManager.gameScore);\n        };\n    };\n\n    TextNode Weapon = new TextNode(-600, 300){\n        {\n             setFont(new Font(Font.SERIF, Font.PLAIN, 12));\n             setText(\"Current Weapon: 0\");\n             setColor(Color.WHITE);\n             scale = 5;\n        }\n        \n        public void physicsProcess() {\n             setText(\"Current Weapon: \" + ((Player) GameManager.getNode(Player.class)).getWeapons().getCurrentGun().name);\n        };\n    };\n    TextNode Bullets = new TextNode(-600, 250){\n        {\n             setFont(new Font(Font.SERIF, Font.PLAIN, 12));\n             setText(\"Bullets: 0\");\n             setColor(Color.WHITE);\n             scale = 5;\n        }\n        \n        public void physicsProcess() {\n             setText(\"Bullets: \" + ((Player) GameManager.getNode(Player.class)).getWeapons().getCurrentGun().getBulletsLeft());\n        };\n    };\n    TextNode Ammo = new TextNode(-600, 200){\n        {\n             setFont(new Font(Font.SERIF, Font.PLAIN, 12));\n             setText(\"Ammo: 0\");\n             setColor(Color.WHITE);\n             scale = 5;\n        }\n        \n        public void physicsProcess() {\n            if (((Player) GameManager.getNode(Player.class)).getWeapons().getCurrentGun() instanceof Pistol) {\n                setText(\"Ammo: ∞\");\n            }\n            else  setText(\"Ammo: \" + ((Player) GameManager.getNode(Player.class)).getWeapons().getCurrentGun().getMagazinesLeft());\n        };\n    };\n\n    TextNode unlockText = new TextNode(0, -200){\n     {\n          setFont(new Font(Font.SERIF, Font.PLAIN, 12));\n          setText(\"New weapon unlocked!\");\n          setColor(Color.WHITE);\n          scale = 4;\n          isVisible = false;\n     }\n     \n     int waitCooldown = 0;\n     boolean prevRifle = false, prevShotgun = false, prevSniper = false, prevRocket = false;\n     \n     public void physicsProcess() {\n         boolean newUnlock = (!prevRifle && Weapons.rifleUnlocked) ||\n                             (!prevShotgun && Weapons.shotgunUnlocked) ||\n                             (!prevSniper && Weapons.sniperUnlocked) ||\n                             (!prevRocket && Weapons.rocketUnlocked);\n         if (newUnlock) {\n             waitCooldown = 180;\n             isVisible = true; \n         }\n         if (waitCooldown > 0) { \n             waitCooldown--;\n             if (waitCooldown == 0) { \n                 isVisible = false;\n             }\n         }\n         prevRifle = Weapons.rifleUnlocked;\n         prevShotgun = Weapons.shotgunUnlocked;\n         prevSniper = Weapons.sniperUnlocked;\n         prevRocket = Weapons.rocketUnlocked;\n     }\n };\n\n    {\n        childNodes.add(PauseMenu);\n        childNodes.add(Health);\n        childNodes.add(Score);\n        childNodes.add(Weapon);\n        childNodes.add(Bullets);\n        childNodes.add(Ammo);\n        childNodes.add(unlockText);\n    }\n}\n",
      "scenes1.java": "package gamedata.scenes;\n\nimport gameclasses.GameNode;\nimport gameclasses.GameScene;\nimport gameclasses.defaultclass.Camera2D;\nimport gameclasses.defaultclass.NodeAnim;\nimport gamedata.nodes.Player;\nimport gamedata.nodes.WaveManager;\n\npublic class scenes1 extends GameScene {\n\n    public scenes1() {\n        GameNode map = new GameNode(0,0) {\n            NodeAnim map = new NodeAnim(\"gamedata/images/welp.png\");\n            {\n                drawLayer = -1;\n                anims.add(map);\n            }\n        };\n        GUI gui = new GUI();\n        childNodes.add(map);\n        childNodes.add(new Camera2D());\n        childNodes.add(new Player());\n        childNodes.addAll(gui.nodeList());\n        childNodes.add(new WaveManager());\n    }\n}\n",
      "WaveManager.java": "package gamedata.nodes;\n\nimport gameclasses.GameManager;\nimport gameclasses.GameNode;\nimport gamedata.nodes.enemies.zombie.AcidZombie;\nimport gamedata.nodes.enemies.zombie.CrawlingZombie;\nimport gamedata.nodes.enemies.zombie.NormalZombie;\nimport gamedata.nodes.enemies.zombie.TankZombie;\n\npublic class WaveManager extends GameNode {\n\n    public final int mapX = 1000;\n    public final int mapY = 1000;\n    public final int spawnMargin = 200;\n    public static int level = 0;\n    public static int zombieAmount = 0;\n    public static boolean isSpawning = true;\n\n    public WaveManager() {\n        super();\n    }\n\n    @Override\n    public void process() {\n        if (!GameManager.isPaused) {\n            spawn();\n            if (level == 2 && !Weapons.rifleAdded) {\n                Weapons.rifleUnlocked = true;\n            }\n            if (level == 4 && !Weapons.shotgunAdded) {\n                Weapons.shotgunUnlocked = true;\n            }\n            if (level == 6 && !Weapons.sniperAdded) {\n                Weapons.sniperUnlocked = true;\n            }\n            if (level == 8 && !Weapons.rocketAdded) {\n                Weapons.rocketUnlocked = true;\n            }\n        }\n    }\n\n    public void spawn() {\n        if (isSpawning && zombieAmount == 0) {\n            zombieAmount = 20 + level*5;\n            int acidAmount = 0, tankAmount = 0, crawlerAmount = 0, normalAmount = 0;\n            if (level >= 6) {\n                acidAmount = level*level/10;\n            }\n            if (level >= 4) {\n                tankAmount = level*level/5 - acidAmount;\n            }\n            if (level >= 2) {\n                crawlerAmount = level*level/3 - acidAmount - tankAmount;\n            }\n            normalAmount = zombieAmount - acidAmount - tankAmount - crawlerAmount;\n            while (normalAmount != 0) {\n                NormalZombie newNormal = new NormalZombie(Math.random()*mapX*2-mapX, Math.random()*mapY*2-mapY);\n                if (newNormal.ghostCollidingWith() == null && newNormal.collidingWith() == null\n                    && (newNormal.position.getX() >= spawnMargin || newNormal.position.getX() <= -spawnMargin) \n                    && (newNormal.position.getY() >= spawnMargin || newNormal.position.getY() <= -spawnMargin)) {\n                    nodeAdd(newNormal);\n                    normalAmount--;\n                }\n                else newNormal = null;\n            }\n            while (crawlerAmount != 0) {\n                CrawlingZombie newCrawling = new CrawlingZombie(Math.random()*mapX*2-mapX, Math.random()*mapY*2-mapY);\n                if (newCrawling.ghostCollidingWith() == null && newCrawling.collidingWith() == null\n                && (newCrawling.position.getX() >= spawnMargin || newCrawling.position.getX() <= -spawnMargin) \n                && (newCrawling.position.getY() >= spawnMargin || newCrawling.position.getY() <= -spawnMargin)) {\n                    nodeAdd(newCrawling);\n                    crawlerAmount--;\n                }\n                else newCrawling = null;\n            }\n            while (tankAmount != 0) {\n                TankZombie newTank = new TankZombie(Math.random()*mapX*2-mapX, Math.random()*mapY*2-mapY);\n                if (newTank.ghostCollidingWith() == null && newTank.collidingWith() == null\n                && (newTank.position.getX() >= spawnMargin || newTank.position.getX() <= -spawnMargin) \n                && (newTank.position.getY() >= spawnMargin || newTank.position.getY() <= -spawnMargin)) {\n                    nodeAdd(newTank);\n                    tankAmount--;\n                }\n                else newTank = null;\n            }\n            while (acidAmount != 0) {\n                AcidZombie newAcid = new AcidZombie(Math.random()*mapX*2-mapX, Math.random()*mapY*2-mapY);\n                if (newAcid.ghostCollidingWith() == null && newAcid.collidingWith() == null\n                && (newAcid.position.getX() >= spawnMargin || newAcid.position.getX() <= -spawnMargin) \n                && (newAcid.position.getY() >= spawnMargin || newAcid.position.getY() <= -spawnMargin)) {\n                    nodeAdd(newAcid);\n                    acidAmount--;\n                }\n                else newAcid = null;\n            }\n            isSpawning = false;\n        }\n        if (!isSpawning && zombieAmount == 0) {\n            isSpawning = true;\n            if (level != 16) level++;\n        }\n    }\n}\n",
      "Weapons.java": "package gamedata.nodes;\n\nimport java.util.ArrayList;\n\nimport gameclasses.GameManager;\nimport gameclasses.GameNode;\nimport gamedata.nodes.weapons.Gun;\nimport gamedata.nodes.weapons.gun.InfantryRifle;\nimport gamedata.nodes.weapons.gun.Pistol;\nimport gamedata.nodes.weapons.gun.RocketLauncher;\nimport gamedata.nodes.weapons.gun.Shotgun;\nimport gamedata.nodes.weapons.gun.SniperRifle;\n\npublic class Weapons extends Gun { // inventory class for the players weapons.\n    // will only be iterated through when changing weapons, so not in the game loop generally.\n    public ArrayList<Gun> weaponList = new ArrayList<Gun>();\n    private int currentIndex = 0;\n    Gun currentGun;\n\n    public InfantryRifle rifle = new InfantryRifle();\n    public static boolean rifleUnlocked = false;\n    public static boolean rifleAdded = false;\n    public Shotgun shotgun = new Shotgun();\n    public static boolean shotgunUnlocked = false;\n    public static boolean shotgunAdded = false;\n    public SniperRifle sniperRifle = new SniperRifle();\n    public static boolean sniperUnlocked = false;\n    public static boolean sniperAdded = false;\n    public RocketLauncher rocketLauncher = new RocketLauncher();\n    public static boolean rocketUnlocked = false;\n    public static boolean rocketAdded = false;\n\n    {\n        Pistol pistol = new Pistol();\n        //DebugRifle debug = new DebugRifle();\n        weaponList.add(pistol);\n        currentGun = weaponList.get(currentIndex);\n    }\n    \n    public Weapons() {\n        super();\n    }\n\n    public void swapWeapon(int index) {\n        if (weaponList.size() > 1) {\n            Gun temp = weaponList.get(index);\n            weaponList.set(index, currentGun);\n            currentGun = temp;\n            currentIndex = index;\n        }\n    }\n    \n    public Gun getCurrentGun() {\n        return currentGun;\n    }\n\n    public int getCurrentIndex() {\n        return currentIndex;\n    }\n\n    @Override\n    public void process() {\n        if (!GameManager.isPaused) {\n            currentGun.position.setLocation(((GameNode) parentNode).position);\n            if (!rifleAdded && rifleUnlocked) {\n                weaponList.add(rifle);\n                rifleAdded = true;\n            }\n            if (!shotgunAdded && shotgunUnlocked) {\n                weaponList.add(shotgun);\n                shotgunAdded = true;\n            }\n            if (!sniperAdded && sniperUnlocked) {\n                weaponList.add(sniperRifle);\n                sniperAdded = true;\n            }\n            if (!rocketAdded && rocketUnlocked) {\n                weaponList.add(rocketLauncher);\n                rocketAdded = true;\n            }\n        }\n        currentGun.process();\n    }\n    \n    @Override\n    public void physicsProcess() {\n        currentGun.physicsProcess();\n    }\n}\n",
      "Player.java": "package gamedata.nodes;\n\nimport gameclasses.GameInput;\nimport gameclasses.GameManager;\nimport gameclasses.GameNode;\nimport gameclasses.defaultclass.NodeAnim;\nimport gameclasses.defaultclass.Vector2D;\nimport gamedata.nodes.enemies.zombie.AcidZombie;\nimport gamedata.nodes.enemies.zombie.CrawlingZombie;\nimport gamedata.nodes.enemies.zombie.NormalZombie;\nimport gamedata.nodes.enemies.zombie.TankZombie;\nimport gamedata.nodes.weapons.bullets.Acid;\nimport gamedata.nodes.weapons.gun.drops.RifleDrop;\nimport gamedata.nodes.weapons.gun.drops.RocketDrop;\nimport gamedata.nodes.weapons.gun.drops.SniperDrop;\nimport gamedata.nodes.weapons.gun.drops.ShotgunDrop;\nimport gamedata.nodes.enemies.Zombie;\n\npublic class Player extends GameNode {\n    // Character health.\n    int HP = 100;\n    boolean isDead = false;\n    public static NodeAnim idle = new NodeAnim(\"gamedata/images/girl.gif\");\n    Weapons weapons = new Weapons();\n\n    {\n        try {\n            anims.add(idle);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        scale = 3;\n        drawLayer = 1;\n        collisionShape.setShape(0, -10, 20, 35);\n        hitboxShape.setShape(0, -10, 20, 35);\n        childNodes.add(weapons);\n    }\n\n    public Player(){\n        super();\n    }\n\n    public Player(int x, int y){\n        super(x,y);\n    }\n\n    boolean switchTriggered = false;\n    @Override\n    public void process() {\n        if (!isDead && !GameManager.isPaused) {\n            if (GameInput.isWeaponSwitch && !switchTriggered) {\n                weapons.swapWeapon((weapons.getCurrentIndex() + 1) % (weapons.weaponList.size()));\n                switchTriggered = true;\n            }\n    \n            if (!GameInput.isWeaponSwitch) {\n                switchTriggered = false;\n            }\n        }\n    }\n\n    public int getHP() {\n        return HP;\n    }\n\n    public void setHP(int value) {\n        HP = value;\n    }\n\n    public Weapons getWeapons() {\n        return weapons;\n    }\n\n    protected int damageCooldown = 0;\n    protected int cooldownLength = 60;\n    @Override\n    public void physicsProcess() {\n        if (!isDead && !GameManager.isPaused) {\n            Vector2D inputVector = new Vector2D(GameInput.isUp, GameInput.isDown,\n            GameInput.isLeft, GameInput.isRight).normalized();\n            Vector2D velocity = Vector2D.ZERO.moveToward(inputVector, 1).dot(8);\n            if (GameInput.getRelativeMouse().getX() < 0) {\n                anims.get(currentAnim).transformAnim(true, false, 0);\n                anims.get(currentAnim).speed = 1;\n            }\n            else if (GameInput.getRelativeMouse().getX() > 0) {\n                anims.get(currentAnim).transformAnim(false, false, 0);\n                anims.get(currentAnim).speed = 1;\n            }\n            if (velocity.x == 0 && velocity.y == 0) {\n                anims.get(currentAnim).setCurrentFrame(0);\n                anims.get(currentAnim).speed = 0;\n            }\n            position.setLocation(position.getX() + velocity.x, position.getY() + velocity.y);\n            GameManager.gameCam.followNode(this);\n\n            if (isHitting(Acid.class) != null) {\n                HP-=8;\n            }\n            GameNode normalDmg = isHitting(NormalZombie.class);\n            if (normalDmg != null && damageCooldown == 0) {\n                HP-=((Zombie) normalDmg).getDamage();\n                damageCooldown = cooldownLength;\n            }\n            GameNode crawlDmg = isHitting(CrawlingZombie.class);\n            if (crawlDmg != null && damageCooldown == 0) {\n                HP-=((Zombie) crawlDmg).getDamage();\n                damageCooldown = cooldownLength;\n            }\n            GameNode tankDmg = isHitting(TankZombie.class);\n            if (tankDmg != null && damageCooldown == 0) {\n                HP-=((Zombie) tankDmg).getDamage();\n                damageCooldown = cooldownLength;\n            }\n            GameNode AcidDmg = isHitting(AcidZombie.class);\n            if (AcidDmg != null && damageCooldown == 0) {\n                HP-=((Zombie) AcidDmg).getDamage();\n                damageCooldown = cooldownLength;\n            }\n\n            if (damageCooldown > 0) {\n                damageCooldown--;\n            }\n\n            if (collidingWith(RifleDrop.class) != null) {\n                weapons.rifle.addMagazine();\n            }\n            if (collidingWith(ShotgunDrop.class) != null) {\n                weapons.shotgun.addMagazine();\n            }\n            if (collidingWith(SniperDrop.class) != null) {\n                weapons.sniperRifle.addMagazine();\n            }\n            if (collidingWith(RocketDrop.class) != null) {\n                weapons.rocketLauncher.addMagazine();\n            }\n\n            if (HP <= 0) {\n                isDead = true;\n                nodeDispose(weapons);\n            }\n        }\n    }\n}\n",
      "AcidExplosion.java": "package gamedata.nodes.other;\n\nimport gameclasses.GameNode;\nimport gameclasses.defaultclass.NodeAnim;\n\npublic class AcidExplosion extends GameNode {\n\n    public static NodeAnim explode = new NodeAnim(\"gamedata/images/acidexplosion.gif\");\n    {\n        try {\n            anims.add(explode);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } \n        hitboxShape.setShape(0, 0, explode.frame(0).getWidth(), explode.frame(0).getHeight());\n        scale = 0.5;\n    }\n\n    public AcidExplosion(double x, double y) {\n        super(x, y);\n    }\n\n    @Override\n    public void process() {}\n\n    int counter = 100;\n    @Override\n    public void physicsProcess() {\n        counter--;\n        if(counter == 0) nodeDispose(this);\n    }\n}\n",
      "Explosion.java": "package gamedata.nodes.other;\n\nimport gameclasses.GameNode;\nimport gameclasses.defaultclass.NodeAnim;\n\npublic class Explosion extends GameNode {\n\n    public static NodeAnim explode = new NodeAnim(\"gamedata/images/explosion.gif\");\n    {\n        try {\n            anims.add(explode);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } \n        hitboxShape.setShape(0, 0, explode.frame(0).getWidth(), explode.frame(0).getHeight());\n        scale = 1;\n    }\n\n    public Explosion(double x, double y) {\n        super(x, y);\n    }\n\n    @Override\n    public void process() {}\n\n    int counter = 100;\n    @Override\n    public void physicsProcess() {\n        counter--;\n        if(counter == 0) nodeDispose(this);\n    }\n}\n",
      "Zombie.java": "package gamedata.nodes.enemies;\n\nimport gameclasses.GameManager;\nimport gameclasses.GameNode;\nimport gameclasses.defaultclass.Vector2D;\nimport gamedata.nodes.Player;\nimport gamedata.nodes.WaveManager;\nimport gamedata.nodes.Weapons;\nimport gamedata.nodes.other.Explosion;\nimport gamedata.nodes.weapons.bullets.Bullet;\nimport gamedata.nodes.weapons.bullets.Rocket;\nimport gamedata.nodes.weapons.bullets.SniperBullet;\nimport gamedata.nodes.weapons.gun.drops.RifleDrop;\nimport gamedata.nodes.weapons.gun.drops.RocketDrop;\nimport gamedata.nodes.weapons.gun.drops.ShotgunDrop;\nimport gamedata.nodes.weapons.gun.drops.SniperDrop;\n\nimport java.awt.geom.Point2D;\n\npublic abstract class Zombie extends GameNode {\n    public static GameNode playerRef;\n    {\n        drawLayer = 1;\n    }\n\n    protected enum Amount {\n        low, medium, high\n    }\n    public enum State {\n        idle, walk, attack, die\n    }\n\n    protected int health;\n    protected int damage;\n    protected double speed;\n    protected State state = State.idle;\n    protected int zombieScore = 20;\n\n    public Zombie() {\n        super();\n    }\n\n    public Zombie(double x, double y) {\n        super(x, y);\n    }\n    \n    public Zombie(double x, double y, Amount healthAmount, Amount speedAmount, Amount damageAmount) {\n        super(x, y);\n        switch (healthAmount) {\n            case low: health = 20; break;\n            case medium: health = 40; break;\n            case high: health = 80; break;\n        }\n        switch (speedAmount) {\n            case low: speed = 1.5; break;\n            case medium: speed = 3; break;\n            case high: speed = 4.5; break;\n        }\n        switch (damageAmount) {\n            case low: damage = 7; break;\n            case medium: damage = 16; break;\n            case high: damage = 25; break;\n        }\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    @Override\n    public void physicsProcess() {\n        if (!GameManager.isPaused) {\n            playerRef = GameManager.getNode(Player.class);\n            if (playerRef!= null) zombieState();\n        }\n    }\n\n    public void zombieState() {\n        takeDamage();   \n        switch (state) {\n            case idle: idle(); break;\n            case walk: walk(); break;\n            case attack: attack(); break;\n            case die: die(); break;\n        }\n    }\n\n    protected double playerMargin = 0.5;\n    public void idle() {\n        if (position.distance(playerRef.position) >= (playerRef.spriteWidth()*playerRef.getScale()/2)*playerMargin) {\n            state = State.walk;\n        }\n        else state = State.attack;\n    }\n\n    public void walk() {\n        if (position.distance(playerRef.position) <= (playerRef.spriteWidth()*playerRef.getScale()/2)*playerMargin) {\n            state = State.idle;\n        }\n        else {\n            Vector2D playerVector = new Vector2D(playerRef.position.getX() - position.getX(),\n            playerRef.position.getY() - position.getY()).normalized();\n            Vector2D velocity = Vector2D.ZERO.moveToward(playerVector, 1).normalized().dot(speed);\n            Point2D previousPosition = new Point2D.Double(position.getX(), position.getY());\n            position.setLocation(position.getX() + velocity.x, position.getY() + velocity.y);\n\n            if (collidingWith() instanceof Zombie) {\n            position = previousPosition;\n            }\n        }  \n    }\n\n    int attackCooldown = 120;\n    public void attack() {\n        if (position.distance(playerRef.position) >= (playerRef.spriteWidth()*playerRef.getScale()/2)*playerMargin) {\n            state = State.idle;\n        }\n        else {\n            if (attackCooldown == 120) {\n                attackCooldown--;\n            }\n            else if (attackCooldown <= 0) attackCooldown = 120;\n            else attackCooldown--;\n        }\n    }\n    public void die() {\n        nodeDispose(this);\n        WaveManager.zombieAmount--;\n        GameManager.gameScore+=zombieScore;\n        double dropRate = Math.random() * 100;\n        if (Weapons.rocketUnlocked && dropRate >= 90) {\n            nodeAdd(new RocketDrop(position.getX(), position.getY()));\n        }\n        else if (Weapons.sniperUnlocked && dropRate >= 75 && dropRate <= 95) {\n            nodeAdd(new SniperDrop(position.getX(), position.getY()));\n        }\n        else if (Weapons.shotgunUnlocked && dropRate >= 60 && dropRate <= 75) {\n            nodeAdd(new ShotgunDrop(position.getX(), position.getY()));\n        }  \n        else if (Weapons.rifleUnlocked && dropRate >= 45 && dropRate <= 60) {\n            nodeAdd(new RifleDrop(position.getX(), position.getY()));\n        }\n\n    }\n    public void takeDamage() {\n        if (health <= 0) {\n            state = State.die;\n            return;\n        }\n        if ((isHitting(Bullet.class)!= null || isHitting(Rocket.class) != null ||\n             isHitting(SniperBullet.class) != null || isHitting(Explosion.class)!= null) \n            && state != State.die) {\n            health = health - 15;\n        }\n    }\n}\n",
      "CrawlingZombie.java": "package gamedata.nodes.enemies.zombie;\n\nimport gameclasses.defaultclass.NodeAnim;\nimport gameclasses.defaultclass.Vector2D;\nimport gamedata.nodes.enemies.Zombie;\nimport java.awt.geom.Point2D;\n\npublic class CrawlingZombie extends Zombie {\n\n    public static NodeAnim idle = new NodeAnim(\"gamedata/images/crawlingzombie.gif\");\n\n    {\n        try {\n            anims.add(idle);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        scale = 0.2;\n        hitboxShape.setShape(-10, -5, 300, 500);\n        collisionShape.setShape(-10, -5, 300, 500);\n        zombieScore = 30;\n    }\n\n    public CrawlingZombie(double x, double y) {\n        super(x, y, Amount.low, Amount.high, Amount.medium);\n    }\n\n    @Override\n    public void physicsProcess() {super.physicsProcess();}\n\n    @Override\n    public void zombieState() {\n        takeDamage();   \n        switch (state) { \n            case idle: idle(); break;\n            case walk: walk(); break;\n            case attack: if (isLunging) {lunge(); break;} attack(); break;\n            case die: die(); break;\n        }\n    }\n\n    @Override\n    public void idle() {\n        if (position.distance(playerRef.position) >= (playerRef.spriteWidth()*playerRef.getScale()/2)*3) {\n            state = State.walk;\n        }\n        else state = State.attack;\n    }\n    @Override\n    public void walk() {\n        if (position.distance(playerRef.position) <= (playerRef.spriteWidth()*playerRef.getScale()/2)*3) {\n            state = State.idle;\n        }\n        else {\n            Vector2D playerVector = new Vector2D(playerRef.position.getX() - position.getX(),\n            playerRef.position.getY() - position.getY()).normalized();\n\n            Vector2D velocity = Vector2D.ZERO.moveToward(playerVector, 1).normalized().dot(speed);\n            Point2D previousPosition = new Point2D.Double(position.getX(), position.getY());\n            position.setLocation(position.getX() + velocity.x, position.getY() + velocity.y);\n\n            if (collidingWith() instanceof Zombie) {\n            position = previousPosition;\n            }\n        }  \n    }\n\n    int attackCooldown = 120;\n    boolean isLunging = false;\n    Point2D lastPosition = position;\n    @Override\n    public void attack() {\n        if (position.distance(playerRef.position) >= (playerRef.spriteWidth()*playerRef.getScale()/2)*3) {\n            state = State.idle;\n        }\n        else if (attackCooldown == 120) {\n            if (position.distance(playerRef.position) <= (playerRef.spriteWidth()*playerRef.getScale()/2)*3\n                && position.distance(playerRef.position) >= (playerRef.spriteWidth()*playerRef.getScale()/2)*playerMargin) {\n                lastPosition = new Point2D.Double(playerRef.position.getX(), playerRef.position.getY());\n                attackCooldown--;\n                isLunging = true;\n            }\n            else if (position.distance(playerRef.position) <= (playerRef.spriteWidth()*playerRef.getScale()/2)*playerMargin) {\n                attackCooldown--;\n            }\n        }\n        else if (attackCooldown <= 0) attackCooldown = 120;\n        else attackCooldown--; \n    }\n\n    public void lunge() {\n        double distance = position.distance(lastPosition);\n\n        if (distance <= 2) { \n            isLunging = false;\n            state = State.idle;\n            attackCooldown--;\n            return;\n        }\n        double step = Math.min(speed * 3, distance);\n\n        Vector2D jumpVector = new Vector2D(lastPosition.getX() - position.getX(),\n        lastPosition.getY() - position.getY()).normalized().dot(step);\n        Point2D previousPosition = new Point2D.Double(position.getX(), position.getY());\n        position.setLocation(position.getX() + jumpVector.x, position.getY() + jumpVector.y);\n\n        if (collidingWith() instanceof Zombie) {\n            position = previousPosition;\n            state = State.idle;\n            isLunging = false;\n            attackCooldown--;\n        }\n    }\n}",
      "AcidZombie.java": "package gamedata.nodes.enemies.zombie;\n\nimport gameclasses.GameManager;\nimport gameclasses.defaultclass.NodeAnim;\nimport gameclasses.defaultclass.Vector2D;\nimport gamedata.nodes.WaveManager;\nimport gamedata.nodes.Weapons;\nimport gamedata.nodes.enemies.Zombie;\nimport gamedata.nodes.other.AcidExplosion;\nimport gamedata.nodes.weapons.bullets.Acid;\nimport gamedata.nodes.weapons.gun.drops.RifleDrop;\nimport gamedata.nodes.weapons.gun.drops.RocketDrop;\nimport gamedata.nodes.weapons.gun.drops.ShotgunDrop;\nimport gamedata.nodes.weapons.gun.drops.SniperDrop;\n\nimport java.awt.geom.Point2D;\n\npublic class AcidZombie extends Zombie {\n\n    public static NodeAnim idle = new NodeAnim(\"gamedata/images/acidzombie.gif\");\n\n    {\n        try {\n            anims.add(idle);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        scale = 0.2;\n        hitboxShape.setShape(-10, -5, 300, 500);\n        collisionShape.setShape(-10, -5, 300, 500);\n        zombieScore = 50;\n    }\n\n    public AcidZombie(double x, double y) {\n        super(x, y, Amount.low, Amount.low, Amount.medium);\n    }\n    \n    @Override\n    public void physicsProcess() {super.physicsProcess();}\n\n    @Override\n    public void idle() {\n        if (position.distance(playerRef.position) >= (playerRef.spriteWidth()*playerRef.getScale()/2)*playerDistance) {\n            state = State.walk;\n        }\n        else state = State.attack;\n    }\n\n    double playerDistance = 6;\n    @Override\n    public void walk() {\n        if (position.distance(playerRef.position) <= (playerRef.spriteWidth()*playerRef.getScale()/2)*playerDistance) {\n            state = State.idle;\n        }\n        else {\n            Vector2D playerVector = new Vector2D(playerRef.position.getX() - position.getX(),\n            playerRef.position.getY() - position.getY()).normalized();\n\n            Vector2D velocity = Vector2D.ZERO.moveToward(playerVector, 1).normalized().dot(speed);\n            Point2D previousPosition = new Point2D.Double(position.getX(), position.getY());\n            position.setLocation(position.getX() + velocity.x, position.getY() + velocity.y);\n\n            if (collidingWith() instanceof Zombie) {\n            position = previousPosition;\n            }\n        }  \n    }\n\n    int attackCooldown = 120;\n    @Override\n    public void attack() {\n        if (position.distance(playerRef.position) >= (playerRef.spriteWidth()*playerRef.getScale()/2)*playerDistance) {\n            state = State.idle;\n        }\n        else {\n            if (attackCooldown == 120) {\n                nodeAdd(new Acid(position.getX(), position.getY(), playerRef));\n                attackCooldown--;\n            }\n            else if (attackCooldown <= 0) attackCooldown = 120;\n            else attackCooldown--;\n        }\n    }\n\n    @Override\n    public void die() {\n        nodeAdd(new AcidExplosion(position.getX(), position.getY()));\n        nodeDispose(this);\n        WaveManager.zombieAmount--;\n        GameManager.gameScore += zombieScore;\n        double dropRate = Math.random() * 100;\n\n        if (Weapons.rocketUnlocked && dropRate >= 90) {\n            nodeAdd(new RocketDrop(position.getX(), position.getY()));\n        }\n        else if (Weapons.sniperUnlocked && dropRate >= 75 && dropRate <= 95) {\n            nodeAdd(new SniperDrop(position.getX(), position.getY()));\n        }\n        else if (Weapons.shotgunUnlocked && dropRate >= 60 && dropRate <= 75) {\n            nodeAdd(new ShotgunDrop(position.getX(), position.getY()));\n        }  \n        else if (Weapons.rifleUnlocked && dropRate >= 45 && dropRate <= 60) {\n            nodeAdd(new RifleDrop(position.getX(), position.getY()));\n        }\n    }\n}",
      "NormalZombie.java": "package gamedata.nodes.enemies.zombie;\n\nimport gameclasses.defaultclass.NodeAnim;\nimport gamedata.nodes.enemies.Zombie;\n\npublic class NormalZombie extends Zombie {\n    // if you need to keep the order for which zombie this is, use id logic.\n    // use the static numerator from earlier, but this time equate it to a class variable too, \n    // so that it works as an id.\n    public static NodeAnim idle = new NodeAnim(\"gamedata/images/zombie.gif\");\n\n    {\n        try {\n            anims.add(idle);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        scale = 0.2;\n        hitboxShape.setShape(-10, -5, 300, 500);\n        collisionShape.setShape(-10, -5, 300, 500);\n    }\n\n    public NormalZombie(double x, double y) {\n        super(x, y, Amount.medium, Amount.low, Amount.medium);\n    }\n\n    @Override\n    public void physicsProcess() {super.physicsProcess();}\n}",
      "TankZombie.java": "package gamedata.nodes.enemies.zombie;\n\nimport gameclasses.defaultclass.NodeAnim;\nimport gamedata.nodes.enemies.Zombie;\n\npublic class TankZombie extends Zombie {\n    \n    public static NodeAnim idle = new NodeAnim(\"gamedata/images/tankzombie.gif\");\n\n    {\n        try {\n            anims.add(idle);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        scale = 0.4;\n        hitboxShape.setShape(-10, -5, 300, 500);\n        collisionShape.setShape(-10, -5, 300, 500);\n        zombieScore = 40;\n    }\n\n\n    public TankZombie(double x, double y) {\n        super(x, y, Amount.high, Amount.low, Amount.high);\n    }\n\n    @Override\n    public void physicsProcess() {super.physicsProcess();}\n}",
      "Gun.java": "package gamedata.nodes.weapons;\n\nimport gameclasses.GameInput;\nimport gameclasses.GameManager;\nimport gameclasses.GameNode;\nimport gamedata.nodes.weapons.bullets.Bullet;\n\npublic abstract class Gun extends GameNode {\n\n    public String name = \"gun\";\n    protected double fireSpeed; // bullets per sec\n    protected int magazine;\n    protected int bulletsLeft;\n    protected int magazinesLeft;\n    protected boolean reloadTriggered = false;\n    protected double recoilAngle = 0;\n\n    public double getFireSpeed() {\n        return fireSpeed;\n    }\n    public int getMagazine() {\n        return magazine;\n    }\n\n    public Gun() {\n        super();\n    }\n\n    public Gun (int magazine, double fireSpeed) {\n        this.fireSpeed = fireSpeed;\n        this.magazine = magazine;\n        bulletsLeft = magazine;\n    }\n\n    @Override\n    public void process() {\n        if (!GameManager.isPaused) {\n            if (GameInput.isReload && !reloadTriggered) {\n                reload();\n                reloadTriggered = true;  \n            }\n    \n            if (!GameInput.isReload) {\n                reloadTriggered = false;\n            }\n        }\n    }\n\n    protected int bulletCooldown = 0; // Counter for bullet cooldown\n    @Override\n    public void physicsProcess() {\n        if (!GameManager.isPaused) {\n            final int cooldownLength = (int) (60/fireSpeed);\n            if (GameInput.isFiring) {\n                if (bulletCooldown <= 0 && bulletsLeft > 0) {\n                    nodeAdd(new Bullet(position.getX(), position.getY(), recoilAngle/2, true));\n                    bulletsLeft--;\n                    bulletCooldown = cooldownLength;\n                }\n            }\n    \n            if (bulletCooldown > 0) {\n                bulletCooldown--;\n            }\n        }\n    }\n\n    public int getBulletsLeft() {\n        return bulletsLeft;\n    }\n\n    public int getMagazinesLeft() {\n        return magazinesLeft;\n    }\n\n    public void addMagazine() {\n        magazinesLeft++;\n    }\n\n    protected void reload() {\n        if (magazinesLeft > 0) {\n            bulletsLeft = magazine;\n            magazinesLeft--;\n        }\n    }\n}",
      "Bullet.java": "package gamedata.nodes.weapons.bullets;\n\nimport gameclasses.GameInput;\nimport gameclasses.GameManager;\nimport gameclasses.GameNode;\nimport gameclasses.defaultclass.NodeAnim;\nimport gameclasses.defaultclass.Vector2D;\nimport gamedata.nodes.enemies.zombie.CrawlingZombie;\nimport gamedata.nodes.enemies.zombie.NormalZombie;\nimport gamedata.nodes.enemies.zombie.TankZombie;\nimport gamedata.nodes.enemies.zombie.AcidZombie;\n\npublic class Bullet extends GameNode {\n    public static int totalamount = 0;\n    protected final int maxBullets = 60; // max amount of projectiles that can be on screen.\n    Vector2D direction = Vector2D.ZERO;\n    public static NodeAnim idle = new NodeAnim(\"gamedata/images/bullet.png\");\n    {\n        try {\n            anims.add(idle);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } \n        hitboxShape.setShape(0, 0, idle.animatedFrame().getWidth(), idle.animatedFrame().getWidth());\n        scale = 1;\n    }\n\n    public Bullet(){\n        super();\n        totalamount++;\n    }\n\n    public Bullet(double x, double y, double recoilRadians, boolean random) {\n        super(x,y);\n        double angle1 = recoilRadians;\n        if (recoilRadians != 0 && random) {\n            int sign = Math.random() < 0.5 ? -1 : 1;\n            angle1 = recoilRadians *  Math.random() * sign;\n        }\n        totalamount++;\n        double mousex = GameInput.getCursor().getX() - GameManager.frame.getWidth()/2;\n        double mousey = GameInput.getCursor().getY() - GameManager.frame.getHeight()/2;\n        direction = new Vector2D(mousex, mousey).rotate(angle1).normalized();\n    }\n\n    @Override\n    public void process() {}\n\n    final int speed = 24;\n    @Override\n    public void physicsProcess() {\n        if (!GameManager.isPaused) {\n            Vector2D velocity = direction.dot(speed);\n\n            if (totalamount >= maxBullets || isHitting(NormalZombie.class) != null ||\n                isHitting(CrawlingZombie.class) != null || isHitting(TankZombie.class)!= null ||\n                isHitting(AcidZombie.class) != null) {\n                totalamount--;\n                nodeDispose(this);\n            }\n            \n            position.setLocation(position.getX() + velocity.x, position.getY() - velocity.y);\n        }\n    }\n}\n",
      "Acid.java": "package gamedata.nodes.weapons.bullets;\n\nimport gameclasses.GameManager;\nimport gameclasses.GameNode;\nimport gameclasses.defaultclass.NodeAnim;\nimport gameclasses.defaultclass.Vector2D;\nimport gamedata.nodes.Player;\n\npublic class Acid extends GameNode {\n    Vector2D direction = Vector2D.ZERO;\n    public static NodeAnim idle = new NodeAnim(\"gamedata/images/acid.png\");\n    {\n        try {\n            anims.add(idle);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } \n        hitboxShape.setShape(0, 0, idle.animatedFrame().getWidth(), idle.animatedFrame().getWidth());\n        scale = 1;\n    }\n\n    public Acid(){\n        super();\n        Bullet.totalamount++;\n    }\n\n    // projectile thrown at node.\n    public Acid(double x, double y, GameNode node) {\n        super(x,y);\n        Bullet.totalamount++;\n        direction = new Vector2D(node.position.getX() - position.getX(),  - node.position.getY() + position.getY()).normalized();\n    }\n\n    @Override\n    public void process() {}\n\n    final int speed = 24;\n    @Override\n    public void physicsProcess() {\n        if (!GameManager.isPaused) {\n            Vector2D velocity = direction.dot(speed);\n            position.setLocation(position.getX() + velocity.x, position.getY() - velocity.y);\n    \n            if (Bullet.totalamount >= 60 || isHitting(Player.class) != null) {\n                Bullet.totalamount--;\n                nodeDispose(this);\n            }\n        }\n    }\n}\n",
      "SniperBullet.java": "package gamedata.nodes.weapons.bullets;\n\nimport gameclasses.GameManager;\nimport gameclasses.defaultclass.Vector2D;\n\npublic class SniperBullet extends Bullet {\n\n    public SniperBullet() {\n        super();\n    }\n\n    public SniperBullet(double x, double y) {\n        super(x, y, 0, false);\n    }\n\n    @Override\n    public void physicsProcess() {\n        if (!GameManager.isPaused) {\n            Vector2D velocity = direction.dot(speed);\n\n            if (totalamount >= maxBullets) {\n                totalamount--;\n                nodeDispose(this);\n            }\n            \n            position.setLocation(position.getX() + velocity.x, position.getY() - velocity.y);\n        }\n    }\n}\n",
      "Rocket.java": "package gamedata.nodes.weapons.bullets;\n\nimport gameclasses.GameManager;\nimport gameclasses.defaultclass.Vector2D;\nimport gamedata.nodes.enemies.zombie.AcidZombie;\nimport gamedata.nodes.enemies.zombie.CrawlingZombie;\nimport gamedata.nodes.enemies.zombie.NormalZombie;\nimport gamedata.nodes.enemies.zombie.TankZombie;\nimport gamedata.nodes.other.Explosion;\n\npublic class Rocket extends Bullet {\n\n    public Rocket() {\n        super();\n    }\n\n    public Rocket(double x, double y) {\n        super(x, y, 0, false);\n    }\n\n    @Override\n    public void physicsProcess() {\n        if (!GameManager.isPaused) {\n            Vector2D velocity = direction.dot(speed);\n\n            if (totalamount >= maxBullets  || isHitting(NormalZombie.class) != null ||\n                isHitting(CrawlingZombie.class) != null || isHitting(TankZombie.class)!= null ||\n                isHitting(AcidZombie.class) != null) {\n                totalamount--;\n                nodeAdd(new Explosion(position.getX(), position.getY()));\n                nodeDispose(this);\n            }\n            \n            position.setLocation(position.getX() + velocity.x, position.getY() - velocity.y);\n        }\n    }  \n}\n",
      "Shotgun.java": "package gamedata.nodes.weapons.gun;\nimport gameclasses.GameInput;\nimport gameclasses.GameManager;\nimport gamedata.nodes.weapons.Gun;\nimport gamedata.nodes.weapons.bullets.Bullet;\npublic class Shotgun extends Gun {\n    // The project manual says that the shotgun shoots 9 bullets in a 45 degrees range, each\n    // bullets velocity vector seperated 5 degrees apart. That isn't mathematically possible.\n    // if you split the 45 degrees range into 5 degree sections, you get 9 sections, BUT 10 lines.\n    // Therefore I'll split the 45 degree range into 8 sections instead.\n    public Shotgun() {\n        super(5, 1);\n        name = \"Shotgun\";\n    }\n\n    @Override\n    public void physicsProcess() {\n        if (!GameManager.isPaused) {\n            final int cooldownLength = (int) (60/fireSpeed);\n            if (GameInput.isFiring) {\n                if (super.bulletCooldown <= 0 && bulletsLeft > 0) {\n                    nodeAdd(new Bullet(position.getX(), position.getY(), Math.PI/8, false));\n                    nodeAdd(new Bullet(position.getX(), position.getY(), 3*Math.PI/32, false));\n                    nodeAdd(new Bullet(position.getX(), position.getY(), Math.PI/16, false));\n                    nodeAdd(new Bullet(position.getX(), position.getY(), Math.PI/32, false));\n                    nodeAdd(new Bullet(position.getX(), position.getY(), 0, false));\n                    nodeAdd(new Bullet(position.getX(), position.getY(), -Math.PI/32, false));\n                    nodeAdd(new Bullet(position.getX(), position.getY(), -Math.PI/16, false));\n                    nodeAdd(new Bullet(position.getX(), position.getY(), -3*Math.PI/32, false));\n                    nodeAdd(new Bullet(position.getX(), position.getY(), -Math.PI/8, false));\n                    bulletsLeft--;\n                    bulletCooldown = cooldownLength;\n                }\n            }\n    \n            if (GameInput.isReload && !reloadTriggered) {\n                reload();\n                reloadTriggered = true;  \n            }\n    \n            if (!GameInput.isReload) {\n                reloadTriggered = false;\n            }\n    \n            if (bulletCooldown > 0) {\n                bulletCooldown--;\n            }\n        }\n    }\n}",
      "InfantryRifle.java": "package gamedata.nodes.weapons.gun;\nimport gamedata.nodes.weapons.Gun;\npublic class InfantryRifle extends Gun {\n    public InfantryRifle() {\n        super(30, 5);\n        super.recoilAngle = Math.PI/6;\n        name = \"Infantry Rifle\";\n    }\n}",
      "SniperRifle.java": "package gamedata.nodes.weapons.gun;\n\nimport gameclasses.GameInput;\nimport gameclasses.GameManager;\nimport gamedata.nodes.weapons.Gun;\nimport gamedata.nodes.weapons.bullets.SniperBullet;\n\npublic class SniperRifle extends Gun {\n    \n    public SniperRifle(){\n        super(5, 0.5);\n        name = \"Sniper Rifle\";\n    }\n\n    public void physicsProcess() {\n        if (!GameManager.isPaused) {\n            final int cooldownLength = (int) (60/fireSpeed);\n            if (GameInput.isFiring) {\n                if (bulletCooldown <= 0 && bulletsLeft > 0) {\n                    nodeAdd(new SniperBullet(position.getX(), position.getY()));\n                    bulletsLeft--;\n                    bulletCooldown = cooldownLength;\n                }\n            }\n\n            if (GameInput.isReload && !reloadTriggered) {\n                reload();\n                reloadTriggered = true;  \n            }\n\n            if (!GameInput.isReload) {\n                reloadTriggered = false;\n            }\n\n            if (bulletCooldown > 0) {\n                bulletCooldown--;\n            }\n        }\n    }\n\n}",
      "DebugRifle.java": "package gamedata.nodes.weapons.gun;\nimport gamedata.nodes.weapons.Gun;\npublic class DebugRifle extends Gun {\n\n    public DebugRifle(){\n        super(3000000, 10);\n        name = \"debug rifle\";\n    }\n}",
      "Pistol.java": "package gamedata.nodes.weapons.gun;\nimport gamedata.nodes.weapons.Gun;\npublic class Pistol extends Gun {\n    public Pistol() {\n        super(12, 2);\n        name = \"Pistol\";\n    }\n\n    // makes it infinitely reload.\n    @Override\n    protected void reload() {\n        super.magazinesLeft++;\n        super.reload();\n    }\n}",
      "RocketLauncher.java": "package gamedata.nodes.weapons.gun;\n\nimport gameclasses.GameInput;\nimport gameclasses.GameManager;\nimport gamedata.nodes.weapons.Gun;\nimport gamedata.nodes.weapons.bullets.Rocket;\n\npublic class RocketLauncher extends Gun {\n\n    public RocketLauncher() {\n        super(1, (1.00/6.00));\n        name = \"Rocket Launcher\";\n    }\n\n    @Override\n    public void physicsProcess() {\n        if (!GameManager.isPaused) {\n            final int cooldownLength = (int) (60/fireSpeed);\n            if (GameInput.isFiring) {\n                if (bulletCooldown <= 0 && bulletsLeft > 0) {\n                    nodeAdd(new Rocket(position.getX(), position.getY()));\n                    bulletsLeft--;\n                    bulletCooldown = cooldownLength;\n                }\n            }\n    \n            if (GameInput.isReload && !reloadTriggered) {\n                reload();\n                reloadTriggered = true;  \n            }\n    \n            if (!GameInput.isReload) {\n                reloadTriggered = false;\n            }\n    \n            if (bulletCooldown > 0) {\n                bulletCooldown--;\n            }\n        }\n    }\n}",
      "RocketDrop.java": "package gamedata.nodes.weapons.gun.drops;\n\nimport gameclasses.defaultclass.NodeAnim;\n\npublic class RocketDrop extends Drop {\n    \n    public static NodeAnim dropSprite = new NodeAnim(\"gamedata/images/rocketdrop.png\");\n\n    {\n        try {\n            anims.add(dropSprite);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        collisionShape.setShape(0, 0, dropSprite.frame(0).getWidth(), dropSprite.frame(0).getHeight());\n    }\n\n    public RocketDrop(double x, double y) {\n        super(x,y);\n    }\n}\n",
      "SniperDrop.java": "package gamedata.nodes.weapons.gun.drops;\n\nimport gameclasses.defaultclass.NodeAnim;\n\npublic class SniperDrop extends Drop {\n    \n    public static NodeAnim dropSprite = new NodeAnim(\"gamedata/images/sniperdrop.png\");\n\n    {\n        try {\n            anims.add(dropSprite);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        collisionShape.setShape(0, 0, dropSprite.frame(0).getWidth(), dropSprite.frame(0).getHeight());\n    }\n\n    public SniperDrop(double x, double y) {\n        super(x,y);\n    }\n}\n",
      "Drop.java": "package gamedata.nodes.weapons.gun.drops;\n\nimport gameclasses.GameManager;\nimport gameclasses.GameNode;\nimport gamedata.nodes.Player;\n\npublic class Drop extends GameNode {\n    \n        public Drop(double x, double y) {\n        super(x,y);\n    }\n\n    int dropWait = 600;\n    @Override\n    public void physicsProcess() {\n        if (!GameManager.isPaused) {\n            if (dropWait <= 0 || collidingWith(Player.class)!= null) nodeDispose(this);\n            dropWait--;\n        }\n    }\n}\n",
      "RifleDrop.java": "package gamedata.nodes.weapons.gun.drops;\n\nimport gameclasses.defaultclass.NodeAnim;\n\npublic class RifleDrop extends Drop {\n    \n    public static NodeAnim dropSprite = new NodeAnim(\"gamedata/images/rifledrop.png\");\n\n    {\n        try {\n            anims.add(dropSprite);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        collisionShape.setShape(0, 0, dropSprite.frame(0).getWidth(), dropSprite.frame(0).getHeight());\n    }\n\n    public RifleDrop(double x, double y) {\n        super(x,y);\n    }\n}\n",
      "ShotgunDrop.java": "package gamedata.nodes.weapons.gun.drops;\n\nimport gameclasses.defaultclass.NodeAnim;\n\npublic class ShotgunDrop extends Drop {\n    \n    public static NodeAnim dropSprite = new NodeAnim(\"gamedata/images/shotgundrop.png\");\n\n    {\n        try {\n            anims.add(dropSprite);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        collisionShape.setShape(0, 0, dropSprite.frame(0).getWidth(), dropSprite.frame(0).getHeight());\n    }\n\n    public ShotgunDrop(double x, double y) {\n        super(x,y);\n    }\n}\n"
    },
    {
      "id": "8857652",
      "Sniper.java": "import java.awt.Color;\nimport java.awt.Graphics;\n\npublic class Sniper extends Weapon {\n    public Sniper() {\n        super(WeaponType.SNIPER);\n    }\n    \n    @Override\n    public void fire(int x, int y, int mx, int my, Handler handler) {\n        if (!canFire()) return;\n        \n        lastFiredTime = System.currentTimeMillis();\n        currentAmmo--;\n        \n      \n        Bullet bullet = new Bullet(x + 16, y + 16, ID.Bullet, handler, mx, my);\n        //bullet.setPiercing(true); //delici mermi\n        //bullet.setDamage(50); // bol hasar\n        handler.addObject(bullet);\n    }\n    \n    @Override\n    public void render(Graphics g, int x, int y) {\n        g.setColor(Color.WHITE);\n        g.drawString(\"Sniper: \" + currentAmmo + \"/\" + totalAmmo, x, y);\n        if (isReloading) {\n            g.drawString(\"Reloading...\", x, y + 15);\n        }\n    }\n}",
      "AcidSpit.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class AcidSpit extends GameObject {\n    private Handler handler;\n    private int lifetime = 120; // 2 s\n    \n    public AcidSpit(int x, int y, int targetX, int targetY, Handler handler) {\n        super(x, y, ID.Effect);\n        this.handler = handler;\n        \n        \n        float dx = targetX - x;\n        float dy = targetY - y;\n        float distance = (float)Math.sqrt(dx*dx + dy*dy);\n        \n        velX = (dx/distance) * 4;\n        velY = (dy/distance) * 4;\n    }\n    \n    @Override\n    public void tick() {\n        x += velX;\n        y += velY;\n        \n        lifetime--;\n        if (lifetime <= 0) {\n            handler.removeObject(this);\n            return;\n        }\n        \n        // collusion\n        for (GameObject obj : handler.object) {\n            if (obj.getID() == ID.Player && getBounds().intersects(obj.getBounds())) {\n                ((Player)obj).takeDamage(15);\n                handler.removeObject(this);\n                return;\n            }\n        }\n    }\n    \n    @Override\n    public void render(Graphics g) {\n        g.setColor(new Color(100, 255, 100, 200));\n        g.fillOval(x-4, y-4, 8, 8);\n    }\n    \n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x-4, y-4, 8, 8);\n    }\n}",
      "AcidZombie.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class AcidZombie extends Enemy {\n    Handler handler;\n    private int acidCooldown = 0;\n    \n    public AcidZombie(int x, int y, Handler handler, Game game) {\n        super(x, y, ID.Enemy, handler, game, ZombieType.ACID);\n    }\n\n    @Override\n    public void tick() {\n        super.tick();\n        if (acidCooldown > 0) {\n            acidCooldown--;\n        } else {\n            GameObject player = findPlayer();\n            if (player != null && getDistance(player) < 200) {\n                spitAcid(player);\n                acidCooldown = 180;\n            }\n        }\n    }\n\n    private void spitAcid(GameObject target) {\n        handler.addObject(new AcidSpit(x+16, y+16, target.getX()+16, target.getY()+16, handler));\n    }\n\n    //@Override\n    protected void onDeath() {\n        handler.addObject(new AcidPool(x, y, handler));\n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(new Color(50, 200, 50));\n        g.fillOval(x, y, 32, 32);\n        \n        // hp bar eklendi\n        g.setColor(Color.RED);\n        g.fillRect(x, y-10, 32, 5);\n        g.setColor(Color.GREEN);\n        g.fillRect(x, y-10, (int)(32 * ((double)hp/zombieType.maxHealth)), 5);\n    }\n\n    private GameObject findPlayer() {\n        for (GameObject obj : handler.object) {\n            if (obj.getID() == ID.Player) return obj;\n        }\n        return null;\n    }\n\n    public float getDistance(GameObject obj) {\n            return (float)Math.sqrt(Math.pow(obj.getX()-x, 2) + Math.pow(obj.getY()-y, 2));\n        }\n}",
      "Audio.java": "import java.io.File;\nimport java.io.IOException;\n\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport javax.sound.sampled.LineUnavailableException;\nimport javax.sound.sampled.UnsupportedAudioFileException;\n\npublic class Audio {\n\n\tprivate File file;\n\tprivate Clip clip;\n\n\tpublic Audio(String path) {\n\t\tthis.file = new File(path);\n\t}\n\n\tpublic void play() {\n\t\ttry {\n\t\t\tclip = AudioSystem.getClip();\n\n\t\t\tclip.open(AudioSystem.getAudioInputStream(file));\n\t\t\tclip.start();\n\t\t\t\n\t\t} catch (LineUnavailableException | IOException | UnsupportedAudioFileException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} \n\t\t\n\t}\n\t\n\tpublic void stop() {\n\t\tclip.stop();\n\t}\n}",
      "Weapon.java": "import java.awt.Graphics;\nimport java.util.Random;\n\npublic abstract class Weapon {\n    protected WeaponType type;\n    protected int currentAmmo;\n    protected int totalAmmo;\n    protected long lastFiredTime;\n    protected boolean isReloading;\n    protected long reloadStartTime;\n    protected Random random = new Random();\n    \n    public Weapon(WeaponType type) {\n        this.type = type;\n        this.currentAmmo = type.magazineSize;\n        this.totalAmmo = type.maxAmmo;\n    }\n    \n    public abstract void fire(int x, int y, int mx, int my, Handler handler);\n    public abstract void render(Graphics g, int x, int y);\n    \n    public void reload() {\n        if (isReloading || totalAmmo <= 0 || currentAmmo == type.magazineSize) {\n            return;\n        }\n        \n        isReloading = true;\n        reloadStartTime = System.currentTimeMillis();\n        \n        new Thread(() -> {\n            try {\n                Thread.sleep(2000);\n                int ammoNeeded = type.magazineSize - currentAmmo;\n                int ammoToAdd = Math.min(ammoNeeded, totalAmmo);\n                \n                currentAmmo += ammoToAdd;\n                totalAmmo -= ammoToAdd;\n                isReloading = false;\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n    \n    public boolean canFire() {\n        if (isReloading) return false;\n        \n        long currentTime = System.currentTimeMillis();\n        long fireDelay = 60000 / type.fireRate;\n        \n        return currentAmmo > 0 && (currentTime - lastFiredTime) >= fireDelay;\n    }\n    \n    public void addAmmo(int amount) {\n        totalAmmo = Math.min(totalAmmo + amount, type.maxAmmo);\n    }\n    \n    public WeaponType getType() { return type; }\n    public int getCurrentAmmo() { return currentAmmo; }\n    public int getTotalAmmo() { return totalAmmo; }\n    public boolean isReloading() { return isReloading; }\n}",
      "Bullet.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Bullet extends GameObject {\n\n\tprivate Handler handler;\n//SpriteSheet ss, int mx, int my\n\tpublic Bullet(int x, int y, ID id, Handler handler,int mx,int my) {\n\t\tsuper(x, y, id);\n\t\tthis.handler = handler;\n\t\tvelX = (mx - x) / 10;\n\t\tvelY = (my - y) / 10;\n\t}\n\n\t@Override\n\tpublic void tick() {\n\t\tx += velX;\n\t\ty += velY;\n\n\t\t\n\n\t\tfor (int i = 0; i < handler.object.size(); i++) {\n\t\t\tGameObject tempObject = handler.object.get(i);\n\n\t\t\tif (tempObject.getID() == ID.Block) {\n\t\t\t\tif (this.getBounds().intersects(tempObject.getBounds())) {\n\t\t\t\t\thandler.removeObject(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void render(Graphics g) {\n\t\tg.setColor(Color.yellow.darker());\n\t\tg.fillOval(x, y, 8, 8);\n\t}\n\n\t@Override\n\tpublic Rectangle getBounds() {\n\t\treturn new Rectangle(x, y, 8, 8);\n\t}\n\n    \n\n}",
      "Shotgun.java": "import java.awt.Color;\nimport java.awt.Graphics;\n\npublic class Shotgun extends Weapon {\n    public Shotgun() {\n        super(WeaponType.SHOTGUN);\n    }\n    \n    @Override\n    public void fire(int x, int y, int mx, int my, Handler handler) {\n        if (!canFire()) return;\n        \n        lastFiredTime = System.currentTimeMillis();\n        currentAmmo--;\n        \n        double baseAngle = Math.atan2(my - (y + 16), mx - (x + 16));\n        \n        // 45 derecelik yayda 9 mermi (5'er derece aralıklı)\n        for (int i = 0; i < 9; i++) {\n            double angle = baseAngle + Math.toRadians(-22.5 + i * 5);\n            int newMx = (int)((x + 16) + 1000 * Math.cos(angle));\n            int newMy = (int)((y + 16) + 1000 * Math.sin(angle));\n            \n            handler.addObject(new Bullet(x + 16, y + 16, ID.Bullet, handler, newMx, newMy));\n        }\n    }\n    \n    @Override\n    public void render(Graphics g, int x, int y) {\n        g.setColor(Color.WHITE);\n        g.drawString(\"Shotgun: \" + currentAmmo + \"/\" + totalAmmo, x, y);\n        if (isReloading) {\n            g.drawString(\"Reloading...\", x, y + 15);\n        }\n    }\n}",
      "AcidPool.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class AcidPool extends GameObject {\n    private Handler handler;\n    private int lifetime = 180; // 3 s\n    \n    public AcidPool(int x, int y, Handler handler) {\n        super(x, y, ID.Effect);\n        this.handler = handler;\n    }\n    \n    @Override\n    public void tick() {\n        lifetime--;\n        if (lifetime <= 0) {\n            handler.removeObject(this);\n            return;\n        }\n        \n        // devamli hasar vermeli\n        for (GameObject obj : handler.object) {\n            if (obj.getID() == ID.Player && getBounds().intersects(obj.getBounds())) {\n                ((Player)obj).takeDamage(2);\n            }\n        }\n    }\n    \n    @Override\n    public void render(Graphics g) {\n        g.setColor(new Color(100, 255, 100, 100));\n        g.fillOval(x-20, y-20, 40, 40);\n    }\n    \n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x-20, y-20, 40, 40);\n    }\n}",
      "NormalZombie.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class NormalZombie extends Enemy {\n    public NormalZombie(int x, int y, Handler handler, Game game) {\n        super(x, y, ID.Enemy, handler, game, ZombieType.NORMAL);\n    }\n\n    @Override\n    public void tick() {\n        super.tick();\n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(Color.YELLOW);\n        g.fillRect(x, y, 32, 32);\n        \n        // Can barı\n        g.setColor(Color.RED);\n        g.fillRect(x, y-10, 32, 5);\n        g.setColor(Color.GREEN);\n        g.fillRect(x, y-10, (int)(32 * ((double)hp/zombieType.maxHealth)), 5);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 32, 32);\n    }\n}",
      "ID.java": "public enum ID {\n    Player(),\n    Block(),\n    Crate(),\n    Bullet(),\n    Enemy(),\n    Effect, \n    AcidSpit, \n    AcidPool;\n\n}\n",
      "KeyInput.java": "import java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\npublic class KeyInput extends KeyAdapter{\n    Handler handler;\n\n    public KeyInput(Handler handler){\n        this.handler=handler;\n    }\n\n    public void keyPressed(KeyEvent e){\n        int key = e.getKeyCode();\n\n        for(int i=0; i<handler.object.size(); i++){\n            GameObject tempObject = handler.object.get(i);\n\n            if(tempObject.getID() == ID.Player){\n                if(key == KeyEvent.VK_W) handler.setUp(true);\n                if(key == KeyEvent.VK_S) handler.setDown(true);\n                if(key == KeyEvent.VK_A) handler.setLeft(true);\n                if(key == KeyEvent.VK_D) handler.setRight(true);\n            }\n        }\n    }\n\n    public void keyReleased(KeyEvent e){\n        int key = e.getKeyCode();\n\n        for(int i=0; i<handler.object.size(); i++){\n            GameObject tempObject = handler.object.get(i);\n\n            if(tempObject.getID() == ID.Player){\n                if(key == KeyEvent.VK_W) handler.setUp(false);\n                if(key == KeyEvent.VK_S) handler.setDown(false);\n                if(key == KeyEvent.VK_A) handler.setLeft(false);\n                if(key == KeyEvent.VK_D) handler.setRight(false);\n            }\n        }\n        \n    }\n\n\n    \n}\n",
      "Enemy.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Enemy extends GameObject {\n    protected ZombieType zombieType;\n    protected int hp;\n    public enum ZombieType {\n        NORMAL(100, 1.0f, 10, Color.YELLOW),\n        CRAWLER(60, 2.5f, 10, Color.RED),\n        TANK(250, 0.5f, 25, new Color(50, 50, 150)),\n        ACID(80, 0.8f, 15, new Color(50, 150, 50));\n\n        public final int maxHealth;\n        public final float speed;\n        public final int damage;\n        public final Color color;\n//collusion kontrolu yapınca nedense oyun kitleniyor o yuzden cikardim koddan\n        ZombieType(int health, float speed, int damage, Color color) {\n            this.maxHealth = health;\n            this.speed = speed;\n            this.damage = damage;\n            this.color = color;\n        }\n    }\n\n    private Handler handler;\n    private Game game;\n    private int persuitTimer;\n    //private int hp;\n    private boolean isMoving;\n    private ZombieType type;\n    private int attackCooldown = 0;\n    private boolean canJump = true;\n\n    public Enemy(int x, int y, ID id, Handler handler, Game game, ZombieType type) {\n        super(x, y, id);\n        this.zombieType = type;\n        this.handler = handler;\n        this.game = game;\n        this.type = type;\n        this.hp = type.maxHealth;\n        this.isMoving = false;\n    }\n\n    @Override\n    public void tick() {\n        this.x += this.velX;\n        this.y += this.velY;\n\n        if (!isMoving) {\n            this.persuitTimer++;\n        }\n\n        // Özel yeteneklerin güncellenmesi\n        if (attackCooldown > 0) attackCooldown--;\n        if (type == ZombieType.CRAWLER && !canJump) persuitTimer++;\n\n        for (int i = 0; i < this.handler.object.size(); i++) {\n            GameObject tempObject = this.handler.object.get(i);\n\n            if (tempObject.getID() == ID.Block) {\n                if (this.getBoundsBig().intersects(tempObject.getBounds())) {\n                    this.turnBack();\n                    isMoving = false;\n                }\n            }\n\n            if (tempObject.getID() == ID.Bullet) {\n                if (this.getBounds().intersects(tempObject.getBounds())) {\n                    this.hp -= 50;\n                    this.handler.removeObject(tempObject);\n                }\n            }\n\n            if (tempObject.getID() == ID.Player) {\n                if (this.getBounds().intersects(tempObject.getBounds())) {\n                    attack((Player)tempObject);\n                }\n                if (this.isMoving) {\n                    this.persuitPlayer(tempObject);\n                    checkSpecialAbility(tempObject);\n                }\n            }\n        }\n\n        if (this.hp <= 0) {\n            onDeath();\n            game.score += 10;\n            this.handler.removeObject(this);\n        }\n\n        if (this.persuitTimer >= 20) {\n            this.isMoving = true;\n            this.persuitTimer = 0;\n        }\n    }\n\n    private void attack(Player player) {\n        if (attackCooldown <= 0) {\n            player.takeDamage(type.damage);\n            attackCooldown = 30; // 0.5 saniye saldırı aralığı\n        }\n    }\n\n    private void checkSpecialAbility(GameObject player) {\n        switch (type) {\n            case CRAWLER:\n                if (canJump && getDistance(player) < 100) {\n                    jumpTowards(player);\n                }\n                break;\n            case ACID:\n                if (attackCooldown <= 0 && getDistance(player) < 200) {\n                    spitAcid(player);\n                    attackCooldown = 180;\n                }\n                break;\n        }\n    }\n\n    private void jumpTowards(GameObject player) {\n        float distance = getDistance(player);\n        velX = (player.getX()-x)/distance * 10;\n        velY = (player.getY()-y)/distance * 10;\n        canJump = false;\n        persuitTimer = -120; // cooldown icin\n    }\n\n    private void spitAcid(GameObject player) { //merkez odakli spit\n        handler.addObject(new AcidSpit(\n        x + 16, \n        y + 16, \n        player.getX() + 16, \n        player.getY() + 16, \n        handler\n    ));\n    }\n\n    private void onDeath() {\n        if (type == ZombieType.ACID) {\n            //asit havuzu \n            handler.addObject(new AcidPool(x, y, handler));\n        }\n    }\n\n    public float getDistance(GameObject obj) {\n        return (float)Math.sqrt(Math.pow(obj.getX()-x, 2) + Math.pow(obj.getY()-y, 2));\n    }\n\n    private void turnBack() {\n        this.velX *= -1;\n        this.velY *= -1;\n    }\n\n    private void persuitPlayer(GameObject player) {\n        \n            \n            float dx = player.getX() - x;\n            float dy = player.getY() - y;\n            float distance = (float) Math.sqrt(dx*dx + dy*dy);\n        \n            // player mesafesindeyse (400 piksel)\n            if (distance < 400) {\n                \n                velX = (dx/distance) * type.speed;\n                velY = (dy/distance) * type.speed;\n                \n                //ozel zombi yeteneklerini kontrol et\n                checkSpecialAbility(player);\n            } else {\n                // player uzaktaysa rastgele hareket veya bekleme\n                if (Math.random() < 0.02) { // %2 sansla yön değiştir\n                    velX = (float)(Math.random() * 2 - 1) * type.speed * 0.5f;\n                    velY = (float)(Math.random() * 2 - 1) * type.speed * 0.5f;\n                }\n            }\n        \n    }\n\n    \n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(type.color);\n        \n        // typea gore look\n        switch (type) {\n            case TANK:\n                g.fillRect(x-8, y-8, 48, 48);\n                break;\n            case CRAWLER:\n                g.fillRect(x, y, 24, 24);\n                break;\n            case ACID:\n                g.fillOval(x, y, 32, 32);\n                break;\n            default: // NORMAL\n                g.fillRect(x, y, 32, 32);\n        }\n        \n        // hp bar\n        g.setColor(Color.RED);\n        g.fillRect(x, y-10, 32, 5);\n        g.setColor(Color.GREEN);\n        g.fillRect(x, y-10, (int)(32 * ((double)hp/type.maxHealth)), 5);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        int size = (type == ZombieType.TANK) ? 48 : \n                  (type == ZombieType.CRAWLER) ? 24 : 32;\n        return new Rectangle(x, y, size, size);\n    }\n\n    public Rectangle getBoundsBig() {\n        return new Rectangle(x - 16, y - 16, 64, 64);\n    }\n\n    \n}\n\n/* \nprivate void persuitPlayer(GameObject player) {\n    if (getDistance(player) < 400) {\n        float dx = player.getX() - x;\n        float dy = player.getY() - y;\n        float distance = getDistance(player);\n        \n        this.velX = (dx/distance) * type.speed;\n        this.velY = (dy/distance) * type.speed;\n    } else {\n        this.velX = 0;\n        this.velY = 0;\n    }\n} */",
      "WeaponType.java": "public enum WeaponType {\n    PISTOL(12, 60, 120, \"Tabanca\"),\n    RIFLE(30, 120, 600, \"Piyade Tüfeği\"),\n    SHOTGUN(5, 30, 60, \"Pompalı Tüfek\"),\n    SNIPER(5, 20, 30, \"Keskin Nişancı\"),\n    ROCKET_LAUNCHER(1, 5, 10, \"Roketatar\");\n    \n    public final int magazineSize;\n    public final int maxAmmo;\n    public final int fireRate; //dakikada ne kadar atis yapar tutariz\n    public final String name;\n    \n    WeaponType(int magazineSize, int maxAmmo, int fireRate, String name) {\n        this.magazineSize = magazineSize;\n        this.maxAmmo = maxAmmo;\n        this.fireRate = fireRate;\n        this.name = name;\n    }\n}",
      "Block.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Block extends GameObject{\n\n    public Block(int x, int y, ID id) {\n            super(x, y, id);\n    }\n\n\n    \n    @Override\n    public void tick() {\n       \n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(Color.BLACK);\n        g.fillRect(x, y, 32, 32);\n       \n    }\n\n    @Override\n    public Rectangle getBounds() {\n      return new Rectangle(x,y,32,32);\n    }\n\n\n    \n}\n",
      "GameMenu.java": "import java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport javax.swing.*;\n\npublic class GameMenu extends JMenuBar {\n    private Game game;\n    private Handler handler;\n    private JCheckBoxMenuItem pauseItem;\n    \n    public GameMenu(Game game, Handler handler) {\n        this.game = game;\n        this.handler = handler;\n        \n        // File Menu\n        JMenu fileMenu = new JMenu(\"File\");\n        \n        pauseItem = new JCheckBoxMenuItem(\"Pause\");\n        pauseItem.addActionListener(e -> game.togglePause());\n        fileMenu.add(pauseItem);\n        \n        JMenuItem saveItem = new JMenuItem(\"Save\");\n        saveItem.addActionListener(e -> GameState.saveGame(\"savegame.dat\", handler, game.ammo, game.health, game.score));\n        fileMenu.add(saveItem);\n        \n        JMenuItem loadItem = new JMenuItem(\"Load\");\n        loadItem.addActionListener(e -> {\n            GameLoadData data = GameState.loadGame(\"savegame.dat\", handler);\n            if (data != null) {\n                game.ammo = data.ammo;\n                game.health = data.health;\n                game.score = data.score;\n            }\n        });\n        fileMenu.add(loadItem);\n        \n        JMenuItem exitItem = new JMenuItem(\"Exit\");\n        exitItem.addActionListener(e -> System.exit(0));\n        fileMenu.add(exitItem);\n        \n        add(fileMenu);\n    }\n    \n    public void setPaused(boolean paused) {\n        pauseItem.setState(paused);\n    }\n}",
      "Pistol.java": "import java.awt.Color;\nimport java.awt.Graphics;\n\npublic class Pistol extends Weapon {\n    public Pistol() {\n        super(WeaponType.PISTOL);\n    }\n    \n    @Override\n    public void fire(int x, int y, int mx, int my, Handler handler) {\n        if (!canFire()) return;\n        \n        lastFiredTime = System.currentTimeMillis();\n        currentAmmo--;\n        \n        handler.addObject(new Bullet(x + 16, y + 16, ID.Bullet, handler, mx, my));\n    }\n    \n    @Override\n    public void render(Graphics g, int x, int y) {\n        g.setColor(Color.WHITE);\n        g.drawString(\"Pistol: \" + currentAmmo + \"/\" + totalAmmo, x, y);\n        if (isReloading) {\n            g.drawString(\"Reloading...\", x, y + 15);\n        }\n    }\n}",
      "Handler.java": "import java.awt.Graphics;\nimport java.util.LinkedList;\n\n\npublic class Handler {\n    LinkedList<GameObject> object = new LinkedList<GameObject>();\n    \n    private boolean up = false, down = false, right = false, left = false;\n\n    public void tick(){\n        for(int i=0; i<object.size();i++){\n            GameObject tempObject = object.get(i);\n\n            tempObject.tick();\n        }\n\n    }\n    \n    //render method\n    public void render(Graphics g){\n        for(int i=0; i<object.size();i++){\n            GameObject tempObject = object.get(i);\n\n            tempObject.render(g);\n        }\n\n    }\n\n    public void addObject(GameObject tempObject){\n        object.add(tempObject);\n    }\n\n    public void removeObject(GameObject tempObject){\n        object.remove(tempObject);\n    }\n\n    // getters and setters\n\n    public boolean isDown() {\n        return down;\n    }\n\n    public boolean isLeft() {\n        return left;\n    }\n\n    public boolean isRight() {\n        return right;\n    }\n\n    public boolean isUp() {\n        return up;\n    }\n\n    public void setDown(boolean down) {\n        this.down = down;\n    }\n\n    public void setLeft(boolean left) {\n        this.left = left;\n    }\n\n    public void setRight(boolean right) {\n        this.right = right;\n    }\n\n    public void setUp(boolean up) {\n        this.up = up;\n    }\n\n}",
      "Rifle.java": "import java.awt.Color;\nimport java.awt.Graphics;\n\npublic class Rifle extends Weapon {\n    public Rifle() {\n        super(WeaponType.RIFLE);\n    }\n    \n    @Override\n    public void fire(int x, int y, int mx, int my, Handler handler) {\n        if (!canFire()) return;\n        \n        lastFiredTime = System.currentTimeMillis();\n        currentAmmo--;\n        \n        // 30 derece sapma ekle\n        double angle = Math.atan2(my - (y + 16), mx - (x + 16));\n        double deviation = (random.nextDouble() - 0.5) * Math.toRadians(30);\n        angle += deviation;\n        \n        int newMx = (int)((x + 16) + 1000 * Math.cos(angle));\n        int newMy = (int)((y + 16) + 1000 * Math.sin(angle));\n        \n        handler.addObject(new Bullet(x + 16, y + 16, ID.Bullet, handler, newMx, newMy));\n    }\n    \n    @Override\n    public void render(Graphics g, int x, int y) {\n        g.setColor(Color.WHITE);\n        g.drawString(\"Rifle: \" + currentAmmo + \"/\" + totalAmmo, x, y);\n        if (isReloading) {\n            g.drawString(\"Reloading...\", x, y + 15);\n        }\n    }\n}",
      "CrawlerZombie.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class CrawlerZombie extends Enemy {\n    Handler handler;\n    private boolean canJump = true;\n    \n    public CrawlerZombie(int x, int y, Handler handler, Game game) {\n        super(x, y, ID.Enemy, handler, game, ZombieType.CRAWLER);\n    }\n\n    @Override\n    public void tick() {\n        super.tick();\n        if (canJump) {\n            GameObject player = findPlayer();\n            if (player != null && getDistance(player) < 100) {\n                jumpTowards(player);\n                canJump = false;\n            }\n        }\n    }\n\n    private void jumpTowards(GameObject target) {\n        float dx = target.getX() - x;\n        float dy = target.getY() - y;\n        float distance = (float)Math.sqrt(dx*dx + dy*dy);\n        velX = (dx/distance) * 8;\n        velY = (dy/distance) * 8;\n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(Color.RED);\n        g.fillRect(x, y, 24, 24);\n        \n        // hp bar eklendi\n        g.setColor(Color.RED);\n        g.fillRect(x, y-10, 24, 3);\n        g.setColor(Color.GREEN);\n        g.fillRect(x, y-10, (int)(24 * ((double)hp/zombieType.maxHealth)), 3);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 24, 24);\n    }\n\n    private GameObject findPlayer() {\n        for (GameObject obj : handler.object) {\n            if (obj.getID() == ID.Player) return obj;\n        }\n        return null;\n    }\n\n    public float getDistance(GameObject obj) {\n            return (float)Math.sqrt(Math.pow(obj.getX()-x, 2) + Math.pow(obj.getY()-y, 2));\n        }\n}",
      "TankZombie.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class TankZombie extends Enemy {\n    public TankZombie(int x, int y, Handler handler, Game game) {\n        super(x, y, ID.Enemy, handler, game, ZombieType.TANK);\n    }\n\n    @Override\n    public void tick() {\n        super.tick();\n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(new Color(70, 70, 70));\n        g.fillRect(x-8, y-8, 48, 48);\n        \n        // Can barı\n        g.setColor(Color.RED);\n        g.fillRect(x-8, y-16, 48, 5);\n        g.setColor(Color.GREEN);\n        g.fillRect(x-8, y-16, (int)(48 * ((double)hp/zombieType.maxHealth)), 5);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x-8, y-8, 48, 48);\n    }\n}",
      "tempCodeRunnerFile.java": "if(green == 255 && blue==0){\n                    handler.addObject(new Enemy(xx*32, yy*32, ID.Enemy, handler,this));\n                }",
      "BufferedImageLoader.java": "import java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class BufferedImageLoader{\n    private BufferedImage image;\n    \n    public BufferedImage loadImage(String path){\n        try {\n            image = ImageIO.read(getClass().getResource(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return image;\n    }\n}",
      "Game.java": "import java.awt.Canvas;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferStrategy;\nimport java.awt.image.BufferedImage;\n\npublic class Game extends Canvas implements Runnable{\n    private static final long serialVersionUID = 1L;\n    private boolean isRunning = false;\n    private Thread thread;\n    private Handler handler;\n\n    private BufferedImage level = null;\n    private Camera camera;\n    private SpriteSheet ss;\n\n    public int ammo = 100; //mermi baslangic\n    public boolean paused = false;\n    public int health = 100;\n    public int score = 0;\n    public int wave = 1;\n    private GameMenu gameMenu;\n\n    public Game(){\n        gameMenu = new GameMenu(this, handler);\n        new Window(1000, 563,\"GUNS N ZOMBIES\",this,gameMenu);\n        //new  Window(WIDTH, HEIGHT, \"GUNS N ZOMBIES\", game); \n        start();\n\n        handler = new Handler();\n        camera = new Camera(0,0);\n        this.addKeyListener(new KeyInput(handler));\n        this.addMouseListener(new MouseInput(handler,camera,this));\n        BufferedImageLoader loader = new BufferedImageLoader();\n        level = loader.loadImage(\"/res/map.png\");\n\n        \n        loadLevel(level);\n        \n        \n\n    }\n\n    public void run(){\n        this.requestFocus();\n        long lastTime = System.nanoTime();\n        double amountOfTicks = 60.0;\n        double ns = 1000000000/amountOfTicks;\n        double delta=0;\n        long timer = System.currentTimeMillis();\n        int frames=0;\n\n        while(isRunning){\n            long now = System.nanoTime();\n            delta+=(now-lastTime) / ns;\n            lastTime=now;\n            while(delta>=1){\n                tick();\n                delta--;\n            }\n            render();\n            frames++;\n\n            if(System.currentTimeMillis() - timer > 1000){\n                timer += 1000;\n                frames = 0;\n            }\n        }\n        stop();\n        \n    }\n\n    public void tick(){\n        if (paused) return;\n        for(int i=0; i<handler.object.size(); i++){\n            if(handler.object.get(i).getID() == ID.Player){\n                camera.tick(handler.object.get(i));\n            }\n        }\n        handler.tick();\n        \n\n    }\n\n    public void render() {\n        if (this.getBufferStrategy() == null) {\n            this.createBufferStrategy(3);\n            return; \n        }\n    \n        BufferStrategy bs = this.getBufferStrategy();\n        Graphics g = bs.getDrawGraphics();\n        Graphics2D g2d = (Graphics2D) g;\n\n        \n    \n        ///// DRAW\n        g.setColor(Color.red);\n        g.fillRect(0, 0, 1000, 563);\n    \n        g2d.translate(-camera.getX(), -camera.getY());\n        \n        handler.render(g); \n\n        g2d.translate(camera.getX(), camera.getY());\n\n    \n    g.setColor(Color.WHITE);\n    Font defaultFont = new Font(\"Arial\", Font.BOLD, 16);\n    g.setFont(defaultFont);\n    \n    // Ssilah mermi\n    g.drawString(\"Ammo: \" + ammo, 20, 20);\n    \n    // can puan\n    g.drawString(\"Health: \" + health, 800, 20);\n    g.drawString(\"Score: \" + score, 800, 40);\n    g.drawString(\"Wave: \" + wave, 800, 60);\n    \n    // pause\n    if (paused) {\n        Font pauseFont = new Font(\"Arial\", Font.BOLD, 48);\n        g.setFont(pauseFont);\n        g.drawString(\"PAUSED\", 400, 300);\n        g.setFont(defaultFont); // Diğer yazılar için fontu geri değiştir\n    }\n\n        \n        ///// cizim son\n        g.dispose();\n        bs.show();\n    }\n\n    //loading  level\n    private void loadLevel(BufferedImage image){\n        int w = image.getWidth();\n        int h = image.getHeight();\n\n        for(int xx=0; xx < w; xx++){\n            for(int yy=0; yy < h; yy++){\n                int pixel = image.getRGB(xx, yy);\n                int red = (pixel >> 16) & 0xff;\n                int green = (pixel >> 8) & 0xff;\n                int blue = (pixel) & 0xff;\n\n                if(red == 87 && blue == 87 && green==87){\n                    handler.addObject(new Block(xx*32, yy*32, ID.Block));\n                }\n\n                if(red == 255 && blue == 255 && green==255){\n                    handler.addObject(new Player(xx*32, yy*32, ID.Player, handler,this));\n                }\n                //buradan zombie typleari check edilebilir\n                if(green == 255 && blue == 0) {\n                    // normal zombi olarak spawnla\n                    handler.addObject(new NormalZombie(xx*32, yy*32, handler, this));\n                    //handler.addObject(new TankZombie(xx*32, yy*32, handler, this));\n                }\n\n                if(red==116 && blue == 255 && green == 253){\n                    handler.addObject(new Crate(xx*32, yy*32, ID.Crate));\n\n                }\n\n\n                \n\n\n            }\n        }\n    }\n    \n\n    private void start(){\n        isRunning=true;\n        thread=new Thread(this);\n        thread.start();\n\n    }\n\n    private void stop(){\n        isRunning=false;\n        try{\n            thread.join();\n        } catch(InterruptedException e){\n            e.printStackTrace();\n        }\n\n    }\n    \n    public static void main(String[] args) {\n\t\tGame game = new Game();\n        //new Window(1000, 563, \"GUNS N ZOMBIES\", game); \n        game.start();\n    }\n\n    public void togglePause() {\n        paused = !paused;\n        gameMenu.setPaused(paused);\n    }\n\n\n    //dalgaya gore zombi turu updateler\n    private void spawnWave(int waveNumber) {\n        int zombieCount = waveNumber * 5;\n        \n        for (int i = 0; i < zombieCount; i++) {\n            int x = (int)(Math.random() * 800) + 100;\n            int y = (int)(Math.random() * 500) + 50;\n            \n           \n            double rand = Math.random();\n            if (waveNumber > 10 && rand < 0.1) {\n                handler.addObject(new AcidZombie(x, y, handler, this));\n            } else if (waveNumber > 7 && rand < 0.15) {\n                handler.addObject(new TankZombie(x, y, handler, this));\n            } else if (waveNumber > 3 && rand < 0.25) {\n                handler.addObject(new CrawlerZombie(x, y, handler, this));\n            } else {\n                handler.addObject(new NormalZombie(x, y, handler, this));\n            }\n        }\n        \n        System.out.println(\"DALGA \" + waveNumber + \" BAŞLADI!\");\n    }\n    private void checkWaveCompletion() {\n        boolean waveComplete = true;\n        for (GameObject obj : handler.object) {\n            if (obj.getID() == ID.Enemy) {\n                waveComplete = false;\n                break;\n            }\n        }\n        \n        if (waveComplete) {\n            wave++;\n            score += wave * 50;\n            \n            // silah kilidi acilir\n            unlockWeapons();\n            \n            // yeni dalga baslangici\n            spawnWave(wave);\n            \n            // successfull dalga gecisi\n            System.out.println(\"DALGA TAMAMLANDI! Yeni dalga: \" + wave);\n        }\n    }\n    \n    private void unlockWeapons() {\n        Player player = getPlayer();\n        if (player == null) return;\n        //dalgaya gore weapon gunceller\n        switch(wave) {\n            case 2:\n                player.switchWeapon(WeaponType.RIFLE);\n                break;\n            case 4:\n                player.switchWeapon(WeaponType.SHOTGUN);\n                break;\n            case 6:\n                player.switchWeapon(WeaponType.SNIPER);\n                break;\n            case 10:\n                player.switchWeapon(WeaponType.ROCKET_LAUNCHER);\n                break;\n        }\n    }\n    private Player getPlayer() {\n        for (GameObject obj : handler.object) {\n            if (obj.getID() == ID.Player) {\n                return (Player)obj;\n            }\n        }\n        return null;\n    }\n\n}",
      "MouseInput.java": "import java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class MouseInput extends MouseAdapter{\n\n    private Handler handler;\n    private Camera camera;\n    private Game game;\n\n    public MouseInput(Handler handler, Camera camera, Game game){\n        this.handler = handler;\n        this.camera=camera;\n        this.game = game;\n    }\n    \n    public void mousePressed(MouseEvent e){\n        int mx=(int) (e.getX() + camera.getX());\n        int my=(int) (e.getY() + camera.getY());\n\n        for(int i=0; i<handler.object.size(); i++){\n            GameObject tempObject = handler.object.get(i);\n\n            if(tempObject.getID()==ID.Player &&game.ammo>1){\n                handler.addObject(new Bullet(tempObject.getX() + 16, tempObject.getY() + 24, ID.Bullet,handler,mx,my));\n                game.ammo--;\n            }\n        }\n    }\n\n    \n}\n",
      "Camera.java": "public class Camera {\n\n\tprivate float x;\n\tprivate float y;\n\n\tpublic Camera(float x, float y) {\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t}\n\n\tpublic void tick(GameObject object) {\n\t\tx += ((object.getX() - this.x) - 1000 / 2) * 0.05f;\n\t\ty += ((object.getY() - this.y) - 563 / 2) * 0.05f;\n\n\t\tif( x<=0 ) x=-4;\n        if( x>=1032 ) x = 1032;\n        if( y<=0 ) y=0;\n        if( y>=579 ) y=579;\n\n\n\t}\n\n\tpublic float getX() {\n\t\treturn x;\n\t}\n\n\tpublic void setX(int x) {\n\t\tthis.x = x;\n\t}\n\n\tpublic float getY() {\n\t\treturn y;\n\t}\n\n\tpublic void setY(int y) {\n\t\tthis.y = y;\n\t}\n\n}",
      "SpriteSheet.java": "import java.awt.image.BufferedImage;\n\npublic class SpriteSheet {\n\n\tprivate BufferedImage image;\n\t\n\tpublic SpriteSheet(BufferedImage image) {\n\t\tthis.image = image;\n\t}\n\t\n\tpublic BufferedImage grabImage(int col, int row, int width, int height) {\n\t\treturn image.getSubimage((col * 32) - 32, (row * 32) - 32, width, height);\n\t}\n}",
      "RocketLauncher.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class RocketLauncher extends GameObject {\n    private Handler handler;\n    private int explosionRadius;\n    \n    public RocketLauncher(int x, int y, ID id, Handler handler, int mx, int my) {\n        super(x, y, id);\n        this.handler = handler;\n        this.explosionRadius = 100;\n        \n        velX = (mx - x) / 10;\n        velY = (my - y) / 10;\n    }\n    \n    public void tick() {\n        x += velX;\n        y += velY;\n        \n        // Sınır kontrolü\n        if (x < 0 || x > Game.WIDTH || y < 0 || y > Game.HEIGHT) {\n            handler.removeObject(this);\n        }\n        \n        // Çarpışma kontrolü\n        collision();\n    }\n    \n    private void collision() {\n        for (int i = 0; i < handler.object.size(); i++) {\n            GameObject tempObject = handler.object.get(i);\n            \n            if (tempObject.getID() == ID.Block || tempObject.getID() == ID.Enemy) {\n                if (getBounds().intersects(tempObject.getBounds())) {\n                    explode();\n                    handler.removeObject(this);\n                    return;\n                }\n            }\n        }\n    }\n    \n    private void explode() {\n        // Patlama efekti\n       // handler.addObject(new Explosion(x, y, explosionRadius, handler));\n        \n        // Patlama yarıçapındaki zombilere hasar ver\n        for (GameObject obj : handler.object) {\n            if (obj.getID() == ID.Enemy) {\n                double distance = Math.sqrt(Math.pow(obj.getX() - x, 2) + Math.pow(obj.getY() - y, 2));\n                if (distance < explosionRadius) {\n                    int damage = (int)(100 * (1 - distance/explosionRadius));\n                    //((Enemy)obj).takeDamage(damage);\n                }\n            }\n        }\n    }\n    \n    public void render(Graphics g) {\n        g.setColor(Color.ORANGE);\n        g.fillOval(x, y, 12, 12);\n    }\n    \n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 12, 12);\n    }\n}",
      "Crate.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\n\npublic class Crate extends GameObject {\n\n\t//private BufferedImage crate_image;\n\t\n\tpublic Crate(int x, int y, ID id) {\n\t\tsuper(x, y, id);\n\t\t//this.crate_image = ss.grabImage(6, 2, 32, 32);\n\t}\n\n\t@Override\n\tpublic void tick() {\n        \n\n\t}\n\n\t@Override\n\tpublic void render(Graphics g) {\n\t\t//g.drawImage(this.crate_image, x, y, null);\n        g.setColor(Color.cyan);\n        g.fillRect(x, y, 32, 32);\n\t}\n\n\t@Override\n\tpublic Rectangle getBounds() {\n\t\treturn new Rectangle(x, y, 32, 32);\n\t}\n\n}",
      "Window.java": "import javax.swing.JFrame;\nimport java.awt.Dimension;\n\npublic class Window{\n    \n    public Window(int width, int height, String title, Game game, GameMenu gameMenu) {\n\n        JFrame frame = new JFrame(title);\n        frame.setPreferredSize(new Dimension(width, height));\n        frame.setMaximumSize(new Dimension(width, height));\n        frame.setMinimumSize(new Dimension(width, height));\n\n        frame.setResizable(false);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setLocationRelativeTo(null);\n        frame.setJMenuBar(gameMenu);\n        \n        frame.add(game);\n        frame.setVisible(true);\n\t}\n}",
      "Player.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Player extends GameObject{\n   // private int targetX, targetY; //cursor kontrolu icin\n   // private float dx, dy; //hareket hizi icin\n   // private float speed = 0.1f; //hareket katsayisi\n    Handler handler;\n    Game game;\n    private int health = 100;\n\n    public WeaponType currentWeapon = WeaponType.PISTOL;\n    private int ammoInMagazine;\n    private int totalAmmo;\n    private boolean isReloading = false;\n    private int reloadTimer = 0;\n    private int fireCooldown = 0;\n\n\n    public Player(int x, int y, ID id, Handler handler,Game game) {\n\n            super(x, y, id);\n            this.ammoInMagazine = currentWeapon.magazineSize;\n            this.totalAmmo = currentWeapon.maxAmmo;\n            this.handler=handler;\n            this.game=game;\n            //this.targetX=x;\n            //this.targetY=y;\n    }\n\n    public void switchWeapon(WeaponType newWeapon) {\n        this.currentWeapon = newWeapon;\n        this.ammoInMagazine = newWeapon.magazineSize;\n        this.totalAmmo = newWeapon.maxAmmo;\n    }\n\n    /* public void setTargetX(int x,int y) {\n        this.targetX = x;\n        this.targetY = y;\n    } */\n    \n    @Override\n    public void tick() {\n\n        x+= velX;\n        y+= velY;\n\n        collision();\n\n\n        //hareket\n        if(handler.isUp()) velY = -5;\n        else if(!handler.isDown()) velY=0;\n\n        if(handler.isDown()) velY=5;\n        else if(!handler.isUp()) velY =0;\n\n        if(handler.isRight()) velX=5;\n        else if(!handler.isLeft()) velX=0;\n\n        if(handler.isLeft()) velX=-5;\n        else if(!handler.isRight()) velX=0;\n\n\n        /* float diffX = targetX - x;\n        float diffY = targetY - y;\n\n        dx += diffX * speed;\n        dy += diffY * speed;\n\n        x += dx;\n        y += dy;\n\n        //hareket daha soft olsun diye ivme kaybi yaratiriz \n        dx *= 0.9f;\n        dy *= 0.9f; */\n        \n    }\n\n    private void collision(){\n        for(int i=0; i<handler.object.size(); i++){\n            GameObject tempObject = handler.object.get(i);\n\n            if(tempObject.getID()==ID.Block){\n                if(getBounds().intersects(tempObject.getBounds())){\n                    x += velX * -1;\n                    y += velY * -1;\n                }\n            }\n\n            if(tempObject.getID()==ID.Crate){\n                if(getBounds().intersects(tempObject.getBounds())){\n                    game.ammo+=20;\n                    handler.removeObject(tempObject);\n                }\n            }\n\n            if(tempObject.getID()==ID.Enemy){\n                if(getBounds().intersects(tempObject.getBounds())){\n                    setHealth(getHealth()-10);\n                    \n                }\n            }\n        }\n    }\n\n    @Override\n    public void render(Graphics g) {\n         g.setColor(Color.BLUE);\n         g.fillRect(x, y, 32, 48);\n        \n    }\n\n    @Override\n    public Rectangle getBounds() {\n            return new Rectangle(x,y,32,48);\n        \n    }\n\n    public void takeDamage(int damage) {\n        health -= damage;\n        if (health <= 0) {\n            // Oyun sonu\n        }\n    }\n    \n    public int getHealth() {\n        return health;\n    }\n\n    public void setHealth(int health) {\n        this.health = health;\n    }\n\n    /* public Weapon getCurrentWeapon() {\n        return this.currentWeapon;\n    } */\n    \n\n}\n",
      "GameObject.java": "import java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic abstract class GameObject {\n    protected int x, y;\n    protected float velX = 0, velY = 0;\n    protected ID id;\n\n    public GameObject(int x,int y, ID id){\n        this.x=x;\n        this.y=y;\n        this.id=id;\n    }\n\n    public abstract void tick();\n    public abstract void render(Graphics g);\n    public abstract Rectangle getBounds();\n\n    public void setTarget(int x, int y) {\n        //hata vermesin diye ekledim\n    }\n\n    public ID getID() {\n        return id;\n    }\n\n    public void setID(ID id) {\n        this.id = id;\n    }\n\n    public float getVelX() {\n        return velX;\n    }\n\n    public float getVelY() {\n        return velY;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setVelX(float velX) {\n        this.velX = velX;\n    }\n\n    public void setVelY(float velY) {\n        this.velY = velY;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n}\n",
      "GameState.java": "import java.io.*;\nimport java.util.LinkedList;\n\npublic class GameState {\n    public static void saveGame(String filename, Handler handler, int ammo, int health, int score) {\n        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(filename))) {\n            LinkedList<GameObject> objects = new LinkedList<>();\n            for (GameObject obj : handler.object) {\n                if (obj.getID() != ID.Player) { // Player'ı kaydetmiyoruz, yeniden oluşturacağız\n                    objects.add(obj);\n                }\n            }\n            out.writeObject(objects);\n            out.writeInt(ammo);\n            out.writeInt(health);\n            out.writeInt(score);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static GameLoadData loadGame(String filename, Handler handler) {\n        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(filename))) {\n            @SuppressWarnings(\"unchecked\")\n            LinkedList<GameObject> objects = (LinkedList<GameObject>) in.readObject();\n            handler.object.clear();\n            \n           \n            handler.addObject(new Player(100, 100, ID.Player, handler, null));\n            \n            for (GameObject obj : objects) {\n                handler.addObject(obj);\n            }\n            \n            return new GameLoadData(\n                in.readInt(), // ammo\n                in.readInt(), // health\n                in.readInt()  // score\n            );\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n\nclass GameLoadData {\n    public final int ammo;\n    public final int health;\n    public final int score;\n    \n    public GameLoadData(int ammo, int health, int score) {\n        this.ammo = ammo;\n        this.health = health;\n        this.score = score;\n    }\n}"
    },
    {
      "id": "7732416",
      "CustomKeyListener.java": "import java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\npublic class CustomKeyListener implements KeyListener {\n\n    public boolean upPressed, downPressed, leftPressed, rightPressed ;\n    public boolean[] pressedNumber = new boolean[5];\n\n    @Override\n    public void keyTyped(KeyEvent e) {}\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int code = e.getKeyCode();\n\n        // walking\n        if (code == KeyEvent.VK_W){\n            upPressed = true ;\n        }\n        if (code == KeyEvent.VK_S){\n            downPressed = true ;\n        }\n        if (code == KeyEvent.VK_A){\n            leftPressed = true ;\n        }\n        if (code == KeyEvent.VK_D){\n            rightPressed = true ;\n        }\n\n        // switching guns\n        if (code == KeyEvent.VK_1) {\n            pressedNumber[0] = true;\n        }\n        if (code == KeyEvent.VK_2) {\n            pressedNumber[1] = true;\n        }\n        if (code == KeyEvent.VK_3) {\n            pressedNumber[2] = true;\n        }\n        if (code == KeyEvent.VK_4) {\n            pressedNumber[3] = true;\n        }\n        if (code == KeyEvent.VK_5) {\n            pressedNumber[4] = true;\n        }\n\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int code = e.getKeyCode();\n\n        if (code == KeyEvent.VK_W){\n            upPressed = false ;\n        }\n        if (code == KeyEvent.VK_S){\n            downPressed = false ;\n        }\n        if (code == KeyEvent.VK_A){\n            leftPressed = false ;\n        }\n        if (code == KeyEvent.VK_D){\n            rightPressed = false;\n        }\n\n        // Release the number keys\n        if (code == KeyEvent.VK_1) {\n            pressedNumber[0] = false;\n        }\n        if (code == KeyEvent.VK_2) {\n            pressedNumber[1] = false;\n        }\n        if (code == KeyEvent.VK_3) {\n            pressedNumber[2] = false;\n        }\n        if (code == KeyEvent.VK_4) {\n            pressedNumber[3] = false;\n        }\n        if (code == KeyEvent.VK_5) {\n            pressedNumber[4] = false;\n        }\n\n    }\n}\n\n\n",
      "Aim.java": "import java.awt.event.MouseEvent;\nimport java.awt.event.MouseMotionListener;\n\npublic class Aim implements MouseMotionListener {\n    public int mouseX ;\n    public int mouseY ;\n\n    @Override\n    public void mouseDragged(MouseEvent e) {}\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n}\n",
      "Wave.java": "import java.awt.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Wave {\n    int waveNumber;\n    int numberOfZombies;\n    double normalZombieRatio;\n    double crawlerZombieRatio;\n    double tankZombieRatio;\n    double acidZombieRatio;\n    List<Zombie> zombies = new ArrayList<>(); //zombie wave\n    GamePanel gp ;\n    Character player;\n\n    public Wave(GamePanel gp, Character player) {\n\n        this.waveNumber = 1;\n        this.numberOfZombies = 6;\n        this.normalZombieRatio = normalZombieRatio = 1.0;\n        this.crawlerZombieRatio = crawlerZombieRatio = 0.0;\n        this.tankZombieRatio = tankZombieRatio = 0.0;\n        this.acidZombieRatio = acidZombieRatio = 0.0;\n        this.gp = gp ;\n        this.player = player ;\n        createZombies();\n    }\n\n    public boolean isWaveAlive(){\n        for (Zombie zombie : zombies){\n            if (zombie.getHealth() > 0){\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void updateWave(){\n        waveNumber++ ;\n        updateRatios();\n        numberOfZombies += 2 ;\n        createZombies();\n\n    }\n\n    public void createZombies(){\n        zombies.clear();\n\n        // number of each zombie\n        int normal = (int) (numberOfZombies * normalZombieRatio);\n        int crawler= (int) (numberOfZombies * crawlerZombieRatio);\n        int tank = (int) (numberOfZombies * tankZombieRatio);\n        int acid = numberOfZombies - (normal + crawler + tank);\n\n        // creating the zombie wave\n        for (int i = 0; i < normal; i++) {\n            zombies.add(new Zombie(gp, player));\n        }\n        for (int i = 0; i < crawler; i++) {\n            zombies.add(new CrawlerZombie(gp, player));\n        }\n        for (int i = 0; i < tank; i++) {\n            zombies.add(new TankZombie(gp, player));\n        }\n        for (int i = 0; i < acid; i++) {\n            zombies.add(new AcidSpitterZombie(gp, player));\n        }\n    }\n\n    public void updateRatios() {\n        // Track total reduction from normal zombies\n        double totalReduction = 0.0;\n\n        // Crawler: +3% per wave after 5 (max 30%)\n        if (waveNumber >= 5) {\n            crawlerZombieRatio = Math.min(0.3, 0.03 * (waveNumber - 5));\n            totalReduction += crawlerZombieRatio;\n        }\n\n        // Tank: +3% per wave after 8 (max 30%)\n        if (waveNumber >= 8) {\n            tankZombieRatio = Math.min(0.3, 0.03 * (waveNumber - 8));\n            totalReduction += tankZombieRatio;\n        }\n\n        // Acid: +3% per wave after 10 (max 30%)\n        if (waveNumber >= 10) {\n            acidZombieRatio = Math.min(0.3, 0.03 * (waveNumber - 10));\n            totalReduction += acidZombieRatio;\n        }\n\n        //100% total\n        normalZombieRatio = 1.0 - totalReduction;\n        normalZombieRatio = Math.max(normalZombieRatio, 0.1); // Never below 10%\n    }\n    public void update(){\n        for (Zombie zombie : zombies){\n            zombie.update();\n        }\n        if (!isWaveAlive()){\n            updateWave();\n        }\n\n        player.updateGun(waveNumber);\n    }\n\n    public void draw(Graphics2D g){\n        for (Zombie zombie : zombies){\n                zombie.draw(g);\n\n        }\n    }\n\n}",
      "Zombie.java": "import javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.io.IOException;\nimport java.util.Random;\n\npublic class Zombie extends Entity{\n    private int damage;\n    private long lastAttack = 0;\n    private int attackCooldown = 100000000 ; // nanoseconds\n    private GamePanel gp;\n    private Character player ;\n    private int attackRange = 32;\n\n    // constructors for sub zombie classes\n    public Zombie(int health, int speed, int damage, GamePanel gp, Character player) {\n        super(getRandomAxisValue(player.getX(), gp.width), getRandomAxisValue(player.getY(), gp.height),health, speed);\n        this.damage = damage;\n        this.gp = gp ;\n        this.player = player ;\n    }\n    // default constructor for the zombies\n    public Zombie(GamePanel gp,Character player) {\n        super(getRandomAxisValue(player.getX(), gp.width), getRandomAxisValue(player.getY(), gp.height),100,2);\n        this.damage = 5 ;\n        this.gp = gp ;\n        this.player = player ;\n        try {\n            this.art = ImageIO.read(getClass().getResourceAsStream(\"/Zombie.png\"));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    public void attack(){\n        if(canAttack()){\n            player.setHealth(player.getHealth() - damage);\n            lastAttack = System.nanoTime();\n        }\n    }\n\n    public double getDistanceToPlayer() {\n        int dx = player.getX() - this.x;\n        int dy = player.getY() - this.y;\n        return Math.sqrt(dx * dx + dy * dy); // Pythagorean theorem\n    }\n\n    private boolean canAttack(){\n        return getDistanceToPlayer() <= attackRange && ((System.nanoTime() - lastAttack) > attackCooldown);\n    }\n\n    //for random spawn\n    private static int getRandomAxisValue(int playerAxisVlue, int screenBound) {\n\n        final int MIN_DISTANCE = 150; // Minimum distance from player on this axis\n        int randomValue; // Variable to store the generated value\n        int attempts = 0;\n        int maxAttempts = 1000; // Prevent infinite loops\n\n        do {\n            randomValue = (int)(Math.random() * screenBound);\n            attempts++;\n        } while (Math.abs(randomValue - playerAxisVlue) < MIN_DISTANCE && attempts < maxAttempts);\n\n        // Fallback to screen edge if too many attempts\n        if (attempts >= maxAttempts) {\n            randomValue = (playerAxisVlue < screenBound / 2) ? screenBound : 0;\n        }\n\n        return randomValue;\n\n    }\n\n    // method to chase the player\n    public void chase(){\n        //Bresenham algorithm based. chasing the player\n        Random random = new Random();\n        int targetX = player.getX();\n        int targetY = player.getY();\n\n        // Calculate direction to player\n        int dx = targetX - x;\n        int dy = targetY - y;\n        int absDx = Math.abs(dx);\n        int absDy = Math.abs(dy);\n\n        // Handle zero-distance case (prevent division by zero)\n        if (dx == 0 && dy == 0) return;\n\n        // Prioritize dominant axis\n        if (absDx > absDy) {\n            // Move horizontally\n            x += Integer.compare(dx, 0) * speed;\n            // Occasionally move vertically\n            if (random.nextDouble() < (double) absDy / (absDx + absDy)) {\n                y += Integer.compare(dy, 0) * speed;\n            }\n        } else {\n            // Move vertically\n            y += Integer.compare(dy, 0) * speed;\n            // Occasionally move horizontally\n            if (random.nextDouble() < (double) absDx / (absDx + absDy)) {\n                x += Integer.compare(dx, 0) * speed;\n            }\n        }\n    }\n\n    @Override\n    public void update() {\n\n        chase();\n        if (health > 0 ) {\n            attack();\n        }\n\n    }\n\n    @Override\n    public void draw(Graphics2D g) {\n        if(health > 0) {\n            g.drawImage(art, x, y, gp.tileSize, gp.tileSize, null);\n        }\n    }\n\n    public void setAttackCooldown(int attackCooldown) {\n        this.attackCooldown = attackCooldown;\n    }\n\n    public void setAttackRange(int attackRange) {\n        this.attackRange = attackRange;\n    }\n\n\n}\n\n\n",
      "Entity.java": "import java.awt.*;\nimport java.awt.image.BufferedImage;\n\nabstract class Entity {\n    int x, y ;\n    int health;\n    int speed; // PPF\n    BufferedImage art ;\n\n    public Entity(int x, int y, int health, int speed) {\n        this.x = x;\n        this.y = y;\n        this.health = health;\n        this.speed = speed;\n    }\n\n    public abstract void update();\n    public abstract void draw(Graphics2D g);\n\n    public int getX() {\n        return x;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public void setHealth(int health) {\n        this.health = health;\n    }\n\n    public int getSpeed() {\n        return speed;\n    }\n\n    public void setSpeed(int speed) {\n        this.speed = speed;\n    }\n}\n",
      "Character.java": "import javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Character extends Entity {\n    public Gun currentGun ;\n    public List<Gun> guns = new ArrayList<>() ;\n    private GamePanel gp ;\n    private CustomKeyListener customKeyListener;\n    private Aim aim ;\n    private MouseClick click ;\n    private double aimAngle ;\n\n    public Character(GamePanel gp, CustomKeyListener keylistener, Aim aim, MouseClick click) { // default values\n        super(100,100,300,5);\n        this.gp = gp ;\n        this.customKeyListener = keylistener ;\n        this.aim = aim ;\n        this.click = click ;\n        guns.add(new Pistol(this, gp.wave));\n        this.currentGun = guns.getFirst();\n\n        try {\n            this.art = ImageIO.read(getClass().getResourceAsStream(\"/Soldier.png\"));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        this.currentGun = currentGun;\n    }\n\n\n    public void updateGun(int waveNumber){\n        if (waveNumber == 1){\n            guns.add(new InfantryRiffle(this, gp.wave));\n        } else if (waveNumber == 3) {\n            guns.add(new Shoutgun(this, gp.wave));\n        } else if (waveNumber == 5) {\n            guns.add(new MarksmanRiffle(this, gp.wave));\n        } else if (waveNumber == 10) {\n            guns.add(new RocketLauncher(this, gp.wave));\n        }\n    }\n\n    @Override\n    public void update() {\n        //walking\n        if (customKeyListener.upPressed){\n            this.y -= speed ;\n        }\n        else if (customKeyListener.downPressed){\n            this.y += speed ;\n        }\n        else if (customKeyListener.leftPressed){\n            this.x -= speed ;\n        }\n        else if (customKeyListener.rightPressed){\n            this.x += speed ;\n        }\n\n        //switch gun\n        if (customKeyListener.pressedNumber[0]){\n            currentGun = guns.getFirst();\n        }else if (customKeyListener.pressedNumber[1]){\n            currentGun = guns.get(1);\n        }else if (customKeyListener.pressedNumber[2]){\n            currentGun = guns.get(2);\n        }else if (customKeyListener.pressedNumber[3]){\n            currentGun = guns.get(3);\n        }else if (customKeyListener.pressedNumber[4]){\n            currentGun = guns.get(4);\n        }\n\n        aimAngle = Math.atan2(aim.mouseY - y, aim.mouseX - x);\n\n        if (click.click){\n            currentGun.shoot();\n            click.click = false ;\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g) {\n        if (health > 0 ) {\n            g.drawImage(art, x, y, gp.tileSize, gp.tileSize, null);\n        }\n    }\n\n    public double getAimAngle() {\n        return aimAngle;\n    }\n}\n",
      "Gun.java": "abstract class Gun {\n    int clipCapacity ; // sarjor\n    int shootingSpeed ; // mermi/dakika\n    int damage;\n    Character player ;\n    Wave wave ;\n\n    public Gun(int clipCapacity, int shootingSpeed, Character player ,Wave wave) {\n        this.clipCapacity = clipCapacity;\n        this.shootingSpeed = shootingSpeed;\n        this.player = player ;\n        this.wave = wave ;\n    }\n\n    public boolean isZombieHit(Zombie zombie, double aimAngle) {\n        double dx = zombie.getX() - player.getX();\n        double dy = zombie.getY() - player.getY();\n        double angleToZombie = Math.atan2(dy, dx);\n\n        return Math.abs(angleToZombie - aimAngle) < 0.3; // Small tolerance to check alignment\n    }\n\n    abstract void shoot();\n    abstract void reload(); // R tusu\n\n\n    public int getDamage() {\n        return damage;\n    }\n}\n",
      "MarksmanRiffle.java": "public class MarksmanRiffle extends Gun{\n\n    public MarksmanRiffle(Character player ,Wave wave) {\n        super(5, 30, player, wave);\n        damage = 40 ;\n    }\n\n    @Override\n    void shoot() {\n\n    }\n    @Override\n    void reload() {\n\n    }\n}\n",
      "Pistol.java": "public class Pistol extends Gun{\n\n    public Pistol( Character player ,Wave wave) {\n        super(12, 120,  player , wave);\n        damage = 25 ;\n    }\n\n    @Override\n    void shoot() {\n        int hitCount = 0;\n        for (Zombie zombie : wave.zombies) {\n            if (isZombieHit(zombie, player.getAimAngle())) {\n                zombie.setHealth(zombie.getHealth() - damage);\n                System.out.println(\"Zombie hit! Remaining health: \" + zombie.getHealth());\n                break;\n            }\n        }\n    }\n\n    @Override\n    void reload() {\n\n    }\n}\n",
      "GamePanel.java": "import javax.swing.*;\nimport java.awt.*;\n\npublic class GamePanel extends JPanel implements Runnable{\n\n    //Panel size\n    final public int tileSize = 32 ; //32x32 tiles\n    final int columNumber = 30 ;\n    final int rowNumber = 16 ;\n    final int width = tileSize * columNumber ;\n    final int height = tileSize * rowNumber ;\n\n    // FPS\n    int FPS = 60;\n\n    Thread gameThread;\n    CustomKeyListener customKeyListener = new CustomKeyListener();\n    Aim aim = new Aim() ;\n    MouseClick click = new MouseClick();\n    Character character = new Character(this,customKeyListener, aim, click);\n    Wave wave = new Wave(this, character);\n\n\n\n    public GamePanel() {\n        this.setPreferredSize(new Dimension(width, height)); // better than setSize()\n        this.setBackground(Color.BLACK);\n        this.setDoubleBuffered(true); // enabling the double buffering for smooth graphics\n\n        this.addKeyListener(customKeyListener); // linking it to the custom-made KeyListener class\n        this.setFocusable(true);\n        this.addMouseListener(new MouseClick());\n    }\n\n    public void startGameThread(){\n        gameThread = new Thread(this); // giving it a runnable object, the class itself\n        gameThread.start();\n    }\n\n    @Override\n    public void run() { // creating the game loop\n\n        double drawInternal = (double) 1000000000/FPS ; // making the calc with nanoseconds to be more precise\n        double delta = 0 ;\n        long lastTime = System.nanoTime() ;\n        long currentTime ;\n\n        while (gameThread != null){\n\n            currentTime = System.nanoTime() ;\n            delta += (currentTime - lastTime) / drawInternal ;\n            lastTime = currentTime;\n\n            if (delta >= 1 ){\n                update();\n                repaint();\n                delta--;\n            }\n\n            if (character.getHealth() <= 0) {\n                break; // Exit the game loop\n            }\n\n        }\n    }\n    public void update(){\n        character.update();\n        if (click.click){\n            character.currentGun.shoot();\n            click.click = false ;\n        }\n        wave.update();\n\n    }\n\n    @Override\n    public void paintComponent(Graphics g){\n\n        super.paintComponent(g);\n        Graphics2D brush = (Graphics2D)g; // to be able to use more methods\n\n        character.draw(brush);\n        wave.draw(brush);\n\n        brush.dispose(); // to release the resources\n    }\n\n}\n",
      "AcidSpitterZombie.java": "import javax.imageio.ImageIO;\nimport java.io.IOException;\n\npublic class AcidSpitterZombie extends Zombie{\n\n    public AcidSpitterZombie(GamePanel gp, Character player) {\n        super(50, 2, 5, gp, player);\n        this.setAttackCooldown(3000);\n        this.setAttackRange(100);\n        try {\n            this.art = ImageIO.read(getClass().getResourceAsStream(\"/AcidSpitter.png\"));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n",
      "CrawlerZombie.java": "import javax.imageio.ImageIO;\nimport java.io.IOException;\n\npublic class CrawlerZombie extends Zombie{\n    private long lastDash = 0 ;\n    private final int ORIGINAL_SPEED = 3 ;\n    private final long DASH_CD = 15000000000L ;\n    private final int DASH_TIME = 1000000000 ;\n    private final int DASH_SPEED = 10 ;\n    private final int DASH_DISTANCE = 70 ;\n\n    public CrawlerZombie(GamePanel gp, Character player) {\n        super(50, 3, 5, gp, player);\n        try {\n            this.art = ImageIO.read(getClass().getResourceAsStream(\"/Crawler.png\"));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void chase() {\n        if (canDash()){\n            dash();\n        }\n        if ((System.nanoTime() - lastDash > DASH_TIME)){\n            this.speed = ORIGINAL_SPEED;\n        }\n        super.chase();\n\n    }\n\n    public void dash(){\n        lastDash = System.nanoTime() ;\n        speed = DASH_SPEED ;\n    }\n\n    private boolean canDash(){\n        return (this.getDistanceToPlayer() <= DASH_DISTANCE) && ((System.nanoTime() - lastDash) > DASH_CD);\n    }\n}\n\n",
      "TankZombie.java": "import javax.imageio.ImageIO;\nimport java.io.IOException;\n\npublic class TankZombie extends Zombie{\n\n    public TankZombie(GamePanel gp,Character player) {\n        super(150, 1, 10, gp, player);\n        try {\n            this.art = ImageIO.read(getClass().getResourceAsStream(\"/Tank.png\"));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n",
      "Shoutgun.java": "public class Shoutgun extends Gun{\n    private static final int NUM_BULLETS = 9; // Number of bullets fired\n\n    public Shoutgun( Character player ,Wave wave) {\n        super(5, 60, player , wave);\n        damage = 50 ;\n    }\n\n    @Override\n    void shoot() {\n        for (int i = 0; i < NUM_BULLETS; i++) {\n            // Calculate the angle for this specific bullet\n            double spreadAngle = player.getAimAngle() + Math.toRadians(i * 5 - 22);\n\n            // Check for each zombie if it is hit by this bullet\n            for (Zombie zombie : wave.zombies) {\n                if (isZombieHit(zombie, spreadAngle)) {\n                    zombie.setHealth(zombie.getHealth() - damage);\n                    break;\n                }\n            }\n        }\n    }\n    @Override\n    void reload() {\n\n    }\n}\n",
      "Game.java": "import javax.swing.*;\nimport java.awt.*;\n\npublic class Game {\n    public static void main(String[] args) {\n\n        // Creating the main window\n        JFrame gameWindow = new JFrame(\"Top-down shooter\");\n        gameWindow.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        gameWindow.setResizable(false); // not allowing resizing\n        gameWindow.setLayout(new FlowLayout()); // flow is already the default\n\n        GamePanel gamePanel = new GamePanel();\n        gameWindow.add(gamePanel);\n        gameWindow.pack(); // sizes according to the subcomponents and the layout of the panel\n\n        gameWindow.setLocationRelativeTo(null); // for it to be in the middle of the screen\n        gameWindow.setVisible(true);\n\n        gamePanel.startGameThread(); // starting the game loop inside panel\n    }\n}\n",
      "InfantryRiffle.java": "public class InfantryRiffle extends Gun{\n    private static final double MAX_SPREAD_ANGLE = Math.toRadians(15);\n\n    public InfantryRiffle( Character player ,Wave wave) {\n        super(30, 600,  player , wave);\n        damage = 40;\n    }\n\n    @Override\n    void shoot() {\n\n        double spreadAngle = player.getAimAngle() + (Math.random() - 0.5) * 2 * MAX_SPREAD_ANGLE;\n\n        for (Zombie zombie : wave.zombies) {\n            if (isZombieHit(zombie, player.getAimAngle())) {\n                zombie.setHealth(zombie.getHealth() - damage);\n                break;\n            }\n        }\n    }\n    @Override\n    void reload() {\n\n    }\n}\n",
      "RocketLauncher.java": "public class RocketLauncher extends Gun{\n\n    public RocketLauncher( Character player ,Wave wave) {\n        super(1, 10,  player , wave);\n        damage = 70 ;\n    }\n\n    @Override\n    void shoot() {\n\n    }\n    @Override\n    void reload() {\n\n    }\n}\n",
      "MouseClick.java": "import java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\n\npublic class MouseClick implements MouseListener {\n     public boolean click ;\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        click = true ;\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {}\n\n    @Override\n    public void mouseReleased(MouseEvent e) {}\n\n    @Override\n    public void mouseEntered(MouseEvent e) {}\n\n    @Override\n    public void mouseExited(MouseEvent e) {}\n}\n"
    },
    {
      "id": "4779274",
      "GameSave.java": "import java.io.Serializable;\n\npublic class GameSave implements Serializable{\n    //bu classtan açılacak obje ile oyunda kaydedilmesi gereken her şey alıncak\n    //sonra dosyaya yazdırılcak\n\n    //kameranın konumu\n    public Camera camera;\n\n    public Player player;\n    //main-static player (entities içinde var ama tek başına da çok kullandım kolaylık sağladığından)\n    public double playerHealth;\n    public int playerScore;\n\n    //dalga boolean değerleri\n    public boolean[] dalga;\n\n    //handler\n    public Handler handler;\n\n    //hangi turda, turun hangi spawner indisinde kaldık\n    public int tour, zombieIndex;\n\n    //silahla alakalı bilgiler\n    public GunType gunType;\n    //dosyadan okurken type'a göre hızlıca silahı modifiye edeceğiz\n    \n}\n",
      "Zombie.java": "import java.awt.Rectangle;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic abstract class Zombie extends GameObject {\n\n    protected Handler handler;\n    protected GameObject player;\n\n    protected int health;\n    protected int attack;\n\n    protected long shootTime=0;\n    protected long jumpTime=0;\n    protected boolean isJumping = false;\n\n    public Zombie(int x, int y, EntityType type, Handler handler) {\n        super(x, y, type);\n        this.handler = handler;\n        this.player = getPlayer();\n    }\n\n    private GameObject getPlayer() {\n        for (int i=0; i < handler.entities.size(); i++) {\n            GameObject tempGameObject = handler.entities.get(i);\n            if (tempGameObject.getType() == EntityType.Player) {\n                return tempGameObject;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void tick() {\n        if (player != null) {\n            if (health <= 0) {\n\n                //asit tüküren zombi ölünce etraftaki zombilerin\n                //canını 2 azaltır - duvarları siler\n                //oyuncu canını da 50 azaltır eğer o alandaysa\n                if(this instanceof ZombieAsitli){\n                    Rectangle etkiAlani = new Rectangle(\n                            this.getX()-60,\n                            this.getY()-60,\n                            120,\n                            120\n                        );\n                    \n                    double random = Math.random();\n                    if(random < 0.25 && Player.gun.type != GunType.Tabanca) {\n                        handler.addEntity(new YedekSarjor(this.getX(), this.getY(), EntityType.YedekSarjor));\n                    }\n\n                    List<GameObject> silinecekler = new ArrayList<>();\n                    silinecekler.add(this);\n\n                    for(int j=0; j<handler.entities.size(); j++) {\n                        GameObject temp = handler.entities.get(j);\n                        if(temp instanceof Zombie && temp.getBounds().intersects(etkiAlani)) {\n                            ((Zombie)temp).setHealth(((Zombie)temp).getHealth() - 3);\n                        }\n\n                        else if(temp instanceof Player && temp.getBounds().intersects(etkiAlani)) {\n                            Player.setHealth(Player.getHealth() - 30);\n                        }\n\n                        else if(temp.getType() == EntityType.Block && temp.getBounds().intersects(etkiAlani)) {\n                            silinecekler.add(temp);\n                        }\n                    }\n\n                    for(GameObject sil : silinecekler) {\n                        handler.removeEntity(sil);\n                        if(sil instanceof Zombie) Player.setScore(Player.getScore() + 5);\n                    }\n\n                    handler.addEntity(new BombEffect(this.getX() - 60, this.getY() - 60, EntityType.AsitliZombiEfekt , 120, 120, 60, handler));\n\n                }\n                \n                else {\n                    double random = Math.random();\n                    if(random < 0.25 && Player.gun.type != GunType.Tabanca) {\n                        handler.addEntity(new YedekSarjor(this.x, this.y, EntityType.YedekSarjor));\n                    }\n                    handler.removeEntity(this);\n                    Player.setScore(Player.getScore() + 5);\n                }\n                \n            }\n\n            int playerX = player.getX();\n            int playerY = player.getY();\n\n            Collision.checkSomeCollision(this, handler);\n\n            double diffX = playerX - x;\n            double diffY = playerY - y;\n            double distance = Math.sqrt(diffX * diffX + diffY * diffY);\n\n            //asit tüküren zombinin asit tükürmesi\n            if(this instanceof ZombieAsitli) {\n                long currentTime = System.currentTimeMillis();\n                if(currentTime - shootTime > 1000) {\n                    shootTime = System.currentTimeMillis();\n                    handler.addEntity(new Acyd(this.getX(), this.getY(), EntityType.Asit, handler, ((Player)player)));\n                }\n            }\n\n            //sürünge zombiler 230 mesafeden sonra oyuncunun sırtına atlar\n            //sonra kaçabiliriz, bir süre sonra tekrar atlar\n            long currentTime = System.currentTimeMillis();\n            if (this instanceof ZombieSurunge && distance <= 230 && distance >= 30) {\n                if (!isJumping && currentTime - jumpTime > 3500) { //3,5 saniye yeniden atlamak için güç toplar\n                    jumpTime = currentTime;\n                    isJumping = true;\n                }\n\n                if (isJumping && currentTime - jumpTime < 400) {\n                    speed_X = (int) ((diffX / distance) * getSpeed() * 3.75);\n                    speed_Y = (int) ((diffY / distance) * getSpeed() * 3.75);\n                } else if (isJumping) { \n                    isJumping = false;\n                    jumpTime = currentTime;\n                }\n            }\n\n\n            else {\n            speed_X = (int) ((diffX / distance) * getSpeed());\n            speed_Y = (int) ((diffY / distance) * getSpeed());\n            }\n\n            x += speed_X;\n            y += speed_Y;\n        }\n    }\n\n\n    protected abstract double getSpeed();\n\n    \n    public int getHealth() {\n        return health;\n    }\n\n    \n    public void setHealth(int health) {\n        this.health = health;\n    }\n\n    \n    public int getAttack() {\n        return attack;\n    }\n\n    \n    public void setAttack(int attack) {\n        this.attack = attack;\n    }\n\n\n\n}\n",
      "ZombieTank.java": "import java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.Color;\n\npublic class ZombieTank extends Zombie{\n    public ZombieTank(int x, int y, EntityType type, Handler handler) {\n        super(x, y, type, handler);\n        health = 5;\n        attack = 4;\n    }\n\n    @Override\n    protected double getSpeed() {\n        return 2.0;\n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(new Color(70,70,40,230));\n        g.fillRect(x, y, 40, 40);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x,y,40,40);\n    }\n\n}\n",
      "ZombieSurunge.java": "import java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.Color;\n\npublic class ZombieSurunge extends Zombie{\n\n    public ZombieSurunge(int x, int y, EntityType type, Handler handler) {\n        super(x, y, type, handler);\n        health = 2;\n        attack = 2;\n    }\n\n    @Override\n    protected double getSpeed() {\n        return 4.0;\n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(new Color(158,0,3,230));\n        g.fillOval(x, y, 32, 32);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x,y,32,32);\n    }\n    \n}",
      "BombEffect.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class BombEffect extends GameObject {\n    private int duration;\n    private Handler handler;\n\n    public BombEffect(int x, int y, EntityType type, int width, int height, int duration, Handler handler) {\n        super(x, y, type);\n        this.width = width;\n        this.height = height;\n        this.duration = duration;\n        this.handler = handler;\n    }\n\n    @Override\n    public void tick() {\n        duration--;  \n        if (duration <= 0) {\n            handler.removeEntity(this);\n        }\n    }\n\n    @Override\n    public void render(Graphics g) {\n        if(type == EntityType.AsitliZombiEfekt) g.setColor(new Color(0, 255, 0, 80));\n        else if(type == EntityType.RoketatarEfekt) g.setColor(new Color(255, 80, 30, 80));\n\n        g.fillRect(x, y, width, height);\n    }\n\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, width, height);\n    }\n}\n",
      "Bullet.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Bullet extends GameObject {\n\n    private Handler handler;\n    private double bulletSpeed;\n    private double angle;\n\n\n    public Bullet(int x, int y, EntityType type, Handler handler, double angle) {\n        super(x, y, type);\n        this.handler = handler;\n        this.angle = angle;\n        this.bulletSpeed = Player.gun.speed;\n    }\n\n    @Override\n    public void tick() {\n        x += bulletSpeed * Math.cos(angle);\n        y += bulletSpeed * Math.sin(angle);\n\n        for(int i = 0; i<handler.entities.size(); i++) {\n\n            GameObject anyObject = handler.entities.get(i);\n\n            if(anyObject instanceof Block) {\n\n                if(getBounds().intersects(anyObject.getBounds())){\n                    handler.removeEntity(this);\n\n                    if(Player.gun.type == GunType.Roketatar) {\n                        Rectangle etkiAlani = new Rectangle(\n                            anyObject.getX()-75,\n                            anyObject.getY()-75,\n                            150,\n                            150\n                        );\n\n                        for(int j=0; j<handler.entities.size(); j++) {\n                            GameObject temp = handler.entities.get(j);\n\n                            if(temp instanceof Zombie && temp.getBounds().intersects(etkiAlani)) {\n                                ((Zombie)temp).setHealth(((Zombie)temp).getHealth() - 3);\n                            }\n\n                            else if(temp.getType() == EntityType.Block && temp.getBounds().intersects(etkiAlani)) {\n                                handler.removeEntity(temp);\n                            }\n\n                        }\n\n                        handler.addEntity(new BombEffect(anyObject.getX()-75, anyObject.getY()-75, EntityType.RoketatarEfekt, 150, 150, 60, handler));\n                    }\n\n                }\n                    \n            }\n\n        }\n\n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(Color.BLACK);\n        g.fillOval(x, y, 8, 8);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 8,8);\n    }\n    \n}\n",
      "YedekSarjor.java": "import java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.Color;\n\n\npublic class YedekSarjor extends GameObject{\n\n    public YedekSarjor(int x, int y, EntityType type) {\n            super(x, y, type);\n    }\n    \n        @Override\n    public void render(Graphics g) {\n        g.setColor(new Color(79,158,138,200));\n        g.fillRect(x, y, 20, 30);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x,y,20,30);\n    }\n\n    @Override\n    public void tick() {\n        //boş hareketsiz çünkü\n    }\n}\n",
      "ZombieAsitli.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class ZombieAsitli extends Zombie {\n    \n    public ZombieAsitli(int x, int y, EntityType type, Handler handler) {\n        super(x, y, type, handler);\n        health = 2;\n        attack = 2;\n    }\n    \n    \n    @Override\n    protected double getSpeed() {\n        return 3.0;\n    }\n\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(new Color(39,100,42,230));\n        g.fillOval(x, y, 32, 32);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x,y,32,32);\n    }\n}\n",
      "GunType.java": "\npublic enum GunType{\n    Tabanca,\n    Piyade,\n    Pompali,\n    KeskinNisanci,\n    Roketatar\n}\n",
      "Block.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Block extends GameObject{\n\n    int width = 32;\n    int height = 32;\n\n    public Block(int x, int y, EntityType type) {\n            super(x, y, type);\n        }\n    \n    @Override\n    public void tick() {\n        //boş\n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(new Color(123, 98, 145,205));\n        g.fillRect(x, y, 32, 32);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 32,32);\n    }\n    \n}\n",
      "Collision.java": "import java.awt.Rectangle;\n\npublic class Collision {\n\n    public static void checkSomeCollision(GameObject entity, Handler handler) {\n\n        if(!(entity instanceof Player || entity instanceof Zombie)) return;\n        \n        for (int i = 0; i < handler.entities.size(); i++) {\n            GameObject anyObject = handler.entities.get(i);\n        \n            if (anyObject.getType() == EntityType.Block || anyObject.getType() == EntityType.KirilmazBlock) {\n                Rectangle blockBounds = anyObject.getBounds();\n                Rectangle entityBounds = entity.getBounds();\n        \n                boolean yatayCollision = false;\n        \n                Rectangle nextYBounds = new Rectangle(\n                    entityBounds.x,\n                    entityBounds.y + (int)entity.getSpeed_Y(),\n                    entityBounds.width,\n                    entityBounds.height\n                );\n\n                Rectangle nextXBounds = new Rectangle(\n                        entityBounds.x + (int)entity.getSpeed_X(),\n                        entityBounds.y,\n                        entityBounds.width,\n                        entityBounds.height\n                    );\n        \n                if (nextYBounds.intersects(blockBounds)) {\n                    yatayCollision = true; //çarpışmaların karışmaması için\n        \n                    if (entity.getSpeed_Y() > 0) {\n                        entity.setY(blockBounds.y - entityBounds.height - 5);\n                    } else if (entity.getSpeed_Y() < 0) {\n                        entity.setY(blockBounds.y + blockBounds.height + 5);\n                    }\n                    entity.setSpeed_Y(0); \n                }\n        \n                if (!yatayCollision) { \n                    if (nextXBounds.intersects(blockBounds)) {\n        \n                        if (entity.getSpeed_X() > 0) {\n                            entity.setX(blockBounds.x - entityBounds.width - 5);\n                        } else if (entity.getSpeed_X() < 0) { \n                            entity.setX(blockBounds.x + blockBounds.width + 5);\n                        }\n                        entity.setSpeed_X(0); \n                    }\n                }\n            }\n        \n            if (anyObject.getType() == EntityType.Bullet && entity instanceof Zombie) {\n                Zombie tempZombie = (Zombie)entity;\n                if(entity.getBounds().intersects(anyObject.getBounds())) {\n                    \n                    //keskin nişancı için mermi yok edilmez,\n                    //merminin değdiği zombiler büyük hasar alır hepsi direkt ölür\n                    //mermi aynı güçte ilerler varsayımı\n                    if(Player.gun.type != GunType.KeskinNisanci) {\n                        handler.removeEntity(anyObject);\n                        Player.setScore(Player.getScore() + 5);\n                    }\n\n                    else{\n                        ((Zombie)entity).setHealth(((Zombie)entity).getHealth() - 5);\n                        Player.setScore(Player.getScore() + 5);\n\n                    }\n                        \n\n\n                    if(Player.gun.type == GunType.Roketatar) {\n                        tempZombie.setHealth(tempZombie.getHealth() -3);\n                        Player.setScore(Player.getScore() + 3);\n                        //mermi kimin kafasına geldiyse ona 3 hasar\n\n                        //patlamanın etki edeceği alan\n                        Rectangle etkiAlani = new Rectangle(\n                            anyObject.getX()-100,\n                            anyObject.getY()-100,\n                            200,\n                            200\n                        );\n\n                        for(int j=0; j<handler.entities.size(); j++) {\n                            GameObject temp = handler.entities.get(j);\n                            if(temp instanceof Zombie && temp.getBounds().intersects(etkiAlani)) {\n                                ((Zombie)temp).setHealth(((Zombie)temp).getHealth() - 2);\n                                //alandaki her zombiye ikişer hasar\n                                Player.setScore(Player.getScore() + 2);\n                            }\n\n                            else if(temp.getType() == EntityType.Block && temp.getBounds().intersects(etkiAlani)) {\n                                handler.removeEntity(temp);\n                            }\n                        }\n\n                        handler.addEntity(new BombEffect(anyObject.getX()-100, anyObject.getY()-100, EntityType.RoketatarEfekt, 200, 200, 60, handler));\n                    }\n\n                    else {\n                        tempZombie.setHealth(tempZombie.getHealth() - 1);\n                        Player.setScore(Player.getScore() + 1);\n                    }\n                }\n            }\n\n            if (anyObject.getType() == EntityType.Asit && entity instanceof Player) {\n                if(entity.getBounds().intersects(anyObject.getBounds())) {\n                    handler.removeEntity(anyObject);\n                    Player.setHealth(Player.getHealth() - 8);\n                }\n            }\n\n            if (entity instanceof Player && anyObject instanceof Zombie) {\n                if(entity.getBounds().intersects(anyObject.getBounds())) {\n                    Player.setHealth(Player.getHealth() - 0.01 * ((Zombie)anyObject).getAttack());\n                }\n            }\n        \n            if (anyObject.getType() == EntityType.YedekSarjor && entity instanceof Player) {\n                if(entity.getBounds().intersects(anyObject.getBounds())) {\n                    Player.gun.yedekSarjor++;\n                    handler.removeEntity(anyObject);\n                }\n                \n            }\n        }\n        \n        \n    }\n}\n",
      "KeyboardInput.java": "import java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\npublic class KeyboardInput extends KeyAdapter{\n\n    Handler handler;\n    static long ReloadCurrentTime;\n\n    public KeyboardInput(Handler handler) {\n        this.handler = handler;\n    }\n\n\n\n    public void keyPressed(KeyEvent e) {\n        int key = e.getKeyCode();\n\n        if(key == KeyEvent.VK_R) {\n            ReloadCurrentTime = System.currentTimeMillis();\n            handler.fillTheMagazine();\n            }\n\n        \n        if(key == KeyEvent.VK_W) handler.setUp(true);\n        if(key == KeyEvent.VK_A) handler.setLeft(true);\n        if(key == KeyEvent.VK_D) handler.setRight(true);\n        if(key == KeyEvent.VK_S) handler.setDown(true);\n        \n    }\n\n    public void keyReleased(KeyEvent e) {\n        int key = e.getKeyCode();\n\n        for(int i=0; i < handler.entities.size() ; i++) {\n            GameObject temp = handler.entities.get(i);\n\n            if (temp.getType() == EntityType.Player) {\n\n                if(key == KeyEvent.VK_W) handler.setUp(false);\n                if(key == KeyEvent.VK_A) handler.setLeft(false);\n                if(key == KeyEvent.VK_D) handler.setRight(false);\n                if(key == KeyEvent.VK_S) handler.setDown(false);\n\n            }\n        }\n    }\n}\n",
      "Handler.java": "import java.util.LinkedList;\nimport java.awt.Graphics;\nimport java.io.Serializable;\n\npublic class Handler implements Serializable{\n    LinkedList<GameObject> entities = new LinkedList<GameObject>();\n    \n    private boolean up = false, down = false, right = false, left = false;\n\n    public void fillTheMagazine() {\n        if(Player.gun.yedekSarjor <= 0 && Player.gun.type != GunType.Tabanca) {\n            MouseInput.isReloading = false;\n            return;\n        }\n\n        MouseInput.isReloading = true;        \n        Player.setMagazine(Player.getmax_magazine());\n        Player.gun.yedekSarjor--;\n    }\n\n    public void tick() {\n        for(int i=0; i<entities.size(); i++) {\n            entities.get(i).tick();\n        }\n    }\n\n    public void render(Graphics g) {\n        for(int i=0; i<entities.size(); i++) {\n            entities.get(i).render(g);\n        }\n    }\n\n    public void addEntity(GameObject newObj) {\n        entities.add(newObj);\n    }\n\n    public void removeEntity(GameObject Entity) {\n        entities.remove(Entity);\n    }\n\n\n    public boolean isUp() {\n        return up;\n    }\n    public void setUp(boolean set) {\n        this.up = set;\n    }\n\n    public boolean isDown() {\n        return down;\n    }\n    public void setDown(boolean set) {\n        this.down = set;\n    }\n\n    public boolean isRight() {\n        return right;\n    }\n    public void setRight(boolean set) {\n        this.right = set;\n    }\n\n    public boolean isLeft() {\n        return left;\n    }\n    public void setLeft(boolean set) {\n        this.left = set;\n    }\n\n}\n",
      "ZombieNormal.java": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class ZombieNormal extends Zombie{\n\n    public ZombieNormal(int x, int y, EntityType type, Handler handler) {\n        super(x, y, type, handler);\n        health = 3;\n        attack = 2; //orta sağlık orta hasar\n    }\n\n    @Override\n    protected double getSpeed() {\n        return 3.0;\n    }\n\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(new Color(76,92,75,230));\n        g.fillOval(x, y, 32, 32);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x,y,32,32);\n    }\n    \n}\n",
      "BufferedImageLoader.java": "import java.awt.image.BufferedImage;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class BufferedImageLoader {\n\n    private BufferedImage image;\n\n    public BufferedImage loadImage(String path) {\n        try {\n            image = ImageIO.read(getClass().getResource(path));\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return image;\n    }\n}\n",
      "SoundPlayer.java": "import javax.sound.sampled.*;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n\n//sesi çekebilmek için internetten fazlasıyla yararlandım.\npublic class SoundPlayer {\n\n    private Clip clip;\n\n    public SoundPlayer(String filePath) {\n        try {\n            InputStream audioSrc = getClass().getResourceAsStream(filePath);\n            if (audioSrc == null) {\n                throw new IllegalArgumentException(\"Ses dosyası bulunamadı!\");\n            }\n            AudioInputStream audioStream = AudioSystem.getAudioInputStream(new BufferedInputStream(audioSrc));\n\n            clip = AudioSystem.getClip();\n            clip.open(audioStream);\n        } catch (UnsupportedAudioFileException | IOException | LineUnavailableException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void play() {\n        if (clip != null) {\n            clip.setFramePosition(0);\n            clip.start();\n        }\n    }\n\n    public void loop() {\n        if (clip != null) {\n            clip.loop(Clip.LOOP_CONTINUOUSLY);\n        }\n    }\n\n    public void stop() {\n        if (clip != null) {\n            clip.stop();\n        }\n    }\n}\n",
      "Game.java": "\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferStrategy;\nimport java.awt.image.BufferedImage;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport javax.swing.JOptionPane;\nimport java.awt.Font;\nimport java.awt.Canvas;\n\npublic class Game extends Canvas implements Runnable{\n\n    public boolean isRunning = false;\n    public Thread thread;\n\n    private Handler handler;\n    private Camera camera;\n    private BufferedImage map = null;\n    public static Player player;\n\n    public KeyboardInput ki;\n    public MouseInput mi;\n    public boolean isSong = false;\n\n    private boolean [] dalga = new boolean[12];\n    public static boolean dalgaBittiYazisi;\n\n    public static int tour = 0;\n    public static int zombieIndex = 0;\n\n    public Player.gun silah;\n\n    public Game() {\n        SoundPlayer theDinerMusic = new SoundPlayer(\"/res/theDinerMusic.wav\");\n        theDinerMusic.loop();\n        isSong = true;\n\n        handler = new Handler();\n        camera = new Camera(0, 0);\n        new Window(1000, 563, \"TheDINER\", this, thread, theDinerMusic);\n    \n    \n        BufferedImageLoader loader = new BufferedImageLoader();\n        map = loader.loadImage(\"/res/theDiner_map.png\");\n    \n        \n        loadMap(map);\n    \n        \n        start();\n    \n        \n        player = new Player(100, 100, EntityType.Player, handler);\n        handler.addEntity(player);\n\n        silah = new Player.gun();\n\n        ki = new KeyboardInput(handler);\n        mi = new MouseInput(handler, camera, this, player);\n\n        //load esnasında bunların silinebilmesi için ki mi olarak tuttum\n        this.addKeyListener(ki);\n        this.addMouseListener(mi);\n        this.addMouseMotionListener(mi);\n\n        for (; tour < 12; tour++) {\n            dalga[tour] = true;\n        \n            if (tour == 0) Player.gun.setGun(GunType.Tabanca);\n\n            else if (tour == 1) {\n                //nedenini bilmediğim bi şekilde silahı Piyade olarak set etmeme rağmen\n                //ilk mermi atışlarında hız güncellenmiyodu\n                //senkronize etmeyle alakalı bir şeydi ama bulamadım problemimi\n                //bu yüzden bu kısımda manuel olarak atış hızını da güncelledim ve düzeldi\n                //diğer silah geçişlerde hiçbir sıkıntı yok bu geçişte neden oldu bilmiyorum..\n                MouseInput.magazine_period = 60*1000/600;\n                Player.gun.setGun(GunType.Piyade);\n            }\n\n            else if (tour == 3) Player.gun.setGun(GunType.Pompali);\n            else if (tour == 5) Player.gun.setGun(GunType.KeskinNisanci);\n            else if (tour == 10) Player.gun.setGun(GunType.Roketatar);\n        \n            int zombieCount = 8 + (int) (tour * 1.1); //zombi sayısı artsın\n            int sleepTime = Math.max(600, 1200 - (tour * 60)); //sleeping düşsün\n        \n            for (; zombieIndex< zombieCount; zombieIndex++) {\n                try {\n                    Thread.sleep(sleepTime);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n        \n                if (zombieIndex%4 == 3) {\n                    handler.addEntity(new ZombieSurunge(1080, 300, EntityType.SurungeZombi, handler));\n                } else if (zombieIndex%4 == 1) {\n                    handler.addEntity(new ZombieAsitli(600, 550, EntityType.AsitTukurenZombi, handler));\n                    if (tour >= 3)\n                    handler.addEntity(new ZombieTank(600, 350, EntityType.TankZombi, handler));\n                } else if (zombieIndex%4 == 0){\n                    handler.addEntity(new ZombieNormal(530, 548, EntityType.NormalZombi, handler));\n                } else {\n                    if(tour>4 && tour%16 == 1)\n                        handler.addEntity(new ZombieAsitli(1200, 850, EntityType.AsitTukurenZombi, handler));\n                    else if(tour>4 && tour%16 == 3)\n                        handler.addEntity(new ZombieSurunge(1200, 850, EntityType.SurungeZombi, handler));\n                }\n                if (tour >= 3 && zombieIndex%16 == 4) { //tank zombiler daha da gelmeye başlasın\n                    handler.addEntity(new ZombieTank(650, 360-(tour*6), EntityType.TankZombi, handler));\n                }\n            }\n            \n        \n            while (dalga[tour]) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n        \n                boolean zombiVarMi = false;\n                for (int i = 0; i<handler.entities.size();i++) {\n                    GameObject e = handler.entities.get(i);\n                    if (e instanceof Zombie) {\n                        zombiVarMi = true;\n                        break;\n                    }\n                }\n        \n                if (!zombiVarMi) {\n                    if (dalga[11] == true){\n                        JOptionPane.showMessageDialog(null, \"12 turu da başarıyla tamamladın! toplam skor: \" + Player.getScore(), \"you ate\", JOptionPane.PLAIN_MESSAGE);\n                        System.exit(0);\n                    }\n                    break;\n                }\n            }\n\n            zombieIndex = 0;\n        \n            dalgaBittiYazisi = true;\n        \n            try {\n                Thread.sleep(3000); //3 sn ara\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            dalga[tour] = false;\n            dalgaBittiYazisi = false;\n        }\n\n\n\n    }\n    public void resumeGame() {\n        isRunning = true;\n    }\n\n    void start() {\n        isRunning = true;\n        thread = new Thread(this);\n        thread.start();\n    }\n\n    private void stop() {\n        isRunning = false;\n        try {\n            thread.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        handler.setDown(false);\n        handler.setLeft(false);\n        handler.setRight(false);\n        handler.setUp(false);\n\n        this.requestFocus();\n        long lastTime = System.nanoTime();\n        int FPS = 60;\n        double ns = 1000000000 / (double)FPS;\n        double delta = 0;\n        \n        long timer = System.currentTimeMillis();\n        @SuppressWarnings(\"unused\")\n        int frames = 0;\n        while(isRunning) {\n            long now = System.nanoTime();\n            delta += (now - lastTime) / ns;\n            lastTime = now;\n\n            while(delta >= 1) {\n                tick();\n                delta--;\n            }\n\n            render();\n            frames++;\n\n            if(System.currentTimeMillis() - timer > 1000) {\n                timer += 1000;\n                frames = 0;\n            }\n        }\n        stop();\n    }\n    \n    public void tick() {\n        camera.tick(player); //kamera kayması\n        handler.tick();     //tüm varlıklar için tick\n    }\n\n    public void render() {\n        BufferStrategy bs = this.getBufferStrategy();\n        if (bs == null) {\n            this.createBufferStrategy(3);\n            return;\n        }\n\n        Graphics g = bs.getDrawGraphics();\n        Graphics2D g2d = (Graphics2D) g;\n\n        //DRAW DRAAW DRAAW\n\n        g.setColor(new Color(225, 225, 235, 240));\n        g.fillRect(0, 0, 1000, 563);\n\n        g2d.translate(-camera.getX(), -camera.getY());\n\n        handler.render(g);\n\n        g2d.translate(camera.getX(), camera.getY());\n\n        String healthText = \"Toplam Kalan Can: \" + String.format(\"%.1f\",  Player.getHealth());\n        String scoreText = \"Toplam Skor: \" + Player.getScore();\n        String yedekText = \"Yedek Şarjörün: \";\n        String reloadingWarnText = \"ŞARJÖR DEĞİŞTİRİLİYOR...\";\n        String dalgaWarn = \"Zombi Dalga\";\n        String dalgaBittiWarn = \"tebrikler, sonraki dalga için hazırlan!\";\n\n        g.setColor(Color.BLACK);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 18));\n        int padding = 10;\n        g.drawString(healthText, getWidth() - g.getFontMetrics().stringWidth(healthText) - padding, 20);\n        g.drawString(scoreText, getWidth() - g.getFontMetrics().stringWidth(scoreText) - padding, 50);\n\n        g.drawString(\"Elindeki Silah: \" + Player.gun.type.toString() + \" /// Şarjör: \" + Player.getMagazine(), padding, 20);\n\n        if(Player.gun.type == GunType.Tabanca) {\n            g.drawString(yedekText + \"sınırsız!\", padding, 50);\n        }\n        else {\n            g.drawString(yedekText + + Player.gun.yedekSarjor + \" adet\", padding, 50);   \n        }\n        \n\n\n        //şarjör değiştirme yazısı ayarları\n        long currentTime = System.currentTimeMillis();\n        if (currentTime - KeyboardInput.ReloadCurrentTime < 1000) MouseInput.isReloading = true;\n        else MouseInput.isReloading = false;\n        if(MouseInput.isReloading && (Player.gun.yedekSarjor > 0 || Player.gun.type == GunType.Tabanca)) \n            g.drawString(reloadingWarnText, padding, 80);\n        else if(Player.gun.yedekSarjor <= 0 && Player.gun.type != GunType.Tabanca)\n            g.drawString(\"reload yapılamaz...\", padding, 80);\n        \n\n        //ateş için hazırlanma süresi uyarısı\n        //piyade ve tabanca için yazmasını istemedim, hızlılar zaten\n        if (currentTime - MouseInput.lastShotTime < MouseInput.magazine_period) MouseInput.isTime = true;\n        else MouseInput.isTime = false;\n        if (MouseInput.isTime /*&& Player.gun.type != GunType.Piyade && Player.gun.type != GunType.Tabanca*/) \n            g.drawString(\"Ateş etmek için \" + (MouseInput.magazine_period - (double)(currentTime - MouseInput.lastShotTime))/1000+ \" saniye daha bekle. \", padding, 100);\n        \n        \n        \n        g.setFont(new Font(\"Arial\", Font.BOLD | Font.ITALIC, 21));\n        padding = 450;\n        for(int i=0;i<dalga.length;i++) {\n\n            if(dalgaBittiYazisi) {\n                g.drawString(dalgaBittiWarn, getWidth() - g.getFontMetrics().stringWidth(scoreText) - padding + 20, 30);\n                if(dalga[0] || dalga[2] || dalga[4] || dalga[9]) {\n                    g.drawString(\"kullandığın silah güncellendi.\", getWidth() - g.getFontMetrics().stringWidth(scoreText) - padding + 20, 60);\n                }\n            }\n\n            else if(dalga[i]) {\n                g.drawString(dalgaWarn+\" \"+(i+1), getWidth() - g.getFontMetrics().stringWidth(scoreText) - padding + 60, 30);\n            }\n        }\n        \n        //draw DRAWWWWWWWWWW biti\n\n        g.dispose();\n        bs.show();\n\n    }\n\n    private void loadMap(BufferedImage image) {\n        int weight = image.getWidth();\n        int height = image.getHeight();\n\n        for(int w=0; w<weight; w++) {\n            for(int h=0; h<height; h++) {\n                int pixel = image.getRGB(w, h);\n                int red = (pixel >> 16) & 0xff;\n                int green = (pixel >> 8) & 0xff;\n                int blue = (pixel) & 0xff;\n            \n\n            if(red == 255 && green == 0 && blue == 0)\n                handler.addEntity(new Block(w*32, h*32, EntityType.Block));\n\n            if(red == 255 && green == 100 && blue == 0) {\n                handler.addEntity(new Block(w*32, h*32, EntityType.KirilmazBlock));\n            }\n            }\n        }\n    }\n\n\n    public static void main(String[] args) {\n        new Game();\n    }\n\n    void readDatasToSave(GameSave newSave) {\n        newSave.player = Game.player;\n\n        newSave.camera = camera;\n\n        newSave.playerHealth = Player.getHealth();\n        newSave.playerScore = Player.getScore();\n\n        newSave.dalga = dalga;\n\n        newSave.handler = handler;\n\n        newSave.tour = Game.tour;\n        newSave.zombieIndex = Game.zombieIndex;\n        \n\n        newSave.gunType = Player.gun.type;\n    }\n\n    GameSave savedDatasToImply() {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"oyunKaydi.ser\"))) {\n        return (GameSave) ois.readObject();\n        } catch (ClassNotFoundException e) {\n            System.out.println(\"KAYDEDILMIS DOSYA YOK.\");\n            return null;\n        }\n        catch (IOException e) {\n            e.getMessage();\n            return null;\n        }\n    }\n\n    void updateDatas(GameSave kayitli) {\n        Game.player = kayitli.player;\n\n        try{\n            player.loadPlayerIcon();\n        } catch (Exception e) {\n            System.out.println(\"player görüntüsü yüklenemedi, kırmızı kutu olarak devam et\");\n        }\n        \n\n        camera = kayitli.camera;\n\n        Player.setHealth(kayitli.playerHealth);\n        Player.setScore(kayitli.playerScore);\n\n        dalga = kayitli.dalga;\n\n        handler = kayitli.handler;\n        handler.setDown(false);\n        handler.setLeft(false);\n        handler.setRight(false);\n        handler.setUp(false);\n        //gereksiz hareketleri önlemesi için handlerdaki değerleri false ladık.\n\n        this.removeKeyListener(ki);\n        this.removeMouseListener(mi);\n        this.removeMouseMotionListener(mi);\n        //tüm listenerleri silip yeni handler ve player için tekrardan ekliyorum\n        ki = new KeyboardInput(handler);\n        mi = new MouseInput(handler, camera, this, player);\n\n        this.addKeyListener(ki);\n        this.addMouseListener(mi);\n        this.addMouseMotionListener(mi);\n\n        Game.tour = kayitli.tour;\n        Game.zombieIndex = kayitli.zombieIndex;\n\n        Player.gun.setGun(kayitli.gunType);\n    }\n\n    \n}",
      "MouseInput.java": "\n//AÇIKLAMA\n//bullet atma kontrolü üzerinde gerçekten çok uzun zaman uğraştım\n//basılı tutarak atmayı düzeltsem başka bir şey bozuluyordu vs..\n//o yüzden MouseInput dosyasında çok fazla dışarıdan kaynak kullandım, Timer Component vs şahsen doğrudan yaptığım şeyler değil.\n\nimport java.awt.*;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.io.Serializable;\nimport java.util.Random;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\npublic class MouseInput extends MouseAdapter implements Serializable{\n\n    private Handler handler;\n    private boolean isPressed = false;\n    private Timer timer;\n    private Camera camera;\n    private TimerTask shootTask;\n    public static long lastShotTime = 0;\n    private Component gameComponent;\n    private Player player;\n    public static long magazine_period;\n    \n    public static boolean isReloading;\n    public static boolean isTime;\n    //bunlar ekrana yazdırılması gerekecek şeyler için statikler\n\n\n    public MouseInput(Handler handler, Camera camera, Component gameComponent, Player player) {\n        this.handler = handler;\n        this.gameComponent = gameComponent;\n        this.player = player;\n        this.camera = camera;\n        timer = null;\n    }\n\n    public void mousePressed(MouseEvent e) {\n        isPressed = true;\n        startShooting();\n    }\n\n    public void mouseReleased(MouseEvent e) {\n        isPressed = false;\n        stopShooting();\n    }\n\n    private void shoot() {\n        MouseInput.magazine_period = 60 * 1000 / Player.getFire();\n\n        long currentTime = System.currentTimeMillis();\n\n        long seconds = currentTime - lastShotTime;\n        MouseInput.isTime = seconds < magazine_period;\n\n\n        if (!isPressed || MouseInput.isTime|| isReloading || Player.getMagazine() <= 0) {\n            return;\n        }\n\n        lastShotTime = currentTime;\n\n        //mouse konumunu net alabilmek için\n        Point p = gameComponent.getMousePosition();\n        if (p == null) return;\n        int mouse_x = (int) (p.x + camera.getX());\n        int mouse_y = (int) (p.y + camera.getY());\n\n        \n        double angle = Math.atan2(mouse_y - player.getY(), mouse_x - player.getX());\n\n        //tabanca keskin nişancı ve roketatar için yalnızca mermi atımı/güncellemesi\n        //delme olayını colissionda bullet yok etmede halledicem keskin nişanc için\n        //patlama olayı da aynı şekilde.\n\n\n        //piyade için sapmaya göre angle güncellenir\n        if(Player.gun.type == GunType.Piyade) {\n            Random random = new Random();\n            double max = 30.0;\n            double sapma = Math.toRadians((random.nextDouble()* 2 * max)-max);\n\n            angle += sapma;\n\n            handler.addEntity(new Bullet(player.getX() + 16, player.getY() + 24, EntityType.Bullet, handler, angle));\n            Player.setMagazine(Player.getMagazine()-1);\n        }\n\n        else if(Player.gun.type == GunType.Tabanca ||\n            Player.gun.type == GunType.KeskinNisanci ||\n            Player.gun.type == GunType.Roketatar) {\n            handler.addEntity(new Bullet(player.getX() + 16, player.getY() + 24, EntityType.Bullet, handler, angle));\n            Player.setMagazine(Player.getMagazine()-1);\n        }\n\n\n        //pompalı için 9 tane aralıklı atar\n        else if(Player.gun.type == GunType.Pompali) {\n            double angleFark = Math.toRadians(45) / 8; //5 derece\n\n            for (int i = 0; i < 9; i++) {\n                double bulletAngle = angle - Math.toRadians(22.5) + (i * angleFark);\n                handler.addEntity(new Bullet(player.getX() + 16, player.getY() + 24, EntityType.Bullet, handler, bulletAngle)); \n            }\n            Player.setMagazine(Player.getMagazine()-1);\n        }\n\n    }\n\n    //herhangi bi press durumunda timer başlatılır, bu sayede tek tık ve basılı tutma için de mermi atımı\n    //optimize edilmiş olur\n    private void startShooting() {\n        if (timer == null) {\n\n            timer = new Timer();\n            shootTask = new TimerTask() {\n                @Override\n                public void run() {\n                    shoot();\n                }\n            };\n            timer.scheduleAtFixedRate(shootTask, 0, magazine_period+15);\n        }\n    }\n\n    private void stopShooting() {\n        if (timer != null) {\n            timer.cancel();\n            timer = null;\n            shootTask = null;\n        }\n    }\n}\n\n\n\n\n",
      "EntityType.java": "public enum EntityType {\n    \n    Player(),\n    Block(),\n    KirilmazBlock(),\n    Bullet(),\n    NormalZombi(),\n    SurungeZombi(),\n    TankZombi(),\n    AsitTukurenZombi(),\n    Asit(),\n    AsitliZombiEfekt(),\n    RoketatarEfekt(),\n    YedekSarjor();\n    //iki efekt tipine göre renkleri farklı olcak\n\n}\n",
      "Acyd.java": "import java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.Color;\n\npublic class Acyd extends GameObject{\n    private Handler handler;\n    private double acydSpeed;\n    private double angle;\n\n    public Acyd(int x, int y, EntityType type, Handler handler,Player player) {\n        super(x, y, type);\n        this.handler = handler;\n        acydSpeed = 6;\n        angle = Math.atan2(player.getY() - y, player.getX() - x);\n    }\n\n    @Override\n    public void tick() {\n        x += acydSpeed * Math.cos(angle);\n        y += acydSpeed * Math.sin(angle);\n        \n        for(int i = 0; i<handler.entities.size(); i++) {\n\n            GameObject anyObject = handler.entities.get(i);\n\n            if(anyObject.getType() == EntityType.Block) {\n\n                if(getBounds().intersects(anyObject.getBounds())){\n                    handler.removeEntity(this);\n                }\n                    \n            }\n\n        }\n    }\n\n    @Override\n    public void render(Graphics g) {\n        g.setColor(new Color(0,100,0,240));\n        g.fillOval(x, y, 8, 8);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, 8,8);\n    }\n    \n}\n",
      "Camera.java": "import java.io.Serializable;\n\npublic class Camera implements Serializable{\n    \n    private float x;\n    private float y;\n\n    public Camera(float x, float y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void tick(GameObject anyObject) {\n        x += ((anyObject.getX() - x) - 1000/2) * 0.05f;\n        y += ((anyObject.getY() - y) - 563/2) * 0.05f;\n        //internetten alındı, smooth olarak geçmesi için\n\n        if( x<=0 ) x=-4;\n        if( x>=1032 ) x = 1032;\n        if( y<=0 ) y=0;\n        if( y>=579 ) y=579;\n    }\n\n    public float getX() {\n        return x;\n    }\n\n    \n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public float getY() {\n        return y;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n}\n",
      "Window.java": "import javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\n\nimport java.awt.BorderLayout;\nimport java.awt.Dimension;\nimport java.awt.FlowLayout;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nimport java.io.ObjectOutputStream;\n\npublic class Window{\n    \n    public Window(int width, int height, String title, Game game, Thread thread, SoundPlayer sp) {\n\n        JFrame frame = new JFrame(title);\n        frame.setPreferredSize(new Dimension(width, height));\n        frame.setMaximumSize(new Dimension(width, height));\n        frame.setMinimumSize(new Dimension(width, height));\n\n        frame.setResizable(false);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setLocationRelativeTo(null);\n\n        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER)); // Ortaya hizala\n\n        JLabel infoLabel = new JLabel(\"Oyun Kontrolleri: \");\n        JButton pauseButton = new JButton(\"Duraklat\");\n        JButton resumeButton = new JButton(\"Devam et\");\n        JButton saveButton = new JButton(\"Kaydet\");\n        JButton loadButton = new JButton(\"Yükle(Kaydedilen Varsa)\");\n        JButton musicButton = new JButton(\"Müziği Kapat/Aç\");\n\n        buttonPanel.add(infoLabel);\n        buttonPanel.add(pauseButton);\n        buttonPanel.add(resumeButton);\n        buttonPanel.add(saveButton);\n        buttonPanel.add(loadButton);\n        buttonPanel.add(musicButton);\n\n        pauseButton.addActionListener(e -> {\n            game.isRunning = false;\n            if (thread != null) {\n                try {\n                    thread.join();\n                } catch (InterruptedException k) {\n                    k.printStackTrace();\n                    }\n            }\n            \n        }\n        );\n\n\n        resumeButton.addActionListener(e -> {\n            if (!game.isRunning) {\n                game.isRunning = true;\n                game.thread = new Thread(game);\n                game.thread.start();\n            }\n        });\n\n        \n\n\n        saveButton.addActionListener(e -> {\n            GameSave newSave = new GameSave();\n\n            //yazılacak save dosyasına verileri girmek için\n            game.readDatasToSave(newSave);\n\n            //dosyaya yazz\n            try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"oyunKaydi.ser\"))) {\n                oos.writeObject(newSave);\n                System.out.println(\"oyun başarıyla kaydedildi\");\n            } catch (IOException io) {\n                io.printStackTrace();\n                }\n\n        });\n\n        loadButton.addActionListener(e -> {\n            //dosyayı gamesave objesine oku\n            GameSave kayitli = game.savedDatasToImply();\n\n            //oyunda güncellenmesi gereken her şeyi güncelle\n            game.updateDatas(kayitli);\n\n        });\n\n        musicButton.addActionListener(e -> {\n            if(game.isSong) {\n                sp.stop();\n                game.isSong = false;\n            }\n            else {\n                sp.play();\n                game.isSong = true;\n            }\n        });\n\n        frame.add(buttonPanel, BorderLayout.SOUTH); // Butonları aşağıya ekle\n        frame.add(game, BorderLayout.CENTER); // Oyun alanını ortada tut\n        frame.setVisible(true);\n        \n    }    \n}",
      "Player.java": "\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport javax.swing.JOptionPane;\n\npublic class Player extends GameObject{\n\n    Handler handler;\n    int width = 64;\n    int height = 64;\n\n    private static double health = 1000;\n    private static int score = 0;\n    public transient BufferedImage ikon;\n\n    \n    public Player(int x, int y, EntityType type, Handler handler) {\n        super(x, y, type);\n        this.handler = handler;\n        \n        loadPlayerIcon();\n    }\n\n    public void loadPlayerIcon() {\n        BufferedImageLoader loader = new BufferedImageLoader();\n        ikon = loader.loadImage(\"/res/ikon.png\");\n    }\n\n    public static class gun {\n\n        protected static int max_magazine;\n        protected static int magazine;\n        protected static int fire;\n        protected static GunType type;\n        \n        protected static int yedekSarjor;\n        protected static double speed;\n        \n        public gun()\n            {\n                //obje oluşturulurken tabanca ile başlanır\n                max_magazine = 12;\n                magazine = 12;\n                fire = 120;\n                type = GunType.Tabanca;\n                speed = 7;\n            }\n        \n        public static void setGun(GunType type) {\n            gun.type = type;\n            if(type == GunType.Tabanca) {\n                max_magazine = 12;\n                magazine = 12;\n                fire = 120;\n                speed = 7; //kontrol edilmeyecek - sonsuz\n                }\n            \n            else if(type == GunType.Piyade) {\n                max_magazine = 30;\n                magazine = 30;\n                fire = 600;\n                speed = 8;\n                yedekSarjor = 2;\n            }\n\n            else if(type == GunType.Pompali) {\n                max_magazine = 5;\n                magazine = 5;\n                fire = 60;\n                speed = 10;\n                yedekSarjor = 3;\n            }\n\n            else if(type == GunType.KeskinNisanci) {\n                max_magazine = 5;\n                magazine = 5;\n                fire = 30;\n                speed = 13;\n                yedekSarjor = 4;\n            }\n\n            else if(type == GunType.Roketatar) {\n                max_magazine = 1;\n                magazine = 1;\n                fire = 10;\n                speed = 10;\n                yedekSarjor = 5;\n            }\n        }\n    }\n\n    public static int getmax_magazine() {\n        return gun.max_magazine;\n    }\n\n    public static int getMagazine() {\n        return gun.magazine;\n    }\n\n    public static void setMagazine(int magazine) {\n        gun.magazine = magazine;\n    }\n\n    public static int getFire() {\n        return gun.fire;\n    }\n\n    public static void setFire(int fire) {\n        gun.fire = fire;\n    }\n\n\n    @Override\n    public void tick() {\n        if(Player.health <= 0) {\n            JOptionPane.showMessageDialog(null, \"öldün malesef :)) gbye\", \"goodbye\", JOptionPane.ERROR_MESSAGE);\n            System.exit(0);\n        }\n\n        x += speed_X;\n        y += speed_Y;\n\n        Collision.checkSomeCollision(this,handler);\n\n        if(handler.isUp()) speed_Y = -4;\n        else if(!handler.isDown()) speed_Y = 0;\n        \n        if(handler.isDown()) speed_Y = 4;\n        else if(!handler.isUp()) speed_Y = 0;\n\n        if(handler.isRight()) speed_X = 4;\n        else if(!handler.isLeft()) speed_X = 0;\n\n        if(handler.isLeft()) speed_X = -4;\n        else if(!handler.isRight()) speed_X = 0;\n    }\n\n\n    @Override\n    public void render(Graphics g) {\n        if (ikon != null) {\n            g.drawImage(ikon, x, y, width, height, null);\n        } else {\n            //resim herhangi bişey yüzünden yüklenmezse\n            g.setColor(Color.RED);\n            g.fillRect(x, y, width, height);\n        }\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle(x, y, width, height);\n    }\n    \n\n    \n    public static double getHealth() {\n        return health;\n    }\n\n    \n    public static void setHealth(Double Newhealth) {\n        health = Newhealth;\n    }\n\n    public static int getScore() {\n        return score;\n    }\n\n    \n    public static void setScore(int Newscore) {\n        score = Newscore;\n    }\n\n}\n",
      "GameObject.java": "import java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.io.Serializable;\n\npublic abstract class GameObject implements Serializable{\n    int x, y;\n    float speed_X = 0, speed_Y = 0;\n    int height, width;\n    EntityType type;\n\n    public GameObject (int x, int y, EntityType type) {\n        this.x = x;\n        this.y = y;\n        this.type = type;\n    }\n\n    public abstract void tick();\n\n    public abstract void render(Graphics g);\n\n    public abstract Rectangle getBounds();\n\n    public EntityType getType() {\n        return type;\n    }\n\n    public void setType(EntityType e) {\n        this.type = e;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n\n    public float getSpeed_X() {\n        return speed_X;\n    }\n\n    public void setSpeed_X(float speed_X) {\n        this.speed_X = speed_X;\n    }\n\n    public float getSpeed_Y() {\n        return speed_Y;\n    }\n\n    public void setSpeed_Y(float speed_Y) {\n        this.speed_Y = speed_Y;\n    }\n\n    public int getHeight() {\n        return height;\n    }\n\n    public int getWidth() {\n        return width;\n    }\n\n\n}\n"
    },
    {
      "id": "4114373",
      "Sniper.java": "import java.io.File;\n\nimport javax.swing.ImageIcon;\n\npublic class Sniper extends Weapon{\n\n    GamePanel game;\n\n    public Sniper(GamePanel game){\n        capacity = 5;\n        currentcapacity = 5;\n        shootSpeed = 30;\n        wave = 6;\n        reloadCooldown = 5000;\n        this.game = game;\n        name = \"Sniper Rifle\";\n        image = new ImageIcon(\"Textures/weapons/Sniper Rifle.png\");\n        bulletImage = new ImageIcon(this.getClass().getResource(\"/textures/weapons/Rifle_Bullet.png\"));\n        soundPath = new File(\"sniperSound.wav\");\n    }\n\n    void shoot(int mouseX, int mouseY) {\n        if(currentcapacity>0){\n            if(Settings.volume){\n                playSound();\n            }\n            currentcapacity -= 1;\n            game.addBullet(mouseX, mouseY);\n        }\n        \n    }\n    \n}\n",
      "Menu.java": "import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Toolkit;\nimport java.awt.event.KeyEvent;\nimport java.io.File;\nimport java.io.IOException;\nimport java.awt.event.KeyAdapter;\n\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport javax.sound.sampled.LineUnavailableException;\nimport javax.sound.sampled.UnsupportedAudioFileException;\nimport javax.swing.ImageIcon;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\n\nclass Menu extends JPanel {\n    private MouseInput mouseInput = new MouseInput(this);\n    Window window;\n\n    public UIElement startButtonElement, settingsButtonElement, quitButtonElement = new UIElement(0, 0, 0, 0, null);\n    ImageIcon bgImage = new ImageIcon(this.getClass().getResource(\"/textures/UI/bg.png  \"));\n    ImageIcon titleImage = new ImageIcon(this.getClass().getResource(\"/textures/UI/title2.png\"));\n    ImageIcon startButton = new ImageIcon(this.getClass().getResource(\"/textures/UI/start_button.png\"));\n    ImageIcon settingsButton = new ImageIcon(this.getClass().getResource(\"/textures/UI/settings_button.png\"));\n    ImageIcon quitButton = new ImageIcon(this.getClass().getResource(\"/textures/UI/quit_button.png\"));\n    ImageIcon gif = new ImageIcon(this.getClass().getResource(\"/textures/UI/rain.gif\"));\n\n    boolean settingsOn;\n\n    private boolean rainMode = true;\n    private boolean extremeMode = false;\n\n    private boolean volume = true;\n    private boolean fullscreen = false;\n\n    File rainSound = new File(\"rain.wav\");\n    AudioInputStream rainInput;\n    Clip rainClip;\n\n    KeyInput keyInput = new KeyInput();\n    private MouseCursor mouseCursor = new MouseCursor(0, 0, 32, 32);\n\n    GameSaveManager saveManager = new GameSaveManager();\n\n    public Menu(Window window) throws UnsupportedAudioFileException, IOException, LineUnavailableException{\n        this.window = window;\n        setFocusable(true);\n        requestFocus();\n        setLayout(null);\n        addKeyListener(keyInput);\n        addMouseMotionListener(mouseInput);\n        addMouseListener(mouseInput);\n        saveManager.loadSettings();\n\n        rainInput = AudioSystem.getAudioInputStream(rainSound);\n        rainClip = AudioSystem.getClip();\n        rainClip.open(rainInput);\n        rainClip.setFramePosition(0);\n        \n\n        rainMode = Settings.rain;\n        extremeMode = Settings.extreme;\n        volume = Settings.volume;\n        fullscreen = Settings.fullscreen;\n\n        setFocusable(true);\n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                if (settingsOn) {\n                    if (e.getKeyCode() == KeyEvent.VK_Z) {\n                        volume = !volume;\n                        Settings.volume = volume;\n\n                        if(!volume){\n                            rainClip.stop();\n                        }\n                        else{\n                            rainClip.start();\n                            rainClip.loop(Clip.LOOP_CONTINUOUSLY);\n                        }\n\n                        saveManager.saveSettings();\n                    }\n                    if (e.getKeyCode() == KeyEvent.VK_R) {\n                        rainMode = !rainMode; \n                        Settings.rain = rainMode;\n                        saveManager.saveSettings();\n                    }\n                    if (e.getKeyCode() == KeyEvent.VK_E) {\n                        extremeMode = !extremeMode;\n                        Settings.extreme = extremeMode;\n                        saveManager.saveSettings();\n                    }\n                    if (e.getKeyCode() == KeyEvent.VK_F5) {\n                        fullscreen = !fullscreen;\n                        Settings.fullscreen = fullscreen;\n                        saveManager.saveSettings();\n\n                        if(fullscreen){\n                            window.fullScreen();\n                            window.changeSize((int)Toolkit.getDefaultToolkit().getScreenSize().getWidth(), (int)Toolkit.getDefaultToolkit().getScreenSize().getHeight());\n                        }\n                        else{\n                            window.changeSize(960, 540);\n                            window.fullScreen();\n                        }\n                    }\n\n                    if (e.getKeyCode() == KeyEvent.VK_K) {\n                        saveManager.saveSettings();\n                    }\n\n                    repaint();\n                }\n\n                if (e.getKeyCode() == KeyEvent.VK_ESCAPE) { \n                    settingsOn = !settingsOn;\n                    repaint();\n                }\n            }\n        });\n    }\n\n    public void paintComponent(Graphics g) {\n\n        g.drawImage(bgImage.getImage(), 0, 0, getWidth(), getHeight(), null);\n        if(Settings.rain){\n            g.drawImage(gif.getImage(), 0, 0, getWidth(), getHeight(), null);\n\n            if(Settings.volume){\n                rainClip.loop(Clip.LOOP_CONTINUOUSLY);\n            }\n\n            \n        }\n        \n        g.setColor(new Color(0, 0, 0, 100));\n        g.fillRect(0, 0, getWidth(), getHeight());\n        g.setColor(new Color(255, 128, 0, 25));\n        g.fillOval(mouseInput.getMouseX() - 75, mouseInput.getMouseY() - 75, 150, 150);\n        g.drawImage(titleImage.getImage(), getWidth() / 2 - getWidth() / 8, getHeight() / 9 - getHeight() / 16,\n                getWidth() / 4, getHeight() / 8, null);\n\n        startButtonElement = new UIElement(getWidth() / 2 - getWidth() / 12, getHeight() / 2 - getHeight() / 12,\n                getWidth() / 6, getHeight() / 6, startButton);\n        settingsButtonElement = new UIElement(getWidth() / 2 - getWidth() / 12,\n                (int) (getHeight() / 1.6) - getHeight() / 12, getWidth() / 6, getHeight() / 6, settingsButton);\n        quitButtonElement = new UIElement(getWidth() / 2 - getWidth() / 12,\n                (int) (getHeight() / 1.33) - getHeight() / 12, getWidth() / 6, getHeight() / 6, quitButton);\n        startButtonElement.draw((Graphics2D) g);\n        settingsButtonElement.draw((Graphics2D) g);\n        quitButtonElement.draw((Graphics2D) g);\n        \n        if(settingsOn){\n            g.setColor(new Color(0, 0, 0, 150));\n\n            int leftPanelX = getWidth() / 18;\n            int leftPanelY = getHeight() / 8;\n            int leftPanelWidth = (int) (getWidth() / 3.5);\n            int leftPanelHeight = (int) (getHeight() / 1.3);\n\n            g.fillRect(leftPanelX, leftPanelY, leftPanelWidth, leftPanelHeight);\n\n            g.setColor(Color.WHITE);\n            g.setFont(new Font(\"Courier New\", Font.BOLD, getWidth()/60));\n            g.drawString(\"Game Modes\", leftPanelX + 20, leftPanelY + 40);\n            g.drawString(\"[R] Rain Mod: \" + (rainMode ? \"On\" : \"Off\"), leftPanelX + 20, leftPanelY + 100);\n            g.drawString(\"[E] Extreme Mod: \" + (extremeMode ? \"On\" : \"Off\"), leftPanelX + 20, leftPanelY + 150);\n\n            int rightPanelX = getWidth() - getWidth() / 3;\n            int rightPanelY = getHeight() / 8;\n            int rightPanelWidth = (int) (getWidth() / 3.5);\n            int rightPanelHeight = (int) (getHeight() / 1.3);\n\n            g.setColor(new Color(0, 0, 0, 150));\n            g.fillRect(rightPanelX, rightPanelY, rightPanelWidth, rightPanelHeight);\n\n            g.setColor(Color.WHITE);\n            g.drawString(\"Audio and Visual\", rightPanelX + 20, rightPanelY + 40);\n            g.drawString(\"[Z] Sound: \" + (volume ? \"On\" : \"Off\"), rightPanelX + 20, rightPanelY + 100);\n            g.drawString(\"[F5] Fullscreen: \" + (fullscreen ? \"On\" : \"Off\"), rightPanelX + 20, rightPanelY + 170);\n\n        }\n\n        mouseCursor.draw((Graphics2D) g, mouseInput.getMouseX(), mouseInput.getMouseY());\n        \n    }\n\n    public void update() {\n        repaint();\n\n        mouseInput.update();\n        mouseCursor.update();\n\n        if(mouseInput.isMousePressed){\n            if((mouseInput.getMouseX() > quitButtonElement.getX() && mouseInput.getMouseX() < quitButtonElement.getX() + quitButtonElement.getWidth()) && (mouseInput.getMouseY() > quitButtonElement.getY() && mouseInput.getMouseY() < quitButtonElement.getY() + quitButtonElement.getHeight())) {\n                sureExit();\n                mouseInput.isMousePressed = false;\n            }\n            if((mouseInput.getMouseX() > settingsButtonElement.getX() && mouseInput.getMouseX() < settingsButtonElement.getX() + settingsButtonElement.getWidth()) && (mouseInput.getMouseY() > settingsButtonElement.getY() && mouseInput.getMouseY() < settingsButtonElement.getY() + settingsButtonElement.getHeight())) {\n                \n                mouseInput.isMousePressed = false;\n                if(settingsOn){\n                    settingsOn = false;\n                }\n                else{\n                    settingsOn = true;\n                }\n            }\n\n            if((mouseInput.getMouseX() > startButtonElement.getX() && mouseInput.getMouseX() < startButtonElement.getX() + startButtonElement.getWidth()) && (mouseInput.getMouseY() > startButtonElement.getY() && mouseInput.getMouseY() < startButtonElement.getY() + startButtonElement.getHeight())) {\n                startGame();\n                mouseInput.isMousePressed = false;\n            }\n\n        }\n\n        \n    }\n\n    public void sureExit() {\n        int result = JOptionPane.showConfirmDialog(null, \"Sure? You want to exit?\", \"EXIT\",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE);\n        if (result == JOptionPane.YES_OPTION) {\n            System.exit(0);\n        }\n    }\n\n    public void startGame(){\n        rainClip.stop();\n        rainClip = null;\n        saveManager.saveSettings();\n        Window.gameOn = true;\n        System.out.println(Window.gameOn);\n        Game.close();\n        Game.create();\n    }\n\n    \n}\n\n",
      "WaveManager.java": "import java.awt.Graphics2D;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class WaveManager {\n    public int wave = 0;\n    ArrayList<Zombie> zombies;\n    Random rand;\n    HealthKit healthKit;\n    Magazine magazine;\n    ArrayList<HealthKit> healthKits = new ArrayList<>();\n    ArrayList<Magazine> magazines = new ArrayList<>();\n    public int zombieCount;\n    public double mult;\n    public int dead;\n\n    ArrayList<AcidArea> acidAreas = new ArrayList<>();\n    ArrayList<Double> acidTimes = new ArrayList<>();\n\n    long last_time = System.nanoTime();\n    double currentTime;\n\n    public WaveManager(GamePanel game){\n        this.game = game;\n        this.zombies  = new ArrayList<>();\n        this.rand = new Random();\n        if(Settings.extreme){\n            mult = 20.0;\n        }\n        else{\n            mult = 10.0;\n        }\n    }\n\n    public GamePanel game;\n\n    boolean validSpawn(Zombie zombie){\n\n        for(Building building: game.buildings){\n            if(zombie.checkCollusion(game.camera, building)){\n                return false;\n            }\n        }\n\n        return true;\n        \n    }\n\n    public void spawnZombies(){\n        zombies.clear();\n\n        if(dead >= wave*mult){\n            dead = 0;\n        }\n\n\n        zombieCount = (int)(wave * mult) - dead;\n        \n\n        ArrayList<Class<? extends Zombie>> availableZombies = new ArrayList<>();\n\n        availableZombies.add(NormalZombie.class);\n        \n        if(wave >= 4){\n            availableZombies.add(ReptileZombie.class);\n        }\n        if(wave >= 7){\n            availableZombies.add(TankZombie.class);\n        }\n        if(wave >= 10){\n            availableZombies.add(AcidZombie.class);\n        }\n\n        for(int i = 0; i < zombieCount; i++){\n            int x = rand.nextInt(0, game.bg.width);\n            int y = rand.nextInt(0, game.bg.height);\n            System.out.println(x + \" \" + y);\n\n            Class<? extends Zombie> zombieType = availableZombies.get(rand.nextInt(availableZombies.size()));\n\n            try {\n                Zombie zombie = zombieType.getDeclaredConstructor(int.class, int.class, Player.class, Camera.class).newInstance(x, y, game.player, game.camera);\n                \n                if(validSpawn(zombie)){\n                    zombies.add(zombie);\n                    zombie.defineManager(this);\n                }\n                else{\n                    i--;\n                }\n                \n                \n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n        }\n\n    }\n\n    public void update(){\n\n        currentTime = System.currentTimeMillis();\n        long time = System.nanoTime();\n        int delta_time = (int) ((time - last_time) / 1000000);\n        last_time = time;\n\n\n\n        for (int i = 0; i < zombies.size(); i++) {\n            if (zombies.get(i).isDead()) {\n                dead += 1;\n                game.player.score += wave;\n\n                if(zombies.get(i) instanceof AcidZombie){\n                    acidAreas.add(new AcidArea(zombies.get(i).x - 64, zombies.get(i).y - 64, 128, 128));\n                    acidTimes.add(currentTime);\n                }\n\n                int r = rand.nextInt(0,20);\n\n                if(r==1 || r==2){\n                    healthKit = new HealthKit(zombies.get(i).x, zombies.get(i).y, 48, 48);\n                    healthKits.add(healthKit);\n                }\n                if(r==3 || r==4 || r==5){\n                    magazine = new Magazine(zombies.get(i).x, zombies.get(i).y, 48, 48);\n                    magazines.add(magazine);\n                }\n                zombies.remove(i);\n                i--;\n            }\n        }\n\n        if(zombies.isEmpty()){\n            nextWave();\n        }\n\n        for(Zombie z: zombies){\n            z.update();\n        }\n\n        for(int i = 0; i < acidAreas.size(); i++){\n            if(currentTime - acidTimes.get(i) > 3000){\n                acidAreas.remove(i);\n                acidTimes.remove(i);\n            }\n\n        }\n\n        for(Zombie z: zombies){\n            for(AcidArea area: acidAreas){\n                if(area.checkCollusion(game.camera, z)){\n                    z.health -= delta_time / 30.0;\n                    System.out.println(delta_time);\n                }\n            }\n        }\n\n    }\n\n    public void render(Graphics2D g, Camera cam) {\n        for (Zombie z : zombies) {\n            z.draw2(g);\n        }\n\n        for(HealthKit hk: healthKits){\n            hk.draw2(g, cam);\n        }\n\n        for(Magazine mg: magazines){\n            mg.draw2(g, cam);\n        }\n\n        for(AcidArea area: acidAreas){\n            area.draw2(g, cam);\n        }\n\n    }\n\n    public void nextWave() {\n        wave += 1;\n        spawnZombies();\n    }\n\n    public List<Zombie> getZombies() {\n        return zombies;\n    }\n\n\n}\n",
      "MouseCursor.java": "import java.awt.Graphics2D;\n\nimport javax.swing.ImageIcon;\n\npublic class MouseCursor extends GameObject{\n    \n    private ImageIcon mouseIcon = new ImageIcon(this.getClass().getResource(\"/textures/cursor.png\"));\n\n    public MouseCursor(int x, int y, int width, int height) {\n        super(x, y, width, height);\n    }\n\n\n    public void update() {\n        \n    }\n\n\n    public void draw(Graphics2D g) {\n        \n    }\n\n    public void draw(Graphics2D g, int x, int y) {\n        g.drawImage(mouseIcon.getImage(), x-16, y-16, width, height, null);\n    }\n    \n}\n",
      "Building.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\n\nimport javax.swing.ImageIcon;\n\npublic class Building extends GameObject{\n\n    Player player;\n\n    ImageIcon[] buildingImages = new ImageIcon[14];\n    ImageIcon buildingImage = buildingImages[11] = new ImageIcon(this.getClass().getResource(\"/textures/tilesets/city/house1.png\"));;\n\n    int wBuilding;\n\n    {\n\n        for(int i = 0; i < 11; i++){\n            buildingImages[i] = new ImageIcon(this.getClass().getResource(\"/textures/tilesets/city/house\" + (int)(i+1) + \".png\"));\n        }\n\n        buildingImages[11] = new ImageIcon(this.getClass().getResource(\"/textures/tilesets/city/building1.png\"));\n        buildingImages[12] = new ImageIcon(this.getClass().getResource(\"/textures/tilesets/city/building2.png\"));\n        buildingImages[13] = new ImageIcon(this.getClass().getResource(\"/textures/tilesets/city/building3.png\"));\n    }\n    \n    public Building(int x, int y, int width, int height){\n        super(x, y, width, height);\n    }\n\n    public void setBuilding(int i){\n        buildingImage = buildingImages[i];\n    }\n\n    public void getPlayer(Player player){\n        this.player = player;\n    }\n\n    public void draw(Graphics2D g) {\n        g.drawImage(buildingImage.getImage(), x, y, width, height, null);\n\n        Rectangle bounds1 = new Rectangle((int) x, (int) y, width, height);\n\n        //g.draw(bounds1);\n    }\n\n}\n",
      "Zombie.java": "import java.awt.Graphics2D;\n\npublic abstract class Zombie extends GameObject{\n    public Zombie(int x, int y, int width, int height) {\n            super(x, y, width, height);\n        }\n\n    public boolean isDead() {\n        return health <= 0;\n    }\n    \n    WaveManager waveManager;\n    GamePanel game;\n    public double health, speed;\n    public double damage;\n    public double velX, velY;\n    boolean isJumping;\n    double speed2 = speed;\n    public boolean collusion = false;\n    abstract void attack();\n\n    Player player;\n    Camera camera;\n\n    void defineManager(WaveManager wm){\n        waveManager = wm;\n        game = wm.game;\n    }\n\n    boolean isNearPlayer;\n    abstract void draw2(Graphics2D g);\n\n    public void moveTowardsPlayer() {\n\n        double playerCenterX = player.getX() + player.getWidth() / 2.0;\n        double playerCenterY = player.getY() + player.getHeight() / 2.0;\n\n        double zombieCenterX = x + width / 2.0;\n        double zombieCenterY = y + height / 2.0;\n\n        double dx = playerCenterX - zombieCenterX;\n        double dy = playerCenterY - zombieCenterY;\n\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if(isJumping){\n            speed2 = 10;\n        }\n\n        double angle = Math.atan2(dy, dx);\n        \n        velX = Math.cos(angle) * speed2;\n        velY = Math.sin(angle) * speed2;\n\n        if(distance >= 50){\n            if(!isJumping){\n                speed2 = speed;\n            }\n            \n            isNearPlayer = false;\n        }\n\n        if(distance < 50){\n            speed2 = 0;\n            isNearPlayer = true;\n        }\n\n        collusion = false;\n        \n        \n\n        for(Building building: game.buildings){\n            if(checkCollusion(camera, building)){\n                collusion = true;\n                \n                if (velX > 0) { \n                    x -= velX;\n                    velX = 0;\n                } else if (velX < 0) { \n                    x += Math.abs(velX);\n                    velX = 0;\n                }\n    \n                if (velY > 0) {\n                    y -= velY;\n                    velY = 0;\n                } else if (velY < 0) {\n                    y += Math.abs(velY);\n                    velY = 0;\n                }\n            }\n        }\n        \n        x += velX;\n        y += velY;\n    }\n\n    \n}\n",
      "Pause.java": "import java.awt.AlphaComposite;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\n\nimport javax.swing.ImageIcon;\n\npublic class Pause extends GameObject{\n\n    int a;\n    private Font uiFont;\n    ImageIcon pauseIcon = new ImageIcon(this.getClass().getResource(\"/textures/UI/pause.png\"));\n\n    public Pause(int x, int y, int width, int height) {\n        super(x, y, width, height);\n    }\n\n    public void set(int w, int h){\n        width = w;\n        height = h;\n        uiFont = new Font(\"Courier New\", Font.BOLD, w/40);\n    }\n\n    public void update(){    \n        if(a<150) a += 3;\n    }\n\n    public void draw(Graphics2D g) {\n        g.setColor(new Color(0,0,0,a));\n        g.fillRect(0, 0, width , height);\n        g.setColor(new Color(255,255,255));\n        g.setFont(uiFont);\n        float alpha = a/150.0f;\n        AlphaComposite ac = AlphaComposite.getInstance(AlphaComposite.SRC_OVER,alpha);\n        g.setComposite(ac);\n        g.drawImage(pauseIcon.getImage(), width/3, width/8,width/3,width/18, null);\n        g.drawString(\"Press 'P' for unpause\", width/2 - (int)(width/6.5), height/2);\n        g.drawString(\"Press 'ESC' for main menu\", width/2 - (int)(width/5.5), (int)(height/1.5));\n    }\n\n}\n",
      "AcidZombie.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\nimport java.util.ArrayList;\n\nimport javax.swing.ImageIcon;\n\npublic class AcidZombie extends Zombie{\n\n    private ImageIcon acidZombieImage = new ImageIcon(this.getClass().getResource(\"/textures/zombies/acidzombie.png\"));\n    ArrayList<Acid> acids = new ArrayList<>();\n    double currentTime;\n    double acidTime;\n\n    public AcidZombie(int x, int y, Player player, Camera camera){\n        super(x,y,80,80);\n        this.health = 10;\n        this.speed = 4;\n        this.damage = 0.2;\n        this.player = player;\n        this.camera = camera;\n        this.visible = true;\n    }\n\n    void attack() {\n\n        if(currentTime - acidTime > 600){\n            acids.add(new Acid((int)(x + width/2 - camera.x),(int)(y + height/2 - camera.y),(int)(player.getX() + player.getWidth() / 2.0 - camera.x), (int)(player.getY() + player.getHeight() / 2.0 - camera.y)));\n            acidTime = currentTime;\n        }\n\n    }\n\n    public void update() {\n\n        for(Acid acid: acids){\n            acid.update();\n        }\n\n        for(int i = 0; i < acids.size(); i++){\n            if(player.checkCollusion(camera, acids.get(i))){\n                acids.remove(i);\n\n                if(player.isPlayerAttackable()){\n                    player.setHealth(player.getHealth() - 5);\n                }\n                \n            }\n        }\n\n        double dx = player.x - x;\n        double dy = player.y - y;\n\n        currentTime = System.currentTimeMillis();\n\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if(distance < 1000 && distance > 200){\n            moveTowardsPlayer();\n        }\n\n        if(distance <= 200){\n            attack();\n        }\n\n        \n    }\n\n    public void draw2(Graphics2D g) {\n\n        for(Acid acid: acids){\n            acid.draw(g);\n        }\n\n        if (visible) {\n            double dx = player.getX() + player.getWidth() / 2.0 - (x + width/2);\n            double dy = player.getY() + player.getHeight() / 2.0 - (y + height/2);\n            double angle = Math.atan2(dy, dx) + Math.PI / 2;\n    \n\n            g.translate(x - camera.getX() + width/2, y - camera.getY() + height/2);\n            g.rotate(angle);\n\n            g.drawImage(acidZombieImage.getImage(), -width/2, -height/2, width, height, null);\n            g.setTransform(new AffineTransform());\n\n            g.setColor(new Color(215,0,0));\n            g.fillRect(x - camera.getX() + 15, y - camera.getY(), (int)((width-30) * (health / 10)), 5);\n            g.setColor(new Color(255,255,255));\n            g.drawRect(x - camera.getX() + 15, y - camera.getY(), (width-30), 5);\n        }\n\n        \n    }\n\n    public void draw(Graphics2D g) {\n\n    }\n\n}\n",
      "Weapon.java": "import java.io.File;\n\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport javax.swing.ImageIcon;\n\npublic abstract class Weapon {\n    public int capacity;\n    public int currentcapacity;\n    public int shootSpeed;\n    public int wave;\n    public int reloadCooldown;\n    public String name;\n    public int speed = 50;\n    public int magazine = capacity;\n\n    public File soundPath;\n    public File reloadPath = new File(\"reloadSound.wav\");\n    public AudioInputStream audioInput;\n    public Clip clip;\n\n    \n    public void playSound(){\n        new Thread(() -> {\n            try{\n                audioInput = AudioSystem.getAudioInputStream(soundPath);\n                clip = AudioSystem.getClip();\n                clip.open(audioInput);\n                clip.setFramePosition(0);\n                clip.start();\n                System.out.println(\"BANG\");\n            }\n\n            catch(Exception e){\n\n            }\n\n        }).start();\n\n    }\n\n    public void reloadSound(){\n        new Thread(() -> {\n            try{\n                audioInput = AudioSystem.getAudioInputStream(reloadPath);\n                clip = AudioSystem.getClip();\n                clip.open(audioInput);\n                clip.setFramePosition(0);\n                clip.start();\n                System.out.println(\"R\");\n            }\n\n            catch(Exception e){\n\n            }\n\n        }).start();\n    }\n    \n    ImageIcon image,bulletImage;\n\n    abstract void shoot(int mouseX, int mouseY);\n\n    public void reload(){\n        if(magazine > capacity){\n            magazine -= capacity - currentcapacity;\n            currentcapacity = capacity;\n        }\n        else{\n            currentcapacity += magazine;\n            magazine = 0;\n        }\n        System.out.println(magazine);\n        System.out.println(capacity - currentcapacity);\n        if(Settings.volume){\n            reloadSound();\n        }\n        \n    }\n}\n",
      "Bullet.java": "import java.awt.Graphics2D;\nimport java.awt.geom.AffineTransform;\n\nimport javax.swing.ImageIcon;\n\npublic class Bullet extends GameObject{\n\n    private double velX, velY;\n    private double speed = 50.0;\n    private double angle;\n    public boolean enabled;\n\n    private ImageIcon BulletImage;\n\n    WaveManager waveManager;\n    Camera camera;\n    Explosion explosion = null;\n    Weapon weapon;\n    double expTime = 0;\n    double currentTime;\n\n    long last_time = System.nanoTime();\n\n\n    public Bullet(int startX, int startY, int targetX, int targetY, Weapon weapon, double ang, WaveManager wm, Camera cam) {\n        \n        super(startX, startY, 8, 8);\n        \n        enabled = true;\n        camera = cam;\n        waveManager = wm;\n        this.weapon = weapon;\n\n        speed = weapon.speed;\n\n        double diffX = targetX - startX;\n        double diffY = targetY - startY;\n        double distance = Math.sqrt(diffX * diffX + diffY * diffY);\n\n        double ang2 = Math.toRadians(ang);\n        angle = Math.atan2(diffY, diffX) + ang2;\n\n        if (distance != 0) {\n            velX = Math.cos(angle) * speed;\n            velY = Math.sin(angle) * speed;\n        } \n        else {\n            velX = 0;\n            velY = 0;\n        }\n\n        BulletImage = weapon.bulletImage;\n    }\n\n    public void update() {\n        currentTime = System.currentTimeMillis();\n        long time = System.nanoTime();\n        int delta_time = (int) ((time - last_time) / 1000000);\n        last_time = time;\n        \n        x += velX;\n        y += velY;\n\n        for(Zombie z: waveManager.zombies){\n            if(checkCollusion(camera, z) && !(weapon instanceof RocketLauncher)){\n                z.health -= 5;\n                if(!(weapon instanceof Sniper)){\n                    enabled = false;\n                }\n                else{\n                    z.health -= 5;\n                    enabled = true;\n                }\n                \n            }\n        }\n\n        for(Zombie z: waveManager.zombies){\n            if(checkCollusion(camera, z)){\n                if(weapon instanceof RocketLauncher){\n                    if(explosion==null){\n                        explosion = new Explosion(x + camera.x - 128, y + camera.y - 128, 256, 256);\n                        velX = 0;\n                        velY = 0;\n                        expTime = currentTime;\n                    }\n                }\n            }\n        }\n\n        for(Building b: waveManager.game.buildings){\n            if(checkCollusion(camera, b)){\n                if(weapon instanceof RocketLauncher){\n                    if(explosion==null){\n                        explosion = new Explosion(x + camera.x - 128, y + camera.y - 128, 256, 256);\n                        velX = 0;\n                        velY = 0;\n                        expTime = currentTime;\n                    }\n                }\n                else{\n                    enabled = false;\n                }\n            }\n        }\n\n        if(explosion!=null){\n            for(Zombie z: waveManager.zombies){\n                if(explosion.checkCollusion(camera, z)){\n                    z.health -= delta_time * 10;\n                }\n            }\n        }\n        \n    }\n\n    public void draw(Graphics2D g) {\n        AffineTransform transform = new AffineTransform();\n        transform.translate(x, y);\n        transform.rotate(angle + Math.PI, BulletImage.getImage().getWidth(null) / 20, BulletImage.getImage().getHeight(null) / 20);\n        \n        if(weapon instanceof RocketLauncher){\n            transform.scale(0.15, 0.15);\n        }\n        else{\n            transform.scale(0.05, 0.05);\n        }\n        \n        \n        g.drawImage(BulletImage.getImage(), transform, null);\n\n        if(explosion != null){\n            explosion.draw2(g, camera);\n        }\n\n        if(currentTime - expTime >= 750 && explosion != null){\n            expTime = 0;\n            explosion = null;\n            enabled = false;\n        }\n\n        \n    }\n\n    public boolean isOutOfBounds() {\n        return x < 0 || x > 4000 || y < 0 || y > 3000;\n    }\n    \n}\n",
      "Shotgun.java": "import java.io.File;\n\nimport javax.swing.ImageIcon;\n\npublic class Shotgun extends Weapon{\n\n    GamePanel game;\n\n    public Shotgun(GamePanel game){\n        capacity = 5;\n        currentcapacity = 5;\n        shootSpeed = 60;\n        wave = 4;\n        reloadCooldown = 5000;\n        this.game = game;\n        name = \"Shotgun\";\n        image = new ImageIcon(\"Textures/weapons/shotgun.png\");\n        bulletImage = new ImageIcon(this.getClass().getResource(\"/textures/weapons/Rifle_Bullet.png\"));\n        soundPath = new File(\"shotgunSound.wav\");\n    }\n\n    void shoot(int mouseX, int mouseY) {\n        if(currentcapacity>0){\n            if(Settings.volume){\n                playSound();\n            }\n            currentcapacity -= 1;\n            game.addBullet(mouseX, mouseY);\n        }\n        \n    }\n    \n}\n",
      "Acid.java": "import java.awt.Graphics2D;\n\npublic class Acid extends GameObject{\n\n    double angle;\n    double speed = 10;\n\n    public Acid(int startX, int startY, int targetX, int targetY){\n        super(startX, startY, 6, 6);\n        double diffX = targetX - startX;\n        double diffY = targetY - startY;\n        double distance = Math.sqrt(diffX * diffX + diffY * diffY);\n\n        angle = Math.atan2(diffY, diffX);\n\n        if (distance != 0) {\n            velX = Math.cos(angle) * speed;\n            velY = Math.sin(angle) * speed;\n        } \n        else {\n            velX = 0;\n            velY = 0;\n        }\n    }\n\n    public void update(){\n        x += velX;\n        y += velY;\n    }\n\n    public void draw(Graphics2D g) {\n        g.fillOval(x, y, width, height);\n    }\n}\n",
      "ReptileZombie.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.geom.AffineTransform;\n\nimport javax.swing.ImageIcon;\n\npublic class ReptileZombie extends Zombie{\n\n    private ImageIcon reptileZombieImage = new ImageIcon(this.getClass().getResource(\"/textures/zombies/reptilezombie.png\"));\n\n    public ReptileZombie(int x, int y, Player player, Camera camera){\n        super(x,y,64,64);\n        this.health = 10;\n        this.speed = 4;\n        this.damage = 0.2;\n        this.player = player;\n        this.camera = camera;\n        this.visible = true;\n    }\n\n    void attack() {\n        if (isNearPlayer && player.isPlayerAttackable()) {\n            player.setHealth(player.getHealth()-damage);\n            //System.out.println(\"attack \" + player.getHealth());\n        }\n    }\n\n    private boolean canJump = true;\n    private long lastJumpTime = 0;\n    private final long jumpCooldown = 2000;\n\n\n    public void update() {\n        double dx = player.x - x;\n        double dy = player.y - y;\n\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if(distance < 1000){\n            moveTowardsPlayer();\n        }\n        attack();\n        checkJump();\n    }\n\n    public void checkJump(){\n        double playerCenterX = player.getX() + player.getWidth() / 2.0;\n        double playerCenterY = player.getY() + player.getHeight() / 2.0;\n\n        double zombieCenterX = x + width / 2.0;\n        double zombieCenterY = y + height / 2.0;\n\n        double dx = playerCenterX - zombieCenterX;\n        double dy = playerCenterY - zombieCenterY;\n\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance < 100) { \n            if (canJump) {\n                isJumping = true;\n                canJump = false;\n                lastJumpTime = System.currentTimeMillis();\n            }\n        }\n\n        if(distance < 50){\n            isJumping = false;\n        }\n    \n        if (!canJump && System.currentTimeMillis() - lastJumpTime > jumpCooldown) {\n            canJump = true;\n        }\n    }\n\n    public void draw2(Graphics2D g) {\n\n        if (visible) {\n    \n            double dx = player.getX() + player.getWidth() / 2.0 - (x + width/2);\n            double dy = player.getY() + player.getHeight() / 2.0 - (y + height/2);\n            double angle = Math.atan2(dy, dx) + Math.PI / 2;\n    \n\n            g.translate(x - camera.getX() + width/2, y - camera.getY() + height/2);\n            g.rotate(angle);\n\n            g.drawImage(reptileZombieImage.getImage(), -width/2, -height/2, width, height, null);\n            g.setTransform(new AffineTransform());\n\n            g.setColor(new Color(215,0,0));\n            g.fillRect(x - camera.getX() + 15, y - camera.getY(), (int)((width-30) * (health / 10)), 5);\n            g.setColor(new Color(255,255,255));\n            g.drawRect(x - camera.getX() + 15, y - camera.getY(), (width-30), 5);\n\n        }\n\n        \n\n        Rectangle bounds1 = new Rectangle((int) x - camera.x, (int) y - camera.y, width, height);\n\n        //g.draw(bounds1);\n    }\n\n    public void draw(Graphics2D g) {\n\n    }\n\n}\n",
      "NormalZombie.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.Rectangle;\nimport java.awt.geom.AffineTransform;\n\nimport javax.swing.ImageIcon;\n\npublic class NormalZombie extends Zombie{\n\n    \n    ImageIcon normalZombieImage = new ImageIcon(this.getClass().getResource(\"/textures/zombies/normalzombie.png\"));\n    \n\n    public NormalZombie(int x, int y, Player player, Camera camera){\n        super(x,y,80,80);\n        this.health = 20;\n        this.speed = 2;\n        this.damage = 0.2;\n        this.player = player;\n        this.camera = camera;\n        this.visible = true;\n    }\n    \n    void attack() {\n        if (isNearPlayer && player.isPlayerAttackable()) {\n            player.setHealth(player.getHealth()-damage);\n            //System.out.println(\"attack \" + player.getHealth());\n        }\n    }\n\n    public void update() {\n        double dx = player.x - x;\n        double dy = player.y - y;\n\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if(distance < 1000){\n            moveTowardsPlayer();\n        }\n        \n        attack();\n    }\n\n    public void draw2(Graphics2D g) {\n\n        if (visible) {\n    \n            double dx = player.getX() + player.getWidth() / 2.0 - (x + width/2);\n            double dy = player.getY() + player.getHeight() / 2.0 - (y + height/2);\n            double angle = Math.atan2(dy, dx) + Math.PI / 2;\n    \n\n            g.translate(x - camera.getX() + width/2, y - camera.getY() + height/2);\n            g.rotate(angle);\n\n            g.drawImage(normalZombieImage.getImage(), -width/2, -height/2, width, height, null);\n            g.setTransform(new AffineTransform());\n\n            g.setColor(new Color(215,0,0));\n            g.fillRect(x - camera.getX() + 15, y - camera.getY(), (int)((width-30) * (health / 20)), 5);\n            g.setColor(new Color(255,255,255));\n            g.drawRect(x - camera.getX() + 15, y - camera.getY(), (width-30), 5);\n\n        }\n\n        Rectangle bounds1 = new Rectangle((int) x - camera.x, (int) y - camera.y, width, height);\n\n        //g.draw(bounds1);\n    }\n\n    public void draw(Graphics2D g) {\n        \n    }\n\n\n}\n",
      "Magazine.java": "import java.awt.Graphics2D;\n\nimport javax.swing.ImageIcon;\n\npublic class Magazine extends GameObject{\n\n    ImageIcon magazine = new ImageIcon(this.getClass().getResource(\"/textures/zombies/magazine.gif\"));\n\n    public Magazine(int x, int y, int width, int height) {\n        super(x, y, width, height);\n    }\n    \n    public void draw2(Graphics2D g, Camera cam) {\n        g.drawImage(magazine.getImage(), x - cam.x, y - cam.y, width, height, null);\n    }\n\n    public void draw(Graphics2D g) {\n\n    }\n\n}\n",
      "KeyInput.java": "import java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\npublic class KeyInput implements KeyListener {\n    private boolean up, down, left, right,shift,q,r,t,k,p,num1,num2,num3,num4,num5,f5,esc;\n\n    public boolean isUp(){\n        return up;\n    }\n\n    public boolean isDown(){\n        return down;\n    }\n\n    public boolean isLeft(){\n        return left;\n    }\n\n    public boolean isRight(){\n        return right;\n    }\n\n    public boolean isShift(){\n        return shift;\n    }\n\n    public boolean isQ(){\n        return q;\n    }\n\n    public boolean isR(){\n        return r;\n    }\n\n    public boolean isT(){\n        return t;\n    }\n    public boolean isK(){\n        return k;\n    }\n\n    public boolean isP(){\n        return p;\n    }\n\n    public boolean is1(){\n        return num1;\n    }\n\n    public boolean is2(){\n        return num2;\n    }\n\n    public boolean is3(){\n        return num3;\n    }\n    \n    public boolean is4(){\n        return num4;\n    }\n\n    public boolean is5(){\n        return num5;\n    }\n\n    public boolean isF5(){\n        return f5;\n    }\n\n    public boolean isESC(){\n        return esc;\n    }\n\n    \n\n    public void keyPressed(KeyEvent e) {\n        int key = e.getKeyCode();\n\n        if (key == KeyEvent.VK_W) \n            up = true;\n        if (key == KeyEvent.VK_S) \n            down = true;\n        if (key == KeyEvent.VK_A) \n            left = true;\n        if (key == KeyEvent.VK_D) \n            right = true;\n        if (key == KeyEvent.VK_SHIFT)\n            shift = true;\n        if (key == KeyEvent.VK_Q)\n            q = true;\n        if (key == KeyEvent.VK_R)\n            r = true;\n        if (key == KeyEvent.VK_T)\n            t = true;\n        if (key == KeyEvent.VK_K)\n            k = true;\n        if (key == KeyEvent.VK_P)\n            p = true;\n        if (key == KeyEvent.VK_1)\n            num1 = true;\n        if (key == KeyEvent.VK_2)\n            num2 = true;\n        if (key == KeyEvent.VK_3)\n            num3 = true;\n        if (key == KeyEvent.VK_4)\n            num4 = true;\n        if (key == KeyEvent.VK_5)\n            num5 = true;\n        if (key == KeyEvent.VK_F5)\n            f5 = true;\n        if (key == KeyEvent.VK_ESCAPE)\n            esc = true;\n    }\n\n    public void keyReleased(KeyEvent e) {\n        int key = e.getKeyCode();\n\n        if (key == KeyEvent.VK_W) \n            up = false;\n        if (key == KeyEvent.VK_S) \n            down = false;\n        if (key == KeyEvent.VK_A) \n            left = false;\n        if (key == KeyEvent.VK_D) \n            right = false;\n        if (key == KeyEvent.VK_SHIFT)\n            shift = false;\n        if (key == KeyEvent.VK_Q)\n            q = false;\n        if (key == KeyEvent.VK_R)\n            r = false;\n        if (key == KeyEvent.VK_T)\n            t = false;\n        if (key == KeyEvent.VK_K)\n            k = false;\n        if (key == KeyEvent.VK_P)\n            p = false;\n        if (key == KeyEvent.VK_1)\n            num1 = false;\n        if (key == KeyEvent.VK_2)\n            num2 = false;\n        if (key == KeyEvent.VK_3)\n            num3 = false;\n        if (key == KeyEvent.VK_4)\n            num4 = false;\n        if (key == KeyEvent.VK_5)\n            num5 = false;\n        if (key == KeyEvent.VK_F5)\n            f5 = false;\n        if (key == KeyEvent.VK_ESCAPE)\n            esc = false;\n    }\n\n    public void keyTyped(KeyEvent e) {\n\n    }\n\n}\n",
      "GameSaveManager.java": "import java.io.*;\n\npublic class GameSaveManager {\n\n    private GamePanel gamePanel;\n\n    public GameSaveManager(GamePanel gamePanel) {\n        this.gamePanel = gamePanel;\n    }\n\n    public GameSaveManager() {\n        \n    }\n\n    public void saveSettings(){\n\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(\"settings.txt\"))) {\n        \n            writer.write(\"rain=\" + Settings.rain);\n            writer.newLine();\n\n            writer.write(\"extreme=\" + Settings.extreme);\n            writer.newLine();\n\n            writer.write(\"fullscreen=\" + Settings.fullscreen);\n            writer.newLine();\n\n            writer.write(\"volume=\" + Settings.volume);\n            writer.newLine();\n        \n        }\n        \n        catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public void loadSettings(){\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"settings.txt\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] parts = line.split(\"=\");\n                String key = parts[0];\n                String value = parts[1];\n\n                switch (key) {\n                    case \"rain\":\n                        Settings.rain = Boolean.parseBoolean(value);\n                        break;\n                    case \"extreme\":\n                        Settings.extreme = Boolean.parseBoolean(value);\n                        break;\n                    case \"fullscreen\":\n                        Settings.fullscreen = Boolean.parseBoolean(value);\n                        break;\n                    case \"volume\":\n                        Settings.volume = Boolean.parseBoolean(value);\n                        break;\n                }\n            }\n\n            System.out.println(\"LOADSETTINGS\");\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void saveGame() {\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(\"save.txt\"))) {\n            writer.write(\"wave=\" + (gamePanel.waveManager.wave-1));\n            writer.newLine();\n\n            writer.write(\"playerX=\" + gamePanel.player.getX());\n            writer.newLine();\n            writer.write(\"playerY=\" + gamePanel.player.getY());\n            writer.newLine();\n\n            writer.write(\"playerS=\" + gamePanel.player.score);\n            writer.newLine();\n\n            writer.write(\"playerH=\" + gamePanel.player.getHealth());\n            writer.newLine();\n            writer.write(\"playerF=\" + gamePanel.player.getFatigue());\n            writer.newLine();\n\n            writer.write(\"cameraX=\" + gamePanel.camera.getX());\n            writer.newLine();\n            writer.write(\"cameraY=\" + gamePanel.camera.getY());\n            writer.newLine();\n\n            writer.write(\"deadZombies=\" + gamePanel.waveManager.dead);\n            writer.newLine();\n\n            writer.write(\"magazine2=\" + gamePanel.rifle.magazine);\n            writer.newLine();\n            writer.write(\"capacity2=\" + gamePanel.rifle.currentcapacity);\n            writer.newLine();\n\n            writer.write(\"magazine3=\" + gamePanel.shotgun.magazine);\n            writer.newLine();\n            writer.write(\"capacity3=\" + gamePanel.shotgun.currentcapacity);\n            writer.newLine();\n\n            writer.write(\"magazine4=\" + gamePanel.sniper.magazine);\n            writer.newLine();\n            writer.write(\"capacity4=\" + gamePanel.sniper.currentcapacity);\n            writer.newLine();\n\n            writer.write(\"magazine5=\" + gamePanel.rocket.magazine);\n            writer.newLine();\n            writer.write(\"capacity5=\" + gamePanel.rocket.currentcapacity);\n            writer.newLine();\n\n            System.out.println(\"SAVED\");\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void loadGame() {\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"save.txt\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] parts = line.split(\"=\");\n                String key = parts[0];\n                String value = parts[1];\n\n                switch (key) {\n                    case \"wave\":\n                        gamePanel.waveManager.wave = Integer.parseInt(value);\n                        break;\n                    case \"rain\":\n                        Settings.rain = Boolean.parseBoolean(value);\n                        break;\n                    case \"extreme\":\n                        Settings.extreme = Boolean.parseBoolean(value);\n                        break;\n                    case \"playerX\":\n                        gamePanel.player.setX(Integer.parseInt(value));\n                        break;\n                    case \"playerY\":\n                        gamePanel.player.setY(Integer.parseInt(value));\n                        break;\n                    case \"playerS\":\n                        gamePanel.player.score = Integer.parseInt(value);\n                        break;\n                    case \"playerH\":\n                        gamePanel.player.setHealth(Double.parseDouble(value));\n                        break;\n                    case \"playerF\":\n                        gamePanel.player.setFatigue(Double.parseDouble(value));\n                        break;\n                    case \"cameraX\":\n                        gamePanel.camera.setX(Integer.parseInt(value));\n                        break;\n                    case \"cameraY\":\n                        gamePanel.camera.setY(Integer.parseInt(value));\n                        break;\n                    case \"deadZombies\":\n                        gamePanel.waveManager.dead = Integer.parseInt(value);\n                        break;\n                    case \"magazine2\":\n                        gamePanel.rifle.magazine = Integer.parseInt(value);\n                        break;\n                    case \"capacity2\":\n                        gamePanel.rifle.currentcapacity = Integer.parseInt(value);\n                        break;\n                    case \"magazine3\":\n                        gamePanel.shotgun.magazine = Integer.parseInt(value);\n                        break;\n                    case \"capacity3\":\n                        gamePanel.shotgun.currentcapacity = Integer.parseInt(value);\n                        break;\n                    case \"magazine4\":\n                        gamePanel.sniper.magazine = Integer.parseInt(value);\n                        break;\n                    case \"capacity4\":\n                        gamePanel.sniper.currentcapacity = Integer.parseInt(value);\n                        break;\n                    case \"magazine5\":\n                        gamePanel.rocket.magazine = Integer.parseInt(value);\n                        break;\n                    case \"capacity5\":\n                        gamePanel.rocket.currentcapacity = Integer.parseInt(value);\n                        break;\n                }\n            }\n            System.out.println(\"LOAD\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "Pistol.java": "import java.io.File;\n\nimport javax.swing.ImageIcon;\n\npublic class Pistol extends Weapon{\n\n    GamePanel game;\n\n    public Pistol(GamePanel game){\n        capacity = 12;\n        currentcapacity = 12;\n        shootSpeed = 120;\n        magazine = Integer.MAX_VALUE;\n        wave = 0;\n        reloadCooldown = 5000;\n        this.game = game;\n        name = \"Pistol\";\n        image = new ImageIcon(\"Textures/weapons/pistol.png\");\n        bulletImage = new ImageIcon(this.getClass().getResource(\"/textures/weapons/Pistol_Bullet.png\"));\n        soundPath = new File(\"pistolSound.wav\");\n    }\n\n    void shoot(int mouseX, int mouseY) {\n        if(currentcapacity>0){\n            if(Settings.volume){\n                playSound();\n            }\n            currentcapacity -= 1;\n            game.addBullet(mouseX, mouseY);\n        }\n        \n    }\n\n}\n",
      "GamePanel.java": "import java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Random;\n\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport javax.sound.sampled.LineUnavailableException;\nimport javax.sound.sampled.UnsupportedAudioFileException;\nimport javax.swing.ImageIcon;\nimport javax.swing.JPanel;\n\nclass GamePanel extends JPanel{\n\n\n    public ArrayList<Bullet> bullets = new ArrayList<>();\n\n    int playerWidth = 96;\n    int playerHeight = 96;\n    \n    int playerSpeed = 5;\n    public Player player = new Player(480, 270, playerWidth, playerHeight, playerSpeed, this);\n    public Camera camera = new Camera(0, 0, 0, 0);\n    public Background bg = new Background(0, 0, 6144, 3456);\n    private MouseCursor mouseCursor = new MouseCursor(0, 0, 32, 32);\n    ArrayList<Building> buildings = new ArrayList<>();\n\n    ImageIcon gif = new ImageIcon(this.getClass().getResource(\"/textures/UI/rain.gif\"));\n\n    Pistol pistol = new Pistol(this);\n    Rifle rifle = new Rifle(this);\n    Shotgun shotgun = new Shotgun(this);\n    Sniper sniper = new Sniper(this);\n    RocketLauncher rocket = new RocketLauncher(this);\n    Weapon currentWeapon = pistol;\n\n    \n\n    protected double mouseAngle = 0;\n\n    private KeyInput keyInput = new KeyInput();\n    private MouseInput mouseInput;\n\n    int active = 0;\n\n    private Image playerImage = new ImageIcon(\"textures/player/player_icon.png\").getImage();\n    private Image weaponImage;\n    private Font uiFont;\n\n    public long lastReloadTime = 0;\n    public long currentTime = 0;\n    public long deadTime = 0;\n    long pauseTime = 0;\n\n    GameOver gameOver = new GameOver(0, 0, 0, 0);\n    Pause pause = new Pause(0, 0, 0, 0);\n\n    int panelHeight;\n    int panelWidth;\n\n    File rainSound = new File(\"rain.wav\");\n    AudioInputStream rainInput;\n    Clip rainClip;\n    File musicSound = new File(\"music.wav\");\n    AudioInputStream musicInput;\n    Clip musicClip;\n\n    boolean isPaused;\n\n    WaveManager waveManager = new WaveManager(this);\n\n    private GameSaveManager saveManager;\n\n    Window window;\n    \n    public GamePanel(Window window) throws UnsupportedAudioFileException, IOException, LineUnavailableException{\n        this.window = window;\n        setFocusable(true);\n        requestFocus();\n        setLayout(null);\n        player.setVisible(true);\n        addKeyListener(keyInput);\n\n        rainInput = AudioSystem.getAudioInputStream(rainSound);\n        rainClip = AudioSystem.getClip();\n        rainClip.open(rainInput);\n        rainClip.setFramePosition(0);\n\n        musicInput = AudioSystem.getAudioInputStream(musicSound);\n        musicClip = AudioSystem.getClip();\n        musicClip.open(musicInput);\n        musicClip.setFramePosition(0);\n\n        if(Settings.volume){\n            musicClip.loop(Clip.LOOP_CONTINUOUSLY);\n            if(Settings.rain){\n                rainClip.loop(Clip.LOOP_CONTINUOUSLY);\n            }\n            \n        }\n        \n        for(int i = 0; i < 23; i++){\n            buildings.add(new Building(0, 0, 512, 512));\n        }\n        \n        for(Building building: buildings){\n            building.getPlayer(player);\n        }\n\n        currentWeapon = pistol;\n        player.changeImage(currentWeapon);\n        lastReloadTime = System.currentTimeMillis();\n\n        weaponImage = currentWeapon.image.getImage();\n\n        mouseInput = new MouseInput(this, currentWeapon);\n        addMouseMotionListener(mouseInput);\n        addMouseListener(mouseInput);\n\n        saveManager = new GameSaveManager(this);\n        saveManager.loadGame();\n        saveManager.loadSettings();\n\n        setBuildings();\n        \n    }\n\n    public void MousePressed(int mouseX, int mouseY){\n        addBullet(mouseX, mouseY);\n    }\n\n    private void renderUI(Graphics g, int w, int h) {\n        Graphics2D g2d = (Graphics2D) g;\n\n        uiFont = new Font(\"Courier New\", Font.BOLD, w/60);\n        g2d.setFont(uiFont);\n\n        g2d.setColor(new Color(0, 0, 0, 150));\n        g2d.fillRoundRect(w - (int)(w/3.8) - (int)(w/100), (int)(w/100), (int)(w/3.8), w/14, 20, 20);\n        g2d.fillRoundRect((int)(w/100), (int)(w/100), (int)(w/4.5), w/20, 20, 20);\n\n        g2d.drawImage(playerIcon(player.getHealth()).getImage(), w - w/16 - w/72, w/72, w/16, w/16, null);\n        g2d.setColor(Color.WHITE);\n        g2d.drawString(\"Score:\" + player.score, w - w/4, w/15);\n\n        uiFont = new Font(\"Courier New\", Font.BOLD, w/80);\n        g2d.setFont(uiFont);\n\n\n        g2d.drawImage(weaponImage, w/55, w/65, w/24, w/24, null);\n\n        g2d.setColor(Color.RED);\n        g2d.fillRect(w - w/6 - w/12, w/48, (int)(player.getHealth()*w/6/100), w/96);\n\n        g2d.setColor(Color.WHITE);\n        g2d.drawRect(w - w/6 - w/12, w/48, w/6, w/96); \n\n        g2d.setColor(new Color(0,75,150));\n        g2d.fillRect(w - w/6 - w/12, w/32, (int)(player.getFatigue()*w/6/100), w/96);\n\n        g2d.setColor(Color.WHITE);\n        g2d.drawRect(w- w/6 - w/12, w/32, w/6, w/96); \n\n        int reloadBar = (int)((currentTime-lastReloadTime)*currentWeapon.reloadCooldown/7/w/24);\n        if(reloadBar>w/24){\n            reloadBar = w/24;\n        }\n\n        g2d.setColor(new Color(75,150,0));\n        g2d.fillRect(w/55, w/60, reloadBar, w/160); \n\n        g2d.setColor(Color.WHITE);\n        g2d.drawRect(w/55, w/60, w/24, w/160);\n\n        g2d.setColor(Color.WHITE);\n        g2d.drawString(\"Bullet: \" + currentWeapon.currentcapacity + \"/\" + currentWeapon.magazine, w/15, w/20);\n        g2d.drawString(\"Weapon: \" + currentWeapon.name, w/15, w/35);\n\n        g2d.setColor(new Color(200,100,0,255));\n        g2d.fillRect(w/3, w/50, (int)(((double)(waveManager.zombies.size())/waveManager.wave/waveManager.mult)*w/3), w/50);\n    \n        g2d.setColor(Color.WHITE);\n        g2d.drawRect(w/3, w/50, w/3, w/50);\n        g2d.drawString(\"Wave: \" + waveManager.wave, w/3, w/50);\n        String str = waveManager.zombies.size() + \"/\" + (int)(waveManager.wave*waveManager.mult);\n        g2d.drawString(str, w/3 + w/3 - str.length()*w/130, w/25);\n\n        g2d.drawString(\"Press 'K' to save the game\", w - w/5, h - h/35);\n        \n    }\n\n    public ImageIcon playerIcon(double health){\n        if(health>80){\n            return new ImageIcon(\"textures/player/player_icon.png\");\n        }\n        else if(health>60){\n            return new ImageIcon(\"textures/player/player_icon2.png\");\n        }\n        else if(health>40){\n            return new ImageIcon(\"textures/player/player_icon3.png\");\n        }\n        else if(health>20){\n            return new ImageIcon(\"textures/player/player_icon4.png\");\n        }\n        else{\n            return new ImageIcon(\"textures/player/player_icon5.png\");\n        }\n    }\n\n    public int getRandomNumber(int min, int max) {\n        return (int) ((Math.random() * (max - min)) + min);\n    }\n\n\n    public void addBullet(int x, int y){\n\n        double ang = 0;\n\n        if(currentWeapon instanceof Pistol){\n            ang = 0;\n            bullets.add(new Bullet(player.getX() - camera.getX() + player.getWidth()/2, player.getY() - camera.getY() + player.getHeight()/2, x, y, currentWeapon, ang, waveManager, camera));\n        }\n        else if(currentWeapon instanceof Rifle){\n            ang = getRandomNumber(-15, 15);\n            bullets.add(new Bullet(player.getX() - camera.getX() + player.getWidth()/2, player.getY() - camera.getY() + player.getHeight()/2, x, y, currentWeapon, ang, waveManager, camera));\n        }\n        else if(currentWeapon instanceof Shotgun){\n            \n            ang = -22.5;\n\n            for(int i = 0; i < 9; i++){\n                bullets.add(new Bullet(player.getX() - camera.getX() + player.getWidth()/2, player.getY() - camera.getY() + player.getHeight()/2, x, y, currentWeapon, ang, waveManager, camera));\n                ang += 5.0;\n            }\n        }\n\n        else if(currentWeapon instanceof Sniper){\n            ang = 0;\n            bullets.add(new Bullet(player.getX() - camera.getX() + player.getWidth()/2, player.getY() - camera.getY() + player.getHeight()/2, x, y, currentWeapon, ang, waveManager, camera));\n        }\n\n        else if(currentWeapon instanceof RocketLauncher){\n            ang = 0;\n            bullets.add(new Bullet(player.getX() - camera.getX() + player.getWidth()/2, player.getY() - camera.getY() + player.getHeight()/2, x, y, currentWeapon, ang, waveManager, camera));\n        }\n        \n    }\n\n    public void setBuildings(){\n        int a = 64;\n        buildings.get(0).setX(bg.x+2*a);\n        buildings.get(0).setY(bg.y+6*a);\n        buildings.get(0).setBuilding(0);\n        buildings.get(1).setX(bg.x+2*a);\n        buildings.get(1).setY(bg.y+17*a);\n        buildings.get(1).setBuilding(6);\n        buildings.get(2).setX(bg.x+2*a);\n        buildings.get(2).setY(bg.y+27*a);\n        buildings.get(2).setBuilding(13);\n        buildings.get(3).setX(bg.x+2*a);\n        buildings.get(3).setY(bg.y+44*a);\n        buildings.get(3).setBuilding(3);\n        buildings.get(4).setX(bg.x+19*a);\n        buildings.get(4).setY(bg.y+2*a);\n        buildings.get(4).setBuilding(3);\n        buildings.get(5).setX(bg.x+19*a);\n        buildings.get(5).setY(bg.y+12*a);\n        buildings.get(5).setBuilding(11);\n        buildings.get(6).setX(bg.x+19*a);\n        buildings.get(6).setY(bg.y+29*a);\n        buildings.get(6).setBuilding(2);\n        buildings.get(7).setX(bg.x+19*a);\n        buildings.get(7).setY(bg.y+39*a);\n        buildings.get(7).setBuilding(1);\n        buildings.get(8).setX(bg.x+29*a);\n        buildings.get(8).setY(bg.y+2*a);\n        buildings.get(8).setBuilding(7);\n        buildings.get(9).setX(bg.x+29*a);\n        buildings.get(9).setY(bg.y+12*a);\n        buildings.get(9).setBuilding(4);\n        buildings.get(10).setX(bg.x+29*a);\n        buildings.get(10).setY(bg.y+29*a);\n        buildings.get(10).setBuilding(7);\n        buildings.get(11).setX(bg.x+29*a);\n        buildings.get(11).setY(bg.y+39*a);\n        buildings.get(11).setBuilding(5);\n        buildings.get(12).setX(bg.x+39*a);\n        buildings.get(12).setY(bg.y+29*a);\n        buildings.get(12).setBuilding(3);\n        buildings.get(13).setX(bg.x+39*a);\n        buildings.get(13).setY(bg.y+39*a);\n        buildings.get(13).setBuilding(9);\n        buildings.get(14).setX(bg.x+46*a);\n        buildings.get(14).setY(bg.y+2*a);\n        buildings.get(14).setBuilding(6);\n        buildings.get(15).setX(bg.x+46*a);\n        buildings.get(15).setY(bg.y+12*a);\n        buildings.get(15).setBuilding(9);\n        buildings.get(16).setX(bg.x+56*a);\n        buildings.get(16).setY(bg.y+29*a);\n        buildings.get(16).setBuilding(2);\n        buildings.get(17).setX(bg.x+56*a);\n        buildings.get(17).setY(bg.y+39*a);\n        buildings.get(17).setBuilding(12);\n        buildings.get(18).setX(bg.x+73*a);\n        buildings.get(18).setY(bg.y+29*a);\n        buildings.get(18).setBuilding(8);\n        buildings.get(19).setX(bg.x+73*a);\n        buildings.get(19).setY(bg.y+46*a);\n        buildings.get(19).setBuilding(3);\n        buildings.get(20).setX(bg.x+83*a);\n        buildings.get(20).setY(bg.y+12*a);\n        buildings.get(20).setBuilding(5);\n        buildings.get(21).setX(bg.x+83*a);\n        buildings.get(21).setY(bg.y+29*a);\n        buildings.get(21).setBuilding(10);\n        buildings.get(22).setX(bg.x+83*a);\n        buildings.get(22).setY(bg.y+46*a);\n        buildings.get(22).setBuilding(7);\n    }\n\n    \n\n    protected void paintComponent(Graphics g){\n        super.paintComponent(g);\n\n        panelHeight = getHeight();\n        panelWidth = getWidth();\n\n        setPreferredSize(new Dimension(panelWidth,panelHeight));\n\n        g.setColor(new Color(237,201,175));\n        g.fillRect(0, 0, panelWidth, panelHeight);\n\n\n        camera.follow(player, panelWidth, panelHeight, 6144,3456);\n\n        bg.setX(-camera.getX());\n        bg.setY(-camera.getY());\n\n        Graphics2D g2d = (Graphics2D)g;\n\n        bg.draw(g);\n\n        if((!(bg.x>0) && (!(bg.x<-4280)))|| (!(bg.y<-2430) && !(bg.y>0))){  \n            setBuildings();\n        }\n\n        for (Building building : buildings) {\n            building.draw((Graphics2D)g);\n        }\n\n        g2d.translate(player.getX() - camera.getX() + player.getWidth()/2, player.getY() - camera.getY() + player.getHeight()/2);\n        g2d.rotate(mouseAngle);        \n            \n        player.draw(g2d);\n\n        waveManager.render((Graphics2D)g, camera);\n\n        for (Bullet bullet : bullets) {\n            bullet.draw((Graphics2D)g);\n        }\n\n        mouseCursor.draw((Graphics2D)g, mouseInput.getMouseX(), mouseInput.getMouseY());\n\n        if(Settings.rain){\n            g.drawImage(gif.getImage(), 0, 0, panelWidth, panelHeight, null);\n        }\n\n        g.setColor(new Color(0,0,0,150-(int)player.getFatigue()));\n        g.fillRect(0,0,panelWidth,panelHeight);\n\n        g.setColor(new Color(128,0,0,50-(int)player.getHealth()/2));\n        g.fillRect(0,0,panelWidth,panelHeight);\n\n            \n            \n        renderUI(g, panelWidth, panelHeight);\n\n        if(player.isDead()){\n            gameOver.set(panelWidth, panelHeight);\n            gameOver.draw((Graphics2D)g);\n        }\n\n        if(isPaused){\n            pause.set(panelWidth, panelHeight);\n            pause.draw((Graphics2D)g);\n        }\n        \n        \n    }\n\n    public void update(){\n        if(!isPaused){\n            update2();\n        }\n        else{\n            if(keyInput.isESC()){\n                rainClip.stop();\n                musicClip.stop();\n                musicClip = null;\n                rainClip = null;\n                window.switchToMenu();\n            }\n        }\n\n        currentTime = System.currentTimeMillis();\n\n        pause.update();\n        \n        repaint();\n\n        if(keyInput.isP() && currentTime - pauseTime > 1000){\n            pauseTime = currentTime;\n            isPaused = !isPaused;\n        }\n    }\n\n\n\n    public void update2(){\n\n        repaint();\n\n        \n\n        //System.out.println(\"Player Position - X: \" + player.getX() + \", Y: \" + player.getY());\n        //System.out.println(bg.getX());\n        //System.out.println(bg.y);\n        //System.out.println(camera.getY());\n\n        if(!player.isDead()){\n            player.update();\n            mouseInput.update();\n            mouseCursor.update();\n            mouseAngle = Math.PI/2 + Math.atan2(mouseInput.getMouseY() - (player.getY() - camera.getY() + player.getHeight()/2) , mouseInput.getMouseX() - (player.getX() - camera.getX() + player.getWidth()/2));\n        }\n        else{\n            gameOver.update();\n        }\n\n        if (player.getX() < 0) {\n            player.setX(0);\n        }\n        if (player.getY() < 0) {\n            player.setY(0);\n        }\n        if (player.getX() + player.getWidth() > bg.getWidth()) {\n            player.setX(bg.getWidth() - player.getWidth());\n        }\n        if (player.getY() + player.getHeight() > bg.getHeight()) {\n            player.setY(bg.getHeight() - player.getHeight());\n        }\n\n        waveManager.update();\n        \n        for (int i = 0; i < bullets.size(); i++) {\n            Bullet b = bullets.get(i);\n            b.update();\n            \n            if (b.isOutOfBounds()) {\n                b.enabled = false;\n            }\n\n            if(!b.enabled){\n                bullets.remove(i);\n                i--;\n            }\n        }\n\n            if(keyInput.isDown()){\n                player.velY = player.getSpeed();\n            }\n            else if(!keyInput.isUp()){\n                player.velY = 0;\n            }\n\n            if(keyInput.isUp()){\n                player.velY = player.getSpeed() * -1;\n            }\n\n            else if(!keyInput.isDown()){\n                player.velY = 0;\n            }\n\n            if(keyInput.isLeft()){\n                player.velX = player.getSpeed() * -1;\n            }\n\n            else if(!keyInput.isRight()){\n                player.velX = 0;\n            }\n\n            if(keyInput.isRight()){\n                player.velX = player.getSpeed();\n            }\n\n            else if(!keyInput.isLeft()){\n                player.velX = 0;\n            }\n\n        if(keyInput.isR()){\n            if(currentTime - lastReloadTime > currentWeapon.reloadCooldown){\n                \n                if(currentWeapon.magazine>0){\n                    currentWeapon.reload();\n                    lastReloadTime = currentTime;\n                }\n\n                \n            }\n        }\n\n        if(keyInput.isT() && player.isDead()){\n            player.setHealth(100);\n            player.setFatigue(100);\n            deadTime = currentTime;\n            gameOver = new GameOver(0, 0, 0, 0);\n            player.score -= 50 * waveManager.wave;\n        }\n\n        if(keyInput.isK()){\n            saveManager.saveGame();\n        }\n\n        if(keyInput.isP()){\n            pause = new Pause(0, 0, 0, 0);\n        }\n\n        if(keyInput.is1()){\n            currentWeapon = pistol;\n            player.changeImage(currentWeapon);\n            weaponImage = currentWeapon.image.getImage();\n            mouseInput = new MouseInput(this, currentWeapon);\n            addMouseMotionListener(mouseInput);\n            addMouseListener(mouseInput);\n\n        }\n\n        if(keyInput.is2() && waveManager.wave >= rifle.wave){\n            currentWeapon = rifle;\n            player.changeImage(currentWeapon);\n            weaponImage = currentWeapon.image.getImage();\n            mouseInput = new MouseInput(this, currentWeapon);\n            addMouseMotionListener(mouseInput);\n            addMouseListener(mouseInput);\n        }\n\n        if(keyInput.is3() && waveManager.wave >= shotgun.wave){\n            currentWeapon = shotgun;\n            player.changeImage(currentWeapon);\n            weaponImage = currentWeapon.image.getImage();\n            mouseInput = new MouseInput(this, currentWeapon);\n            addMouseMotionListener(mouseInput);\n            addMouseListener(mouseInput);\n        }\n\n        if(keyInput.is4() && waveManager.wave >= sniper.wave){\n            currentWeapon = sniper;\n            player.changeImage(currentWeapon);\n            weaponImage = currentWeapon.image.getImage();\n            mouseInput = new MouseInput(this, currentWeapon);\n            addMouseMotionListener(mouseInput);\n            addMouseListener(mouseInput);\n        }\n\n        if(keyInput.is5() && waveManager.wave >= rocket.wave){\n            currentWeapon = rocket;\n            player.changeImage(currentWeapon);\n            weaponImage = currentWeapon.image.getImage();\n            mouseInput = new MouseInput(this, currentWeapon);\n            addMouseMotionListener(mouseInput);\n            addMouseListener(mouseInput);\n        }\n        \n        if(bg.getX()>1){\n            bg.setX(0);\n        }\n\n        if(bg.getY()>1){\n            bg.setY(0);\n        }\n\n        if(bg.getX()<-4281){\n            bg.setX(-4280);\n        }\n\n        if(bg.getY()<-2431){\n            bg.setY(-2430);\n        }\n\n        if(keyInput.isShift() && !player.isDead()){\n            if(player.getFatigue()>0){\n                player.setSpeed(10);\n                player.setFatigue(player.getFatigue()-0.25);\n            }\n            else{\n                player.setSpeed(5);\n            }\n            \n        }\n        else{\n            player.setSpeed(5);\n            player.setFatigue(player.getFatigue()+0.5);\n            \n        }\n    }\n}",
      "UIElement.java": "import java.awt.Graphics2D;\n\nimport javax.swing.ImageIcon;\n\npublic class UIElement extends GameObject {\n\n    ImageIcon button;\n\n    public UIElement(int x, int y, int width, int height, ImageIcon imageIcon) {\n        super(x, y, width, height);\n        button = imageIcon;\n    }\n\n    public void draw(Graphics2D g) {\n        g.drawImage(button.getImage(), x, y, width, height, null);\n    }\n\n}\n",
      "HealthKit.java": "import java.awt.Graphics2D;\n\nimport javax.swing.ImageIcon;\n\npublic class HealthKit extends GameObject{\n\n    ImageIcon healthKit = new ImageIcon(this.getClass().getResource(\"/textures/zombies/healthkit.gif\"));\n\n    public HealthKit(int x, int y, int width, int height) {\n        super(x, y, width, height);\n    }\n    \n    public void draw2(Graphics2D g, Camera cam) {\n        g.drawImage(healthKit.getImage(), x - cam.x, y - cam.y, width, height, null);\n    }\n\n    public void draw(Graphics2D g) {\n        throw new UnsupportedOperationException(\"Unimplemented method 'draw'\");\n    }\n\n}\n",
      "Rifle.java": "import java.io.File;\n\nimport javax.swing.ImageIcon;\n\npublic class Rifle extends Weapon{\n\n    GamePanel game;\n\n    public Rifle(GamePanel game){\n        capacity = 30;\n        currentcapacity = 30;\n        shootSpeed = 600;\n        wave = 2;\n        reloadCooldown = 5000;\n        this.game = game;\n        name = \"Rifle\";\n        image = new ImageIcon(\"Textures/weapons/rifle.png\");\n        bulletImage = new ImageIcon(this.getClass().getResource(\"/textures/weapons/Rifle_Bullet.png\"));\n        soundPath = new File(\"rifleSound.wav\");\n    }\n\n    void shoot(int mouseX, int mouseY) {\n        if(currentcapacity>0){\n            if(Settings.volume){\n                playSound();\n            }\n            currentcapacity -= 1;\n            game.addBullet(mouseX, mouseY);\n        }\n        \n    }\n    \n}\n",
      "Explosion.java": "import java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.Toolkit;\nimport java.io.File;\n\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\n\npublic class Explosion extends GameObject{\n\n    Image explosion;\n\n    public File explosionPath = new File(\"explosionSound.wav\");\n    public AudioInputStream audioInput;\n    public Clip clip;\n\n    public Explosion(int x, int y, int width, int height) {\n            super(x, y, width, height);\n            explosion = Toolkit.getDefaultToolkit().createImage(this.getClass().getResource(\"/textures/weapons/explosion.gif\"));\n\n            if(Settings.volume){\n                try{\n                    audioInput = AudioSystem.getAudioInputStream(explosionPath);\n                    clip = AudioSystem.getClip();\n                    clip.open(audioInput);\n                    clip.setFramePosition(0);\n                    clip.start();\n                    System.out.println(\"E\");\n                }\n    \n                catch(Exception e){\n    \n                }\n            }\n\n        }\n\n    public void draw2(Graphics2D g, Camera cam) {\n        g.drawImage(explosion, x - cam.x, y - cam.y, width, height, null);\n    }\n\n    public void draw(Graphics2D g) {\n\n    }\n\n    public void update() {\n\n    }\n    \n}\n",
      "Background.java": "import java.awt.Graphics;\nimport java.awt.Graphics2D;\n\nimport javax.swing.ImageIcon;\n\npublic class Background extends GameObject {\n\n    public ImageIcon backgroundImage1 = new ImageIcon(this.getClass().getResource(\"/textures/backgrounds/city.png\"));\n    public ImageIcon black = new ImageIcon(this.getClass().getResource(\"/textures/backgrounds/bg2.png\"));\n\n\n    public Background(int x, int y, int width, int height){\n        super(x, y, width, height);\n    }\n\n    public void update() {\n\n    }\n\n    public void draw(Graphics2D g) {\n        \n    }\n\n    public void draw(Graphics g) {\n        g.drawImage(backgroundImage1.getImage(), x, y, width, height, null);\n        g.drawImage(black.getImage(), x, y, width, height, null);\n    }\n    \n}\n",
      "TankZombie.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.geom.AffineTransform;\n\nimport javax.swing.ImageIcon;\n\npublic class TankZombie extends Zombie{\n\n    private ImageIcon tankZombieImage = new ImageIcon(this.getClass().getResource(\"/textures/zombies/tankzombie.png\"));\n    \n\n    public TankZombie(int x, int y, Player player, Camera camera){\n        super(x,y,96,96);\n        this.health = 40;\n        this.speed = 2;\n        this.damage = 0.3;\n        this.player = player;\n        this.camera = camera;\n        this.visible = true;\n    }\n\n\n    void attack() {\n        if (isNearPlayer && player.isPlayerAttackable()) {\n            player.setHealth(player.getHealth()-damage);\n            //System.out.println(\"attack \" + player.getHealth());\n        }\n    }\n\n\n    public void update() {\n        double dx = player.x - x;\n        double dy = player.y - y;\n\n        // İki nokta arasındaki mesafe\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if(distance < 1000){\n            moveTowardsPlayer();\n        }\n        attack();\n    }\n\n    public void draw2(Graphics2D g) {\n        if (visible) {\n    \n            // Oyuncunun merkezi ile zombinin merkezi arasındaki açı\n            double dx = player.getX() + player.getWidth() / 2.0 - (x + width/2);\n            double dy = player.getY() + player.getHeight() / 2.0 - (y + height/2);\n            double angle = Math.atan2(dy, dx) + Math.PI / 2;\n    \n\n            g.translate(x - camera.getX() + width/2, y - camera.getY() + height/2);\n            g.rotate(angle);\n\n            g.drawImage(tankZombieImage.getImage(), -width/2, -height/2, width, height, null);\n            g.setTransform(new AffineTransform());\n\n            g.setColor(new Color(215,0,0));\n            g.fillRect(x - camera.getX() + 15, y - camera.getY(), (int)((width-30) * (health / 40)), 5);\n            g.setColor(new Color(255,255,255));\n            g.drawRect(x - camera.getX() + 15, y - camera.getY(), (width-30), 5);\n        }\n\n        \n\n        Rectangle bounds1 = new Rectangle((int) x - camera.x, (int) y - camera.y, width, height);\n\n        //g.draw(bounds1);\n    }\n\n\n    @Override\n    public void draw(Graphics2D g) {\n        // TODO Auto-generated method stub\n        throw new UnsupportedOperationException(\"Unimplemented method 'draw'\");\n    }\n\n}\n",
      "AcidArea.java": "import java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.Toolkit;\nimport java.io.File;\n\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\n\npublic class AcidArea extends GameObject{\n\n    Image acid;\n\n    public File acidPath = new File(\"acid.wav\");\n    public AudioInputStream audioInput;\n    public Clip clip;\n\n    public AcidArea(int x, int y, int width, int height) {\n            super(x, y, width, height);\n            acid = Toolkit.getDefaultToolkit().createImage(this.getClass().getResource(\"/textures/zombies/acid.gif\"));\n\n            if(Settings.volume){\n                try{\n                    audioInput = AudioSystem.getAudioInputStream(acidPath);\n                    clip = AudioSystem.getClip();\n                    clip.open(audioInput);\n                    clip.setFramePosition(0);\n                    clip.start();\n                    System.out.println(\"E\");\n                }\n    \n                catch(Exception e){\n    \n                }\n            }\n            \n\n        }\n\n    public void draw2(Graphics2D g, Camera cam) {\n        g.drawImage(acid, x - cam.x, y - cam.y, (int)(width*1.5), (int)(height*1.5), null);\n    }\n\n    public void draw(Graphics2D g) {\n\n    }\n\n    public void update() {\n        \n    }\n    \n}\n",
      "GameOver.java": "import java.awt.AlphaComposite;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\n\nimport javax.swing.ImageIcon;\n\npublic class GameOver extends GameObject{\n\n    int a;\n    private Font uiFont;\n    ImageIcon deadIcon = new ImageIcon(this.getClass().getResource(\"/textures/UI/dead.png\"));\n\n    public GameOver(int x, int y, int width, int height) {\n        super(x, y, width, height);\n        \n    }\n\n    public void set(int w, int h){\n        width = w;\n        height = h;\n        uiFont = new Font(\"Courier New\", Font.BOLD, w/40);\n    }\n\n    public void update(){    \n        if(a<150) a += 3;\n    }\n\n    public void draw(Graphics2D g) {\n        g.setColor(new Color(0,0,0,a));\n        g.fillRect(0, 0, width , height);\n        g.setColor(new Color(255,255,255));\n        g.setFont(uiFont);\n        float alpha = a/150.0f;\n        AlphaComposite ac = AlphaComposite.getInstance(AlphaComposite.SRC_OVER,alpha);\n        g.setComposite(ac);\n        g.drawImage(deadIcon.getImage(), width/3, width/8,width/3,width/18, null);\n        g.drawString(\"Press 'T' for respawn\", width/2 - (int)(width/6.5), height/2);\n    }\n\n}\n",
      "Game.java": "import java.awt.Cursor;\nimport java.awt.Image;\nimport java.awt.Point;\nimport java.awt.Toolkit;\nimport java.awt.image.MemoryImageSource;\nimport java.io.IOException;\nimport javax.sound.sampled.LineUnavailableException;\nimport javax.sound.sampled.UnsupportedAudioFileException;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\n\npublic class Game{\n    static Window window;\n    public static void main(String[] args) throws IOException{\n        create();\n        \n    }\n\n    public static void create(){\n        \n        try {\n            window = new Window();\n            window.start();\n            window.run();\n        } catch (UnsupportedAudioFileException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (LineUnavailableException e) {\n            e.printStackTrace();\n        }\n\n        \n    }\n\n    public static void close(){\n        window.dispose();\n    }\n}\n\nclass Window extends JFrame{\n\n    private GamePanel gamePanel;\n    private Menu menuPanel;\n    private Thread thread;\n    private boolean running = false;\n    public static int width = 960;\n    public static int height = 540;\n    \n    public static boolean gameOn = false;\n    public static boolean fs = false;\n\n    public void start(){\n        running = true;\n        thread = new Thread();\n        thread.start();\n    }\n\n    public void run(){\n        while(running){\n            update();\n            repaint();\n            try{\n                Thread.sleep(16);  \n            }\n            catch(InterruptedException e){\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void update(){\n\n        if(gameOn && gamePanel!=null){\n            gamePanel.update();\n        }\n        else{\n            menuPanel.update();\n        }\n\n        setSize(width,height);\n    }\n\n    public Cursor pointer(){\n\n        int[] pixels = new int[16 * 16];\n\n        Image image = Toolkit.getDefaultToolkit().createImage(new MemoryImageSource(16, 16, pixels, 0, 16));\n        Cursor transparentCursor = Toolkit.getDefaultToolkit().createCustomCursor(image, new Point(0, 0), \"invisibleCursor\");\n        return transparentCursor;\n    }\n\n    GameSaveManager saveManager = new GameSaveManager();\n\n    public Window() throws UnsupportedAudioFileException, IOException, LineUnavailableException{\n        \n        if(gameOn){\n            gamePanel = new GamePanel(this);\n            add(gamePanel);\n        }\n        else{\n            menuPanel = new Menu(this);\n            add(menuPanel);\n        }\n        \n        ImageIcon gameIcon = new ImageIcon(this.getClass().getResource(\"/textures/icon.png\"));\n\n        setSize(width,height);\n        setLocation((int)Toolkit.getDefaultToolkit().getScreenSize().getWidth()/2 - width/2, (int)Toolkit.getDefaultToolkit().getScreenSize().getHeight()/2 - height/2);\n        //setExtendedState(JFrame.MAXIMIZED_BOTH); //TAM EKRAN İÇİN\n        setUndecorated(fs);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        setTitle(\"Gravewave\");\n        setIconImage(gameIcon.getImage());\n        setCursor(pointer());\n        setVisible(true);\n        setResizable(false);\n\n        saveManager.loadSettings();\n\n        if(Settings.fullscreen){\n            fs = false;\n            fullScreen();\n            changeSize((int)Toolkit.getDefaultToolkit().getScreenSize().getWidth(), (int)Toolkit.getDefaultToolkit().getScreenSize().getHeight());\n        }\n        else{\n            fs = true;\n            changeSize(960, 540);\n            fullScreen();\n        }\n\n    }\n\n    public void switchToMenu() {\n        gameOn = false;\n        Game.close();\n        Game.create();\n    }\n\n    public void changeSize(int w, int h){\n        width = w;\n        height = h;\n    }\n\n    public void fullScreen(){\n        \n        if(!fs){\n            dispose();\n            fs = true;\n            setUndecorated(true);\n            setExtendedState(MAXIMIZED_BOTH);\n            setVisible(true);\n        }\n        else{\n            dispose();\n            fs = false;\n            setUndecorated(false);\n            setLocationRelativeTo(null);\n            setVisible(true);\n        }\n        \n    }\n}",
      "MouseInput.java": "import java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\nimport javax.swing.JPanel;\n\npublic class MouseInput extends MouseAdapter{\n    private int mouseX, mouseY;\n    private JPanel game;\n    public boolean isMousePressed;\n\n    Weapon weapon;\n\n    private long lastBulletTime = 0;\n    public static long bulletFireInterval = 500;\n\n    public void update(){\n\n        long currentTime = System.currentTimeMillis();\n        \n        if(isMousePressed && game instanceof GamePanel){\n            \n            if(currentTime - lastBulletTime >= bulletFireInterval){\n                lastBulletTime = currentTime;\n                weapon.shoot(mouseX, mouseY);\n            }\n        }\n    }\n\n    public MouseInput(JPanel game, Weapon weapon){\n        this.game = game;\n        this.weapon = weapon;\n        bulletFireInterval = (long)(60.0/weapon.shootSpeed*1000);\n    }\n\n    public MouseInput(JPanel game){\n        this.game = game;\n    }\n\n    public int getMouseX(){\n        return mouseX;\n    }\n    public int getMouseY(){\n        return mouseY;\n    }\n\n    public void mouseMoved(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n\n    public void mouseDragged(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n    }\n\n    public void mousePressed(MouseEvent e) {\n        isMousePressed = true;\n    }\n\n    public void mouseReleased(MouseEvent e){\n        isMousePressed = false;\n    }\n\n}\n",
      "Camera.java": "import java.awt.Graphics2D;\n\npublic class Camera extends GameObject{\n\n    public Camera(int x, int y, int width, int height) {\n        super(x, y, width, height);\n    }\n    \n    public void update() {\n\n    }\n\n    public void draw(Graphics2D g) {\n        \n    }\n\n    public void follow(GameObject gameObject, int panelWidth, int panelHeight, int bgWidth, int bgHeight) {\n        \n        x += ((gameObject.getX() - x) - panelWidth / 2 + gameObject.getWidth() / 2) * 0.05f; \n        y += ((gameObject.getY() - y) - panelHeight / 2 + gameObject.getHeight() / 2) * 0.05f;\n    \n        if (x < 0) {\n            x = 0;\n        }\n        if (x > bgWidth - panelWidth) {\n            x = bgWidth - panelWidth;\n        }\n        if (y < 0) {\n            y = 0;\n        }\n        if (y > bgHeight - panelHeight) {\n            y = bgHeight - panelHeight;\n        }\n    }\n}\n",
      "RocketLauncher.java": "import java.io.File;\n\nimport javax.swing.ImageIcon;\n\npublic class RocketLauncher extends Weapon{\n\n    GamePanel game;\n\n    public RocketLauncher(GamePanel game){\n        capacity = 1;\n        currentcapacity = 1;\n        shootSpeed = 10;\n        speed = 10;\n        wave = 11;\n        reloadCooldown = 5000;\n        this.game = game;\n        name = \"Rocket Launcher\";\n        image = new ImageIcon(\"Textures/weapons/Rocket Launcher.png\");\n        bulletImage = new ImageIcon(this.getClass().getResource(\"/textures/weapons/Rocket_Bullet.png\"));\n        soundPath = new File(\"rocketSound.wav\");\n    }\n\n    void shoot(int mouseX, int mouseY) {\n        if(currentcapacity>0){\n            if(Settings.volume){\n                playSound();\n            }\n            currentcapacity -= 1;\n            game.addBullet(mouseX, mouseY);\n        }\n        \n    }\n    \n}\n",
      "Settings.java": "public class Settings {\n    public static boolean fullscreen, rain = true, extreme, volume = true;\n}\n",
      "Player.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.geom.AffineTransform;\nimport java.io.File;\n\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport javax.swing.ImageIcon;\n\npublic class Player extends GameObject {\n    private int speed;\n    private ImageIcon playerImage = new ImageIcon(this.getClass().getResource(\"/textures/player/Player_Pistol.png\"));\n    private ImageIcon pistolPlayer = new ImageIcon(this.getClass().getResource(\"/textures/player/Player_Pistol.png\"));\n    private ImageIcon riflePlayer = new ImageIcon(this.getClass().getResource(\"/textures/player/Player_Rifle.png\"));\n    private ImageIcon shotgunPlayer = new ImageIcon(this.getClass().getResource(\"/textures/player/Player_Shotgun.png\"));\n    private ImageIcon sniperPlayer = new ImageIcon(this.getClass().getResource(\"/textures/player/Player_Sniper.png\"));\n    private ImageIcon rocketPlayer = new ImageIcon(this.getClass().getResource(\"/textures/player/Player_Rocket.png\"));\n    public double velX, velY;\n    private double health;\n    private double fatigue;\n    private GamePanel gamePanel;\n    public boolean collusion = false;\n    public int score;\n\n    public File path = new File(\"collectSound.wav\");\n    public AudioInputStream audioInput;\n    public Clip clip;\n\n    public Player(int x, int y, int width, int height, int speed, GamePanel gamePanel) {\n        super(x, y, width, height);\n        this.speed = speed;\n        this.gamePanel = gamePanel;\n        health = 100;\n        fatigue = 100;\n    }\n\n    public void changeImage(Weapon weapon){\n        if(weapon instanceof Pistol){\n            playerImage = pistolPlayer;\n        }\n        if(weapon instanceof Rifle){\n            playerImage = riflePlayer;\n        }\n        if(weapon instanceof Shotgun){\n            playerImage = shotgunPlayer;\n        }\n        if(weapon instanceof Sniper){\n            playerImage = sniperPlayer;\n        }\n        if(weapon instanceof RocketLauncher){\n            playerImage = rocketPlayer;\n        }\n\n        \n    }\n\n    public boolean isPlayerAttackable(){\n        return gamePanel.currentTime - gamePanel.deadTime > 3000;\n    }\n    \n    public void update() {\n\n        if(health > 100){\n            health = 100;\n        }\n\n        if(health < 0){\n            health = 0;\n        }\n\n        x += velX;\n        y += velY;\n\n        collusion = false;\n\n        for(Building building: gamePanel.buildings){\n            if(checkCollusion(gamePanel.camera, building)){\n\n                collusion = true;\n                \n                if (velX > 0) {\n                    x -= velX;\n                    velX = 0;\n                }\n\n                if (velX < 0) {\n                    x -= velX;\n                    velX = 0;\n                }\n\n                if (velY > 0) {\n                    y -= velY;\n                    velY = 0;\n                }\n\n                if (velY < 0) {\n                    y -= velY;\n                    velY = 0;\n                }\n  \n            }\n        }\n\n        for(int i = 0; i < gamePanel.waveManager.healthKits.size(); i++){\n            if(checkCollusion(gamePanel.camera, gamePanel.waveManager.healthKits.get(i))){\n                gamePanel.waveManager.healthKits.remove(gamePanel.waveManager.healthKits.get(i));\n                health += 10;\n                score += gamePanel.waveManager.wave*3;\n                i--;\n\n                if(Settings.volume){\n                    new Thread(() -> {\n                        try{\n                            audioInput = AudioSystem.getAudioInputStream(path);\n                            clip = AudioSystem.getClip();\n                            clip.open(audioInput);\n                            clip.setFramePosition(0);\n                            clip.start();\n                            System.out.println(\"c\");\n                        }\n\n                        catch(Exception e){\n\n                        }\n\n                    }).start();\n                }\n            }\n        }\n\n        for(int i = 0; i < gamePanel.waveManager.magazines.size(); i++){\n            if(checkCollusion(gamePanel.camera, gamePanel.waveManager.magazines.get(i))){\n                gamePanel.waveManager.magazines.remove(gamePanel.waveManager.magazines.get(i));\n                if(!(gamePanel.currentWeapon instanceof Pistol)){\n                    gamePanel.currentWeapon.magazine += gamePanel.currentWeapon.capacity;\n                }\n                score += gamePanel.waveManager.wave *3;\n                i--;\n\n                if(Settings.volume){\n                    new Thread(() -> {\n                        try{\n                            audioInput = AudioSystem.getAudioInputStream(path);\n                            clip = AudioSystem.getClip();\n                            clip.open(audioInput);\n                            clip.setFramePosition(0);\n                            clip.start();\n                            System.out.println(\"c\");\n                        }\n    \n                        catch(Exception e){\n    \n                        }\n    \n                    }).start();\n                }\n\n                \n            }\n        }\n\n        //System.out.println(x);\n        //System.out.println(gamePanel.buildings.get(0).getX() + \" \" + gamePanel.buildings.get(0).getY());\n    }\n\n    public int getSpeed(){\n        return speed;\n    }\n\n    public void setSpeed(int speed){\n        this.speed = speed;\n    }\n\n    public void draw(Graphics2D g) {\n        if(visible){\n            g.drawImage(playerImage.getImage(), -width/2, -height/2, width, height, null);\n            g.setTransform(new AffineTransform());\n        }\n\n        Rectangle bounds1 = new Rectangle((int) x - gamePanel.camera.x + (int)velX, (int) y - gamePanel.camera.y + (int)velY, width, height);\n\n        //g.draw(bounds1);\n    }\n\n    public double getHealth(){\n        return health;\n    }\n\n    public void setHealth(double health){\n        this.health = health;\n    }\n\n    public double getFatigue(){\n        return fatigue;\n    }\n\n    public void setFatigue(double fatigue){\n        if(this.fatigue<=100){\n            this.fatigue = fatigue;\n        }\n\n        if(this.fatigue>100){\n            this.fatigue = 100;\n        }\n        \n    }\n\n    public boolean isDead(){\n        return health<=0;\n    }\n}\n",
      "GameObject.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\n\npublic abstract class GameObject {\n    protected int x, y;\n    protected int width, height;\n    protected boolean visible;\n    protected double velX, velY;\n\n    public GameObject(int x, int y, int width, int height){\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.visible = true;\n    }\n\n    public abstract void update();\n\n    public abstract void draw(Graphics2D g);\n\n    public boolean isVisible(){\n        return visible;\n    }\n\n    public void setVisible(boolean visible){\n        this.visible = visible;\n    }\n\n    public int getX(){\n        return x;\n    }\n\n    public int getY(){\n        return y;\n    }\n\n    public void setX(int x){\n        this.x = x;\n    }\n\n    public void setY(int y){\n        this.y = y;\n    }\n\n    public void setWidth(int width){\n        this.width = width;\n    }\n\n    public void setHeight(int height){\n        this.height = height;\n    }\n\n    public int getWidth(){\n        return width;\n    }\n\n    public int getHeight(){\n        return height;\n    }\n\n    public boolean checkCollusion(Camera camera, GameObject other) {\n\n        Rectangle bounds1 = new Rectangle((int) x, (int) y, width, height);\n        Rectangle bounds2 = new Rectangle((int) other.getX(), (int) other.getY(), other.getWidth(), other.getHeight());\n\n\n        if(this instanceof Player && other instanceof Building){\n            bounds1 = new Rectangle((int) x - camera.x + (int)velX*2, (int) y - camera.y + (int)velY*2, width, height);\n            bounds2 = new Rectangle((int) other.getX(), (int) other.getY(), other.getWidth(), other.getHeight());\n        }\n\n\n        if(other instanceof Zombie && this instanceof Bullet){\n            bounds2 = new Rectangle((int) other.getX() - camera.x, (int) other.getY() - camera.y, other.getWidth(), other.getHeight());\n        }\n\n        if(this instanceof Zombie && other instanceof Building){\n            bounds1 = new Rectangle((int) x - camera.x + (int)velX*2, (int) y - camera.y + (int)velY*2, width - 10, height - 10);\n            bounds2 = new Rectangle((int) other.getX(), (int) other.getY(), other.getWidth(), other.getHeight());\n        }\n\n        if(this instanceof Bullet && other instanceof Building){\n            bounds1 = new Rectangle((int) x, (int) y, width, height);\n            bounds2 = new Rectangle((int) other.getX(), (int) other.getY(), other.getWidth(), other.getHeight());\n        }\n\n        if(this instanceof Player && (other instanceof HealthKit || other instanceof Magazine)){\n            bounds1 = new Rectangle((int) x, (int) y, width, height);\n            bounds2 = new Rectangle((int) other.getX(), (int) other.getY(), other.getWidth(), other.getHeight());\n        }\n\n        if(this instanceof Explosion && other instanceof Zombie){\n            bounds1 = new Rectangle((int) x, (int) y, width, height);\n            bounds2 = new Rectangle((int) other.getX(), (int) other.getY(), other.getWidth(), other.getHeight());\n        }\n\n        if(this instanceof AcidArea && other instanceof Zombie){\n            bounds1 = new Rectangle((int) x, (int) y, width, height);\n            bounds2 = new Rectangle((int) other.getX(), (int) other.getY(), other.getWidth(), other.getHeight());\n        }\n\n        if(this instanceof Player && other instanceof Acid){\n            bounds1 = new Rectangle((int) x - camera.x, (int) y - camera.y, width, height);\n            bounds2 = new Rectangle((int) other.getX(), (int) other.getY(), other.getWidth(), other.getHeight());\n        }\n        \n        return bounds1.intersects(bounds2);\n    }\n\n\n}\n"
    },
    {
      "id": "4540765",
      "module-info.java": "/**\n * \n */\n/**\n * \n */\nmodule Assignment {\n\trequires java.desktop;\n}",
      "Sniper.java": "package game;\n\nimport java.awt.Rectangle;\n\npublic class Sniper extends Gun {\n\n    public Sniper() {\n        super(5, 30, 0);\n        this.reloadPerBullet=500;\n    }\n\n    \n    @Override\n    public void fire(float x, float y, float angle, Handler handler) {\n        if (!canFire()) return;\n\n        Bullet piercingBullet = new Bullet(x, y, ID.Bullet, handler) {\n            private float damage = 100f;\n            private java.util.Set<Zombie> hitZombies = new java.util.HashSet<>();\n\n            @Override\n            public void tick() {\n                x += velX;\n                y += velY;\n\n                for (GameObject obj : new java.util.LinkedList<>(handler.object)) {\n                    if (obj instanceof Zombie zombie && !hitZombies.contains(zombie)) {\n                        if (getBounds().intersects(zombie.getBounds())) {\n                            zombie.health -= damage;\n                            hitZombies.add(zombie); \n\n                            if (zombie.health <= 0) {\n                                handler.removeObject(zombie);\n                                Game.killedZombies++;\n                            }\n\n                            damage *= 0.5f;\n\n                            if (damage < 10) {\n                                handler.removeObject(this);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            @Override\n            public Rectangle getBounds() {\n                return new Rectangle((int)x, (int)y, 8, 8);\n            }\n        };\n\n        piercingBullet.velX = (float)(15 * Math.cos(angle));\n        piercingBullet.velY = (float)(15 * Math.sin(angle));\n        handler.addObject(piercingBullet);\n\n        currentAmmo--;\n        lastFiredTime = System.currentTimeMillis();\n    }\n\n\n}\n",
      "Box.java": "\npackage game;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\n\n\n//ENTITYLER OLUSTURULMADAN ONCE TEST İCİN KULLANİLAN BIR CLASS\n\npublic class Box extends GameObject {\n\tprivate Player player;\n\tprivate Camera cam;\n\tprivate BufferedImage zombieImage;\n\n\tpublic Box(float x, float y, ID id,Camera cam,Player player) {\n\t\tsuper(x, y, id);\n\t\tthis.maxHealth = 100;\n\t    this.health = maxHealth;\n\t    this.cam=cam;\n\t    this.player=player;\n\t    try {\n\t        File file = new File(\"src/game/zomb.png\"); // Yol doğru olmalı\n\t        zombieImage = ImageIO.read(file);\n\t        System.out.println(\"Zombi resmi yüklendi!\");\n\t    } catch (IOException e) {\n\t        System.out.println(\"Zombi resmi yüklenemedi!\");\n\t        e.printStackTrace();\n\t    }\n\n\t\n\t}\n\n\t@Override\n\tpublic void tick() {\n\t    float dx = player.getX() - x;\n\t    float dy = player.getY() - y;\n\n\t    float distance = (float)Math.sqrt(dx*dx + dy*dy);\n\t    if (distance != 0) {\n\t        float speed = 1.0f; // zombi hızı\n\t        velX = (dx / distance) * speed;\n\t        velY = (dy / distance) * speed;\n\t    }\n\n\t    x += velX;\n\t    y += velY;\n\n\t    // Harita dışına çıkmasın\n\t    x = Math.max(0, Math.min(x, cam.getWorldWidth() - 32));\n\t    y = Math.max(0, Math.min(y, cam.getWorldHeight() - 32));\n\t}\n\n\t@Override\n\tpublic void render(Graphics g) {\n\t\t\n\t\t if (zombieImage != null) {\n\t\t        g.drawImage(zombieImage, (int)x, (int)y, 32, 32, null);\n\t\t    } else {\n\t\t        g.setColor(Color.red);\n\t\t        g.fillRect((int)x, (int)y, 32, 32);\n\t\t    }\n\t\t\n\t\trenderHealthBar(g, 32);\n\t\t\n\t\t\n\t}\n\t\n\t\n\tpublic Rectangle getBounds() {\n\t    return new Rectangle((int)x, (int)y, 32, 32);\n\t}\n\n\t\n\t\n\t\n\n}\n\n",
      "Zombie.java": "package game;\n\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic abstract class Zombie extends GameObject {\n    protected Player player;\n    protected Camera cam;\n    protected BufferedImage image;\n    protected int damage;\n\n    public Zombie(float x, float y, ID id, Camera cam, Player player) {\n        super(x, y, id);\n        this.player = player;\n        this.cam = cam;\n    }\n\n    @Override\n    public void render(Graphics g) {\n        if (image != null) {\n            g.drawImage(image, (int) x, (int) y, 32, 32, null);\n        } else {\n            g.fillRect((int) x, (int) y, 32, 32);\n        }\n\n        renderHealthBar(g, 32);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle((int) x, (int) y, 44, 44);\n    }\n\n    public Rectangle getAttackBounds() {\n        return new Rectangle((int) x + 16, (int) y + 16, 16, 16);\n    }\n\n    protected void followPlayer(float speed) {\n        float dx = player.getX() - x;\n        float dy = player.getY() - y;\n        float distance = (float) Math.sqrt(dx * dx + dy * dy);\n\n        if (distance == 0) return;\n\n        float dirX = dx / distance;\n        float dirY = dy / distance;\n\n        float tryX = x + dirX * speed;\n        float tryY = y + dirY * speed;\n        Rectangle testBounds = new Rectangle((int) tryX, (int) tryY, 32, 32);\n        TileManager tm = Game.instance.getHandler().getTileManager();\n\n        if (tm == null) return; //Nullsa hata atmadan returnla\n\n        if (!tm.hasCollision(testBounds)) {\n            x = tryX;\n            y = tryY;\n            return;\n        }\n\n        tryX = x + dirX * speed;\n        testBounds = new Rectangle((int) tryX, (int) y, 32, 32);\n        if (!tm.hasCollision(testBounds)) {\n            x = tryX;\n            return;\n        }\n\n        tryY = y + dirY * speed;\n        testBounds = new Rectangle((int) x, (int) tryY, 32, 32);\n        if (!tm.hasCollision(testBounds)) {\n            y = tryY;\n        }\n    }\n\n}\n",
      "Difficulty.java": "package game;\n\npublic enum Difficulty {\n    EASY,\n    MEDIUM,\n    HARD,\n    TEST\n    \n}\n",
      "AcidZombie.java": "package game;\n\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\nimport java.awt.Rectangle;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\n\npublic class AcidZombie extends Zombie {\n    private long lastSpitTime = 0;\n    private long spitCooldown = 2000; // 2 saniye\n    private float spitRange = 200f;\n    private BufferedImage acidImage;\n\n    public AcidZombie(float x, float y, Camera cam, Player player) {\n        super(x, y, ID.Zombie, cam, player);\n        this.maxHealth = 50;\n        this.health = maxHealth;\n        this.damage = 30;\n\n        try {\n            image = ImageIO.read(new File(\"src/game/zomb1.1.png\"));\n            acidImage = ImageIO.read(new File(\"src/game/acid.png\"));\n        } catch (IOException e) {\n            System.out.println(\"Asit zombi veya asit resmi yüklenemedi!\");\n        }\n    }\n\n    @Override\n    public void tick() {\n    \t   \n        float dx = player.getX() + 16 - x;\n        float dy = player.getY() + 16 - y;\n        followPlayer(0.8f); // yavaş hareket\n\n        // Asit tükür\n        long now = System.currentTimeMillis();\n        float distance = (float) Math.sqrt(dx * dx + dy * dy);\n\n        if (distance <= spitRange && now - lastSpitTime > spitCooldown) {\n            float angle = (float) Math.atan2(dy, dx);\n            shootAcid(angle);\n            lastSpitTime = now;\n        }\n\n        \n        if (this.health <= 0) {\n        \tSystem.out.println(\"Zombi oldu\");\n            explodeNearby();\n            cam.getHandler().removeObject(this); // zombiyi kaldır\n            Game.killedZombies++;\n        }\n\n    }\n\n    private void shootAcid(float angle) {\n        Bullet acid = new Bullet(x, y, ID.Bullet, cam.getHandler()) {\n            @Override\n            public void tick() {\n                x += velX;\n                y += velY;\n\n                if (getBounds().intersects(player.getBounds())) {\n                    player.takeDamage(15); \n                    cam.getHandler().removeObject(this);\n                }\n            }\n\n            @Override\n            public void render(Graphics g) {\n                if (acidImage != null) {\n                    g.drawImage(acidImage, (int)x, (int)y, 10, 10, null);\n                }\n            }\n\n            @Override\n            public Rectangle getBounds() {\n                return new Rectangle((int)x, (int)y, 10, 10);\n            }\n        };\n\n        acid.velX = (float) (6 * Math.cos(angle));\n        acid.velY = (float) (6 * Math.sin(angle));\n        cam.getHandler().addObject(acid);\n    }\n\n    private void explodeNearby() {\n    \tSystem.out.println(\"[ASIT ZOMBI] Patladı! Yakındakilere hasar veriliyor...\");\n\n        Handler h = cam.getHandler();\n\n       \n        System.out.println(\"[ASIT ZOMBI] Patladı! Yakındaki objelere hasar veriliyor...\");\n        \n        //Yakındaki Zombi Hasarı\n        for (GameObject obj : new java.util.LinkedList<>(h.object)) {\n            double dist = Math.hypot(obj.getX() - x, obj.getY() - y);\n\n            if (dist < 50) {\n                if (obj instanceof Zombie z && obj != this) {\n                    z.health -= 80;\n                    if (z.health <= 0) {\n                        h.removeObject(z);\n                        Game.killedZombies++;\n                    }\n                } else if (obj instanceof Box box) {\n                    box.health -= 20;\n                }\n            }\n        }\n    }\n\n}\n",
      "Gun.java": "package game;\n\npublic abstract class Gun {\n    protected int magazineSize;\n    protected int currentAmmo;\n    protected int reserveAmmo;\n    protected int fireRate; // mermi/dk\n    protected long lastFiredTime = 0;\n    protected boolean isReloading = false;\n    protected long reloadStartTime = 0;\n    protected long reloadDuration = 2000; // 2 sn\n    protected int reloadPerBullet = 300; // 0.3 sn\n\n    public void setCurrentAmmo(int ammo) {\n        this.currentAmmo = ammo;\n    }\n\n    public void setReserveAmmo(int ammo) {\n        this.reserveAmmo = ammo;\n    }\n\n    public boolean isReloading() {\n        return isReloading;\n    }\n\n    public float getReloadProgress() {\n        if (!isReloading) return 0;\n        return Math.min(1f, (System.currentTimeMillis() - reloadStartTime) / (float)reloadDuration);\n    }\n\n    public Gun(int magazineSize, int fireRate, int reserveAmmo) {\n        this.magazineSize = magazineSize;\n        this.fireRate = fireRate;\n        this.reserveAmmo = reserveAmmo;\n        this.currentAmmo = magazineSize;\n    }\n\n    public void addAmmo(int amount) {\n        reserveAmmo += amount;\n    }\n\n    public boolean canFire() {\n        long currentTime = System.currentTimeMillis();\n        return currentAmmo > 0 && currentTime - lastFiredTime >= (60000 / fireRate) && !isReloading;\n    }\n\n    public void reload() {\n        if (currentAmmo == magazineSize || reserveAmmo == 0 || isReloading) return;\n\n        int needed = magazineSize - currentAmmo;\n        int toReload = Math.min(needed, reserveAmmo);\n\n        isReloading = true;\n        reloadStartTime = System.currentTimeMillis();\n        reloadDuration = Math.min(toReload * reloadPerBullet, 2500); \n    }\n\n    \n    \n    public void cancelReload() {\n        isReloading = false;\n        reloadStartTime = 0;\n        reloadDuration = 0;\n    }\n\n\n\n    public void completeReload() {\n        int needed = magazineSize - currentAmmo;\n        int toReload = Math.min(needed, reserveAmmo);\n        currentAmmo += toReload;\n        reserveAmmo -= toReload;\n        isReloading = false;\n    }\n\n    public abstract void fire(float x, float y, float angle, Handler handler);\n\n    public int getCurrentAmmo() {\n        return currentAmmo;\n    }\n\n    public int getReserveAmmo() {\n        return reserveAmmo;\n    }\n}",
      "Bullet.java": "package game;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class Bullet extends GameObject {\n\n    private Handler handler;\n    private static BufferedImage bulletImage;\n\n    static {\n        try {\n            bulletImage = ImageIO.read(new File(\"src/game/bullet.png\"));\n        } catch (IOException e) {\n            System.out.println(\"Bullet görseli yüklenemedi!\");\n        }\n    }\n\n\n    public Bullet(float x, float y, ID id, Handler handler) {\n        super(x, y, id);\n        this.handler = handler;\n    }\n\n    @Override\n    public void tick() {\n        x += velX;\n        y += velY;\n\n        for (int i = 0; i < handler.object.size(); i++) {\n            GameObject obj = handler.object.get(i);\n\n            if (obj instanceof Zombie zombie) {\n                if (getBounds().intersects(zombie.getBounds())) {\n                    zombie.health -= 25; \n                    //System.out.println(\">> Mermi zombiye çarptı: \" + zombie.getClass().getSimpleName() + \" | Yeni can: \" + zombie.health);\n\n                    if (zombie.health <= 0) {\n                        if (zombie instanceof AcidZombie) {\n                           \n                           \n                        } else {\n                            handler.removeObject(zombie);\n                            Game.killedZombies++;\n\n                            if (zombie instanceof NormalZombie) Game.score += 10;\n                            else if (zombie instanceof TankZombie) Game.score += 30;\n                            else if (zombie instanceof CrawlerZombie) Game.score += 15;\n\n                           \n                            if (Game.player != null) {\n                                Player p = Game.player;\n                                java.util.List<Gun> availableGuns = new java.util.ArrayList<>();\n\n                                if (p.rifle != null) availableGuns.add(p.rifle);\n                                if (p.shotgun != null) availableGuns.add(p.shotgun);\n                                if (p.sniper != null) availableGuns.add(p.sniper);\n                                if (p.rocketLauncher != null) availableGuns.add(p.rocketLauncher);\n\n                                if (!availableGuns.isEmpty()) {\n                                    Gun selectedGun = availableGuns.get(new java.util.Random().nextInt(availableGuns.size()));\n\n                                    if (selectedGun instanceof Rifle) selectedGun.addAmmo(10);\n                                    else if (selectedGun instanceof Shotgun) selectedGun.addAmmo(2);\n                                    else if (selectedGun instanceof Sniper) selectedGun.addAmmo(1);\n                                    else if (selectedGun instanceof RocketLauncher) selectedGun.addAmmo(1);\n\n                                    System.out.println(selectedGun.getClass().getSimpleName() + \" için mermi düştü!\");\n                                }\n                            }\n                        }\n                    }\n\n                    handler.removeObject(this); \n                    break;\n                }\n            }\n        }\n    }\n\n\n    @Override\n    public void render(Graphics g) {\n        if (bulletImage != null) {\n            Graphics2D g2d = (Graphics2D) g.create();\n\n            \n            int drawX = (int) x;\n            int drawY = (int) y;\n            int w = 24, h = 24; \n            float centerX = drawX + w / 2f;\n            float centerY = drawY + h / 2f;\n\n            //Açı Hesap Algoritması\n            double angle = Math.atan2(velY, velX);\n\n            g2d.rotate(angle, centerX, centerY);\n            g2d.drawImage(bulletImage, drawX, drawY, w, h, null);\n            g2d.dispose();\n        } else {\n            g.setColor(Color.YELLOW);\n            g.fillRect((int)x, (int)y, 8, 8);\n        }\n    }\n\n\n    \t\n   \n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle((int)x-2, (int)y-2, 12, 12);\n    }\n}\n",
      "Shotgun.java": "package game;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic class Shotgun extends Gun {\n\n    public Shotgun() {\n        super(5, 60, 0); // Şarjör: 5, ateş hızı: 60, yedek: 25 mermi\n        this.reloadPerBullet=400;\n        \n    }\n\n    @Override\n    public void fire(float x, float y, float angle, Handler handler) {\n        if (!canFire()) return;\n\n        int pelletCount = 9;\n        float spread = (float) Math.toRadians(45); // 9x5 45 derece dagil\n        float startAngle = angle - spread / 2;\n\n        for (int i = 0; i < pelletCount; i++) {\n            float pelletAngle = startAngle + i * (spread / (pelletCount - 1));\n\n            Bullet pellet = new Bullet(x, y, ID.Bullet, handler) {\n                private final float startX = x;\n                private final float startY = y;\n\n                @Override\n                public void tick() {\n                    x += velX;\n                    y += velY;\n\n                    for (GameObject obj : new java.util.LinkedList<>(handler.object)) {\n                        if (obj instanceof Zombie zombie) {\n                            if (getBounds().intersects(zombie.getBounds())) {\n                                float dx = x - startX;\n                                float dy = y - startY;\n                                float distance = (float) Math.sqrt(dx * dx + dy * dy);\n\n                                //Mesafeye göre logaritmik hasar algoritmasi\n                                float baseDamage = 50f;\n                                float minDamage = 5f;\n                                float logFactor = (float) Math.log(distance + 2);\n                                float actualDamage = Math.max(minDamage, baseDamage / (0.5f + logFactor));\n\n                                zombie.health -= actualDamage;\n                                if (zombie.health <= 0) {\n                                    handler.removeObject(zombie);\n                                    Game.killedZombies++;\n                                }\n\n                                handler.removeObject(this); \n                                break;\n                            }\n                        }\n                    }\n                }\n\n                @Override\n                public void render(Graphics g) {\n                    g.setColor(new Color(139, 69, 19)); \n                    g.fillRect((int) x, (int) y, 4, 4);\n                }\n\n                @Override\n                public Rectangle getBounds() {\n                    return new Rectangle((int) x, (int) y, 4, 4);\n                }\n            };\n\n            pellet.velX = (float) (10 * Math.cos(pelletAngle));\n            pellet.velY = (float) (10 * Math.sin(pelletAngle));\n            handler.addObject(pellet);\n        }\n\n        currentAmmo--;\n        lastFiredTime = System.currentTimeMillis();\n    }\n}\n",
      "NormalZombie.java": "package game;\n\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class NormalZombie extends Zombie {\n    public NormalZombie(float x, float y, Camera cam, Player player) {\n        super(x, y, ID.Zombie, cam, player);\n        this.maxHealth = 100;\n        this.health = maxHealth;\n        this.damage = 30;\n\n        try {\n            image = ImageIO.read(new File(\"src/game/zomb1.3.png\"));\n        } catch (IOException e) {\n            System.out.println(\"Normal zombi resmi yüklenemedi!\");\n        }\n    }\n\n    @Override\n    public void tick() {\n        float dx = player.getX() + 16 - x;\n        float dy = player.getY() + 16 - y;\n        followPlayer(1.0f); // yavaş\n    }\n}",
      "ID.java": "package game;\n\npublic enum ID {\n\t\n\tPlayer(),\n\tZombie(),\n\tBlock(),\n\tBullet(),\n\tParticle();\n\t\n\n}\n",
      "KeyInput.java": "package game;\n\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\npublic class KeyInput extends KeyAdapter {\n    private Player player;\n    public boolean keys[] = new boolean[4]; // D, A, W, S\n\n    public void setPlayer(Player player) {\n        this.player = player;\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int key = e.getKeyCode();\n     // kontrol için   System.out.println(\"Tuş basıldı: \" + key); \n\n        // Save Alma\n        if (key == KeyEvent.VK_M) {\n            Game.instance.saveGame();\n            Game.instance.showSaveMenu = true;\n            Game.instance.saveMenuStartTime = System.currentTimeMillis();\n           // System.out.println(\"M başarili\");\n            return;\n        }\n\n        // F Music Kapa aç\n        if (key == KeyEvent.VK_F) {\n            Game.instance.musicOn = !Game.instance.musicOn;\n            if (Game.instance.backgroundMusic != null) {\n                if (Game.instance.musicOn) {\n                    Game.instance.backgroundMusic.start();\n                //    System.out.println(\"Music Acildi);\n                } else {\n                    Game.instance.backgroundMusic.stop();\n                    //System.out.println(\" Music Kapandi\");\n                }\n            }\n            return;\n        }\n\n        // Heal Menü\n     // Heal Menü\n        if (Game.openHealthMenu) {\n            if (player == null) return;\n\n            switch (key) {\n                case KeyEvent.VK_K -> {\n                    if ((Game.score - Game.spentScore) >= 100 && player.getHealth() < player.getMaxHealth()) {\n                        player.heal(20);\n                        Game.spentScore += 100;\n                    }\n                }\n                case KeyEvent.VK_L -> {\n                    if ((Game.score - Game.spentScore) >= 250) {\n                        player.increaseMaxHealth(20);\n                        Game.spentScore += 250;\n                    }\n                }\n                case KeyEvent.VK_U -> {\n                    if ((Game.score - Game.spentScore) >= 150 && player.getHealth() < player.getMaxHealth()) {\n                        player.heal(player.getMaxHealth() - player.getHealth());\n                        Game.spentScore += 150;\n                    }\n                }\n                case KeyEvent.VK_O -> {\n                    Game.openHealthMenu = false;\n                    Game.instance.togglePause();\n                }\n            }\n            return;\n        }\n\n\n        // Movement\n        if (key == KeyEvent.VK_D) keys[0] = true;\n        if (key == KeyEvent.VK_A) keys[1] = true;\n        if (key == KeyEvent.VK_W) keys[2] = true;\n        if (key == KeyEvent.VK_S) keys[3] = true;\n\n        // Silah degisimi ve reload\n        if (player != null) {\n            switch (key) {\n                case KeyEvent.VK_1 -> player.setCurrentGun(player.pistol);\n                case KeyEvent.VK_2 -> {\n                    if (player.rifle != null) player.setCurrentGun(player.rifle);\n                }\n                case KeyEvent.VK_3 -> {\n                    if (player.shotgun != null) player.setCurrentGun(player.shotgun);\n                }\n                case KeyEvent.VK_4 -> {\n                    if (player.sniper != null) player.setCurrentGun(player.sniper);\n                }\n                case KeyEvent.VK_5 -> {\n                    if (player.rocketLauncher != null) player.setCurrentGun(player.rocketLauncher);\n                }\n                case KeyEvent.VK_R -> {\n                    Gun gun = player.getCurrentGun();\n                    if (gun.isReloading()) {\n                        gun.cancelReload();\n                      //  System.out.println(\" Reload iptal \");\n                    } else {\n                        gun.reload();\n                        //System.out.println(\" Reload başladı.\");\n                    }\n                }\n                case KeyEvent.VK_H -> {\n                    Game.openHealthMenu = true;\n                    Game.instance.togglePause();\n                    //System.out.println(\"Health Menu Acildi\");\n                }\n            }\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int key = e.getKeyCode();\n\n        if (key == KeyEvent.VK_D) keys[0] = false;\n        if (key == KeyEvent.VK_A) keys[1] = false;\n        if (key == KeyEvent.VK_W) keys[2] = false;\n        if (key == KeyEvent.VK_S) keys[3] = false;\n    }\n}\n",
      "Pistol.java": "package game;\n\npublic class Pistol extends Gun {\n    public Pistol() {\n        super(12, 120, Integer.MAX_VALUE); // sınırsız yedek şarjör\n        this.reloadPerBullet=150;\n    }\n    \n\n    @Override\n    public void fire(float x, float y, float angle, Handler handler) {\n        if (!canFire()) return;\n\n        Bullet bullet = new Bullet(x, y, ID.Bullet,handler);\n        bullet.velX = (float) (10 * Math.cos(angle));\n        bullet.velY = (float) (10 * Math.sin(angle));\n        handler.addObject(bullet);\n\n        currentAmmo--;\n        lastFiredTime = System.currentTimeMillis();\n    }\n}\n",
      "Handler.java": "package game;\n\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.util.LinkedList;\n\npublic class Handler {\n\n    public LinkedList<GameObject> object = new LinkedList<>();\n    private TileManager tileManager;\n\n    public void setTileManager(TileManager tileManager) {\n        this.tileManager = tileManager;\n    }\n\n    public TileManager getTileManager() {\n        return tileManager;\n    }\n\n    public void tick() {\n        for (int i = 0; i < object.size(); i++) {\n            GameObject obj = object.get(i);\n\n            obj.tick();\n\n            // Collision checkliyoruz burda ve aşşağılarda\n            if (tileManager != null && obj.getId() != ID.Bullet) {\n                if (tileManager.hasCollision(obj.getBounds())) {\n                    //Algoritma \n                    obj.setX(obj.getX() - obj.velX);\n                    obj.setY(obj.getY() - obj.velY);\n                    obj.velX = 0;\n                    obj.velY = 0;\n                }\n            }\n        }\n    }\n\n    public int zombieCount() {\n        int count = 0;\n        for (GameObject obj : object) {\n            if (obj instanceof Zombie) count++;\n        }\n        return count;\n    }\n\n    public void render(Graphics g) {\n        for (int i = 0; i < object.size(); i++) {\n            object.get(i).render(g);\n        }\n\n        \n        for (int i = 0; i < object.size(); i++) {\n            GameObject obj = object.get(i);\n            if (obj.getId() == ID.Bullet) {\n                Rectangle bulletBounds = obj.getBounds();\n                for (int j = 0; j < object.size(); j++) {\n                    GameObject obj2 = object.get(j);\n                    if (obj2.getId() == ID.Block) {\n                        Rectangle boxBounds = obj2.getBounds();\n                        if (bulletBounds.intersects(boxBounds)) {\n                            Box box = (Box) obj2;\n                            box.health -= 50;\n                            removeObject(obj); \n                            if (box.health <= 0) {\n                                removeObject(box);\n                                Game.killedBoxes++;\n                            }\n                            break;\n                        }\n                    }\n                }\n\n                \n                if (tileManager != null && tileManager.hasCollision(bulletBounds)) {\n                    removeObject(obj); \n                }\n            }\n        }\n    }\n\n    public GameObject addObject(GameObject tempobject) {\n        object.add(tempobject);\n        return tempobject;\n    }\n\n    public void removeObject(GameObject tempObject) {\n        object.remove(tempObject);\n    }\n}\n",
      "Rifle.java": "package game;\n\nimport java.util.Random;\n\npublic class Rifle extends Gun {\n    private Random rand = new Random();\n\n    public Rifle() {\n        super(30, 600, 0); // 30 elde 600 hızında\n        this.reloadPerBullet=100;\n    }\n\n    @Override\n    public void fire(float x, float y, float angle, Handler handler) {\n        if (!canFire()) return;\n\n        \n        float deviation = (float) Math.toRadians(rand.nextFloat() * 30 - 15);\n        float finalAngle = angle + deviation;\n\n        Bullet bullet = new Bullet(x, y, ID.Bullet,handler);\n        bullet.velX = (float) (10 * Math.cos(finalAngle));\n        bullet.velY = (float) (10 * Math.sin(finalAngle));\n        handler.addObject(bullet);\n\n        currentAmmo--;\n        lastFiredTime = System.currentTimeMillis();\n    }\n}\n",
      "CrawlerZombie.java": "package game;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class CrawlerZombie extends Zombie {\n    private boolean leaped = false;\n    private float angle = 0; //radyan\n\n    public CrawlerZombie(float x, float y, Camera cam, Player player) {\n        super(x, y, ID.Zombie, cam, player);\n        this.maxHealth = 60;\n        this.health = maxHealth;\n        this.damage = 30;\n\n        try {\n            image = ImageIO.read(new File(\"src/game/crawl zombie.png\"));\n        } catch (IOException e) {\n            System.out.println(\"Sürünge zombi resmi yüklenemedi!\");\n        }\n    }\n  \n    \n    @Override\n    public void render(Graphics g) {\n        if (image != null) {\n            Graphics2D g2d = (Graphics2D) g.create();\n\n            float dx = player.getX() - x;\n            float dy = player.getY() - y;\n\n            int drawX = (int) x;\n            int drawY = (int) y;\n            int width = 32;\n            int height = 32;\n\n            \n            if (Math.abs(dx) > Math.abs(dy)) {\n                if (dx > 0) {\n                    //Sağ\n                    g2d.drawImage(image, drawX, drawY, width, height, null);\n                } else {\n                    // Sol\n                    g2d.drawImage(image, drawX + width, drawY, -width, height, null);\n                }\n            } else {\n                if (dy > 0) {\n                    // Aşağı\n                    g2d.rotate(Math.PI / 2, drawX + width / 2.0, drawY + height / 2.0);\n                    g2d.drawImage(image, drawX, drawY, width, height, null);\n                } else {\n                    // Yukarı\n                    g2d.rotate(-Math.PI / 2, drawX + width / 2.0, drawY + height / 2.0);\n                    g2d.drawImage(image, drawX, drawY, width, height, null);\n                }\n            }\n\n            g2d.dispose();\n        } else {\n            g.setColor(Color.GREEN);\n            g.fillRect((int) x, (int) y, 32, 32);\n        }\n\n        renderHealthBar(g, 32);\n    }\n\n    @Override\n    public void tick() {\n        float dx = player.getX() + 16 - x;\n        float dy = player.getY() + 16 - y;\n        float distance = (float)Math.sqrt(dx * dx + dy * dy);\n\n        // Eğer 1.5 tile (48px) veya daha yakınsa ve henüz atlamadıysa\n        if (distance <= 48 && !leaped) { //jump özelliği yazıldı\n        \t//System.out.println(\"atladi\");\n            float boost = 6.0f; // zıplama hızı jump için\n            velX = dx / distance * boost;\n            velY = dy / distance * boost;\n            x += velX;\n            y += velY;\n            leaped = true;\n        } else {\n            followPlayer(2.0f); // normal hiz\n        }\n    }\n\n}",
      "TankZombie.java": "package game;\n\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class TankZombie extends Zombie {\n    public TankZombie(float x, float y, Camera cam, Player player) {\n        super(x, y, ID.Zombie, cam, player);\n        this.maxHealth = 300;\n        this.health = maxHealth;\n        this.damage = 60;\n\n        try {\n            image = ImageIO.read(new File(\"src/game/zomb1.4.png\"));\n        } catch (IOException e) {\n            System.out.println(\"Tank zombi resmi yüklenemedi!\");\n        }\n    }\n\n    @Override\n    public void tick() {\n        float dx = player.getX() + 16 - x;\n        float dy = player.getY() + 16 - y;\n        followPlayer(0.5f); // çok yavaş\n    }\n}",
      "Game.java": "package game;\n\nimport java.awt.Canvas;\nimport javax.sound.sampled.*;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferStrategy;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport javax.imageio.ImageIO;\n\npublic class Game extends Canvas implements Runnable {\n    public final static int width = 800;\n    public final static int height = 600;\n    String title = \"After the Apocalypse\";\n    static protected int killedBoxes = 0;\n    public static int killedZombies = 0;\n    public static int score = 0;\n    public static boolean gameOver = false;\n    private int frames = 0;\n    private int fps = 0;\n    public static Difficulty difficulty = Difficulty.MEDIUM; \n    public static boolean openHealthMenu = false;\n    public static Game instance;\n    private boolean bonusGiven = false; \n    private TileManager tileManager;\n    private BufferedImage menuBackground, startButtonImg, exitButtonImg, musicButtonImg,loadButtonImg;\n    Rectangle startButton;\n\tRectangle exitButton;\n\tRectangle musicButton;\n\tRectangle loadButton;\n    public boolean musicOn = true;\n    public Clip backgroundMusic;\n    public boolean showDifficultyMenu = false;\n    public Rectangle easyButton = new Rectangle(300, 240, 200, 40);\n    public Rectangle mediumButton = new Rectangle(300, 300, 200, 40);\n    public Rectangle hardButton = new Rectangle(300, 360, 200, 40);\n    public Rectangle testButton = new Rectangle(300, 420, 200, 40); // Yeni test butonu\n    public static int spentScore = 0;\n\n    public boolean gameStarted = false;\n    public boolean isLoadingGame = false;\n    public boolean openEscapeMenu = false;\n    public boolean showSaveMenu = false;\n    long saveMenuStartTime = 0;\n    \n\n\n\n\n    private Thread thread;\n    private boolean isRunning = false;\n    private KeyInput input;\n    private MouseInput minput;\n    private Handler handler;\n    Camera cam;\n    public static  Player player;\n    private BufferedImage backgroundImage;\n    private boolean isPaused = false;\n\n    private int currentWave = 1;\n    private long waveStartTime = System.currentTimeMillis();\n    private boolean waveInProgress = false;\n    private long waveDelay = 2000;\n    private long lastWaveTime = 0;\n    private boolean showWaveText = false;\n    public boolean openMainMenu = false;\n    public Rectangle saveButtonRect = new Rectangle(300, 250, 200, 40);\n    public Rectangle loadButtonRect = new Rectangle(300, 310, 200, 40);\n\n\n    public Game() {\n        new Window(width, height, title, this);\n        instance=this;\n        init();\n        start();\n    }\n    public Handler getHandler() {\n        return handler;\n    }\n\n    public void startGame() {\n        \n        gameStarted = true;\n        showDifficultyMenu = false;\n        openMainMenu = false;\n        isPaused = false;\n        gameOver = false;\n        \n\n        init();\n    }\n\n    public void initMusic() {\n        try {\n            AudioInputStream audioStream = AudioSystem.getAudioInputStream(new File(\"src/game/backgroundmus.wav\"));\n            backgroundMusic = AudioSystem.getClip();\n            backgroundMusic.open(audioStream);\n            backgroundMusic.loop(Clip.LOOP_CONTINUOUSLY);\n            FloatControl gainControl = (FloatControl) backgroundMusic.getControl(FloatControl.Type.MASTER_GAIN);\n            gainControl.setValue(1);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n\n    private void init() {\n    \tif (!isLoadingGame) {\n    \t    killedZombies = 0;\n    \t    score = (difficulty == Difficulty.TEST) ? 500 : 0;\n    \t    currentWave = 1;\n    \t    bonusGiven = false;\n    \t}\n\n        isLoadingGame = false;\n\n        if (musicOn && backgroundMusic == null) {\n            try {\n                AudioInputStream audioStream = AudioSystem.getAudioInputStream(new File(\"src/game/backgroundmus.wav\"));\n                backgroundMusic = AudioSystem.getClip();\n                backgroundMusic.open(audioStream);\n                backgroundMusic.loop(Clip.LOOP_CONTINUOUSLY);\n                FloatControl gainControl = (FloatControl) backgroundMusic.getControl(FloatControl.Type.MASTER_GAIN);\n                gainControl.setValue(1);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        \n\n        try {\n            menuBackground = ImageIO.read(new File(\"src/game/anaekran.png\"));\n            startButtonImg = ImageIO.read(new File(\"src/game/startgame.png\"));\n            exitButtonImg = ImageIO.read(new File(\"src/game/exit.png\"));\n            musicButtonImg = ImageIO.read(new File(\"src/game/music.png\"));\n            loadButtonImg = ImageIO.read(new File(\"src/game/loadgame.png\"));\n\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        startButton = new Rectangle(300, 220, 200, 30);\n        loadButton  = new Rectangle(300, 270, 200, 30);\n        musicButton = new Rectangle(300, 320, 200, 30);\n        exitButton  = new Rectangle(300, 370, 200, 30);\n\n       \n        \n        if (!gameStarted) {\n            openMainMenu = true;\n        }\n\n        try {\n            File file = new File(\"src/game/bckg2.jpg\");\n            backgroundImage = ImageIO.read(file);\n            System.out.println(\"Arka plan yüklendi!\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        handler = new Handler();\n        tileManager = new TileManager();           \n        handler.setTileManager(tileManager);        \n\n        input = new KeyInput();\n\n     \n     for (var l : this.getKeyListeners()) this.removeKeyListener(l);\n     this.addKeyListener(input);\n\n        \n        cam = new Camera(0, 0, handler, backgroundImage);\n        minput = new MouseInput(handler, cam);\n\n    \n     for (var l : this.getMouseListeners()) this.removeMouseListener(l);\n     this.addMouseListener(minput);\n \n        \n\n        float spawnX = 300, spawnY = 300;\n        while (tileManager.hasCollision(new Rectangle((int)spawnX, (int)spawnY, 32, 32))) {\n            spawnX += 32; // Bloklarda Sıkışmaması için\n        }\n\n        player = new Player(spawnX, spawnY, ID.Player, input, handler, cam);\n        Game.player = player;\n        input.setPlayer(player);\n        handler.addObject(player);\n        minput.findPlayer();\n        \n\n    }\n    private synchronized void start() {\n        if (isRunning) return;\n        thread = new Thread(this);\n        thread.start();\n        isRunning = true;\n    }\n\n    private synchronized void stop() {\n        try {\n            if (backgroundMusic != null) backgroundMusic.stop();\n            thread.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        isRunning = false;\n    }\n\n\n    public void run() {\n    \tthis.setFocusable(true); \n    \tthis.requestFocus();     \n\n        this.requestFocus();\n        long lastTime = System.nanoTime();\n        double amountOfTicks = 60.0;\n        double ns = 1000000000 / amountOfTicks;\n        double delta = 0;\n        long timer = System.currentTimeMillis();\n\n        while (isRunning) {\n            long now = System.nanoTime();\n            delta += (now - lastTime) / ns;\n            lastTime = now;\n            while (delta >= 1) {\n                tick();\n                delta--;\n            }\n            render();\n            frames++;\n\n            if (System.currentTimeMillis() - timer > 1000) {\n                timer += 1000;\n                fps = frames;\n                frames = 0;\n            }\n        }\n        stop();\n    }\n\n    public void toggleMainMenu() {\n        if (showDifficultyMenu) return;\n        openMainMenu = !openMainMenu;\n        isPaused = openMainMenu;\n        \n    }\n\n\n\n    \n    private void tick() {\n        if (gameOver) return;\n        if (openMainMenu || openEscapeMenu) return;\n\n        if (showSaveMenu && System.currentTimeMillis() - saveMenuStartTime > 2000) {\n            showSaveMenu = false; // 2 saniye sonra kapat\n        }\n\n\n        \n        if (isPaused || gameOver) return;\n\n        handler.tick();\n        cam.tick();\n        minput.tick();\n\n        Gun gun = player.getCurrentGun();\n        if (gun.isReloading() && System.currentTimeMillis() - gun.reloadStartTime >= gun.reloadDuration) {\n            gun.completeReload();\n        }\n\n        if (player.getHealth() <= 0) {\n            gameOver = true;\n            return;\n        }\n\n        if (currentWave <= 12 && getRemainingZombies() == 0 && !waveInProgress) {\n\n            \n            if (!bonusGiven && currentWave > 1) {\n                int bonus = 75+(currentWave - 1) * 50; \n                Game.score += bonus;\n                System.out.println((currentWave - 1) + \". dalga tamamlandı! +\" + bonus + \" skor.\");\n                bonusGiven = true;\n            }\n\n            \n            spawnWave(currentWave);\n\n            if (currentWave == 2) player.unlockRifle();\n            if (currentWave == 4) player.unlockShotgun();\n            if (currentWave == 6) player.unlockSniper();\n            if (currentWave == 11) player.unlockRocketLauncher();\n\n            showWaveText = true;\n            currentWave++;\n            waveInProgress = true;\n            waveStartTime = System.currentTimeMillis();\n        }\n\n\n        if (currentWave > 12 && getRemainingZombies() == 0 && !waveInProgress) {\n            gameOver = true;\n            System.out.println(\"Tüm Dalgalar Tamamlandı!\");\n        }\n\n        if (System.currentTimeMillis() - waveStartTime > waveDelay) {\n            waveInProgress = false;\n            showWaveText = false;\n        }\n        \n      \n\n    }\n\n    private int getRemainingZombies() {\n        int count = 0;\n        for (GameObject obj : handler.object) {\n            if (obj instanceof Zombie) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private void spawnWave(int wave) {\n        int totalZombies;\n        switch (difficulty) {\n            case EASY -> totalZombies = (wave <= 10) ? 2 : 4;\n            case MEDIUM -> totalZombies = 3 + wave * 2;\n            case HARD -> totalZombies = (int) ((3 + wave * 2) * 1.5);\n            case TEST -> totalZombies = (wave < 12) ? 1 : 4;\n            default -> totalZombies = 3 + wave * 2;\n        }\n\n        for (int i = 0; i < totalZombies; i++) {\n            float x = 0, y = 0;\n            Rectangle zombieBox;\n            int attempts = 0;\n\n            // En fazla 10  deneme yeterli olacaktır daha iyi olsun istersek arttırırız\n            do {\n                x = (float) (Math.random() * cam.getWorldWidth());\n                y = (float) (Math.random() * cam.getWorldHeight());\n                zombieBox = new Rectangle((int)x, (int)y, 32, 32);\n                attempts++;\n            } while (\n                (Math.hypot(player.getX() - x, player.getY() - y) < 100 ||\n                tileManager.hasCollision(zombieBox) ||\n                !tileManager.isSpawnable(zombieBox)) &&\n                attempts < 10\n            );\n\n            // Uygun değilse kaydır\n            if (tileManager.hasCollision(zombieBox)) {\n                int[] dx = {0, 32, -32, 0, 0};\n                int[] dy = {0, 0, 0, -32, 32};\n                for (int j = 0; j < dx.length; j++) {\n                    float newX = x + dx[j];\n                    float newY = y + dy[j];\n                    Rectangle tryRect = new Rectangle((int)newX, (int)newY, 32, 32);\n                    if (!tileManager.hasCollision(tryRect)) {\n                        x = newX;\n                        y = newY;\n                        break;\n                    }\n                }\n            }\n\n            Zombie z = (difficulty == Difficulty.TEST && wave == 12)\n                ? switch (i) {\n                    case 0 -> new NormalZombie(x, y, cam, player);\n                    case 1 -> new TankZombie(x, y, cam, player);\n                    case 2 -> new CrawlerZombie(x, y, cam, player);\n                    case 3 -> new AcidZombie(x, y, cam, player);\n                    default -> new NormalZombie(x, y, cam, player);\n                }\n                : switch (i % 4) {\n                    case 0 -> new NormalZombie(x, y, cam, player);\n                    case 1 -> new TankZombie(x, y, cam, player);\n                    case 2 -> new CrawlerZombie(x, y, cam, player);\n                    case 3 -> new AcidZombie(x, y, cam, player);\n                    default -> new NormalZombie(x, y, cam, player);\n                };\n\n            handler.addObject(z);\n        }\n\n        waveInProgress = false;\n        lastWaveTime = System.currentTimeMillis();\n    }\n    \n    private void render() {\n        BufferStrategy bs = this.getBufferStrategy();\n        if (bs == null) {\n            this.createBufferStrategy(3);\n            return;\n        }\n\n        Graphics g = bs.getDrawGraphics();\n        Graphics2D g2d = (Graphics2D) g;\n\n        // Giriş Arayüzü\n        if (!gameStarted && openMainMenu && !showDifficultyMenu) {\n            if (menuBackground != null)\n                g.drawImage(menuBackground, 0, 0, Game.width, Game.height, null);\n            else {\n                g.setColor(Color.BLACK);\n                g.fillRect(0, 0, Game.width, Game.height);\n            }\n\n            if (startButtonImg != null)\n                g.drawImage(startButtonImg, startButton.x, startButton.y, startButton.width, startButton.height, null);\n            if (exitButtonImg != null)\n                g.drawImage(exitButtonImg, exitButton.x, exitButton.y, exitButton.width, exitButton.height, null);\n            if (musicButtonImg != null)\n                g.drawImage(musicButtonImg, musicButton.x, musicButton.y, musicButton.width, musicButton.height, null);\n            if (loadButtonImg != null)\n                g.drawImage(loadButtonImg, loadButton.x, loadButton.y, loadButton.width, loadButton.height, null);\n\n            g.dispose();\n            bs.show();\n            return;\n        }\n\n        if (showDifficultyMenu) {\n            g.setColor(new Color(0, 0, 0, 180));\n            g.fillRect(100, 100, 600, 400);\n\n            g.setColor(Color.WHITE);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 32));\n            g.drawString(\"ZORLUK SEÇ\", 310, 160);\n\n            g.setFont(new Font(\"Arial\", Font.PLAIN, 20));\n            g.drawRect(easyButton.x, easyButton.y, easyButton.width, easyButton.height);\n            g.drawString(\"Kolay\", easyButton.x + 70, easyButton.y + 25);\n\n            g.drawRect(mediumButton.x, mediumButton.y, mediumButton.width, mediumButton.height);\n            g.drawString(\"Orta\", mediumButton.x + 75, mediumButton.y + 25);\n\n            g.drawRect(hardButton.x, hardButton.y, hardButton.width, hardButton.height);\n            g.drawString(\"Zor\", hardButton.x + 80, hardButton.y + 25);\n\n            \n            g.drawRect(testButton.x, testButton.y, testButton.width, testButton.height);\n            g.drawString(\"TEST\", testButton.x + 75, testButton.y + 25);\n\n            g.dispose();\n            bs.show();\n            return;\n        }\n\n\n        // Oyun\n        g2d.translate(-cam.getX(), -cam.getY());\n        if (tileManager != null) tileManager.render(g2d);\n        handler.render(g2d);\n        g2d.translate(cam.getX(), cam.getY());\n\n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 16));\n        String controlsText = \"H: Health Menu  |  M: Save\";\n        int texttWidth = g.getFontMetrics().stringWidth(controlsText);\n        g.drawString(controlsText, (Game.width - texttWidth) / 2 + 20, 20);\n        \n        \n        String musicText = \"F: Music ON/OFF\";\n        int musicTextWidth = g.getFontMetrics().stringWidth(musicText);\n        g.drawString(musicText, (Game.width - musicTextWidth) / 2 + 20, 40);\n        String bilText = \"NEBİ YANAR 231301037\";\n        int bilTextWidth = g.getFontMetrics().stringWidth(bilText);\n        g.drawString(bilText, (Game.width - bilTextWidth) / 2 + 20, 55);\n\n\n        \n   \n\n        \n        \n        // Üst Yazılar\n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 20));\n        g.drawString(\"Killed Zombies: \" + killedZombies, Game.width - 190, 20);\n        int netScore = score - spentScore;\n        g.drawString(\"Score: \" + netScore + \"/\" + score, Game.width - 190, 40);\n\n\n        Gun gun = player.getCurrentGun();\n        g.drawString(\"Weapon: \" + gun.getClass().getSimpleName(), 15, 20);\n        g.drawString(\"Ammo: \" + gun.getCurrentAmmo() + \"/\" + gun.getReserveAmmo(), 15, 40);\n\n        g.setColor(Color.RED);\n        g.fillRect(10, 50, player.getHealth() * 2, 20);\n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"Arial\", Font.BOLD, 15));\n        g.drawString(\"Health: \" + player.getHealth(), 15, 65);\n\n        if (gun.isReloading()) {\n            int radius = 12;\n\n            int centerX = (int) (player.getX() - cam.getX() + 16);\n            int centerY = (int) (player.getY() - cam.getY() + 16);\n\n            g.setColor(Color.WHITE);\n            g.drawOval(centerX - radius, centerY - radius, radius * 2, radius * 2);\n\n            float progress = gun.getReloadProgress();\n\n            //Geçiş Algoritması(R -> G)\n            int red = (int) (255 * (1 - progress));\n            int green = (int) (255 * progress);\n            g.setColor(new Color(red, green, 0));\n\n            g.fillArc(centerX - radius, centerY - radius, radius * 2, radius * 2, 90, -(int) (360 * progress));\n        }\n\n\n\n        if (showWaveText && currentWave > 1 && currentWave <= 13) {\n            g.setFont(new Font(\"Arial\", Font.BOLD, 40));\n            g.setColor(Color.YELLOW);\n            String text = (currentWave - 1) + \". Dalga\";\n            int textWidth = g.getFontMetrics().stringWidth(text);\n            g.drawString(text, Game.width / 2 - textWidth / 2, Game.height / 2 - 100);\n        }\n\n        // Heal Menu\n        if (openHealthMenu) {\n            g.setColor(new Color(0, 0, 0, 180));\n            g.fillRect(100, 100, 600, 400);\n\n            g.setColor(Color.WHITE);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 24));\n            g.drawString(\"SAĞLIK MENÜSÜ\", 310, 140);\n\n            g.setFont(new Font(\"Arial\", Font.PLAIN, 20));\n            g.drawString(\"[K] 100 Skor → +20 Can\", 240, 200);\n            g.drawString(\"[L] 250 Skor → +20 Max Can && Anlık +20 Regen \", 240, 240);\n            g.drawString(\"[U] 150 Skor → Full Can (regen)\", 240, 280);\n            g.drawString(\"[O] Menüden Çık\", 240, 320);\n        }\n\n        //  M ile Save \n        if (showSaveMenu) {\n            g.setColor(new Color(0, 0, 0, 180));\n            g.fillRect(250, 200, 300, 150);\n            g.setColor(Color.WHITE);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 24));\n            g.drawString(\"Oyun Kaydedildi!\", 290, 260);\n            g.setFont(new Font(\"Arial\", Font.PLAIN, 16));\n            g.drawString(\"Save Alindi\", 270, 300);\n        }\n\n        // Oyunun iki türlü bitmesi\n        if (gameOver) {\n            g.setColor(Color.BLACK);\n            g.setFont(new Font(\"Arial\", Font.BOLD, 50));\n            if (player.getHealth() <= 0)\n                g.drawString(\"YOU DIED!\", Game.width / 2 - 130, Game.height / 2);\n            else\n                g.drawString(\"TÜM DALGALAR TAMAMLANDI!\", Game.width / 2 - 390, Game.height / 2);\n        }\n\n        // FPS\n        g.setColor(Color.GREEN);\n        g.setFont(new Font(\"Arial\", Font.PLAIN, 14));\n        g.drawString(\"FPS: \" + fps, Game.width - 100, 70);\n\n        g.dispose();\n        bs.show();\n    }\n\n    public void togglePause() {\n        isPaused = !isPaused;\n        System.out.println(\"Pause durumu: \" + (isPaused ? \"Durduruldu\" : \"Devam Ediyor\"));\n    }\n\n    public void saveGame() {\n        try {\n            FileWriter writer = new FileWriter(\"savegame.txt\");\n\n            // Dosyaya zombi player ve gun infoları yaz tekrar okuyacağız\n            writer.write(\"PLAYER,\" +\n            \t    player.getX() + \",\" +\n            \t    player.getY() + \",\" +\n            \t    player.getHealth() + \",\" +\n            \t    player.getMaxHealth() + \",\" +\n            \t    killedZombies + \",\" +\n            \t    score + \",\" +\n            \t    spentScore + \",\" + \n            \t    currentWave + \",\" +\n            \t    (player.rifle != null) + \",\" +\n            \t    (player.shotgun != null) + \",\" +\n            \t    (player.sniper != null) + \",\" +\n            \t    (player.rocketLauncher != null) + \",\" +\n            \t    (player.rifle != null ? player.rifle.getCurrentAmmo() : -1) + \",\" +\n            \t    (player.rifle != null ? player.rifle.getReserveAmmo() : -1) + \",\" +\n            \t    (player.shotgun != null ? player.shotgun.getCurrentAmmo() : -1) + \",\" +\n            \t    (player.shotgun != null ? player.shotgun.getReserveAmmo() : -1) + \",\" +\n            \t    (player.sniper != null ? player.sniper.getCurrentAmmo() : -1) + \",\" +\n            \t    (player.sniper != null ? player.sniper.getReserveAmmo() : -1) + \",\" +\n            \t    (player.rocketLauncher != null ? player.rocketLauncher.getCurrentAmmo() : -1) + \",\" +\n            \t    (player.rocketLauncher != null ? player.rocketLauncher.getReserveAmmo() : -1) + \",\" +\n            \t    player.pistol.getCurrentAmmo() + \",\" +\n            \t    player.pistol.getReserveAmmo() + \",\" +\n            \t    Game.difficulty.name() + \"\\n\");\n\n\n\n\n            \n            for (GameObject obj : handler.object) {\n                if (obj instanceof Zombie zombie) {\n                    writer.write(\"ZOMBIE,\" + zombie.getClass().getSimpleName() + \",\" + zombie.getX() + \",\" + zombie.getY() + \",\" + zombie.health + \"\\n\");\n                }\n            }\n\n            writer.close();\n            System.out.println(\"Oyun başarıyla kaydedildi!\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    public void loadGame() {\n        isLoadingGame = true;\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(\"savegame.txt\"));\n            String line;\n\n            \n            handler = new Handler();\n            tileManager = new TileManager();\n            handler.setTileManager(tileManager);\n            input = new KeyInput();\n\n         \n         for (var l : this.getKeyListeners()) this.removeKeyListener(l);\n         this.addKeyListener(input);\n            cam = new Camera(0, 0, handler, backgroundImage);\n            minput = new MouseInput(handler, cam);\n            this.minput = minput;\n\n            \n            for (var l : this.getMouseListeners()) this.removeMouseListener(l);\n            this.addMouseListener(minput);\n            minput.findPlayer(); \n            player = new Player(0, 0, ID.Player, input, handler, cam); \n            Game.player = player;\n            input.setPlayer(player);\n            minput.findPlayer();\n            handler.addObject(player);\n\n            while ((line = reader.readLine()) != null) {\n                String[] data = line.split(\",\");\n\n                if (data[0].equals(\"PLAYER\")) {\n                    float savedX = Float.parseFloat(data[1]);\n                    float savedY = Float.parseFloat(data[2]);\n                    int savedHealth = Integer.parseInt(data[3]);\n                    int savedMaxHealth = Integer.parseInt(data[4]);\n                    killedZombies = Integer.parseInt(data[5]);\n                    if (data.length >= 24) { //zorluga gelcek \n                        try {\n                            Game.difficulty = Difficulty.valueOf(data[23]);\n                            System.out.println(\"Yüklenen zorluk seviyesi: \" + Game.difficulty);\n                        } catch (Exception ex) {\n                            System.out.println(\"Zorluk seviyesi okunamadı, varsayılan MEDIUM kullanılacak.\");\n                            Game.difficulty = Difficulty.MEDIUM;\n                        }\n                    }\n\n                    score = Integer.parseInt(data[6]);\n                    spentScore = (data.length >= 24) ? Integer.parseInt(data[7]) : 0; \n                    currentWave = Integer.parseInt(data[8]);\n\n                  \n                    \n                    player.setX(savedX);\n                    player.setY(savedY);\n\n                    Rectangle checkRect = new Rectangle((int) savedX, (int) savedY, 32, 32);\n                    TileManager tileManager = handler.getTileManager();\n\n                    // Stuck kalcak şekilde doğduysa kaydır\n                    if (tileManager != null && tileManager.hasCollision(checkRect)) {\n                        \n\n                        boolean found = false;\n                        int[] dx = {0, 32, -32, 0, 0}; // sağ, sol, yukarı, aşağı\n                        int[] dy = {0, 0, 0, -32, 32};\n\n                        for (int i = 0; i < dx.length; i++) {\n                            float newX = savedX + dx[i];\n                            float newY = savedY + dy[i];\n                            Rectangle tryRect = new Rectangle((int) newX, (int) newY, 32, 32);\n\n                            if (!tileManager.hasCollision(tryRect)) {\n                                player.setX(newX);\n                                player.setY(newY);\n                                found = true;\n                                break;\n                            }\n                        }\n\n                       \n                    }\n\n                    \n                    \n                    \n                    player.setMaxHealth(savedMaxHealth);\n                    player.takeDamage(player.getHealth() - savedHealth);\n                    player.pistol.setCurrentAmmo(Integer.parseInt(data[21]));\n                    player.pistol.setReserveAmmo(Integer.parseInt(data[22]));\n\n                    // Silahlar\n                    boolean hasRifle = Boolean.parseBoolean(data[9]);\n                    boolean hasShotgun = Boolean.parseBoolean(data[10]);\n                    boolean hasSniper = Boolean.parseBoolean(data[11]);\n                    boolean hasRocket = Boolean.parseBoolean(data[12]);\n\n                    if (hasRifle) {\n                        player.unlockRifle();\n                        player.rifle.setCurrentAmmo(Integer.parseInt(data[13]));\n                        player.rifle.setReserveAmmo(Integer.parseInt(data[14]));\n                    }\n\n                    if (hasShotgun) {\n                        player.unlockShotgun();\n                        player.shotgun.setCurrentAmmo(Integer.parseInt(data[15]));\n                        player.shotgun.setReserveAmmo(Integer.parseInt(data[16]));\n                    }\n\n                    if (hasSniper) {\n                        player.unlockSniper();\n                        player.sniper.setCurrentAmmo(Integer.parseInt(data[17]));\n                        player.sniper.setReserveAmmo(Integer.parseInt(data[18]));\n                    }\n\n                    if (hasRocket) {\n                        player.unlockRocketLauncher();\n                        player.rocketLauncher.setCurrentAmmo(Integer.parseInt(data[19]));\n                        player.rocketLauncher.setReserveAmmo(Integer.parseInt(data[20]));\n                    }\n\n                } else if (data[0].equals(\"ZOMBIE\")) {\n                    String type = data[1];\n                    float x = Float.parseFloat(data[2]);\n                    float y = Float.parseFloat(data[3]);\n                    int health = Integer.parseInt(data[4]);\n\n                    Rectangle zombieRect = new Rectangle((int)x, (int)y, 32, 32);\n                    TileManager tileManager = handler.getTileManager();\n\n                    // 10 kez dene daha iyi olsun istersek arttırırız\n                    int attempts = 0;\n                    while ((tileManager.hasCollision(zombieRect) || !tileManager.isSpawnable(zombieRect)) && attempts < 10) {\n                        x = (float) (Math.random() * cam.getWorldWidth());\n                        y = (float) (Math.random() * cam.getWorldHeight());\n                        zombieRect = new Rectangle((int)x, (int)y, 32, 32);\n                        attempts++;\n                    }\n\n                    // Yukardaki Playerin aynisi\n                    if (tileManager.hasCollision(zombieRect)) {\n                        int[] dx = {0, 32, -32, 0, 0};\n                        int[] dy = {0, 0, 0, -32, 32};\n                        for (int i = 0; i < dx.length; i++) {\n                            float newX = x + dx[i];\n                            float newY = y + dy[i];\n                            Rectangle tryRect = new Rectangle((int)newX, (int)newY, 32, 32);\n                            if (!tileManager.hasCollision(tryRect)) {\n                                x = newX;\n                                y = newY;\n                                break;\n                            }\n                        }\n                    }\n\n                    Zombie z = switch (type) {\n                        case \"NormalZombie\" -> new NormalZombie(x, y, cam, player);\n                        case \"TankZombie\" -> new TankZombie(x, y, cam, player);\n                        case \"CrawlerZombie\" -> new CrawlerZombie(x, y, cam, player);\n                        case \"AcidZombie\" -> new AcidZombie(x, y, cam, player);\n                        default -> null;\n                    };\n\n                    if (z != null) {\n                        z.health = health;\n                        handler.addObject(z);\n                    }\n                }\n\n            }\n\n            reader.close();\n            gameStarted = true;\n            openMainMenu = false;\n            showDifficultyMenu = false;\n            isPaused = false;\n            System.out.println(\"Kayıtlı oyun yüklendi!\");\n        } catch (IOException e) {\n            System.out.println(\"Kayıtlı oyun bulunamadı!\");\n        }\n        minput.findPlayer(); \n\n    }\n\n\n\n    public static void main(String[] args) {\n        new Game();\n    }\n}",
      "MouseInput.java": "package game;\n\nimport java.awt.Point;\nimport java.awt.MouseInfo;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class MouseInput extends MouseAdapter {\n\n    private Handler handler;\n    private Camera cam;\n    private GameObject tempPlayer = null;\n    private boolean shooting = false;\n\n    public MouseInput(Handler handler, Camera cam) {\n        this.handler = handler;\n        this.cam = cam;\n    }\n\n    public void findPlayer() {\n        for (int i = 0; i < handler.object.size(); i++) {\n            if (handler.object.get(i).getId() == ID.Player) {\n                tempPlayer = handler.object.get(i);\n                break;\n            }\n        }\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        shooting = true;\n\n        int mx = e.getX();\n        int my = e.getY();\n        Point click = new Point(mx, my);\n\n        // === Ana Menü ===\n        if (Game.instance.openMainMenu) {\n            if (Game.instance.startButton.contains(click)) {\n                Game.instance.openMainMenu = false;\n                Game.instance.showDifficultyMenu = true;\n            } else if (Game.instance.loadButton.contains(click)) {\n                Game.instance.loadGame();\n            } else if (Game.instance.exitButton.contains(click)) {\n                System.exit(0);\n            } else if (Game.instance.musicButton.contains(click)) {\n                Game.instance.musicOn = !Game.instance.musicOn;\n\n                if (Game.instance.musicOn) {\n                    if (Game.instance.backgroundMusic != null) {\n                        Game.instance.backgroundMusic.start();\n                    } else {\n                        Game.instance.initMusic(); \n                    }\n                } else {\n                    if (Game.instance.backgroundMusic != null) {\n                        Game.instance.backgroundMusic.stop();\n                    }\n                }\n            }\n            return;\n        }\n\n        // Difficulty sec\n        if (Game.instance.showDifficultyMenu) {\n            if (Game.instance.easyButton.contains(click)) {\n                Game.difficulty = Difficulty.EASY;\n                Game.instance.startGame();\n            } else if (Game.instance.mediumButton.contains(click)) {\n                Game.difficulty = Difficulty.MEDIUM;\n                Game.instance.startGame();\n            } else if (Game.instance.hardButton.contains(click)) {\n                Game.difficulty = Difficulty.HARD;\n                Game.instance.startGame();\n            } else if (Game.instance.testButton.contains(click)) {\n                Game.difficulty = Difficulty.TEST;\n                Game.instance.startGame();\n            }\n            return;\n        }\n\n      \n    }\n\n\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        shooting = false;\n    }\n\n    public void tick() {\n        if (tempPlayer == null) findPlayer();\n\n        if (!shooting || tempPlayer == null) return;\n\n        Player p = (Player) tempPlayer;\n        Gun gun = p.getCurrentGun();\n\n        if (gun.isReloading()) {\n            gun.cancelReload();  // Önce reload'u iptal et\n        }\n\n        if (gun.canFire()) {\n            try {\n                Point mousePos = MouseInfo.getPointerInfo().getLocation();\n                Point gamePos = Game.instance.getLocationOnScreen();\n\n                int mx = mousePos.x - gamePos.x;\n                int my = mousePos.y - gamePos.y;\n\n                float[] gunTip = p.getGunTipPosition();\n                float dx = mx - (gunTip[0] - cam.getX());\n                float dy = my - (gunTip[1] - cam.getY());\n                float angle = (float) Math.atan2(dy, dx);\n\n                gun.fire(gunTip[0], gunTip[1], angle, handler);\n            } catch (Exception e) {\n               \n            }\n        }\n    }\n\n}\n",
      "Camera.java": "package game;\n\nimport java.awt.image.BufferedImage;\n\npublic class Camera {\n    private float x, y;\n    private Handler handler;\n    private GameObject tempPlayer = null;\n\n    private int worldWidth, worldHeight;\n\n    public Handler getHandler() {\n        return handler;\n    }\n\n    public int getWorldWidth() {\n        return worldWidth;\n    }\n\n    public int getWorldHeight() {\n        return worldHeight;\n    }\n\n    public Camera(float x, float y, Handler handler, BufferedImage backgroundImage) {\n        this.x = x;\n        this.y = y;\n        this.handler = handler;\n        findPlayer();\n\n        \n        this.worldWidth = TileManager.WIDTH * TileManager.TILE_SIZE;\n        this.worldHeight = TileManager.HEIGHT * TileManager.TILE_SIZE;\n    }\n\n    public void findPlayer() {\n        for (int i = 0; i < handler.object.size(); i++) {\n            if (handler.object.get(i).getId() == ID.Player) {\n                tempPlayer = handler.object.get(i);\n                break;\n            }\n        }\n    }\n\n    public void tick() {\n        if (tempPlayer != null) {\n            float newX = tempPlayer.getX() - Game.width / 2 + 16;\n            float newY = tempPlayer.getY() - Game.height / 2 + 16;\n\n            x += (newX - x) * 0.1;\n            y += (newY - y) * 0.1;\n        } else {\n            findPlayer();\n        }\n\n        //Camera Limitleri\n        x = clamp(x, worldWidth - Game.width, 0);\n        y = clamp(y, worldHeight - Game.height + TileManager.TILE_SIZE, 0);\n\n    }\n\n    public int getX() {\n        return (int) x;\n    }\n\n    public int getY() {\n        return (int) y;\n    }\n\n    \n    private float clamp(float value, float max, float min) {\n        if (value < min) return min;\n        if (value > max) return max;\n        return value;\n    }\n}\n",
      "RocketLauncher.java": "package game;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\n\npublic class RocketLauncher extends Gun {\n\t\n\n\tprivate static BufferedImage rocketImage;\n\n\t//static yaptık her seferde olusturmasin diye\n    static {\n        try {\n            rocketImage = ImageIO.read(new File(\"src/game/rocketlauncherbullet.png\"));\n        } catch (IOException e) {\n            System.out.println(\"Rocket bullet görseli yüklenemedi!\");\n        }\n    }\n\t\n    public RocketLauncher() {\n        super(1, 10, 0); // 1 roket, 10 hızında, 3 yedek\n        this.reloadPerBullet=1000;\n        \n    }\n\n    @Override\n    public void fire(float x, float y, float angle, Handler handler) {\n        if (!canFire()) return;\n\n        Bullet rocket = new Bullet(x, y, ID.Bullet,handler) {\n            @Override\n            public void tick() {\n                x += velX;\n                y += velY;\n\n                //Collision Baktık\n                for (GameObject obj : handler.object) {\n                    if (obj.getId() == ID.Zombie) {\n                        if (getBounds().intersects(obj.getBounds())) {\n                            explode();\n                            handler.removeObject(this);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            private void explode() {\n                for (GameObject obj : new java.util.LinkedList<>(handler.object)) {\n                    if (obj instanceof Zombie zomb) {\n                        double dist = Math.hypot(zomb.getX() - x, zomb.getY() - y);\n                        if (dist < 70) {\n                            zomb.health -= 150;\n                            if (zomb.health <= 0) {\n                                handler.removeObject(zomb);\n                                Game.killedZombies++;\n                            }\n                        }\n                    }\n                }\n            }\n\n\n            @Override\n            public void render(Graphics g) {\n            \t\n\n            \tif (rocketImage != null) {\n                    g.drawImage(rocketImage, (int) x, (int) y, 12, 12, null);\n                } else {\n                    g.setColor(java.awt.Color.orange);\n                    g.fillRect((int) x, (int) y, 12, 12);\n                }\n\n            }\n\n            @Override\n            public Rectangle getBounds() {\n                return new Rectangle((int)x, (int)y, 12, 12);\n            }\n        };\n\n        rocket.velX = (float) (7 * Math.cos(angle));\n        rocket.velY = (float) (7 * Math.sin(angle));\n        handler.addObject(rocket);\n\n        currentAmmo--;\n        lastFiredTime = System.currentTimeMillis();\n    }\n}\n",
      "TileManager.java": "package game;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\n\npublic class TileManager {\n    public static final int TILE_SIZE = 32;\n    public static final int WIDTH = 40;\n    public static final int HEIGHT = 30;\n    private Tile[][] tiles = new Tile[WIDTH][HEIGHT];\n    private Set<Point> occupied = new HashSet<>();\n\n    public enum TileType {\n        GRASS(\"grass.png\", false),\n        BUSH(\"bush.png\", false),\n        TREE(\"tree.png\", true),\n        HAYBALE(\"haybale.png\", true), // mapte çok collision alan olacagi icin\n        BRICK(\"brick.png\", true),     // kullanilmadi\n        STONE(\"stone.png\", true),\n        LAVA(\"lava.png\", false),\n        WATER(\"water.png\", false);\n\n        public final String filename;\n        public final boolean hasCollision;\n\n        TileType(String filename, boolean hasCollision) {\n            this.filename = filename;\n            this.hasCollision = hasCollision;\n        }\n    }\n\n    public static class Tile {\n        TileType type;\n        BufferedImage image;\n\n        Tile(TileType type) {\n            this.type = type;\n            try {\n                image = ImageIO.read(new File(\"src/game/\" + type.filename));\n            } catch (IOException e) {\n                System.out.println(\"Görsel yüklenemedi: \" + type.filename);\n            }\n        }\n\n        void render(Graphics g, int x, int y) {\n            if (image != null)\n                g.drawImage(image, x, y, TILE_SIZE, TILE_SIZE, null);\n        }\n\n        boolean hasCollision() {\n            return type.hasCollision;\n        }\n\n        TileType getType() {\n            return type;\n        }\n    }\n\n    public TileManager() {\n        generateMap();\n    }\n\n    public void generateMap() {\n        for (int x = 0; x < WIDTH; x++) {\n            for (int y = 0; y < HEIGHT; y++) {\n                setTile(x, y, TileType.GRASS);\n            }\n        }\n\n        for (int x = 0; x < WIDTH; x++) {\n            setTile(x, 0, TileType.BRICK);\n            setTile(x, HEIGHT - 1, TileType.BRICK);\n        }\n        for (int y = 0; y < HEIGHT; y++) {\n            setTile(0, y, TileType.BRICK);\n            setTile(WIDTH - 1, y, TileType.BRICK);\n        }\n\n        int wx = 2, wy = 2;\n        placeArea(wx, wy, TileType.WATER);\n        surroundArea(wx, wy, TileType.STONE);\n\n        int lx = WIDTH - 5, ly = HEIGHT - 5;\n        placeArea(lx, ly, TileType.LAVA);\n        surroundArea(lx, ly, TileType.STONE);\n\n        Random rand = new Random();\n        int treeCount = 60;\n        int bushCount = 100;\n\n        for (int i = 0; i < treeCount;) {\n            int x = rand.nextInt(WIDTH - 2) + 1;\n            int y = rand.nextInt(HEIGHT - 2) + 1;\n            if (canPlaceTree(x, y)) {\n                setTile(x, y, TileType.TREE);\n                markSurroundingOccupied(x, y);\n                i++;\n            }\n        }\n\n        for (int i = 0; i < bushCount;) {\n            int x = rand.nextInt(WIDTH - 2) + 1;\n            int y = rand.nextInt(HEIGHT - 2) + 1;\n            Point p = new Point(x, y);\n            if (!occupied.contains(p) && !isSpecialTile(x, y)) {\n                setTile(x, y, TileType.BUSH);\n                i++;\n            }\n        }\n    }\n\n    private boolean canPlaceTree(int x, int y) {\n        if (isSpecialTile(x, y)) return false;\n        for (int dx = -1; dx <= 1; dx++) {\n            for (int dy = -1; dy <= 1; dy++) {\n                Point p = new Point(x + dx, y + dy);\n                if (occupied.contains(p)) return false;\n            }\n        }\n        return true;\n    }\n\n    private void markSurroundingOccupied(int cx, int cy) {\n        for (int dx = -1; dx <= 1; dx++) {\n            for (int dy = -1; dy <= 1; dy++) {\n                int x = cx + dx;\n                int y = cy + dy;\n                if (x > 0 && y > 0 && x < WIDTH && y < HEIGHT) {\n                    occupied.add(new Point(x, y));\n                }\n            }\n        }\n    }\n\n    private void placeArea(int startX, int startY, TileType type) {\n        for (int x = startX; x < startX + 2; x++) {\n            for (int y = startY; y < startY + 2; y++) {\n                setTile(x, y, type);\n                occupied.add(new Point(x, y));\n            }\n        }\n    }\n\n    private void surroundArea(int startX, int startY, TileType type) {\n        for (int x = startX - 1; x <= startX + 2; x++) {\n            for (int y = startY - 1; y <= startY + 2; y++) {\n                if (x >= 0 && y >= 0 && x < WIDTH && y < HEIGHT) {\n                    if (!occupied.contains(new Point(x, y)))\n                        setTile(x, y, type);\n                }\n            }\n        }\n    }\n\n    private boolean isSpecialTile(int x, int y) {\n        TileType t = getTileTypeAt(x, y);\n        return t == TileType.WATER || t == TileType.LAVA || t == TileType.STONE || t == TileType.BRICK;\n    }\n\n    public void setTile(int x, int y, TileType type) {\n        if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {\n            tiles[x][y] = new Tile(type);\n        }\n    }\n\n    public void render(Graphics g) {\n        for (int x = 0; x < WIDTH; x++) {\n            for (int y = 0; y < HEIGHT; y++) {\n                tiles[x][y].render(g, x * TILE_SIZE, y * TILE_SIZE);\n            }\n        }\n    }\n\n    public boolean hasCollision(float x, float y) {\n        int tileX = (int)(x / TILE_SIZE);\n        int tileY = (int)(y / TILE_SIZE);\n        if (tileX < 0 || tileY < 0 || tileX >= WIDTH || tileY >= HEIGHT) return true;\n        return tiles[tileX][tileY].hasCollision();\n    }\n\n    public boolean hasCollision(Rectangle bounds) {\n        int left = bounds.x;\n        int right = bounds.x + bounds.width;\n        int top = bounds.y;\n        int bottom = bounds.y + bounds.height;\n\n        return hasCollision(left, top) || hasCollision(right, top) ||\n               hasCollision(left, bottom) || hasCollision(right, bottom);\n    }\n\n    public TileType getTileTypeAt(int x, int y) {\n        if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {\n            return tiles[x][y].type;\n        }\n        return TileType.GRASS;\n    }\n\n    // iyi bir spawn yeri mi\n    public boolean isSpawnable(Rectangle rect) {\n        int left = rect.x / TILE_SIZE;\n        int top = rect.y / TILE_SIZE;\n        int right = (rect.x + rect.width) / TILE_SIZE;\n        int bottom = (rect.y + rect.height) / TILE_SIZE;\n\n        for (int x = left; x <= right; x++) {\n            for (int y = top; y <= bottom; y++) {\n                if (x < 0 || y < 0 || x >= WIDTH || y >= HEIGHT) return false;\n                Tile tile = tiles[x][y];\n                TileType type = tile.getType();\n                if (type == TileType.LAVA || type == TileType.WATER || type == TileType.BRICK || type == TileType.STONE || tile.hasCollision()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n",
      "Window.java": "package game;\n\nimport java.awt.Dimension;\nimport java.awt.Image;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JFrame;\n\npublic class Window {\n\n    private JFrame frame;\n\n    public Window(int width, int height, String title, Game game) {\n        frame = new JFrame(title);\n        try {\n            Image icon = ImageIO.read(new File(\"src/game/icon.png\"));\n            frame.setIconImage(icon);\n        } catch (IOException e) {\n            System.out.println(\"İkon yüklenemedi!\");\n        }\n\n        frame.setPreferredSize(new Dimension(width, height));\n        frame.setMaximumSize(new Dimension(width, height));\n        frame.setMinimumSize(new Dimension(width, height));\n\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setResizable(false);\n        frame.setLocationRelativeTo(null);\n        frame.add(game); \n        game.requestFocus(); \n\n\n        \n        \n        frame.setVisible(true);\n    }\n}\n",
      "Player.java": "package game;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class Player extends GameObject {\n\n    private float _acc = 1f;\n    private float _dcc = 0.5f;\n    private KeyInput input;\n    private int health = 150;\n    private Handler handler;\n    private Camera cam;\n    private int maxHealth = 150;\n\n    private BufferedImage pistolImg, rifleImg, shotgunImg, sniperImg, rocketImg;\n    private BufferedImage idleImage;\n    private BufferedImage[] runFrames = new BufferedImage[8];\n\n    private int animationIndex = 0;\n    private long lastFrameTime = 0;\n    private long frameDelay = 100;\n    private String direction = \"down\";\n\n    private long lastDamageTime = 0;\n    private long damageCooldown = 1000;\n\n    private Gun currentGun;\n    public Gun pistol = new Pistol();\n    public Gun rifle = null;\n    public Gun shotgun = null;\n    public Gun sniper = null;\n    public Gun rocketLauncher = null;\n\n    public void heal(int amount) {\n        health = Math.min(health + amount, maxHealth);\n    }\n\n    public int getMaxHealth() {\n        return maxHealth;\n    }\n\n    public void setMaxHealth(int maxHealth) {\n        this.maxHealth = maxHealth;\n    }\n\n    public void increaseMaxHealth(int amount) {\n        maxHealth += amount;\n        health += amount;\n    }\n\n    public Player(float x, float y, ID id, KeyInput input, Handler handler, Camera cam) {\n        super(x, y, id);\n        this.input = input;\n        this.handler = handler;\n        this.cam = cam;\n        this.currentGun = pistol;\n        velX = 0;\n        velY = 0;\n\n        try {\n            idleImage = ImageIO.read(new File(\"src/game/idle1.png\"));\n            for (int i = 0; i < 8; i++) {\n                runFrames[i] = ImageIO.read(new File(\"src/game/run\" + (i + 1) + \".png\"));\n            }\n            System.out.println(\"Tüm sprite'lar başarıyla yüklendi!\");\n        } catch (IOException e) {\n            System.out.println(\"Sprite yüklenirken hata oluştu!\");\n        }\n\n        try {\n            pistolImg = ImageIO.read(new File(\"src/game/pistol.png\"));\n            rifleImg = ImageIO.read(new File(\"src/game/assault_rifle.png\"));\n            shotgunImg = ImageIO.read(new File(\"src/game/shotgun.png\"));\n            sniperImg = ImageIO.read(new File(\"src/game/sniper.png\"));\n            rocketImg = ImageIO.read(new File(\"src/game/rocketlauncher.png\"));\n        } catch (IOException e) {\n            System.out.println(\"Silah görselleri yüklenemedi!\");\n        }\n    }\n\n    //silah hizalama\n    public float[] getGunTipPosition() {\n        float gunX = x;\n        float gunY = y;\n        int offsetX = 16;\n        int offsetY = 16;\n\n        int gunLength = switch (currentGun.getClass().getSimpleName()) {\n            case \"Pistol\" -> 16;\n            case \"Rifle\" -> 20;\n            case \"Shotgun\" -> 18;\n            case \"Sniper\" -> 24;\n            case \"RocketLauncher\" -> 26;\n            default -> 16;\n        };\n\n        switch (direction) {\n            case \"right\" -> {\n                gunX += offsetX + gunLength;\n                gunY += offsetY;\n            }\n            case \"left\" -> {\n                gunX += offsetX - gunLength;\n                gunY += offsetY;\n            }\n            case \"up\" -> {\n                gunX += offsetX;\n                gunY += offsetY - gunLength;\n            }\n            case \"down\" -> {\n                gunX += offsetX;\n                gunY += offsetY + gunLength;\n            }\n        }\n\n        return new float[]{gunX, gunY};\n    }\n\n    @Override\n    public void tick() {\n        Gun gun = getCurrentGun();\n        if (gun.isReloading() && System.currentTimeMillis() - gun.reloadStartTime >= gun.reloadDuration) {\n            gun.completeReload();\n        }\n\n        // Movement için\n        if (input.keys[0]) {\n            velX += _acc;\n            direction = \"right\";\n        } else if (input.keys[1]) {\n            velX -= _acc;\n            direction = \"left\";\n        } else {\n            if (velX > 0) velX -= _dcc;\n            else if (velX < 0) velX += _dcc;\n        }\n\n        if (input.keys[2]) {\n            velY -= _acc;\n            direction = \"up\";\n        } else if (input.keys[3]) {\n            velY += _acc;\n            direction = \"down\";\n        } else {\n            if (velY > 0) velY -= _dcc;\n            else if (velY < 0) velY += _dcc;\n        }\n\n        velX = clamp(velX, 5, -5);\n        velY = clamp(velY, 5, -5);\n\n        float nextX = x + velX;\n        float nextY = y + velY;\n        Rectangle nextBounds = new Rectangle((int) nextX, (int) nextY, 32, 32);\n\n        if (handler.getTileManager() == null || !handler.getTileManager().hasCollision(nextBounds)) {\n            x = nextX;\n            y = nextY;\n        } else {\n            velX = 0;\n            velY = 0;\n        }\n\n        long now = System.currentTimeMillis();\n        if (isMoving() && now - lastFrameTime > frameDelay) {\n            animationIndex = (animationIndex + 1) % runFrames.length;\n            lastFrameTime = now;\n        }\n\n        for (GameObject obj : handler.object) {\n            if (obj instanceof Zombie z && z.getAttackBounds().intersects(getBounds())) {\n                if (now - lastDamageTime >= damageCooldown) {\n                    takeDamage(z.damage);\n                    lastDamageTime = now;\n                }\n            }\n        }\n    }\n\n    private boolean isMoving() {\n        return input.keys[0] || input.keys[1] || input.keys[2] || input.keys[3];\n    }\n\n    private float clamp(float value, float max, float min) {\n        if (value > max) return max;\n        else if (value < min) return min;\n        return value;\n    }\n\n    @Override\n    public void render(Graphics g) {\n        BufferedImage frame = runFrames[animationIndex];\n\n        if (!isMoving()) {\n            g.drawImage(idleImage, (int) x, (int) y, 32, 32, null);\n        } else {\n            switch (direction) {\n                case \"right\" -> g.drawImage(frame, (int) x, (int) y, 32, 32, null);\n                case \"left\" -> g.drawImage(frame, (int) x + 32, (int) y, -32, 32, null);\n                case \"up\", \"down\" -> g.drawImage(frame, (int) x, (int) y, 32, 32, null);\n            }\n        }\n\n        BufferedImage gunImage = null;\n        if (currentGun instanceof Pistol) gunImage = pistolImg;\n        else if (currentGun instanceof Rifle) gunImage = rifleImg;\n        else if (currentGun instanceof Shotgun) gunImage = shotgunImg;\n        else if (currentGun instanceof Sniper) gunImage = sniperImg;\n        else if (currentGun instanceof RocketLauncher) gunImage = rocketImg;\n\n        if (gunImage != null) {\n            int gunWidth = 20, gunHeight = 20;\n            int gunOffsetX = 0, gunOffsetY = 0;\n\n            switch (direction) {\n                case \"right\" -> {\n                    gunOffsetX = 22;\n                    gunOffsetY = 14;\n                    g.drawImage(gunImage, (int) x + gunOffsetX, (int) y + gunOffsetY, gunWidth, gunHeight, null);\n                }\n                case \"left\" -> {\n                    gunOffsetX = -10;\n                    gunOffsetY = 14;\n                    g.drawImage(gunImage, (int) x + gunOffsetX + gunWidth, (int) y + gunOffsetY, -gunWidth, gunHeight, null);\n                }\n                case \"up\", \"down\" -> {\n                    Graphics2D g2d = (Graphics2D) g.create();\n                    double angle = direction.equals(\"up\") ? -Math.PI / 2 : Math.PI / 2;\n                    gunOffsetX = 6;\n                    gunOffsetY = direction.equals(\"up\") ? -5 : 20;\n                    int centerX = (int) x + gunOffsetX + gunWidth / 2;\n                    int centerY = (int) y + gunOffsetY + gunHeight / 2;\n                    g2d.rotate(angle, centerX, centerY);\n                    g2d.drawImage(gunImage, (int) x + gunOffsetX, (int) y + gunOffsetY, gunWidth, gunHeight, null);\n                    g2d.dispose();\n                }\n            }\n        }\n\n        renderHealthBar(g, 32);\n    }\n\n    @Override\n    public Rectangle getBounds() {\n        return new Rectangle((int) x, (int) y, 32, 32);\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public void takeDamage(int damage) {\n        health -= damage;\n        if (health <= 0) {\n            health = 0;\n            System.out.println(\"YOU DIED\");\n            Game.gameOver = true;\n        }\n    }\n\n    public Gun getCurrentGun() {\n        return currentGun;\n    }\n\n    public void setCurrentGun(Gun gun) {\n        if (currentGun != null) currentGun.cancelReload();\n        this.currentGun = gun;\n    }\n\n    public void unlockRifle() {\n        if (rifle == null) rifle = new Rifle();\n    }\n\n    public void unlockShotgun() {\n        if (shotgun == null) shotgun = new Shotgun();\n    }\n\n    public void unlockSniper() {\n        if (sniper == null) sniper = new Sniper();\n    }\n\n    public void unlockRocketLauncher() {\n        if (rocketLauncher == null) rocketLauncher = new RocketLauncher();\n    }\n}\n",
      "GameObject.java": "package game;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Rectangle;\n\npublic abstract class GameObject {\n\t\n\tprotected float x,y;\n\tprotected float velX,velY;\n\tprotected ID id;\n\tprotected int health;\n\tprotected int maxHealth;\n\n\tpublic GameObject(float x,float y,ID id) {\n\tthis.x=x;\n\tthis.y=y;\n\tthis.id=id;\n\t}\n\tpublic abstract Rectangle getBounds();\n\tpublic abstract void tick();\n\tpublic abstract void render(Graphics g);\n\t\n\tpublic void renderHealthBar(Graphics g, int width) {\n\t    g.setColor(Color.green);\n\t    int barWidth = (int)(width * ((float)health / maxHealth));\n\t    g.fillRect((int)x, (int)y - 10, barWidth, 5);\n\t    \n\t    if(health<= maxHealth*0.5) {\n\t    \tg.setColor(Color.red);\n\t    \t g.fillRect((int)x, (int)y - 10, barWidth, 5);\n\t    }\n\t}\n\n\n\tpublic float getX() {\n\t\treturn x;\n\t}\n\n\tpublic void setX(float x) {\n\t\tthis.x = x;\n\t}\n\n\tpublic float getY() {\n\t\treturn y;\n\t}\n\n\tpublic void setY(float y) {\n\t\tthis.y = y;\n\t}\n\n\tpublic float getVelX() {\n\t\treturn velX;\n\t}\n\n\tpublic void setVelX(float velX) {\n\t\tthis.velX = velX;\n\t}\n\n\tpublic float getVelY() {\n\t\treturn velY;\n\t}\n\n\tpublic void setVelY(float velY) {\n\t\tthis.velY = velY;\n\t}\n\n\tpublic ID getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(ID id) {\n\t\tthis.id = id;\n\t}\n\t\n\t\n\n}\n"
    },
    {
      "id": "5361565",
      "PompaliTufek.java": "public class PompaliTufek extends Weapon {\n    public PompaliTufek() {\n        super(10, 5, 0, 15); // damage, magazine size, total ammo, fire rate\n        this.reloadTime = 2000; // 2 seconds reload time\n    }\n\n    @Override\n    public void shoot() {\n        if (currentAmmo > 0) {\n            currentAmmo--;\n        }\n    }\n\n    @Override\n    public boolean isRocket() {\n        return false;\n    }\n}\n",
      "Tabanca.java": "public class Tabanca extends Weapon {\n    public Tabanca() {\n        super(10, 12, 0, 15); // damage, magazine size, total ammo, fire rate\n        this.reloadTime = 500; // 0.5 seconds reload time\n    }\n\n    @Override\n    public void shoot() {\n        if (currentAmmo > 0) {\n            currentAmmo--;\n        }\n    }\n\n    @Override\n    public boolean isRocket() {\n        return false;\n    }\n}\n",
      "NormalZombi.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class NormalZombi extends Zombie{\n    public NormalZombi(GamePanel gp){\n        super(gp, 0); // Call parent constructor with type 0 (Normal)\n        this.gp=gp;\n        health = 60;\n        damage = 6;\n        velocity=2;\n        direction = \"down\";\n        counter = 0;\n        num = 1;\n        collisionOn = false;\n\n        // Set up collision area\n        solid = new Rectangle(3, 18, 42, 30);\n\n        getImage();\n    }\n    public void getImage(){\n        try {\n            System.out.println(\"Loading Normal Zombie images...\");\n            up1 = ImageIO.read(getClass().getResourceAsStream(\"merchant_down_1.png\"));\n            up2 = ImageIO.read(getClass().getResourceAsStream(\"merchant_down_2.png\"));\n            down1 = ImageIO.read(getClass().getResourceAsStream(\"merchant_down_1.png\"));\n            down2 = ImageIO.read(getClass().getResourceAsStream(\"merchant_down_2.png\"));\n            left1 = ImageIO.read(getClass().getResourceAsStream(\"merchant_down_1.png\"));\n            left2 = ImageIO.read(getClass().getResourceAsStream(\"merchant_down_2.png\"));\n            right1 = ImageIO.read(getClass().getResourceAsStream(\"merchant_down_1.png\"));\n            right2 = ImageIO.read(getClass().getResourceAsStream(\"merchant_down_2.png\"));\n            System.out.println(\"Normal Zombie images loaded successfully\");\n        } catch (IOException e) {\n            System.out.println(\"Error loading Normal Zombie images: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public void setAction() {\n        // Zombinin oyuncuya olan uzaklığını hesapla\n        int xDistance = gp.shooter.worldX - worldX;\n        int yDistance = gp.shooter.worldY - worldY;\n\n        // Zombinin hareket yönünü belirle\n        if(Math.abs(xDistance) > Math.abs(yDistance)) {\n            // X ekseni farkı daha büyükse, öncelikle X yönünde hareket et\n            if(xDistance < 0) {\n                direction = \"left\";\n            } else {\n                direction = \"right\";\n            }\n        } else {\n            // Y ekseni farkı daha büyükse veya eşitse, öncelikle Y yönünde hareket et\n            if(yDistance < 0) {\n                direction = \"up\";\n            } else {\n                direction = \"down\";\n            }\n        }\n\n        // Her 60 frame'de bir yön güncelleme yapılsın\n        counter++;\n        if(counter > 60) {\n            counter = 0;\n        }\n    }\n\n    @Override\n    public void update() {\n        // Only update if zombie is alive and not null in the array\n        if (health > 0 && isAliveInArray()) {\n            super.update(); // Call parent's update method for movement\n            setAction();\n            \n            counter++;\n            if(counter > 12) {\n                if(num == 1) {\n                    num = 2;\n                }\n                else {\n                    num = 1;\n                }\n                counter = 0;\n            }\n        }\n    }\n\n    private boolean isAliveInArray() {\n        // Check if this zombie instance is still in the array\n        for (int i = 0; i < gp.zombies.length; i++) {\n            if (gp.zombies[i] == this) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        // Only draw if zombie is alive and not null in the array\n        if (health <= 0 || !isAliveInArray() || g2d == null) {\n            return;\n        }\n\n        BufferedImage image = null;\n        switch(direction) {\n            case \"up\":\n                if(num == 1) { image = up1; }\n                if(num == 2) { image = up2; }\n                break;\n            case \"down\":\n                if(num == 1) { image = down1; }\n                if(num == 2) { image = down2; }\n                break;\n            case \"left\":\n                if(num == 1) { image = left1; }\n                if(num == 2) { image = left2; }\n                break;\n            case \"right\":\n                if(num == 1) { image = right1; }\n                if(num == 2) { image = right2; }\n                break;\n        }\n\n        if (image == null) {\n            return;\n        }\n\n        int screenX = worldX - gp.shooter.worldX + gp.shooter.screenX;\n        int screenY = worldY - gp.shooter.worldY + gp.shooter.screenY;\n        g2d.drawImage(image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n    }\n}\n",
      "Zombie.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Zombie extends Entity {\n    public int health;\n    public int damage;\n    public GamePanel gp;\n    public int worldX, worldY;\n    public int speed;\n    public int maxHealth;\n    public int type; // 0: Normal, 1: Fast, 2: Tank, 3: Crawler, 4: AsitTukurenZombi\n    public int screenX;\n    public int screenY;\n    public int size;\n    public boolean isJumping = false;\n    public int jumpHeight = 0;\n    public int maxJumpHeight = 100;\n    public int jumpSpeed = 5;\n    public int jumpCooldown = 0;\n    public int maxJumpCooldown = 120; // 2 seconds at 60 FPS\n    public boolean collisionOn = false;\n    public Rectangle solid;\n    public String direction;\n    public boolean active = true;\n    public int spriteCounter = 0;\n    public int spriteNum = 1;\n    public BufferedImage up1, up2, down1, down2, left1, left2, right1, right2;\n\n    public Zombie(GamePanel gp, int type) {\n        this.gp = gp;\n        this.type = type;\n        setDefaultValues();\n        \n        // Set up collision area to match shooter's collision box\n        solid = new Rectangle(8, 16, gp.tilesize-16, gp.tilesize-16);\n    }\n\n    public void setDefaultValues() {\n        switch(type) {\n            case 0: // Normal\n                speed = 2;\n                health = 100;\n                maxHealth = 100;\n                damage = 20;\n                size = gp.tilesize;\n                break;\n            case 1: // Fast\n                speed = 4;\n                health = 50;\n                maxHealth = 50;\n                damage = 10;\n                size = gp.tilesize;\n                break;\n            case 2: // Tank\n                speed = 1;\n                health = 200;\n                maxHealth = 200;\n                damage = 30;\n                size = gp.tilesize;\n                break;\n            case 3: // Crawler\n                speed = 3;\n                health = 80;\n                maxHealth = 80;\n                damage = 15;\n                size = gp.tilesize;\n                maxJumpHeight = 150; // Increased jump height\n                jumpSpeed = 8; // Increased jump speed\n                maxJumpCooldown = 60; // Reduced cooldown to 1 second\n                break;\n            case 4: // AsitTukurenZombi\n                speed = 2;\n                health = 120;\n                maxHealth = 120;\n                damage = 25;\n                size = gp.tilesize;\n                break;\n        }\n    }\n\n    public void update() {\n        if (health <= 0) {\n            active = false;\n            return;\n        }\n\n        // Update jumping state for crawler\n        if (type == 3) { // Crawler\n            if (jumpCooldown > 0) {\n                jumpCooldown--;\n            }\n            \n            if (isJumping) {\n                jumpHeight += jumpSpeed;\n                if (jumpHeight >= maxJumpHeight) {\n                    jumpHeight = maxJumpHeight;\n                    jumpSpeed = -jumpSpeed;\n                } else if (jumpHeight <= 0) {\n                    jumpHeight = 0;\n                    jumpSpeed = Math.abs(jumpSpeed);\n                    isJumping = false;\n                }\n            } else if (jumpCooldown == 0) {\n                // Check if player is in front of the crawler\n                int distanceToPlayer = Math.abs(worldX - gp.shooter.worldX);\n                if (distanceToPlayer < gp.tilesize * 3) { // Jump when player is within 3 tiles\n                    isJumping = true;\n                    jumpHeight = 0;\n                    jumpSpeed = Math.abs(jumpSpeed);\n                    jumpCooldown = maxJumpCooldown;\n                }\n            }\n        }\n\n        // Calculate distance to player\n        double dx = gp.shooter.worldX - worldX;\n        double dy = gp.shooter.worldY - worldY;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        // Move towards player\n        if (distance > 0) {\n            // Normalize direction vector\n            dx = dx / distance;\n            dy = dy / distance;\n\n            // Set direction based on movement\n            if (Math.abs(dx) > Math.abs(dy)) {\n                direction = dx > 0 ? \"right\" : \"left\";\n            } else {\n                direction = dy > 0 ? \"down\" : \"up\";\n            }\n\n            // Store original position\n            int originalX = worldX;\n            int originalY = worldY;\n\n            // Try moving horizontally first\n            worldX += (int)(dx * speed);\n            solid.x = worldX;\n            solid.y = worldY;\n            collisionOn = false;\n            gp.cc.checkTile(this);\n            if (collisionOn) {\n                worldX = originalX;\n                solid.x = worldX;\n            }\n\n            // Then try moving vertically\n            worldY += (int)(dy * speed);\n            solid.x = worldX;\n            solid.y = worldY;\n            collisionOn = false;\n            gp.cc.checkTile(this);\n            if (collisionOn) {\n                worldY = originalY;\n                solid.y = worldY;\n            }\n\n            // Update screen position relative to player\n            screenX = worldX - gp.shooter.worldX + gp.shooter.screenX;\n            screenY = worldY - gp.shooter.worldY + gp.shooter.screenY;\n        }\n\n        // Update animation\n        spriteCounter++;\n        if (spriteCounter > 12) {\n            if (spriteNum == 1) {\n                spriteNum = 2;\n            } else if (spriteNum == 2) {\n                spriteNum = 1;\n            }\n            spriteCounter = 0;\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        BufferedImage image = null;\n        switch(direction) {\n            case \"up\":\n                if(spriteNum == 1) image = up1;\n                if(spriteNum == 2) image = up2;\n                break;\n            case \"down\":\n                if(spriteNum == 1) image = down1;\n                if(spriteNum == 2) image = down2;\n                break;\n            case \"left\":\n                if(spriteNum == 1) image = left1;\n                if(spriteNum == 2) image = left2;\n                break;\n            case \"right\":\n                if(spriteNum == 1) image = right1;\n                if(spriteNum == 2) image = right2;\n                break;\n        }\n\n        int screenX = worldX - gp.shooter.worldX + gp.shooter.screenX;\n        int screenY = worldY - gp.shooter.worldY + gp.shooter.screenY;\n\n        if(worldX + size > gp.shooter.worldX - gp.shooter.screenX &&\n           worldX - size < gp.shooter.worldX + gp.shooter.screenX &&\n           worldY + size > gp.shooter.worldY - gp.shooter.screenY &&\n           worldY - size < gp.shooter.worldY + gp.shooter.screenY) {\n            \n            // Draw health bar first\n            int barWidth = gp.tilesize;\n            int barHeight = 6;\n            int barX = screenX;\n            int barY = screenY - 10;\n            \n            // Background of health bar\n            g2.setColor(Color.RED);\n            g2.fillRect(barX, barY, barWidth, barHeight);\n            \n            // Health amount\n            g2.setColor(Color.GREEN);\n            g2.fillRect(barX, barY, (int)(barWidth * ((double)health/maxHealth)), barHeight);\n            \n            // Border of health bar\n            g2.setColor(Color.BLACK);\n            g2.drawRect(barX, barY, barWidth, barHeight);\n            \n            if(image != null) {\n                if(type == 3) { // Crawler\n                    screenY += size/2; // Adjust for crawler's jump height\n                }\n                g2.drawImage(image, screenX, screenY, size, size, null);\n            } else {\n                // Different colors for different zombie types\n                if(this instanceof NormalZombi) {\n                    g2.setColor(Color.RED); // Red for Normal Zombie\n                } else if(this instanceof TankZombi) {\n                    g2.setColor(Color.BLUE); // Blue for Tank Zombie\n                } else if(this instanceof SurungeZombi) {\n                    g2.setColor(Color.GREEN); // Green for Surunge Zombie\n                } else if(this instanceof AsitTukurenZombi) {\n                    g2.setColor(Color.YELLOW); // Yellow for AsitTukuren Zombie\n                } else {\n                    g2.setColor(Color.MAGENTA); // Magenta for unknown types\n                }\n                g2.fillRect(screenX, screenY, size, size);\n            }\n        }\n    }\n\n    public void takeDamage(int damage) {\n        health -= damage;\n        if (health <= 0) {\n            health = 0;\n            active = false;\n        }\n    }\n}\n",
      "Roketatar.java": "public class Roketatar extends Weapon {\n    private static final int EXPLOSION_RADIUS = 100; // pixels\n\n    public Roketatar() {\n        super(100, 1, 0, 5); // damage, magazine size, total ammo, fire rate\n        this.reloadTime = 3000; // 3 seconds reload time\n    }\n\n    @Override\n    public boolean isRocket() {\n        return true;\n    }\n\n    @Override\n    public void shoot() {\n        if (currentAmmo > 0) {\n            currentAmmo--;\n            // Self damage will be handled in the GamePanel's checkBulletCollisions method\n        }\n    }\n\n    public int getExplosionRadius() {\n        return EXPLOSION_RADIUS;\n    }\n}\n",
      "AcidExplosion.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class AcidExplosion {\n    private GamePanel gp;\n    private int worldX;\n    private int worldY;\n    private int screenX;\n    private int screenY;\n    private int radius;\n    private int maxRadius;\n    private int damage;\n    private boolean active;\n    private int duration;\n    private int maxDuration;\n\n    public AcidExplosion(GamePanel gp, int worldX, int worldY, int damage) {\n        this.gp = gp;\n        this.worldX = worldX;\n        this.worldY = worldY;\n        this.damage = damage;\n        this.maxRadius = 100; // Maximum explosion radius\n        this.radius = 0;\n        this.active = true;\n        this.maxDuration = 60; // Duration in frames (1 second at 60 FPS)\n        this.duration = maxDuration;\n    }\n\n    public void update() {\n        if (!active) return;\n\n        // Increase radius over time\n        if (radius < maxRadius) {\n            radius += 2;\n        }\n\n        // Decrease duration\n        duration--;\n        if (duration <= 0) {\n            active = false;\n        }\n\n        // Update screen position\n        screenX = worldX - gp.shooter.worldX + gp.screenWidth / 2;\n        screenY = worldY - gp.shooter.worldY + gp.screenHeight / 2;\n\n        // Damage zombies within the explosion radius\n        for (int i = 0; i < gp.zombies.length; i++) {\n            Zombie zombie = gp.zombies[i];\n            if (zombie != null && zombie.health > 0) {\n                // Calculate distance from explosion center to zombie center\n                int zombieCenterX = zombie.worldX + gp.tilesize / 2;\n                int zombieCenterY = zombie.worldY + gp.tilesize / 2;\n                double distance = Math.sqrt(\n                    Math.pow(zombieCenterX - worldX, 2) +\n                    Math.pow(zombieCenterY - worldY, 2)\n                );\n\n                // If zombie is within explosion radius\n                if (distance <= radius) {\n                    // Calculate damage based on distance (more damage closer to explosion center)\n                    int explosionDamage = (int) (damage * (1 - distance / maxRadius));\n                    zombie.health -= explosionDamage;\n                    if (zombie.health <= 0) {\n                        zombie.health = 0;\n                        gp.zombies[i] = null;\n                        gp.zombiesAlive--;\n                        gp.currentScore += 10;\n\n                        // Update high score if necessary\n                        if (gp.currentScore > gp.highScore) {\n                            gp.highScore = gp.currentScore;\n                            gp.saveHighScore();\n                        }\n                    }\n                }\n            }\n        }\n\n        // Check for damage to player\n        int dx = gp.shooter.worldX - worldX;\n        int dy = gp.shooter.worldY - worldY;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance <= radius) {\n            // Apply damage based on distance (more damage closer to center)\n            int actualDamage = (int) (damage * (1 - distance / maxRadius));\n            gp.shooter.health -= actualDamage;\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        if (!active) return;\n\n        // Draw acid explosion effect\n        g2.setColor(new Color(0, 255, 0, (int) (255 * (duration / (double) maxDuration))));\n        g2.fillOval(screenX - radius, screenY - radius, radius * 2, radius * 2);\n\n        // Draw outer ring\n        g2.setColor(new Color(0, 200, 0, (int) (128 * (duration / (double) maxDuration))));\n        g2.drawOval(screenX - radius, screenY - radius, radius * 2, radius * 2);\n    }\n\n    public boolean isActive() {\n        return active;\n    }\n}",
      "Entity.java": "import java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Entity {\n    public int worldX,worldY;\n    public int velocity;\n    public int speed;\n\n    public BufferedImage up1,up2,down1,down2,left1,left2,right1,right2;\n    public String direction;\n\n    public int counter=0;\n    public int num=1;\n\n    public Rectangle solid;\n    public boolean collisionOn=false;\n\n    public Entity() {\n        // Initialize solid with default collision area\n        solid = new Rectangle(3, 18, 42, 30);\n        speed = 2; // Default speed\n        direction = \"down\"; // Initialize direction\n    }\n}\n",
      "Weapon.java": "public abstract class Weapon {\n    protected int damage;\n    protected int magazineSize;\n    protected int currentAmmo;\n    protected int totalAmmo;\n    protected boolean isReloading;\n    protected long lastShotTime;\n    protected int fireRate; // shots per second\n    protected long reloadStartTime;\n    protected int reloadTime; // reload time in milliseconds\n    protected boolean unlocked;\n\n    public Weapon(int damage, int magazineSize, int totalAmmo, int fireRate) {\n        this.damage = damage;\n        this.magazineSize = magazineSize;\n        this.currentAmmo = magazineSize;\n        this.totalAmmo = totalAmmo;\n        this.fireRate = fireRate;\n        this.isReloading = false;\n        this.lastShotTime = 0;\n        this.reloadStartTime = 0;\n        this.reloadTime = 2000; // Default 2 seconds reload time\n        this.unlocked = false;\n    }\n\n    public void shoot() {\n        if (canShoot()) {\n            currentAmmo--;\n            lastShotTime = System.currentTimeMillis();\n        }\n    }\n\n    public void reload() {\n        if (!isReloading && currentAmmo < magazineSize) {\n            isReloading = true;\n            reloadStartTime = System.currentTimeMillis();\n        }\n    }\n\n    public void update() {\n        // Update reloading state if needed\n        if (isReloading) {\n            long currentTime = System.currentTimeMillis();\n            if (currentTime - reloadStartTime >= reloadTime) {\n                // Calculate how many bullets we need to fill the magazine\n                int bulletsNeeded = magazineSize - currentAmmo;\n                \n                // If this is the pistol (index 0), always give full ammo\n                if (this instanceof Tabanca) {\n                    currentAmmo = magazineSize;\n                    totalAmmo = Integer.MAX_VALUE;\n                } else {\n                    // For other weapons, handle ammo normally\n                    if (totalAmmo >= bulletsNeeded) {\n                        totalAmmo -= bulletsNeeded;\n                        currentAmmo = magazineSize;\n                    } else {\n                        currentAmmo += totalAmmo;\n                        totalAmmo = 0;\n                    }\n                }\n                \n                isReloading = false;\n            }\n        }\n    }\n\n    public boolean canShoot() {\n        boolean canShoot = currentAmmo > 0 && !isReloading;\n        System.out.println(\"Can shoot: \" + canShoot + \" (ammo: \" + currentAmmo + \", reloading: \" + isReloading + \")\");\n        return canShoot;\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public int getCurrentAmmo() {\n        return currentAmmo;\n    }\n\n    public int getMagazineAmmo() {\n        return currentAmmo;\n    }\n\n    public int getMagazineSize() {\n        return magazineSize;\n    }\n\n    public int getTotalAmmo() {\n        return totalAmmo;\n    }\n\n    public boolean isReloading() {\n        return isReloading;\n    }\n\n    public abstract boolean isRocket();\n\n    public int getAmmo() {\n        return currentAmmo;\n    }\n    \n    public boolean isUnlocked() {\n        return unlocked;\n    }\n\n    public void setCurrentAmmo(int ammo) {\n        this.currentAmmo = ammo;\n    }\n\n    public void setTotalAmmo(int totalAmmo) {\n        this.totalAmmo = totalAmmo;\n    }\n}\n",
      "Bullet.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class Bullet {\n    GamePanel gp;\n    public int worldX;\n    public int worldY;\n    public int speed = 10;\n    public double angle;\n    public boolean active = true;\n    public int damage = 20;\n    public int size = 16;\n    public int range = 500; // Default range in pixels\n    public boolean isPiercing = false;\n\n    public Bullet(GamePanel gp, int worldX, int worldY, double angle) {\n        this(gp, worldX, worldY, angle, 20);\n    }\n\n    public Bullet(GamePanel gp, int worldX, int worldY, double angle, int damage) {\n        this.gp = gp;\n        this.worldX = worldX;\n        this.worldY = worldY;\n        this.angle = angle;\n        this.damage = damage;\n    }\n\n    public Bullet(GamePanel gp, int worldX, int worldY, double angle, int damage, boolean isPiercing) {\n        this.gp = gp;\n        this.worldX = worldX;\n        this.worldY = worldY;\n        this.angle = angle;\n        this.damage = damage;\n        this.isPiercing = isPiercing;\n    }\n\n    public void update() {\n        // Move bullet\n        worldX += Math.cos(angle) * speed;\n        worldY += Math.sin(angle) * speed;\n\n        // Check if bullet is out of bounds\n        if (worldX < 0 || worldX > gp.worldWidth || \n            worldY < 0 || worldY > gp.worldHeight) {\n            active = false;\n            return;\n        }\n\n        // Check for collisions with zombies\n        for (int i = 0; i < gp.zombies.length; i++) {\n            Zombie zombie = gp.zombies[i];\n            if (zombie != null && zombie.health > 0) {\n                if (checkCollision(zombie)) {\n                    zombie.health -= damage;\n                    if (zombie.health <= 0) {\n                        zombie.health = 0;\n                        gp.zombies[i] = null;\n                        gp.zombiesAlive--;\n                        gp.currentScore += 10;\n                    }\n                    if (!isPiercing) {\n                        active = false;\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    public boolean checkCollision(Zombie zombie) {\n        // Calculate bullet's center position\n        int bulletCenterX = worldX + size/2;\n        int bulletCenterY = worldY + size/2;\n        \n        // Calculate zombie's center position using its actual position and size\n        int zombieCenterX = zombie.worldX + gp.tilesize/2;\n        int zombieCenterY = zombie.worldY + gp.tilesize/2;\n        \n        // Calculate distance between centers\n        double dx = bulletCenterX - zombieCenterX;\n        double dy = bulletCenterY - zombieCenterY;\n        \n        // Check for collision using the sum of half-widths and half-heights\n        double minDistanceX = (size/2 + gp.tilesize/2);\n        double minDistanceY = (size/2 + gp.tilesize/2);\n        \n        // If the distance is less than the minimum distance in both X and Y, they collide\n        return Math.abs(dx) < minDistanceX && Math.abs(dy) < minDistanceY;\n    }\n\n    public void draw(Graphics2D g2) {\n        // Convert world coordinates to screen coordinates\n        int screenX = worldX - gp.shooter.worldX + gp.screenWidth/2;\n        int screenY = worldY - gp.shooter.worldY + gp.screenHeight/2;\n        \n        // Draw bullet trail\n        g2.setColor(new Color(255, 255, 0, 100));\n        g2.fillOval(screenX - size/2, screenY - size/2, size, size);\n        \n        // Draw bullet\n        g2.setColor(Color.YELLOW);\n        g2.fillOval(screenX - size/3, screenY - size/3, size*2/3, size*2/3);\n        g2.setColor(Color.WHITE);\n        g2.drawOval(screenX - size/3, screenY - size/3, size*2/3, size*2/3);\n    }\n} ",
      "Tile.java": "\nimport java.awt.image.BufferedImage;\n\npublic class Tile {\n    public BufferedImage image;\n    public boolean collision=false;\n\n}\n",
      "SniperBullet.java": "public class SniperBullet extends Bullet {\n    public SniperBullet(GamePanel gp, int worldX, int worldY, double angle) {\n        super(gp, worldX, worldY, angle);\n        damage = 50; // Changed from 100 to 50\n        speed = 15; // Faster than normal bullets\n        size = 4; // Smaller than normal bullets\n        isPiercing = true; // Can pierce through zombies\n    }\n\n    \n    public void checkZombieCollisions() {\n        for (int i = 0; i < gp.zombies.length; i++) {\n            Zombie zombie = gp.zombies[i];\n            if (zombie != null && zombie.health > 0) {\n                if (checkCollision(zombie)) {\n                    zombie.health -= damage;\n                    if (zombie.health <= 0) {\n                        zombie.health = 0;  // Ensure health doesn't go negative\n                    }\n                    // Sniper bullets don't disappear after hitting zombies\n                    // They continue until they hit a wall or reach their range\n                }\n            }\n        }\n    }\n} ",
      "AcidProjectile.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class AcidProjectile {\n    GamePanel gp;\n    public int worldX, startX;\n    public int worldY, startY;\n    public int velocity = 7;\n    public double angle;\n    public boolean active = true;\n    public int damage = 2;\n    public int range = 400;\n    public int size = 16; // Size of the projectile\n\n    public AcidProjectile(GamePanel gp, int worldX, int worldY, double angle) {\n        this.gp = gp;\n        this.worldX = worldX;\n        this.worldY = worldY;\n        this.startX = worldX;\n        this.startY = worldY;\n        this.angle = angle;\n    }\n\n    public void update() {\n        // Move projectile in the direction of the angle\n        worldX += Math.cos(angle) * velocity;\n        worldY += Math.sin(angle) * velocity;\n\n        // Check collision with player using simple position check\n        int playerCenterX = gp.shooter.worldX + gp.tilesize/2;\n        int playerCenterY = gp.shooter.worldY + gp.tilesize/2;\n        int projectileCenterX = worldX + size/2;\n        int projectileCenterY = worldY + size/2;\n\n        // Calculate distance between centers\n        double distance = Math.sqrt(\n            Math.pow(projectileCenterX - playerCenterX, 2) + \n            Math.pow(projectileCenterY - playerCenterY, 2)\n        );\n\n        // If distance is less than half the sum of sizes, they collide\n        if (distance < (gp.tilesize/2 + size/2)) {\n            gp.shooter.health -= damage;\n            active = false;\n            return;\n        }\n\n        // Check if projectile has exceeded its range\n        double distanceFromStart = Math.sqrt(Math.pow(worldX - startX, 2) + Math.pow(worldY - startY, 2));\n        if (distanceFromStart > range) {\n            active = false;\n            return;\n        }\n\n        // Check if projectile is out of bounds\n        if (worldX < 0 || worldX > gp.worldWidth || \n            worldY < 0 || worldY > gp.worldHeight) {\n            active = false;\n        }\n\n        // Check for collisions with walls\n        int col = (int)(worldX / gp.tilesize);\n        int row = (int)(worldY / gp.tilesize);\n        \n        // Make sure we're within map bounds\n        if (col >= 0 && col < gp.worldColumn && row >= 0 && row < gp.worldRow) {\n            if (gp.tm.tile[gp.tm.map[col][row]].collision) {\n                active = false;\n                return;\n            }\n        }\n    }\n\n    public void draw(Graphics2D g2d) {\n        int screenX = worldX - gp.shooter.worldX + gp.shooter.screenX;\n        int screenY = worldY - gp.shooter.worldY + gp.shooter.screenY;\n        \n        // Draw acid projectile as a green blob with trail\n        g2d.setColor(new Color(0, 255, 0, 100)); // Semi-transparent green trail\n        g2d.fillRect(screenX - 4, screenY - 4, 24, 24);\n        \n        g2d.setColor(Color.GREEN); // Solid green projectile\n        g2d.fillRect(screenX, screenY, size, size);\n    }\n} ",
      "PiyadeTufegi.java": "public class PiyadeTufegi extends Weapon {\n    public PiyadeTufegi() {\n        super(15, 30, 0, 20); // damage, magazine size, total ammo, fire rate\n        this.reloadTime = 1500; // 1.5 seconds reload time\n    }\n\n    @Override\n    public void shoot() {\n        if (currentAmmo > 0) {\n            currentAmmo--;\n        }\n    }\n\n    @Override\n    public boolean isRocket() {\n        return false;\n    }\n}\n",
      "GamePanel.java": "import java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.util.ArrayList;\nimport javax.swing.JPanel;\n\npublic class GamePanel extends JPanel implements Runnable {\n   \n    public int originalTilesize = 16;\n    public int scale = 3;\n    public int tilesize = originalTilesize * scale;\n    public int maxScreenCol=16;\n    public int maxScreenRow=12;\n    public int screenHeight=tilesize*maxScreenRow;\n    public int screenWidth=tilesize*maxScreenCol;\n    public int worldColumn=50;\n    public int worldRow=50;\n    public int worldHeight=tilesize*worldRow;\n    public int worldWidth=tilesize*worldColumn;\n\n\n    public KeyHandler keyHandler = new KeyHandler(this);\n    public MouseHandler mouseHandler = new MouseHandler(this);\n    public UI ui = new UI(this);\n    public CollisionChecker cc = new CollisionChecker(this);\n\n\n    public Thread gameThread;\n\n    public Shooter shooter=new Shooter(this, keyHandler);\n   public  Zombie[] zombies=new Zombie[20];\n   ZombieSetter zs=new ZombieSetter(this);\n    public int gameState;\n    public int titleState=0;\n    public int playState=1;\n    public int pauseState=2;\n    public int gameOverState=3;\n\n    // Wave tracking variables\n    public int currentWave = 1;\n    public boolean waveInProgress = false;\n    public int zombiesAlive = 0;\n    \n    // Score tracking\n    public int currentScore = 0;\n    public int highScore = 0;\n    public int score = 0;\n\n   public  TileManager tm = new TileManager(this);\n\n    int shooterX=100;\n    int shooterY=100;\n    int shooterVelocity=6;\n\n    int fps=60;\n    int maxWorldRow;\n\n    public ArrayList<Chest> chests = new ArrayList<>();\n    private int zombiesKilledSinceLastChest = 0;\n    public ArrayList<AcidExplosion> acidExplosions = new ArrayList<>();\n\n    // Add these variables at the class level\n    private int lastZombieX = 0;\n    private int lastZombieY = 0;\n    private boolean lastZombieKilled = false;\n\n    // Add at class level\n    private int damageCooldown = 0;\n    private static final int DAMAGE_COOLDOWN_TIME = 30; // Half a second at 60 FPS\n\n    private boolean isLoadingGame = false;\n\n    public GamePanel(){\n        this.setPreferredSize(new Dimension(screenWidth, screenHeight));\n        this.setBackground(Color.BLACK);\n        this.setDoubleBuffered(true);\n        this.addKeyListener(keyHandler);\n        this.addMouseListener(mouseHandler);\n        this.addMouseMotionListener(mouseHandler);\n\n        setFocusable(true);\n\n        // Load high score at startup\n        loadHighScore();\n        \n        this.setUpGame();\n    } \n    public void setUpGame(){\n        // Initialize game state to title screen\n        gameState = titleState;\n        currentWave = 1;\n        waveInProgress = false;\n        zombiesAlive = 0;\n        currentScore = 0;\n        \n        // Reset player position\n        shooter.worldX = 23 * tilesize - tilesize/2;\n        shooter.worldY = 23 * tilesize - tilesize/2;\n        shooter.health = 100;\n        shooter.bullets.clear();\n        shooter.resetWeapons();\n        \n        // Clear all zombies\n        for(int i = 0; i < zombies.length; i++) {\n            zombies[i] = null;\n        }\n    }\n\n    public void startGame() {\n        // Reset game state\n        gameState = playState;\n        currentWave = 1;  // Start with wave 1\n        waveInProgress = false;  // Don't set wave in progress until zombies are spawned\n        zombiesAlive = 0;\n        currentScore = 0; // Reset current score\n        \n        // Reset player\n        shooter.health = 100;\n        shooter.worldX = 23 * tilesize - tilesize/2;\n        shooter.worldY = 23 * tilesize - tilesize/2;\n        shooter.bullets.clear(); // Clear all bullets\n        \n        // Unlock all weapons but give them no ammo\n        shooter.unlockWeapon(0); // Tabanca (Pistol)\n        shooter.unlockWeapon(1); // PiyadeTufegi\n        shooter.unlockWeapon(2); // PompaliTufek\n        shooter.unlockWeapon(3); // KeskinNisanciTufegi\n        shooter.unlockWeapon(4); // Roketatar\n        \n        // Set all weapons to have 0 ammo\n        shooter.setWeaponAmmo(0, 12); // Tabanca (Pistol)\n        shooter.setWeaponTotalAmmo(0, Integer.MAX_VALUE); // Infinite ammo for pistol\n        shooter.setWeaponAmmo(1, 0); // PiyadeTufegi\n        shooter.setWeaponAmmo(2, 0); // PompaliTufek\n        shooter.setWeaponAmmo(3, 0); // KeskinNisanciTufegi\n        shooter.setWeaponAmmo(4, 0); // Roketatar\n        \n        // Clear all zombies\n        for(int i = 0; i < zombies.length; i++) {\n            zombies[i] = null;\n        }\n        \n        // Clear all chests\n        chests.clear();\n        \n        // Start the first wave\n        zs.startFirstWave();\n        \n        // Ensure game thread is running\n        if (gameThread == null || !gameThread.isAlive()) {\n            startGameThread();\n        }\n    }\n\n    public void startGameThread(){\n        System.out.println(\"Starting game thread...\");\n        if (gameThread != null && gameThread.isAlive()) {\n            return; // Thread is already running\n        }\n        gameThread = new Thread(this);\n        gameThread.start();\n        \n        // Initialize game state to title screen if not already set\n        if (gameState != playState) {\n            gameState = titleState;\n            currentWave = 1;\n            waveInProgress = false;\n            zombiesAlive = 0;\n        }\n    }\n    @Override\n    public void run() {\n        double drawInterval = 1000000000/fps;\n        double nextDrawTime = System.nanoTime()+drawInterval;\n\n        while(gameThread!=null){\n            update();\n            repaint();\n\n            try {\n                double remainingTime = nextDrawTime-System.nanoTime();\n                remainingTime=remainingTime/1000000;\n\n                if(remainingTime<0){\n                    remainingTime=0;\n                }\n                Thread.sleep((long)remainingTime);\n                nextDrawTime+=drawInterval;\n\n            } catch (InterruptedException e) {\n                // Handle interruption gracefully\n                Thread.currentThread().interrupt();\n                break;\n            } catch (Exception e) {\n                e.printStackTrace();\n                break;\n            }\n        }\n    }\n\n    public void update() {\n        if (gameState == playState) {\n            // Update damage cooldown\n            if (damageCooldown > 0) {\n                damageCooldown--;\n            }\n            \n            // Update player\n            shooter.update();\n            \n            // Update bullets\n            for (int i = shooter.bullets.size() - 1; i >= 0; i--) {\n                Bullet bullet = shooter.bullets.get(i);\n                if (bullet != null) {\n                    bullet.update();\n                    if (!bullet.active) {\n                        shooter.bullets.remove(i);\n                    }\n                }\n            }\n            \n            // Update zombies\n            for (int i = zombies.length - 1; i >= 0; i--) {\n                Zombie zombie = zombies[i];\n                if (zombie != null) {\n                    zombie.update();\n                    \n                    // Check collision with player\n                    if (damageCooldown == 0 && shooter.getBounds().intersects(zombie.solid)) {\n                        int damage = 2; // Default damage for normal zombies\n                        if (zombie.getClass().getSimpleName().equals(\"SurungeZombie\")) damage = 5;\n                        else if (zombie.getClass().getSimpleName().equals(\"TankZombie\")) damage = 10;\n                        else if (zombie.getClass().getSimpleName().equals(\"AcidZombie\")) damage = 15;\n                        \n                        shooter.health -= damage;\n                        damageCooldown = DAMAGE_COOLDOWN_TIME;\n                        \n                        if (shooter.health <= 0) {\n                            // Check if current score is higher than high score\n                            if (currentScore > highScore) {\n                                highScore = currentScore;\n                                saveHighScore(); // Save the updated high score\n                            }\n                            gameState = gameOverState;\n                        }\n                    }\n                }\n            }\n            \n            // Check if wave is complete\n            if (zombiesAlive == 0 && waveInProgress && !isLoadingGame) {\n                currentWave++;\n                waveInProgress = false;\n                \n                // Spawn chest at last zombie's position\n                if (lastZombieX != 0 && lastZombieY != 0) {\n                    Chest chest = new Chest(this, lastZombieX, lastZombieY);\n                    chests.add(chest);\n                    ui.showMessage(\"A chest has appeared!\");\n                } else {\n                    // If no last zombie position, spawn near player\n                    Chest chest = new Chest(this, shooter.worldX + 100, shooter.worldY + 100);\n                    chests.add(chest);\n                    ui.showMessage(\"A chest has appeared!\");\n                }\n                \n                // Start next wave after delay\n                new java.util.Timer().schedule(new java.util.TimerTask() {\n                    @Override\n                    public void run() {\n                        zs.startNextWave();\n                    }\n                }, 3000);\n            }\n            \n            // Update chests\n            for (int i = chests.size() - 1; i >= 0; i--) {\n                Chest chest = chests.get(i);\n                chest.update();\n            }\n        }\n    }\n\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2d = (Graphics2D) g;\n        \n        if (gameState == titleState) {\n            ui.draw(g2d);\n        }\n        else if (gameState == playState) {\n            // Draw map\n            tm.draw(g2d);\n            \n            // Draw zombies\n            for (Zombie zombie : zombies) {\n                if (zombie != null) {\n                    zombie.draw(g2d);\n                }\n            }\n            \n            // Draw chests\n            for (Chest chest : chests) {\n                chest.draw(g2d);\n            }\n            \n            // Draw bullets\n            for (Bullet bullet : shooter.bullets) {\n                if (bullet != null) {\n                    bullet.draw(g2d);\n                }\n            }\n            \n            // Draw player last (so it appears on top)\n            shooter.draw(g2d);\n            \n            // Draw UI\n            ui.draw(g2d);\n        }\n        else if (gameState == pauseState) {\n            ui.draw(g2d);\n        }\n        else if (gameState == gameOverState) {\n            ui.draw(g2d);\n        }\n    }\n\n    private void spawnChest(int x, int y) {\n        chests.add(new Chest(this, x, y));\n    }\n\n    public void saveGame() {\n        try {\n            java.io.FileWriter writer = new java.io.FileWriter(\"SavedGame.txt\");\n            \n            // Save player position and health\n            writer.write(\"PlayerX:\" + shooter.worldX + \"\\n\");\n            writer.write(\"PlayerY:\" + shooter.worldY + \"\\n\");\n            writer.write(\"PlayerHealth:\" + shooter.health + \"\\n\");\n            \n            // Save game progress\n            writer.write(\"CurrentWave:\" + currentWave + \"\\n\");\n            writer.write(\"CurrentScore:\" + currentScore + \"\\n\");\n            \n            // Save weapon states\n            boolean[] unlockedWeapons = shooter.getUnlockedWeapons();\n            for (int i = 0; i < unlockedWeapons.length; i++) {\n                writer.write(\"Weapon\" + i + \":\" + unlockedWeapons[i] + \"\\n\");\n            }\n            \n            // Save weapon ammo (both current and total)\n            Weapon[] weapons = shooter.getWeapons();\n            for (int i = 0; i < weapons.length; i++) {\n                writer.write(\"Weapon\" + i + \"CurrentAmmo:\" + weapons[i].getCurrentAmmo() + \"\\n\");\n                writer.write(\"Weapon\" + i + \"TotalAmmo:\" + weapons[i].getTotalAmmo() + \"\\n\");\n            }\n            \n            writer.close();\n            ui.showMessage(\"Game Saved!\");\n        } catch (Exception e) {\n            System.out.println(\"Error saving game: \" + e.getMessage());\n            ui.showMessage(\"Failed to save game!\");\n        }\n    }\n\n    public void loadGame() {\n        try {\n            isLoadingGame = true;\n            java.io.FileReader reader = new java.io.FileReader(\"SavedGame.txt\");\n            java.io.BufferedReader bufferedReader = new java.io.BufferedReader(reader);\n            String line;\n            \n            while ((line = bufferedReader.readLine()) != null) {\n                String[] parts = line.split(\":\");\n                if (parts.length != 2) continue;\n                \n                String key = parts[0];\n                String value = parts[1];\n                \n                switch (key) {\n                    case \"PlayerX\":\n                        shooter.worldX = Integer.parseInt(value);\n                        break;\n                    case \"PlayerY\":\n                        shooter.worldY = Integer.parseInt(value);\n                        break;\n                    case \"PlayerHealth\":\n                        shooter.health = Integer.parseInt(value);\n                        break;\n                    case \"CurrentWave\":\n                        currentWave = Integer.parseInt(value);\n                        break;\n                    case \"CurrentScore\":\n                        currentScore = Integer.parseInt(value);\n                        break;\n                    default:\n                        if (key.startsWith(\"Weapon\")) {\n                            // Extract weapon index from the key\n                            String indexStr = key.substring(6); // Remove \"Weapon\" prefix\n                            int weaponIndex;\n                            \n                            if (indexStr.endsWith(\"CurrentAmmo\")) {\n                                weaponIndex = Integer.parseInt(indexStr.substring(0, indexStr.indexOf(\"CurrentAmmo\")));\n                                int currentAmmo = Integer.parseInt(value);\n                                shooter.setWeaponAmmo(weaponIndex, currentAmmo);\n                            } else if (indexStr.endsWith(\"TotalAmmo\")) {\n                                weaponIndex = Integer.parseInt(indexStr.substring(0, indexStr.indexOf(\"TotalAmmo\")));\n                                int totalAmmo = Integer.parseInt(value);\n                                shooter.setWeaponTotalAmmo(weaponIndex, totalAmmo);\n                            } else {\n                                weaponIndex = Integer.parseInt(indexStr);\n                                boolean unlocked = Boolean.parseBoolean(value);\n                                shooter.setUnlockedWeapon(weaponIndex, unlocked);\n                            }\n                        }\n                        break;\n                }\n            }\n            \n            bufferedReader.close();\n            reader.close();\n            \n            // Reset game state to play state\n            gameState = playState;\n            waveInProgress = true;\n            \n            // Start the current wave\n            zs.startWave(currentWave);\n            \n            ui.showMessage(\"Game Loaded!\");\n            isLoadingGame = false;\n        } catch (Exception e) {\n            System.out.println(\"Error loading game: \" + e.getMessage());\n            ui.showMessage(\"Failed to load game!\");\n            isLoadingGame = false;\n        }\n    }\n\n    public void loadHighScore() {\n        try {\n            File file = new File(\"HighScore.txt\");\n            if (file.exists()) {\n                BufferedReader reader = new BufferedReader(new FileReader(file));\n                String line = reader.readLine();\n                if (line != null) {\n                    highScore = Integer.parseInt(line.trim());\n                }\n                reader.close();\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error loading high score: \" + e.getMessage());\n        }\n    }\n\n    public void saveHighScore() {\n        try {\n            File file = new File(\"HighScore.txt\");\n            BufferedWriter writer = new BufferedWriter(new FileWriter(file));\n            writer.write(String.valueOf(highScore));\n            writer.close();\n        } catch (Exception e) {\n            System.out.println(\"Error saving high score: \" + e.getMessage());\n        }\n    }\n}\n\n",
      "UI.java": "import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.text.DecimalFormat;\n\npublic class UI {\n    GamePanel gp;\n\n    Font arial_40,arial_80B;\n    Graphics2D g2d;\n    public boolean messageOn=false;\n    public String message=\"\";\n    int messageCounter=0;\n    public boolean gameFinished=false;\n    public int commandNum=0;\n    public String currentDialogue = \"\";\n\n    double playTime;\n    DecimalFormat dFormat =new DecimalFormat(\"#0.00\");\n\n    public UI(GamePanel gp){\n        this.gp=gp;\n        arial_40=new Font(\"Arial\",Font.PLAIN,40);\n        arial_80B=new Font(\"Arial\",Font.BOLD,80); \n    }\n\n    public void showMessage(String text){\n        message=text;\n        messageOn=true;\n        messageCounter = 0;\n    }\n    public void draw(Graphics2D g2) {\n        if (gp.gameState == gp.titleState) {\n            drawTitleScreen(g2);\n        } else if (gp.gameState == gp.playState) {\n            // Draw weapon info in top left\n            g2.setColor(Color.WHITE);\n            g2.setFont(new Font(\"Arial\", Font.BOLD, 20));\n            \n            // Get current weapon name\n            String weaponName = \"Tabanca\";\n            if (gp.shooter.getCurrentWeapon() instanceof PiyadeTufegi) weaponName = \"Piyade Tufegi\";\n            else if (gp.shooter.getCurrentWeapon() instanceof PompaliTufek) weaponName = \"Pompali Tufek\";\n            else if (gp.shooter.getCurrentWeapon() instanceof KeskinNisanciTufegi) weaponName = \"Keskin Nisanci Tufegi\";\n            else if (gp.shooter.getCurrentWeapon() instanceof Roketatar) weaponName = \"Roketatar\";\n            \n            // Draw weapon name and ammo\n            g2.drawString(\"Silah: \" + weaponName, 10, 30);\n            \n            // Special display for pistol (infinite ammo)\n            if (gp.shooter.getCurrentWeapon() instanceof Tabanca) {\n                g2.drawString(\"Mermi: \" + gp.shooter.getCurrentWeapon().getMagazineAmmo() + \"/∞\", 10, 60);\n            } else {\n                g2.drawString(\"Mermi: \" + gp.shooter.getCurrentWeapon().getMagazineAmmo() + \"/\" + gp.shooter.getCurrentWeapon().getTotalAmmo(), 10, 60);\n            }\n            \n            // Draw health and score in top right\n            g2.setColor(Color.RED);\n            g2.drawString(\"Can: \" + gp.shooter.health, gp.screenWidth - 150, 30);\n            g2.setColor(Color.YELLOW);\n            g2.drawString(\"Puan: \" + gp.currentScore, gp.screenWidth - 150, 60);\n            g2.setColor(Color.GREEN);\n            g2.drawString(\"Rekor: \" + gp.highScore, gp.screenWidth - 150, 90);\n            \n            // Draw wave info and zombies alive\n            g2.setColor(Color.GREEN);\n            g2.drawString(\"Dalga: \" + gp.currentWave, gp.screenWidth - 150, 120);\n            g2.setColor(Color.RED);\n            g2.drawString(\"Zombi: \" + gp.zombiesAlive, gp.screenWidth - 150, 150);\n            \n            // Draw weapon info\n            g2.setColor(Color.WHITE);\n            g2.setFont(new Font(\"Arial\", Font.BOLD, 16));\n            g2.drawString(\"Silahlar:\", 20, 130);\n            \n            // Draw each weapon's status\n            int y = 160;\n            for (int i = 0; i < gp.shooter.getWeapons().length; i++) {\n                Weapon weapon = gp.shooter.getWeapons()[i];\n                if (weapon != null) {\n                    String name = \"Tabanca\";\n                    if (weapon instanceof PiyadeTufegi) name = \"Piyade Tufegi\";\n                    else if (weapon instanceof PompaliTufek) name = \"Pompali Tufek\";\n                    else if (weapon instanceof KeskinNisanciTufegi) name = \"Keskin Nisanci Tufegi\";\n                    else if (weapon instanceof Roketatar) name = \"Roketatar\";\n                    \n                    // Special display for pistol (infinite ammo)\n                    String ammo;\n                    if (weapon instanceof Tabanca) {\n                        ammo = \"Mermi: \" + weapon.getMagazineAmmo() + \"/∞\";\n                    } else {\n                        ammo = \"Mermi: \" + weapon.getMagazineAmmo() + \"/\" + weapon.getTotalAmmo();\n                    }\n                    \n                    // Highlight current weapon\n                    if (weapon == gp.shooter.getCurrentWeapon()) {\n                        g2.setColor(Color.YELLOW);\n                    } else {\n                        g2.setColor(Color.WHITE);\n                    }\n                    \n                    g2.drawString(name, 20, y);\n                    g2.drawString(ammo, 20, y + 40);\n                    y += 70;\n                }\n            }\n        } else if (gp.gameState == gp.pauseState) {\n            drawPauseScreen(g2);\n        } else if (gp.gameState == gp.gameOverState) {\n            drawGameOverScreen(g2);\n        }\n    }\n\n    public void drawPauseScreen(Graphics2D g2) {\n        g2.setColor(new Color(0, 0, 0, 128));\n        g2.fillRect(0, 0, gp.screenWidth, gp.screenHeight);\n\n        g2.setFont(arial_80B);\n        String text = \"PAUSED\";\n        int x = getXforCenteredText(text, g2);\n        int y = gp.screenHeight/2;\n        g2.setColor(Color.white);\n        g2.drawString(text, x, y);\n        \n        // Add wave number\n        text = \"Wave: \" + gp.currentWave;\n        g2.setFont(g2.getFont().deriveFont(Font.PLAIN, 40F));\n        x = getXforCenteredText(text, g2);\n        y += 60;\n        g2.drawString(text, x, y);\n        \n        // Add menu options\n        g2.setFont(g2.getFont().deriveFont(Font.PLAIN, 30F));\n        text = \"Save Game\";\n        x = getXforCenteredText(text, g2);\n        y += 60;\n        g2.drawString(text, x, y);\n        if(commandNum == 0) {\n            g2.drawString(\">\", x-gp.tilesize, y);\n        }\n        \n        text = \"Continue\";\n        x = getXforCenteredText(text, g2);\n        y += 40;\n        g2.drawString(text, x, y);\n        if(commandNum == 1) {\n            g2.drawString(\">\", x-gp.tilesize, y);\n        }\n    }\n    public void drawTitleScreen(Graphics2D g2) {\n        // Draw background\n        g2.setColor(Color.BLACK);\n        g2.fillRect(0, 0, gp.screenWidth, gp.screenHeight);\n        \n        // Draw title\n        g2.setFont(arial_80B);\n        String text = \"Top Down\";\n        String txt = \"Shooter\";\n        int x = getXforCenteredText(text, g2);\n        int y = gp.tilesize*3;\n        g2.setColor(Color.white);\n        g2.drawString(text, x, y);\n        g2.drawString(txt, x+40, y+80);\n\n        // Draw menu options\n        g2.setFont(g2.getFont().deriveFont(Font.BOLD, 48F));\n        text = \"New Game\";\n        x = getXforCenteredText(text, g2);\n        y += gp.tilesize*5;\n        g2.drawString(text, x, y);\n        if(commandNum == 0) {\n            g2.drawString(\">\", x-gp.tilesize, y);\n        }\n\n        text = \"Load Game\";\n        x = getXforCenteredText(text, g2);\n        y += gp.tilesize*1.2;\n        g2.drawString(text, x, y);\n        if(commandNum == 1) {\n            g2.drawString(\">\", x-gp.tilesize, y);\n        }\n\n        text = \"Quit\";\n        x = getXforCenteredText(text, g2);\n        y += gp.tilesize*1.2;\n        g2.drawString(text, x, y);\n        if(commandNum == 2) {\n            g2.drawString(\">\", x-gp.tilesize, y);\n        }\n    }\n    public int getXforCenter(String text){\n         int length=(int)g2d.getFontMetrics().getStringBounds(text, g2d).getWidth();\n       int  x=gp.screenWidth/2-length/2;\n        return x;\n    }\n\n    public void drawPlayerHealth() {\n        // Draw health\n        String healthText = \"Health: \" + gp.shooter.health;\n        g2d.setFont(g2d.getFont().deriveFont(Font.PLAIN, 24F));\n        int textWidth = g2d.getFontMetrics().stringWidth(healthText);\n        int x = gp.screenWidth - textWidth - gp.tilesize/2;\n        int y = gp.tilesize/2;\n        \n        g2d.setColor(Color.black);\n        g2d.drawString(healthText, x, y);\n\n        // Draw weapon and ammo info\n        Weapon currentWeapon = gp.shooter.getCurrentWeapon();\n        String weaponName = \"\";\n        switch(gp.shooter.getCurrentWeaponIndex()) {\n            case 0: weaponName = \"Pistol\"; break;\n            case 1: weaponName = \"Rifle\"; break;\n            case 2: weaponName = \"Shotgun\"; break;\n            case 3: weaponName = \"Sniper\"; break;\n            case 4: weaponName = \"Rocket\"; break;\n        }\n        \n        String ammoText = weaponName + \": \" + currentWeapon.getCurrentAmmo() + \"/\" + currentWeapon.getMagazineSize();\n        if(currentWeapon.isReloading()) {\n            ammoText += \" (Reloading...)\";\n        }\n        \n        textWidth = g2d.getFontMetrics().stringWidth(ammoText);\n        x = gp.screenWidth - textWidth - gp.tilesize/2;\n        y = gp.tilesize*2;\n        \n        g2d.setColor(Color.black);\n        g2d.drawString(ammoText, x, y);\n    }\n\n    public void drawWaveInfo() {\n        int x = gp.tilesize/2;\n        int y = gp.tilesize*2;\n        g2d.setFont(arial_40);\n        g2d.setColor(Color.white);\n        g2d.drawString(\"Wave: \" + gp.currentWave, x, y);\n    }\n\n    public void drawMessage() {\n        if (messageOn) {\n            g2d.setFont(g2d.getFont().deriveFont(30F));\n            g2d.setColor(Color.white);\n            int x = gp.tilesize/2;\n            int y = gp.tilesize*3;\n            g2d.drawString(message, x, y);\n            messageCounter++;\n            if (messageCounter > 180) {\n                messageOn = false;\n                messageCounter = 0;\n            }\n        }\n    }\n\n    public void drawGameOverScreen(Graphics2D g2) {\n        // Draw semi-transparent black background\n        g2.setColor(new Color(0, 0, 0, 180));\n        g2.fillRect(0, 0, gp.screenWidth, gp.screenHeight);\n        \n        // Draw game over text\n        g2.setColor(Color.RED);\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 48));\n        String gameOverText = \"GAME OVER\";\n        int gameOverX = gp.screenWidth/2 - 100;\n        int gameOverY = gp.screenHeight/2 - 50;\n        g2.drawString(gameOverText, gameOverX, gameOverY);\n        \n        // Draw score\n        g2.setColor(Color.WHITE);\n        g2.setFont(new Font(\"Arial\", Font.BOLD, 24));\n        String scoreText = \"Score: \" + gp.currentScore;\n        int scoreX = gp.screenWidth/2 - 50;\n        int scoreY = gp.screenHeight/2 + 20;\n        g2.drawString(scoreText, scoreX, scoreY);\n        \n        // Draw restart instructions\n        g2.setFont(new Font(\"Arial\", Font.PLAIN, 20));\n        String restartText = \"Press SPACE to restart\";\n        int restartX = gp.screenWidth/2 - 80;\n        int restartY = gp.screenHeight/2 + 60;\n        g2.drawString(restartText, restartX, restartY);\n    }\n\n    public int getXforCenteredText(String text, Graphics2D g2) {\n        int length = (int)g2.getFontMetrics().getStringBounds(text, g2).getWidth();\n        int x = gp.screenWidth/2 - length/2;\n        return x;\n    }\n\n    public void drawPlayScreen() {\n        // Draw weapon and ammo info in top left corner\n        g2d.setColor(Color.WHITE);\n        g2d.setFont(new Font(\"Arial\", Font.BOLD, 20));\n        \n        // Get current weapon info\n        Weapon currentWeapon = gp.shooter.getCurrentWeapon();\n        String weaponName = \"No Weapon\";\n        if (currentWeapon != null) {\n            if (currentWeapon instanceof Tabanca) weaponName = \"Tabanca\";\n            else if (currentWeapon instanceof PiyadeTufegi) weaponName = \"Piyade Tufegi\";\n            else if (currentWeapon instanceof PompaliTufek) weaponName = \"Pompali Tufek\";\n            else if (currentWeapon instanceof KeskinNisanciTufegi) weaponName = \"Keskin Nisanci Tufegi\";\n            else if (currentWeapon instanceof Roketatar) weaponName = \"Roketatar\";\n        }\n        int ammoCount = currentWeapon != null ? currentWeapon.getCurrentAmmo() : 0;\n        int totalAmmo = currentWeapon != null ? currentWeapon.getTotalAmmo() : 0;\n        \n        // Draw weapon name and ammo count\n        g2d.drawString(\"Weapon: \" + weaponName, 10, 30);\n        g2d.drawString(\"Ammo: \" + ammoCount + \"/\" + totalAmmo, 10, 60);\n        \n        // Draw health bar\n        g2d.setColor(Color.RED);\n        g2d.fillRect(10, 80, 200, 20);\n        g2d.setColor(Color.GREEN);\n        g2d.fillRect(10, 80, gp.shooter.health * 2, 20);\n        g2d.setColor(Color.WHITE);\n        g2d.drawRect(10, 80, 200, 20);\n        g2d.drawString(\"Health: \" + gp.shooter.health, 10, 95);\n        \n        // Draw score\n        g2d.drawString(\"Score: \" + gp.currentScore, 10, 120);\n        \n        // Draw wave info\n        g2d.drawString(\"Wave: \" + gp.currentWave, 10, 150);\n        g2d.drawString(\"Zombies Alive: \" + gp.zombiesAlive, 10, 180);\n        \n        // Draw weapon inventory\n        g2d.setFont(new Font(\"Arial\", Font.BOLD, 16));\n        g2d.drawString(\"Weapon Inventory:\", 10, 220);\n        \n        Weapon[] weapons = gp.shooter.getWeapons();\n        boolean[] unlockedWeapons = gp.shooter.getUnlockedWeapons();\n        \n        for (int i = 0; i < weapons.length; i++) {\n            if (unlockedWeapons[i]) {\n                String inventoryWeaponName = \"Unknown\";\n                if (weapons[i] instanceof Tabanca) inventoryWeaponName = \"Tabanca\";\n                else if (weapons[i] instanceof PiyadeTufegi) inventoryWeaponName = \"Piyade Tufegi\";\n                else if (weapons[i] instanceof PompaliTufek) inventoryWeaponName = \"Pompali Tufek\";\n                else if (weapons[i] instanceof KeskinNisanciTufegi) inventoryWeaponName = \"Keskin Nisanci Tufegi\";\n                else if (weapons[i] instanceof Roketatar) inventoryWeaponName = \"Roketatar\";\n                \n                String weaponText = (i + 1) + \": \" + inventoryWeaponName + \" (\" + weapons[i].getCurrentAmmo() + \"/\" + weapons[i].getTotalAmmo() + \")\";\n                // Draw in red if no ammo\n                if (weapons[i].getCurrentAmmo() <= 0) {\n                    g2d.setColor(Color.RED);\n                } else {\n                    g2d.setColor(Color.WHITE);\n                }\n                g2d.drawString(weaponText, 10, 250 + (i * 25));\n            }\n        }\n        \n        // Draw message if any\n        if (message != null && !message.isEmpty()) {\n            g2d.setColor(Color.YELLOW);\n            g2d.setFont(new Font(\"Arial\", Font.BOLD, 24));\n            g2d.drawString(message, gp.screenWidth/2 - g2d.getFontMetrics().stringWidth(message)/2, gp.screenHeight - 50);\n            \n            // Increment message counter and clear message after 2 seconds (120 frames at 60 FPS)\n            messageCounter++;\n            if (messageCounter > 120) {\n                message = \"\";\n                messageCounter = 0;\n            }\n        }\n    }\n}\n\n",
      "RocketBullet.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class RocketBullet extends Bullet {\n    private static final int EXPLOSION_RADIUS = 200; // pixels\n    private boolean exploded = false;\n    private int explosionDuration = 30; // Duration of explosion animation in frames\n    private int explosionTimer = 0;\n    \n\n    public RocketBullet(GamePanel gp, int worldX, int worldY, double angle, int damage) {\n        super(gp, worldX, worldY, angle, damage);\n        this.size = 24; // Make rocket bullets bigger than normal bullets\n        this.speed = 8;\n        this.range = 800;\n        this.active = true;\n        this.damage = 200; // Set damage to 100\n    }\n\n    @Override\n    public void update() {\n        if (!exploded) {\n            // Move the rocket\n            worldX += Math.cos(angle) * speed;\n            worldY += Math.sin(angle) * speed;\n            \n            boolean shouldExplode = false;\n            \n            // Check if bullet has gone out of range\n            if (worldX < 0 || worldX > gp.worldWidth || \n                worldY < 0 || worldY > gp.worldHeight) {\n                active = false;\n                return;\n            }\n\n            // Check for collision with walls\n            int col = (int)(worldX / gp.tilesize);\n            int row = (int)(worldY / gp.tilesize);\n            \n            // Make sure we're within map bounds\n            if (col >= 0 && col < gp.worldColumn && row >= 0 && row < gp.worldRow) {\n                if (gp.tm.tile[gp.tm.map[col][row]].collision) {\n                    shouldExplode = true;\n                }\n            }\n\n            // Check for direct collision with zombies\n            for (int i = 0; i < gp.zombies.length; i++) {\n                Zombie zombie = gp.zombies[i];\n                if (zombie != null && zombie.health > 0) {\n                    // Calculate centers of bullet and zombie\n                    int bulletCenterX = worldX + size/2;\n                    int bulletCenterY = worldY + size/2;\n                    int zombieCenterX = zombie.worldX + gp.tilesize/2;\n                    int zombieCenterY = zombie.worldY + gp.tilesize/2;\n\n                    // Calculate distance between centers\n                    double distance = Math.sqrt(\n                        Math.pow(bulletCenterX - zombieCenterX, 2) + \n                        Math.pow(bulletCenterY - zombieCenterY, 2)\n                    );\n\n                    // If distance is less than half the sum of sizes, they collide\n                    if (distance < (gp.tilesize/2 + size/2)) {\n                        shouldExplode = true;\n                        break;\n                    }\n                }\n            }\n            \n            // If we should explode, do it after checking all collisions\n            if (shouldExplode) {\n                explode();\n            }\n        } else {\n            // Update explosion animation\n            explosionTimer++;\n            if (explosionTimer >= explosionDuration) {\n                active = false;\n            }\n        }\n    }\n\n    private void explode() {\n        exploded = true;\n        // Damage all zombies in explosion radius\n        for (int i = 0; i < gp.zombies.length; i++) {\n            Zombie zombie = gp.zombies[i];\n            if (zombie != null && zombie.health > 0) {\n                // Calculate distance from explosion center to zombie center\n                int zombieCenterX = zombie.worldX + gp.tilesize/2;\n                int zombieCenterY = zombie.worldY + gp.tilesize/2;\n                double distance = Math.sqrt(\n                    Math.pow(zombieCenterX - worldX, 2) + \n                    Math.pow(zombieCenterY - worldY, 2)\n                );\n                \n                // If zombie is within explosion radius\n                if (distance <= EXPLOSION_RADIUS) {\n                    // Calculate damage based on distance (more damage closer to explosion)\n                    int explosionDamage = (int)(damage * (1 - distance/EXPLOSION_RADIUS));\n                    zombie.health -= explosionDamage;\n                    if (zombie.health <= 0) {\n                        zombie.health = 0;\n                        gp.zombies[i] = null;\n                        gp.zombiesAlive--;\n                        gp.currentScore += 10;\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2) {\n        if (!exploded) {\n            // Convert world coordinates to screen coordinates\n            int screenX = worldX - gp.shooter.worldX + gp.screenWidth/2;\n            int screenY = worldY - gp.shooter.worldY + gp.screenHeight/2;\n            \n            // Draw rocket bullet\n            g2.setColor(Color.ORANGE);\n            g2.fillOval(screenX, screenY, size, size);\n            \n            // Draw rocket trail\n            g2.setColor(new Color(255, 165, 0, 100)); // Semi-transparent orange\n            int trailLength = 20;\n            \n            // Calculate trail position based on angle\n            double trailX = screenX + Math.cos(angle) * size;\n            double trailY = screenY + Math.sin(angle) * size;\n            \n            // Draw trail in the opposite direction of movement\n            g2.fillOval((int)trailX, (int)trailY, size, trailLength);\n        } else {\n            // Convert world coordinates to screen coordinates for explosion\n            int screenX = worldX - gp.shooter.worldX + gp.screenWidth/2;\n            int screenY = worldY - gp.shooter.worldY + gp.screenHeight/2;\n            \n            // Draw explosion with fade out effect\n            int alpha = (int)(255 * (1.0 - (double)explosionTimer / explosionDuration));\n            \n            // Draw outer explosion circle\n            g2.setColor(new Color(255, 165, 0, alpha)); // Fade out orange\n            g2.fillOval(screenX - EXPLOSION_RADIUS, screenY - EXPLOSION_RADIUS, \n                       EXPLOSION_RADIUS * 2, EXPLOSION_RADIUS * 2);\n            \n            // Draw inner explosion circle\n            g2.setColor(new Color(255, 100, 0, alpha)); // More intense orange\n            g2.fillOval(screenX - EXPLOSION_RADIUS/2, screenY - EXPLOSION_RADIUS/2, \n                       EXPLOSION_RADIUS, EXPLOSION_RADIUS);\n            \n            // Draw explosion center\n            g2.setColor(new Color(255, 50, 0, alpha)); // Most intense orange\n            g2.fillOval(screenX - EXPLOSION_RADIUS/4, screenY - EXPLOSION_RADIUS/4, \n                       EXPLOSION_RADIUS/2, EXPLOSION_RADIUS/2);\n        }\n    }\n} ",
      "KeyHandler.java": "import java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\npublic class KeyHandler implements KeyListener {\n\n    GamePanel gp;\n\n    public boolean upPressed, downPressed, leftPressed, rightPressed, enterPressed;\n    public boolean onePressed, twoPressed, threePressed, fourPressed, fivePressed;\n    public boolean reloadPressed;\n\n    public KeyHandler(GamePanel gp){\n        this.gp=gp;\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int code = e.getKeyCode();\n\n        if(gp.gameState == gp.titleState) {\n            if (code == KeyEvent.VK_W || code == KeyEvent.VK_UP) {\n                gp.ui.commandNum--;\n                if(gp.ui.commandNum < 0) {\n                    gp.ui.commandNum = 2;\n                }\n            }\n            if (code == KeyEvent.VK_S || code == KeyEvent.VK_DOWN) {\n                gp.ui.commandNum++;\n                if(gp.ui.commandNum > 2) {\n                    gp.ui.commandNum = 0;\n                }\n            }\n            if(code == KeyEvent.VK_ENTER) {\n                if(gp.ui.commandNum == 0) {\n                    gp.startGame();\n                }\n                else if(gp.ui.commandNum == 1) {\n                    gp.loadGame();\n                }\n                else if(gp.ui.commandNum == 2) {\n                    System.exit(0);\n                }\n            }\n            if (code == KeyEvent.VK_SPACE) {\n                gp.gameState = gp.playState;\n                gp.startGame();\n            }\n        }\n        else if(gp.gameState == gp.gameOverState) {\n            if(code == KeyEvent.VK_ENTER) {\n                gp.startGame();\n            }\n            if (code == KeyEvent.VK_SPACE) {\n                gp.gameState = gp.titleState;\n                gp.setUpGame();\n            }\n        }\n        else if(gp.gameState == gp.playState || gp.gameState == gp.pauseState) {\n            if (code == KeyEvent.VK_W || code == KeyEvent.VK_UP) {\n                upPressed = true;\n            }\n            if (code == KeyEvent.VK_S || code == KeyEvent.VK_DOWN) {\n                downPressed = true;\n            }\n            if (code == KeyEvent.VK_A || code == KeyEvent.VK_LEFT) {\n                leftPressed = true;\n            }\n            if (code == KeyEvent.VK_D || code == KeyEvent.VK_RIGHT) {\n                rightPressed = true;\n            }\n            if (code == KeyEvent.VK_ENTER) {\n                enterPressed = true;\n            }\n            if (code == KeyEvent.VK_ESCAPE || code == KeyEvent.VK_P) {\n                if(gp.gameState == gp.playState) {\n                    gp.gameState = gp.pauseState;\n                    gp.ui.commandNum = 0; // Reset command number when entering pause menu\n                }\n                else {\n                    gp.gameState = gp.playState;\n                }\n            }\n            // Handle pause menu navigation\n            if(gp.gameState == gp.pauseState) {\n                if (code == KeyEvent.VK_W || code == KeyEvent.VK_UP) {\n                    gp.ui.commandNum--;\n                    if(gp.ui.commandNum < 0) {\n                        gp.ui.commandNum = 1;\n                    }\n                }\n                if (code == KeyEvent.VK_S || code == KeyEvent.VK_DOWN) {\n                    gp.ui.commandNum++;\n                    if(gp.ui.commandNum > 1) {\n                        gp.ui.commandNum = 0;\n                    }\n                }\n                if(code == KeyEvent.VK_ENTER) {\n                    if(gp.ui.commandNum == 0) {\n                        gp.saveGame();\n                    }\n                    else if(gp.ui.commandNum == 1) {\n                        gp.gameState = gp.playState;\n                    }\n                }\n            }\n            // Weapon switching\n            if (code == KeyEvent.VK_1) {\n                onePressed = true;\n            }\n            if (code == KeyEvent.VK_2) {\n                twoPressed = true;\n            }\n            if (code == KeyEvent.VK_3) {\n                threePressed = true;\n            }\n            if (code == KeyEvent.VK_4) {\n                fourPressed = true;\n            }\n            if (code == KeyEvent.VK_5) {\n                fivePressed = true;\n            }\n            // Reloading\n            if (code == KeyEvent.VK_R) {\n                reloadPressed = true;\n            }\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int code = e.getKeyCode();\n\n        if (code == KeyEvent.VK_W || code == KeyEvent.VK_UP) {\n            upPressed = false;\n        }\n        if (code == KeyEvent.VK_S || code == KeyEvent.VK_DOWN) {\n            downPressed = false;\n        }\n        if (code == KeyEvent.VK_A || code == KeyEvent.VK_LEFT) {\n            leftPressed = false;\n        }\n        if (code == KeyEvent.VK_D || code == KeyEvent.VK_RIGHT) {\n            rightPressed = false;\n        }\n        if (code == KeyEvent.VK_ENTER) {\n            enterPressed = false;\n        }\n        // Weapon switching\n        if (code == KeyEvent.VK_1) {\n            onePressed = false;\n        }\n        if (code == KeyEvent.VK_2) {\n            twoPressed = false;\n        }\n        if (code == KeyEvent.VK_3) {\n            threePressed = false;\n        }\n        if (code == KeyEvent.VK_4) {\n            fourPressed = false;\n        }\n        if (code == KeyEvent.VK_5) {\n            fivePressed = false;\n        }\n        // Reloading\n        if (code == KeyEvent.VK_R) {\n            reloadPressed = false;\n        }\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {\n        // Not used\n    }\n}\n",
      "SurungeZombi.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class SurungeZombi extends Zombie{\n    public SurungeZombi(GamePanel gp){\n        super(gp, 3); // Call parent constructor with type 3 (Crawler)\n        this.gp=gp;\n        health = 30;  // Match the parent class health\n        damage = 6;  // Match the parent class damage\n        velocity=4;\n        direction = \"down\";\n        counter = 0;\n        num = 1;\n        collisionOn = false;\n\n        // Set up collision area\n        solid = new Rectangle(3, 18, 42, 30);\n\n        getImage();\n    }\n    public void getImage(){\n        try {\n            System.out.println(\"Loading Surunge Zombie images...\");\n            up1 = ImageIO.read(getClass().getResourceAsStream(\"greenslime_down_1.png\"));\n            up2 = ImageIO.read(getClass().getResourceAsStream(\"greenslime_down_1.png\"));\n            down1 = ImageIO.read(getClass().getResourceAsStream(\"greenslime_down_1.png\"));\n            down2 = ImageIO.read(getClass().getResourceAsStream(\"greenslime_down_1.png\"));\n            left1 = ImageIO.read(getClass().getResourceAsStream(\"greenslime_down_1.png\"));\n            left2 = ImageIO.read(getClass().getResourceAsStream(\"greenslime_down_1.png\"));\n            right1 = ImageIO.read(getClass().getResourceAsStream(\"greenslime_down_1.png\"));\n            right2 = ImageIO.read(getClass().getResourceAsStream(\"greenslime_down_1.png\"));\n            System.out.println(\"Surunge Zombie images loaded successfully\");\n        } catch (IOException e) {\n            System.out.println(\"Error loading Surunge Zombie images: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public void setAction() {\n        // Zombinin oyuncuya olan uzaklığını hesapla\n        int xDistance = gp.shooter.worldX - worldX;\n        int yDistance = gp.shooter.worldY - worldY;\n\n        // Zombinin hareket yönünü belirle\n        if(Math.abs(xDistance) > Math.abs(yDistance)) {\n            // X ekseni farkı daha büyükse, öncelikle X yönünde hareket et\n            if(xDistance < 0) {\n                direction = \"left\";\n            } else {\n                direction = \"right\";\n            }\n        } else {\n            // Y ekseni farkı daha büyükse veya eşitse, öncelikle Y yönünde hareket et\n            if(yDistance < 0) {\n                direction = \"up\";\n            } else {\n                direction = \"down\";\n            }\n        }\n\n        // Her 60 frame'de bir yön güncelleme yapılsın\n        counter++;\n        if(counter > 60) {\n            counter = 0;\n        }\n    }\n\n    @Override\n    public void update() {\n        // Only update if zombie is alive\n        if (health > 0) {\n            super.update(); // Call parent's update method for jumping mechanics\n            // Don't call setAction() here as it would override the parent's movement\n            \n            counter++;\n            if(counter > 12) {\n                if(num == 1) {\n                    num = 2;\n                }\n                else {\n                    num = 1;\n                }\n                counter = 0;\n            }\n        }\n    }\n\n    @Override\n    public void draw(Graphics2D g2d) {\n        if (g2d == null) {\n            System.out.println(\"Graphics2D is null in draw method\");\n            return;\n        }\n\n        BufferedImage image = null;\n        switch(direction) {\n            case \"up\":\n                if(num == 1) { image = up1; }\n                if(num == 2) { image = up2; }\n                break;\n            case \"down\":\n                if(num == 1) { image = down1; }\n                if(num == 2) { image = down2; }\n                break;\n            case \"left\":\n                if(num == 1) { image = left1; }\n                if(num == 2) { image = left2; }\n                break;\n            case \"right\":\n                if(num == 1) { image = right1; }\n                if(num == 2) { image = right2; }\n                break;\n        }\n\n        if (image == null) {\n            System.out.println(\"Lunge Zombie: Image is null for direction: \" + direction + \" and num: \" + num);\n            return;\n        }\n\n        // Draw the zombie image with jump height adjustment\n        g2d.drawImage(image, screenX, screenY - jumpHeight, gp.tilesize, gp.tilesize, null);\n    }\n\n}\n",
      "Shooter.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport javax.imageio.ImageIO;\n\npublic class Shooter extends Entity {\n\n    GamePanel gp;\n    KeyHandler  keyHandler;\n    public int screenX;\n    public int screenY;\n    public int standCounter=0;\n    public int health = 100;\n    public int maxHealth = 100;\n\n    // Weapon system\n    private Weapon[] weapons;\n    private int currentWeaponIndex;\n    private boolean[] unlockedWeapons;  // Track which weapons are unlocked\n    \n    // Shooting variables\n    public ArrayList<Bullet> bullets = new ArrayList<>();\n    public boolean shooting = false;\n    private boolean canShootAgain = true; // Add this new field at the class level\n\n    public Shooter(GamePanel gp, KeyHandler keyHandler){\n        this.gp=gp;\n        this.keyHandler=keyHandler;\n\n        screenX=gp.screenWidth/2;\n        screenY=gp.screenHeight/2;\n        \n        // Initialize weapons\n        weapons = new Weapon[5];\n        weapons[0] = new Tabanca();\n        weapons[1] = new PiyadeTufegi();\n        weapons[2] = new PompaliTufek();\n        weapons[3] = new KeskinNisanciTufegi();\n        weapons[4] = new Roketatar();\n        currentWeaponIndex = 0;  // Start with pistol\n        \n        // Initialize unlocked weapons array (only pistol unlocked at start)\n        unlockedWeapons = new boolean[5];\n        unlockedWeapons[0] = true;  // Pistol is unlocked initially\n        \n        setDefaultValues();\n        getPlayerImage();\n\n        solid=new Rectangle(8,16,gp.tilesize-16,gp.tilesize-16);   \n    }\n\n    public void setDefaultValues(){\n        worldX=23*gp.tilesize-gp.tilesize/2;\n        worldY=23*gp.tilesize-gp.tilesize/2;\n        velocity=3;\n        direction=\"down\";\n    }\n\n    public void getPlayerImage(){\n        try {\n            up1=ImageIO.read(getClass().getResourceAsStream(\"/boy_up_1.png\"));\n            up2=ImageIO.read(getClass().getResourceAsStream(\"/boy_up_2.png\"));\n            down1=ImageIO.read(getClass().getResourceAsStream(\"/boy_down_1.png\"));\n            down2=ImageIO.read(getClass().getResourceAsStream(\"/boy_down_2.png\"));\n            left1=ImageIO.read(getClass().getResourceAsStream(\"/boy_left_1.png\"));\n            left2=ImageIO.read(getClass().getResourceAsStream(\"/boy_left_2.png\"));\n            right1=ImageIO.read(getClass().getResourceAsStream(\"/boy_right_1.png\"));\n            right2=ImageIO.read(getClass().getResourceAsStream(\"/boy_right_2.png\"));\n                     \n        } catch (Exception e) {\n        }\n    }\n   public void update(){\n        // Reset movement flags at the start of each update\n        boolean upPressed = false;\n        boolean downPressed = false;\n        boolean leftPressed = false;\n        boolean rightPressed = false;\n\n        // Check key presses\n        if (keyHandler.upPressed) {\n            upPressed = true;\n            direction = \"up\";\n        }\n        if (keyHandler.downPressed) {\n            downPressed = true;\n            direction = \"down\";\n        }\n        if (keyHandler.leftPressed) {\n            leftPressed = true;\n            direction = \"left\";\n        }\n        if (keyHandler.rightPressed) {\n            rightPressed = true;\n            direction = \"right\";\n        }\n\n        // Store original position\n        int originalX = worldX;\n        int originalY = worldY;\n\n        // Handle diagonal movement\n        if (upPressed && leftPressed) {\n            direction = \"up\";\n            worldX -= velocity;\n            worldY -= velocity;\n        } else if (upPressed && rightPressed) {\n            direction = \"up\";\n            worldX += velocity;\n            worldY -= velocity;\n        } else if (downPressed && leftPressed) {\n            direction = \"down\";\n            worldX -= velocity;\n            worldY += velocity;\n        } else if (downPressed && rightPressed) {\n            direction = \"down\";\n            worldX += velocity;\n            worldY += velocity;\n        } else {\n            // Single direction movement\n            if (upPressed) {\n                worldY -= velocity;\n            }\n            if (downPressed) {\n                worldY += velocity;\n            }\n            if (leftPressed) {\n                worldX -= velocity;\n            }\n            if (rightPressed) {\n                worldX += velocity;\n            }\n        }\n\n        // Check for collisions\n        collisionOn = false;\n        gp.cc.checkTile(this);\n\n        // If collision occurred, revert position\n        if (collisionOn) {\n            worldX = originalX;\n            worldY = originalY;\n        }\n\n        // Update screen position\n        screenX = worldX - gp.shooter.worldX + gp.screenWidth/2 - (gp.tilesize/2);\n        screenY = worldY - gp.shooter.worldY + gp.screenHeight/2 - (gp.tilesize/2);\n\n        // Handle weapon switching\n        if (keyHandler.onePressed && unlockedWeapons[0]) currentWeaponIndex = 0;\n        if (keyHandler.twoPressed && unlockedWeapons[1]) currentWeaponIndex = 1;\n        if (keyHandler.threePressed && unlockedWeapons[2]) currentWeaponIndex = 2;\n        if (keyHandler.fourPressed && unlockedWeapons[3]) currentWeaponIndex = 3;\n        if (keyHandler.fivePressed && unlockedWeapons[4]) currentWeaponIndex = 4;\n        \n        // Handle reloading\n        if (keyHandler.reloadPressed) {\n            weapons[currentWeaponIndex].reload();\n        }\n\n        // Handle shooting\n        if (gp.mouseHandler.leftPressed && !weapons[currentWeaponIndex].isReloading && canShootAgain) {\n            Weapon currentWeapon = weapons[currentWeaponIndex];\n            if (currentWeapon.canShoot()) {\n                canShootAgain = false; // Prevent shooting until mouse is released\n                currentWeapon.shoot();\n                \n                // Calculate bullet starting position from player center\n                int bulletX = worldX + gp.tilesize/2;\n                int bulletY = worldY + gp.tilesize/2;\n                \n                // Calculate angle between player and mouse position\n                double dx = gp.mouseHandler.mouseWorldX - bulletX;\n                double dy = gp.mouseHandler.mouseWorldY - bulletY;\n                double angle = Math.atan2(dy, dx);\n                \n                // Create bullet with appropriate properties\n                if (currentWeaponIndex == 3) { // Sniper rifle\n                    bullets.add(new Bullet(gp, bulletX, bulletY, angle, 50, true)); // High damage, piercing\n                } else if (currentWeaponIndex == 4) { // Rocket launcher\n                    bullets.add(new RocketBullet(gp, bulletX, bulletY, angle, 100)); // High damage, explosion\n                } else if (currentWeaponIndex == 1) { // Piyade Tüfeği (Rifle) - 30 degrees spread, 1 bullet\n                    // Create 1 bullet for rifle with spread\n                    double spread = Math.toRadians((Math.random() * 30) - 15); // -15 to +15 degrees\n                    bullets.add(new Bullet(gp, bulletX, bulletY, angle + spread, currentWeapon.getDamage(), false));\n                } else if (currentWeaponIndex == 2) { // Pompali Tüfek (Shotgun) - 45 degrees spread, 9 bullets\n                    // Create 9 bullets for shotgun with even spread\n                    double startAngle = angle - Math.toRadians(22.5); // Start at -22.5 degrees\n                    double angleStep = Math.toRadians(5); // 5 degrees between each bullet\n                    for (int i = 0; i < 9; i++) {\n                        bullets.add(new Bullet(gp, bulletX, bulletY, startAngle + (angleStep * i), currentWeapon.getDamage(), false));\n                    }\n                } else {\n                    bullets.add(new Bullet(gp, bulletX, bulletY, angle, currentWeapon.getDamage(), false));\n                }\n            }\n        }\n        \n        // Reset shooting flag when mouse button is released\n        if (!gp.mouseHandler.leftPressed) {\n            canShootAgain = true;\n        }\n\n        // Update current weapon\n        weapons[currentWeaponIndex].update();\n\n        // Update bullets\n        for (int i = bullets.size() - 1; i >= 0; i--) {\n            Bullet bullet = bullets.get(i);\n            if (bullet != null) {\n                bullet.update();\n                if (!bullet.active) {\n                    bullets.remove(i);\n                }\n            }\n        }\n    }\n    public void draw(Graphics2D g){\n        // Draw bullets first (so they appear behind the player)\n        for(Bullet bullet : bullets){\n            if (bullet != null) {\n                bullet.draw(g);\n            }\n        }\n        \n        // Draw the shooter\n        BufferedImage img = null;\n        switch (direction) {\n            case \"up\":\n                img = (num == 1) ? up1 : up2;\n                break;\n            case \"down\":\n                img = (num == 1) ? down1 : down2;\n                break;\n            case \"left\":\n                img = (num == 1) ? left1 : left2;\n                break;\n            case \"right\":\n                img = (num == 1) ? right1 : right2;\n                break;\n            default:\n                img = down1; // Default to facing down when idle\n                break;\n        }\n        \n        g.drawImage(img, screenX, screenY, gp.tilesize, gp.tilesize, null);\n    }\n\n    public void unlockWeapon(int index) {\n        if (index >= 0 && index < unlockedWeapons.length) {\n            unlockedWeapons[index] = true;\n            // Show unlock message\n            gp.ui.showMessage(\"New weapon unlocked!\");\n        }\n    }\n\n    public boolean isWeaponUnlocked(int index) {\n        return index >= 0 && index < unlockedWeapons.length && unlockedWeapons[index];\n    }\n\n    public void resetWeapons() {\n        // Reset all weapons to full ammo and not reloading\n        for (Weapon weapon : weapons) {\n            weapon.currentAmmo = weapon.magazineSize;\n            weapon.isReloading = false;\n        }\n        \n        // Reset unlocked weapons to initial state (only pistol unlocked)\n        unlockedWeapons[0] = true;  // Pistol is always unlocked\n        for (int i = 1; i < unlockedWeapons.length; i++) {\n            unlockedWeapons[i] = false;\n        }\n        \n        // Reset to pistol\n        currentWeaponIndex = 0;\n    }\n\n    public Weapon getCurrentWeapon() {\n        return weapons[currentWeaponIndex];\n    }\n\n    public int getCurrentWeaponAmmo() {\n        return weapons[currentWeaponIndex].getAmmo();\n    }\n\n    public int getWeaponAmmo(int index) {\n        return weapons[index].getAmmo();\n    }\n\n    public int getCurrentWeaponIndex() {\n        return currentWeaponIndex;\n    }\n\n    public Weapon[] getWeapons() {\n        return weapons;\n    }\n    \n    public boolean[] getUnlockedWeapons() {\n        return unlockedWeapons;\n    }\n    \n    public void setWeaponAmmo(int index, int ammo) {\n        if (weapons[index] != null) {\n            weapons[index].setCurrentAmmo(ammo);\n        }\n    }\n\n    public void setWeaponTotalAmmo(int index, int totalAmmo) {\n        if (weapons[index] != null) {\n            weapons[index].setTotalAmmo(totalAmmo);\n        }\n    }\n\n    public void setUnlockedWeapon(int index, boolean unlocked) {\n        if (index >= 0 && index < unlockedWeapons.length) {\n            unlockedWeapons[index] = unlocked;\n        }\n    }\n\n    public Rectangle getBounds() {\n        return new Rectangle(worldX, worldY, gp.tilesize, gp.tilesize);\n    }\n\n    public void increaseWeaponAmmo(int weaponIndex, int amount) {\n        if (weaponIndex >= 0 && weaponIndex < weapons.length) {\n            if (weaponIndex == 0) { // Tabanca (Pistol)\n                // For pistol, just set total ammo to max value\n                weapons[weaponIndex].totalAmmo = Integer.MAX_VALUE;\n            } else {\n                // For other weapons, add the specified amount\n                weapons[weaponIndex].totalAmmo += amount;\n            }\n            System.out.println(\"Increased ammo for weapon \" + weaponIndex + \" by \" + amount);\n        }\n    }\n}\n",
      "Game.java": "import javax.swing.JFrame;\n\npublic class Game {\n    public static void main(String[] args) {\n        JFrame window=new JFrame(\"Top Down Shooter\");\n        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        window.setResizable(false);\n\n        GamePanel gamePanel = new GamePanel();\n        window.add(gamePanel);\n        window.pack();\n\n        window.setLocationRelativeTo(window);\n        window.setVisible(true);\n        \n        gamePanel.setUpGame();\n        gamePanel.startGameThread();\n    }\n    \n}\n",
      "ZombieSetter.java": "public class ZombieSetter {\n    GamePanel gp;\n    private long lastWaveEndTime = 0;\n    private long lastWaveStartTime = 0;\n    private static final long WAVE_DELAY = 2000; // 2 seconds in milliseconds\n    private boolean waveEndMessageShown = false;\n    private static final int MAX_WAVES = 100;\n    private boolean isLoadingGame = false;\n\n    public ZombieSetter(GamePanel gp){\n        this.gp = gp;\n    }\n\n    public boolean isLoadingGame() {\n        return isLoadingGame;\n    }\n\n    private boolean isValidSpawnPosition(int x, int y) {\n        // Check if position is within map bounds\n        if (x < 5 || x > gp.worldColumn - 5 || y < 5 || y > gp.worldRow - 5) {\n            return false;\n        }\n        \n        // Check distance from other zombies\n        for (int i = 0; i < gp.zombies.length; i++) {\n            if (gp.zombies[i] != null && gp.zombies[i].health > 0) {\n                int distanceX = Math.abs(x - (gp.zombies[i].worldX / gp.tilesize));\n                int distanceY = Math.abs(y - (gp.zombies[i].worldY / gp.tilesize));\n                // Minimum distance of 8 tiles between zombies\n                if (distanceX < 8 && distanceY < 8) {\n                    return false;\n                }\n            }\n        }\n        \n        // Check distance from player (minimum 15 tiles)\n        int playerX = gp.shooter.worldX / gp.tilesize;\n        int playerY = gp.shooter.worldY / gp.tilesize;\n        int distanceX = Math.abs(x - playerX);\n        int distanceY = Math.abs(y - playerY);\n        if (distanceX < 15 && distanceY < 15) {\n            return false;\n        }\n        \n        return true;\n    }\n\n    private int[] getRandomSpawnPosition() {\n        int maxAttempts = 50;\n        int attempts = 0;\n        \n        while (attempts < maxAttempts) {\n            int x = (int)(Math.random() * (gp.worldColumn - 10)) + 5;\n            int y = (int)(Math.random() * (gp.worldRow - 10)) + 5;\n            \n            // Check if the tile at this position has collision\n            int tileNum = gp.tm.map[x][y];\n            if (!gp.tm.tile[tileNum].collision) {\n                return new int[]{x, y};\n            }\n            attempts++;\n        }\n        \n        // If no valid position found, return a default position\n        return new int[]{10, 25};\n    }\n\n    public void startFirstWave() {\n        System.out.println(\"Starting first wave\");\n        \n        // Clear existing zombies\n        for(int i = 0; i < gp.zombies.length; i++) {\n            gp.zombies[i] = null;\n        }\n        \n        // Spawn 5 normal zombies for first wave\n        int zombieIndex = 0;\n        for (int i = 0; i < 5 && zombieIndex < gp.zombies.length; i++) {\n            int[] spawnPos = getRandomSpawnPosition();\n            gp.zombies[zombieIndex] = new NormalZombi(gp);\n            gp.zombies[zombieIndex].worldX = spawnPos[0] * gp.tilesize;\n            gp.zombies[zombieIndex].worldY = spawnPos[1] * gp.tilesize;\n            zombieIndex++;\n        }\n        \n        gp.zombiesAlive = zombieIndex;\n        gp.waveInProgress = true; // Set wave in progress after zombies are spawned\n        System.out.println(\"First wave started with \" + zombieIndex + \" zombies\");\n        gp.ui.showMessage(\"Wave 1 Started!\");\n    }\n\n    \n\n    public void startNextWave() {\n        System.out.println(\"Starting wave \" + gp.currentWave);\n        \n        // Clear existing zombies\n        for(int i = 0; i < gp.zombies.length; i++) {\n            gp.zombies[i] = null;\n        }\n        \n        // Spawn zombies based on wave number\n        switch(gp.currentWave) {\n            case 1:\n                spawnWave1();\n                break;\n            case 2:\n                spawnWave2();\n                break;\n            case 3:\n                spawnWave3();\n                break;\n            case 4:\n                spawnWave4();\n                break;\n            default:\n                // For waves beyond 4, use a mix of zombies\n                int numZombies = 5 + (gp.currentWave - 1) * 2;\n                int zombieIndex = 0;\n                for (int i = 0; i < numZombies && zombieIndex < gp.zombies.length; i++) {\n                    int[] spawnPos = getRandomSpawnPosition();\n                    \n                    // Randomly select zombie type based on wave\n                    double random = Math.random();\n                    if (gp.currentWave >= 11) {\n                        // Wave 11+: All types available with increasing difficulty\n                        if (random < 0.2) gp.zombies[zombieIndex] = new NormalZombi(gp);\n                        else if (random < 0.4) gp.zombies[zombieIndex] = new SurungeZombi(gp);\n                        else if (random < 0.6) gp.zombies[zombieIndex] = new TankZombi(gp);\n                        else gp.zombies[zombieIndex] = new AsitTukurenZombi(gp, 4);\n                    } else if (gp.currentWave >= 6) {\n                        // Wave 6-10: Mix of Normal, Surunge, and Tank\n                        if (random < 0.4) gp.zombies[zombieIndex] = new NormalZombi(gp);\n                        else if (random < 0.7) gp.zombies[zombieIndex] = new SurungeZombi(gp);\n                        else gp.zombies[zombieIndex] = new TankZombi(gp);\n                    } else if (gp.currentWave >= 4) {\n                        // Wave 4-5: Mix of Normal and Surunge\n                        if (random < 0.6) gp.zombies[zombieIndex] = new NormalZombi(gp);\n                        else gp.zombies[zombieIndex] = new SurungeZombi(gp);\n                    } else {\n                        // Wave 1-3: Only Normal zombies\n                        gp.zombies[zombieIndex] = new NormalZombi(gp);\n                    }\n                    \n                    gp.zombies[zombieIndex].worldX = spawnPos[0] * gp.tilesize;\n                    gp.zombies[zombieIndex].worldY = spawnPos[1] * gp.tilesize;\n                    zombieIndex++;\n                }\n                gp.zombiesAlive = zombieIndex;\n                break;\n        }\n        \n        gp.waveInProgress = true; // Set wave in progress after zombies are spawned\n        System.out.println(\"Wave \" + gp.currentWave + \" started with \" + gp.zombiesAlive + \" zombies\");\n        gp.ui.showMessage(\"Wave \" + gp.currentWave + \" Started!\");\n    }\n\n    private void spawnWave1() {\n        int zombieCount = 0;\n        int maxAttempts = 100; // Increase max attempts for better spawn distribution\n        \n        // Spawn 5 normal zombies for wave 1\n        while (zombieCount < 5) {\n            int[] spawnPos = getRandomSpawnPosition();\n            \n            // Find an empty slot in the zombies array\n            for (int i = 0; i < gp.zombies.length; i++) {\n                if (gp.zombies[i] == null) {\n                    gp.zombies[i] = new NormalZombi(gp);\n                    gp.zombies[i].worldX = spawnPos[0] * gp.tilesize;\n                    gp.zombies[i].worldY = spawnPos[1] * gp.tilesize;\n                    gp.zombiesAlive++;\n                    zombieCount++;\n                    System.out.println(\"Spawned zombie \" + zombieCount + \" at X=\" + gp.zombies[i].worldX + \", Y=\" + gp.zombies[i].worldY);\n                    break;\n                }\n            }\n            \n            // Break if we've tried too many times\n            if (zombieCount >= maxAttempts) {\n                System.out.println(\"WARNING: Could not spawn all zombies in Wave 1!\");\n                break;\n            }\n        }\n        \n        System.out.println(\"Wave 1 spawned \" + zombieCount + \" zombies\");\n    }\n\n    private void spawnWave2() {\n        System.out.println(\"\\n=== STARTING WAVE 2 ===\");\n        int zombieCount = 0;\n        \n        // Spawn Normal Zombies\n        for(int i = 0; i < 5; i++) {\n            gp.zombies[i] = new NormalZombi(gp);\n            int[] pos = getRandomSpawnPosition();\n            gp.zombies[i].worldX = gp.tilesize * pos[0];\n            gp.zombies[i].worldY = gp.tilesize * pos[1];\n            System.out.println(\"Created Normal Zombie \" + i + \" at X=\" + gp.zombies[i].worldX + \", Y=\" + gp.zombies[i].worldY);\n            zombieCount++;\n        }\n        // Spawn Surunge Zombies\n        for(int i = 5; i < 8; i++) {\n            gp.zombies[i] = new SurungeZombi(gp);\n            int[] pos = getRandomSpawnPosition();\n            gp.zombies[i].worldX = gp.tilesize * pos[0];\n            gp.zombies[i].worldY = gp.tilesize * pos[1];\n            System.out.println(\"Created Surunge Zombie \" + (i-5) + \" at X=\" + gp.zombies[i].worldX + \", Y=\" + gp.zombies[i].worldY);\n            zombieCount++;\n        }\n        gp.zombiesAlive = zombieCount;\n        System.out.println(\"Wave 2 spawned \" + zombieCount + \" zombies\");\n        System.out.println(\"=== WAVE 2 COMPLETE ===\\n\");\n    }\n\n    private void spawnWave3() {\n        System.out.println(\"\\n=== STARTING WAVE 3 ===\");\n        int zombieCount = 0;\n        \n        // Spawn Normal Zombies\n        for(int i = 0; i < 6; i++) {\n            gp.zombies[i] = new NormalZombi(gp);\n            int[] pos = getRandomSpawnPosition();\n            gp.zombies[i].worldX = gp.tilesize * pos[0];\n            gp.zombies[i].worldY = gp.tilesize * pos[1];\n            System.out.println(\"Created Normal Zombie \" + i + \" at X=\" + gp.zombies[i].worldX + \", Y=\" + gp.zombies[i].worldY);\n            zombieCount++;\n        }\n        // Spawn Surunge Zombies\n        for(int i = 6; i < 10; i++) {\n            gp.zombies[i] = new SurungeZombi(gp);\n            int[] pos = getRandomSpawnPosition();\n            gp.zombies[i].worldX = gp.tilesize * pos[0];\n            gp.zombies[i].worldY = gp.tilesize * pos[1];\n            System.out.println(\"Created Surunge Zombie \" + (i-6) + \" at X=\" + gp.zombies[i].worldX + \", Y=\" + gp.zombies[i].worldY);\n            zombieCount++;\n        }\n        // Spawn Tank Zombies\n        for(int i = 10; i < 12; i++) {\n            gp.zombies[i] = new TankZombi(gp);\n            int[] pos = getRandomSpawnPosition();\n            gp.zombies[i].worldX = gp.tilesize * pos[0];\n            gp.zombies[i].worldY = gp.tilesize * pos[1];\n            System.out.println(\"Created Tank Zombie \" + (i-10) + \" at X=\" + gp.zombies[i].worldX + \", Y=\" + gp.zombies[i].worldY);\n            zombieCount++;\n        }\n        gp.zombiesAlive = zombieCount;\n        System.out.println(\"Wave 3 spawned \" + zombieCount + \" zombies\");\n        System.out.println(\"=== WAVE 3 COMPLETE ===\\n\");\n    }\n\n    private void spawnWave4() {\n        System.out.println(\"\\n=== STARTING WAVE 4 ===\");\n        int zombieCount = 0;\n        \n        // Spawn Normal Zombies\n        for(int i = 0; i < 8; i++) {\n            gp.zombies[i] = new NormalZombi(gp);\n            int[] pos = getRandomSpawnPosition();\n            gp.zombies[i].worldX = gp.tilesize * pos[0];\n            gp.zombies[i].worldY = gp.tilesize * pos[1];\n            System.out.println(\"Created Normal Zombie \" + i + \" at X=\" + gp.zombies[i].worldX + \", Y=\" + gp.zombies[i].worldY);\n            zombieCount++;\n        }\n        // Spawn Surunge Zombies\n        for(int i = 8; i < 14; i++) {\n            gp.zombies[i] = new SurungeZombi(gp);\n            int[] pos = getRandomSpawnPosition();\n            gp.zombies[i].worldX = gp.tilesize * pos[0];\n            gp.zombies[i].worldY = gp.tilesize * pos[1];\n            System.out.println(\"Created Surunge Zombie \" + (i-8) + \" at X=\" + gp.zombies[i].worldX + \", Y=\" + gp.zombies[i].worldY);\n            zombieCount++;\n        }\n        // Spawn Tank Zombies\n        for(int i = 14; i < 18; i++) {\n            gp.zombies[i] = new TankZombi(gp);\n            int[] pos = getRandomSpawnPosition();\n            gp.zombies[i].worldX = gp.tilesize * pos[0];\n            gp.zombies[i].worldY = gp.tilesize * pos[1];\n            System.out.println(\"Created Tank Zombie \" + (i-14) + \" at X=\" + gp.zombies[i].worldX + \", Y=\" + gp.zombies[i].worldY);\n            zombieCount++;\n        }\n        // Spawn Acid Spitting Zombies\n        for(int i = 18; i < 20; i++) {\n            gp.zombies[i] = new AsitTukurenZombi(gp, 4);\n            int[] pos = getRandomSpawnPosition();\n            gp.zombies[i].worldX = gp.tilesize * pos[0];\n            gp.zombies[i].worldY = gp.tilesize * pos[1];\n            System.out.println(\"Created Acid Spitting Zombie \" + (i-18) + \" at X=\" + gp.zombies[i].worldX + \", Y=\" + gp.zombies[i].worldY);\n            zombieCount++;\n        }\n        gp.zombiesAlive = zombieCount;\n        System.out.println(\"Wave 4 spawned \" + zombieCount + \" zombies\");\n        System.out.println(\"=== WAVE 4 COMPLETE ===\\n\");\n    }\n\n    public void startWave(int waveNumber, boolean isLoad) {\n        isLoadingGame = isLoad;\n        startWave(waveNumber);\n        isLoadingGame = false;\n    }\n\n    public void startWave(int waveNumber) {\n        // Check and set weapon availability based on wave number\n        if (waveNumber >= 2) gp.shooter.unlockWeapon(1); // PiyadeTufegi\n        if (waveNumber >= 4) gp.shooter.unlockWeapon(2); // PompaliTufek\n        if (waveNumber >= 6) gp.shooter.unlockWeapon(3); // KeskinNisanciTufegi\n        if (waveNumber >= 11) gp.shooter.unlockWeapon(4); // Roketatar\n        \n        // Clear all existing zombies\n        for(int i = 0; i < gp.zombies.length; i++) {\n            gp.zombies[i] = null;\n        }\n        \n        // Reset wave state\n        gp.waveInProgress = true;\n        waveEndMessageShown = false;\n        \n        // Show wave start message\n        gp.ui.showMessage(\"Wave \" + waveNumber + \" Started!\");\n        \n        // Spawn zombies based on wave number\n        switch(waveNumber) {\n            case 1:\n                spawnWave1();\n                break;\n            case 2:\n                spawnWave2();\n                break;\n            case 3:\n                spawnWave3();\n                break;\n            case 4:\n                spawnWave4();\n                break;\n            default:\n                spawnWave1();\n                break;\n        }\n        System.out.println(\"Started Wave \" + waveNumber + \" with \" + gp.zombiesAlive + \" zombies\");\n    }\n\n    // Keep the old method for backward compatibility\n    public void setNormalZombie() {\n        startNextWave();\n    }\n\n    public void checkWaveCompletion() {\n        // Count living zombies\n        int livingZombies = 0;\n        for (Zombie zombie : gp.zombies) {\n            if (zombie != null && zombie.health > 0) {\n                livingZombies++;\n            }\n        }\n        \n        // Update zombiesAlive count\n        gp.zombiesAlive = livingZombies;\n        \n        // Only proceed if all zombies are dead and wave is in progress\n        if (livingZombies == 0 && gp.waveInProgress) {\n            System.out.println(\"Wave \" + gp.currentWave + \" completed!\");\n            gp.waveInProgress = false;\n            \n            // Show wave complete message\n            gp.ui.showMessage(\"Wave \" + gp.currentWave + \" Complete!\");\n            \n            // Start next wave after delay\n            if (gp.currentWave < MAX_WAVES) {\n                System.out.println(\"Starting next wave in 2 seconds...\");\n                gp.ui.showMessage(\"Next wave starting in 2 seconds...\");\n                \n                // Start the next wave after the delay\n                Thread waveThread = new Thread(() -> {\n                    try {\n                        Thread.sleep(WAVE_DELAY);\n                        // Double check zombies are still dead\n                        if (gp.zombiesAlive == 0) {\n                            System.out.println(\"Starting wave \" + (gp.currentWave + 1));\n                            gp.currentWave++;\n                            startNextWave();\n                        }\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                });\n                waveThread.start();\n            } else {\n                System.out.println(\"Game completed! All waves finished!\");\n                gp.ui.showMessage(\"Congratulations! You've completed all waves!\");\n                gp.gameState = gp.titleState; // Return to title screen\n            }\n        }\n    }\n}\n",
      "TankZombi.java": "import java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class TankZombi extends Zombie{\n    public TankZombi(GamePanel gp){\n        super(gp, 2);\n        this.gp=gp;\n        health = 120;\n        damage = 12;\n        velocity=1;\n        direction = \"down\";\n        counter = 0;\n        num = 1;\n        collisionOn = false;\n\n        this.solid=new Rectangle(3, 18, 42, 30);\n\n        getImage();\n    }\n    public void getImage(){\n        try {\n            System.out.println(\"Loading Tank Zombie images...\");\n            up1 = ImageIO.read(getClass().getResourceAsStream(\"orc_up_1.png\"));\n            up2 = ImageIO.read(getClass().getResourceAsStream(\"orc_up_2.png\"));\n            down1 = ImageIO.read(getClass().getResourceAsStream(\"orc_down_1.png\"));\n            down2 = ImageIO.read(getClass().getResourceAsStream(\"orc_down_2.png\"));\n            left1 = ImageIO.read(getClass().getResourceAsStream(\"orc_left_1.png\"));\n            left2 = ImageIO.read(getClass().getResourceAsStream(\"orc_left_2.png\"));\n            right1 = ImageIO.read(getClass().getResourceAsStream(\"orc_right_1.png\"));\n            right2 = ImageIO.read(getClass().getResourceAsStream(\"orc_right_2.png\"));\n            System.out.println(\"Tank Zombie images loaded successfully\");\n        } catch (IOException e) {\n            System.out.println(\"Error loading Tank Zombie images: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public void setAction() {\n        // Zombinin oyuncuya olan uzaklığını hesapla\n        int xDistance = gp.shooter.worldX - worldX;\n        int yDistance = gp.shooter.worldY - worldY;\n\n        // Zombinin hareket yönünü belirle\n        if(Math.abs(xDistance) > Math.abs(yDistance)) {\n            // X ekseni farkı daha büyükse, öncelikle X yönünde hareket et\n            if(xDistance < 0) {\n                direction = \"left\";\n            } else {\n                direction = \"right\";\n            }\n        } else {\n            // Y ekseni farkı daha büyükse veya eşitse, öncelikle Y yönünde hareket et\n            if(yDistance < 0) {\n                direction = \"up\";\n            } else {\n                direction = \"down\";\n            }\n        }\n\n        // Her 60 frame'de bir yön güncelleme yapılsın\n        counter++;\n        if(counter > 60) {\n            counter = 0;\n        }\n    }\n\n    @Override\n    public void update() {\n        // Only update if zombie is alive\n        if (health > 0) {\n            setAction();\n            \n            // Store original position\n            int originalX = worldX;\n            int originalY = worldY;\n            \n            // Try to move based on direction\n            switch(direction) {\n                case \"up\":\n                    worldY -= velocity;\n                    break;\n                case \"down\":\n                    worldY += velocity;\n                    break;\n                case \"left\":\n                    worldX -= velocity;\n                    break;\n                case \"right\":\n                    worldX += velocity;\n                    break;\n            }\n            \n            // Check for collisions\n            solid.x = worldX;\n            solid.y = worldY;\n            collisionOn = false;\n            gp.cc.checkTile(this);\n            \n            // If collision occurred, revert position\n            if (collisionOn) {\n                worldX = originalX;\n                worldY = originalY;\n                solid.x = worldX;\n                solid.y = worldY;\n            }\n            \n            // Update animation\n            counter++;\n            if(counter > 12) {\n                if(num == 1) {\n                    num = 2;\n                }\n                else {\n                    num = 1;\n                }\n                counter = 0;\n            }\n        }\n    }\n\n    public void draw(Graphics2D g2d) {\n        if (g2d == null) {\n            System.out.println(\"Graphics2D is null in draw method\");\n            return;\n        }\n\n        BufferedImage image = null;\n        switch(direction) {\n            case \"up\":\n                if(num == 1) { image = up1; }\n                if(num == 2) { image = up2; }\n                break;\n            case \"down\":\n                if(num == 1) { image = down1; }\n                if(num == 2) { image = down2; }\n                break;\n            case \"left\":\n                if(num == 1) { image = left1; }\n                if(num == 2) { image = left2; }\n                break;\n            case \"right\":\n                if(num == 1) { image = right1; }\n                if(num == 2) { image = right2; }\n                break;\n        }\n\n        if (image == null) {\n            System.out.println(\"Tank Zombie: Image is null for direction: \" + direction + \" and num: \" + num);\n            return;\n        }\n\n        int screenX = worldX - gp.shooter.worldX + gp.shooter.screenX;\n        int screenY = worldY - gp.shooter.worldY + gp.shooter.screenY;\n        g2d.drawImage(image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n    }\n\n}\n",
      "CollisionChecker.java": "public class CollisionChecker {\n\n    GamePanel gp;\n    public int damageCooldown = 0;\n    public int damageCooldownTime = 60; // 1 second at 60 FPS\n    public CollisionChecker(GamePanel gp) {\n        this.gp = gp;\n    }\n    public void checkTile(Entity entity){\n        // Reset collision state\n        entity.collisionOn = false;\n        \n        // Skip collision check if solid is null\n        if (entity.solid == null) {\n            return;\n        }\n        \n        // Skip collision check if direction is null\n        if (entity.direction == null) {\n            entity.direction = \"down\"; // Set default direction\n        }\n        \n        // Calculate entity's collision box corners\n        int entityLeftWorldX = entity.worldX + entity.solid.x;\n        int entityRightWorldX = entityLeftWorldX + entity.solid.width;\n        int entityTopWorldY = entity.worldY + entity.solid.y;\n        int entityBottomWorldY = entityTopWorldY + entity.solid.height;\n        \n        // Calculate tile coordinates for all corners\n        int entityLeftCol = entityLeftWorldX / gp.tilesize;\n        int entityRightCol = entityRightWorldX / gp.tilesize;\n        int entityTopRow = entityTopWorldY / gp.tilesize;\n        int entityBottomRow = entityBottomWorldY / gp.tilesize;\n        \n        // Check if any corner is outside map boundaries\n        if (entityLeftCol < 0 || entityRightCol >= gp.worldColumn || \n            entityTopRow < 0 || entityBottomRow >= gp.worldRow) {\n            entity.collisionOn = true;\n            return;\n        }\n\n        // Check tile collisions based on direction\n        switch (entity.direction) {\n            case \"up\":\n                entityTopRow = (entityTopWorldY - entity.speed) / gp.tilesize;\n                if (entityTopRow >= 0) {\n                    // Check all tiles that the entity might collide with\n                    for (int col = entityLeftCol; col <= entityRightCol; col++) {\n                        int tileNum = gp.tm.map[col][entityTopRow];\n                        if (gp.tm.tile[tileNum].collision) {\n                            entity.collisionOn = true;\n                            return;\n                        }\n                    }\n                }\n                break;\n            case \"down\":\n                entityBottomRow = (entityBottomWorldY + entity.speed) / gp.tilesize;\n                if (entityBottomRow < gp.worldRow) {\n                    // Check all tiles that the entity might collide with\n                    for (int col = entityLeftCol; col <= entityRightCol; col++) {\n                        int tileNum = gp.tm.map[col][entityBottomRow];\n                        if (gp.tm.tile[tileNum].collision) {\n                            entity.collisionOn = true;\n                            return;\n                        }\n                    }\n                }\n                break;\n            case \"left\":\n                entityLeftCol = (entityLeftWorldX - entity.speed) / gp.tilesize;\n                if (entityLeftCol >= 0) {\n                    // Check all tiles that the entity might collide with\n                    for (int row = entityTopRow; row <= entityBottomRow; row++) {\n                        int tileNum = gp.tm.map[entityLeftCol][row];\n                        if (gp.tm.tile[tileNum].collision) {\n                            entity.collisionOn = true;\n                            return;\n                        }\n                    }\n                }\n                break;\n            case \"right\":\n                entityRightCol = (entityRightWorldX + entity.speed) / gp.tilesize;\n                if (entityRightCol < gp.worldColumn) {\n                    // Check all tiles that the entity might collide with\n                    for (int row = entityTopRow; row <= entityBottomRow; row++) {\n                        int tileNum = gp.tm.map[entityRightCol][row];\n                        if (gp.tm.tile[tileNum].collision) {\n                            entity.collisionOn = true;\n                            return;\n                        }\n                    }\n                }\n                break;\n        }    \n    }\n    public void checkZombie(Zombie z){\n        // Calculate centers of shooter and zombie\n        int shooterCenterX = gp.shooter.worldX + gp.tilesize/2;\n        int shooterCenterY = gp.shooter.worldY + gp.tilesize/2;\n        int zombieCenterX = z.worldX + gp.tilesize/2;\n        int zombieCenterY = z.worldY + gp.tilesize/2;\n        \n        // Calculate distance between centers\n        double dx = shooterCenterX - zombieCenterX;\n        double dy = shooterCenterY - zombieCenterY;\n        double distance = Math.sqrt(dx*dx + dy*dy);\n        \n        // Check for collision (using half tile size as collision radius)\n        if (distance < gp.tilesize) {\n            // Only apply damage if cooldown is 0\n            if(damageCooldown == 0) {\n                // Apply damage to the shooter\n                gp.shooter.health -= z.damage;\n                \n                // Show damage message\n                gp.ui.showMessage(\"You took \" + z.damage + \" damage!\");\n                \n                // Set cooldown\n                damageCooldown = damageCooldownTime;\n                \n                // Check if player died\n                if(gp.shooter.health <= 0) {\n                    gp.shooter.health = 0;\n                    gp.gameState = gp.gameOverState;\n                }\n            }\n        }\n        \n        // Decrease cooldown if it's greater than 0\n        if(damageCooldown > 0) {\n            damageCooldown--;\n        }\n    }\n\n    public void checkBulletCollisions() {\n        // Check each bullet against each zombie\n        for(int i = gp.shooter.bullets.size()-1; i >= 0; i--) {\n            Bullet bullet = gp.shooter.bullets.get(i);\n            \n            // Calculate bullet's center position\n            int bulletCenterX = bullet.worldX + bullet.size/2;\n            int bulletCenterY = bullet.worldY + bullet.size/2;\n\n            // Check collision with each zombie\n            for(int j = 0; j < gp.zombies.length; j++) {\n                if(gp.zombies[j] != null) {\n                    // Calculate zombie's center position\n                    int zombieCenterX = gp.zombies[j].worldX + gp.tilesize/2;\n                    int zombieCenterY = gp.zombies[j].worldY + gp.tilesize/2;\n                    \n                    // Calculate distance between centers\n                    double dx = bulletCenterX - zombieCenterX;\n                    double dy = bulletCenterY - zombieCenterY;\n                    double distance = Math.sqrt(dx*dx + dy*dy);\n                    \n                    // Check for collision (using half tile size as collision radius)\n                    if (distance < gp.tilesize) {\n                        // Apply damage to zombie\n                        gp.zombies[j].health -= bullet.damage;\n                        \n                        // If it's a rocket bullet, apply area damage\n                        if (bullet instanceof RocketBullet) {\n                            applyAreaDamage(bulletCenterX, bulletCenterY, 100, 20); // 100 pixel radius, 20 damage\n                        }\n                        \n                        // Remove bullet if it's not a sniper bullet\n                        if (!(bullet instanceof SniperBullet)) {\n                            bullet.active = false;\n                        }\n                        \n                        // Check if zombie died\n                        if(gp.zombies[j].health <= 0) {\n                            // If it's an acid spitting zombie, apply acid area damage\n                            if (gp.zombies[j] instanceof AsitTukurenZombi) {\n                                applyAcidAreaDamage(zombieCenterX, zombieCenterY);\n                            }\n                            \n                            // Add points based on zombie type\n                            if (gp.zombies[j] instanceof NormalZombi) {\n                                gp.currentScore += 3;\n                            } else if (gp.zombies[j] instanceof TankZombi) {\n                                gp.currentScore += 5;\n                            } else if (gp.zombies[j] instanceof SurungeZombi) {\n                                gp.currentScore += 6;\n                            } else if (gp.zombies[j] instanceof AsitTukurenZombi) {\n                                gp.currentScore += 8;\n                            }\n                            \n                            // Update high score if current score is higher\n                            if (gp.currentScore > gp.highScore) {\n                                gp.highScore = gp.currentScore;\n                                // Save new high score to file\n                                try {\n                                    java.io.FileWriter writer = new java.io.FileWriter(\"HighScore.txt\");\n                                    writer.write(String.valueOf(gp.highScore));\n                                    writer.close();\n                                } catch (Exception e) {\n                                    System.out.println(\"Error saving high score: \" + e.getMessage());\n                                }\n                            }\n                            \n                            gp.zombies[j] = null;\n                            gp.zombiesAlive--; // Decrease the count of alive zombies\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Method to apply area damage from rocket explosions\n    private void applyAreaDamage(int centerX, int centerY, int radius, int damage) {\n        // Check damage to player\n        int playerCenterX = gp.shooter.worldX + gp.tilesize/2;\n        int playerCenterY = gp.shooter.worldY + gp.tilesize/2;\n        double dx = playerCenterX - centerX;\n        double dy = playerCenterY - centerY;\n        double distance = Math.sqrt(dx*dx + dy*dy);\n        if (distance < radius) {\n            gp.shooter.health -= damage;\n            gp.ui.showMessage(\"You took \" + damage + \" damage from rocket explosion!\");\n            if (gp.shooter.health <= 0) {\n                gp.shooter.health = 0;\n                gp.gameState = gp.gameOverState;\n            }\n        }\n\n        // Check damage to zombies\n        for (int i = 0; i < gp.zombies.length; i++) {\n            if (gp.zombies[i] != null) {\n                int zombieCenterX = gp.zombies[i].worldX + gp.tilesize/2;\n                int zombieCenterY = gp.zombies[i].worldY + gp.tilesize/2;\n                dx = zombieCenterX - centerX;\n                dy = zombieCenterY - centerY;\n                distance = Math.sqrt(dx*dx + dy*dy);\n                if (distance < radius) {\n                    gp.zombies[i].health -= damage;\n                }\n            }\n        }\n    }\n\n    // Method to apply acid area damage when acid spitting zombie dies\n    private void applyAcidAreaDamage(int centerX, int centerY) {\n        int radius = 150; // Acid spread radius\n        int damage = 15; // Acid damage\n\n        // Check damage to player\n        int playerCenterX = gp.shooter.worldX + gp.tilesize/2;\n        int playerCenterY = gp.shooter.worldY + gp.tilesize/2;\n        double dx = playerCenterX - centerX;\n        double dy = playerCenterY - centerY;\n        double distance = Math.sqrt(dx*dx + dy*dy);\n        if (distance < radius) {\n            gp.shooter.health -= damage;\n            gp.ui.showMessage(\"You took \" + damage + \" damage from acid splash!\");\n            if (gp.shooter.health <= 0) {\n                gp.shooter.health = 0;\n                gp.gameState = gp.gameOverState;\n            }\n        }\n\n        // Check damage to other zombies\n        for (int i = 0; i < gp.zombies.length; i++) {\n            if (gp.zombies[i] != null) {\n                int zombieCenterX = gp.zombies[i].worldX + gp.tilesize/2;\n                int zombieCenterY = gp.zombies[i].worldY + gp.tilesize/2;\n                dx = zombieCenterX - centerX;\n                dy = zombieCenterY - centerY;\n                distance = Math.sqrt(dx*dx + dy*dy);\n                if (distance < radius) {\n                    gp.zombies[i].health -= damage;\n                }\n            }\n        }\n    }\n\n    public void checkZombieTile(Zombie zombie) {\n        // Calculate zombie's collision box corners\n        int entityLeftWorldX = zombie.worldX + zombie.solid.x;\n        int entityRightWorldX = entityLeftWorldX + zombie.solid.width;\n        int entityTopWorldY = zombie.worldY + zombie.solid.y;\n        int entityBottomWorldY = entityTopWorldY + zombie.solid.height;\n\n        // Calculate tile coordinates\n        int entityLeftCol = entityLeftWorldX / gp.tilesize;\n        int entityRightCol = entityRightWorldX / gp.tilesize;\n        int entityTopRow = entityTopWorldY / gp.tilesize;\n        int entityBottomRow = entityBottomWorldY / gp.tilesize;\n\n        // Add bounds checking\n        if (entityLeftCol < 0 || entityRightCol >= gp.worldColumn || \n            entityTopRow < 0 || entityBottomRow >= gp.worldRow) {\n            zombie.collisionOn = true;\n            return;\n        }\n\n        int tileNum1, tileNum2;\n\n        switch(zombie.direction) {\n            case \"up\":\n                entityTopRow = (entityTopWorldY - zombie.velocity) / gp.tilesize;\n                if (entityTopRow >= 0) {\n                    tileNum1 = gp.tm.map[entityLeftCol][entityTopRow];\n                    tileNum2 = gp.tm.map[entityRightCol][entityTopRow];\n                    if(gp.tm.tile[tileNum1].collision == true || gp.tm.tile[tileNum2].collision == true) {\n                        zombie.collisionOn = true;\n                    }\n                }\n                break;\n            case \"down\":\n                entityBottomRow = (entityBottomWorldY + zombie.velocity) / gp.tilesize;\n                if (entityBottomRow < gp.worldRow) {\n                    tileNum1 = gp.tm.map[entityLeftCol][entityBottomRow];\n                    tileNum2 = gp.tm.map[entityRightCol][entityBottomRow];\n                    if(gp.tm.tile[tileNum1].collision == true || gp.tm.tile[tileNum2].collision == true) {\n                        zombie.collisionOn = true;\n                    }\n                }\n                break;\n            case \"left\":\n                entityLeftCol = (entityLeftWorldX - zombie.velocity) / gp.tilesize;\n                if (entityLeftCol >= 0) {\n                    tileNum1 = gp.tm.map[entityLeftCol][entityTopRow];\n                    tileNum2 = gp.tm.map[entityLeftCol][entityBottomRow];\n                    if(gp.tm.tile[tileNum1].collision == true || gp.tm.tile[tileNum2].collision == true) {\n                        zombie.collisionOn = true;\n                    }\n                }\n                break;\n            case \"right\":\n                entityRightCol = (entityRightWorldX + zombie.velocity) / gp.tilesize;\n                if (entityRightCol < gp.worldColumn) {\n                    tileNum1 = gp.tm.map[entityRightCol][entityTopRow];\n                    tileNum2 = gp.tm.map[entityRightCol][entityBottomRow];\n                    if(gp.tm.tile[tileNum1].collision == true || gp.tm.tile[tileNum2].collision == true) {\n                        zombie.collisionOn = true;\n                    }\n                }\n                break;\n        }\n    }\n\n}\n",
      "Chest.java": "import java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\n\npublic class Chest {\n    public GamePanel gp;\n    public BufferedImage image;\n    public int worldX, worldY;\n    public Rectangle solid;\n    public boolean active = true;\n    \n    public Chest(GamePanel gp, int x, int y) {\n        this.gp = gp;\n        this.worldX = x;\n        this.worldY = y;\n        this.image = gp.tm.chestImage;\n        this.solid = new Rectangle(worldX, worldY, gp.tilesize, gp.tilesize);\n    }\n    \n    public void update() {\n        // Check collision with player\n        if (active && solid.intersects(gp.shooter.getBounds())) {\n            // Give ammo based on current wave\n            switch(gp.currentWave) {\n                case 2: // After wave 1\n                    gp.shooter.increaseWeaponAmmo(1, gp.shooter.getWeapons()[1].magazineSize * 3); // Give 2 magazines to PiyadeTufegi\n                    gp.ui.showMessage(\"Found 2 Piyade Tufegi magazines!\");\n                    break;\n                case 4: // After wave 3\n                    gp.shooter.increaseWeaponAmmo(2, gp.shooter.getWeapons()[2].magazineSize * 3); // Give 2 magazines to PompaliTufek\n                    gp.ui.showMessage(\"Found 2 Pompali Tufek magazines!\");\n                    break;\n                case 6: // After wave 5\n                    gp.shooter.increaseWeaponAmmo(3, gp.shooter.getWeapons()[3].magazineSize * 3); // Give 2 magazines to KeskinNisanciTufegi\n                    gp.ui.showMessage(\"Found 2 Keskin Nisanci Tufegi magazines!\");\n                    break;\n                case 11: // After wave 10\n                    gp.shooter.increaseWeaponAmmo(4, gp.shooter.getWeapons()[4].magazineSize * 3); // Give 2 magazines to Roketatar\n                    gp.ui.showMessage(\"Found 2 Roketatar magazines!\");\n                    break;\n                default:\n                    // For other waves, give random ammo to weapons unlocked up to this point\n                    int maxUnlockedWeapon = 0;\n                    if (gp.currentWave >= 11) maxUnlockedWeapon = 4; // All weapons unlocked\n                    else if (gp.currentWave >= 6) maxUnlockedWeapon = 3; // Up to KeskinNisanciTufegi\n                    else if (gp.currentWave >= 4) maxUnlockedWeapon = 2; // Up to PompaliTufek\n                    else if (gp.currentWave >= 2) maxUnlockedWeapon = 1; // Up to PiyadeTufegi\n                    else maxUnlockedWeapon = 0; // Only pistol\n\n                    if (maxUnlockedWeapon > 0) {\n                        // Give 2 magazines to a random unlocked weapon\n                        int randomIndex = (int)(Math.random() * maxUnlockedWeapon) + 1; // +1 because 0 is pistol\n                        gp.shooter.increaseWeaponAmmo(randomIndex, gp.shooter.getWeapons()[randomIndex].magazineSize * 3);\n                        \n                        String weaponName = \"Unknown\";\n                        if (gp.shooter.getWeapons()[randomIndex] instanceof PiyadeTufegi) weaponName = \"Piyade Tufegi\";\n                        else if (gp.shooter.getWeapons()[randomIndex] instanceof PompaliTufek) weaponName = \"Pompali Tufek\";\n                        else if (gp.shooter.getWeapons()[randomIndex] instanceof KeskinNisanciTufegi) weaponName = \"Keskin Nisanci Tufegi\";\n                        else if (gp.shooter.getWeapons()[randomIndex] instanceof Roketatar) weaponName = \"Roketatar\";\n                        gp.ui.showMessage(\"Found 2 \" + weaponName + \" magazines!\");\n                    }\n                    break;\n            }\n            active = false;\n        }\n    }\n    \n    public void draw(java.awt.Graphics2D g2d) {\n        if (active) {\n            int screenX = worldX - gp.shooter.worldX + gp.shooter.screenX;\n            int screenY = worldY - gp.shooter.worldY + gp.shooter.screenY;\n            \n            // Draw the chest image\n            g2d.drawImage(image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n            \n            // Draw a border around the chest to make it more visible\n            g2d.setColor(java.awt.Color.BLACK);\n            g2d.drawRect(screenX, screenY, gp.tilesize, gp.tilesize);\n        }\n    }\n} ",
      "KeskinNisanciTufegi.java": "public class KeskinNisanciTufegi extends Weapon {\n    public KeskinNisanciTufegi() {\n        super(50, 5, 0, 10); // damage, magazine size, total ammo, fire rate\n        this.reloadTime = 2500; // 2.5 seconds reload time\n    }\n\n    @Override\n    public void shoot() {\n        if (currentAmmo > 0) {\n            currentAmmo--;\n        }\n    }\n\n    @Override\n    public boolean isRocket() {\n        return false;\n    }\n}\n",
      "TileManager.java": "import java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\nimport javax.imageio.ImageIO;\n\npublic class TileManager {\n\n    GamePanel gp;\n    public Tile[] tile;\n    public int map[][];\n    public BufferedImage chestImage;\n\n    public TileManager(GamePanel gp) {\n        this.gp = gp;\n        tile = new Tile[10];\n        map = new int[gp.worldColumn][gp.worldRow];\n        getTileImage();\n        loadMap(\"Map.txt\");\n    }\n\n    public void loadMap(String filePath) {\n        try {\n            // First, create a border of walls\n            for(int col = 0; col < gp.worldColumn; col++) {\n                map[col][0] = 1; // Top border\n                map[col][gp.worldRow-1] = 1; // Bottom border\n            }\n            for(int row = 0; row < gp.worldRow; row++) {\n                map[0][row] = 1; // Left border\n                map[gp.worldColumn-1][row] = 1; // Right border\n            }\n\n            // Then load the rest of the map\n            Scanner scan = new Scanner(new FileInputStream(filePath));\n            for (int row = 1; row < gp.worldRow-1; row++) {\n                String line = scan.nextLine();\n                for (int col = 1; col < gp.worldColumn-1; col++) {\n                    char c = line.charAt(col-1);\n                    // Convert map characters to tile numbers\n                    switch(c) {\n                        case 'W': map[col][row] = 1; break; // Wall\n                        case 'G': map[col][row] = 0; break; // Grass\n                        case 'T': map[col][row] = 3; break; // Tree\n                        default: map[col][row] = 0; break; // Default to grass\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void getTileImage() {\n        try {\n            tile[0] = new Tile();\n            tile[0].image = ImageIO.read(getClass().getResourceAsStream(\"grass.png\"));\n\n            tile[1] = new Tile();\n            tile[1].image = ImageIO.read(getClass().getResourceAsStream(\"wall.png\"));\n            tile[1].collision = true;\n\n            tile[2] = new Tile();\n            tile[2].image = ImageIO.read(getClass().getResourceAsStream(\"water.png\"));\n            tile[2].collision = true;\n\n            tile[3] = new Tile();\n            tile[3].image = ImageIO.read(getClass().getResourceAsStream(\"tree.png\"));\n            tile[3].collision = true;\n\n            tile[4] = new Tile();\n            tile[4].image = ImageIO.read(getClass().getResourceAsStream(\"grass.png\"));\n\n            tile[5] = new Tile();\n            tile[5].image = ImageIO.read(getClass().getResourceAsStream(\"wall.png\"));\n            tile[5].collision = true;\n\n            tile[6] = new Tile();\n            tile[6].image = ImageIO.read(getClass().getResourceAsStream(\"water.png\"));\n            tile[6].collision = true;\n\n            tile[7] = new Tile();\n            tile[7].image = ImageIO.read(getClass().getResourceAsStream(\"tree.png\"));\n            tile[7].collision = true;\n\n            tile[8] = new Tile();\n            tile[8].image = ImageIO.read(getClass().getResourceAsStream(\"grass.png\"));\n\n            tile[9] = new Tile();\n            tile[9].image = ImageIO.read(getClass().getResourceAsStream(\"wall.png\"));\n            tile[9].collision = true;\n\n            // Try to load chest image, if fails create a default colored rectangle\n            try {\n                chestImage = ImageIO.read(getClass().getResourceAsStream(\"chest.png\"));\n            } catch (Exception e) {\n                System.out.println(\"Warning: Could not load chest.png, using default colored rectangle\");\n                chestImage = new BufferedImage(gp.tilesize, gp.tilesize, BufferedImage.TYPE_INT_ARGB);\n                java.awt.Graphics2D g2d = chestImage.createGraphics();\n                g2d.setColor(java.awt.Color.YELLOW);\n                g2d.fillRect(0, 0, gp.tilesize, gp.tilesize);\n                g2d.setColor(java.awt.Color.BLACK);\n                g2d.drawRect(0, 0, gp.tilesize-1, gp.tilesize-1);\n                g2d.dispose();\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void draw(Graphics2D g2d) {\n        for (int row = 0; row < gp.worldRow; row++) {\n            for (int col = 0; col < gp.worldColumn; col++) {\n                int worldX = col * gp.tilesize;\n                int worldY = row * gp.tilesize;\n                int screenX = worldX - gp.shooter.worldX + gp.shooter.screenX;\n                int screenY = worldY - gp.shooter.worldY + gp.shooter.screenY;\n\n                if (map[col][row] == 0) {\n                    g2d.drawImage(tile[0].image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n                } else if (map[col][row] == 1) {\n                    g2d.drawImage(tile[1].image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n                } else if (map[col][row] == 2) {\n                    g2d.drawImage(tile[2].image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n                } else if (map[col][row] == 3) {\n                    g2d.drawImage(tile[3].image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n                } else if (map[col][row] == 4) {\n                    g2d.drawImage(tile[4].image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n                } else if (map[col][row] == 5) {\n                    g2d.drawImage(tile[5].image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n                } else if (map[col][row] == 6) {\n                    g2d.drawImage(tile[6].image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n                } else if (map[col][row] == 7) {\n                    g2d.drawImage(tile[7].image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n                } else if (map[col][row] == 8) {\n                    g2d.drawImage(tile[8].image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n                } else if (map[col][row] == 9) {\n                    g2d.drawImage(tile[9].image, screenX, screenY, gp.tilesize, gp.tilesize, null);\n                }\n            }\n        }\n    }\n}\n\n\n",
      "GameState.java": "import java.io.Serializable;\n\npublic class GameState implements Serializable {\n    private static final long serialVersionUID = 1L;\n    \n    // Version tracking\n    public int version;\n    \n    // Player data\n    public int playerX;\n    public int playerY;\n    public int playerHealth;\n    \n    // Game progress\n    public int currentWave;\n    public int currentScore;\n    \n    // Weapon data\n    public boolean[] unlockedWeapons;\n    public int[] weaponAmmo;\n    \n    public GameState(int playerX, int playerY, int playerHealth, \n                    int currentWave, int currentScore,\n                    boolean[] unlockedWeapons, int[] weaponAmmo,\n                    int version) {\n        this.playerX = playerX;\n        this.playerY = playerY;\n        this.playerHealth = playerHealth;\n        this.currentWave = currentWave;\n        this.currentScore = currentScore;\n        this.unlockedWeapons = unlockedWeapons.clone();\n        this.weaponAmmo = weaponAmmo.clone();\n        this.version = version;\n    }\n} ",
      "AsitTukurenZombi.java": "import java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport javax.imageio.ImageIO;\n\npublic class AsitTukurenZombi extends Zombie {\n    private ArrayList<AcidProjectile> acidProjectiles = new ArrayList<>();\n    private long lastShotTime = 0;\n    private int fireRate = 2000; // Shoot every 2 seconds\n    private int shootRange = 300; // Range at which the zombie will shoot\n    private boolean isExploding = false;\n    private int explosionTimer = 0;\n    private int explosionDuration = 60; // 1 second at 60 FPS\n    private int explosionRadius = 100; // Initial explosion radius\n    private int maxExplosionRadius = 200; // Maximum explosion radius\n    private int acidProjectileSpeed = 5;\n    private int acidProjectileSize = 20;\n    private int acidProjectileDamage = 20;\n    private int acidProjectileDuration = 60; // 1 second at 60 FPS\n    private int acidProjectileTimer = 0;\n    private int acidProjectileCooldown = 60; // 1 second between shots\n    private boolean active = true;\n\n    public AsitTukurenZombi(GamePanel gp,int n) {\n        super(gp, n);\n        health = 30;\n        damage = 6;\n        velocity = 2;\n        direction = \"down\";\n        counter = 0;\n        num = 1;\n        collisionOn = false;\n\n        this.solid = new Rectangle(3, 18, 42, 30);\n\n        getImage();\n    }\n\n    public void getImage(){\n        try {\n            System.out.println(\"Loading Acid Spitting Zombie images...\");\n            // Use down images for all directions since we don't have up images\n            up1=ImageIO.read(getClass().getResourceAsStream(\"redslime_down_1.png\"));\n            System.out.println(\"Loaded redslime_down_1.png for up\");\n            up2=ImageIO.read(getClass().getResourceAsStream(\"redslime_down_2.png\"));\n            System.out.println(\"Loaded redslime_down_2.png for up\");\n            down1=ImageIO.read(getClass().getResourceAsStream(\"redslime_down_1.png\"));\n            System.out.println(\"Loaded redslime_down_1.png\");\n            down2=ImageIO.read(getClass().getResourceAsStream(\"redslime_down_2.png\"));\n            System.out.println(\"Loaded redslime_down_2.png\");\n            left1=ImageIO.read(getClass().getResourceAsStream(\"redslime_down_1.png\"));\n            System.out.println(\"Loaded redslime_down_1.png for left\");\n            left2=ImageIO.read(getClass().getResourceAsStream(\"redslime_down_2.png\"));\n            System.out.println(\"Loaded redslime_down_2.png for left\");\n            right1=ImageIO.read(getClass().getResourceAsStream(\"redslime_down_1.png\"));\n            System.out.println(\"Loaded redslime_down_1.png for right\");\n            right2=ImageIO.read(getClass().getResourceAsStream(\"redslime_down_2.png\"));\n            System.out.println(\"Loaded redslime_down_2.png for right\");\n            System.out.println(\"All Acid Spitting Zombie images loaded successfully\");\n        } catch (IOException e) {\n            System.out.println(\"Error loading Acid Spitting Zombie images: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public void setAction() {\n        // Zombinin oyuncuya olan uzaklığını hesapla\n        int xDistance = gp.shooter.worldX - worldX;\n        int yDistance = gp.shooter.worldY - worldY;\n\n        // Zombinin hareket yönünü belirle\n        if(Math.abs(xDistance) > Math.abs(yDistance)) {\n            // X ekseni farkı daha büyükse, öncelikle X yönünde hareket et\n            if(xDistance < 0) {\n                direction = \"left\";\n            } else {\n                direction = \"right\";\n            }\n        } else {\n            // Y ekseni farkı daha büyükse veya eşitse, öncelikle Y yönünde hareket et\n            if(yDistance < 0) {\n                direction = \"up\";\n            } else {\n                direction = \"down\";\n            }\n        }\n\n        // Her 60 frame'de bir yön güncelleme yapılsın\n        counter++;\n        if(counter > 60) {\n            counter = 0;\n        }\n    }\n\n    @Override\n    public void takeDamage(int damage) {\n        health -= damage;\n        if (health <= 0) {\n            health = 0;\n            isExploding = true;\n            explosionTimer = 0;\n        }\n    }\n\n    @Override\n    public void update() {\n        if (!active) {\n            return;\n        }\n\n        // Only update if zombie is alive\n        if (health > 0) {\n            setAction();\n            \n            // Check if player is in range to shoot\n            int xDistance = gp.shooter.worldX - worldX;\n            int yDistance = gp.shooter.worldY - worldY;\n            double distance = Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n            \n            // If player is in range, shoot at them\n            if (distance <= shootRange) {\n                long currentTime = System.currentTimeMillis();\n                if (currentTime - lastShotTime >= fireRate) {\n                    shoot();\n                    lastShotTime = currentTime;\n                }\n            }\n            \n            // Update acid projectiles\n            for (int i = acidProjectiles.size() - 1; i >= 0; i--) {\n                AcidProjectile projectile = acidProjectiles.get(i);\n                projectile.update();\n                if (!projectile.active) {\n                    acidProjectiles.remove(i);\n                }\n            }\n            \n            collisionOn = false;\n            gp.cc.checkTile(this);\n\n            if (!collisionOn) {\n                switch (direction) {\n                    case \"up\":\n                        worldY -= velocity;\n                        break;\n                    case \"down\":\n                        worldY += velocity;\n                        break;\n                    case \"left\":\n                        worldX -= velocity;\n                        break;\n                    case \"right\":\n                        worldX += velocity;\n                        break;\n                }\n            }\n\n            counter++;\n            if (counter > 12) {\n                num = (num == 1) ? 2 : 1;\n                counter = 0;\n            }\n        } else if (isExploding) {\n            // Update explosion\n            explosionTimer++;\n            \n            // Calculate current explosion radius based on timer\n            explosionRadius = (int)(maxExplosionRadius * (1.0 - (double)explosionTimer / explosionDuration));\n            \n            // Apply damage to nearby entities\n            int centerX = worldX + gp.tilesize/2;\n            int centerY = worldY + gp.tilesize/2;\n            \n            // Damage player if in range\n            int playerCenterX = gp.shooter.worldX + gp.tilesize/2;\n            int playerCenterY = gp.shooter.worldY + gp.tilesize/2;\n            double dx = playerCenterX - centerX;\n            double dy = playerCenterY - centerY;\n            double distance = Math.sqrt(dx*dx + dy*dy);\n            \n            if (distance < explosionRadius) {\n                int damage = (int)(30 * (1.0 - distance / maxExplosionRadius));\n                gp.shooter.health -= damage;\n                if (gp.shooter.health <= 0) {\n                    gp.shooter.health = 0;\n                    gp.gameState = gp.gameOverState;\n                }\n            }\n            \n            // Damage other zombies\n            for (Zombie otherZombie : gp.zombies) {\n                if (otherZombie != this && otherZombie != null && otherZombie.health > 0) {\n                    int zombieCenterX = otherZombie.worldX + gp.tilesize/2;\n                    int zombieCenterY = otherZombie.worldY + gp.tilesize/2;\n                    dx = zombieCenterX - centerX;\n                    dy = zombieCenterY - centerY;\n                    distance = Math.sqrt(dx*dx + dy*dy);\n                    \n                    if (distance < explosionRadius) {\n                        int damage = (int)(30 * (1.0 - distance / maxExplosionRadius));\n                        otherZombie.takeDamage(damage);\n                    }\n                }\n            }\n            \n            // End explosion after duration\n            if (explosionTimer >= explosionDuration) {\n                active = false;\n            }\n        }\n    }\n\n    private void shoot() {\n        // Calculate angle to player\n        double dx = gp.shooter.worldX - worldX;\n        double dy = gp.shooter.worldY - worldY;\n        double angle = Math.atan2(dy, dx);\n        \n        // Create new acid projectile\n        acidProjectiles.add(new AcidProjectile(gp, worldX, worldY, angle));\n    }\n\n    @Override\n    public void draw(Graphics2D g2) {\n        if (!active) {\n            return;\n        }\n\n        if (health > 0) {\n            // Draw acid projectiles first\n            for (AcidProjectile projectile : acidProjectiles) {\n                projectile.draw(g2);\n            }\n            \n            // Then draw the zombie\n            super.draw(g2);\n        } else if (isExploding) {\n            // Draw acid explosion effect\n            int screenX = worldX - gp.shooter.worldX + gp.shooter.screenX;\n            int screenY = worldY - gp.shooter.worldY + gp.shooter.screenY;\n            \n            // Calculate alpha based on explosion timer\n            float alpha = 1.0f - (float)explosionTimer / explosionDuration;\n            \n            // Draw multiple circles with different shades of green for the explosion effect\n            for (int i = 0; i < 3; i++) {\n                float currentAlpha = alpha * (1.0f - (float)i / 3);\n                int size = (int)(explosionRadius * (1.0f - (float)i / 3));\n                \n                // Create a green color with alpha\n                Color greenColor = new Color(0, 255, 0, (int)(currentAlpha * 255));\n                g2.setColor(greenColor);\n                g2.fillOval(screenX - size/2, screenY - size/2, size, size);\n                \n                // Add a brighter center\n                if (i == 0) {\n                    g2.setColor(new Color(150, 255, 150, (int)(currentAlpha * 255)));\n                    g2.fillOval(screenX - size/4, screenY - size/4, size/2, size/2);\n                }\n            }\n        }\n    }\n}\n",
      "MouseHandler.java": "import java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseMotionListener;\n\npublic class MouseHandler extends MouseAdapter implements MouseMotionListener {\n    GamePanel gp;\n    public int mouseX, mouseY;\n    public int mouseWorldX, mouseWorldY;\n    public boolean rightPressed = false;\n    public boolean leftPressed = false;\n\n    public MouseHandler(GamePanel gp) {\n        this.gp = gp;\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e) {\n        // Not used\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        if(e.getButton() == MouseEvent.BUTTON3) { // Right click\n            rightPressed = true;\n        }\n        else if(e.getButton() == MouseEvent.BUTTON1) { // Left click\n            leftPressed = true;\n            updateMousePosition(e);\n        }\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n        if(e.getButton() == MouseEvent.BUTTON3) { // Right click\n            rightPressed = false;\n        }\n        else if(e.getButton() == MouseEvent.BUTTON1) { // Left click\n            leftPressed = false;\n        }\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e) {\n        // Not used\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e) {\n        // Not used\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        updateMousePosition(e);\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e) {\n        updateMousePosition(e);\n    }\n\n    private void updateMousePosition(MouseEvent e) {\n        mouseX = e.getX();\n        mouseY = e.getY();\n        \n        // Convert screen coordinates to world coordinates\n        mouseWorldX = mouseX - gp.screenWidth/2 + gp.shooter.worldX;\n        mouseWorldY = mouseY - gp.screenHeight/2 + gp.shooter.worldY;\n        \n        System.out.println(\"Mouse world position: \" + mouseWorldX + \", \" + mouseWorldY);\n    }\n} "
    },
    {
      "id": "2786122",
      "Font.java": "package Main;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.util.HashMap;\nimport javax.imageio.ImageIO;\n\npublic class Font {\n\n    private HashMap<Character, BufferedImage> charImages = new HashMap<>();\n\n    public Font() {\n        loadFontImages();\n    }\n\n    private void loadFontImages() {\n        String chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ:/?.∞\";  \n        for (char c : chars.toCharArray()) {\n            try {\n                String path = \"/Font/\" + getFileName(c);\n                charImages.put(c, ImageIO.read(getClass().getResource(path)));\n            } catch (Exception e) {\n                System.out.println(\"Font image missing for: \" + c);\n            }\n        }\n    }\n\n    private String getFileName(char c) {\n        if (c == ':') \n            return \"colon.png\";  \n        \n        if (c == '/') \n            return \"slash.png\"; \n    \n        if (c == '?') \n            return \"qm.png\";  \n    \n        if (c == '.') \n            return \"dot.png\";   \n    \n        if (c == '∞') \n            return \"inf.png\";\n        \n        return c + \".png\";\n    }\n\n    public void drawText(Graphics2D g, String text, int x, int y, int width, int height) {\n        int charWidth = 20;\n        for (char c : text.toCharArray()) {\n            BufferedImage img = charImages.get(c);\n            \n            if (img != null) {\n                g.drawImage(img, x, y,width,height, null);\n            }\n            x += charWidth;\n        }\n    }\n}",
      "WaveManager.java": "package Main;\n\nimport Zombies.*;\nimport Player.Player;\nimport Weapons.*;\n\npublic class WaveManager {\n    private GamePanel gamePanel;\n    public static int waveNumber = 0;\n\n    public WaveManager(GamePanel gamePanel) {\n        this.gamePanel = gamePanel;\n    }\n\n    public void update() {\n        if (gamePanel.zombies.isEmpty()) {\n            startNewWave();\n        }\n    }\n\n    public void startNewWave() {\n        waveNumber++;\n        spawnZombies();\n        waveRewards();\n    }\n\n    private void spawnZombies() {\n        gamePanel.zombies.clear();\n\n        int normalCount = Math.min(5 + waveNumber * 2, 50);\n        int crawlingCount = Math.min(waveNumber / 3, 15);\n        int tankCount = Math.min(waveNumber / 5, 5);\n        int corrosiveCount = Math.min(waveNumber / 4, 5);\n\n        for (int i = 0; i < normalCount; i++) {\n            int[] position = randomValidPosition();\n            gamePanel.zombies.add(new NormalZombie(position[0], position[1]));\n        }\n\n        for (int i = 0; i < crawlingCount; i++) {\n            int[] position = randomValidPosition();\n            gamePanel.zombies.add(new CrawlingZombie(position[0], position[1]));\n        }\n\n        for (int i = 0; i < tankCount; i++) {\n            int[] position = randomValidPosition();\n            gamePanel.zombies.add(new TankZombie(position[0], position[1]));\n        }\n\n        for (int i = 0; i < corrosiveCount; i++) {\n            int[] position = randomValidPosition();\n            gamePanel.zombies.add(new CorrosiveZombie(position[0], position[1]));\n        }\n    }\n\n    public void waveRewards() {\n        Player player = gamePanel.player;\n\n        switch (waveNumber) {\n            case 2:\n                player.addWeapon(new AssaultRifle());\n                break;\n\n            case 4:\n                player.addWeapon(new Shotgun());\n                break;\n\n            case 6:\n                player.addWeapon(new SniperRifle());\n                break;\n                \n            case 11:\n                player.addWeapon(new RocketLauncher());\n                break;\n        }\n    }\n\n    private int[] randomValidPosition() {\n        int x, y;\n        do {\n            x = (int) (Math.random() * gamePanel.worldWidth);\n            y = (int) (Math.random() * gamePanel.worldHeight);\n        } \n        while (!isValidSpawnLocation(x, y));\n            return new int[] { x, y };\n    }\n\n    private boolean isValidSpawnLocation(int x, int y) {\n        int tileX = x / gamePanel.tileSize;\n        int tileY = y / gamePanel.tileSize;\n\n        if (tileX < 0 || tileX >= gamePanel.maxWorldColumn || tileY < 0 || tileY >= gamePanel.maxWorldRow) {\n            return false;\n        }\n\n        int tileNumber = gamePanel.tileManager.mapTileNumber[tileY][tileX];\n\n        return tileNumber == 1;\n    }\n}",
      "SaveData.java": "package Main;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\npublic class SaveData implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    public Date saveDate;\n    public double playerX, playerY;\n    public int playerHealth;\n    public String currentWeapon;\n    public int waveNumber;\n    public int score;\n    public int killCounter;\n\n    public List<WeaponData> weapons = new ArrayList<>();\n    public List<ZombieData> zombies = new ArrayList<>();\n    public List<BulletData> bullets = new ArrayList<>();\n\n    public SaveData(double playerX, double playerY, int playerHealth, String currentWeapon, int waveNumber, Date saveDate , int score, int killCounter) {\n        this.playerX = playerX;\n        this.playerY = playerY;\n        this.playerHealth = playerHealth;\n        this.currentWeapon = currentWeapon;\n        this.waveNumber = waveNumber;\n        this.saveDate = saveDate;\n        this.score = score;\n        this.killCounter = killCounter;\n    }\n    \n    public static class WeaponData implements Serializable {\n        private static final long serialVersionUID = 1L;\n        public String weaponName;\n        public int bulletsLeft;\n        public int totalAmmo;\n\n        public WeaponData(String weaponName, int bulletsLeft, int totalAmmo) {\n            this.weaponName = weaponName;\n            this.bulletsLeft = bulletsLeft;\n            this.totalAmmo = totalAmmo;\n        }\n    }\n\n    public static class ZombieData implements Serializable {\n        private static final long serialVersionUID = 1L;\n        public double x, y;\n        public int health;\n        public int speed;\n        public int damage;\n        public String spritePath;\n        public String attackSpritePath;\n        public String hurtSpritePath;\n        public String deadSpritePath;\n        public int attackFrames;\n        public int hurtFrames;\n        public int deadFrames;\n        public int frameCount;\n        public int spriteWidth;\n        public int spriteHeight;\n        public boolean canBeKnockedBack;\n        public String zombieType;\n    \n        public ZombieData(double x, double y, int health, int speed, int damage, String spritePath, int frameCount, int spriteWidth, int spriteHeight, String attackSpritePath, int attackFrames, String hurtSpritePath, int hurtFrames, String deadSpritePath, int deadFrames, boolean canBeKnockedBack, String zombieType) {\n            this.x = x;\n            this.y = y;\n            this.health = health;\n            this.speed = speed;\n            this.damage = damage;\n            this.spritePath = spritePath;\n            this.frameCount = frameCount;\n            this.spriteWidth = spriteWidth;\n            this.spriteHeight = spriteHeight;\n            this.attackSpritePath = attackSpritePath;\n            this.attackFrames = attackFrames;\n            this.hurtSpritePath = hurtSpritePath;\n            this.hurtFrames = hurtFrames;\n            this.deadSpritePath = deadSpritePath;\n            this.deadFrames = deadFrames;\n            this.canBeKnockedBack = canBeKnockedBack;\n            this.zombieType = zombieType;\n        }\n    }\n    \n    public static class BulletData implements Serializable {\n        private static final long serialVersionUID = 1L;\n        public double x, y, angle;\n        public int speed;\n\n        public BulletData(double x, double y, double angle, int speed) {\n            this.x = x;\n            this.y = y;\n            this.angle = angle;\n            this.speed = speed;\n        }\n    }\n}",
      "UIManager.java": "package Main;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.*;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.text.SimpleDateFormat;\n\npublic class UIManager {\n    private Font font = new Font();\n    GamePanel gamePanel;\n    Graphics2D g2;\n    boolean gameFinished = false;\n    int volumeLevel = 6;\n\n    public int mainMenuselectedOption = 0;\n    public int loadGameSelectedOption = 0;\n    public int settingsSelectedOption = 0;\n    public int pauseMenuSelectedOption = 0;\n    public int confirmMenuSelectedOption = 0;\n    public int endMenuSelectedOption = 0;\n\n    Image backgroundGif,introGif,warningGif;\n    BufferedImage newGameImage, loadGameImage, settingsImage, exitImage, hackedImage, apocalyspeImage;\n    BufferedImage newGameSelectedImage, loadGameSelectedImage, settingsSelectedImage, exitSelectedImage, hackedSelectedImage, apocalyspeSelectedImage;\n    BufferedImage volumeImage, backImage, screenModeImage;\n    BufferedImage volumeSelectedImage, backSelectedImage, screenModeSelectedImage;\n    BufferedImage continueImage, mainMenuImage, saveGameImage, pausedImage;\n    BufferedImage continueSelectedImage, mainMenuSelectedImage, saveGameSelectedImage;\n\n    BufferedImage slot1Image, slot2Image, slot3Image;\n    BufferedImage slot1SelectedImage, slot2SelectedImage, slot3SelectedImage;\n\n    BufferedImage confirmImage, cancelImage;\n    BufferedImage confirmSelectedImage, cancelSelectedImage;\n\n    BufferedImage gameoverImage, restartImage;\n    BufferedImage restartSelectedImage;\n\n    public UIManager(GamePanel gamePanel) {\n        this.gamePanel = gamePanel;\n        try {\n            introGif = new ImageIcon(getClass().getResource(\"/Images/GFPRESENTS.gif\")).getImage();\n            warningGif = new ImageIcon(getClass().getResource(\"/Images/WARNING.gif\")).getImage();\n            backgroundGif = new ImageIcon(getClass().getResource(\"/Images/BACKGROUND.gif\")).getImage();\n\n            hackedImage = ImageIO.read(getClass().getResource(\"/Images/HACKED.png\"));\n            apocalyspeImage = ImageIO.read(getClass().getResource(\"/Images/APOCALYSPE.png\"));\n            newGameImage = ImageIO.read(getClass().getResource(\"/Images/NEWGAME.png\"));\n            loadGameImage = ImageIO.read(getClass().getResource(\"/Images/LOADGAME.png\"));\n            settingsImage = ImageIO.read(getClass().getResource(\"/Images/SETTINGS.png\"));\n            exitImage = ImageIO.read(getClass().getResource(\"/Images/EXIT.png\"));\n\n            newGameSelectedImage = ImageIO.read(getClass().getResource(\"/Images/NEWGAMESELECTED.png\"));\n            loadGameSelectedImage = ImageIO.read(getClass().getResource(\"/Images/LOADGAMESELECTED.png\"));\n            settingsSelectedImage = ImageIO.read(getClass().getResource(\"/Images/SETTINGSSELECTED.png\"));\n            exitSelectedImage = ImageIO.read(getClass().getResource(\"/Images/EXITSELECTED.png\"));\n\n            volumeImage = ImageIO.read(getClass().getResource(\"/Images/VOLUME.png\"));\n            screenModeImage = ImageIO.read(getClass().getResource(\"/Images/SCREENMODE.png\"));\n            backImage = ImageIO.read(getClass().getResource(\"/Images/BACK.png\"));\n\n            volumeSelectedImage = ImageIO.read(getClass().getResource(\"/Images/VOLUMESELECTED.png\"));\n            screenModeSelectedImage = ImageIO.read(getClass().getResource(\"/Images/SCREENMODESELECTED.png\"));\n            backSelectedImage = ImageIO.read(getClass().getResource(\"/Images/BACKSELECTED.png\"));\n\n            continueImage = ImageIO.read(getClass().getResource(\"/Images/CONTINUE.png\"));\n            saveGameImage = ImageIO.read(getClass().getResource(\"/Images/SAVEGAME.png\"));\n            mainMenuImage = ImageIO.read(getClass().getResource(\"/Images/MAINMENU.png\"));\n            pausedImage = ImageIO.read(getClass().getResource(\"/Images/PAUSED.png\"));\n\n            continueSelectedImage = ImageIO.read(getClass().getResource(\"/Images/CONTINUESELECTED.png\"));\n            saveGameSelectedImage = ImageIO.read(getClass().getResource(\"/Images/SAVEGAMESELECTED.png\"));\n            mainMenuSelectedImage = ImageIO.read(getClass().getResource(\"/Images/MAINMENUSELECTED.png\"));\n\n            slot1Image = ImageIO.read(getClass().getResource(\"/Images/SLOT1.png\"));\n            slot2Image = ImageIO.read(getClass().getResource(\"/Images/SLOT2.png\"));\n            slot3Image = ImageIO.read(getClass().getResource(\"/Images/SLOT3.png\"));\n\n            slot1SelectedImage = ImageIO.read(getClass().getResource(\"/Images/SLOT1SELECTED.png\"));\n            slot2SelectedImage = ImageIO.read(getClass().getResource(\"/Images/SLOT2SELECTED.png\"));\n            slot3SelectedImage = ImageIO.read(getClass().getResource(\"/Images/SLOT3SELECTED.png\"));\n\n            confirmImage = ImageIO.read(getClass().getResource(\"/Images/CONFIRM.png\"));\n            cancelImage = ImageIO.read(getClass().getResource(\"/Images/CANCEL.png\"));\n\n            confirmSelectedImage = ImageIO.read(getClass().getResource(\"/Images/CONFIRMSELECTED.png\"));\n            cancelSelectedImage = ImageIO.read(getClass().getResource(\"/Images/CANCELSELECTED.png\"));\n\n            gameoverImage = ImageIO.read(getClass().getResource(\"/Images/GAMEOVER.png\"));\n            restartImage = ImageIO.read(getClass().getResource(\"/Images/RESTART.png\"));\n\n            restartSelectedImage = ImageIO.read(getClass().getResource(\"/Images/RESTARTSELECTED.png\"));\n            \n        } catch(Exception e) {\n            e.getMessage();\n        }\n    }\n\n    public void draw(Graphics2D g2) {\n        this.g2 = g2;\n        g2.setColor(Color.white);\n\n        if (gamePanel.gameState == gamePanel.INTRO_STATE) {\n            drawIntroScreen();\n        }\n\n        else if (gamePanel.gameState == gamePanel.WARNING_STATE) {\n            drawWarningScreen();\n        }\n\n        else if (gamePanel.gameState == gamePanel.MENU_STATE) {\n            drawTitleScreen();\n        }\n\n        else if (gamePanel.gameState == gamePanel.LOAD_STATE) {\n            drawLoadMenu();\n        }\n\n        else if (gamePanel.gameState == gamePanel.SETTINGS_STATE) {\n            drawSettingsMenu();\n        }\n        \n        else if (gamePanel.gameState == gamePanel.PAUSE_SETTINGS_STATE) {\n            drawPauseSettingsMenu();\n        }\n\n        else if (gamePanel.gameState == gamePanel.CONFIRM_STATE) {\n            drawConfirmMenu();\n        }\n        \n        else if (gamePanel.gameState == gamePanel.PAUSE_STATE) {\n            drawPauseMenu();  \n        }\n\n        else if (gamePanel.gameState == gamePanel.END_STATE) {\n            drawEndScreen();\n    }\n    }\n\n    public void drawIntroScreen() {\n        g2.setColor(Color.BLACK);\n        g2.fillRect(0, 0, gamePanel.screenWidth, gamePanel.screenHeight);\n        g2.drawImage(introGif, 0, 0, gamePanel.screenWidth, gamePanel.screenHeight, null);\n    }\n\n    public void drawWarningScreen() {\n        g2.setColor(Color.BLACK);\n        g2.fillRect(0, 0, gamePanel.screenWidth, gamePanel.screenHeight);\n        g2.drawImage(warningGif, 0, 0, gamePanel.screenWidth, gamePanel.screenHeight, null);\n    }\n\n    public void drawTitleScreen() {\n        if (backgroundGif != null) {\n            g2.drawImage(backgroundGif, 0, 0, gamePanel.screenWidth, gamePanel.screenHeight, null);\n        } \n        \n        else {\n            g2.setColor(Color.BLACK);\n            g2.fillRect(0, 0, gamePanel.screenWidth, gamePanel.screenHeight);\n        }\n\n        g2.drawImage(hackedImage, 475, 0, 600, 125, null);\n        g2.drawImage(apocalyspeImage, 475, 80, 600, 125, null);\n\n        drawMenuOption(newGameImage, newGameSelectedImage, 300, 0);\n        drawMenuOption(loadGameImage, loadGameSelectedImage, 360, 1);\n        drawMenuOption(settingsImage, settingsSelectedImage, 420, 2);\n        drawMenuOption(exitImage, exitSelectedImage, 480, 3);\n    \n        gamePanel.repaint();\n    }\n    \n    private void drawMenuOption(BufferedImage normalImage, BufferedImage selectedImage, int yPosition, int optionIndex) {\n        int width = 300;\n        int height = 75;\n        BufferedImage imageToDraw = (mainMenuselectedOption == optionIndex) ? selectedImage : normalImage;\n        g2.drawImage(imageToDraw, gamePanel.screenWidth / 2 - width / 2, yPosition, width, height, null);\n    }\n\n    public void drawLoadMenu() {\n        int width = 300;\n        int height = 75;\n        int menuX = gamePanel.screenWidth / 4;\n        int menuY = gamePanel.screenHeight / 4;\n\n        g2.drawImage(backgroundGif, 0, 0, gamePanel.screenWidth, gamePanel.screenHeight, null);\n        g2.drawImage(loadGameImage, menuX + 100, menuY - 200, width * 2, height * 2, null);\n\n        SimpleDateFormat sdf = new SimpleDateFormat(\"dd/MM/yyyy HH:mm\");\n\n        drawLoadGameOption(slot1Image, slot1SelectedImage, 300, 200, 0);\n        drawLoadGameOption(slot2Image, slot2SelectedImage, 300, 300, 1);\n        drawLoadGameOption(slot3Image, slot3SelectedImage, 300, 400, 2);\n        drawLoadGameOption(backImage, backSelectedImage, 625, 500, 3);\n\n        for (int i = 0; i < 3; i++) {\n            SaveData saveData = SaveManager.getSaveSlotInfo(i + 1);\n            int y = 212 + (i * 100);\n\n            if (saveData == null) {\n                font.drawText(g2, \"EMPTY\", 500, y,200 ,50);\n            } \n            \n            else {\n                String dateString = sdf.format(saveData.saveDate);\n                String slotText = \"WAVE \" + saveData.waveNumber + \" | \" + dateString;\n                font.drawText(g2, slotText,500, y,200 ,50);\n            }\n        }\n    }\n\n    private void drawLoadGameOption(BufferedImage normalImage, BufferedImage selectedImage, int x, int y, int optionIndex) {\n        BufferedImage imageToDraw = (loadGameSelectedOption == optionIndex) ? selectedImage : normalImage;\n        g2.drawImage(imageToDraw, x, y, 300, 75, null);\n    }\n\n    private void drawSettingsMenu() {\n        int width = 300;\n        int height = 75;\n    \n        int menuX = gamePanel.screenWidth / 4;\n        int menuY = gamePanel.screenHeight / 4;\n    \n        g2.drawImage(backgroundGif, 0, 0, gamePanel.screenWidth, gamePanel.screenHeight, null);\n        g2.drawImage(settingsImage, menuX + 100, menuY - 200, width * 2, height * 2, null);\n        \n        drawSettingsOption(volumeImage, volumeSelectedImage, 400, 200, 0);\n        drawVolumeSlider(menuX + width + 200, menuY + 20);\n        drawSettingsOption(backImage, backSelectedImage, 375, 300, 1);\n    }\n\n    private void drawSettingsOption(BufferedImage normalImage, BufferedImage selectedImage, int x, int y, int optionIndex) {\n        int width = 300;\n        int height = 75;\n        BufferedImage imageToDraw = (settingsSelectedOption == optionIndex) ? selectedImage : normalImage;\n        g2.drawImage(imageToDraw, x, y, width, height, null);\n    }\n\n    public void drawVolumeSlider(int x, int y) {\n        int sliderWidth = 200;  \n        int sliderHeight = 20;  \n        int segmentWidth = sliderWidth / 5;  \n\n        g2.setColor(Color.GRAY);\n        g2.fillRect(x, y, sliderWidth, sliderHeight);\n\n        g2.setColor(Color.green);\n        g2.fillRect(x, y, volumeLevel * segmentWidth / 2, sliderHeight);\n\n        g2.setColor(Color.BLACK);\n        \n        for (int i = 0; i <= 10; i++) {\n            int lineX = x + i * segmentWidth;\n            g2.drawLine(lineX, y, lineX, y + sliderHeight);\n        }\n    }\n\n    public void drawPauseMenu() {\n        int width = 300;\n        int height = 75;\n        int menuX = gamePanel.screenWidth / 4;\n        int menuY = gamePanel.screenHeight / 4;\n    \n        if (gamePanel.pauseBackground != null) {\n            g2.drawImage(gamePanel.pauseBackground, 0, 0, gamePanel.screenWidth, gamePanel.screenHeight, null);\n        }\n    \n        g2.setColor(new Color(0, 0, 0, 150));\n        g2.fillRect(0, 0, gamePanel.screenWidth, gamePanel.screenHeight);\n    \n        g2.drawImage(pausedImage, menuX + 80, menuY - 200, width * 2, height * 2, null);\n    \n        drawPauseMenuOption(continueImage, continueSelectedImage, gamePanel.screenWidth / 2 - width / 2, 250, 0);\n        drawPauseMenuOption(saveGameImage, saveGameSelectedImage, gamePanel.screenWidth / 2 - width / 2, 350, 1);\n        drawPauseMenuOption(settingsImage, settingsSelectedImage, gamePanel.screenWidth / 2 - width / 2, 450, 2);\n        drawPauseMenuOption(mainMenuImage, mainMenuSelectedImage, gamePanel.screenWidth / 2 - width / 2, 550, 3);\n    }\n    \n    private void drawPauseMenuOption(BufferedImage normalImage, BufferedImage selectedImage, int x, int y, int optionIndex) {\n        BufferedImage imageToDraw = (pauseMenuSelectedOption == optionIndex) ? selectedImage : normalImage;\n        g2.drawImage(imageToDraw, x, y, 300, 75, null);\n    } \n    \n    public void drawPauseSettingsMenu() {\n        int width = 300;\n        int height = 75;\n    \n        int menuX = gamePanel.screenWidth / 4;\n        int menuY = gamePanel.screenHeight / 4;\n    \n        if (gamePanel.pauseBackground != null) {\n            g2.drawImage(gamePanel.pauseBackground, 0, 0, gamePanel.screenWidth, gamePanel.screenHeight, null);\n        }\n    \n        g2.setColor(new Color(0, 0, 0, 180));\n        g2.fillRect(0, 0, gamePanel.screenWidth, gamePanel.screenHeight);\n    \n        g2.drawImage(settingsImage, menuX + 100, menuY - 200, width * 2, height * 2, null);\n    \n        drawSettingsOption(volumeImage, volumeSelectedImage, 400, 200, 0);\n        drawVolumeSlider(menuX + width + 200, menuY + 20);\n        drawSettingsOption(backImage, backSelectedImage, 375, 300, 1);\n    }\n    \n    public void drawConfirmMenu() {\n        if (gamePanel.pauseBackground != null) {\n            g2.drawImage(gamePanel.pauseBackground, 0, 0, gamePanel.screenWidth, gamePanel.screenHeight, null);\n        }\n    \n        g2.setColor(new Color(0, 0, 0, 180));\n        g2.fillRect(0, 0, gamePanel.screenWidth, gamePanel.screenHeight);\n\n        font.drawText(g2, \"ARE YOU SURE YOU WANT TO QUIT?\", 390, 200,200 ,50);\n        font.drawText(g2, \"ANY UNSAVED PROGRESS WILL BE LOST.\", 350, 250,200 ,50);\n\n        drawConfirmOptions(confirmImage, confirmSelectedImage, 530, 320, 1);\n        drawConfirmOptions(cancelImage, cancelSelectedImage, 820, 320, 0);\n    }\n\n    public void drawConfirmOptions(BufferedImage normalImage, BufferedImage selectedImage, int x, int y, int optionIndex) {\n        BufferedImage imageToDraw = (confirmMenuSelectedOption == optionIndex) ? selectedImage : normalImage;\n        g2.drawImage(imageToDraw, x, y, 200, 50, null);\n    }\n\n    public void drawEndScreen() {\n        int width = 300;\n        int height = 75;\n    \n        int menuX = gamePanel.screenWidth / 4;\n        int menuY = gamePanel.screenHeight / 4;\n\n        if (gamePanel.pauseBackground != null) {\n            g2.drawImage(gamePanel.pauseBackground, 0, 0, gamePanel.screenWidth, gamePanel.screenHeight, null);\n        }\n    \n        g2.setColor(new Color(0, 0, 0, 180));\n        g2.fillRect(0, 0, gamePanel.screenWidth, gamePanel.screenHeight);\n        g2.drawImage(gameoverImage, menuX + 120, menuY - 200, width * 2, height * 2, null);\n        \n        font.drawText(g2, \"WAVE SURVIVED:\" + (WaveManager.waveNumber - 1), 390, 200,200 ,50);\n        font.drawText(g2, \"ENEMIES KILLED:\" + gamePanel.player.killCounter, 390, 300,200 ,50);\n        font.drawText(g2, \"SCORE:\" + gamePanel.player.score, 390, 400,200 ,50);\n\n        drawEndOptions(restartImage, restartSelectedImage, 450, 600, 0);\n        drawEndOptions(mainMenuImage, mainMenuSelectedImage,800, 600, 1);\n    }\n\n    public void drawEndOptions(BufferedImage normalImage, BufferedImage selectedImage, int x, int y, int optionIndex) {\n        BufferedImage imageToDraw = (endMenuSelectedOption == optionIndex) ? selectedImage : normalImage;\n        g2.drawImage(imageToDraw, x, y, 300, 75, null);\n    }\n}",
      "Tile.java": "package Main;\n\nimport java.awt.image.BufferedImage;\n\npublic class Tile {\n    public BufferedImage image;\n    public boolean collision = false;\n}",
      "GamePanel.java": "package Main;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport javax.swing.*;\n\nimport Items.Pickup;\nimport Player.Player;\nimport Weapons.Bullet;\nimport Zombies.*;\n\npublic class GamePanel extends JPanel implements Runnable {\n    \n    private int FPS = 60;\n\n    private final int originalTileSize = 16;\n    private final int scale = 3;\n    public final int tileSize = originalTileSize * scale;\n\n    private final int maxScreenColumn = 32;\n    private final int maxScreenRow = 17;\n    public int screenWidth = tileSize * maxScreenColumn;\n    public int screenHeight = tileSize * maxScreenRow;\n    public final int maxWorldColumn = 100;\n    public final int maxWorldRow = 100;\n    public final int worldWidth = tileSize * maxWorldColumn;\n    public final int worldHeight = tileSize * maxWorldRow;\n\n    public int cameraX = 0;\n    public int cameraY = 0;\n\n    public BufferedImage pauseBackground;\n    \n    public final int INTRO_STATE = -2;\n    public final int WARNING_STATE = -1;\n    public final int MENU_STATE = 0;\n    public final int LOAD_STATE = 1;\n    public final int SETTINGS_STATE = 2;\n    public final int GAME_STATE = 3;\n    public final int PAUSE_STATE = 4;\n    public final int PAUSE_SETTINGS_STATE = 5;\n    public final int CONFIRM_STATE = 6;\n    public final int END_STATE = 7;\n    public int gameState;\n\n    SoundManager musicManager = new SoundManager();\n    public SoundManager effectManager = new SoundManager();\n    WaveManager waveManager;\n    KeyHandler keyHandler = new KeyHandler(this);\n    public CollisionChecker collisionChecker = new CollisionChecker(this);\n    UIManager uiManager = new UIManager(this);\n    public Player player = new Player(this, keyHandler);\n    TileManager tileManager = new TileManager(this);\n    \n    public ArrayList<Zombie> zombies = new ArrayList<>();\n    public ArrayList<Bullet> projectiles = new ArrayList<>();\n    public static ArrayList<Pickup> pickups = new ArrayList<>();\n\n    Thread gameThread;\n    public JFrame window;\n\n    private long stateStartTime;\n\n    public GamePanel(JFrame window) {\n        this.window = window;\n        gameThread = new Thread(this);\n        setPreferredSize(new Dimension(screenWidth, screenHeight));\n        addKeyListener(keyHandler);\n        setFocusable(true);\n        requestFocus();\n        setDoubleBuffered(true);\n        waveManager = new WaveManager(this);\n    }\n\n    public void capturePauseBackground() {\n        pauseBackground = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);\n        Graphics2D g2 = pauseBackground.createGraphics();\n        paint(g2);\n        g2.dispose();\n    }\n\n    public void setUpGame() {\n        gameState = INTRO_STATE;\n        stateStartTime = System.currentTimeMillis();\n        waveManager.startNewWave();\n        musicManager.setFile(0);\n        musicManager.play();\n    }\n\n    public void startGameThread() {\n        gameThread.start();\n    }\n\n    public void resetGame() {\n        player = new Player(this, keyHandler);\n        zombies.clear();\n        projectiles.clear();\n        waveManager = new WaveManager(this);\n        WaveManager.waveNumber = 0;\n        waveManager.startNewWave();\n        stopMusic();\n        playMusic(0);\n    }\n\n    public void restartGame() {\n        player = new Player(this, keyHandler);\n        zombies.clear();\n        projectiles.clear();\n        waveManager = new WaveManager(this);\n        WaveManager.waveNumber = 0;\n        waveManager.startNewWave();\n        stopMusic();\n        playMusic(12);\n    }\n\n    @Override\n    public void run() {\n        double drawInterval = 1_000_000_000.0 / FPS;\n        long lastTime = System.nanoTime();\n        long currentTime;\n        double delta = 0;\n        \n        while (gameThread != null) {\n            currentTime = System.nanoTime();\n            delta += (currentTime - lastTime) / drawInterval;\n            lastTime = currentTime;\n\n            if (delta >= 1) {\n                update();\n                repaint();\n                delta--;\n            }\n        }\n    }\n\n    public void update() {\n        long elapsedTime = System.currentTimeMillis() - stateStartTime;\n\n        switch (gameState) {\n            case INTRO_STATE:\n                if (elapsedTime > 5000) {\n                    gameState = WARNING_STATE;\n                    stateStartTime = System.currentTimeMillis();\n                }\n                break;\n                \n            case WARNING_STATE:\n                if (elapsedTime > 5000) {\n                    gameState = MENU_STATE;\n                    stateStartTime = System.currentTimeMillis();\n                }\n                break;\n\n            case GAME_STATE:\n                player.update();\n                Zombie.updateZombies(zombies, player, this);\n                waveManager.update();\n                updateProjectiles();\n\n                for (Zombie z : zombies) {\n                    if (z instanceof CorrosiveZombie) {\n                        ((CorrosiveZombie) z).update(player.worldX, player.worldY, projectiles, this);\n                    }\n                }\n\n                for (Pickup pickup : pickups) {\n                    pickup.update(player);\n                }\n                break;\n        }\n    }\n\n    public void paint(Graphics g) {\n        super.paint(g);\n        Graphics2D g2 = (Graphics2D) g;\n        g2.clearRect(0, 0, screenWidth, screenHeight);\n        \n        switch (gameState) {\n            case INTRO_STATE:\n                uiManager.draw(g2);\n                break;\n\n            case WARNING_STATE:\n                uiManager.draw(g2);\n                break;\n\n            case MENU_STATE:\n                uiManager.draw(g2);\n                break;  \n\n            case LOAD_STATE:\n                uiManager.draw(g2);\n                break;\n\n            case SETTINGS_STATE:\n                uiManager.draw(g2);\n                break;\n\n            case GAME_STATE:\n                tileManager.draw(g2);\n                player.draw(g2);\n                Zombie.drawZombies(g2, zombies, this, player);\n                drawProjectiles(g2, cameraX, cameraY);\n\n                for (Pickup pickup : pickups) {\n                    pickup.draw(g2, this);\n                }\n                break;\n\n            case PAUSE_STATE:\n                uiManager.draw(g2);\n                break;   \n\n            case PAUSE_SETTINGS_STATE:\n                uiManager.draw(g2);\n                break;\n\n            case CONFIRM_STATE:\n                uiManager.draw(g2);\n                break;\n\n            case END_STATE:\n                uiManager.draw(g2);\n                break;\n        }\n    }    \n\n    public void stopGameThread() {\n        gameThread = null;\n    }\n\n    public void playMusic(int music) {\n        musicManager.setFile(music);\n        musicManager.play();\n        musicManager.loop();\n    }\n\n    public void stopMusic() {\n        musicManager.stop();\n    }\n\n    public void addProjectile(Bullet bullet) {\n        projectiles.add(bullet);\n    }\n\n    public void updateProjectiles() {\n        for (int i = projectiles.size() - 1; i >= 0; i--) {\n            Bullet b = projectiles.get(i);\n            b.update();\n    \n            if (b.x < 0 || b.x > worldWidth || b.y < 0 || b.y > worldHeight) {\n                projectiles.remove(i);\n                continue;\n            }\n    \n            if (b.isFromEnemy() && b.getHitbox().intersects(player.hitbox)) {\n                player.takeDamage(20);\n                projectiles.remove(i);\n            }\n        }\n    }\n    \n    public void drawProjectiles(Graphics2D g, int cameraX, int cameraY) {\n        for (Bullet bullet : projectiles) {\n            bullet.draw(g, cameraX, cameraY);\n        }\n    }\n\n    public void explodeOnDeath(CorrosiveZombie z) {\n        int explosionRadius = 200;\n        int explosionDamage = 20;\n        int knockbackPower = 15;\n        \n        int dx = player.worldX - z.worldX;\n        int dy = player.worldY - z.worldY;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance <= explosionRadius) {\n            player.takeDamage(explosionDamage);\n        }\n    \n        for (Zombie otherZombie : zombies) {\n            if (otherZombie != z) {\n                int zx = otherZombie.worldX - z.worldX;\n                int zy = otherZombie.worldY - z.worldY;\n                double zDistance = Math.sqrt(zx * zx + zy * zy);\n                \n                if (zDistance <= explosionRadius) {\n                    double angle = Math.atan2(zy, zx);\n                    otherZombie.takeDamage(explosionDamage, angle, knockbackPower, player);\n                }\n            }\n        }\n    }    \n}",
      "KeyHandler.java": "package Main;\n\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\npublic class KeyHandler extends KeyAdapter {\n\n    GamePanel gamePanel;\n    SoundManager soundManager = new SoundManager();\n\n    boolean isFullscreen = false;\n\n    public boolean upPressed, downPressed, leftPressed, rightPressed,rPressed, pPressed, qPressed, mPressed;\n\n    public KeyHandler(GamePanel gamePanel) {\n        this.gamePanel = gamePanel;\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int key = e.getKeyCode();\n        soundManager.setFile(1);\n\n        if (gamePanel.gameState == gamePanel.MENU_STATE) {\n            if (key == KeyEvent.VK_UP) {\n                soundManager.play();\n\n                if (gamePanel.uiManager.mainMenuselectedOption == 0) {\n                    gamePanel.uiManager.mainMenuselectedOption = 3;\n                } \n\n                else {\n                    gamePanel.uiManager.mainMenuselectedOption--;\n                }\n            }\n\n            if (key == KeyEvent.VK_DOWN) {\n                soundManager.play();\n\n                if (gamePanel.uiManager.mainMenuselectedOption == 3) {\n                    gamePanel.uiManager.mainMenuselectedOption = 0;\n                } \n\n                else {\n                    gamePanel.uiManager.mainMenuselectedOption++;\n                }\n            }\n\n            if (key == KeyEvent.VK_ENTER) {\n                soundManager.setFile(2);\n                switch (gamePanel.uiManager.mainMenuselectedOption) {\n                    case 0:\n                        gamePanel.musicManager.stop();\n                        gamePanel.gameState = gamePanel.GAME_STATE;\n                        gamePanel.musicManager.setFile(12);\n                        gamePanel.musicManager.play();\n                        gamePanel.musicManager.loop();\n                        break;\n\n                    case 1:\n                        soundManager.play();\n                        gamePanel.gameState = gamePanel.LOAD_STATE;\n                        break;\n\n                    case 2:\n                        soundManager.play();\n                        gamePanel.gameState = gamePanel.SETTINGS_STATE;\n                        break;\n\n                    case 3:\n                        System.exit(0);\n                        break;\n                }\n            }\n        }\n\n        else if (gamePanel.gameState == gamePanel.SETTINGS_STATE) {\n            soundManager.setFile(1);\n\n            if (key == KeyEvent.VK_UP) {\n                soundManager.play();\n\n                if (gamePanel.uiManager.settingsSelectedOption == 0) {\n                    gamePanel.uiManager.settingsSelectedOption = 1;\n                } \n\n                else\n                    gamePanel.uiManager.settingsSelectedOption = 0;\n            }\n\n            if (key == KeyEvent.VK_DOWN) {\n                soundManager.play();\n\n                if (gamePanel.uiManager.settingsSelectedOption == 1) {\n                    gamePanel.uiManager.settingsSelectedOption = 0;\n                } \n\n                else\n                    gamePanel.uiManager.settingsSelectedOption = 1;\n            }\n\n            if (key == KeyEvent.VK_LEFT) {\n                if(gamePanel.uiManager.settingsSelectedOption == 0) {\n                    soundManager.play();\n                    gamePanel.musicManager.volumeDown();\n                    gamePanel.uiManager.volumeLevel -= 2;\n                }\n            }\n\n            if (key == KeyEvent.VK_RIGHT) {\n                if(gamePanel.uiManager.settingsSelectedOption == 0) {\n                    soundManager.play();\n                    gamePanel.musicManager.volumeUp();\n                    gamePanel.uiManager.volumeLevel += 2;\n                }\n            }\n\n            if (key == KeyEvent.VK_ENTER) {\n                soundManager.setFile(3);\n                switch (gamePanel.uiManager.settingsSelectedOption) {\n                    case 0:\n                        \n                        break;\n\n                    case 1:\n                        soundManager.play();\n                        gamePanel.gameState = gamePanel.MENU_STATE;\n                        break;\n                }\n            }\n\n            if (key == KeyEvent.VK_ESCAPE) {\n                soundManager.setFile(3);\n                soundManager.play();\n                gamePanel.gameState = gamePanel.MENU_STATE;\n            }\n        }\n\n        else if (gamePanel.gameState == gamePanel.LOAD_STATE) {\n            soundManager.setFile(1);\n            if (key == KeyEvent.VK_UP) {\n                soundManager.play();\n                upPressed = true;\n\n                if (gamePanel.uiManager.loadGameSelectedOption == 0) {\n                    gamePanel.uiManager.loadGameSelectedOption = 3;\n                } \n\n                else {\n                    gamePanel.uiManager.loadGameSelectedOption--;\n                }\n            }\n\n            if (key == KeyEvent.VK_DOWN) {\n                soundManager.play();\n                downPressed = true;\n\n                if (gamePanel.uiManager.loadGameSelectedOption == 3) {\n                    gamePanel.uiManager.loadGameSelectedOption = 0;\n                } \n\n                else {\n                    gamePanel.uiManager.loadGameSelectedOption++;\n                }\n            }\n\n            if (key == KeyEvent.VK_ENTER) {\n                soundManager.setFile(3);\n                if (gamePanel.uiManager.loadGameSelectedOption == 3) {\n                    soundManager.play();\n                    gamePanel.gameState = gamePanel.MENU_STATE;\n                } \n\n                else {\n                    int slot = gamePanel.uiManager.loadGameSelectedOption + 1;\n                    SaveManager.loadGame(gamePanel, slot);\n                    gamePanel.musicManager.stop();\n                    gamePanel.gameState = gamePanel.GAME_STATE;\n                    gamePanel.musicManager.setFile(12);\n                    gamePanel.musicManager.play();\n                }\n            }\n\n            if (key == KeyEvent.VK_ESCAPE) {\n                soundManager.setFile(3);\n                soundManager.play();\n                gamePanel.gameState = gamePanel.MENU_STATE;\n            }\n        }\n\n        else if (gamePanel.gameState == gamePanel.GAME_STATE) {\n            if (key == KeyEvent.VK_W) {\n                upPressed = true;\n            }\n\n            if (key == KeyEvent.VK_S) {\n                downPressed = true;\n            }\n\n            if (key == KeyEvent.VK_A) {\n                leftPressed = true;\n            }\n\n            if (key == KeyEvent.VK_D) {\n                rightPressed = true;\n            }\n\n            if (key == KeyEvent.VK_R) {\n                rPressed = true;\n            }\n        \n            if (key == KeyEvent.VK_Q) {\n                qPressed = true;\n            }\n\n            if (key == KeyEvent.VK_P) {\n                pPressed = true;\n                gamePanel.capturePauseBackground();\n                gamePanel.gameState = gamePanel.PAUSE_STATE;\n            }   \n        }\n\n        else if (gamePanel.gameState == gamePanel.PAUSE_STATE) {\n            if (key == KeyEvent.VK_P) {\n                pPressed = true;\n                gamePanel.gameState = gamePanel.GAME_STATE;\n            }\n\n            if (key == KeyEvent.VK_UP) {\n                upPressed = true;\n                if (gamePanel.uiManager.pauseMenuSelectedOption == 0) {\n                    gamePanel.uiManager.pauseMenuSelectedOption = 3;\n                } \n                \n                else {\n                    gamePanel.uiManager.pauseMenuSelectedOption--;\n                }\n            }\n            \n            if (key == KeyEvent.VK_DOWN) {\n                downPressed = true;\n                \n                if (gamePanel.uiManager.pauseMenuSelectedOption == 3) {\n                    gamePanel.uiManager.pauseMenuSelectedOption = 0;\n                } \n                \n                else {\n                    gamePanel.uiManager.pauseMenuSelectedOption++;\n                }\n            }\n            \n            if (key == KeyEvent.VK_ENTER) {\n                \n                if(gamePanel.uiManager.pauseMenuSelectedOption == 0) {\n                    gamePanel.gameState = gamePanel.GAME_STATE;\n                }\n                \n                if(gamePanel.uiManager.pauseMenuSelectedOption == 1) {\n                    SaveManager.saveGame(gamePanel, WaveManager.waveNumber);\n                }\n                \n                if(gamePanel.uiManager.pauseMenuSelectedOption == 2) {\n                    gamePanel.gameState = gamePanel.PAUSE_SETTINGS_STATE;\n                }\n                \n                if(gamePanel.uiManager.pauseMenuSelectedOption == 3) {\n                    gamePanel.gameState = gamePanel.CONFIRM_STATE;\n                }\n            }\n\n            if (key == KeyEvent.VK_ESCAPE) {\n                gamePanel.gameState = gamePanel.GAME_STATE;\n            }\n        }\n\n        else if (gamePanel.gameState == gamePanel.PAUSE_SETTINGS_STATE) {\n            soundManager.setFile(1);\n            \n            if (key == KeyEvent.VK_UP) {\n                soundManager.play();\n                \n                if (gamePanel.uiManager.settingsSelectedOption == 0) {\n                    gamePanel.uiManager.settingsSelectedOption = 1;\n                } \n        \n                else {\n                    gamePanel.uiManager.settingsSelectedOption = 0;\n                }\n            }\n\n            if (key == KeyEvent.VK_DOWN) {\n                soundManager.play();\n                \n                if (gamePanel.uiManager.settingsSelectedOption == 1) {\n                    gamePanel.uiManager.settingsSelectedOption = 0;\n                } \n                \n                else {\n                    gamePanel.uiManager.settingsSelectedOption = 1;\n                }\n            }\n\n            if (key == KeyEvent.VK_LEFT) {\n                \n                if(gamePanel.uiManager.settingsSelectedOption == 0) {\n                    soundManager.play();\n                    gamePanel.musicManager.volumeDown();\n                    gamePanel.uiManager.volumeLevel -= 2;\n                }\n            }\n\n            if (key == KeyEvent.VK_RIGHT) {\n                \n                if(gamePanel.uiManager.settingsSelectedOption == 0) {\n                    soundManager.play();\n                    gamePanel.musicManager.volumeUp();\n                    gamePanel.uiManager.volumeLevel += 2;\n                }\n            }\n\n            if (key == KeyEvent.VK_ENTER) {\n                soundManager.setFile(3);\n                \n                switch (gamePanel.uiManager.settingsSelectedOption) {\n                    case 0:\n                        break;\n                    case 1:\n                        soundManager.play();\n                        gamePanel.gameState = gamePanel.PAUSE_STATE;\n                        break;\n                }\n            }\n\n            if (key == KeyEvent.VK_ESCAPE) {\n                soundManager.setFile(3);\n                soundManager.play();\n                gamePanel.gameState = gamePanel.MENU_STATE;\n            }\n        }\n\n        else if (gamePanel.gameState == gamePanel.CONFIRM_STATE) {\n            \n            if (key == KeyEvent.VK_LEFT) {\n            \n                if (gamePanel.uiManager.confirmMenuSelectedOption == 1) {\n                    gamePanel.uiManager.confirmMenuSelectedOption = 0;\n                } \n            \n                else {\n                    gamePanel.uiManager.confirmMenuSelectedOption = 1;\n                }\n            }\n\n            if (key == KeyEvent.VK_RIGHT) {\n            \n                if (gamePanel.uiManager.confirmMenuSelectedOption == 0) {\n                    gamePanel.uiManager.confirmMenuSelectedOption = 1;\n                } \n            \n                else {\n                    gamePanel.uiManager.confirmMenuSelectedOption = 0;;\n                }\n            }\n\n            if (key == KeyEvent.VK_ENTER) {\n            \n                if (gamePanel.uiManager.confirmMenuSelectedOption == 0) {\n                    gamePanel.gameState = gamePanel.PAUSE_STATE;\n                }\n\n                if (gamePanel.uiManager.confirmMenuSelectedOption == 1) {\n                    gamePanel.resetGame();\n                    gamePanel.gameState = gamePanel.MENU_STATE;\n                }\n            }\n        }\n\n        else if (gamePanel.gameState == gamePanel.END_STATE) {\n            if (key == KeyEvent.VK_LEFT) {\n            \n                if (gamePanel.uiManager.endMenuSelectedOption == 1) {\n                    gamePanel.uiManager.endMenuSelectedOption = 0;\n                } \n            \n                else {\n                    gamePanel.uiManager.endMenuSelectedOption = 1;\n                }\n            }\n\n            if (key == KeyEvent.VK_RIGHT) {\n            \n                if (gamePanel.uiManager.endMenuSelectedOption == 0) {\n                    gamePanel.uiManager.endMenuSelectedOption = 1;\n                } \n            \n                else {\n                    gamePanel.uiManager.endMenuSelectedOption = 0;;\n                }\n            }\n\n            if (key == KeyEvent.VK_ENTER) {\n            \n                if (gamePanel.uiManager.endMenuSelectedOption == 0) {\n                    gamePanel.restartGame();\n                    gamePanel.gameState = gamePanel.GAME_STATE;\n                }\n\n                if (gamePanel.uiManager.endMenuSelectedOption == 1) {\n                    gamePanel.resetGame();\n                    gamePanel.gameState = gamePanel.MENU_STATE;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n        int key = e.getKeyCode();\n\n        if (key == KeyEvent.VK_UP) {\n            upPressed = false;\n        }\n\n        if (key == KeyEvent.VK_DOWN) {\n            downPressed = false;\n        }\n\n        if (key == KeyEvent.VK_W) {\n            upPressed = false;\n        }\n\n        if (key == KeyEvent.VK_S) {\n            downPressed = false;\n        }\n\n        if (key == KeyEvent.VK_A) {\n            leftPressed = false;\n        }\n        \n        if (key == KeyEvent.VK_D) {\n            rightPressed = false;\n        }\n\n        if (key == KeyEvent.VK_R) {\n            rPressed = false;\n        }\n\n        if (key == KeyEvent.VK_P) {\n            pPressed = false;\n        }\n\n        if (key == KeyEvent.VK_Q) {\n            qPressed = false;\n        }\n    }\n}",
      "SaveManager.java": "package Main;\n\nimport java.io.*;\nimport java.util.Date;\nimport Player.Player;\nimport Weapons.AssaultRifle;\nimport Weapons.Bullet;\nimport Weapons.Pistol;\nimport Weapons.RocketLauncher;\nimport Weapons.Shotgun;\nimport Weapons.SniperRifle;\nimport Weapons.Weapon;\nimport Zombies.CorrosiveZombie;\nimport Zombies.CrawlingZombie;\nimport Zombies.NormalZombie;\nimport Zombies.TankZombie;\nimport Zombies.Zombie;\n\npublic class SaveManager {\n    private static final String SLOT_1 = \"savegame1.dat\";\n    private static final String SLOT_2 = \"savegame2.dat\";\n    private static final String SLOT_3 = \"savegame3.dat\";\n\n    public static void saveGame(GamePanel gamePanel, int waveNumber) {\n        shiftSaveFiles();\n    \n        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(SLOT_1))) {\n            Player player = gamePanel.player;\n            SaveData saveData = new SaveData(player.getWorldX(), player.getWorldY(), player.health, player.currentWeapon.getClass().getSimpleName(), waveNumber, new Date(), player.score, player.killCounter);\n    \n            for (Weapon weapon : player.weapons) {\n                saveData.weapons.add(new SaveData.WeaponData(weapon.getClass().getSimpleName(), weapon.bulletsLeft, weapon.totalAmmo));\n            }\n    \n            for (Zombie z : gamePanel.zombies) {\n                String zombieType = null;\n\n                if (z instanceof NormalZombie) {\n                    zombieType = \"NormalZombie\";\n                }\n                \n                else if (z instanceof CrawlingZombie) {\n                    zombieType = \"CrawlingZombie\";\n                } \n                \n                else if (z instanceof CorrosiveZombie) {\n                    zombieType = \"CorrosiveZombie\";\n                } \n                \n                else if (z instanceof TankZombie) {\n                    zombieType = \"TankZombie\";\n                }\n\n                saveData.zombies.add(new SaveData.ZombieData(z.worldX, z.worldY, z.health, z.speed, z.damage, z.spritePath, z.frameCount, z.spriteWidth, z.spriteHeight, z.attackSpritePath, z.attackFrames, z.hurtSpritePath, z.hurtFrames, z.deadSpritePath, z.deadFrames, z.canBeKnockedBack, zombieType));\n            }\n    \n            for (Bullet b : gamePanel.projectiles) {\n                saveData.bullets.add(new SaveData.BulletData(b.x, b.y, b.getAngle(), b.speed));\n            }\n    \n            out.writeObject(saveData);\n        } catch (Exception e) {\n            e.getMessage();\n        }\n    }\n    \n    public static SaveData getSaveSlotInfo(int slot) {\n        String fileName = getSlotFileName(slot);\n\n        if (fileName == null || !new File(fileName).exists()) {\n            return null;\n        }\n\n        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(fileName))) {\n            return (SaveData) in.readObject();\n        } catch (Exception e) {\n            e.getMessage();\n            return null;\n        }\n    }\n\n    public static void loadGame(GamePanel gamePanel, int slot) {\n        SaveData saveData = getSaveSlotInfo(slot);\n        if (saveData == null) {\n            return;\n        }\n\n        WaveManager.waveNumber = saveData.waveNumber;\n    \n        Player player = gamePanel.player;\n        player.worldX = (int) saveData.playerX;\n        player.worldY = (int) saveData.playerY;\n        player.health = saveData.playerHealth;\n        player.score = saveData.score;\n        player.killCounter = saveData.killCounter;\n    \n        for (SaveData.WeaponData wData : saveData.weapons) {\n            boolean weaponFound = false;\n            for (Weapon weapon : player.weapons) {\n                if (weapon.getClass().getSimpleName().equals(wData.weaponName)) {\n                    weaponFound = true;\n                    break;\n                }\n            }\n            \n            if (!weaponFound) {\n                player.addWeapon(createWeaponFromName(wData.weaponName));\n            }\n        }\n        \n        for (Weapon weapon : player.weapons) {\n            for (SaveData.WeaponData wData : saveData.weapons) {\n                if (weapon.getClass().getSimpleName().equals(wData.weaponName)) {\n                    weapon.bulletsLeft = wData.bulletsLeft;\n                    weapon.totalAmmo = wData.totalAmmo;\n    \n                    if (saveData.currentWeapon.equals(wData.weaponName)) {\n                        player.currentWeapon = weapon;\n                    }\n                    break;\n                }\n            }\n        }\n    \n        gamePanel.zombies.clear();\n    \n        for (SaveData.ZombieData zd : saveData.zombies) {\n            Zombie newZombie = null;\n            switch (zd.zombieType) {\n                case \"NormalZombie\":\n                    newZombie = new NormalZombie((int) zd.x, (int) zd.y);\n                    newZombie.health = zd.health;\n                    newZombie.speed = zd.speed;\n                    newZombie.damage = zd.damage;\n                    newZombie.spritePath = zd.spritePath;\n                    newZombie.frameCount = zd.frameCount;\n                    newZombie.spriteWidth = zd.spriteWidth;\n                    newZombie.spriteHeight = zd.spriteHeight;\n                    newZombie.attackSpritePath = zd.attackSpritePath;\n                    newZombie.attackFrames = zd.attackFrames;\n                    newZombie.hurtSpritePath = zd.hurtSpritePath;\n                    newZombie.hurtFrames = zd.hurtFrames;\n                    newZombie.deadSpritePath = zd.deadSpritePath;\n                    newZombie.deadFrames = zd.deadFrames;\n                    newZombie.canBeKnockedBack = zd.canBeKnockedBack;\n                    break;\n\n                case \"CrawlingZombie\":\n                    newZombie = new CrawlingZombie((int) zd.x, (int) zd.y);\n                    newZombie.health = zd.health;\n                    newZombie.speed = zd.speed;\n                    newZombie.damage = zd.damage;\n                    newZombie.spritePath = zd.spritePath;\n                    newZombie.frameCount = zd.frameCount;\n                    newZombie.spriteWidth = zd.spriteWidth;\n                    newZombie.spriteHeight = zd.spriteHeight;\n                    newZombie.attackSpritePath = zd.attackSpritePath;\n                    newZombie.attackFrames = zd.attackFrames;\n                    newZombie.hurtSpritePath = zd.hurtSpritePath;\n                    newZombie.hurtFrames = zd.hurtFrames;\n                    newZombie.deadSpritePath = zd.deadSpritePath;\n                    newZombie.deadFrames = zd.deadFrames;\n                    newZombie.canBeKnockedBack = zd.canBeKnockedBack;\n                    break;\n\n                case \"CorrosiveZombie\":\n                    newZombie = new CorrosiveZombie((int) zd.x, (int) zd.y);\n                    newZombie.health = zd.health;\n                    newZombie.speed = zd.speed;\n                    newZombie.damage = zd.damage;\n                    newZombie.spritePath = zd.spritePath;\n                    newZombie.frameCount = zd.frameCount;\n                    newZombie.spriteWidth = zd.spriteWidth;\n                    newZombie.spriteHeight = zd.spriteHeight;\n                    newZombie.attackSpritePath = zd.attackSpritePath;\n                    newZombie.attackFrames = zd.attackFrames;\n                    newZombie.hurtSpritePath = zd.hurtSpritePath;\n                    newZombie.hurtFrames = zd.hurtFrames;\n                    newZombie.deadSpritePath = zd.deadSpritePath;\n                    newZombie.deadFrames = zd.deadFrames;\n                    newZombie.canBeKnockedBack = zd.canBeKnockedBack;\n                    break;\n\n                case \"TankZombie\":\n                    newZombie = new TankZombie((int) zd.x, (int) zd.y);\n                    newZombie.health = zd.health;\n                    newZombie.speed = zd.speed;\n                    newZombie.damage = zd.damage;\n                    newZombie.spritePath = zd.spritePath;\n                    newZombie.frameCount = zd.frameCount;\n                    newZombie.spriteWidth = zd.spriteWidth;\n                    newZombie.spriteHeight = zd.spriteHeight;\n                    newZombie.attackSpritePath = zd.attackSpritePath;\n                    newZombie.attackFrames = zd.attackFrames;\n                    newZombie.hurtSpritePath = zd.hurtSpritePath;\n                    newZombie.hurtFrames = zd.hurtFrames;\n                    newZombie.deadSpritePath = zd.deadSpritePath;\n                    newZombie.deadFrames = zd.deadFrames;\n                    newZombie.canBeKnockedBack = zd.canBeKnockedBack;\n                    break;\n            }\n            gamePanel.zombies.add(newZombie);\n        }\n    \n        gamePanel.projectiles.clear();\n    \n        for (SaveData.BulletData bd : saveData.bullets) {\n            gamePanel.projectiles.add(new Bullet((int) bd.x, (int) bd.y, bd.angle, bd.speed));\n        }\n    }\n\n    private static Weapon createWeaponFromName(String weaponName) {\n        switch (weaponName) {\n            case \"Pistol\":\n                return new Pistol(); \n\n            case \"SniperRifle\":\n                return new SniperRifle(); \n\n            case \"RocketLauncher\":\n                return new RocketLauncher(); \n\n            case \"AssaultRifle\":\n                return new AssaultRifle(); \n\n            case \"Shotgun\":\n                return new Shotgun();\n                \n            default:\n                return null;\n        }\n    }\n\n    private static void shiftSaveFiles() {\n        File slot3 = new File(SLOT_3);\n\n        if (slot3.exists()) {\n            slot3.delete();\n        }\n\n        File slot2 = new File(SLOT_2);\n        \n        if (slot2.exists()) {\n            slot2.renameTo(new File(SLOT_3));\n        }\n        \n        File slot1 = new File(SLOT_1);\n        \n        if (slot1.exists()) {\n            slot1.renameTo(new File(SLOT_2));\n        }\n    }\n\n    private static String getSlotFileName(int slot) {\n        String s = null;\n        \n        switch (slot) {\n            case 1:\n                s = SLOT_1;\n                break;\n            case 2:\n                s = SLOT_2;\n                break;\n            case 3:\n                s = SLOT_3;\n                break;\n        };\n        return s;\n    }\n}",
      "Game.java": "package Main;\n\nimport javax.swing.*;\n\npublic class Game {\n    public static void main(String[] args) {\n        \n        JFrame gameFrame = new JFrame(\"Hacked Apocalypse\");\n        GamePanel gamePanel = new GamePanel(gameFrame);\n\n        gameFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        gameFrame.setResizable(true);\n        gameFrame.add(gamePanel);\n        gameFrame.pack();\n        gameFrame.setLocationRelativeTo(null);\n        gameFrame.setVisible(true);\n\n        gamePanel.setUpGame();\n        gamePanel.startGameThread();\n    }\n}",
      "CollisionChecker.java": "package Main;\n\nimport Zombies.Zombie;\nimport java.util.List;\nimport Player.Player;\n\npublic class CollisionChecker {\n\n    GamePanel gamePanel;\n\n    public CollisionChecker(GamePanel gamePanel) {\n        this.gamePanel = gamePanel;\n    }\n\n    public boolean checkCollision(Player player, int nextX, int nextY) {\n        if (nextX < 0 || nextX + player.hitbox.width > gamePanel.worldWidth || \n            nextY < 0 || nextY + player.hitbox.height > gamePanel.worldHeight) {\n            return true;\n        }\n    \n        return checkTileCollision(player, nextX, nextY);\n    }\n\n    public void checkZombieCollisions(List<Zombie> zombies) {\n        for (int i = 0; i < zombies.size(); i++) {\n            Zombie z1 = zombies.get(i);\n            if (!z1.isAlive()) continue;\n\n            for (int j = i + 1; j < zombies.size(); j++) {\n                Zombie z2 = zombies.get(j);\n                if (!z2.isAlive()) continue;\n\n                if (z1.hitbox.intersects(z2.hitbox)) {\n                    int dx = z1.worldX - z2.worldX;\n                    int dy = z1.worldY - z2.worldY;\n                    double distance = Math.sqrt(dx * dx + dy * dy);\n\n                    if (distance < 40) {\n                        double pushAmount = 2;\n\n                        z1.worldX += (int) (dx / distance * pushAmount);\n                        z1.worldY += (int) (dy / distance * pushAmount);\n                        z1.hitbox.setLocation(z1.worldX, z1.worldY);\n\n                        z2.worldX -= (int) (dx / distance * pushAmount);\n                        z2.worldY -= (int) (dy / distance * pushAmount);\n                        z2.hitbox.setLocation(z2.worldX, z2.worldY);\n                    }\n                }\n            }\n        }\n    }\n\n    public boolean checkTileCollision(Player player, int nextX, int nextY) {\n        int left = nextX;\n        int right = nextX + player.hitbox.width;\n        int top = nextY;\n        int bottom = nextY + player.hitbox.height;\n    \n        int leftCol = left / gamePanel.tileSize;\n        int rightCol = right / gamePanel.tileSize;\n        int topRow = top / gamePanel.tileSize;\n        int bottomRow = bottom / gamePanel.tileSize;\n    \n        if (leftCol < 0 || rightCol >= gamePanel.maxWorldColumn || topRow < 0 || bottomRow >= gamePanel.maxWorldRow) {\n            return true;\n        }\n    \n        if (gamePanel.tileManager.tile[gamePanel.tileManager.mapTileNumber[topRow][leftCol]].collision ||\n            gamePanel.tileManager.tile[gamePanel.tileManager.mapTileNumber[topRow][rightCol]].collision ||\n            gamePanel.tileManager.tile[gamePanel.tileManager.mapTileNumber[bottomRow][leftCol]].collision ||\n            gamePanel.tileManager.tile[gamePanel.tileManager.mapTileNumber[bottomRow][rightCol]].collision) {\n            return true;\n        }\n    \n        return false;\n    } \n\n    public boolean checkZombieTileCollision(Zombie zombie, int nextX, int nextY) {\n        int left = nextX;\n        int right = nextX + zombie.hitbox.width;\n        int top = nextY;\n        int bottom = nextY + zombie.hitbox.height;\n    \n        int leftCol = left / gamePanel.tileSize;\n        int rightCol = right / gamePanel.tileSize;\n        int topRow = top / gamePanel.tileSize;\n        int bottomRow = bottom / gamePanel.tileSize;\n    \n        if (leftCol < 0 || rightCol >= gamePanel.maxWorldColumn || topRow < 0 || bottomRow >= gamePanel.maxWorldRow) {\n            return true;\n        }\n    \n        return gamePanel.tileManager.tile[gamePanel.tileManager.mapTileNumber[topRow][leftCol]].collision ||\n               gamePanel.tileManager.tile[gamePanel.tileManager.mapTileNumber[topRow][rightCol]].collision ||\n               gamePanel.tileManager.tile[gamePanel.tileManager.mapTileNumber[bottomRow][leftCol]].collision ||\n               gamePanel.tileManager.tile[gamePanel.tileManager.mapTileNumber[bottomRow][rightCol]].collision;\n    }        \n}",
      "TileManager.java": "package Main;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport javax.imageio.ImageIO;\n\npublic class TileManager {\n    GamePanel gamePanel;\n    public Tile[] tile; \n    public int mapTileNumber[][];\n\n    public TileManager(GamePanel gamePanel) {\n        this.gamePanel = gamePanel;\n        tile = new Tile[10];\n        mapTileNumber = new int[gamePanel.maxWorldRow][gamePanel.maxWorldColumn];\n\n        getTileImage();\n        loadMap(\"/Maps/worldMap.txt\");\n    }\n\n    public void getTileImage() {\n        try {\n            tile[0] = new Tile();\n            tile[0].image = loadImage(\"/Tiles/çim.jpg\");\n            tile[0].collision = false;\n    \n            tile[1] = new Tile();\n            tile[1].image = loadImage(\"/Tiles/yol.jpg\");\n            tile[1].collision = false;\n    \n            tile[2] = new Tile();\n            tile[2].image = loadImage(\"/Tiles/kaldırım.jpg\");\n            tile[2].collision = false;\n    \n            tile[3] = new Tile();\n            tile[3].image = loadImage(\"/Tiles/yaya.jpg\");\n            tile[3].collision = false;\n\n            tile[4] = new Tile();\n            tile[4].image = loadImage(\"/Tiles/1.jpg\");\n            tile[4].collision = true;\n\n            tile[5] = new Tile();\n            tile[5].image = loadImage(\"/Tiles/4.jpg\");\n            tile[5].collision = true;\n\n            tile[6] = new Tile();\n            tile[6].image = loadImage(\"/Tiles/5.jpg\");\n            tile[6].collision = true;\n            \n            tile[7] = new Tile();\n            tile[7].image = loadImage(\"/Tiles/6.jpg\");\n            tile[7].collision = true;\n\n            tile[8] = new Tile();\n            tile[8].image = loadImage(\"/Tiles/7.jpg\");\n            tile[8].collision = true;\n\n            tile[9] = new Tile();\n            tile[9].collision = true;\n    \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private BufferedImage loadImage(String path) throws Exception {\n        return ImageIO.read(getClass().getResourceAsStream(path));\n    }    \n\n    public void loadMap(String filePath) {\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(filePath)))) {\n            for (int row = 0; row < gamePanel.maxWorldRow; row++) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n\n                String[] numbers = line.split(\" \");\n                \n                for (int col = 0; col < gamePanel.maxWorldColumn; col++) {\n                    mapTileNumber[row][col] = Integer.parseInt(numbers[col]);\n                }\n            }\n        } catch (Exception e) {\n            e.getMessage();\n        }\n    }    \n\n    public void draw(Graphics2D g2) {\n        for (int row = 0; row < gamePanel.maxWorldRow; row++) {\n            for (int col = 0; col < gamePanel.maxWorldColumn; col++) {\n                int tileIndex = mapTileNumber[row][col];\n                if (tileIndex < 0 || tileIndex >= tile.length || tile[tileIndex] == null || tile[tileIndex].image == null) {\n                    continue;  \n                }\n                \n                int x = col * gamePanel.tileSize;\n                int y = row * gamePanel.tileSize;\n                if(tileIndex != 4)\n                    g2.drawImage(tile[tileIndex].image, x - gamePanel.cameraX, y - gamePanel.cameraY, gamePanel.tileSize, gamePanel.tileSize, null);\n            \n                if(tileIndex == 4)\n                    g2.drawImage(tile[tileIndex].image, x - gamePanel.cameraX, y - gamePanel.cameraY, 8*gamePanel.tileSize, 13*gamePanel.tileSize, null);\n\n                if(tileIndex == 5 || tileIndex == 6)\n                    g2.drawImage(tile[tileIndex].image, x - gamePanel.cameraX, y - gamePanel.cameraY, 12*gamePanel.tileSize, 8*gamePanel.tileSize, null);\n                \n                if(tileIndex == 7 || tileIndex == 8)\n                    g2.drawImage(tile[tileIndex].image, x - gamePanel.cameraX, y - gamePanel.cameraY, 8*gamePanel.tileSize, 7*gamePanel.tileSize, null);\n            } \n\n        }\n    }    \n}",
      "SoundManager.java": "package Main;\n\nimport java.net.URL;\n\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport javax.sound.sampled.FloatControl;\n\npublic class SoundManager {\n\n    FloatControl fc;\n    Clip clip;\n    URL soundUrl[] = new URL[13];\n    float previousVolume = 0;\n    float currentVolume = 0;\n    boolean isMuted = false;\n\n    public SoundManager() {\n        soundUrl[0] = getClass().getResource(\"/Music/menumusic.wav\");\n        soundUrl[1] = getClass().getResource(\"/Effect/menuNavigationEffect.wav\");\n        soundUrl[2] = getClass().getResource(\"/Effect/menuClickEffect.wav\");\n        soundUrl[3] = getClass().getResource(\"/Effect/menuBackEffect.wav\");\n        soundUrl[4] = getClass().getResource(\"/Effect/pauseMenuExitEffect.wav\");\n        soundUrl[5] = getClass().getResource(\"/Effect/pauseMenuOpeningEffect.wav\");\n        soundUrl[6] = getClass().getResource(\"/Effect/pistolShotEffect.wav\");\n        soundUrl[7] = getClass().getResource(\"/Effect/arShotEffect.wav\");\n        soundUrl[8] = getClass().getResource(\"/Effect/shotgunShotEffect.wav\");\n        soundUrl[9] = getClass().getResource(\"/Effect/sniperShotEffect.wav\");\n        soundUrl[10] = getClass().getResource(\"/Effect/rocketLaunch.wav\");\n        soundUrl[11] = getClass().getResource(\"/Effect/rocketExplode.wav\");\n        soundUrl[12] = getClass().getResource(\"/Music/gamemusic.wav\");\n    }\n\n    public void setFile(int index) {\n        try {\n            AudioInputStream ais = AudioSystem.getAudioInputStream(soundUrl[index]);\n            clip = AudioSystem.getClip();\n            clip.open(ais);\n            fc = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);\n            fc.setValue(-16.0f);\n            currentVolume = -16.0f;\n        } catch (Exception e) {\n            e.getMessage();\n        }\n    }\n\n    public void play() {\n        if(clip.isRunning()){\n            clip.stop();\n        }\n\n        clip.setFramePosition(0);\n        clip.start();\n    }\n\n    public void volumeUp() {\n        if(currentVolume == -80.0f)\n            currentVolume = -40.0f;\n        \n        currentVolume += 8.0f;\n        \n        if(currentVolume > 0)\n            currentVolume = 0;\n        \n        fc.setValue(currentVolume);    \n    }\n\n    public void volumeDown() {\n        currentVolume -= 8.0f;\n        \n        if(currentVolume <= -40.0f)\n            currentVolume = -80.0f; \n        \n        fc.setValue(currentVolume);\n    }\n\n    public void mute() {\n        if(isMuted) {\n            currentVolume = previousVolume;\n            fc.setValue(currentVolume);\n            isMuted = false;\n        } \n        \n        else {\n            previousVolume = currentVolume;\n            currentVolume = -80.0f;\n            fc.setValue(currentVolume);\n            isMuted = true;\n        }\n    }\n\n    public void stop() {\n        clip.stop();\n    }\n\n    public void loop() {\n        clip.loop(Clip.LOOP_CONTINUOUSLY);\n    }\n}",
      "Weapon.java": "package Weapons;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic abstract class Weapon {\n    public int capacity;\n    public int firerate;\n    public int bulletsLeft;\n    public int totalAmmo;\n    public int damage;\n    protected long lastShotTime = 0;\n\n    protected List<Bullet> bullets = new ArrayList<>();\n\n    public Weapon(int capacity, int firerate, int damage, int totalAmmo) {\n        this.capacity = capacity;\n        this.firerate = 60000 / firerate;\n        this.bulletsLeft = capacity;\n        this.totalAmmo = totalAmmo;\n        this.damage = damage;\n    }\n\n    public boolean canShoot() {\n        return (System.currentTimeMillis() - lastShotTime) >= firerate && bulletsLeft > 0;\n    }\n\n    public abstract void shoot(int x, int y, double angle);\n\n    public void reload() {\n        int bulletsNeeded = capacity - bulletsLeft;\n        if (totalAmmo > 0) {\n            int reloadAmount = Math.min(bulletsNeeded, totalAmmo);\n            bulletsLeft += reloadAmount;\n            totalAmmo -= reloadAmount;\n        }\n    }\n\n    public List<Bullet> getBullets() {\n        return bullets;\n    }\n}",
      "Bullet.java": "package Weapons;\n\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\n\npublic class Bullet {\n    public double x, y;\n    private double velocityX, velocityY;\n    public int speed;\n    public boolean piercing;\n    private Rectangle hitbox;\n    public boolean explosive;\n    public boolean isShotgunPellet;\n    private boolean isFromEnemy;\n    private Weapon weaponUsed;\n\n    BufferedImage pistolBullet, arBullet, shotgunBullet, sniperBullet, rocketBullet, acidBullet;\n\n    public Bullet(int x, int y, double angle, int speed) {\n        this(x, y, angle, speed, false, false, false, false, new Pistol());\n    }\n\n    public Bullet(int x, int y, double angle, int speed, boolean piercing, boolean explosive, boolean isShotgunPellet, boolean isFromEnemy, Weapon weaponUsed) {\n        this.x = x;\n        this.y = y;\n        this.piercing = piercing;\n        this.explosive = explosive;\n        this.isShotgunPellet = isShotgunPellet;\n        this.isFromEnemy = isFromEnemy;\n        this.speed = speed;\n        this.weaponUsed = weaponUsed;\n\n        double dirX = Math.cos(angle);\n        double dirY = Math.sin(angle);\n        double length = Math.sqrt(dirX * dirX + dirY * dirY);\n        \n        velocityX = (dirX / length) * speed;\n        velocityY = (dirY / length) * speed;\n\n        this.hitbox = new Rectangle((int) x, (int) y, 5, 5);\n    }\n\n    public void update() {\n        x += velocityX;\n        y += velocityY;\n        hitbox.setLocation((int) x, (int) y);\n    }\n\n    public void draw(Graphics2D g, int cameraX, int cameraY) {\n        int screenX = (int) x - cameraX;\n        int screenY = (int) y - cameraY;\n        \n        BufferedImage bulletImage = null;\n    \n        try {\n            if (isFromEnemy) {\n                if (acidBullet == null) {\n                    acidBullet = ImageIO.read(getClass().getResource(\"/Bullets/acidBullet.png\"));\n                }\n                bulletImage = acidBullet;\n            } \n            \n            else if (weaponUsed instanceof Shotgun) {\n                if (shotgunBullet == null) {\n                    shotgunBullet = ImageIO.read(getClass().getResource(\"/Bullets/shotgunBullet.png\"));\n                }\n                bulletImage = shotgunBullet;\n            } \n            \n            else if (weaponUsed instanceof SniperRifle) {\n                if (sniperBullet == null) {\n                    sniperBullet = ImageIO.read(getClass().getResource(\"/Bullets/sniperBullet.png\"));\n                }\n                bulletImage = sniperBullet;\n            } \n            \n            else if (weaponUsed instanceof RocketLauncher) {\n                if (rocketBullet == null) {\n                    rocketBullet = ImageIO.read(getClass().getResource(\"/Bullets/rocketBullet.png\"));\n                }\n                bulletImage = rocketBullet;\n            } \n            \n            else if (weaponUsed instanceof AssaultRifle) {\n                if (arBullet == null) {\n                    arBullet = ImageIO.read(getClass().getResource(\"/Bullets/arBullet.png\"));\n                }\n                bulletImage = arBullet;\n            } \n            \n            else {\n                if (pistolBullet == null) {\n                    pistolBullet = ImageIO.read(getClass().getResource(\"/Bullets/pistolBullet.png\"));\n                }\n                bulletImage = pistolBullet;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    \n        if (bulletImage != null) {\n            g.drawImage(bulletImage, screenX, screenY, null);\n        }\n    }    \n\n    public boolean isFromEnemy() {\n        return isFromEnemy;\n    }\n\n    public Rectangle getHitbox() {\n        return hitbox;\n    }\n\n    public boolean isPiercing() {\n        return piercing;\n    }    \n\n    public double getAngle() {\n        return Math.atan2(velocityY, velocityX);\n    }\n}",
      "Shotgun.java": "package Weapons;\n\npublic class Shotgun extends Weapon {\n    public Shotgun() {\n        super(5, 60, 30, 20);\n    }\n\n    @Override\n    public void shoot(int x, int y, double angle) {\n        if (canShoot()) {\n            for (int i = -4; i <= 4; i++) {\n                double spread = Math.toRadians(i * 5);\n                bullets.add(new Bullet(x, y, angle + spread, 30,false, false, true, false, this));\n            }\n            \n            bulletsLeft--;\n            lastShotTime = System.currentTimeMillis();\n        }\n    }\n}",
      "SniperRifle.java": "package Weapons;\n\npublic class SniperRifle extends Weapon {\n    public SniperRifle() {\n        super(5, 30, 120, 15);\n    }\n\n    @Override\n    public void shoot(int x, int y, double angle) {\n        if (canShoot()) {\n            bullets.add(new Bullet(x, y, angle, 30,true, false, false, false, this));\n            bulletsLeft--;\n            lastShotTime = System.currentTimeMillis();\n        }\n    }\n}",
      "Pistol.java": "package Weapons;\n\npublic class Pistol extends Weapon {\n    public Pistol() {\n        super(12, 120, 20, Integer.MAX_VALUE);\n    }\n\n    @Override\n    public void shoot(int x, int y, double angle) {\n        if (canShoot()) {\n            bullets.add(new Bullet(x, y, angle, 30));\n            bulletsLeft--;\n            lastShotTime = System.currentTimeMillis();\n        }\n    }\n}",
      "AssaultRifle.java": "package Weapons;\n\nimport java.util.Random;\n\npublic class AssaultRifle extends Weapon {\n    private Random random = new Random();\n\n    public AssaultRifle() {\n        super(30, 600, 25, 90);\n    }\n\n    @Override\n    public void shoot(int x, int y, double angle) {\n        if (canShoot()) {\n            double spread = Math.toRadians(random.nextInt(31) - 15);\n            bullets.add(new Bullet(x, y, angle + spread, 30));\n            bulletsLeft--;\n            lastShotTime = System.currentTimeMillis();\n        }\n    }\n}",
      "RocketLauncher.java": "package Weapons;\n\npublic class RocketLauncher extends Weapon {\n    public RocketLauncher() {\n        super(1, 10, 200, 5);\n    }\n\n    @Override\n    public void shoot(int x, int y, double angle) {\n        if (canShoot()) {\n            bullets.add(new Bullet(x, y, angle, 15,false, true, false, false, this));\n            bulletsLeft--;\n            lastShotTime = System.currentTimeMillis();\n        }\n    }\n}",
      "Pickup.java": "package Items;\n\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\nimport Main.GamePanel;\nimport Player.Player;\nimport Weapons.AssaultRifle;\nimport Weapons.RocketLauncher;\nimport Weapons.Shotgun;\nimport Weapons.SniperRifle;\nimport Weapons.Weapon;\n\npublic class Pickup {\n    public int worldX, worldY;\n    private BufferedImage sprite;\n    private Rectangle hitbox;\n    private String type;\n    private boolean collected = false;\n\n    public Pickup(int x, int y, String type) {\n        this.worldX = x;\n        this.worldY = y;\n        this.type = type;\n        this.hitbox = new Rectangle(x, y, 32, 32);\n\n        loadSprite();\n    }\n\n    private void loadSprite() {\n        try {\n            switch (type) {\n                case \"health\":\n                    sprite = ImageIO.read(getClass().getResourceAsStream(\"/Items/health.png\"));\n                    break;\n                case \"ar\":\n                    sprite = ImageIO.read(getClass().getResourceAsStream(\"/Items/arammo.png\"));\n                    break;\n                case \"shotgun\":\n                    sprite = ImageIO.read(getClass().getResourceAsStream(\"/Items/shotgunammo.png\"));\n                    break;\n                case \"sniper\":\n                    sprite = ImageIO.read(getClass().getResourceAsStream(\"/Items/sniperammo.png\"));\n                    break;\n                case \"rocket\":\n                    sprite = ImageIO.read(getClass().getResourceAsStream(\"/Items/rocketammo.png\"));\n                    break;\n            }\n        } catch (Exception e) {\n            e.getMessage();\n        }\n    }\n\n    public void update(Player player) {\n        if (!collected && player.hitbox.intersects(hitbox)) {\n            applyEffect(player);\n            collected = true;\n        }\n    }\n\n    private void applyEffect(Player player) {\n        if (type.equals(\"health\")) {\n            if (player.health <= 80)\n                player.health += 20;\n            else\n                player.health += 100 - player.health;\n        } \n        \n        else {\n            for (Weapon weapon : player.weapons) {\n                if (type.equals(\"ar\") && weapon instanceof AssaultRifle) {\n                    weapon.totalAmmo += 30;\n                    break;\n                } \n\n                else if (type.equals(\"shotgun\") && weapon instanceof Shotgun) {\n                    weapon.totalAmmo += 5;\n                    break;\n                } \n                \n                else if (type.equals(\"sniper\") && weapon instanceof SniperRifle) {\n                    weapon.totalAmmo += 5; \n                    break; \n                } \n                \n                else if (type.equals(\"rocket\") && weapon instanceof RocketLauncher) {\n                    weapon.totalAmmo += 1; \n                    break;\n                }\n            }\n        }\n    }\n\n    public void draw(Graphics2D g2, GamePanel gamePanel) {\n        if (!collected) {\n            int screenX = worldX - gamePanel.cameraX;\n            int screenY = worldY - gamePanel.cameraY;\n            g2.drawImage(sprite, screenX, screenY, 32, 32, null);\n        }\n    }\n}",
      "Zombie.java": "package Zombies;\n\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.AffineTransformOp;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\n\nimport Items.Pickup;\n\nimport java.util.List;\nimport java.util.Random;\n\nimport Main.GamePanel;\nimport Main.WaveManager;\nimport Player.Player;\n\npublic class Zombie {\n    public int worldX, worldY;\n    public int health;\n    public int speed;\n    public int damage;\n    protected boolean alive = true;\n    public Rectangle hitbox;\n    protected int knockbackX;\n    protected int knockbackY;\n    protected int knockbackDuration;\n    public boolean canBeKnockedBack = true;\n\n    protected BufferedImage[] sprites;\n    protected BufferedImage[] attackSprites;\n    protected BufferedImage[] hurtSprites;\n    protected BufferedImage[] deadSprites;\n    private int frameIndex = 0;\n    private int frameDelay = 10;\n    private int frameCounter = 0;\n\n    private int attackFrameIndex = 0;\n    private int hurtFrameIndex = 0;\n    private int deadFrameIndex = 0;\n\n    public int spriteWidth;\n    public int spriteHeight;\n    public String spritePath;\n    public String attackSpritePath;\n    public String hurtSpritePath;\n    public String deadSpritePath;\n    public int frameCount;\n    public int attackFrames;\n    public int hurtFrames;\n    public int deadFrames;\n\n    private boolean hasDealtDamage = false;\n    protected boolean isAttacking = false;\n    private boolean isHurt = false;\n    private int attackCounter = 0;\n    private int hurtCounter = 0;\n    private final int hurtDuration = 20;\n    private boolean isDying = false;\n    private int deathCounter = 0;\n    private final int deathDuration = 60;\n\n    protected long lastAttackTime = 0;\n    protected long attackCooldown = 1000;\n\n    public Zombie(int worldX, int worldY, int health, int speed, int damage, String spritePath, int frames, int spriteWidth, int spriteHeight, String attackSpritePath, int attackFrames, String hurtSpritePath, int hurtFrames, String deadSpritePath, int deadFrames, boolean canBeKnockedBack) {\n        this.spritePath = spritePath;\n        this.attackSpritePath = attackSpritePath;\n        this.hurtSpritePath = hurtSpritePath;\n        this.deadSpritePath = deadSpritePath;\n        this.attackFrames = attackFrames;\n        this.hurtFrames = hurtFrames;\n        this.deadFrames = deadFrames;\n        this.frameCount = frames;\n        this.worldX = worldX;\n        this.worldY = worldY;\n        this.health = health;\n        this.speed = speed;\n        this.damage = damage;\n        this.spriteWidth = spriteWidth;\n        this.spriteHeight = spriteHeight;\n        this.hitbox = new Rectangle(worldX, worldY, 48, 64);\n        this.canBeKnockedBack = canBeKnockedBack;\n        loadSprites(spritePath, frames, spriteWidth, spriteHeight);\n        loadAttackSprites(attackSpritePath, attackFrames, spriteWidth, spriteHeight);\n        loadHurtSprites(hurtSpritePath, spriteWidth, spriteHeight);\n        loadDeadSprites(deadSpritePath, deadFrames, spriteWidth, spriteHeight);\n    }\n\n    public long getLastAttackTime() {\n        return lastAttackTime;\n    }\n\n    public void setLastAttackTime(long lastAttackTime) {\n        this.lastAttackTime = lastAttackTime;\n    }\n\n    private void loadSprites(String path, int frames, int spriteWidth, int spriteHeight) {\n        try {\n            BufferedImage spriteSheet = ImageIO.read(getClass().getResourceAsStream(path));\n            sprites = new BufferedImage[frames];\n\n            for (int i = 0; i < frames; i++) {\n                sprites[i] = spriteSheet.getSubimage(i * spriteWidth, 0, spriteWidth, spriteHeight);\n            }\n        } catch (Exception e) {\n            e.getMessage();\n        }\n    }\n\n    private void loadAttackSprites(String path, int frames, int spriteWidth, int spriteHeight) {\n        try {\n            BufferedImage spriteSheet = ImageIO.read(getClass().getResourceAsStream(path));\n            attackSprites = new BufferedImage[frames];\n\n            for (int i = 0; i < frames; i++) {\n                attackSprites[i] = spriteSheet.getSubimage(i * spriteWidth, 0, spriteWidth, spriteHeight);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void loadHurtSprites(String path, int spriteWidth, int spriteHeight) {\n        try {\n            BufferedImage spriteSheet = ImageIO.read(getClass().getResourceAsStream(path));\n            hurtSprites = new BufferedImage[2];\n            for (int i = 0; i < 2; i++) {\n                hurtSprites[i] = spriteSheet.getSubimage(i * spriteWidth, 0, spriteWidth, spriteHeight);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void loadDeadSprites(String path, int frames, int spriteWidth, int spriteHeight) {\n        try {\n            BufferedImage spriteSheet = ImageIO.read(getClass().getResourceAsStream(path));\n            deadSprites = new BufferedImage[frames];\n            for (int i = 0; i < frames; i++) {\n                deadSprites[i] = spriteSheet.getSubimage(i * spriteWidth, 0, spriteWidth, spriteHeight);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void moveTowardsPlayer(int playerX, int playerY, GamePanel gamePanel) {\n        if (isDying) return;\n    \n        if (!alive || knockbackDuration > 0) {\n            int nextX = worldX + knockbackX;\n            int nextY = worldY + knockbackY;\n    \n            if (!gamePanel.collisionChecker.checkZombieTileCollision(this, nextX, worldY)) {\n                worldX = nextX;\n            }\n    \n            if (!gamePanel.collisionChecker.checkZombieTileCollision(this, worldX, nextY)) {\n                worldY = nextY;\n            }\n    \n            knockbackDuration--;\n            hitbox.setLocation(worldX, worldY);\n            return;\n        }\n    \n        int nextX = worldX;\n        int nextY = worldY;\n    \n        boolean canMoveX = true, canMoveY = true;\n    \n        if (playerX > worldX) {\n            nextX += speed;\n        } \n        \n        else if (playerX < worldX) {\n            nextX -= speed;\n        }\n    \n        if (gamePanel.collisionChecker.checkZombieTileCollision(this, nextX, worldY)) {\n            canMoveX = false;\n        }\n    \n        if (playerY > worldY) {\n            nextY += speed;\n        } \n        \n        else if (playerY < worldY) {\n            nextY -= speed;\n        }\n    \n        if (gamePanel.collisionChecker.checkZombieTileCollision(this, worldX, nextY)) {\n            canMoveY = false;\n        }\n    \n        if (canMoveX && canMoveY) {\n            if (Math.abs(playerX - worldX) > Math.abs(playerY - worldY)) {\n                worldX = nextX;\n            } \n            \n            else {\n                worldY = nextY;\n            }\n        } \n        \n        else if (canMoveX) {\n            worldX = nextX;\n        } \n        \n        else if (canMoveY) {\n            worldY = nextY;\n        }\n    \n        hitbox.setLocation(worldX, worldY);\n    }\n    \n    public void attack(Player player) {\n        if (!isAttacking && !(this instanceof CorrosiveZombie)) {\n            isAttacking = true;\n            attackFrameIndex = 0;\n            attackCounter = 0;\n        }\n\n        if (attackFrameIndex == attackSprites.length / 2) {\n            player.takeDamage(this.damage);\n        }\n    }\n\n    public void updateAnimation(Player player) {\n        if (isDying) {\n            deathCounter++;\n    \n            if (deathCounter % 10 == 0) {\n                deadFrameIndex++;\n            }\n    \n            if (deadFrameIndex >= deadSprites.length) {\n                deadFrameIndex = deadSprites.length - 1;\n            }\n    \n            if (deathCounter >= deathDuration) {\n                alive = false;\n            }\n\n            return;\n        }\n    \n        if (isAttacking) {\n            attackCounter++;\n    \n            if (attackCounter % 10 == 0) {\n                attackFrameIndex++;\n    \n                if (!(this instanceof CorrosiveZombie) \n                    && attackFrameIndex == attackSprites.length / 2 \n                    && !hasDealtDamage) {\n    \n                    player.takeDamage(this.damage);\n                    hasDealtDamage = true;\n                }\n    \n                if (attackFrameIndex >= attackSprites.length) { \n                    isAttacking = false;\n                    attackFrameIndex = 0;\n                    hasDealtDamage = false;\n                }\n            }\n        }\n    \n        if (isHurt && !isAttacking) {\n            hurtCounter++;\n    \n            if (hurtCounter % 10 == 0) {\n                hurtFrameIndex = (hurtFrameIndex + 1) % hurtSprites.length;\n            }\n            if (hurtCounter >= hurtDuration) {\n                isHurt = false;\n            }\n        }\n    }\n\n    public void takeDamage(int damage, double bulletAngle, int knockbackPower, Player player) {\n        if (isDying) return;\n\n        health -= damage;\n        isHurt = true;\n        hurtFrameIndex = 0;\n        hurtCounter = 0;\n\n        if (canBeKnockedBack && knockbackDuration == 0) {\n            knockbackX = (int) (Math.cos(bulletAngle) * knockbackPower);\n            knockbackY = (int) (Math.sin(bulletAngle) * knockbackPower);\n            knockbackDuration = 5;\n        }\n\n        if (health <= 0) {\n            die(player);\n        }\n    }\n\n    protected void die(Player player) {\n        if(this instanceof NormalZombie)\n            player.score += 10;\n\n        if(this instanceof CrawlingZombie)\n            player.score += 20;\n\n        if(this instanceof CorrosiveZombie)\n            player.score += 30;\n\n        if(this instanceof TankZombie)\n            player.score += 50;\n\n        isDying = true;\n        deadFrameIndex = 0;\n        deathCounter = 0;\n        player.killCounter++;\n        Random rand = new Random();\n        int dropChance = rand.nextInt(100);\n    \n        if (dropChance < 35) {\n\n            if (dropChance < 10) {\n                GamePanel.pickups.add(new Pickup(worldX, worldY, \"health\"));\n            } \n            \n            else {\n                int ammoTypeChance = rand.nextInt(100);\n                String ammoType = null;\n    \n                if (WaveManager.waveNumber >= 11) { \n                    if (ammoTypeChance < 45) \n                        ammoType = \"ar\";\n                    \n                    else if (ammoTypeChance < 70) \n                        ammoType = \"shotgun\";\n                    \n                    else if (ammoTypeChance < 90) \n                        ammoType = \"sniper\";\n                    \n                    else \n                        ammoType = \"rocket\"; // %10 Rocket\n                } \n                \n                else if (WaveManager.waveNumber >= 6) { \n                    if (ammoTypeChance < 50) \n                        ammoType = \"ar\";\n                    \n                    else if (ammoTypeChance < 80) \n                        ammoType = \"shotgun\";\n                    \n                    else \n                        ammoType = \"sniper\";\n                } \n                \n                else if (WaveManager.waveNumber >= 4) { \n                    if (ammoTypeChance < 70) \n                        ammoType = \"ar\";\n                    \n                    else \n                        ammoType = \"shotgun\";\n                } \n                \n                else if (WaveManager.waveNumber >= 2) { \n                    ammoType = \"ar\";\n                }\n    \n                if (ammoType != null) {\n                    GamePanel.pickups.add(new Pickup(worldX, worldY, ammoType));\n                }\n            }\n        }\n    }    \n\n    public boolean isAlive() {\n        return !isDying || deathCounter < deathDuration;\n    }\n\n    public void draw(Graphics2D g2, GamePanel gp, int cameraX, int cameraY, int playerX) {\n        if (!alive) return;\n    \n        int screenX = (worldX - cameraX) - (spriteWidth / 2) + (hitbox.width / 2);\n        int screenY = (worldY - cameraY) - (spriteHeight / 2) + (hitbox.height / 2) - 16;\n        boolean shouldFlip = worldX > playerX;\n    \n        if (this instanceof CrawlingZombie) {\n            screenY -= spriteHeight / 2 - 24;\n            hitbox.height = 48;\n        }\n        if (this instanceof TankZombie || this instanceof CorrosiveZombie) {\n            screenY -= spriteHeight / 2 - 48;\n        }\n    \n        if (screenX + spriteWidth > 0 && screenX < gp.screenWidth && screenY + spriteHeight > 0 && screenY < gp.screenHeight) {\n            BufferedImage sprite;\n    \n            if (isDying) {\n                sprite = deadSprites[Math.min(deadFrameIndex, deadSprites.length - 1)];\n                deathCounter++;\n                if (deathCounter % 10 == 0) {\n                    deadFrameIndex++;\n                }\n                \n                if (deadFrameIndex >= deadSprites.length) {\n                    deadFrameIndex = deadSprites.length - 1;\n                }\n            } \n            \n            else if (isHurt) {\n                sprite = hurtSprites[hurtFrameIndex];\n            } \n            \n            else if (isAttacking) {\n                sprite = attackSprites[attackFrameIndex];\n            } \n            \n            else {\n                frameCounter++;\n                if (frameCounter >= frameDelay) {\n                    frameIndex = (frameIndex + 1) % sprites.length;\n                    frameCounter = 0;\n                }\n                sprite = sprites[frameIndex];\n            }\n    \n            if (shouldFlip) {\n                AffineTransform tx = AffineTransform.getScaleInstance(-1, 1);\n                tx.translate(-sprite.getWidth(), 0);\n                AffineTransformOp op = new AffineTransformOp(tx, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);\n                sprite = op.filter(sprite, null);\n            }\n    \n            g2.drawImage(sprite, screenX, screenY, spriteWidth, spriteHeight, null);\n        }\n    }\n\n    public int getDamage() {\n        return damage;\n    }\n\n    public static void updateZombies(List<Zombie> zombies, Player player, GamePanel gamePanel) {\n        long currentTime = System.currentTimeMillis();\n        \n        for (int i = zombies.size() - 1; i >= 0; i--) {\n            Zombie zombie = zombies.get(i);\n            \n            if (zombie.isAlive()) {\n                zombie.moveTowardsPlayer(player.getWorldX(), player.getWorldY(), gamePanel);\n                \n                zombie.updateAnimation(player);\n                \n                if (zombie.hitbox.intersects(player.hitbox)) {\n                    if (currentTime - zombie.getLastAttackTime() >= zombie.attackCooldown) {\n                        zombie.attack(player);\n                        zombie.setLastAttackTime(currentTime);\n                    }\n                }\n            } \n            \n            else {\n                if (zombie instanceof CorrosiveZombie) {\n                    gamePanel.explodeOnDeath((CorrosiveZombie) zombie);\n                }\n                zombies.remove(i);\n            }\n        }\n    \n        gamePanel.collisionChecker.checkZombieCollisions(zombies);\n    }\n      \n    \n    public static void drawZombies(Graphics2D g2, List<Zombie> zombies, GamePanel gamePanel, Player player) {\n        try {\n            for (Zombie zombie : zombies) {\n                if (zombie.isAlive()) {\n                    zombie.draw(g2, gamePanel, gamePanel.cameraX, gamePanel.cameraY, player.getWorldX());\n                }\n            }\n        } catch (Exception e) {\n            \n        }\n    }    \n}",
      "CrawlingZombie.java": "package Zombies;\n\nimport Main.GamePanel;\n\npublic class CrawlingZombie extends Zombie {\n    private boolean isJumping = false;\n    private boolean hasJumped = false;\n    private int jumpProgress = 0;\n    private final int jumpDuration = 15;\n    private int jumpStartX, jumpStartY;\n    private int targetX, targetY;\n\n    public CrawlingZombie(int x, int y) {\n        super(x, y, 80, 2, 20, \"/ZombieImages/crawlingZombieWalk.png\", 10, 96, 96, \"/ZombieImages/crawlingAttack.png\", 4, \"/ZombieImages/crawlingHurt.png\", 5, \"/ZombieImages/crawlingDead.png\", 5, true);\n    }\n\n    @Override\n    public void moveTowardsPlayer(int playerX, int playerY, GamePanel gamePanel) {\n        if (!alive) \n            return;\n\n        if (knockbackDuration > 0) {\n            worldX += knockbackX;\n            worldY += knockbackY;\n            knockbackDuration--;\n            hitbox.setLocation(worldX, worldY);\n            return; \n        }\n\n        int dx = playerX - worldX;\n        int dy = playerY - worldY;\n        double distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (!hasJumped && !isJumping && distance < 150) {\n            isJumping = true;\n            hasJumped = true;\n            jumpProgress = 0;\n            jumpStartX = worldX;\n            jumpStartY = worldY;\n            targetX = playerX;\n            targetY = playerY;\n        }\n\n        if (isJumping) {\n            jumpProgress++;\n\n            double t = (double) jumpProgress / jumpDuration;\n            if (t > 1) \n                t = 1;\n\n            worldX = (int) (jumpStartX + t * (targetX - jumpStartX));\n            worldY = (int) (jumpStartY + t * (targetY - jumpStartY));\n\n            if (jumpProgress >= jumpDuration) {\n                isJumping = false;\n            }\n        } \n        \n        else {\n            super.moveTowardsPlayer(playerX, playerY, gamePanel);\n        }\n\n        hitbox.setLocation(worldX, worldY);\n    }\n}",
      "NormalZombie.java": "package Zombies;\npublic class NormalZombie extends Zombie {\n    public NormalZombie(int x, int y) {\n        super(x, y, 120, 1, 10, \"/ZombieImages/normalZombieWalk.png\", 8, 96, 96, \"/ZombieImages/normalAttack.png\", 4, \"/ZombieImages/normalHurt.png\", 3,\"/ZombieImages/normalDead.png\", 5,true);\n    }\n}",
      "TankZombie.java": "package Zombies;\npublic class TankZombie extends Zombie {\n    public TankZombie(int x, int y) {\n        super(x, y, 400, 1, 30, \"/ZombieImages/tankZombieWalk.png\", 10, 128, 128, \"/ZombieImages/tankAttack.png\", 5, \"/ZombieImages/tankHurt.png\", 4, \"/ZombieImages/tankDead.png\", 5,false);\n    }\n}",
      "CorrosiveZombie.java": "package Zombies;\n\nimport Weapons.Bullet;\nimport java.util.List;\n\nimport Main.GamePanel;\n\npublic class CorrosiveZombie extends Zombie {\n    private long lastSpitTime = 0;\n    private final int spitCooldown = 2000;\n    private final int spitRange = 200;\n    private boolean isSpitting = false;\n\n    public CorrosiveZombie(int x, int y) {\n        super(x, y, 120, 1, 20, \"/ZombieImages/corrosiveZombieWalk.png\", 10, 128, 128, \"/ZombieImages/corrosiveAttack.png\", 4, \"/ZombieImages/corrosiveHurt.png\", 4, \"/ZombieImages/corrosiveDead.png\", 5,true);\n    }\n\n    private boolean isPlayerInRange(int playerX, int playerY) {\n        int dx = playerX - this.worldX;\n        int dy = playerY - this.worldY;\n        return Math.sqrt(dx * dx + dy * dy) <= spitRange;\n    }\n\n    private int moveCounter = 0;\n\n    public void update(int playerX, int playerY, List<Bullet> projectiles, GamePanel gamePanel) {\n        long currentTime = System.currentTimeMillis();\n\n        if (isPlayerInRange(playerX, playerY)) {\n            if (currentTime - lastSpitTime >= spitCooldown) {\n                isSpitting = true;\n                isAttacking = true;\n                spitAcid(playerX, playerY, projectiles);\n            }\n        } \n        \n        else {\n            isSpitting = false;\n            isAttacking = false;\n            \n            moveCounter++;\n            \n            if (moveCounter % 3 == 0) {\n                moveTowardsPlayer(playerX, playerY, gamePanel);\n            }\n        }\n    }   \n\n    private void spitAcid(int playerX, int playerY, List<Bullet> projectiles) {\n        long currentTime = System.currentTimeMillis();\n    \n        if (currentTime - lastSpitTime >= spitCooldown) {\n            double angle = Math.atan2(playerY - this.worldY, playerX - this.worldX);\n            Bullet acidBullet = new Bullet(this.worldX, this.worldY, angle, 5, false, false, false, true, null);\n            projectiles.add(acidBullet);\n            lastSpitTime = currentTime;\n        }\n    }    \n\n    @Override\n    public void moveTowardsPlayer(int playerX, int playerY, GamePanel gamePanel) {\n        if (!isSpitting) {\n            super.moveTowardsPlayer(playerX, playerY, gamePanel);\n        }\n    }\n}",
      "Player.java": "package Player;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\nimport java.util.List;\nimport java.util.ArrayList;\n\nimport Main.GamePanel;\nimport Main.KeyHandler;\nimport Main.WaveManager;\nimport Weapons.*;\nimport Zombies.Zombie;\nimport Main.Font;\n\npublic class Player implements MouseMotionListener, MouseListener {\n    private Font font = new Font();\n    GamePanel gamePanel;\n    KeyHandler keyHandler;\n    public Weapon currentWeapon;\n\n    public List<Weapon> weapons = new ArrayList<>();\n    List<Bullet> bullets = new ArrayList<>();\n\n    public int cameraX;\n    public int cameraY;\n    public int worldX;\n    public int worldY;\n    public int health = 100;\n    public int maxHealth = 100;\n    public int killCounter = 0;;\n    public int score = 0;\n    public int speed = 4;\n    public int size = 48;\n    private double angle = 0;\n    private long lastShotTime = 0;\n    private int currentFrame = 0;\n    private long lastFrameTime = 0;\n    private long lastDamageTime = 0;\n    private final int damageCooldown = 1000;\n    private boolean qWasPressed;\n    private int[] healthIndex = new int[2];\n\n    public Rectangle hitbox;\n    Image playerImage;\n    BufferedImage pistolImage, arImage, shotgunImage, sniperImage, rocketImage, healthBarImage;\n    private BufferedImage[][] walkingSprites_Pistol = new BufferedImage[10][6];\n    private BufferedImage[][] walkingSprites_AR = new BufferedImage[10][6]; \n    private BufferedImage[][] walkingSprites_Shotgun = new BufferedImage[10][6];\n    private BufferedImage[][] walkingSprites_Sniper = new BufferedImage[10][6];\n    private BufferedImage[][] walkingSprites_Rocket = new BufferedImage[10][6];\n    private BufferedImage[][] healthBar = new BufferedImage[5][2];\n\n    public Player(GamePanel gamePanel, KeyHandler keyHandler) {\n        this.gamePanel = gamePanel;\n        this.keyHandler = keyHandler;\n        this.worldX = gamePanel.worldWidth / 2;\n        this.worldY = gamePanel.worldHeight / 2;\n        this.hitbox = new Rectangle(worldX, worldY, size, size);\n        \n        gamePanel.addMouseMotionListener(this);\n        gamePanel.addMouseListener(this);\n\n        weapons.add(new Pistol());\n\n        currentWeapon = weapons.get(0);\n        try {\n            pistolImage = ImageIO.read(getClass().getResource(\"/Images/pistol.png\"));\n            arImage = ImageIO.read(getClass().getResource(\"/Images/ar.png\"));\n            shotgunImage = ImageIO.read(getClass().getResource(\"/Images/shotgun.png\"));\n            sniperImage = ImageIO.read(getClass().getResource(\"/Images/sniper.png\"));\n            rocketImage = ImageIO.read(getClass().getResource(\"/Images/rocket.png\"));\n            healthBarImage = ImageIO.read(getClass().getResource(\"/Images/HEALTHBAR.png\"));\n        } catch (Exception e) {\n            e.getMessage();\n        }\n        \n        loadSprites();\n    }\n\n    private void loadSprites() {\n        try {\n            loadWeaponSprites(\"/Images/walkWithPistol_\", walkingSprites_Pistol);\n            loadWeaponSprites(\"/Images/walkWithAssaultRifle_\", walkingSprites_AR);\n            loadWeaponSprites(\"/Images/walkWithShotgun_\", walkingSprites_Shotgun);\n            loadWeaponSprites(\"/Images/walkWithSniper_\", walkingSprites_Sniper);\n            loadWeaponSprites(\"/Images/walkWithRocket_\", walkingSprites_Rocket);\n        } catch (Exception e) {\n            e.getMessage();\n        }\n    }\n\n    private void loadWeaponSprites(String basePath, BufferedImage[][] spriteArray) throws Exception {\n        String[] directions = {\"0_right\", \"45_right\", \"90_right\", \"135_right\", \"180_right\", \"0_left\", \"45_left\", \"90_left\", \"135_left\", \"180_left\"};\n    \n        for (int d = 0; d < 10; d++) {\n            BufferedImage sheet = ImageIO.read(getClass().getResource(basePath + directions[d] + \".png\"));\n            \n            for (int i = 0; i < 6; i++) {\n                spriteArray[d][i] = sheet.getSubimage(i * size, 0, size, size);\n            }\n        }\n    }\n\n    private int getDirectionIndex() {\n        double angleDeg = Math.toDegrees(angle);\n        \n        if(angleDeg <= 90 && angleDeg > 80) {\n            return 0;\n        }\n        \n        if(angleDeg <= 80 && angleDeg > 10) {\n            return 1;\n        }    \n        \n        if(angleDeg <= 10 && angleDeg > -10) {\n            return 2;\n        }\n        \n        if(angleDeg <= -10 && angleDeg > -80) {\n            return 3;\n        }\n        \n        if(angleDeg <= -80 && angleDeg > -90) {\n            return 4;\n        }\n        \n        if(angleDeg <= -90 && angleDeg > -100) {\n            return 9;\n        }\n        \n        if(angleDeg <= -100 && angleDeg > -170) {\n            return 8;\n        }\n        \n        if(angleDeg <= -170 && angleDeg > -180) {\n            return 7;\n        }\n        \n        if(angleDeg <= 180 && angleDeg > 170) {\n            return 7;\n        }\n        \n        if(angleDeg <= 170 && angleDeg > 100) {\n            return 6;\n        }\n        return 5;\n    }\n    \n    public void update() {\n        int nextX = worldX;\n        int nextY = worldY;\n    \n        gamePanel.cameraX = worldX - gamePanel.screenWidth / 2;\n        gamePanel.cameraY = worldY - gamePanel.screenHeight / 2;\n\n        if (gamePanel.cameraX < 0) {\n            gamePanel.cameraX = 0;\n        }\n        \n        if (gamePanel.cameraY < 0) { \n            gamePanel.cameraY = 0;\n        }\n        \n        if (gamePanel.cameraX > gamePanel.worldWidth - gamePanel.screenWidth) {\n            gamePanel.cameraX = gamePanel.worldWidth - gamePanel.screenWidth;\n        }\n        \n        if (gamePanel.cameraY > gamePanel.worldHeight - gamePanel.screenHeight) {\n            gamePanel.cameraY = gamePanel.worldHeight - gamePanel.screenHeight;\n        }\n\n        if (keyHandler.upPressed) \n            nextY -= speed;\n        \n        if (keyHandler.downPressed) \n            nextY += speed;\n    \n        if (keyHandler.leftPressed) \n            nextX -= speed;\n    \n        if (keyHandler.rightPressed) \n            nextX += speed;\n    \n            if (!gamePanel.collisionChecker.checkCollision(this, nextX, nextY) &&\n            !gamePanel.collisionChecker.checkTileCollision(this, nextX, nextY)) {\n            worldX = nextX;\n            worldY = nextY;\n        }\n        \n        hitbox.setLocation(worldX, worldY);\n    \n        if (keyHandler.rPressed) {\n            currentWeapon.reload();\n        }\n\n        if (keyHandler.qPressed && !qWasPressed) {\n            switchWeapon();\n            qWasPressed = true;\n        } \n        \n        else if (!keyHandler.qPressed) {\n            qWasPressed = false;\n        }\n    \n        bullets.removeIf(bullet -> bullet.x < 0 || bullet.y < 0 || bullet.x > gamePanel.worldWidth || bullet.y > gamePanel.worldHeight);\n    \n        try {\n            for (Bullet bullet : bullets) {\n                bullet.update();\n            }\n        } catch (Exception e) {\n            \n        }\n        for (Bullet bullet : bullets) {\n            bullet.update();\n        }\n        checkBulletCollisions();\n\n        if (keyHandler.upPressed || keyHandler.downPressed || keyHandler.leftPressed || keyHandler.rightPressed) {\n            long currentTime = System.currentTimeMillis();\n            \n            if (currentTime - lastFrameTime > 100) { \n                currentFrame = (currentFrame + 1) % getCurrentWeaponSprites()[getDirectionIndex()].length;\n                lastFrameTime = currentTime;\n            }            \n        } \n\n        else {\n            currentFrame = 0;\n        }\n    }\n\n    private void checkBulletCollisions() {\n        for (int x = 0; x < bullets.size(); x++) {\n            Bullet bullet = bullets.get(x);\n            boolean shouldRemove = false;\n    \n            for (Zombie zombie : gamePanel.zombies) {\n                if (zombie.isAlive() && bullet.getHitbox().intersects(zombie.hitbox)) {\n                    double bulletAngle = bullet.getAngle();\n                    int knockbackPower = getKnockbackPower(currentWeapon);\n    \n                    zombie.takeDamage(currentWeapon.damage, bulletAngle, knockbackPower, this);\n    \n                    if (currentWeapon instanceof RocketLauncher) {\n                        gamePanel.effectManager.setFile(11);\n                        gamePanel.effectManager.play();\n                        applyExplosionDamage(bullet.x, bullet.y, 500, currentWeapon.damage);\n                    }\n    \n                    if (!(currentWeapon instanceof SniperRifle) && !bullet.isPiercing()) {\n                        shouldRemove = true;\n                        break;\n                    }\n                }\n            }\n            \n            if (shouldRemove) {\n                bullets.remove(x);\n                x--;\n            }\n        }\n    }\n    \n    private void applyExplosionDamage(double x, double y, int radius, int maxDamage) {\n            for (Zombie zombie : gamePanel.zombies) {\n                double distance = Math.hypot(zombie.worldX - x, zombie.worldY - y);\n            \n            if (distance <= radius) {\n                int damage = (int) (maxDamage * (1 - (distance / radius)));\n                zombie.takeDamage(damage, 0, 0, this);\n            }\n        }\n    }\n    \n    public void takeDamage(int damage) {\n        health -= damage;\n        \n        if (health <= 0) {\n            die();\n        }\n    }\n\n    public void die() {\n        gamePanel.capturePauseBackground();\n        gamePanel.gameState = gamePanel.END_STATE;\n    }\n\n    private int getKnockbackPower(Weapon weapon) {\n        if (weapon instanceof Pistol) return 5;\n        if (weapon instanceof Shotgun) return 15;\n        if (weapon instanceof AssaultRifle) return 8;\n        if (weapon instanceof SniperRifle) return 20;\n        if (weapon instanceof RocketLauncher) return 40;\n        return 0;\n    }\n\n    private BufferedImage[][] getCurrentWeaponSprites() {\n        if (currentWeapon instanceof AssaultRifle) \n            return walkingSprites_AR;\n        \n        if (currentWeapon instanceof Shotgun) \n            return walkingSprites_Shotgun;\n    \n        if (currentWeapon instanceof SniperRifle) \n            return walkingSprites_Sniper;\n    \n        if (currentWeapon instanceof RocketLauncher) \n            return walkingSprites_Rocket;\n        \n        return walkingSprites_Pistol;\n    }\n    \n    public void draw(Graphics2D g2) {\n        int screenX = (worldX - gamePanel.cameraX) - (80 / 2) + (hitbox.width / 2);\n        int screenY = (worldY - gamePanel.cameraY) - (80 / 2) + (hitbox.height / 2);\n    \n        BufferedImage[][] currentSprites = getCurrentWeaponSprites();\n        int directionIndex = getDirectionIndex();\n    \n        if (directionIndex >= 0 && directionIndex < currentSprites.length && currentFrame >= 0 && currentFrame < currentSprites[directionIndex].length) {\n            g2.drawImage(currentSprites[directionIndex][currentFrame], screenX, screenY, 80, 80, null);\n        }\n    \n        for (Bullet bullet : bullets) {\n            try {\n                bullet.draw(g2, gamePanel.cameraX, gamePanel.cameraY);   \n            } catch (Exception e) {\n                e.getMessage();\n            }\n        }\n    \n        drawHUD(g2);\n    }\n    \n    private void drawHUD(Graphics2D g) {\n        if (currentWeapon instanceof Pistol) {\n            g.drawImage(pistolImage, 250, 20, 75, 25, null);\n            font.drawText(g,\"AMMO:\" + currentWeapon.bulletsLeft + \"/\" + currentWeapon.capacity, -50, 10,160 ,40);\n            font.drawText(g,\"TOTAL AMMO:\", -50, 50,160 ,40);\n            font.drawText(g,\"∞\",180, 52,160 ,40);\n        }\n        \n        else if (currentWeapon instanceof AssaultRifle){\n            g.drawImage(arImage, 250, 20 ,75, 25, null);\n            font.drawText(g,\"AMMO:\" + currentWeapon.bulletsLeft + \"/\" + currentWeapon.capacity, -50, 10,160 ,40);\n            font.drawText(g,\"TOTAL AMMO:\" + currentWeapon.totalAmmo, -50, 50,160 ,40);\n        }\n        \n        else if (currentWeapon instanceof Shotgun){\n            g.drawImage(shotgunImage, 220, 20, 75, 25, null);\n            font.drawText(g,\"AMMO:\" + currentWeapon.bulletsLeft + \"/\" + currentWeapon.capacity, -50, 10,160 ,40);\n            font.drawText(g,\"TOTAL AMMO:\" + currentWeapon.totalAmmo, -50, 50,160 ,40);\n        }\n        \n        else if (currentWeapon instanceof SniperRifle){\n            g.drawImage(sniperImage, 220, 20, 75, 25, null);\n            font.drawText(g,\"AMMO:\" + currentWeapon.bulletsLeft + \"/\" + currentWeapon.capacity, -50, 10,160 ,40);\n            font.drawText(g,\"TOTAL AMMO:\" + currentWeapon.totalAmmo, -50, 50,160 ,40);\n        }\n        \n        else if (currentWeapon instanceof RocketLauncher){\n            g.drawImage(rocketImage, 220, 20, 75, 25, null);\n            font.drawText(g,\"AMMO:\" + currentWeapon.bulletsLeft + \"/\" + currentWeapon.capacity, -50, 10,160 ,40);\n            font.drawText(g,\"TOTAL AMMO:\" + currentWeapon.totalAmmo, -50, 50,160 ,40);\n        }\n        \n        healthBar = splitHealthBar(healthBarImage);\n        healthIndex = getHealthSegment(health);\n        g.drawImage(healthBar[healthIndex[0]][healthIndex[1]], 1280, -10, 220, 80, null);\n        font.drawText(g, \"SCORE:\" + score, 1250, 50, 160, 40);\n        font.drawText(g, \"WAVE\" + WaveManager.waveNumber, 650, 0, 200, 50);\n    }\n\n    public static int[] getHealthSegment(int hp) {\n        int[] index = new int[2];\n        if (hp == 100) {\n            index[0] = 4;\n            index[1] = 0;\n        }\n        if (hp == 90) {\n            index[0] = 3;\n            index[1] = 0;\n        }\n        if (hp == 80) {\n            index[0] = 2;\n            index[1] = 0;\n        }\n        if (hp == 70) {\n            index[0] = 1;\n            index[1] = 0;\n        }\n        if (hp == 60) {\n            index[0] = 0;\n            index[1] = 0;\n        }\n        if (hp == 50) {\n            index[0] = 4;\n            index[1] = 1;\n        }\n        if (hp == 40) {\n            index[0] = 3;\n            index[1] = 1;\n        }\n        if (hp == 30) {\n            index[0] = 2;\n            index[1] = 1;\n        }\n        if (hp == 20) {\n            index[0] = 1;\n            index[1] = 1;\n        }\n        if (hp == 10) {\n            index[0] = 0;\n            index[1] = 1;\n        }\n        if (hp < 10) {\n            index[0] = 0;\n            index[1] = 1;\n        }\n        return index;\n    }\n\n    public BufferedImage[][] splitHealthBar(BufferedImage fullHealthBar) {\n        int rows = 5;\n        int cols = 2;\n        int partWidth = 192;\n        int partHeight = 64;\n\n        BufferedImage[][] healthBarParts = new BufferedImage[rows][cols];\n\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                healthBarParts[row][col] = fullHealthBar.getSubimage(col * partWidth, row * partHeight, partWidth, partHeight);\n            }\n        }\n\n        return healthBarParts;\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e) {\n        int mouseWorldX = e.getX() + gamePanel.cameraX; \n        int mouseWorldY = e.getY() + gamePanel.cameraY;\n    \n        int playerCenterX = worldX + 2*(size / 2) -24;\n        int playerCenterY = worldY + 2*(size / 2) -24;\n\n        angle = Math.atan2(mouseWorldY - playerCenterY, mouseWorldX - playerCenterX);\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n        if (gamePanel.gameState == gamePanel.GAME_STATE) {\n            \n            long currentTime = System.currentTimeMillis();\n\n            if (currentTime - lastShotTime >= currentWeapon.firerate && currentWeapon.bulletsLeft > 0) {\n                lastShotTime = currentTime;\n                \n                if (currentWeapon instanceof Pistol) {\n                    gamePanel.effectManager.setFile(6);\n                }\n                \n                if (currentWeapon instanceof AssaultRifle) {\n                    gamePanel.effectManager.setFile(7);\n                }\n                \n                if (currentWeapon instanceof Shotgun) {\n                    gamePanel.effectManager.setFile(8);\n                }\n                \n                if (currentWeapon instanceof SniperRifle) {\n                    gamePanel.effectManager.setFile(9);\n                }\n                \n                if (currentWeapon instanceof RocketLauncher) {\n                    gamePanel.effectManager.setFile(10);\n                }\n                \n                gamePanel.effectManager.play();\n                int bulletX = worldX + 2 * (size / 2) - 24;\n                int bulletY = worldY + 2 * (size / 2) - 24;\n\n                if (currentWeapon instanceof Shotgun) {\n                    for (int i = -4; i <= 4; i++) {\n                        double spread = Math.toRadians(i * 5);\n                        Bullet newBullet = new Bullet(bulletX, bulletY, angle + spread, 30);\n                        bullets.add(newBullet);\n                        currentWeapon.shoot(bulletX, bulletY, angle + spread);\n                    }\n                }\n                \n                else if (currentWeapon instanceof AssaultRifle) {\n                    double spread = Math.toRadians((Math.random() * 10) - 5);\n                    Bullet newBullet = new Bullet(bulletX, bulletY, angle + spread, 30);\n                    bullets.add(newBullet);\n                    currentWeapon.shoot(bulletX, bulletY, angle + spread);\n                }\n                \n                else {\n                    Bullet newBullet = new Bullet(bulletX, bulletY, angle, 30);\n                    bullets.add(newBullet);\n                    currentWeapon.shoot(bulletX, bulletY, angle);\n                }\n            }\n        }\n    }\n\n    public void switchWeapon() {\n        int currentIndex = weapons.indexOf(currentWeapon);\n        int nextIndex = (currentIndex + 1) % weapons.size();\n        currentWeapon = weapons.get(nextIndex);\n        \n        loadSprites();\n    }\n\n    public void addWeapon(Weapon weapon) {\n        weapons.add(weapon);\n    }\n\n    public int getWorldX() {\n        return worldX;\n    }\n\n    public int getWorldY() {\n        return worldY;\n    }\n\n    public long getLastDamageTime() {\n        return lastDamageTime;\n    }\n    \n    public void setLastDamageTime(long time) {\n        this.lastDamageTime = time;\n    }\n    \n    public int getDamageCooldown() {\n        return damageCooldown;\n    }\n\n    @Override public void mouseDragged(MouseEvent e) {}\n    @Override public void mouseReleased(MouseEvent e) {}\n    @Override public void mouseClicked(MouseEvent e) {}\n    @Override public void mouseEntered(MouseEvent e) {}\n    @Override public void mouseExited(MouseEvent e) {}\n}"
    }
  ]
}