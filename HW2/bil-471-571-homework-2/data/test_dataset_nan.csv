id,NaN_count,answers
4380745,1,"recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q3{ public static void main(string[] args){ sayac sayac = new sayac(""100101111101010""); sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s2.say()); system.out.println(sayac.say()); } } public class lab1q2{ public static void main(string[] args){ int[] arr1 = {1,8,9,12,7,3,45,10}; int[] arr2 = {5,4,1,2}; cocktailsort(arr2); for(int i = 0; i < arr2.length; i++){ system.out.println(arr2[i]); } } public static void cocktailsort(int[] arr){ cocktailsort(arr, 0, arr.length-1); } public static void cocktailsort(int[] arr, int i, int j){ boolean fsflag = forwardsort(arr, i, j, false); if(!fsflag){ return; } boolean bsflag = backsort(arr, i, j, false); if(!bsflag){ return; } cocktailsort(arr, i+1, j-1); } public static void swap(int[] arr, int i, int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return; } public static boolean forwardsort(int[] arr, int i, int j, boolean flag){ if(i == j){ return flag; } if(arr[i] >= arr[i+1]){ swap(arr, i, i+1); flag = true; } return forwardsort(arr, i+1, j, flag); } public static boolean backsort(int[] arr, int i, int j, boolean flag){ if(j == i){ return flag; } if(arr[j - 1] >= arr[j]){ swap(arr, j, j-1); flag = true; } return backsort(arr, i, j-1, flag); } } public class sayac{ public string input; public sayac(string input){ this.input = input; } public int say(){ return sayrecursive(0); } public int sayrecursive(int index){ if(index >= input.length()){ return 0; } if(input.charat(index) == '1'){ return 1 + sayrecursive(index + 1); } else{ return sayrecursive(index + 1); } } } public class lab1q1{ public static void main(string[] args){ system.out.println(collatz(2)); } public static int collatz(int i){ if(i == 1){ return 0; } else if(i%2 == 0){ return 1 + collatz(i/2); } else{ return 1 + collatz(3*i + 1); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arraylist; import java.util.arrays; import java.util.list; import java.util.random;; public class bil211l2 { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki == null){ continue; } if(sarki instanceof metalsarki){ ((metalsarki)sarki).gostermetalozellikler(); } } } } abstract class sarki { protected string isim; protected string sanatci; abstract void oynat(); } interface calmastratejisi{ abstract void cal(list<sarki> sarkilistesi); } class metalsarki extends sarki{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik){ this.isim = new string(isim); this.sanatci = new string(sanatci); this.metalozellik = new string(metalozellik); } @override public void oynat(){ system.out.println(sanatci + "" - "" + isim + "" ("" + metalozellik +"")""); } public void gostermetalozellikler(){ system.out.println(sanatci + "" - "" + isim + "" [ozellik: "" + metalozellik +""]""); } } class rocksarki extends sarki{ public rocksarki(string isim, string sanatci){ this.isim = new string(isim); this.sanatci = new string(sanatci); } @override public void oynat(){ system.out.println(sanatci + "" - "" + isim + "" ("" + ""huzurlu ve nostaljik"" +"")""); } } class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci){ this.isim = new string(isim); this.sanatci = new string(sanatci); } @override public void oynat(){ system.out.println(sanatci + "" - "" + isim + "" ("" + ""hafif ve sakin"" +"")""); } } class siralicalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { string etiket; for(sarki sarki: sarkilistesi){ if(sarki == null){ continue; } if(sarki instanceof metalsarki){ etiket = ""[metal]""; } else if(sarki instanceof rocksarki){ etiket = ""[rock]""; } else{ etiket = ""[klasik]""; } system.out.print(etiket + "" ""); sarki.oynat(); } } } class karisikcalma implements calmastratejisi{ random random = new random(666); @override public void cal(list<sarki> sarkilistesi) { string etiket; list<sarki> sarkilistesi_ = new arraylist<>(); for(sarki sarki: sarkilistesi){ if(sarki == null){ continue; } sarkilistesi_.add(sarki); } while(sarkilistesi_.size() > 0){ int index = random.nextint(sarkilistesi_.size()); if(sarkilistesi_.get(index) == null){ sarkilistesi_.remove(index); continue; } if(sarkilistesi_.get(index) instanceof metalsarki){ etiket = ""[metal]""; } else if(sarkilistesi_.get(index) instanceof rocksarki){ etiket = ""[rock]""; } else{ etiket = ""[klasik]""; } system.out.print(etiket + "" ""); sarkilistesi_.get(index).oynat(); sarkilistesi_.remove(index); } } } class rockcuozelcalma implements calmastratejisi{ random random = new random(666); @override public void cal(list<sarki> sarkilistesi) { string etiket; string mode = ""metal""; for(sarki sarki: sarkilistesi){ if(sarki == null){ continue; } if(sarki instanceof metalsarki){ etiket = ""[metal]""; if(mode.equals(""rock"")){ system.out.println(""[bilgi] ses duzeyi: normal""); } mode = ""metal""; } else if(sarki instanceof rocksarki){ etiket = ""[rock]""; //degisti = mode.equals(""normal"") ? false : true; if(!mode.equals(""rock"")){ system.out.println(""[bilgi] ses duzeyi: yuksek""); } mode = ""rock""; } else{ etiket = ""[klasik]""; //degisti = mode.equals(""normal"") ? false : true; if(mode.equals(""rock"")){ system.out.println(""[bilgi] ses duzeyi: normal""); } mode = ""klasik""; } system.out.print(etiket + "" ""); sarki.oynat(); } } } class muzikcalar{ calmastratejisi strateji; public void setstrateji(calmastratejisi s){ strateji = s; } public void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } metin karşılaştırıcı bil 211 - lab 3 20 şubat 2025 1 giriş bulaboratuvarda fileio ve exceptions kullanarakbir metinkarşılaştırıcı geliştireceğiz. metinkarşılaştırıcı , verilen iki metin dosyasını karşılaştırarak ikinci metnin yalnızca yeni satırlar eklenerek oluşturulup oluştu- rulmadığını kontrol edecek ve gerektiğinde hangi satırdan sonra hangi eklemelerin yapıldığını belirleyecektir. 2 genel program program, çalıştırılırken komut satırından iki dosya adı alacaktır: - orijinal metin dosyası (ilk argüman) - değiştirilmiş metin dosyası (ikinci argüman) program şu şekilde çalıştırmalıdır (burada köşeli parantezler yerine dosyaların asıl adı gelmeli): java metinkarsilastirici [orijinal.txt] [degistirilmis.txt] program, ilk argümanda verilen dosyayı orijinal metin, ikinci argümandaki dosyayı değiştirilmiş metin olarak kabul edecek ve yalnızca yeni satırlar eklenerek oluşturulup oluşturulmadığını kontrol edecektir. eğer mümkünse, hangi satırdan sonra hangi eklemelerin yapıldığını tespit ederek bir çıktı dosyasına yazacaktır: -farklar.txt – yeni satırların hangi satırdan sonra eklendiğini gösteren çıktı dosyası. eğer dosya adları eksikse veya hatalı formatta verilmişse, program özel bir hata oluşturmalı ve stderr’e uygun bir mesaj yazmalıdır. 3 fileio program, dosyaokumaveyazmaişlemleriiçinjava’nın java.io paketindekisınıflarıkullanacaktır(örn., buf- ferredreader, scanner, printwriter). dosyaları okurken ve yazarken kullanacağınız fileio sınıflarının seçimi size bırakılmıştır. program, aşağıdaki olası dosya hatalarını atmalı ve stderr’e belirlenen hata mesajlarını yazmalıdır: - dosya bulunamıyorsa: ""hata: [dosya adı] bulunamadı."" - dosya boşsa: ""hata: [dosya adı] boş."" 4 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program hata kodu ile çıkış yapmalıdır (yani mainmetodunuz bu hataları atarak sonlanmalı) ve hatalar stderr’e yazılmalıdır (programınızı hata atarak sonlandırırsanız java bunu kendisi yapacaktır). belirtilen hata mesajları ile birlikte java’nın hata ile sonlanan programlar için oluşturduğu sınıf, metod, ve satır gibi bilgiler bulunabilir. 4.1 girdi hataları (inputexception class) bu kategori, programın giriş dosyalarıyla ilgili karşılaşabileceği tüm hataları kapsar. öğrenciler, dosya işlem- leriyle ilgili hata türlerini inputexception sınıfından türetmelidir. aşağıdaki özel hata türleri tanımlanmalıdır: 1 - yanlisargumanexception (extends inputexception): argümanlar eksik ya da fazlaysa atılacak hata. burada[argümanlar] yerine programın çalıştırıldığı argüman listesi yazılmalıdır. - hata mesajı: ""hata: hatalı argüman kullanımı: [argümanlar]. program argüman olarak 2 dosya ismi almalı."" - dosyabulunamadiexception (extends inputexception): dosya eksikse atılacak hata. - hata mesajı: ""hata: [dosya adı] bulunamadı."" - bosdosyaexception (extends inputexception): dosya boşsa atılacak hata. - hata mesajı: ""hata: [dosya adı] boş."" 4.2 geçersiz değişiklik hatası (gecersizdegisiklikexception class) eğerdegistirilmis.txt dosyası,orijinal.txt dosyasına yalnızca yeni satırlar eklenerek oluşturulamıy- orsa, program gecersizdegisiklikexception hatasını atmalıdır. bu hata oluştuğunda stderr’e şu mesaj yazılmalıdır: hata: [degistirilmis.txt] dosyası, [orijinal.txt] dosyasına yalnızca yeni satırlar eklenerek oluşturulmamış. 5 dosya formatları 5.1 girdi dosyaları 5.1.1orijinal.txt vedegistirilmis.txt formatı bu dosyalar, her satırın ayrı bir metin satırı olduğu düz metin formatında olmalıdır. örnek i̇çerik ( orijinal.txt ): merhaba dünya. bu bir test dosyasıdır. son satır budur. örnek i̇çerik ( degistirilmis.txt ): merhaba dünya. bu bir test dosyasıdır. eklenen yeni bir satır. son satır budur. yeni bir satır daha eklendi. 5.2 çıktı dosyası 5.2.1farklar.txt formatı farklar.txt dosyası, hangi satırdan sonra hangi yeni satırın eklendiğini gösterecek şekilde yapılandırıl- malıdır: örnek çıktı ( farklar.txt ): 2 -> eklenen yeni bir satır. 4 -> yeni bir satır daha eklendi. burada ‘2 ->‘ ifadesi, ""2. satırdan sonra eklenmiştir"" anlamına gelir. eğer aynı yere birden fazla satır eklenmişse aynı sayıyı tekrar ederek eklenme sırasında yazılmalı. 5.3 özel hata durumları ve çıktıları eğerdegistirilmis.txt ,orijinal.txt üzerine sadece yeni satırlar eklenerek oluşturulmamışsa stderr’e şu mesaj yazılmalıdır: hata: degistirilmis.txt dosyası, orijinal.txt dosyasına yalnızca yeni satırlar eklenerek oluşturulmamış. eğer dosya adları eksikse veya hatalıysa, stderr’e şu mesaj yazılmalıdır: hata: geçersiz dosya adı. 2 6 gönderim formatı - labı bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara şeklinde isimlendirin (örn., johnnash_181101014.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""lab3 gönderim"" başlıklı bir mail ile gönderin. metot açıklama string(string s) sile aynı değere sahip bir string oluşturur. string(char[] a) a[]dizisindeki karakterleri temsil eden bir string oluşturur. int length() string içindeki karakter sayısını döndürür. char charat(int i) belirtilen iindeksindeki karakteri döndürür. string substring(int i, int j) iilej-1arasındaki karakterleri içeren bir alt string döndürür. boolean contains(string substring) string’in substring içerip içermediğini kontrol eder. boolean startswith(string prefix) string’in prefixile başlayıp başlamadığını kontrol eder. boolean endswith(string postfix) string’in postfix ile bitip bitmediğini kontrol eder. int indexof(string pattern) pattern ifadesinin ilk geçtiği indeks değerini döndürür. int indexof(string pattern, int i) iindeksinden sonraki ilk pattern konumunu döndürür. string concat(string t) string’in sonuna teklenmiş halini döndürür. int compareto(string t) i̇ki string’i karşılaştırır (sözlük sırasına göre). string tolowercase() string’in tüm harflerini küçük harfe çevirir. string touppercase() string’in tüm harflerini büyük harfe çevirir. string replace(string a, string b) string içindeki a’larıbile değiştirir. string trim() string’in başındaki ve sonundaki boşlukları kaldırır. boolean matches(string regexp) string’in belirtilen regexle eşleşip eşleşmediğini kontrol eder. string[] split(string delimiter) string’idelimiter kullanarak böler ve bir dizi döndürür. boolean equals(object t) string’in değeri tile aynı mı diye kontrol eder. table 1: java string sınıfı metotları 3 package bil211lab3; public class gecersizdegisiklikexception extends exception { public gecersizdegisiklikexception(string degistirilmis, string original){ super(""hata: ["" + degistirilmis + ""] dosyası, ["" + original + ""] dosyasına yalnızca yeni satırlar eklenerek oluşturulmamış.""); } } package bil211lab3; public class bosdosyaexception extends inputexception { public bosdosyaexception(string filename) { super(""hata: ["" + filename + ""] boş""); } } package bil211lab3; public class yanlisargumanexception extends inputexception { // buraya göndermeden args -> msg dönüşümü yapılmalı public yanlisargumanexception(string message) { super(""hata: hatalı argüman kullanımı: "" + message + "". program argüman olarak 2 dosya ismi almalı""); } } package bil211lab3; import java.io.file; import java.io.fileinputstream; import java.io.filenotfoundexception; import java.io.fileoutputstream; import java.io.ioexception; import java.io.printstream; import java.util.arraylist; import java.util.scanner; public class metinkarsilastirici { static arraylist<integer> indexlist = new arraylist<>(); public static void main(string[] args) { try { method(args); } catch (throwable e) { system.err.println(e.getmessage()); } } public static void method(string[] args) throws throwable{ if(args.length != 2){ string message = """"; for(string str:args){ message += str + "", ""; } throw new yanlisargumanexception(message); } file file = new file(""farklar.txt""); if(file.createnewfile()){} system.setout(new printstream(new fileoutputstream(file))); filehandler(args[0], args[1]); } public static void filehandler(string original, string degistirilmis) throws throwable{ file originalfile = new file(original); file degistirilmisfile = new file(degistirilmis); fileinputstream originalinput; fileinputstream degistirilmisinput; try{ originalinput = new fileinputstream(originalfile); } catch (filenotfoundexception e) { throw new dosyabulunamadiexception(original); } try{ degistirilmisinput = new fileinputstream(degistirilmisfile); } catch (filenotfoundexception e) { throw new dosyabulunamadiexception(degistirilmis); } if(originalfile.length() <= 0){ throw new bosdosyaexception(original); } if(degistirilmisfile.length() <= 0){ throw new bosdosyaexception(degistirilmis); } string originalline = null; string degistirilmisline = null; scanner originalscanner = new scanner(originalinput); scanner degistirilmisscanner = new scanner(degistirilmisinput); int index = 0; while(originalscanner.hasnextline()){ index++; originalline = originalscanner.nextline(); if(degistirilmisscanner.hasnextline()){ degistirilmisline = degistirilmisscanner.nextline(); } else{ degistirilmisline = null; } while(!originalline.equals(degistirilmisline) && degistirilmisline != null){ indexlist.add(index); if(degistirilmisscanner.hasnextline()){ degistirilmisline = degistirilmisscanner.nextline(); } else{ degistirilmisline = null; } } if(degistirilmisfile == null){ throw new gecersizdegisiklikexception(degistirilmisline, originalline); } } while(degistirilmisscanner.hasnextline()){ indexlist.add(index); degistirilmisscanner.nextline(); } boolean flag = true; for(int i:indexlist){ if(flag){ system.out.println(i + ""-> eklenen yeni bir satır""); flag = false; } else{ system.out.println(i + ""-> yeni bir satır daha eklendi""); } } originalscanner.close(); degistirilmisscanner.close(); originalinput.close(); degistirilmisinput.close(); } } package bil211lab3; public class inputexception extends exception { public inputexception(string message){ super(message); } } package bil211lab3; public class dosyabulunamadiexception extends inputexception{ public dosyabulunamadiexception(string filename) { super(""hata: ["" + filename + ""] bulunamadı""); } } generic 1) envanter yönetim sistemi bu labda amacımı bir oyun için envanter sistemi eklemektir. item isminde bir arayüz tanımlayın: aşağıdaki metotları içermelidir: string getname() int getvalue() weapon sınıfı tanımlayın. bu sınıf item arayüzünü uygulamalıdır. int damage isimli bir özelliği olmalıdır. armor sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. int defense isimli bir değişkeni olmalıdır. potion sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. string effect isimli bir değişkeni olmalıdır. generic inventory<t> sınıfı bir arraylist kullanarak nesneleri saklamalıdır. void additem(t item): envantere istenilen eşyayı eklemeli void removeitem(t item): envanterden istenilen eşyayı silmeli void printinventory(): envanteri basmalı t mostvaluableitem(): en değerli eşyayı dönmeli t finditembyname(string name): verilen isme karşılık gelen eşyayı dönmeli. i̇simlerin unique olduğunu varsayabilirsiniz. eğer yoksa null dönün. list<t> finditemsbyvalue(int value): verilen değerden daha değerli eşyaarın listesini döndürür. int gettotalvalue(): envanterin toplam değerini döner. list<t> filterbytype(class<?> type): istenilen sınıfa ait ögeleri döner. int gettotalweapondamage(): weapon classına ait olan nesnelerin toplam hasarınıdöner. void sortbyvalue(): değeri azalan şekilde envanteri sıralamalıdır. public static void printmostvaluableitem(inventory<? extends item> inventory): verilen envanterdem en değerli eşayı ekrana basmalıdır. public static void transferarmor(inventory<? super armor> destination, inventory<armor> source): verilen hedef envantere zırhı taşımalıdır. driver class: main metodu burada olmalıdır. sadece weapon’dan oluşan ve itemdan oluşan invertory classı yazıp test ediniz. yardımcı olabilecek metotlar: class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon package bil211lab4; import java.util.arraylist; import java.util.list; public class inventory<t extends item> { arraylist<t> inventory; public inventory(){ inventory = new arraylist<>(); } public list<t> getinventory(){ return inventory; } public void additem(t item){ if(inventory != null){ inventory.add(item); } } public void removeitem(t item){ if(inventory != null){ for(int i = 0; i < inventory.size(); i++){ if(inventory.get(i).getname().equals(item.getname())){ inventory.remove(i); break; } } } } public void printinventory(){ if(inventory != null){ for(int i = 0; i < inventory.size(); i++){ system.out.println(""name: "" + inventory.get(i).getname()); system.out.println(""value: "" + inventory.get(i).getvalue()); } } } public t mostvaluableitem(){ t mvaluable = null; if(inventory != null){ for(int i = 0; i < inventory.size(); i++){ if(mvaluable != null && mvaluable.getvalue() < inventory.get(i).getvalue()){ mvaluable = inventory.get(i); } if(mvaluable == null){ mvaluable = inventory.get(i); continue; } } } return mvaluable; } public t finditembyname(string name){ t item = null; if(inventory != null){ for(int i = 0; i < inventory.size(); i++){ if(inventory.get(i).getname().equals(name)){ item = inventory.get(i); break; } } } return item; } public arraylist<t> finditemsbyvalue(int value){ arraylist<t> list = new arraylist<>(); if(inventory != null){ for(int i = 0; i < inventory.size(); i++){ if(inventory.get(i).getvalue() > value){ list.add(inventory.get(i)); } } } return list; } public int gettotalvalue(){ int value =0; if(inventory != null){ for(int i = 0; i < inventory.size(); i++){ value += inventory.get(i).getvalue(); } } return value; } public arraylist<t> filterbytype(class<?> type){ arraylist<t> list = new arraylist<>(); if(inventory != null){ for(int i = 0; i < inventory.size(); i++){ if(inventory.get(i).getclass().getname().equals(type.getname())){ list.add(inventory.get(i)); } } } return list; } public int gettotalweapondamage(){ int totaldamage = 0; if(inventory != null){ for(int i = 0; i < inventory.size(); i++){ if(inventory.get(i) instanceof weapon){ totaldamage += ((weapon)inventory.get(i)).damage; } } } return totaldamage; } public void sortbyvalue(){ if(inventory != null){ for(int i = 0; i < inventory.size(); i++){ for(int j = 0; j < inventory.size() - 1; j++){ if(inventory.get(j).getvalue() < inventory.get(j + 1).getvalue()){ t temp = inventory.get(j); inventory.set(j, inventory.get(j + 1)); inventory.set(j + 1, temp); } } } } } public static void printmostvaluableitem(inventory<? extends item> inventory){ item item = null; if(inventory != null){ for(int i = 0; i < inventory.getinventory().size(); i++){ if(item != null && item.getvalue() < inventory.getinventory().get(i).getvalue()){ item = inventory.getinventory().get(i); } if(item == null){ item = inventory.getinventory().get(i); } } } if(item != null){ system.out.println(""name: "" + item.getname()); system.out.println(""value: "" + item.getvalue()); } } public static void transferarmor(inventory<? super armor> destination, inventory<armor> inventory2){ if(destination != null && inventory2 != null){ for(int i = 0; i < inventory2.getinventory().size(); i++){ destination.getinventory().add(inventory2.getinventory().get(i)); } } } } package bil211lab4; public class weapon implements item{ int damage = 10; string name; int value; public weapon(string name, int value, int damage){ this.name = name; this.value = value; this.damage = damage; } @override public string getname() { return name; } @override public int getvalue() { return value; } } package bil211lab4; public interface item { string getname(); int getvalue(); } package bil211lab4; public class armor implements item{ int defense; string name; int value; public armor(string name, int value, int defense){ this.name = name; this.value = value; this.defense = defense; } @override public string getname() { return name; } @override public int getvalue() { return value; } } package bil211lab4; public class potion implements item{ string effect; string name; int value; public potion(string name, int value, string effect){ this.name = name; this.value = value; this.effect = effect; } @override public string getname() { return name; } @override public int getvalue() { return value; } } package bil211lab4; import java.util.arraylist; public class driver { public static void main(string[] args) { inventory<weapon> inventory1 = new inventory<weapon>(); inventory<item> inventory2 = new inventory<item>(); for(int i = 0; i < 5; i++){ inventory1.additem(new weapon(""weapon"" + i, i,i)); if(i%3 == 0){ inventory2.additem(new armor(""armor"" + i, i,i)); } else if(i%3 == 1){ inventory2.additem(new potion(""potion"" + i, i, ""effect"" + i)); } else{ inventory2.additem(new weapon(""weapon"" + i, i, i)); } } //inventory1.printinventory(); //inventory2.printinventory(); //inventory1.removeitem(inventory1.getinventory().get(2)); //inventory1.printinventory(); //item item = inventory2.mostvaluableitem(); //system.out.println(""name: "" + item.getname()); //system.out.println(""value: "" + item.getvalue()); //item item = inventory2.finditembyname(""potion4""); //system.out.println(item); //arraylist<item> list = inventory2.finditemsbyvalue(2); //for(int i = 0; i < list.size(); i++){ // system.out.println(list.get(i).getname()); // system.out.println(list.get(i).getvalue()); //} //system.out.println(inventory1.gettotalweapondamage()); //system.out.println(inventory1.gettotalvalue()); //arraylist<item> list = inventory2.filterbytype(potion.class); //for(int i = 0; i < list.size(); i++){ // system.out.println(list.get(i).getname()); // system.out.println(list.get(i).getvalue()); //} //inventory2.sortbyvalue(); //inventory2.printinventory(); //inventory.printmostvaluableitem(inventory2); //inventory<armor> inventory3 = new inventory<armor>(); //inventory3.additem(new armor(""a1"",1,1)); //inventory3.additem(new armor(""a2"",2,2)); //inventory3.additem(new armor(""a3"",3,3)); //inventory3.additem(new armor(""a4"",4,4)); //inventory<armor> inventory4 = new inventory<armor>(); //inventory.transferarmor(inventory4, inventory3); //inventory4.printinventory(); } } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. matematikteki induction’ın proglama dünyasındaki hali recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. recursion’dan çıkış koşuludur. olmazsa sonsuz recursion’a girilir bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? index’i 0 olqcak şekilde ve başlatmayı string uzunluğunun bir eksiğinden itibaren olacak şekilde stringi gezen bir recursive metot yazılır recursive bir metotta base case olmazsa ne olur? sonsuz döngüye girer recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. stackde önceki bulununan durumun üstüne doğru yeni parametrelerle yeni durum yazılır ve hali hazırda üzerinde bulunulan fonksiyonlar bittikçe eki değerlere dönülerek veriler işlenerek önceki metotda döndürülmüş olur fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. çünkü aynı değerler tekrar ve tekrar hesaplanır tail recursion nedir, kısaca açıklayınız. ? abstraction kavramını açıklayınız. soyutlama, kodun birbirleriyle etkileşime girmesi gereken kısımları birbirinden ayırarak aralarındaki etkileşimi daha iyi yönetmemizi sağlayan kavram ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? extend yapılarak kalıtım ile oluşan ilişki türi bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? default ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? a veya c olabilir java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? evet çünkü hiçbir kalıtım yapılmamış sınıfları java object classı ile extend eder. zaten inheritance yapılmışlar için super çağrılır java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? mümkün değildir metot overriding ve overloading kavramlarını açıklayınız. overriding inheritance yapıldığında kalıtım ile gelen sınıfın metot signature’ı korunurken içeriğinin değiştirilmesidir. overloading aynı isme sahip fonksiyonların farklı signature a sahip olması sağlanarak o fonksiyonun gerekli olan çeşitli versiyonlarının yaratılmasıdır class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dog bark! class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? circle 8.0 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? hangi metodun hangi versiyonunun kullanılacağının belirlenmesidir. i̇ki tipi bardır: statik ve dinamik hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? overload edilen metotlarda statik, override edilenlerde dinamik binding kullanılır dinamik bağlamada jvm'nin görevi nedir? runtime esnasında metodun hangi versiyonunun kullanılacağına karar vermek java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? başlangıçta metotları yükleme aşaması olmaz ve bir statik metoda ihtiyaç duyulduğu zaman kullanılamazdı java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? ? java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. edilemez çünkü kalıtımda üstteki class’ın hakları kadar alt class’lara kadar aktarılabilir class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? bark meow dinamik class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? parent p = new child() kısmında parent olduğunu söylüyoruz javaya p’nin ama parent’da olmayan bir metot çağrılıyor mnce child’a cast edilmeli dinamik binding child display child special java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? i̇mplementasyon aşamasında eksik olan sınıftır abstract metotlar tanımlayabilir abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? edilemez abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. temel sağlanması gereken bir şablon sunar, bu da bize abstract metotları, implemente edilmeye zorunlu bırakılan class ve metotlar abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract class’lar concrete metotlar içerebilir marker interface ve functional interface kavramları nedir, nasıl kullanılır? bir şeyin bir şey yapıp yapamayacağını belirten interfsce’ler vardır runnable gibi bir de belirli görevlerin nasıl gerçekleştirileceğinin ayarlanması gereken interface’ler olur bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? bir class birden çok interface’i implemente edebilir. bir interface diğer interface’leri extend eder. abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? a içindeki sound metodu implemente edilmemiş versiyonudur onun yerine dog nesnesi oluşturulup dog referanxı tutan bir variable’a verilmelidir output: buddy woof interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? i̇nterface içinde concrete metot oluşturulmuş swimmiable abstract class yapılıp flyable implemente edilmelidir output: swimming java'da inner class nedir, avantajları nelerdir? sınıf içindeki sınıflardır. bazı sistem tasarım mimarilerinde kullanılır. statik ve statik olmayan (member) inner class arasındaki temel fark nedir? statik olanlar ana class olmadan da yaşayabilirler diğerlerinin yaşamı dışarıdaki class’a bağlıdır anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? bir sınıf üzerinden yeni bir class yartmadan doğrudan kullanacağımız şekilde hangi class üzerinden yaratacaksak köşeli parantezler açılarak tanımlanır. concrete class inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? erişebiliyor, bu sayede o ana nesneyi oluşturan builder tipi inner class’lar yaratılıp constructor tasarım aşamasındaki karmaşanın önüne geçilebilir statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? tanımlanabilir, nesnenin yaratılmasına ihtiyaç duymaz statik tanımlamalar anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? olabilir bu sayede anlık constructor override esilecekse yeni bir metot yazmadan anında anonim classlar ile kullanılabilir hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? static inner class’lar class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? outer.inner diye bir erişim olmaz doğrudan inner diye çağırması gerekir value: 10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? derlenir, count: 5 text file ile binary file arasındaki fark nedir? text olarak yazılınca karakter karakter yazılıyor. binary olunca doğrudan veri byte byte yazılıyor bu sayede nesneler vb. yapılarda dosyalara yazılabiliyor. bir dosyaya yazarken düzenli olarak flush yapmamak neye yol açabilir? düzenli veri akışının olduğu bir durumda okunması gereken önemli bir veri olduğu zaman veriyi doğru bir şekilde alınması için flush alınması gerekir. binary bir dosyaya bir object yazdırırken bu objenin hangi interfaceyi implement etmesi gerekiyor? bu interfacenin metotlarını sıralayınız. bu interface functional veya marker bir interface midir? evet markerdır. binary bir dosyaya primitive typeler (int, float, char etc.) yazılabilir mi, evet ise nasıl? type olarak ayrı ayrı yazılamaz, karakter karakter yazılır. bizim ayırmamız gerekir. buffered reader ve scanner sınıfları ile dosya okurken dosyanın sonuna geldiğini nasıl kontrol edilir? karakter karakter okunarak null değerin gelinceye kadar okunur binary bir dosya okurken dosyanın sonuna gelindiği nasıl test edilir? length’ine bakılır. public class randomaccessdemo { public static void main(string[] args) throws exception { randomaccessfile raf = new randomaccessfile(""numbers.bin"", ""rw""); raf.writeint(10); raf.writeint(20); raf.seek(0); int a = raf.readint(); raf.seek(7); byte b = raf.readbyte(); system.out.println(a + "" "" + b); raf.close(); } } output? 10 10 public class demo { public static void main(string[] args) throws exception { try{ fileoutputstream fos = new fileoutputstream(""log.txt"", true); printwriter pw = new printwriter(fos); pw.println(""new log entry""); throw new exception(); } catch(exception e){ system.err(""oopps!""); } } } bu kod çalıştırıldığında log.txt dosyası nasıl etkilenir, açıklayınız. new log entry yazar. sonra exception fırlatılır ve mesaage’ı oops! olan hata açılır what grade (a, b, c, d, or f) do you expect to earn by the end of this course? aa java'da generic kavramı nedir, bu kavramın temel amacı nedir? bir sınıf başka sınıflara göre değişmesi gerekiyorsa diye var olan bir özellik bir wildcard'ı ne zaman sınırlamaya ihtiyaç duyarsınız, sınırlandığı ve sınırlanmadığı durumlar için birer örnek veriniz. boundları hangi keywordlerle ifade edersiniz? sayılarla işlem yapılacaksa string gibi class’ların eklenmemesi gibi durumlarda kullanılır. extends ve super ile kısıtlama yapılır jenerik olmayan bir class jenerik bir metot içerebilir mi? açıklayınız. i̇çerebilir ancak metodun generic olduğunu belirtmek gerekebilir mygenericclass<integer> ve mygenericclass<number> classları arasında kalıtım(child-parent) ilişkisi nasıldır, açıklayınız. number integer’ın üst class’ı olduğundan dolayı integer’lar number generic’e yazılabilir. class node<t>{ t[] data = new t[10]; } //psvm node<string> stringnode = new node<>(); bu kodda bir hata var mı? (varsa) bu hata nedir, nedenini açıklayınız. (varsa) bu hata nasıl düzeltilmeli, kodun doğru halini yazınız. generic sınıfınfan nesne üretilemez. public _____________ { double sum = 0.0; for (t item : list) { sum += item.doublevalue(); } return sum / list.size(); } public static void main(string[] args) { list<integer> integers = arrays.aslist(1, 2, 3, 4); list<double> doubles = arrays.aslist(1.5, 2.5, 3.5); main m = new main(); system.out.println(average(integers)); system.out.println(average(doubles)); } yukarıda boşluk bırakılan yeri doldurun. not: metodun jenerik olduğuna, çağırılma biçimine ve jenerik tipine dikkat edin! boşluğu doldurduktan sonra programın çıktısı ne olur? static <t> int average(t[] list) aşağıda tanımı verilmiş node classının birbirlerine bağlanmış nodelerinden ilkini alan ve hepsini 1 defa sağa kaydıran metodu nasıl yazardınız, stratejiniz ne olurdu? peki ya n defa sağa kaydırma işlemini nasıl yapardınız? n defa kaydırma çözümünüz sizce optimal olan çözüm mü, neden? örnek: başlangıçta: a -> b -> c metodu a ile çağırdığıktan sonra: c -> a -> b ayrıca metot en başa gelen nodeyi dönmelidir (bu örnekte c dönmeli). class node{ int data; node next; } static node rotate(node head){...} her seferinde o nesnenin sağına kendisini sağının sağına kendisini derken recursive bir algortima yazardım. ve n zaman en iyi zamandır bu node yapısı için. arraylist ve linkedlist veri yapılarını kıyaslayınız, aralarındaki farkları açıklayınız. arraylist’e index ile doğrudan erişilebilir. linkedlist elemanlarına sırasıyla erişilebiliyor. collections interfacesindeki metotlar temel olarak hangi işlevleri yerine getiriyor? ekleme çıkarma gibi temel list işlemlerini. kendi yazdığınız bir classta veri yapilarını istenilen şekilde (mesela hashset'te duplicate objelerin olmamasi) kullanabilmek için object classının hangi metotlarını override etmek gerekir, neden? hashcode override edilmeli ki iki nesneyi neye göre kıyaslayacağını kod bilebilsin bir dijital kütüphane uygulaması geliştiriyorsunuz. bu uygulamada, öğrenciler araştırma projeleri için kaynak ekliyor ve sistem, en son eklenen kaynağı ilk olarak görüntülemek üzere tasarlanıyor. öğrenciler, ekledikleri kaynakların boyut sırasına göre tekrar gözden geçebilmek istiyorlar. bu durumda, hangi veri yapısını tercih edersiniz? neden? stack kullanırım fifo nedir, açıklayınız ve aşağıdakı veri yapılarını fifo/lifo şeklinde sınıflandırınız: stack queue map priorityqueue first in first out, lifo fifo fifo fifo public class demo { public static void main(string[] args) { stack<integer> stack = new stack<>(); stack.push(10); stack.push(20); stack.push(30); system.out.println(stack.pop()); system.out.println(stack.peek()); system.out.println(stack.pop()); } } output? 30 20 20 public class test { public static void main(string[] args) { map<string, integer> scores = new hashmap<>(); scores.put(""alice"", 95); scores.put(""bob"", 85); scores.put(""charlie"", 90); scores.put(""alice"", 100); system.out.println(scores.get(""alice"")); system.out.println(scores.size()); } } output? 95 4 ara sınavdan yaklaşık hangi notu bekliyorsun (0-100)? 60 4. sütun option1 java gui uygulamalarında olayları yönetmek için bir programcının yapması gereken iki temel görev nedir? i̇mplementasyon, giriş-çıkışlar neden gui uygulamalarında system.exit(0) sıklıkla gerekli olurken, konsol uygulamalarında bu durum geçerli değildir? çünkü gui için çıkışta uygulamaların düzgünce kapatılması gerekir. return yeterli değildir gui tasarımında düzen yöneticilerinin (layout managers) amacı nedir ve bu yöneticiler geliştiricilere nasıl yardımcı olur? layoutları daha etkin ve kolay yönetmeye yardımcı olurlar. bu sayede daha hızlı ve doğru bir şekilde gliştirilebilir. jframe'de setdefaultcloseoperation metodunun işlevini açıklayın. uygulama kapanırken yapılacakları belirtir flowlayout ve gridlayout, bileşenleri düzenlemede nasıl farklılık gösterirler? birisi daha statik bir şekilde tanımlanırken diğeri daha esnektir aşağıdaki kodun çalışmasını izleyin ve jframe'de neyin görüntüleneceğini belirleyin: jframe frame = new jframe(""test""); frame.setsize(300, 200); frame.setlayout(new borderlayout()); jbutton northbutton = new jbutton(""north""); jbutton centerbutton = new jbutton(""center""); frame.add(northbutton, borderlayout.north); frame.add(centerbutton, borderlayout.center); northbutton.setvisible(false); frame.setvisible(true); ortada center yazılı bir buton aşağıdaki kod parçasını göz önünde bulundurun: import javax.swing.*; import java.awt.event.*; public class testframe extends jframe { public testframe() { settitle(""test""); setsize(300, 200); jbutton btn = new jbutton(""exit""); btn.addactionlistener(new actionlistener() { public void actionperformed(actionevent e) { system.out.println(""button clicked""); system.exit(0); } }); add(btn); setdefaultcloseoperation(jframe.exit_on_close); setvisible(true); } public static void main(string[] args) { new testframe(); } } kullanıcı ""exit"" düğmesine tıkladığında olaylar sırası nasıldır? i̇lk önce set actionlistener çalışır daha sonraexit olurken setdefaultclose çalılır thread oluşturmanın 2 temel yöntemi nedir? thread oluştururken lambda notasyonunun kullanılabilmesi ne sağlar? thread nesnesi oluşturmak, anonim sınıf üzerinden lambda aracılığıyla üretmek data race problemi nedir, neden kaynaklanır? nasıl önüne geçilir? threadler’in ortak kullanması gereken bir veri olduğu durumda ilk hangisnin çalışcağı durumdur dead lock problemi nedir, neden kaynaklanır; bunun önüne geçebilmek için ne yapılabilir? birbirini bekleyen 2 thread’in birisi diğerinin lock’unu diğeri de diğerininkini kullandığı için asla wait durumundan çıkamadıkları durum bir threadi başlatmak için neden run metodu çağırılmamalı, açıklayınız. peki hangi metot çağrılmalıdır? awake kullanılmalı. run sistemi doğrudan çalıştırır awake ise gerektiği zaman uyandırır bir thread başka bir thread tarafından nasıl doğru bir şekilde sonlandırılabilir? kill java'da kaç çeşit thread vardır, farkları açıklayınız. 2, top thread ve sub threads public class bankaccount { private double balance; public void deposit(double amount) { balance = balance + amount; ; } public void withdraw(double amount) balance = balance - amount ; } public static void main(string[] args) { bankaccount account = new bankaccount(); thread t1 = new thread(() -> { for (int i = 0; i < 3; i++) { account.deposit(100); } }); thread t2 = new thread(() -> { for (int i = 0; i < 2; i++) { account.withdraw(100); } }); t1.start(); t2.start(); } } bu kodda bir problem var mı? varsa bu problemi nasıl çözersiniz? (varsa) problemi çözdükten sonra program çalıştığında balance'nin son değeri ne olur? data race’e sebep olur. daha sonra balance 100 olur class threadvisibility { private static boolean flag = false; private static int value = 0; public static void main(string[] args) throws interruptedexception { thread t1 = new thread(() -> { string name = thread.currentthread().getname(); system.out.println(""started""); while (!flag) { try { thread.sleep(100); } catch (interruptedexception e) { e.printstacktrace(); } } system.out.println(name + value); }); t1.setname(""t2""); t1.start(); thread.sleep(1000); // give t1 time to start value = 11; synchronized (threadvisibility.class) { flag = true; } } } output? hata bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.arraylist; public class bil211q1q2 { public static void main(string[] args) { penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(""antarctica"", -15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); p1.hunt(); habitat.printhabitat(); } } class penguin{ private string name; private string species; private int age; private double weight; public penguin(){ this(""willy"", ""emperor"", 1, 5.0); } public penguin(string name, string species, int age, double weight){ this.name = new string(name); this.species = new string(species); this.age = age; this.weight = weight; } public string getname(){ return new string(name); } public void setname(string name){ this.name = new string(name); } public string getspecies(){ return new string(species); } public void setspecies(string species){ this.species = new string(species); } public int getage(){ return age; } public void setage(int age){ this.age = age; } public double getweight(){ return weight; } public void setweight(double weight){ this.weight = weight; } public void hunt(){ setweight(getweight() + 1); } public void printpenguin(){ system.out.println(""penguin name: "" + getname() + ""\n"" + ""penguin species: "" + getspecies() + ""\n"" + ""penguin age: "" + getage() + ""\n""+ ""penguin weight: "" + getweight() + ""\n"" + ""----------------------""); } } class habitat{ private string location; private double temperature; private arraylist<penguin> penguins; public habitat(string location, double temperature){ this.location = new string(location); this.temperature = temperature; penguins = new arraylist<penguin>(); } public string getlocation(){ return new string(location); } public void setlocation(string location){ this.location = new string(location); } public double gettemperature(){ return temperature; } public void settemperature(double temperature){ this.temperature = temperature; } public arraylist<penguin> getpenguins(){ return penguins; } public void setpenguins(arraylist<penguin> list){ penguins = list; } public void addpenguin(penguin penguin){ penguins.add(penguin); } public void printhabitat(){ system.out.println(""habitat location: "" + getlocation() + ""\n"" + ""average temperature: "" + gettemperature() + "" c\n"" +""penguins living here:""); for(int i = 0; i < penguins.size(); i++){ penguins.get(i).printpenguin(); } } } import java.util.arraylist; public class bil211q1q1 { static arraylist<string> arr = new arraylist<string>(); public static void main(string[] args) { parantezbas(3); parantezbas(2); } public static void parantezbas(int n){ parantezbas(n, """"); } public static void parantezbas(int n, string output){ if(n <= 0){ boolean flag = false; for(int i = 0; i < arr.size(); i++){ if(output.equals(arr.get(i))){ flag = true; } } if(flag){ return; } system.out.println(output); arr.add(output); return; } parantezbas(n-1,""("" + output + "")""); parantezbas(n-1,""("" + "")"" + output); parantezbas(n-1, output + ""("" + "")""); } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public class latte extends basecoffee{ @override public double calculateprice() { int price = 50; string message = ""sipariş: latte""; for(coffeeaddon addon : addons){ price += addon.getcost(); message += "" + "" + addon.getname(); } system.out.println(message); system.out.println(""toplam fiyat: "" + price + ""tl""); system.out.println(); return price; } @override public string gettype() { return ""latte""; } } public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); anothermachine.displaysumofcoffenumber();// burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } public class espresso extends basecoffee{ private boolean isheated = false; public espresso(){ } @override public double calculateprice() { int price = 40; string message = ""sipariş: espresso""; if(isheated) message += "" (sıcak fincan)""; for(coffeeaddon addon : addons){ price += addon.getcost(); message += "" + "" + addon.getname(); } system.out.println(message); system.out.println(""toplam fiyat: "" + price + ""tl""); system.out.println(); return price; } public void heatcup(){ isheated = true; } @override public string gettype() { return ""espresso""; } } public class vanillasyrup implements coffeeaddon{ @override public double getcost() { return 6; } @override public string getname() { return ""vanilla syrup""; } } public interface coffeeaddon { double getcost(); string getname(); } import java.util.arraylist; public abstract class basecoffee { protected arraylist<coffeeaddon> addons; public basecoffee(){ addons = new arraylist<coffeeaddon>(); } public void addaddon(coffeeaddon addon){ addons.add(addon); } public abstract double calculateprice(); public abstract string gettype(); } public class americano extends basecoffee{ @override public double calculateprice() { int price = 45; string message = ""sipariş: americano""; for(coffeeaddon addon : addons){ price += addon.getcost(); message += "" + "" + addon.getname(); } system.out.println(message); system.out.println(""toplam fiyat: "" + price + ""tl""); system.out.println(); return price; } @override public string gettype() { return ""americano""; } } public class coffeemachine { static int sumofcoffenumber = 0; public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon){ if(coffee instanceof espresso && (adddon instanceof doubleshot || adddon instanceof chocolate)){ coffee.addaddon(adddon); } else if(coffee instanceof latte && (adddon instanceof milk || adddon instanceof vanillasyrup || adddon instanceof chocolate)){ coffee.addaddon(adddon); } else if(coffee instanceof americano && (adddon instanceof milk || adddon instanceof vanillasyrup)){ coffee.addaddon(adddon); } else{ system.out.println(""[uyari] "" + coffee.gettype() + "" tipi kahveye "" + adddon.getname() + "" eklenemez""); } } public void makecoffee(basecoffee coffee){ coffee.calculateprice(); sumofcoffenumber++; } public void heatespressocup(basecoffee coffee){ if(coffee instanceof espresso){ ((espresso)coffee).heatcup(); system.out.println(""espresso kahve fincanı ısıtıldı""); } else{ system.out.println(""[uyari] yalnızca espresso kahve fincanları ısıtılabilir""); } } public void displaysumofcoffenumber(){ system.out.println(""tum kahve makineleri tarafindan toplam "" + sumofcoffenumber + "" kahve uretildi""); } } public class milk implements coffeeaddon{ @override public double getcost() { return 5; } @override public string getname() { return ""milk""; } } public class doubleshot implements coffeeaddon{ @override public double getcost() { return 10; } @override public string getname() { return ""double shot""; } } public class chocolate implements coffeeaddon{ @override public double getcost() { return 7; } @override public string getname() { return ""chocolate""; } } kek üretim boru hattı bil 211 - quiz 3 27 şubat 2025 1 giriş bu quizde, fileio ve exceptions kullanarak basit bir kek üretim boru hattı uygulaması geliştireceğiz. uygulama, interaktif bir terminal menüsü üzerinden, bir kekin üretiminde yer alacak aşamaların (pastaban, krema, süsleme) seçilmesini, belirlenen sıraya göre uygulanmasını ve bu üretim geçmişinin bir dosyaya kayıt edilip sonradan geri yüklenebilmesini sağlayacaktır. ayrıca, üretime eklenen özelliklerin desteklenmemesi, aşamaların beklenen sırada uygulanmaması veya dosya yükleme sırasında oluşabilecek sorunlu durumlarda özel hatalar atmalıdır. 2 genel program program konsol tabanlı bir kullanıcı arayüzü ile kek üretim boru hattının denetlenmesini sağlamalıdır. arayüz özellikleri aşağıdaki gibidir. - terminal menüsü: kullanıcıya aşağıdaki seçenekleri sunacaktır: – üretim başlat: kek üretiminde kullanılacak aşamaların (pastaban, krema, süsleme) seçilmesi sürecini başlatır. – üretim geçmişi: üretim geçmişinin ekranda listelenmesi. – kaydet: üretim geçmişinin dosyaya kaydedilmesi. – yükle: dosyadan üretim geçmişinin geri yüklenmesi. – çıkış: program sonlandırılır. - üretim süreci: kek üretimi başlatıldığında (ilk seçenek) kullanıcıya döngü içerisinde yeni bir aşama ekleme, üretimi tamamlama ya da üretimden vazgeçme seçenekleri sunulmalıdır (yani üretim tamam- lanana ya da üretimden vazgeçilene kadar ana menüye dönmeden sürekli yeni aşama eklenmelidir). yeni aşama eklenirken kullanıcıdan bu aşama ile ilgili ek bilgi alınmalı ve kaydedilmelidir (örn., sade pastaban, kakaolu krema, çilek süsleme). seçilen aşamalar iki adet pasta üretim kuralına uymalıdır: 1) ""krema"" eklenmeden önce mutlaka en az bir katman ""pastaban"" eklenmiş olmalıdır; 2) ""süsleme"" eklendikten sonra ""süsleme"" dışında herhangi bir aşama seçilemez. eğer kullanıcı üretimi tamam- ladığında bu kurallardan birisi ihlal ediliyorsa bununla ilgili bir hata atılmalı ve üretim iptal edilerek ana menüye dönülmelidir (atılacak hata ile ilgili ilerleyen bölümleri inceleyin). - dosya i̇şlemleri: üretilen keklerin üretim geçmişi, programın çalıştığı dizinde sabit isimli kek_uretim dosyasında saklanabilmeli ve bu dosyadan geri yüklenebilmelidir. 3 uretimasamasi sınıfı değişkenler: - tip (private string) uretim asamasinin tipi (yalnizca pastaban, krema ya da susleme olabilir). - ozellik (private string) uretim asamasinin ozelligi (örn., krema, çilek). metotlar: - public uretimasamasi(string tip, string ozellik) constructor. - private değişkenler için getter ve setter tanımlayabilirsiniz. 1 4 uretimkaydi sınıfı değişkenler: - asamalar (private arraylist<uretimasamaasi>) keki üretmek için gerekli aşamalar (aşamalar dizi sırasında gerçekleşir). metotlar: - public uretimkaydi() constructor. - public void parcaekle(uretimasamaasi asama) asamalar dizisine kek üretimi için yeni bir aşama ekler. - private değişkenler için getter ve setter tanımlayabilirsiniz. 5 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları (örn., bufferedreader, scanner, printwriter) kullanacaktır. dosya işlemleri sırasında aşağıdaki hata durumları için uygun mesajlar verilmelidir: - dosya bulunamazsa: ""hata: kek_uretim dosyası bulunamadı."" - dosya boşsa: ""hata: kek_uretim dosyası boş."" 6 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program, hata kodu ile sonlanmalı ve ilgili hata mesajları stderr’e yazdırılmalıdır. 6.1 girdi hataları (inputexception class) dosya işlemleriyle ilgili hatalar için kendi tanımlayacağınız inputexception sınıfından türeyen özel hata sınıfları oluşturulacaktır: - dosyabulunamadiexception (extends inputexception): dosya eksikse atılacak hata. - hata mesajı: ""hata: kek_uretim dosyası bulunamadı."" - bosdosyaexception (extends inputexception): dosya boşsa atılacak hata. - hata mesajı: ""hata: kek_uretim dosyası boş."" 6.2 üretim süreci hataları ürüne eklenen aşamaların desteklenmemesi veya üretim aşamalarının hatalı sırayla uygulanması durum- larında aşağıdaki hata türleri kullanılacaktır: - ozellikdesteksizexception (extends exception): eklenmek istenen aşama, kek üretiminde destek- lenmiyorsa atılacak hata. - hata mesajı: ""hata: [aşama adı] kek üretiminde desteklenmiyor."" - sirauyumsuzluguexception (extends exception): üretim aşamalarının beklenen sırada uygu- lanmaması durumunda atılacak hata. - hata mesajı: ""hata: üretim sırası uyumsuz. [ihlal edilen pasta üretim kuralı]."" 7 gönderim formatı - quizinizi bitirdiğinizde asistanlarınızdan birisine kodunuzu ve çıktısını gösterip puanlatın. - asistan labınızı puanladığında tüm kaynak dosyalarını ve bu dökümantasyonu bir arşiv dosyası (zip, rar, 7z, tar, tar.gz) halinde sıkıştırın. - arşiv dosyasının isim_numara formatında isimlendirin (örn., sebnemferah_181101014.zip). - i̇simlendirdiğiniz arşiv dosyasını uzak sistemindeki quiz alanına yükleyin. 2 package bil211quiz3; public class uretimasamasi { private string tip; private string ozellik; public uretimasamasi(string tip, string ozellik){ this.tip = tip; this.ozellik = ozellik; } public string gettip(){ return tip; } public string getozellik(){ return ozellik; } public void settip(string tip){ if(tip.equalsignorecase(""pastaban"") || tip.equalsignorecase(""krema"") || tip.equalsignorecase(""susleme"")) this.tip = tip; } public void setozellik(string ozellik){ this.ozellik = ozellik; } } package bil211quiz3; import java.io.file; import java.io.fileinputstream; import java.io.filenotfoundexception; import java.io.fileoutputstream; import java.io.ioexception; import java.io.objectinputstream; import java.io.objectoutputstream; import java.util.arraylist; import java.util.scanner; public class mainprogram { static arraylist<uretimkaydi> kayitlar = new arraylist<>(); public static void main(string[] args) { string filename2 = ""kek_uretim.bin""; uretimkaydi uretimkaydi; try{ uretimkaydi = new uretimkaydi(); scanner scanner = new scanner(system.in); int state = 0; int state2; system.out.println(""0: yeni kayıt""); system.out.println(""1: kayıt yukle""); system.out.println(""2: kayıt yaz""); system.out.println(""3: kayıt göster""); system.out.println(""4: çıkış""); state2 = scanner.nextint(); while(state2 == 0 || state2 == 1 || state2 == 2 ||state == 3){ if(state2 == 0){ system.out.println(""0: katman ekle""); system.out.println(""1: uretimi tamamla""); system.out.println(""2: vazgeç""); uretimasamasi asama = new uretimasamasi("""", """"); while((state = scanner.nextint()) == 0){ system.out.println(""0: pastaban""); system.out.println(""1: krema""); system.out.println(""2: susleme""); int tiptype = scanner.nextint(); string ozellik; scanner.nextline(); if(tiptype == 0){ if(suslemecontroller(uretimkaydi)){ throw new sirauyumsuzluguexception(""2: susleme aşamasından sonra susleme dışında başka bir aşama eklenemez""); } else{ system.out.println(""çeşidi belirtiniz""); ozellik = scanner.nextline(); asama = new uretimasamasi(""pastaban"", ozellik); } } else if(tiptype == 1){ if(suslemecontroller(uretimkaydi)){ throw new sirauyumsuzluguexception(""2: susleme aşamasından sonra susleme dışında başka bir aşama eklenemez""); } else if(kremapastabancontroller(uretimkaydi)){ system.out.println(""çeşidi belirtiniz""); ozellik = scanner.nextline(); asama = new uretimasamasi(""krema"", ozellik); } else{ throw new sirauyumsuzluguexception(""1: krema eklenmeden önce mutlaka en az bir katman pastaban eklenmelidir""); } } else if(tiptype == 2){ system.out.println(""çeşidi belirtiniz""); ozellik = scanner.nextline(); asama = new uretimasamasi(""susleme"", ozellik); } else{ system.out.println(""oyle bir seçenek yok""); continue; } uretimkaydi.parcaekle(asama); } if(state != 0 && state != 1 && state != 2 && state != 3 && state != 4) throw new ozellikdesteksizexception("""" + state); if(state == 1) kayitlar.add(uretimkaydi); if(state == 2) uretimkaydi = new uretimkaydi(); } else if(state2 == 1){ kayitlar = kayitoku(filename2); } else if(state2 == 2){ kayityaz(kayitlar, filename2); } else{ kayitgoster(kayitlar); } state2 = scanner.nextint(); } scanner.close(); } catch(exception e){ system.err.println(e.getmessage()); e.printstacktrace(); } } public static boolean kremapastabancontroller(uretimkaydi kayit){ boolean flag = false; for(int i = 0; i < kayit.getasamalar().size(); i++){ if(kayit.getasamalar().get(i).gettip().equalsignorecase(""pastaban"")){ flag = true; break; } } return flag; } public static boolean suslemecontroller(uretimkaydi kayit){ for(int i = 0; i < kayit.getasamalar().size(); i++){ if(kayit.getasamalar().get(i).gettip().equalsignorecase(""susleme"")){ return true; } } return false; } @suppresswarnings(""unchecked"") public static arraylist<uretimkaydi> kayitoku(string filename) throws dosyabulunamadıexception, ioexception, classnotfoundexception, bosdosyaexception { arraylist<uretimkaydi> list; file file = new file(filename); if(!file.exists()) throw new dosyabulunamadıexception(); if(file.length() <= 0) throw new bosdosyaexception(); try(objectinputstream binaryin = new objectinputstream(new fileinputstream(filename))){ list = (arraylist<uretimkaydi>) binaryin.readobject(); return list; } catch(filenotfoundexception e){ throw new dosyabulunamadıexception(); } } public static void kayityaz(arraylist<uretimkaydi> list, string filename) throws dosyabulunamadıexception, ioexception{ file file = new file(filename); if(!file.exists()) throw new dosyabulunamadıexception(); try(objectoutputstream binaryout = new objectoutputstream(new fileoutputstream(filename))){ binaryout.writeobject(list); } } public static void kayitgoster(arraylist<uretimkaydi> list){ for(int i = 0; i < list.size(); i++){ for(int j = 0; j < list.get(i).getasamalar().size(); j++){ system.out.println(list.get(i).getasamalar().get(j).gettip() + "" - "" + list.get(i).getasamalar().get(j).getozellik()); } } } } package bil211quiz3; public class dosyabulunamadıexception extends inputexception{ public dosyabulunamadıexception(){ super(""hata: kek_uretim dosyası bulunamadı.""); } } package bil211quiz3; public class bosdosyaexception extends inputexception{ public bosdosyaexception(){ super(""hata: keke-uretim dosyası boş.""); } } package bil211quiz3; import java.io.serializable; import java.util.arraylist; public class uretimkaydi implements serializable{ private arraylist<uretimasamasi> asamalar; public uretimkaydi(){ asamalar = new arraylist<>(); } public void parcaekle(uretimasamasi asama){ asamalar.add(asama); } public arraylist<uretimasamasi> getasamalar(){ return asamalar; } public void setasamalar(arraylist<uretimasamasi> asamalar){ this.asamalar = asamalar; } } package bil211quiz3; public class ozellikdesteksizexception extends exception{ public ozellikdesteksizexception(uretimasamasi asama){ super(""hata: "" + asama.gettip() + ""kek üretiminde desteklenmiyor.""); } public ozellikdesteksizexception(string asama){ super(""hata: "" + asama + ""kek üretiminde desteklenmiyor.""); } } package bil211quiz3; public class sirauyumsuzluguexception extends exception{ public sirauyumsuzluguexception(string hataliasama){ super(""hata: üretim sırası uyumsuz. "" + hataliasama+"".""); } } package bil211quiz3; public class inputexception extends exception{ public inputexception(string message){ super(message); } } bil211 quiz 4 section 1 quizleri uzak sistemine yükleyeceksiniz. q1: yalnızca tek sayıları saklayan liste oddnumberlist adında bir sınıf oluşturun. bu sınıf: ● add(t item) → yalnızca tek sayılar eklenebilir. çift sayı eklenmeye çalışılırsa hata mesajı basılır. ● addall(collection<t> collection) → sadece içindeki tek sayıları ekler. ● getoddnumbers() → i̇çerideki tüm tek sayıları liste olarak döndürür. ● sumofodds() → tüm tek sayıların toplamını döndürür. örnek kullanım: oddnumberlist list = new oddnumberlist(); list.add(5); list.add(3); list.add(8); // eklenmemeli system.out.println(list); // çıktı: [5, 3] q2: koleksiyondan tekrar edenleri kaldırma ● bir collection<t> içindeki tüm tekrar eden öğeleri kaldıran bir generic metod yazın. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> removeduplicates(collection<t> collection) { // metodu tamamlayın } örnek kullanım: list<string> words = arrays.aslist(""apple"", ""banana"", ""apple"", ""orange"", ""banana"", ""grape""); system.out.println(removeduplicates(words)); q3:aşağıdaki generic metodu tamamlayın. ● verilen list<t> içindeki tüm öğeleri büyük harfe çeviren (veya sayıysa olduğu gibi bırakan) bir metod yazın. ● eğer t bir string ise büyük harfe çevirmeli, değilse değiştirmemelidir. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> converttouppercaseifstring(list<t> list) { // metodu tamamlayın } örnek kullanım: list<object> items = arrays.aslist(""hello"", 123, ""world"", 456); system.out.println(converttouppercaseifstring(items)); package bil211q4; import java.util.arraylist; import java.util.collection; import java.util.hashset; import java.util.list; public class oddnumberlist<t>{ public static void main(string[] args){ oddnumberlist<integer> numberlist = new oddnumberlist<>(); oddnumberlist<object> numberlist2 = new oddnumberlist<>(); try{ numberlist.add(5); numberlist.add(3); numberlist.add(7); numberlist.add(9); numberlist.add(11); numberlist.add(5); numberlist.add(3); numberlist.add(7); numberlist.showlist(); arraylist<integer> templist = new arraylist<>(); templist.add(101); templist.add(103); templist.add(105); templist.add(104); templist.add(101); templist.add(103); templist.add(105); templist.add(104); numberlist.addall(templist); numberlist.showlist(); numberlist2.add(5); numberlist2.add(7); numberlist2.add(""hata""); arraylist<object> templist2 = numberlist2.getoddnumbers(); for(object o:templist2){ system.out.println(o); } system.out.println(numberlist2.sumofodds()); list<integer> templist3 = oddnumberlist.removeduplicates(templist); for(integer i:templist3){ system.out.println(i); } arraylist<string> stringlist = new arraylist<>(); stringlist.add(""jkfdsl 2 dsajd dsajhd jsa hdjsa djsaak""); stringlist.add(""dfhsyfgwq 26317 f dgsa 621wdgfa""); stringlist.add(""dsajk udıdqoıw nsamdsgh gyuq asbdhja""); list<string> newstringlist = oddnumberlist.converttouppercaseifstring(stringlist); for(string s:newstringlist){ system.out.println(s); } arraylist<integer> integerlist = new arraylist<>(); integerlist.add(3); integerlist.add(2); integerlist.add(15); list<integer> newintegerlist = oddnumberlist.converttouppercaseifstring(integerlist); for(integer i:newintegerlist){ system.out.println(i); } } catch(exception e){ system.err.println(e.getmessage()); } } arraylist<t> list; int size; public oddnumberlist(){ list = new arraylist<>(); size = 0; } public boolean add(t e) throws exception { if(e instanceof number){ if(((number)e).intvalue()%2 == 0){ throw new exception(""wrong value "" + e); } else{ list.add(e); } } else{ list.add(e); } return true; } public boolean addall(collection<t> collection) throws exception{ for(t e:collection){ if(e instanceof number){ if(((number)e).intvalue()%2 == 1){ list.add(e); } } } return true; } public arraylist<t> getoddnumbers(){ arraylist<t> newlist = new arraylist<>(); for(t e:list){ if(e instanceof number){ if(((number)e).intvalue()%2 == 1){ newlist.add(e); } } } return newlist; } public int sumofodds(){ int sum = 0; for(t e:list){ if(e instanceof number){ if(((number)e).intvalue()%2 == 1){ sum += ((number)e).intvalue(); } } } return sum; } public void showlist(){ for(t e:list){ system.out.println(e); } } public static <t> list<t> removeduplicates(collection<t> collection) { hashset<t> set = new hashset<>(); for(t e:collection){ set.add(e); } arraylist<t> newlist = new arraylist<>(); for(t e:set){ newlist.add(e); } return newlist; } @suppresswarnings(""unchecked"") public static <t> list<t> converttouppercaseifstring(list<t> list) { arraylist<t> newlist = new arraylist<>(); if(list.size() > 0 && list.get(0) instanceof string){ for(t e:list){ newlist.add(((t)((string)e).touppercase())); } } else{ for(t e:list){ newlist.add(e); } } return newlist; } } 1 kuş bakışı atış oyunu (top-down shooter) bil 211 - proje teslim tarihi: 27 mart 2025 23:59 1 amaç bu ödevde amacınız, java swing kullanarak kuş bakışı bir atış oyunu (top-down shooter) tasarlamaktır. oyunda, yönettiğimiz karakterin üzerine dalga dalga gelen çeşitli zombileri fare ile hedef alarak farklı silahlar kullanıp öldürmemiz gerekmektedir. karakterimiz öldüğünde oyun sona erecektir. her dalga başına ve öldürülen zombi başına kazanılan puan artacaktır. dalgalar ilerledikçe gelen zombilerin sayısı ve çeşitleri artarak zorluk seviyesi yükselecektir. 2 gereksinimler oyun derste öğrendiğiniz oop ilkelerine uygun sınıf/arayüz tasarımları ile geliştirilmelidir. - zorluk seviyesi arttıkça zombi sayısı ve çeşitliliği artmalıdır. - oyun duraklatılabilmeli ve kaydedilip tekrar yüklenilebilmelidir (fileio kullanılmalıdır). - sol üst köşede seçili silah ve kalan mermi miktarı gösterilmelidir. - sağ üst köşede oyuncunun canı ve toplam puanı gösterilmelidir. - oyunun duraklatılması, kaydedilmesi ve devam ettirilmesi için bir menü bulunmalıdır. 3 silahlar oyunda farklı silahlar bulunmaktadır. belirli zombi dalgaları temizlendikten sonra oyun ödül olarak yeni bir silahverecektir. hersilahınkendineözgübirçalışmamekanizmasıvardır. silahlarınşarjörkapasitesisınırlıdır ve şarjördeki mermiler bittiğinde tekrar doldurulmadan ateş edilemez. toplam mermi sayısı oyuncunun o silaha ait elinde ne kadar mermi olduğunu gösterir. r tuşuna basarak şarjör yeniden doldurulabilir. 3.1 tabanca - şarjör kapasitesi: 12 mermi - ateş hızı: 120 mermi/dakika - elde etme: oyuncu oyuna bu silahla başlar. - özellik: düz atış yapar, sapma yoktur. sınırsız yedek şarjör (diğer tüm silahlar için yedek şarjör ve mermiler rastgele bir şekilde dalga sırasında ve sonlarında zombilerden düşer). 3.2 piyade tüfeği - şarjör kapasitesi: 30 mermi - ateş hızı: 600 mermi/dakika - elde etme: 1. dalga tamamlandıktan sonra - özellik: düzatışyaparancak30derecesapmasıvardır. sapmaaçısı, karakterinbaktığıyöndemerminin her iki dönme yönüne de saçılabileceği maksimum açıdır. 1 3.3 pompalı tüfek - şarjör kapasitesi: 5 mermi - ateş hızı: 60 mermi/dakika - elde etme: 3. dalga tamamlandıktan sonra - özellik: her atış 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi atar (yani karakter merkezli mermi hız vektörleri arasında 5 derece açı olmalıdır). 3.4 keskin nişancı tüfeği - şarjör kapasitesi: 5 mermi - ateş hızı: 30 mermi/dakika - elde etme: 5. dalga tamamlandıktan sonra - özellik: mermileri zombileri delip arasındaki zombilere de hasar verir. 3.5 roketatar - şarjör kapasitesi: 1 roket - ateş hızı: 10 roket/dakika - elde etme: 10. dalga tamamlandıktan sonra - özellik: patlama etkisiyle birden fazla zombiye zarar verir. 4 zombiler zombiler oyundaki düşman tipleridir. zombiler oyuncuya doğru ilerlerler ve eğer oyuncuya temas ederlerse oyuncuya hasar verirler. zorluk seviyesi arttıkça zombilerin sayısı ve çeşitliliği artmaktadır. zombi tipleri birbirinden renk ya da şekil olarak ayırt edilebilmelidir. 4.1 normal zombi - can: orta - hız: yavaş - hasar: orta 4.2 sürünge zombi - can: düşük - hız: hızlı - hasar: orta - özellik: oyuncunun yakınına geldiğinde zıplar. 4.3 tank zombi - can: yüksek - hız: çok yavaş - hasar: yüksek 2 4.4 asit tüküren zombi - can: düşük - hız: yavaş - hasar: orta (uzaktan asit tükürebilir) - özellik: öldürüldüğünde yanındaki birimlere zarar verir. 5 rapor ve teslim formatı - oyun, oopprensiplerineuygunolaraktasarlanmalıvesınıfdiyagramları, arayüztasarımıfinalraporda sunulmalıdır. - oyun test edilerek ekran görüntüleri rapora eklenmelidir. - rapor pdf formatında olmalı ve ismi proje_rapor.pdf olmalıdır. - oyunun mainfonksiyonu gameisimli bir sınıf içinde bulunmalıdır ( java game komutuyla çalışmalı). - kaynak kodun tamamı source.zip (uzantı 7z, rar, tar.gz de olabilir) şeklinde sıkıştırılmış olmalıdır. - sıkıştırılmış kaynak kod ve rapor uzak sistemine yüklenmelidir. 6 yardımcı kaynaklar dahaöncehiçkuşbakışıatışoyunuoynamadıysanızaşağıdakioyunlarıreferansolarakalabilirsiniz. buradaki oyunlarıngrafikleriilemekaniklerisizdenbeklenendenfarklıolsadaharitatasarımı, karakterhareketi,kamera hareketi, ateş etme mekanikleri ve zombilerin yapay zekası ile ilgili temel fikirler edinebilirsiniz. - little top-down shooter: https://www.youtube.com/watch?v=pj3m3fu3i5a - super c - stage 2: https://www.youtube.com/watch?v=os2t_v5suj4 - neon chrome: https://www.youtube.com/watch?v=puhw1bevtro 3 package bil211game2.game.main; import java.net.url; import java.util.concurrent.blockingqueue; import java.util.concurrent.linkedblockingqueue; import javax.sound.sampled.audioinputstream; import javax.sound.sampled.audiosystem; import javax.sound.sampled.clip; import javax.sound.sampled.floatcontrol; import javax.sound.sampled.lineevent; public class sound implements runnable { // sound thread ve durumu private thread soundthread; private boolean running = false; // komut kuyrukları private blockingqueue<soundcommand> commandqueue = new linkedblockingqueue<>(); // ses url'leri private url[] soundurl = new url[30]; // müzik için clip private clip musicclip; // ses ayarları private float volume = 0.5f; // ses sabitleri public static final int title_screen_music = 0; public static final int phase1_music = 1; public static final int phase3_music = 2; public static final int phase5_music = 3; public static final int phase7_music = 4; public static final int phase10_music = 5; // ses efektleri public static final int acid_zombie_acid_sound = 13; public static final int pistol_sound = 14; public static final int rifle_sound = 15; public static final int shotgun_sound = 16; public static final int sniper_sound = 17; public static final int rocket_sound = 18; public static final int rocket_bang_sound = 19; public static final int zombie_hurt = 20; public static final int player_hurt = 21; public static final int fanfare_sound = 22; public sound() { // ses dosyalarını yükle loadsounds(); // sound thread'i başlat startsoundthread(); } private void loadsounds() { soundurl[title_screen_music] = getclass().getresource(""/bil211game2/resources/sound/music/halls of the undead - kevin macleod.wav""); soundurl[phase1_music] = getclass().getresource(""/bil211game2/resources/sound/music/thewasteland.wav""); soundurl[phase3_music] = getclass().getresource(""/bil211game2/resources/sound/music/thewasteland.wav""); soundurl[phase5_music] = getclass().getresource(""/bil211game2/resources/sound/music/thewasteland.wav""); soundurl[phase7_music] = getclass().getresource(""/bil211game2/resources/sound/music/thewasteland.wav""); soundurl[phase10_music] = getclass().getresource(""/bil211game2/resources/sound/music/thewasteland.wav""); soundurl[acid_zombie_acid_sound] = getclass().getresource(""/bil211game2/resources/sound/se/315846__gneube__zombie-roar.wav""); soundurl[pistol_sound] = getclass().getresource(""/bil211game2/resources/sound/se/627087clutvhsilenced-pistol-shot.wav""); soundurl[rifle_sound] = getclass().getresource(""/bil211game2/resources/sound/se/404561__superphat__assaultrifle2.wav""); soundurl[shotgun_sound] = getclass().getresource(""/bil211game2/resources/sound/se/564480__lumikon__shotgun-shot-sfx.wav""); soundurl[sniper_sound] = getclass().getresource(""/bil211game2/resources/sound/se/182051qubodupsniper-rifle-shot-sound-effect.wav""); soundurl[rocket_sound] = getclass().getresource(""/bil211game2/resources/sound/se/517169__mrthenoronha__rocket-launcher-1-8-bit.wav""); soundurl[rocket_bang_sound] = getclass().getresource(""/bil211game2/resources/sound/se/268557cydonexplosion001.wav""); soundurl[zombie_hurt] = getclass().getresource(""/bil211game2/resources/sound/se/396797__scorpion67890__mutant-scream.wav""); soundurl[player_hurt] = getclass().getresource(""/bil211game2/resources/sound/se/262279__dirtjm__grunts-male.wav""); soundurl[fanfare_sound] = getclass().getresource(""/bil211game2/resources/sound/se/401144fullmetaljedipiece-of-shred.wav""); } // thread'i başlat private void startsoundthread() { if (soundthread == null || !soundthread.isalive()) { running = true; soundthread = new thread(this); soundthread.setdaemon(true); soundthread.start(); } } // sound thread'inin çalışacağı metot @override public void run() { try { while (running) { try { // kuyruktan bir komut al ve işle soundcommand command = commandqueue.take(); processcommand(command); } catch (interruptedexception e) { e.printstacktrace(); } } } catch (exception e) { e.printstacktrace(); } } // komut işleme private void processcommand(soundcommand command) { try { switch (command.type) { case load_music: loadmusic(command.soundindex); break; case play_effect: playeffect(command.soundindex); break; case play_music: playmusic(); break; case loop_music: loopmusic(); break; case stop_music: stopmusic(); break; case set_volume: setvolumeinternal(command.volumelevel); break; case cleanup: cleanupresources(); running = false; // thread'i durdur break; } } catch (exception e) { e.printstacktrace(); } } // müzik yükleme private void loadmusic(int soundindex) { try { if (musicclip != null) { musicclip.stop(); musicclip.close(); musicclip = null; } audioinputstream ain = audiosystem.getaudioinputstream(soundurl[soundindex]); musicclip = audiosystem.getclip(); musicclip.open(ain); // ses seviyesini ayarla applyvolumetoclip(musicclip); // stream'i kapat ain.close(); } catch (exception e) { e.printstacktrace(); } } // efekt çalma private void playeffect(int soundindex) { try { clip effectclip = audiosystem.getclip(); audioinputstream ain = audiosystem.getaudioinputstream(soundurl[soundindex]); effectclip.open(ain); // ses seviyesini ayarla applyvolumetoclip(effectclip); // tamamlandığında kaynakları serbest bırak effectclip.addlinelistener(event -> { if (event.gettype() == lineevent.type.stop) { effectclip.close(); } }); // efekti çal effectclip.start(); // stream'i kapat ain.close(); } catch (exception e) { e.printstacktrace(); } } // ses seviyesini clip'e uygula private void applyvolumetoclip(clip clip) { try { if (clip.iscontrolsupported(floatcontrol.type.master_gain)) { floatcontrol gaincontrol = (floatcontrol) clip.getcontrol(floatcontrol.type.master_gain); float db = (float) (math.log(volume) / math.log(10.0) * 20.0); gaincontrol.setvalue(db); } } catch (exception e) { e.printstacktrace(); } } // müziği çal private void playmusic() { if (musicclip != null) { musicclip.setframeposition(0); musicclip.start(); } } // müziği döngüye al private void loopmusic() { if (musicclip != null) { musicclip.loop(clip.loop_continuously); } } // müziği durdur private void stopmusic() { if (musicclip != null) { musicclip.stop(); } } // ses seviyesini ayarla private void setvolumeinternal(float level) { volume = level; if (musicclip != null) { applyvolumetoclip(musicclip); } } // kaynakları temizle private void cleanupresources() { if (musicclip != null) { musicclip.stop(); musicclip.close(); musicclip = null; } } // -- public api methods -- // müzik yükle (gamepanel'ın çağıracağı public metot) public void setfile(int i) { try { commandqueue.put(new soundcommand(commandtype.load_music, i)); } catch (interruptedexception e) { e.printstacktrace(); } } // ses efekti çal public void playse(int i) { try { commandqueue.put(new soundcommand(commandtype.play_effect, i)); } catch (interruptedexception e) { e.printstacktrace(); } } // müziği çal public void play() { try { commandqueue.put(new soundcommand(commandtype.play_music)); } catch (interruptedexception e) { e.printstacktrace(); } } // müziği döngüye al public void loop() { try { commandqueue.put(new soundcommand(commandtype.loop_music)); } catch (interruptedexception e) { e.printstacktrace(); } } // müziği durdur public void stop() { try { commandqueue.put(new soundcommand(commandtype.stop_music)); } catch (interruptedexception e) { e.printstacktrace(); } } // ses seviyesini ayarla public void setvolume(float volume) { try { commandqueue.put(new soundcommand(commandtype.set_volume, volume)); } catch (interruptedexception e) { e.printstacktrace(); } } // tüm kaynakları temizle ve thread'i durdur public void cleanup() { try { commandqueue.put(new soundcommand(commandtype.cleanup)); // thread'in kapanmasını bekle if (soundthread != null) { soundthread.join(1000); // en fazla 1 saniye bekle } } catch (interruptedexception e) { e.printstacktrace(); } } // -- helper classes -- // komut tipleri private enum commandtype { load_music, play_effect, play_music, loop_music, stop_music, set_volume, cleanup } // komut sınıfı private class soundcommand { commandtype type; int soundindex; float volumelevel; // standart komut constructor soundcommand(commandtype type) { this.type = type; } // ses indeksi ile komut constructor soundcommand(commandtype type, int soundindex) { this.type = type; this.soundindex = soundindex; } // ses seviyesi ile komut constructor soundcommand(commandtype type, float volumelevel) { this.type = type; this.volumelevel = volumelevel; } } } package bil211game2.game.main; import java.awt.graphics2d; import java.awt.image.bufferedimage; public class utilitytool { public static bufferedimage scaleimage(bufferedimage original, int width, int height){ bufferedimage scaledimage = new bufferedimage(width, height, original.gettype()); graphics2d g2 = scaledimage.creategraphics(); g2.drawimage(original, 0, 0, width, height, null); g2.dispose(); return scaledimage; } public static double distancecalculator(int p1x, int p1y, int p2x, int p2y){ return math.sqrt((p2x - p1x)*(p2x - p1x)+(p2y - p1y)*(p2y - p1y)); } } package bil211game2.game.main; import java.awt.canvas; import java.awt.color; import java.awt.dimension; import java.awt.graphics2d; import java.awt.graphicsconfiguration; import java.awt.graphicsenvironment; import java.awt.renderinghints; import java.awt.toolkit; import java.awt.transparency; import java.awt.geom.affinetransform; import java.awt.image.bufferstrategy; import java.awt.image.bufferedimage; import java.io.fileinputstream; import java.io.fileoutputstream; import java.io.ioexception; import java.io.objectinputstream; import java.io.objectoutputstream; import java.util.arraylist; import java.util.collections; import java.util.comparator; import java.util.random; import bil211game2.game.entity.acidzombie; import bil211game2.game.entity.entity; import bil211game2.game.entity.monster; import bil211game2.game.entity.normalzombie; import bil211game2.game.main.tile.tilemanager; import bil211game2.game.objects.ammos.ammo; import bil211game2.game.objects.ammos.pistolammo; import bil211game2.game.objects.ammos.rifleammo; import bil211game2.game.objects.ammos.rocketammo; import bil211game2.game.objects.ammos.shotgunammo; import bil211game2.game.objects.ammos.sniperammo; import bil211game2.game.objects.animations.animationmanager; import bil211game2.game.entity.player; import bil211game2.game.entity.reptilezombie; import bil211game2.game.entity.tankzombie; public class gamepanel extends canvas implements runnable{ final int originaltilesize = 16; final int scale = 3; public final int tilesize = originaltilesize * scale; public final int maxscreencol = 16; public final int maxscreenrow = 12; public final int screenwidth = tilesize*maxscreencol; public final int screenheight = tilesize*maxscreenrow; public final int maxworldcol = 116; public final int maxworldrow = 112; int fps = 60; // double buffer variables private bufferstrategy bufferstrategy; private graphicsconfiguration graphicsconfig; private bufferedimage offscreenbuffer; // system public thread gamethread; public keyhandler keyh = new keyhandler(this); public mousehandler mouseh = new mousehandler(this); public collisionchecker cchecker = new collisionchecker(this); public ui ui = new ui(this); public assetsetter asetter = new assetsetter(this); public eventhandler ehandler = new eventhandler(this); public sound music = new sound(); public sound se = new sound(); public sound seammo = new sound(); public sound semonster = new sound(); tilemanager tilem = new tilemanager(this); private int framecount = 0; private long fpstimer = 0; public int fps = 0; public boolean drawfps = false; public animationmanager animationmanager; // entity public player player = new player(this, keyh, mouseh); arraylist<entity> entitylist = new arraylist<>(); public arraylist<monster> monsters = new arraylist<>(); public arraylist<ammo> ammos = new arraylist<>(); // game state public int gamestate; public final int titlestate = 0; public final int playstate = 1; public final int pausestate = 2; public final int dialogstate = 3; public final int finishstate = 4; public boolean phasefinished = false; public boolean phasefinishdraw = false; private int phasetransitioncounter = 0; private final int phase_transition_duration = 90; // phases public final int phase1 = 0; public final int phase2 = 1; public final int phase3 = 2; public final int phase4 = 3; public final int phase5 = 4; public final int phase6 = 5; public final int phase7 = 6; public final int phase8 = 7; public final int phase9 = 8; public final int phase10 = 9; public int currentphase; // gamepanel sınıfına eklenecek yeni değişkenler private boolean screenshakeactive = false; private int screenshakeintensity = 0; private int screenshakeduration = 0; private int screenshaketimer = 0; private int shakeoffsetx = 0; private int shakeoffsety = 0; private random shakerandom = new random(); public gamepanel(){ this.setpreferredsize(new dimension(screenwidth, screenheight)); this.setbackground(color.black); this.setignorerepaint(true); this.addkeylistener(keyh); this.addmouselistener(mouseh); this.addmousemotionlistener(mouseh); this.setfocusable(true); animationmanager = new animationmanager(this); graphicsenvironment env = graphicsenvironment.getlocalgraphicsenvironment(); graphicsconfig = env.getdefaultscreendevice().getdefaultconfiguration(); } public void setupaftervisible() { createbufferstrategy(3); bufferstrategy = getbufferstrategy(); offscreenbuffer = graphicsconfig.createcompatibleimage( screenwidth, screenheight, transparency.opaque); } public void setupgame(){ gamestate = titlestate; currentphase = phase1 - 1; playmusic(sound.title_screen_music); } public void startgamethread(){ gamethread = new thread(this); gamethread.start(); } @override public void run() { double drawinternal = 1000000000/fps; double delta = 0; long lasttime = system.nanotime(); long currenttime; fpstimer = system.currenttimemillis(); while(gamethread != null){ currenttime = system.nanotime(); delta += (currenttime - lasttime)/drawinternal; lasttime = currenttime; if(delta >= 1){ update(); // çizim yap render(); delta--; framecount++; // her saniye fps'i güncelle if(system.currenttimemillis() - fpstimer >= 1000) { fps = framecount; framecount = 0; fpstimer = system.currenttimemillis(); } } } } private void render() { // bufferstrategy kontrol et if (bufferstrategy == null) { return; } try { graphics2d g2 = offscreenbuffer.creategraphics(); try { configuregraphicsquality(g2); g2.setcolor(color.black); g2.fillrect(0, 0, screenwidth, screenheight); if (gamestate == titlestate) { ui.draw(g2); } else { // oyun öğeleri için ekran sallama uygula affinetransform originaltransform = g2.gettransform(); if (screenshakeactive) { g2.translate(shakeoffsetx, shakeoffsety); } // tiles tilem.draw(g2); // add to elements to arraylist entitylist.add(player); // monsters adding for (int i = 0; i < monsters.size(); i++) { if (monsters.get(i) != null) { entitylist.add(monsters.get(i)); } } // sort collections.sort(entitylist, new comparator<entity>() { @override public int compare(entity e1, entity e2) { int result = integer.compare(e1.worldy, e2.worldy); return result; } }); // draw list for (int i = 0; i < entitylist.size(); i++) { if (utilitytool.distancecalculator(entitylist.get(i).worldx, entitylist.get(i).worldy, player.worldx, player.worldy) < 10 * tilesize) { entitylist.get(i).draw(g2); } } // empty list entitylist.clear(); // ammo's draw for (ammo ammo : ammos) { if (utilitytool.distancecalculator(ammo.worldx, ammo.worldy, player.worldx, player.worldy) < 8 * tilesize) { ammo.draw(g2); } } // ui çizmeden önce dönüşümü sıfırla (ui sallanmasın) g2.settransform(originaltransform); animationmanager.draw(g2); // ui ui.draw(g2); } } finally { g2.dispose(); } graphics2d g = (graphics2d) bufferstrategy.getdrawgraphics(); try { g.drawimage(offscreenbuffer, 0, 0, null); } finally { g.dispose(); } if (!bufferstrategy.contentslost()) { bufferstrategy.show(); } toolkit.getdefaulttoolkit().sync(); } catch (exception e) { e.printstacktrace(); } } private void configuregraphicsquality(graphics2d g2) { g2.setrenderinghint(renderinghints.key_antialiasing, renderinghints.value_antialias_on); g2.setrenderinghint(renderinghints.key_rendering, renderinghints.value_render_quality); g2.setrenderinghint(renderinghints.key_color_rendering, renderinghints.value_color_render_quality); g2.setrenderinghint(renderinghints.key_interpolation, renderinghints.value_interpolation_bilinear); } public void update(){ if(gamestate == playstate){ updatescreenshake(); player.update(); // handle phase transitions if(phasefinishdraw) { phasetransitioncounter++; if(phasetransitioncounter >= phase_transition_duration) { phasefinishdraw = false; phasetransitioncounter = 0; } } else if(phasechecker()){ phasefinished = true; phasefinishdraw = true; currentphase++; asetter.setmonsterbyphase(); playse(sound.fanfare_sound); } for(int i = 0; i < monsters.size(); i++){ if(monsters.get(i) != null){ monster monstertemp = monsters.get(i); if(monstertemp.alive && !monstertemp.dying){ monstertemp.update(); } else if(monstertemp.dying){ monstertemp.updatedying(); } if(!monstertemp.alive){ monsters.set(i, null); } } } for(ammo ammo : ammos) { ammo.update(); } animationmanager.update(); } if(gamestate == pausestate){ } } public void playmusic(int i){ music.setfile(i); music.play(); music.loop(); } public void stopmusic(){ music.stop(); } public void playse(int i){ se.setfile(i); se.setvolume(0.5f); se.play(); } public void cleanupresources() { // ses kaynaklarını temizle if (music != null) { music.cleanup(); } if (se != null) { se.cleanup(); } } public boolean phasechecker(){ boolean flag = true; for(int i = 0; i < monsters.size(); i++){ if(monsters.get(i) != null){ flag = false; break; } } return flag; } public void resetgame(){ currentphase = phase1 - 1; player = new player(this, keyh, mouseh); monsters = new arraylist<>(); ammos = new arraylist<>(); asetter.resetchances(); stopmusic(); playmusic(sound.phase1_music); } public void savegame(){ gamesavedata data = new gamesavedata(); data.playerx = player.worldx; data.playery = player.worldy; data.playerlife = player.life; data.playerscore = player.score; for(monster monster:monsters){ if(monster != null){ data.monstersx.add(monster.worldx); data.monstersy.add(monster.worldy); data.monsterslife.add(monster.life); if(monster instanceof normalzombie){ data.monsterstype.add(""normal""); } else if(monster instanceof reptilezombie){ data.monsterstype.add(""reptile""); } else if(monster instanceof tankzombie){ data.monsterstype.add(""tank""); } else{ data.monsterstype.add(""acid""); } } } for(ammo ammo:ammos){ if(ammo != null){ data.ammosx.add(ammo.worldx); data.ammosy.add(ammo.worldy); data.ammosxspeed.add(ammo.speedx); data.ammosyspeed.add(ammo.speedy); if(ammo instanceof pistolammo){ data.ammostypes.add(""pistol""); } else if(ammo instanceof rifleammo){ data.monsterstype.add(""rifle""); } else if(ammo instanceof shotgunammo){ data.ammostypes.add(""shotgun""); } else if(ammo instanceof sniperammo){ data.ammostypes.add(""sniper""); } else{ data.ammostypes.add(""rocket""); } } } for(int i = 0; i < 5; i++){ data.weaponsammo[i] = player.weapons[i].ammo; data.weaponsmagazineammo[i] = player.weapons[i].magazineammo; } data.gamephase = currentphase; data.normalzombiechance = asetter.normalzombiechance; data.reptilezombiechance = asetter.reptilezombiechance; data.tankzombiechance = asetter.tankzombiechance; data.acidzombiechance = asetter.acidzombiechance; try(objectoutputstream objout = new objectoutputstream(new fileoutputstream(""bil211game2/resources/save/lastgamesave.bin""))){ objout.writeobject(data); } catch(ioexception e){ e.printstacktrace(); } } public void loadgame(){ resetgame(); try(objectinputstream objout = new objectinputstream(new fileinputstream(""bil211game2/resources/save/lastgamesave.bin""))){ gamesavedata data = (gamesavedata)objout.readobject(); player = new player(this, keyh, mouseh); player.worldx = data.playerx; player.worldy = data.playery; player.life = data.playerlife; player.score = data.playerscore; monsters = new arraylist<>(); for(int i = 0; i < data.monsterstype.size(); i++){ if(data.monsterslife != null && data.monstersx != null && data.monstersy != null && data.monsterstype != null){ switch(data.monsterstype.get(i)){ case ""normal"": monsters.add(new normalzombie(this)); break; case ""reptile"": monsters.add(new reptilezombie(this)); break; case ""tank"": monsters.add(new tankzombie(this)); break; case ""acid"": monsters.add(new acidzombie(this)); break; } if(monsters.size() > i){ monsters.get(i).worldx = data.monstersx.get(i); monsters.get(i).worldy = data.monstersy.get(i); monsters.get(i).life = data.monsterslife.get(i); } } } ammos = new arraylist<>(); for(int i = 0; i < data.ammostypes.size(); i++){ if(data.ammostypes != null && data.ammosx != null && data.ammosxspeed != null && data.ammosy != null && data.ammosyspeed != null){ switch(data.ammostypes.get(i)){ case ""pistol"": ammos.add(new pistolammo(this)); break; case ""rifle"": ammos.add(new rifleammo(this)); break; case ""ahotgun"": ammos.add(new shotgunammo(this)); break; case ""sniper"": ammos.add(new sniperammo(this)); break; case ""rocket"": ammos.add(new rocketammo(this)); break; } ammos.get(i).worldx = data.ammosx.get(i); ammos.get(i).worldy = data.ammosy.get(i); ammos.get(i).speedx = data.ammosxspeed.get(i); ammos.get(i).speedy = data.ammosyspeed.get(i); } } for(int i = 0; i < 5; i++){ player.weapons[i].ammo = data.weaponsammo[i]; player.weapons[i].magazineammo = data.weaponsmagazineammo[i]; } currentphase = data.gamephase; asetter.loadchances(data.normalzombiechance, data.reptilezombiechance, data.tankzombiechance, data.acidzombiechance); gamestate = playstate; } catch(ioexception e){ e.printstacktrace(); } catch (classnotfoundexception e) { e.printstacktrace(); } stopmusic(); playmusic(sound.phase1_music); } public void testmode(){ resetgame(); player.worldx = 40*tilesize; player.worldy = 40*tilesize; for(int i = 0; i < 30; i++){ for(int j = 0; j < 30; j++){ normalzombie zombie = new normalzombie(this); monsters.add(zombie); zombie.worldx = (j+9)*tilesize; zombie.worldy = (i+7)*tilesize; } } currentphase = phase10 + 1; gamestate = playstate; } public void startscreenshake(int intensity, int duration) { screenshakeactive = true; screenshakeintensity = intensity; screenshakeduration = duration; screenshaketimer = 0; } private void updatescreenshake() { if (screenshakeactive) { // zamanla azalan bir yoğunluk hesapla float currentintensity = screenshakeintensity * (1.0f - (float)screenshaketimer / screenshakeduration); // rastgele ofsetler oluştur shakeoffsetx = (int)(shakerandom.nextint((int)currentintensity * 2 + 1) - currentintensity); shakeoffsety = (int)(shakerandom.nextint((int)currentintensity * 2 + 1) - currentintensity); screenshaketimer++; if (screenshaketimer >= screenshakeduration) { screenshakeactive = false; screenshaketimer = 0; shakeoffsetx = 0; shakeoffsety = 0; } } } } package bil211game2.game.main; import java.awt.basicstroke; import java.awt.color; import java.awt.font; import java.awt.gradientpaint; import java.awt.graphics2d; import java.awt.image.bufferedimage; import bil211game2.game.entity.entity; import bil211game2.game.objects.others.obj_hearth; public class ui { gamepanel gp; font arial_40, arial_80b; bufferedimage heartfull, hearthalf, heartblank; public boolean messageon = false; public string message = """"; int messagecounter = 0; public boolean gamefinished = false; graphics2d g2; public string currentdialog = """"; public int commandnum = 0; public int pausecommandnum = 0; int phasetransitioncounter = 0; boolean transitionflag = false; public ui(gamepanel gp){ this.gp = gp; arial_40 = new font(""arial"",font.plain,40); arial_80b = new font(""arial"",font.bold,80); // create hud object entity heart = new obj_hearth(gp); heartfull = heart.image; hearthalf = heart.image2; heartblank = heart.image3; } public void showmessage(string text){ message = text; messageon = true; } public void draw(graphics2d g2){ this.g2 = g2; g2.setfont(arial_40); g2.setcolor(color.white); if(gp.gamestate == gp.playstate){ drawplayerlife(); drawplayerammo(); drawplayerscore(); drawzombiecounter(); if(gp.phasefinishdraw){ transitionflag = true; if(gp.currentphase == gp.phase1){ drawphasetransition(""please ready for the game""); } else{ drawphasetransition((gp.currentphase) + "". phase finished.\n please ready for next""); } } if(gp.drawfps){ drawfps(); } } if(gp.gamestate == gp.pausestate){ drawplayerlife(); drawplayerammo(); drawplayerscore(); drawpausescreen(); } if(gp.gamestate == gp.dialogstate){ drawdialogscreen(); } if(gp.gamestate == gp.titlestate){ drawtitlescreen(); } if(gp.gamestate == gp.finishstate){ drawfinishscreen(); } } public void drawpausescreen(){ // tüm ekranı kaplayan yarı-saydam siyah arka plan g2.setcolor(new color(0, 0, 0, 150)); g2.fillrect(0, 0, gp.screenwidth, gp.screenheight); // pause menü paneli int panelwidth = gp.tilesize*10; int panelheight = gp.tilesize*8; int panelx = gp.screenwidth/2 - panelwidth/2; int panely = gp.screenheight/2 - panelheight/2; // panel arka planı (mavi-mor gradyan) gradientpaint gradient = new gradientpaint( panelx, panely, new color(50, 50, 80), panelx, panely + panelheight, new color(20, 20, 40) ); g2.setpaint(gradient); g2.fillroundrect(panelx, panely, panelwidth, panelheight, 25, 25); // panel kenarı g2.setstroke(new basicstroke(3)); g2.setcolor(new color(100, 100, 180, 200)); g2.drawroundrect(panelx, panely, panelwidth, panelheight, 25, 25); // ""game paused"" başlığı g2.setfont(new font(""arial"", font.bold, 36)); g2.setcolor(new color(220, 220, 255)); string pausedtext = ""game paused""; int pausedx = gp.screenwidth/2 - g2.getfontmetrics().stringwidth(pausedtext)/2; g2.drawstring(pausedtext, pausedx, (int) (panely + gp.tilesize*1.5)); // alt çizgi g2.setstroke(new basicstroke(2)); g2.drawline(panelx + gp.tilesize, panely + gp.tilesize*2, panelx + panelwidth - gp.tilesize, panely + gp.tilesize*2); // karakter resmi (daha küçük) int charactersize = gp.tilesize*3/2; int characterx = gp.screenwidth/2 - charactersize/2; int charactery = (int) (panely + gp.tilesize*2.5); g2.drawimage(gp.player.down1, characterx, charactery, charactersize, charactersize, null); // menü seçenekleri g2.setfont(new font(""arial"", font.plain, 24)); // menü arkaplanları ve metinleri drawmenuitem(""continue"", panelx, (int) (panely + gp.tilesize*4.5), panelwidth, pausecommandnum == 0); drawmenuitem(""save game"", panelx, (int) (panely + gp.tilesize*5.5), panelwidth, pausecommandnum == 1); drawmenuitem(""quit"", panelx, (int) (panely + gp.tilesize*6.5), panelwidth, pausecommandnum == 2); // oyuncu istatistikleri drawpausestats(panelx + gp.tilesize/2, (int) (panely + panelheight - gp.tilesize*0.5 - gp.tilesize/4), panelwidth - gp.tilesize); } public void drawsubwindow(int x, int y, int width, int height){ color c = new color(0,0,0, 175); g2.setcolor(c); g2.fillroundrect(x, y, width, height, 35, 35);; c = new color(255,255,255); g2.setcolor(c); // set the outlines what was created by graphics2 g2.setstroke(new basicstroke(5)); g2.drawroundrect(x+5, y+5, width-10, height-10, 25, 25); } public void drawdialogscreen(){ // window int x = gp.tilesize*2; int y = gp.tilesize/2; int width = gp.screenwidth - (gp.tilesize*4); int height = gp.tilesize*4; drawsubwindow(x, y, width, height); g2.setfont(g2.getfont().derivefont(font.plain, 32f)); x += gp.tilesize/2; y += gp.tilesize; for(string line:currentdialog.split(""\n"")){ g2.drawstring(line, x, y); y += 40; } } public int getxforcenteredtext(string text){ int length = (int)g2.getfontmetrics().getstringbounds(text, g2).getwidth(); return gp.screenwidth/2 - length/2; } public void drawtitlescreen(){ // gradyan arka plan gradientpaint gradient = new gradientpaint(0, 0, new color(40, 40, 60), 0, gp.screenheight, new color(80, 20, 80)); g2.setpaint(gradient); g2.fillrect(0, 0, gp.screenwidth, gp.screenheight); // doku ekleme (küçük kareler şeklinde) g2.setcolor(new color(0, 0, 0, 50)); for(int i = 0; i < gp.screenwidth; i += 20) { for(int j = 0; j < gp.screenheight; j += 20) { g2.fillrect(i, j, 10, 10); } } // kırmızı yarı saydam kaplama (zombi temasını vurgulamak için) g2.setcolor(new color(142, 22, 22, 70)); g2.fillrect(0, 0, gp.screenwidth, gp.screenheight); // oyun başlığı string gametitle = ""zombie apocalypse""; g2.setfont(new font(""impact"", font.bold, 60)); // başlığa gölge efekti ekleme g2.setcolor(new color(120, 0, 0)); int x = getxforcenteredtext(gametitle); int y = gp.tilesize*3; g2.drawstring(gametitle, x+3, y+3); // başlık ana rengi g2.setcolor(new color(220, 20, 20)); g2.drawstring(gametitle, x, y); // karakter gösterimi int charactersize = gp.tilesize*3; int characterx = gp.screenwidth/2 - charactersize/2; int charactery = y + gp.tilesize; g2.drawimage(gp.player.down1, characterx, charactery - gp.tilesize + gp.tilesize/2, charactersize, charactersize, null); // menü paneli int menuwidth = gp.tilesize*8; int menuheight = gp.tilesize*4 + gp.tilesize/2 + gp.tilesize/8; int menux = gp.screenwidth/2 - menuwidth/2; int menuy = charactery + charactersize - gp.tilesize/6; // menü arka planı g2.setcolor(new color(0, 0, 0, 150)); g2.fillroundrect(menux, menuy, menuwidth, menuheight, 25, 25); // menü kenarı g2.setstroke(new basicstroke(3)); g2.setcolor(new color(100, 20, 20, 200)); g2.drawroundrect(menux, menuy, menuwidth, menuheight, 25, 25); // menü başlığı g2.setfont(new font(""arial"", font.bold, 24)); g2.setcolor(new color(220, 220, 220)); string menutitle = ""main menu""; int menutitlex = getxforcenteredtext(menutitle); g2.drawstring(menutitle, menutitlex, menuy + gp.tilesize/2 + 10); // alt çizgi g2.setstroke(new basicstroke(2)); g2.drawline(menux + gp.tilesize, menuy + gp.tilesize/2 + 20, menux + menuwidth - gp.tilesize, menuy + gp.tilesize/2 + 20); // menü seçenekleri g2.setfont(new font(""arial"", font.plain, 20)); // menü öğeleri string[] options = {""new game"", ""test mode"", ""load game"", ""quit""}; for(int i = 0; i < options.length; i++) { drawmenuoption(options[i], menux, (int) (menuy + gp.tilesize*1.5 + (i * gp.tilesize*0.9)), menuwidth, i == commandnum); } // ekranın alt kısmında kontrol bilgileri g2.setfont(new font(""arial"", font.plain, 12)); g2.setcolor(new color(180, 180, 180)); string controlstext = ""controls: w,a,s,d to move | mouse to aim and shoot | r to reload | p to pause""; int controlsx = gp.screenwidth/2 - g2.getfontmetrics().stringwidth(controlstext)/2; g2.drawstring(controlstext, controlsx, gp.screenheight - gp.tilesize/8); } public void menuselect(){ if(commandnum == 0){ gp.gamestate = gp.playstate; gp.asetter.setmonsterbyphase(); gp.stopmusic(); gp.playmusic(sound.phase1_music); } else if(commandnum == 1){ gp.testmode(); gp.stopmusic(); gp.playmusic(sound.phase1_music); } else if(commandnum == 2){ gp.loadgame(); } else{ system.exit(0); } } public void drawplayerlife(){ int x = gp.screenwidth - gp.tilesize*4; int y = gp.tilesize/2; int i = 0; // draw max life while(i < gp.player.maxlife / 2){ g2.drawimage(heartblank, x, y, null); i++; x += gp.tilesize + gp.tilesize/6; } // reset x = gp.screenwidth - gp.tilesize*4; y = gp.tilesize/2; i = 0; // draw current life while(i < gp.player.life){ g2.drawimage(hearthalf, x, y, null); i++; if(i < gp.player.life){ g2.drawimage(heartfull, x, y, null); } i++; x += gp.tilesize + gp.tilesize/6; } } public void drawplayerammo(){ int x = gp.tilesize/2; int y = gp.tilesize/2; int width = gp.tilesize*4; int height = gp.tilesize; // arka plan paneli g2.setcolor(new color(40, 40, 40, 200)); g2.fillroundrect(x, y, width, height, 15, 15); // silah adı string weaponname = """"; switch(gp.player.currentweaponindex) { case 0: weaponname = ""pistol""; break; case 1: weaponname = ""rifle""; break; case 2: weaponname = ""shotgun""; break; case 3: weaponname = ""sniper""; break; case 4: weaponname = ""rocket""; break; } g2.setfont(new font(""arial"", font.bold, 16)); g2.setcolor(color.white); g2.drawstring(weaponname, x + 10, y + 20); // mevcut mermi / toplam mermi string ammotext = gp.player.weapons[gp.player.currentweaponindex].magazineammo + "" / "" + gp.player.weapons[gp.player.currentweaponindex].ammo; g2.drawstring(ammotext, x + 10, y + height - 4); // sarjor doluluk seviyesi int magazinesize = gp.player.weapons[gp.player.currentweaponindex].magazinesize; int currentammo = gp.player.weapons[gp.player.currentweaponindex].magazineammo; int barwidth = width - 20; int barheight = 5; int barx = x + 10; int bary = y + height - 25; // boş şarjör g2.setcolor(new color(100, 100, 100)); g2.fillrect(barx, bary, barwidth, barheight); // dolu şarjör float ammoratio = (float)currentammo / magazinesize; int filledwidth = (int)(barwidth * ammoratio); g2.setcolor(new color(230, 230, 30)); g2.fillrect(barx, bary, filledwidth, barheight); } public void drawphasetransition(string text){ // yarı saydam siyah arka plan g2.setcolor(new color(0, 0, 0, 150)); g2.fillrect(0, 0, gp.screenwidth, gp.screenheight); // dalgalı animasyon efekti float alpha = 0.7f + 0.3f * (float)math.sin(system.currenttimemillis() / 200.0); g2.setcolor(new color(255, 165, 0, (int)(alpha * 255))); // ana metin g2.setfont(new font(""arial"", font.bold, 40)); int y = gp.screenheight/2 - 50; for(string line : text.split(""\n"")){ int x = getxforcenteredtext(line); g2.drawstring(line, x, y); y += 50; } // alt bilgi metni g2.setfont(new font(""arial"", font.plain, 20)); g2.setcolor(new color(255, 255, 255, 200)); string readytext = ""zombie amount: "" + ((gp.currentphase + 1)*3); int readyx = getxforcenteredtext(readytext); g2.drawstring(readytext, readyx, gp.screenheight/2 + 100); } public void drawplayerscore(){ // skor paneli konumu ve boyutu int x = gp.screenwidth - gp.tilesize*4 - gp.tilesize/2; int y = gp.tilesize/2 + gp.tilesize + 10; int width = gp.tilesize*4; int height = gp.tilesize; // arka plan paneli g2.setcolor(new color(40, 40, 40, 200)); g2.fillroundrect(x, y, width, height, 15, 15); // panel kenarı g2.setcolor(new color(150, 150, 150, 150)); g2.setstroke(new basicstroke(2)); g2.drawroundrect(x, y, width, height, 15, 15); // skor etiketi g2.setfont(new font(""arial"", font.bold, 18)); g2.setcolor(new color(220, 220, 220)); g2.drawstring(""score:"", x + 10, y + height/2 + 6); // skor değeri g2.setfont(new font(""arial"", font.bold, 22)); g2.setcolor(new color(255, 215, 0)); // altın sarısı string scorevalue = string.valueof(gp.player.score); int valuex = x + width - g2.getfontmetrics().stringwidth(scorevalue) - 10; g2.drawstring(scorevalue, valuex, y + height/2 + 6); } public void drawfinishscreen(){ // tüm ekranı kaplayan yarı-saydam siyah arka plan g2.setcolor(new color(0, 0, 0, 180)); g2.fillrect(0, 0, gp.screenwidth, gp.screenheight); // oyun sonu paneli int panelwidth = gp.tilesize*10; int panelheight = gp.tilesize*8; int panelx = gp.screenwidth/2 - panelwidth/2; int panely = gp.screenheight/2 - panelheight/2; // panel arka planı gradientpaint gradient = new gradientpaint( panelx, panely, new color(80, 0, 0), panelx, panely + panelheight, new color(30, 0, 0) ); g2.setpaint(gradient); g2.fillroundrect(panelx, panely, panelwidth, panelheight, 30, 30); // panel kenarı g2.setstroke(new basicstroke(4)); g2.setcolor(new color(150, 0, 0)); g2.drawroundrect(panelx, panely, panelwidth, panelheight, 30, 30); // ""game over"" başlığı g2.setfont(new font(""arial"", font.bold, 48)); g2.setcolor(new color(200, 0, 0)); string gameovertext = ""game over""; int gameoverx = gp.screenwidth/2 - g2.getfontmetrics().stringwidth(gameovertext)/2; g2.drawstring(gameovertext, gameoverx, panely + gp.tilesize*2); // alt gölge efekti g2.setcolor(new color(50, 0, 0)); g2.drawstring(gameovertext, gameoverx + 3, panely + gp.tilesize*2 + 3); // skor g2.setfont(new font(""arial"", font.bold, 36)); g2.setcolor(new color(255, 215, 0)); // altın rengi string scoretext = ""score: "" + gp.player.score; int scorex = gp.screenwidth/2 - g2.getfontmetrics().stringwidth(scoretext)/2; g2.drawstring(scoretext, scorex, panely + gp.tilesize*4); // faz bilgisi g2.setfont(new font(""arial"", font.plain, 22)); g2.setcolor(new color(220, 220, 220)); string phasetext = ""phase reached: "" + (gp.currentphase + 1); int phasex = gp.screenwidth/2 - g2.getfontmetrics().stringwidth(phasetext)/2; g2.drawstring(phasetext, phasex, panely + gp.tilesize*5); // yeniden başlatma talimatı g2.setfont(new font(""arial"", font.bold, 20)); g2.setcolor(new color(200, 200, 200)); string restarttext = ""press enter to return to main menu""; int restartx = gp.screenwidth/2 - g2.getfontmetrics().stringwidth(restarttext)/2; // yanıp sönen metin için basit efekt if(system.currenttimemillis() / 500 % 2 == 0) { g2.drawstring(restarttext, restartx, panely + gp.tilesize*7); } } public void drawfps() { // fps göstergesi için konum ve boyut int x = gp.tilesize/2; int y = gp.screenheight - gp.tilesize; int width = gp.tilesize*2; int height = gp.tilesize/2; // arka plan paneli g2.setcolor(new color(0, 0, 0, 180)); g2.fillroundrect(x, y, width, height, 10, 10); // panel kenarı g2.setcolor(new color(150, 150, 150, 120)); g2.setstroke(new basicstroke(1)); g2.drawroundrect(x, y, width, height, 10, 10); // fps değeri g2.setfont(new font(""consolas"", font.bold, 14)); // fps durumuna göre renk değişimi if (gp.fps >= 55) { g2.setcolor(new color(30, 180, 30)); // yeşil - iyi } else if (gp.fps >= 30) { g2.setcolor(new color(180, 180, 30)); // sarı - orta } else { g2.setcolor(new color(180, 30, 30)); // kırmızı - düşük } string fpstext = ""fps: "" + gp.fps; int textx = x + 10; int texty = y + height - gp.tilesize/8 - 1; g2.drawstring(fpstext, textx, texty); } private void drawmenuitem(string text, int x, int y, int width, boolean selected) { int itemheight = gp.tilesize/2 + 10; int textx = gp.screenwidth/2 - g2.getfontmetrics().stringwidth(text)/2; // seçili öğe için arka plan if(selected) { g2.setcolor(new color(100, 100, 180, 180)); g2.fillroundrect(x + gp.tilesize, y - itemheight/2, width - gp.tilesize*2, itemheight, 15, 15); g2.setcolor(new color(220, 220, 255)); // seçim işaretçisi g2.fillpolygon( new int[]{x + gp.tilesize - 10, x + gp.tilesize - 20, x + gp.tilesize - 10}, new int[]{y - 8, y, y + 8}, 3 ); } else { g2.setcolor(new color(180, 180, 180)); } // menü metni g2.drawstring(text, textx, y + 10); } private void drawpausestats(int x, int y, int width) { g2.setfont(new font(""arial"", font.plain, 16)); g2.setcolor(new color(180, 180, 180)); // skor string scoretext = ""score: "" + gp.player.score; g2.drawstring(scoretext, x, y); // can string healthtext = ""health: "" + gp.player.life + ""/"" + gp.player.maxlife; int healthx = x + width - g2.getfontmetrics().stringwidth(healthtext); g2.drawstring(healthtext, healthx, y); // silah string weapontext = ""weapon: ""; switch(gp.player.currentweaponindex) { case 0: weapontext += ""pistol""; break; case 1: weapontext += ""rifle""; break; case 2: weapontext += ""shotgun""; break; case 3: weapontext += ""sniper""; break; case 4: weapontext += ""rocket""; break; } g2.drawstring(weapontext, x, y + 25); // mevcut faz string phasetext = ""phase: "" + (gp.currentphase + 1); int phasex = x + width - g2.getfontmetrics().stringwidth(phasetext); g2.drawstring(phasetext, phasex, y + 25); } private void drawmenuoption(string text, int x, int y, int width, boolean selected) { int itemheight = gp.tilesize/2; int textx = gp.screenwidth/2 - g2.getfontmetrics().stringwidth(text)/2; // seçili öğe için arka plan if(selected) { // kırmızı gradyan arka plan gradientpaint optiongradient = new gradientpaint( x + gp.tilesize, y - itemheight/2, new color(120, 20, 20, 200), x + gp.tilesize, y + itemheight/2, new color(180, 30, 30, 200) ); g2.setpaint(optiongradient); g2.fillroundrect(x + gp.tilesize/2, y - itemheight/2, width - gp.tilesize, itemheight, 15, 15); // seçim işaretçisi (üçgen) g2.setcolor(new color(255, 255, 255)); g2.fillpolygon( new int[]{x + gp.tilesize/2 - 5, x + gp.tilesize/2 - 15, x + gp.tilesize/2 - 5}, new int[]{y - 8, y, y + 8}, 3 ); g2.setcolor(new color(255, 255, 255)); } else { g2.setcolor(new color(200, 200, 200)); } // menü metni g2.drawstring(text, textx, y + gp.tilesize/6 - 1); } public void drawzombiecounter() { // zombi sayacı için konum ve boyut int x = gp.tilesize/2; int y = gp.tilesize*2 - gp.tilesize/4; int width = gp.tilesize*4; int height = (int)(gp.tilesize*0.8); // arka plan paneli g2.setcolor(new color(40, 0, 0, 180)); g2.fillroundrect(x, y, width, height, 15, 15); // panel kenarı g2.setcolor(new color(120, 20, 20, 150)); g2.setstroke(new basicstroke(2)); g2.drawroundrect(x, y, width, height, 15, 15); // zombi ikonu (basit bir zombi kafa silüeti) g2.setcolor(new color(50, 150, 50)); // zombi yeşili int iconsize = (int)(height * 0.6); int iconx = x + 10; // hayatta kalan zombi sayısı int remainingzombies = 0; for(int i = 0; i < gp.monsters.size(); i++) { if(gp.monsters.get(i) != null) { remainingzombies++; } } // zombi sayısı metni g2.setfont(new font(""arial"", font.bold, 18)); g2.setcolor(color.white); string zombietext = ""zombies: "" + remainingzombies; g2.drawstring(zombietext, iconx + iconsize + 15, y + height/2 + 6); // eğer faz bitmiş ve yeni zombiler gelecekse uyarı işareti ekle if(gp.phasefinished && !gp.phasefinishdraw) { g2.setfont(new font(""arial"", font.bold, 14)); g2.setcolor(new color(255, 200, 0)); string warningtext = ""next wave coming!""; g2.drawstring(warningtext, x + 10, y + height + 20); } } } package bil211game2.game.main; import java.awt.rectangle; public class eventrect extends rectangle{ int eventrectdefaultx, eventrectdefaulty; boolean eventdone = false; } package bil211game2.game.main; import java.io.serializable; import java.util.arraylist; public class gamesavedata implements serializable{ public int playerx; public int playery; public int playerlife; public int playerscore; public arraylist<integer> monstersx = new arraylist<>(); public arraylist<integer> monstersy = new arraylist<>(); public arraylist<integer> monsterslife = new arraylist<>(); public arraylist<string> monsterstype = new arraylist<>(); public arraylist<integer> ammosx = new arraylist<>(); public arraylist<integer> ammosy = new arraylist<>(); public arraylist<integer> ammosxspeed = new arraylist<>(); public arraylist<integer> ammosyspeed = new arraylist<>(); public arraylist<string> ammostypes = new arraylist<>(); public int[] weaponsammo = new int[5]; public int[] weaponsmagazineammo = new int[5]; public int gamephase; public int normalzombiechance, reptilezombiechance, tankzombiechance, acidzombiechance; } package bil211game2.game.main; import java.util.random; import bil211game2.game.entity.acidzombie; import bil211game2.game.entity.monster; import bil211game2.game.entity.normalzombie; import bil211game2.game.entity.reptilezombie; import bil211game2.game.entity.tankzombie; public class assetsetter{ gamepanel gp; int normalzombiechance = 100; int reptilezombiechance = 0; int tankzombiechance = 0; int acidzombiechance = 0; public assetsetter(gamepanel gp){ this.gp = gp; } public void setmonster(){ gp.monsters.add(0, new normalzombie(gp)); gp.monsters.get(0).worldx = gp.tilesize*23; gp.monsters.get(0).worldy = gp.tilesize*36; gp.monsters.add(1, new normalzombie(gp)); gp.monsters.get(1).worldx = gp.tilesize*27; gp.monsters.get(1).worldy = gp.tilesize*20; gp.monsters.add(2, new normalzombie(gp)); gp.monsters.get(2).worldx = gp.tilesize*29; gp.monsters.get(2).worldy = gp.tilesize*20; gp.monsters.add(3, new normalzombie(gp)); gp.monsters.get(3).worldx = gp.tilesize*25; gp.monsters.get(3).worldy = gp.tilesize*20; gp.monsters.add(4, new reptilezombie(gp)); gp.monsters.get(4).worldx = gp.tilesize*27; gp.monsters.get(4).worldy = gp.tilesize*23; gp.monsters.add(5, new reptilezombie(gp)); gp.monsters.get(5).worldx = gp.tilesize*27; gp.monsters.get(5).worldy = gp.tilesize*26; gp.monsters.add(6, new tankzombie(gp)); gp.monsters.get(6).worldx = gp.tilesize*27; gp.monsters.get(6).worldy = gp.tilesize*17; gp.monsters.add(7, new tankzombie(gp)); gp.monsters.get(7).worldx = gp.tilesize*15; gp.monsters.get(7).worldy = gp.tilesize*14; gp.monsters.add(8, new tankzombie(gp)); gp.monsters.get(8).worldx = gp.tilesize*18; gp.monsters.get(8).worldy = gp.tilesize*18; gp.monsters.add(9, new tankzombie(gp)); gp.monsters.get(9).worldx = gp.tilesize*30; gp.monsters.get(9).worldy = gp.tilesize*30; gp.monsters.add(10, new acidzombie(gp)); gp.monsters.get(10).worldx = gp.tilesize*31; gp.monsters.get(10).worldy = gp.tilesize*31; gp.monsters.add(11, new acidzombie(gp)); gp.monsters.get(11).worldx = gp.tilesize*40; gp.monsters.get(11).worldy = gp.tilesize*40; } public void setmonsterbyphase(){ if(gp.gamestate == gp.playstate){ random random = new random(); if(gp.currentphase == gp.phase1 || gp.currentphase == gp.phase2){ normalzombiechance -= 10; reptilezombiechance += 10; } else if(gp.currentphase == gp.phase3 || gp.currentphase == gp.phase4){ normalzombiechance -= 10; tankzombiechance += 10; } else if(gp.currentphase == gp.phase5 || gp.currentphase == gp.phase6){ normalzombiechance -= 5; acidzombiechance += 5; } else if(gp.currentphase == gp.phase7 || gp.currentphase == gp.phase8){ normalzombiechance -= 10; reptilezombiechance += 3; tankzombiechance += 3; acidzombiechance += 4; } for(int i = 0; i < (gp.currentphase+1)*3; i++){ int chance = random.nextint(101); if(chance < normalzombiechance){ normalzombie normalzombie = new normalzombie(gp); monstercreator(normalzombie); } else if(chance < normalzombiechance + reptilezombiechance){ reptilezombie reptilezombie = new reptilezombie(gp); monstercreator(reptilezombie); } else if(chance < normalzombiechance + reptilezombiechance + tankzombiechance){ tankzombie tankzombie = new tankzombie(gp); monstercreator(tankzombie); } else{ acidzombie acidzombie = new acidzombie(gp); monstercreator(acidzombie); } } gp.phasefinished = false; } } public void monstercreator(monster monster){ if(gp.gamestate == gp.playstate){ int x = 0; int y = 0; random random = new random(); boolean validposition = false; while(!validposition){ x = random.nextint(gp.maxworldcol); y = random.nextint(gp.maxworldrow); // harita sınırları içinde mi kontrolü // çarpışma olmayan bir karo mu? if(!gp.tilem.tiles[gp.tilem.maptilenum[x][y]].collision){ double distance = utilitytool.distancecalculator(x*gp.tilesize, y*gp.tilesize, gp.player.worldx, gp.player.worldy); if(distance > 3*gp.tilesize){ // oyuncudan en az 3 karo uzakta olsun boolean positionfree = true; // mevcut monster listesi üzerinde güvenli yineleme for(int i = 0; i < gp.monsters.size(); i++){ monster monstertemp = gp.monsters.get(i); if(monstertemp != null && monstertemp.worldx/gp.tilesize == x && monstertemp.worldy/gp.tilesize == y){ positionfree = false; break; } } if(positionfree){ validposition = true; } } } } monster.worldx = x*gp.tilesize; monster.worldy = y*gp.tilesize; gp.monsters.add(monster); } } public void resetchances(){ normalzombiechance = 100; reptilezombiechance = 0; tankzombiechance = 0; acidzombiechance = 0; } public void loadchances(int normalzombiechance, int reptilezombiechance, int tankzombiechance, int acidzombiechance){ this.normalzombiechance = normalzombiechance; this.reptilezombiechance = reptilezombiechance; this.tankzombiechance = tankzombiechance; this.acidzombiechance = acidzombiechance; } } package bil211game2.game.main; import java.awt.event.keyevent; import java.awt.event.keylistener; public class keyhandler implements keylistener{ public boolean uppressed, downpressed, leftpressed, rightpressed, rpressed, escpressed, hpressed; gamepanel gp; public keyhandler(gamepanel gp){ this.gp = gp; } @override public void keytyped(keyevent e) { } @override public void keypressed(keyevent e){ int code = e.getkeycode(); if(gp.gamestate == gp.playstate){ if(code == keyevent.vk_w){ uppressed = true; } if(code == keyevent.vk_s){ downpressed = true; } if(code == keyevent.vk_a){ leftpressed = true; } if(code == keyevent.vk_d){ rightpressed = true; } if(code == keyevent.vk_p){ gp.gamestate = gp.pausestate; } if(code == keyevent.vk_r){ rpressed = true; } if(code == keyevent.vk_escape){ escpressed = true; } if(code == keyevent.vk_1){ gp.player.changeweapon(0); } if(code == keyevent.vk_2){ gp.player.changeweapon(1); } if(code == keyevent.vk_3){ gp.player.changeweapon(2); } if(code == keyevent.vk_4){ gp.player.changeweapon(3); } if(code == keyevent.vk_5){ gp.player.changeweapon(4); } if(code == keyevent.vk_r){ gp.player.weapons[gp.player.currentweaponindex].reload(); } if(code == keyevent.vk_t){ gp.drawfps = !gp.drawfps; } if(code == keyevent.vk_h){ hpressed = true; } if(code == keyevent.vk_l){ gp.tilem.loadmap(""/bil211game2/resources/maps/apocalypseworld_1.txt""); } } else if(gp.gamestate == gp.pausestate){ if(code == keyevent.vk_p){ gp.gamestate = gp.playstate; } if(code == keyevent.vk_w){ gp.ui.pausecommandnum--; if(gp.ui.pausecommandnum < 0){ gp.ui.pausecommandnum = 2; } } if(code == keyevent.vk_s){ gp.ui.pausecommandnum++; if(gp.ui.pausecommandnum > 2){ gp.ui.pausecommandnum = 0; } } if(code == keyevent.vk_enter){ if(gp.ui.pausecommandnum == 0){ gp.gamestate = gp.playstate; } else if(gp.ui.pausecommandnum == 1){ gp.savegame(); } else{ gp.resetgame(); gp.gamestate = gp.titlestate; gp.stopmusic(); gp.playmusic(sound.title_screen_music); } } } else if(gp.gamestate == gp.titlestate){ if(code == keyevent.vk_w){ gp.ui.commandnum--; if(gp.ui.commandnum < 0){ gp.ui.commandnum = 3; } } if(code == keyevent.vk_s){ gp.ui.commandnum++; if(gp.ui.commandnum > 3){ gp.ui.commandnum = 0; } } if(code == keyevent.vk_enter){ gp.ui.menuselect(); } } else if(gp.gamestate == gp.finishstate){ if(code == keyevent.vk_enter){ gp.resetgame(); gp.gamestate = gp.titlestate; gp.stopmusic(); gp.playmusic(sound.title_screen_music); } } } @override public void keyreleased(keyevent e) { int code = e.getkeycode(); if(code == keyevent.vk_w){ uppressed = false; } if(code == keyevent.vk_s){ downpressed = false; } if(code == keyevent.vk_a){ leftpressed = false; } if(code == keyevent.vk_d){ rightpressed = false; } if(code == keyevent.vk_p){} if(code == keyevent.vk_r){ rpressed = false; } if(code == keyevent.vk_escape){ escpressed = false; } if(code == keyevent.vk_h){ hpressed = false; } } } package bil211game2.game.main; import java.awt.image.bufferedimage; import java.io.ioexception; import javax.imageio.imageio; import javax.swing.jframe; public class game { public static void main(string[] args) { jframe window = new jframe(); window.setdefaultcloseoperation(jframe.exit_on_close); window.setresizable(false); window.settitle(""zombie apocalypse""); try { bufferedimage icon = imageio.read( game.class.getresourceasstream (""/bil211game2/resources/images/other/zombie poster/zombie-tileset---_0296_capa-297.png"")); window.seticonimage(icon); } catch (ioexception e) { e.printstacktrace(); } gamepanel gamepanel = new gamepanel(); window.add(gamepanel); window.pack(); window.setlocationrelativeto(null); window.setvisible(true); window.addwindowlistener(new java.awt.event.windowadapter() { @override public void windowclosing(java.awt.event.windowevent windowevent) { gamepanel.cleanupresources(); } }); gamepanel.setupaftervisible(); gamepanel.setupgame(); gamepanel.startgamethread(); } } /* * 4500 satir kod */ package bil211game2.game.main; import java.util.arraylist; import bil211game2.game.entity.entity; import bil211game2.game.objects.ammos.ammo; public class collisionchecker { gamepanel gp; public collisionchecker(gamepanel gp){ this.gp = gp; } public void checktile(entity entity){ int entityleftworldx = entity.worldx + entity.solidarea.x; int entityrightworldx = entity.worldx + entity.solidarea.x + entity.solidarea.width; int entitytopworldy = entity.worldy + entity.solidarea.y; int entitybottomworldy = entity.worldy + entity.solidarea.y + entity.solidarea.height; int entityleftcol = entityleftworldx/gp.tilesize; int entityrightcol = entityrightworldx/gp.tilesize; int entitytoprow = entitytopworldy/gp.tilesize; int entitybottomrow = entitybottomworldy/gp.tilesize; int tilenum1, tilenum2, tilenum3, tilenum4; switch(entity.direction){ case ""up"": entitytoprow = (entitytopworldy - entity.speed)/gp.tilesize; tilenum1 = gp.tilem.maptilenum[entityleftcol][entitytoprow]; tilenum2 = gp.tilem.maptilenum[entityrightcol][entitytoprow]; tilenum3 = gp.tilem.maptilesecondstage[entityleftcol][entitytoprow]; tilenum4 = gp.tilem.maptilesecondstage[entityrightcol][entitytoprow]; if(gp.tilem.tiles[tilenum1].collision||gp.tilem.tiles[tilenum2].collision ||gp.tilem.tiles[tilenum3 != 0 ? tilenum3 : 0].collision ||gp.tilem.tiles[tilenum4 != 0 ? tilenum3 : 0].collision){ entity.collisionon = true; } break; case ""down"": entitybottomrow = (entitybottomworldy + entity.speed)/gp.tilesize; tilenum1 = gp.tilem.maptilenum[entityleftcol][entitybottomrow]; tilenum2 = gp.tilem.maptilenum[entityrightcol][entitybottomrow]; tilenum3 = gp.tilem.maptilesecondstage[entityleftcol][entitybottomrow]; tilenum4 = gp.tilem.maptilesecondstage[entityrightcol][entitybottomrow]; if(gp.tilem.tiles[tilenum1].collision||gp.tilem.tiles[tilenum2].collision ||gp.tilem.tiles[tilenum3 != 0 ? tilenum3 : 0].collision ||gp.tilem.tiles[tilenum4 != 0 ? tilenum3 : 0].collision){ entity.collisionon = true; } break; case ""left"": entityleftcol = (entityleftworldx - entity.speed)/gp.tilesize; tilenum1 = gp.tilem.maptilenum[entityleftcol][entitytoprow]; tilenum2 = gp.tilem.maptilenum[entityleftcol][entitybottomrow]; tilenum3 = gp.tilem.maptilesecondstage[entityleftcol][entitytoprow]; tilenum4 = gp.tilem.maptilesecondstage[entityleftcol][entitybottomrow]; if(gp.tilem.tiles[tilenum1].collision||gp.tilem.tiles[tilenum2].collision ||gp.tilem.tiles[tilenum3 != 0 ? tilenum3 : 0].collision ||gp.tilem.tiles[tilenum4 != 0 ? tilenum3 : 0].collision){ entity.collisionon = true; } break; case ""right"": entityrightcol = (entityrightworldx + entity.speed)/gp.tilesize; tilenum1 = gp.tilem.maptilenum[entityrightcol][entitytoprow]; tilenum2 = gp.tilem.maptilenum[entityrightcol][entitybottomrow]; tilenum3 = gp.tilem.maptilesecondstage[entityrightcol][entitytoprow]; tilenum4 = gp.tilem.maptilesecondstage[entityrightcol][entitybottomrow]; if(gp.tilem.tiles[tilenum1].collision||gp.tilem.tiles[tilenum2].collision ||gp.tilem.tiles[tilenum3 != 0 ? tilenum3 : 0].collision ||gp.tilem.tiles[tilenum4 != 0 ? tilenum3 : 0].collision){ entity.collisionon = true; } break; } } public int checkentity(entity entity, arraylist<? extends entity> target){ int index = 999; for(int i = 0; i < target.size(); i++){ if(target.get(i) != null){ entity trgt = target.get(i); // get entity's solid area position entity.solidarea.x = entity.worldx + entity.solidarea.x; entity.solidarea.y = entity.worldy + entity.solidarea.y; // get the object's solid area position trgt.solidarea.x = trgt.worldx + trgt.solidarea.x; trgt.solidarea.y = trgt.worldy + trgt.solidarea.y; switch(entity.direction){ case ""up"": entity.solidarea.y -= entity.speed; break; case ""down"": entity.solidarea.y += entity.speed; break; case ""left"": entity.solidarea.x -= entity.speed; break; case ""right"": entity.solidarea.x += entity.speed; break; } if(entity.solidarea.intersects(trgt.solidarea)){ if(trgt != entity){ entity.collisionon = true; index = i; } } entity.solidarea.x = entity.solidareadefaultx; entity.solidarea.y = entity.solidareadefaulty; trgt.solidarea.x = trgt.solidareadefaultx; trgt.solidarea.y = trgt.solidareadefaulty; } } return index; } public boolean checkplayer(entity entity){ boolean contactplayer = false; if(gp.player != null){ // get entity's solid area position entity.solidarea.x = entity.worldx + entity.solidarea.x; entity.solidarea.y = entity.worldy + entity.solidarea.y; // get the object's solid area position gp.player.solidarea.x = gp.player.worldx + gp.player.solidarea.x; gp.player.solidarea.y = gp.player.worldy + gp.player.solidarea.y; switch(entity.direction){ case ""up"": entity.solidarea.y -= entity.speed; break; case ""down"": entity.solidarea.y += entity.speed; break; case ""left"": entity.solidarea.x -= entity.speed; break; case ""right"": entity.solidarea.x += entity.speed; break; } if(entity.solidarea.intersects(gp.player.solidarea)){ entity.collisionon = true; contactplayer = true; } entity.solidarea.x = entity.solidareadefaultx; entity.solidarea.y = entity.solidareadefaulty; gp.player.solidarea.x = gp.player.solidareadefaultx; gp.player.solidarea.y = gp.player.solidareadefaulty; } return contactplayer; } public boolean checkammo(ammo ammo, entity entity){ boolean collision = false; if(ammo == null || entity == null || entity.dying || !entity.alive || ammo.contact){ return false; } if(solidareacheck(ammo.worldx, ammo.worldy, ammo.solidareadefaultx, ammo.solidareadefaulty, entity.worldx+ entity.solidareadefaultx, entity.worldy + entity.solidareadefaulty, entity.solidarea.width, entity.solidarea.height, entity.direction, entity.speed)){ collision = true; } return collision; } public boolean solidareacheck(int o1x,int o1y,int o1width,int o1height,int o2x, int o2y,int o2width,int o2height, string direction, int speed){ boolean inside = false; int xincr = 0; int yincr = 0; switch(direction){ case ""up"": yincr = -speed; break; case ""down"": yincr = +speed; break; case ""left"": xincr = -speed; break; case ""right"": xincr = +speed; break; } int centerx = o1x + o1width/2; int centery = o1y + o1height/2; if(centerx > o2x + xincr && centerx < o2x + o2width + xincr && centery > o2y + yincr && centery < o2y + o2height + yincr){ inside = true; } return inside; } } package bil211game2.game.main; public class eventhandler { gamepanel gp; eventrect[][] eventrects; int previouseventx, previouseventy; boolean cantouchevent = true; public eventhandler(gamepanel gp){ this.gp = gp; eventrects = new eventrect[gp.maxworldcol][gp.maxworldrow]; int col = 0; int row = 0; while(col < gp.maxworldcol && row < gp.maxworldrow){ eventrects[col][row] = new eventrect(); eventrects[col][row].x = 27; eventrects[col][row].y = 22; eventrects[col][row].width = 2; eventrects[col][row].height = 2; eventrects[col][row].eventrectdefaultx = eventrects[col][row].x; eventrects[col][row].eventrectdefaulty = eventrects[col][row].y; col++; if(col == gp.maxworldcol){ row++; col = 0; } } } public void checkevent(){ int xdistance = math.abs(gp.player.worldx - previouseventx); int ydistance = math.abs(gp.player.worldy - previouseventy); int distance = (int)math.sqrt(ydistance*ydistance + xdistance*xdistance); if(distance > gp.tilesize){ cantouchevent = true; } if(cantouchevent){ if(hit(28, 22,""any"")){ damagepit(28,22); } else if(hit(26, 20,""any"")){ teleport(9,7); } } } public boolean hit(int col, int row, string reqdirection){ boolean hit = false; gp.player.solidarea.x = gp.player.worldx + gp.player.solidarea.x; gp.player.solidarea.y = gp.player.worldy + gp.player.solidarea.y; eventrects[col][row].x = col*gp.tilesize + eventrects[col][row].x; eventrects[col][row].y = row*gp.tilesize + eventrects[col][row].y; if(gp.player.solidarea.intersects(eventrects[col][row]) && !eventrects[col][row].eventdone){ if(gp.player.direction.contentequals(reqdirection) || reqdirection.contentequals(""any"")){ hit = true; previouseventx = gp.player.worldx; previouseventy = gp.player.worldy; } } gp.player.solidarea.x = gp.player.solidareadefaultx; gp.player.solidarea.y = gp.player.solidareadefaulty; eventrects[col][row].x = eventrects[col][row].eventrectdefaultx; eventrects[col][row].y = eventrects[col][row].eventrectdefaulty; return hit; } public void damagepit(int col, int row){ gp.player.life--; //eventrects[col][row].eventdone = true; cantouchevent = false; } public void teleport(int col, int row){ gp.player.worldx = col*gp.tilesize; gp.player.worldy = row*gp.tilesize; cantouchevent = false; } } package bil211game2.game.main; import java.awt.cursor; import java.awt.point; import java.awt.toolkit; import java.awt.event.mouseevent; import java.awt.event.mouselistener; import java.awt.event.mousemotionlistener; import java.awt.image.bufferedimage; import javax.imageio.imageio; public class mousehandler implements mouselistener, mousemotionlistener{ gamepanel gp; public mouseevent event; public boolean mouseleftpressed; public int mousex, mousey; private cursor customnormalcursor; private cursor customtargetcursor; public mousehandler(gamepanel gp){ this.gp = gp; try{ bufferedimage cursortargetimg = imageio.read(getclass().getresourceasstream(""/bil211game2/resources/images/ui/mouse/target.png"")); bufferedimage cursornormalimg = imageio.read(getclass().getresourceasstream(""/bil211game2/resources/images/ui/mouse/normal.png"")); point hotspottarget = new point(cursortargetimg.getwidth() / 2, cursortargetimg.getheight() / 2); point hotspotnormal = new point(cursornormalimg.getwidth() / 2, cursornormalimg.getheight() / 2); customtargetcursor = toolkit.getdefaulttoolkit().createcustomcursor( cursortargetimg, hotspottarget, ""target cursor""); customnormalcursor = toolkit.getdefaulttoolkit().createcustomcursor( cursornormalimg, hotspotnormal, ""game cursor""); } catch(exception e){ e.printstacktrace(); } } @override public void mouseclicked(mouseevent e) { } @override public void mousepressed(mouseevent e) { int code = e.getbutton(); if(code == mouseevent.button1){ mouseleftpressed = true; event = e; } } @override public void mousereleased(mouseevent e) { mouseleftpressed = false; } @override public void mouseentered(mouseevent e) { if(customnormalcursor == null || customtargetcursor == null){ gp.setcursor(new cursor(cursor.crosshair_cursor)); } else if(gp.gamestate == gp.playstate){ gp.setcursor(customtargetcursor); } else{ gp.setcursor(customnormalcursor); } } @override public void mouseexited(mouseevent e) { gp.setcursor(new cursor(cursor.default_cursor)); // varsayılana dön } @override public void mousedragged(mouseevent e) { // update current mouse position while dragging if(mouseleftpressed) { mousex = e.getx(); mousey = e.gety(); event = e; // also update the event object } } @override public void mousemoved(mouseevent e) { // update current mouse position while moving mousex = e.getx(); mousey = e.gety(); } } package bil211game2.game.main.tile; import java.awt.image.bufferedimage; public class tile { public bufferedimage image; public boolean collision = false; } package bil211game2.game.main.tile; import java.awt.graphics2d; import java.io.bufferedreader; import java.io.ioexception; import java.io.inputstream; import java.io.inputstreamreader; import java.util.random; import javax.imageio.imageio; import bil211game2.game.main.gamepanel; import bil211game2.game.main.utilitytool; public class tilemanager { gamepanel gp; public tile[] tiles; public int[][] maptilenum; public int[][] maptilesecondstage; public tilemanager(gamepanel gp){ this.gp = gp; tiles = new tile[160]; maptilenum = new int[gp.maxworldcol][gp.maxworldrow]; maptilesecondstage = new int[gp.maxworldcol][gp.maxworldrow]; gettileimage(); //loadmap(""/bil211game2/resources/maps/grassland1.txt""); loadmap(""/bil211game2/resources/maps/apocalypseworld_1.txt""); } public void loadmap(string filepath){ try(inputstream in = getclass().getresourceasstream(filepath); bufferedreader br = new bufferedreader(new inputstreamreader(in))){ random random = new random(); int col = 0; int row = 0; while(col < gp.maxscreencol && row < gp.maxworldrow){ string line = br.readline(); while(col < gp.maxworldcol){ string[] numbers = line.split("" ""); int num = 0; if(integer.parseint(numbers[col]) == 0){ boolean flag = random.nextboolean(); if(flag){ int type = random.nextint(3); num = type + 1; } else{ num = integer.parseint(numbers[col]); } maptilesecondstage[col][row] = 0; } else if(integer.parseint(numbers[col]) == 148){ int type = random.nextint(3); num = type + 148; maptilesecondstage[col][row] = 0; } else{ boolean flag = random.nextboolean(); if(flag){ int type = random.nextint(3); num = type + 1; } else{ num = integer.parseint(numbers[col]); } maptilesecondstage[col][row] = integer.parseint(numbers[col]); } maptilenum[col][row] = num; col++; } if(col == gp.maxworldcol){ col =0; row++; } } } catch(exception e){ e.printstacktrace(); } } public void gettileimage(){ // terrains setupnew(0, ""terrain variations/zombie-tileset---_0077_capa-78"", false); setupnew(1, ""terrain variations/zombie-tileset---_0078_capa-79"", false); setupnew(2, ""terrain variations/zombie-tileset---_0079_capa-80"", false); setupnew(3, ""terrain variations/zombie-tileset---_0080_capa-81"", false); // terrain roads for(int i = 0; i < 12; i++){ setupnew(i+4, ""modular terrain path/zombie-tileset---_00""+(i+65)+""_capa-""+(i+66), false); } // terrain wall - vertical setupnew(16, ""terrain wall/zombie-tileset---_0064_capa-65"", true); // modular road for(int i = 0; i < 26; i++){ setupnew(i+17, ""modular road/zombie-tileset---_00""+(i+29)+""_capa-""+(i+30), false); } // small building for(int i = 0; i < 8; i++){ setupnew(i+43, ""modular small building/zombie-tileset---_00""+(i+91)+""_capa-""+(i+92), true); } setupnew(52, ""modular small building/zombie-tileset---_0099_capa-100"", true); for(int i = 0; i < 6; i++){ setupnew(i+53, ""modular small building/zombie-tileset---_0""+(i+100)+""_capa-""+(i+101), true); } // modular fences for(int i = 0; i < 8; i++){ setupnew(i+59, ""modular fences/zombie-tileset---_0""+(i+126)+""_capa-""+(i+127), true); } for(int i = 0; i < 23; i++){ setupnew(i+67, ""modular fences/zombie-tileset---_0""+(i+194)+""_capa-""+(i+195), true); } // modular barns for(int i = 0; i < 58; i++){ setupnew(i+90, ""modular barns/zombie-tileset---_0""+(i+226)+""_capa-""+(i+227), true); } // water animation frames setupnew(148, ""water animation frames/zombie-tileset---_0061_capa-62"", true); setupnew(149, ""water animation frames/zombie-tileset---_0062_capa-63"", true); setupnew(150, ""water animation frames/zombie-tileset---_0063_capa-64"", true); // tractor setupnew(151, ""tractor/zombie-tileset---_0172_capa-173"", true); setupnew(152, ""tractor/zombie-tileset---_0173_capa-174"", true); setupnew(153, ""tractor/zombie-tileset---_0174_capa-175"", true); setupnew(154, ""tractor/zombie-tileset---_0175_capa-176"", true); } public void setup(int index, string imagename, boolean collision){ try{ tiles[index] = new tile(); tiles[index].image = imageio.read(getclass().getresourceasstream(""/bil211game/resources/tiles/""+ imagename +"".png"")); tiles[index].image = utilitytool.scaleimage(tiles[index].image, gp.tilesize, gp.tilesize); tiles[index].collision = collision; } catch(ioexception e){ e.printstacktrace(); } } public void setupnew(int index, string imagename, boolean collision){ try{ tiles[index] = new tile(); tiles[index].image = imageio.read(getclass().getresourceasstream(""/bil211game2/resources/images/tiles/""+ imagename +"".png"")); tiles[index].image = utilitytool.scaleimage(tiles[index].image, gp.tilesize, gp.tilesize); tiles[index].collision = collision; } catch(ioexception e){ e.printstacktrace(); } } public void draw(graphics2d g2){ int worldcol = 0; int worldrow = 0; while(worldcol < gp.maxworldcol && worldrow < gp.maxworldrow){ int tilenum = maptilenum[worldcol][worldrow]; int worldx = worldcol * gp.tilesize; int worldy = worldrow * gp.tilesize; int screenx = worldx - gp.player.worldx + gp.player.screenx; int screeny = worldy - gp.player.worldy + gp.player.screeny; if(worldx + gp.tilesize > gp.player.worldx - gp.player.screenx && worldx - gp.tilesize < gp.player.worldx + gp.player.screenx && worldy + gp.tilesize > gp.player.worldy - gp.player.screeny && worldy - gp.tilesize < gp.player.worldy + gp.player.screeny){ g2.drawimage(tiles[tilenum].image, screenx, screeny, null); } worldcol++; if(worldcol == gp.maxworldcol){ worldcol = 0; worldrow++; } } worldcol = 0; worldrow = 0; while(worldcol < gp.maxworldcol && worldrow < gp.maxworldrow){ int tilenum = maptilesecondstage[worldcol][worldrow]; int worldx = worldcol * gp.tilesize; int worldy = worldrow * gp.tilesize; int screenx = worldx - gp.player.worldx + gp.player.screenx; int screeny = worldy - gp.player.worldy + gp.player.screeny; if(tilenum != 0 && worldx + gp.tilesize > gp.player.worldx - gp.player.screenx && worldx - gp.tilesize < gp.player.worldx + gp.player.screenx && worldy + gp.tilesize > gp.player.worldy - gp.player.screeny && worldy - gp.tilesize < gp.player.worldy + gp.player.screeny){ g2.drawimage(tiles[0].image, screenx, screeny, null); g2.drawimage(tiles[tilenum].image, screenx, screeny, null); } worldcol++; if(worldcol == gp.maxworldcol){ worldcol = 0; worldrow++; } } } } package bil211game2.game.objects.others; import bil211game2.game.entity.entity; import bil211game2.game.main.gamepanel; public class obj_hearth extends entity{ public obj_hearth(gamepanel gp){ super(gp); name = ""heart""; image = setupnew(""other/hearts/heart_full"", gp.tilesize, gp.tilesize); image2 = setupnew(""other/hearts/heart_half"", gp.tilesize, gp.tilesize); image3 = setupnew(""other/hearts/heart_blank"", gp.tilesize, gp.tilesize); } } package bil211game2.game.objects.weapons; import bil211game2.game.main.gamepanel; import bil211game2.game.main.sound; import bil211game2.game.objects.ammos.sniperammo; public class sniper extends weapon{ public sniper(gamepanel gp) { super(gp); attack = 5; magazinesize = 5; magazineammo = magazinesize; firerate = 30; ammo = 2*magazinesize; } @override public void fire(int x, int y) { if(magazineammo <= 0) return; sniperammo pistolammo = new sniperammo(gp); int playerx = gp.player.worldx; int playery = gp.player.worldy; // mermi başlangıç pozisyonunu hesapla int ammox, ammoy; // yöne bağlı olarak mermi çıkış noktasını ayarla switch(gp.player.direction) { case ""up"": ammox = playerx + gp.tilesize/2; ammoy = playery - gp.tilesize/2; break; case ""down"": ammox = playerx + gp.tilesize/2; ammoy = playery + gp.tilesize + gp.tilesize/2; break; case ""left"": ammox = playerx - gp.tilesize/2; ammoy = playery + gp.tilesize/2; break; case ""right"": ammox = playerx + gp.tilesize; ammoy = playery + gp.tilesize/2; break; default: ammox = playerx + gp.tilesize/2; ammoy = playery + gp.tilesize/2; break; } pistolammo.worldx = ammox; pistolammo.worldy = ammoy; // hasarı ayarla pistolammo.attack = attack; // oyuncuya doğru açıyı hesapla pistolammo.rad = math.atan2(y - ammoy, x - ammox); // açıya göre hızı hesapla pistolammo.speedy = (int)(sniperammo.defaultspeed*math.sin(pistolammo.rad)); pistolammo.speedx = (int)(sniperammo.defaultspeed*math.cos(pistolammo.rad)); // çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan pistolammo.setupsolidarea(gp.tilesize/2, gp.tilesize/2); pistolammo.speedhandler(); // shoot gp.ammos.add(pistolammo); magazineammo--; gp.playse(sound.sniper_sound); } @override public void reload() { if(ammo >= magazinesize - magazineammo){ ammo -= magazinesize - magazineammo; magazineammo = magazinesize; } else{ magazineammo += ammo; ammo = 0; } } } package bil211game2.game.objects.weapons; import java.io.serializable; import bil211game2.game.main.gamepanel; public abstract class weapon implements serializable{ public int ammo = 0; int attack = 0; public int magazinesize = 0; public int magazineammo = 0; public int firerate = 0; gamepanel gp; public weapon(gamepanel gp){ this.gp = gp; } public abstract void fire(int x, int y); public abstract void reload(); } package bil211game2.game.objects.weapons; import bil211game2.game.main.gamepanel; import bil211game2.game.main.sound; import bil211game2.game.objects.ammos.shotgunammo; public class shotgun extends weapon{ public shotgun(gamepanel gp) { super(gp); attack = 2; magazinesize = 5; magazineammo = magazinesize; firerate = 60; ammo = 2*magazinesize; } @override public void fire(int x, int y) { if(magazineammo <= 0) return; for(int i = 0; i <= 4; i++){ shotgunammo pistolammo = new shotgunammo(gp); int playerx = gp.player.worldx; int playery = gp.player.worldy; // mermi başlangıç pozisyonunu hesapla int ammox, ammoy; // yöne bağlı olarak mermi çıkış noktasını ayarla switch(gp.player.direction) { case ""up"": ammox = playerx + gp.tilesize/2; ammoy = playery - gp.tilesize/2; break; case ""down"": ammox = playerx + gp.tilesize/2; ammoy = playery + gp.tilesize + gp.tilesize/2; break; case ""left"": ammox = playerx - gp.tilesize/2; ammoy = playery + gp.tilesize/2; break; case ""right"": ammox = playerx + gp.tilesize; ammoy = playery + gp.tilesize/2; break; default: ammox = playerx + gp.tilesize/2; ammoy = playery + gp.tilesize/2; break; } pistolammo.worldx = ammox; pistolammo.worldy = ammoy; // hasarı ayarla pistolammo.attack = attack; // oyuncuya doğru açıyı hesapla pistolammo.rad = math.atan2(y - ammoy, x - ammox); // açıya göre hızı hesapla pistolammo.speedy = (int)(shotgunammo.defaultspeed*math.sin(pistolammo.rad - math.toradians(5*i))); pistolammo.speedx = (int)(shotgunammo.defaultspeed*math.cos(pistolammo.rad - math.toradians(5*i))); // çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan pistolammo.setupsolidarea(gp.tilesize/2, gp.tilesize/2); pistolammo.speedhandler(); // shoot gp.ammos.add(pistolammo); } for(int i = 1; i <= 4; i++){ shotgunammo pistolammo = new shotgunammo(gp); int playerx = gp.player.worldx; int playery = gp.player.worldy; // mermi başlangıç pozisyonunu hesapla int ammox, ammoy; // yöne bağlı olarak mermi çıkış noktasını ayarla switch(gp.player.direction) { case ""up"": ammox = playerx + gp.tilesize/2; ammoy = playery - gp.tilesize/2; break; case ""down"": ammox = playerx + gp.tilesize/2; ammoy = playery + gp.tilesize + gp.tilesize/2; break; case ""left"": ammox = playerx - gp.tilesize/2; ammoy = playery + gp.tilesize/2; break; case ""right"": ammox = playerx + gp.tilesize; ammoy = playery + gp.tilesize/2; break; default: ammox = playerx + gp.tilesize/2; ammoy = playery + gp.tilesize/2; break; } pistolammo.worldx = ammox; pistolammo.worldy = ammoy; // hasarı ayarla pistolammo.attack = attack; // oyuncuya doğru açıyı hesapla pistolammo.rad = math.atan2(y - ammoy, x - ammox); // açıya göre hızı hesapla pistolammo.speedy = (int)(shotgunammo.defaultspeed*math.sin(pistolammo.rad + math.toradians(5*i))); pistolammo.speedx = (int)(shotgunammo.defaultspeed*math.cos(pistolammo.rad + math.toradians(5*i))); // çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan pistolammo.setupsolidarea(gp.tilesize/2, gp.tilesize/2); pistolammo.speedhandler(); // shoot gp.ammos.add(pistolammo); } magazineammo--; gp.playse(sound.shotgun_sound); } @override public void reload() { if(ammo >= magazinesize - magazineammo){ ammo -= magazinesize - magazineammo; magazineammo = magazinesize; } else{ magazineammo += ammo; ammo = 0; } } } package bil211game2.game.objects.weapons; import bil211game2.game.main.gamepanel; import bil211game2.game.main.sound; import bil211game2.game.objects.ammos.pistolammo; public class pistol extends weapon{ public pistol(gamepanel gp) { super(gp); attack = 1; magazinesize = 12; magazineammo = magazinesize; firerate = 120; } @override public void fire(int x, int y) { if(magazineammo <= 0) return; pistolammo pistolammo = new pistolammo(gp); int playerx = gp.player.worldx; int playery = gp.player.worldy; // mermi başlangıç pozisyonunu hesapla int ammox, ammoy; // yöne bağlı olarak mermi çıkış noktasını ayarla switch(gp.player.direction) { case ""up"": ammox = playerx + gp.tilesize/2; ammoy = playery - gp.tilesize/2; break; case ""down"": ammox = playerx + gp.tilesize/2; ammoy = playery + gp.tilesize + gp.tilesize/2; break; case ""left"": ammox = playerx - gp.tilesize/2; ammoy = playery + gp.tilesize/2; break; case ""right"": ammox = playerx + gp.tilesize; ammoy = playery + gp.tilesize/2; break; default: ammox = playerx + gp.tilesize/2; ammoy = playery + gp.tilesize/2; break; } pistolammo.worldx = ammox; pistolammo.worldy = ammoy; // hasarı ayarla pistolammo.attack = attack; // oyuncuya doğru açıyı hesapla pistolammo.rad = math.atan2(y - ammoy, x - ammox); // açıya göre hızı hesapla pistolammo.speedy = (int)(pistolammo.defaultspeed*math.sin(pistolammo.rad)); pistolammo.speedx = (int)(pistolammo.defaultspeed*math.cos(pistolammo.rad)); // çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan pistolammo.setupsolidarea(gp.tilesize/2, gp.tilesize/2); pistolammo.speedhandler(); // shoot gp.ammos.add(pistolammo); magazineammo--; gp.playse(sound.pistol_sound); } @override public void reload() { magazineammo = magazinesize; } } package bil211game2.game.objects.weapons; import java.util.random; import bil211game2.game.main.gamepanel; import bil211game2.game.main.sound; import bil211game2.game.objects.ammos.rifleammo; public class rifle extends weapon{ random random; public rifle(gamepanel gp) { super(gp); attack = 2; random = new random(); magazinesize = 30; magazineammo = magazinesize; firerate = 600; ammo = 2*magazinesize; } @override public void fire(int x, int y) { if(magazineammo <= 0) return; rifleammo pistolammo = new rifleammo(gp); int playerx = gp.player.worldx; int playery = gp.player.worldy; int sapma = random.nextint(15); boolean flag = random.nextboolean(); if(flag){ sapma = (-1)*sapma; } // mermi başlangıç pozisyonunu hesapla int ammox, ammoy; // yöne bağlı olarak mermi çıkış noktasını ayarla switch(gp.player.direction) { case ""up"": ammox = playerx + gp.tilesize/2; ammoy = playery - gp.tilesize/2; break; case ""down"": ammox = playerx + gp.tilesize/2; ammoy = playery + gp.tilesize + gp.tilesize/2; break; case ""left"": ammox = playerx - gp.tilesize/2; ammoy = playery + gp.tilesize/2; break; case ""right"": ammox = playerx + gp.tilesize; ammoy = playery + gp.tilesize/2; break; default: ammox = playerx + gp.tilesize/2; ammoy = playery + gp.tilesize/2; break; } pistolammo.worldx = ammox; pistolammo.worldy = ammoy; // hasarı ayarla pistolammo.attack = attack; // oyuncuya doğru açıyı hesapla pistolammo.rad = math.atan2(y - ammoy, x - ammox); // açıya göre hızı hesapla pistolammo.speedy = (int)(rifleammo.defaultspeed*math.sin(pistolammo.rad + math.toradians(sapma))); pistolammo.speedx = (int)(rifleammo.defaultspeed*math.cos(pistolammo.rad + math.toradians(sapma))); // çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan pistolammo.setupsolidarea(gp.tilesize/2, gp.tilesize/2); pistolammo.speedhandler(); // shoot gp.ammos.add(pistolammo); magazineammo--; gp.playse(sound.rifle_sound); } @override public void reload() { if(ammo >= magazinesize - magazineammo){ ammo -= magazinesize - magazineammo; magazineammo = magazinesize; } else{ magazineammo += ammo; ammo = 0; } } } package bil211game2.game.objects.weapons; import bil211game2.game.main.gamepanel; import bil211game2.game.main.sound; import bil211game2.game.objects.ammos.rocketammo; public class rocketlauncher extends weapon{ public rocketlauncher(gamepanel gp) { super(gp); attack = 10; magazinesize = 1; magazineammo = magazinesize; firerate = 10; ammo = 2*magazinesize; } @override public void fire(int x, int y) { if(magazineammo <= 0) return; rocketammo pistolammo = new rocketammo(gp); int playerx = gp.player.worldx; int playery = gp.player.worldy; // mermi başlangıç pozisyonunu hesapla int ammox, ammoy; // yöne bağlı olarak mermi çıkış noktasını ayarla switch(gp.player.direction) { case ""up"": ammox = playerx + gp.tilesize/2; ammoy = playery - gp.tilesize/2; break; case ""down"": ammox = playerx + gp.tilesize/2; ammoy = playery + gp.tilesize + gp.tilesize/2; break; case ""left"": ammox = playerx - gp.tilesize/2; ammoy = playery + gp.tilesize/2; break; case ""right"": ammox = playerx + gp.tilesize; ammoy = playery + gp.tilesize/2; break; default: ammox = playerx + gp.tilesize/2; ammoy = playery + gp.tilesize/2; break; } pistolammo.worldx = ammox; pistolammo.worldy = ammoy; // hasarı ayarla pistolammo.attack = attack; // oyuncuya doğru açıyı hesapla pistolammo.rad = math.atan2(y - ammoy, x - ammox); // açıya göre hızı hesapla pistolammo.speedy = (int)(rocketammo.defaultspeed*math.sin(pistolammo.rad)); pistolammo.speedx = (int)(rocketammo.defaultspeed*math.cos(pistolammo.rad)); // çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan pistolammo.setupsolidarea(gp.tilesize/2, gp.tilesize/2); pistolammo.speedhandler(); // shoot gp.ammos.add(pistolammo); magazineammo--; gp.playse(sound.rocket_sound); } @override public void reload() { if(ammo >= magazinesize - magazineammo){ ammo -= magazinesize - magazineammo; magazineammo = magazinesize; } else{ magazineammo += ammo; ammo = 0; } } } package bil211game2.game.objects.animations; import java.awt.alphacomposite; import java.awt.color; import java.awt.graphics2d; import java.awt.image.bufferedimage; import java.io.ioexception; import javax.imageio.imageio; import bil211game2.game.main.gamepanel; import bil211game2.game.main.utilitytool; public class bloodsplashanimation extends animation { public bloodsplashanimation(gamepanel gp, int worldx, int worldy) { super(gp, worldx, worldy, gp.tilesize); // kan sıçraması boyutu lifespan = 5; // 5 karelik animasyon delay = 3; // her 3 update döngüsünde bir kare değişecek frames = new bufferedimage[lifespan]; // kan sıçrama karelerini yükle loadanimationframes(); } private void loadanimationframes() { // mevcut explosion animasyonunu kan efekti için kullanabiliriz // daha sonra özel kan görselleri eklenebilir frames[0] = setupimage(""zombie-tileset---_0379_capa-380""); frames[1] = setupimage(""zombie-tileset---_0380_capa-381""); frames[2] = setupimage(""zombie-tileset---_0381_capa-382""); frames[3] = setupimage(""zombie-tileset---_0382_capa-383""); frames[4] = setupimage(""zombie-tileset---_0383_capa-384""); } @override public void draw(graphics2d g2) { // kan efekti için kırmızı renk tonu ayarla if (!finished && currentframe < frames.length) { float alpha = 0.8f; // son frame'lerde soluklaştır if (currentframe >= lifespan - 2) { alpha = (float) (lifespan - currentframe) / 2 * 0.8f; } // orijinal alpha değerini kaydet alphacomposite originalcomposite = (alphacomposite) g2.getcomposite(); // kırmızı renk tonu eklemek için g2.setcomposite(alphacomposite.getinstance(alphacomposite.src_over, alpha)); // kırmızı overlay color originalcolor = g2.getcolor(); g2.setcolor(new color(180, 0, 0, 100)); // önce orijinal frame'i çiz int screenx = worldx - gp.player.worldx + gp.player.screenx - size/2 + gp.tilesize/2; int screeny = worldy - gp.player.worldy + gp.player.screeny - size/2 + gp.tilesize/2; g2.drawimage(frames[currentframe], screenx, screeny, size, size, null); // kırmızı overlay ekle g2.filloval(screenx, screeny, size, size); // renk ve alpha değerlerini sıfırla g2.setcolor(originalcolor); g2.setcomposite(originalcomposite); } } protected bufferedimage setupimage(string imagepath) { bufferedimage image = null; try { image = imageio.read(getclass().getresourceasstream(""/bil211game2/resources/images/items/blood animation frames/"" + imagepath + "".png"")); image = utilitytool.scaleimage(image, size, size); } catch (ioexception e) { e.printstacktrace(); } return image; } } // asit sıçrama animasyonu package bil211game2.game.objects.animations; import java.awt.alphacomposite; import java.awt.graphics2d; import java.awt.image.bufferedimage; import bil211game2.game.main.gamepanel; public class acidsplashanimation extends animation { public acidsplashanimation(gamepanel gp, int worldx, int worldy) { super(gp, worldx, worldy, gp.tilesize * 5); // asit sıçraması daha geniş alana etki eder lifespan = 8; // 8 karelik animasyon delay = 2; // her 2 update döngüsünde bir kare değişecek frames = new bufferedimage[lifespan]; // asit sıçrama karelerini yükle loadanimationframes(); } private void loadanimationframes() { frames[0] = setupimage(""zombie-tileset---_0358_capa-359""); frames[1] = setupimage(""zombie-tileset---_0359_capa-360""); frames[2] = setupimage(""zombie-tileset---_0360_capa-361""); frames[3] = setupimage(""zombie-tileset---_0361_capa-362""); frames[4] = setupimage(""zombie-tileset---_0362_capa-363""); frames[5] = setupimage(""zombie-tileset---_0363_capa-364""); } @override public void draw(graphics2d g2) { // asit sıçrama efekti için renk ve alpha değerini ayarla if (!finished && currentframe < frames.length) { float alpha = 0.8f; // son üç karede saydamlaştır if (currentframe >= lifespan - 3) { alpha = (float) (lifespan - currentframe) / 3 * 0.8f; } // yeşil renk tonu eklemek için g2.setcomposite(alphacomposite.getinstance(alphacomposite.src_over, alpha)); // orijinal görüntüyü çiz super.draw(g2); // alpha değerini sıfırla g2.setcomposite(alphacomposite.getinstance(alphacomposite.src_over, 1.0f)); } } } package bil211game2.game.objects.animations; import java.awt.alphacomposite; import java.awt.graphics2d; import java.awt.image.bufferedimage; import bil211game2.game.main.gamepanel; public class explosionanimation extends animation { public explosionanimation(gamepanel gp, int worldx, int worldy) { super(gp, worldx, worldy, gp.tilesize * 3); // patlama boyutu normal tile'ın 3 katı lifespan = 6; // 6 karelik animasyon delay = 3; // her 3 update döngüsünde bir kare değişecek frames = new bufferedimage[lifespan]; // patlama karelerini yükle loadanimationframes(); } private void loadanimationframes() { frames[0] = setupimage(""zombie-tileset---_0358_capa-359""); frames[1] = setupimage(""zombie-tileset---_0359_capa-360""); frames[2] = setupimage(""zombie-tileset---_0360_capa-361""); frames[3] = setupimage(""zombie-tileset---_0361_capa-362""); frames[4] = setupimage(""zombie-tileset---_0362_capa-363""); frames[5] = setupimage(""zombie-tileset---_0363_capa-364""); } @override public void draw(graphics2d g2) { // patlama efekti için alpha değerini ayarla (sona doğru saydamlaşsın) if (!finished && currentframe < frames.length) { float alpha = 1.0f; // son iki karede saydamlaştır if (currentframe >= lifespan - 2) { alpha = (float) (lifespan - currentframe) / 2; } g2.setcomposite(alphacomposite.getinstance(alphacomposite.src_over, alpha)); super.draw(g2); g2.setcomposite(alphacomposite.getinstance(alphacomposite.src_over, 1.0f)); } } } package bil211game2.game.objects.animations; import java.awt.graphics2d; import java.util.arraylist; import java.util.iterator; import java.util.list; import bil211game2.game.main.gamepanel; public class animationmanager { private gamepanel gp; private list<animation> animations; public animationmanager(gamepanel gp) { this.gp = gp; animations = new arraylist<>(); } public void addexplosion(int worldx, int worldy) { animations.add(new explosionanimation(gp, worldx, worldy)); } public void addacidsplash(int worldx, int worldy) { animations.add(new acidsplashanimation(gp, worldx, worldy)); } public void addbloodsplash(int worldx, int worldy) { animations.add(new bloodsplashanimation(gp, worldx, worldy)); } public void update() { iterator<animation> iterator = animations.iterator(); while (iterator.hasnext()) { animation animation = iterator.next(); animation.update(); if (animation.isfinished()) { iterator.remove(); } } } public void draw(graphics2d g2) { for (animation animation : animations) { animation.draw(g2); } } } package bil211game2.game.objects.animations; import java.awt.graphics2d; import java.awt.image.bufferedimage; import java.io.ioexception; import javax.imageio.imageio; import bil211game2.game.main.gamepanel; import bil211game2.game.main.utilitytool; public class animation { protected gamepanel gp; protected int worldx, worldy; protected int lifespan; // animasyonun toplam kareleri protected int currentframe; protected boolean finished; protected bufferedimage[] frames; protected int delay; // her kare arasındaki gecikme (kaç update döngüsü) protected int delaycounter; protected int size; // animasyon boyutu public animation(gamepanel gp, int worldx, int worldy, int size) { this.gp = gp; this.worldx = worldx; this.worldy = worldy; this.size = size; currentframe = 0; delaycounter = 0; finished = false; } public void update() { delaycounter++; if (delaycounter >= delay) { currentframe++; delaycounter = 0; if (currentframe >= lifespan) { finished = true; } } } public void draw(graphics2d g2) { if (!finished && currentframe < frames.length) { int screenx = worldx - gp.player.worldx + gp.player.screenx; int screeny = worldy - gp.player.worldy + gp.player.screeny; // eğer ekranda görünüyorsa çiz if (worldx + size > gp.player.worldx - gp.player.screenx && worldx - size < gp.player.worldx + gp.player.screenx && worldy + size > gp.player.worldy - gp.player.screeny && worldy - size < gp.player.worldy + gp.player.screeny) { // animasyonun ortada olması için pozisyonu ayarla screenx -= size / 2; screeny -= size / 2; g2.drawimage(frames[currentframe], screenx, screeny, size, size, null); } } } public boolean isfinished() { return finished; } // yardımcı metot: görüntüleri ayarlamak için protected bufferedimage setupimage(string imagepath) { bufferedimage image = null; try { image = imageio.read(getclass().getresourceasstream(""/bil211game2/resources/images/items/explosion animation frames/"" + imagepath + "".png"")); image = utilitytool.scaleimage(image, size, size); } catch (ioexception e) { e.printstacktrace(); } return image; } } package bil211game2.game.objects.ammos; import bil211game2.game.main.gamepanel; public class acid extends ammo{ public static int defaultspeed = 10; public acid(gamepanel gp) { super(gp); solidarea.x = speedx > 0 ? -gp.tilesize/4 : gp.tilesize/4; solidarea.y = speedy > 0 ? -gp.tilesize/4 : gp.tilesize/4; solidarea.width = gp.tilesize/2; solidarea.height = gp.tilesize/2; // set default values explicitly solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; getimages(); setupsolidarea(solidarea.width, solidarea.height); } public void getimages(){ image = setupnew(""turret zombie vomit shooting animation frames/zombie-tileset---_0470_capa-471"", gp.tilesize/2, gp.tilesize/2); } } package bil211game2.game.objects.ammos; import bil211game2.game.main.gamepanel; public class sniperammo extends ammo{ public static int defaultspeed = 20; public sniperammo(gamepanel gp) { super(gp); solidarea.x = speedx > 0 ? -gp.tilesize/4 : gp.tilesize/4; solidarea.y = speedy > 0 ? -gp.tilesize/4 : gp.tilesize/4; solidarea.width = gp.tilesize/2; solidarea.height = gp.tilesize/2; // set default values explicitly solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; // set a longer lifespan for the acid projectile lifespan = 180; getimages(); setupsolidarea(solidarea.width, solidarea.height); } public void getimages(){ image = setupnew(""sniper"", gp.tilesize/4, gp.tilesize/2); } } package bil211game2.game.objects.ammos; import bil211game2.game.entity.entity; import bil211game2.game.main.gamepanel; import bil211game2.game.main.sound; import bil211game2.game.main.utilitytool; public class rocketammo extends ammo{ public static int defaultspeed = 10; public rocketammo(gamepanel gp) { super(gp); solidarea.x = speedx > 0 ? -gp.tilesize/4 : gp.tilesize/4; solidarea.y = speedy > 0 ? -gp.tilesize/4 : gp.tilesize/4; solidarea.width = gp.tilesize/2; solidarea.height = gp.tilesize/2; // set default values explicitly solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; // set a longer lifespan for the acid projectile lifespan = 180; getimages(); setupsolidarea(solidarea.width, solidarea.height); } public void getimages(){ image = setupnew(""rocket"", gp.tilesize, gp.tilesize); } @override public void additionalfeature(entity entity) { gp.animationmanager.addexplosion(worldx, worldy); for(int i = 0; i < gp.monsters.size(); i++){ if(gp.monsters.get(i) != null && utilitytool.distancecalculator(gp.monsters.get(i).worldx, gp.monsters.get(i).worldy, worldx, worldy) < 3 * gp.tilesize){ gp.monsters.get(i).shooted(attack); } } gp.startscreenshake(25, 30); gp.playse(sound.rocket_bang_sound); } } package bil211game2.game.objects.ammos; import bil211game2.game.main.gamepanel; public class rifleammo extends ammo{ public static int defaultspeed = 20; public rifleammo(gamepanel gp) { super(gp); solidarea.x = speedx > 0 ? -gp.tilesize/4 : gp.tilesize/4; solidarea.y = speedy > 0 ? -gp.tilesize/4 : gp.tilesize/4; solidarea.width = gp.tilesize/2; solidarea.height = gp.tilesize/2; // set default values explicitly solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; // set a longer lifespan for the acid projectile lifespan = 180; getimages(); setupsolidarea(solidarea.width, solidarea.height); } public void getimages(){ image = setupnew(""rifle"", gp.tilesize/3, gp.tilesize/3); } } package bil211game2.game.objects.ammos; import bil211game2.game.main.gamepanel; public class shotgunammo extends ammo{ public static int defaultspeed = 12; public shotgunammo(gamepanel gp) { super(gp); solidarea.x = speedx > 0 ? -gp.tilesize/4 : gp.tilesize/4; solidarea.y = speedy > 0 ? -gp.tilesize/4 : gp.tilesize/4; solidarea.width = gp.tilesize/2; solidarea.height = gp.tilesize/2; // set default values explicitly solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; // set a longer lifespan for the acid projectile lifespan = 100; getimages(); setupsolidarea(solidarea.width, solidarea.height); } public void getimages(){ image = setupnew(""shotgun"", gp.tilesize/3, gp.tilesize/3); } } package bil211game2.game.objects.ammos; import bil211game2.game.main.gamepanel; public class pistolammo extends ammo{ public static int defaultspeed = 15; public pistolammo(gamepanel gp) { super(gp); solidarea.x = speedx > 0 ? -gp.tilesize/4 : gp.tilesize/4; solidarea.y = speedy > 0 ? -gp.tilesize/4 : gp.tilesize/4; solidarea.width = gp.tilesize/2; solidarea.height = gp.tilesize/2; // set default values explicitly solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; // set a longer lifespan for the acid projectile lifespan = 180; getimages(); setupsolidarea(solidarea.width, solidarea.height); } public void getimages(){ image = setupnew(""pistol"", gp.tilesize/3, gp.tilesize/3); } } package bil211game2.game.objects.ammos; import java.awt.graphics2d; import java.awt.rectangle; import java.awt.geom.affinetransform; import java.awt.image.bufferedimage; import java.io.ioexception; import java.io.serializable; import javax.imageio.imageio; import bil211game2.game.entity.entity; import bil211game2.game.main.gamepanel; import bil211game2.game.main.utilitytool; public abstract class ammo implements serializable{ public int speedx = 1; public int speedy = 1; public int worldx; public int worldy; public bufferedimage image; public int attack = 0; public double rad = 0; public boolean collisionon = true; public boolean contact = false; public int lifespan = 120; public int lifetime = 0; public rectangle solidarea = new rectangle(0, 0, 48, 48); public int solidareadefaultx, solidareadefaulty; gamepanel gp; public ammo(gamepanel gp){ this.gp = gp; solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; } public bufferedimage setup(string imagepath, int width, int height){ bufferedimage image = null; try{ image = imageio.read(getclass().getresourceasstream(""/bil211game/resources/"" + imagepath + "".png"")); image = utilitytool.scaleimage(image, width, height); } catch(ioexception e){ e.printstacktrace(); } return image; } public bufferedimage setupnew(string imagepath, int width, int height){ bufferedimage image = null; try{ image = imageio.read(getclass().getresourceasstream(""/bil211game2/resources/images/items/ammos/"" + imagepath + "".png"")); image = utilitytool.scaleimage(image, width, height); } catch(ioexception e){ e.printstacktrace(); } return image; } // mermiyi çizmek için genel metot public void draw(graphics2d g2) { if(image != null) { // ekran konumunu hesapla int screenx = worldx - gp.player.worldx + gp.player.screenx; int screeny = worldy - gp.player.worldy + gp.player.screeny; // ekranda görünüyor mu kontrol et if(worldx + gp.tilesize/2 > gp.player.worldx - gp.player.screenx && worldx - gp.tilesize/2 < gp.player.worldx + gp.player.screenx && worldy + gp.tilesize/2 > gp.player.worldy - gp.player.screeny && worldy - gp.tilesize/2 < gp.player.worldy + gp.player.screeny) { // görüntüyü döndürmek için affinetransform kullan affinetransform at = new affinetransform(); // çizim merkezini hesapla int imagewidth = image.getwidth(); int imageheight = image.getheight(); screenx -= imagewidth / 2; screeny -= imageheight / 2; // dönüş için bileşenleri ayarla at.translate(screenx + imagewidth/2, screeny + imageheight/2); at.rotate(rad); at.translate(-imagewidth/2, -imageheight/2); // döndürülmüş görüntüyü çiz g2.drawimage(image, at, null); // debug mod - çarpışma alanını görselleştirme (isteğe bağlı) //g2.setcolor(color.red); //g2.drawrect(screenx + solidarea.x, screeny + solidarea.y, solidarea.width, solidarea.height); } } } public void update() { // mermiyi hızına göre hareket ettir worldx += speedx; worldy += speedy; // ömür sayacını artır lifetime++; // ömür süresini kontrol et if(lifetime >= lifespan) { contact = true; } } // çarpışma alanını hareket yönüne göre ayarla public void setupsolidarea(int width, int height) { // çarpışma alanı boyutlarını ayarla solidarea.width = width; solidarea.height = height; // varsayılan değerleri kaydet solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; } public void speedhandler(){ solidarea.x = (image.getwidth() - solidarea.width) / 2; solidarea.y = (image.getheight() - solidarea.height) / 2; // güncellenen değerleri solidareadefault değişkenlerine ata! solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; } public void additionalfeature(entity entity){ } } package bil211game2.game.entity; import bil211game2.game.main.gamepanel; public abstract class zombie extends monster{ public zombie(gamepanel gp) { super(gp); } } package bil211game2.game.entity; import java.awt.alphacomposite; import java.awt.color; import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.ioexception; import java.io.serializable; import javax.imageio.imageio; import bil211game2.game.main.utilitytool; import bil211game2.game.objects.ammos.acid; import bil211game2.game.objects.ammos.sniperammo; import bil211game2.game.main.gamepanel; import bil211game2.game.main.sound; public abstract class entity implements serializable{ gamepanel gp; public int worldx, worldy; public int speed; public int attackentity = 1; public bufferedimage up1, up2, down1, down2, left1, left2, right1, right2, attackup1, attackup2, attackdown1, attackdown2, attackleft1, attackleft2, attackright1, attackright2; public string direction = ""down""; public int spritecounter = 0; public int spritenum = 1; public rectangle solidarea = new rectangle(0,0,48,48); public rectangle attackarea = new rectangle(0,0,0,0); public int solidareadefaultx, solidareadefaulty; public boolean collisionon = false; public int actionlockcounter = 0; public int inviciblecounter = 0; public boolean invicible = false; public int type; public boolean attacking = false; public boolean alive = true; public boolean dying = false; int dyingcounter = 0; public boolean hpbaron = false; int hpbarcounter = 0; public bufferedimage image, image2, image3; public string name; public boolean collision = false; // character status public int maxlife; public int life; public entity(bil211game2.game.main.gamepanel gp2){ this.gp = gp2; } public void draw(graphics2d g2){ int screenx = worldx - gp.player.worldx + gp.player.screenx; int screeny = worldy - gp.player.worldy + gp.player.screeny; if(worldx + gp.tilesize > gp.player.worldx - gp.player.screenx && worldx - gp.tilesize < gp.player.worldx + gp.player.screenx && worldy + gp.tilesize > gp.player.worldy - gp.player.screeny && worldy - gp.tilesize < gp.player.worldy + gp.player.screeny){ bufferedimage image = null; switch(direction){ case ""up"": if(spritenum == 1){ image = up1; } if(spritenum == 2){ image = up2; } break; case ""down"": if(spritenum == 1){ image = down1; } if(spritenum == 2){ image = down2; } break; case ""left"": if(spritenum == 1){ image = left1; } if(spritenum == 2){ image = left2; } break; case ""right"": if(spritenum == 1){ image = right1; } if(spritenum == 2){ image = right2; } break; } if(type == 2 && hpbaron){ hpbarcounter++; if(hpbarcounter < 120){ g2.setcolor(new color(35,35,35)); g2.fillrect(screenx - 1, screeny-17, gp.tilesize + 2, 13); g2.setcolor(new color(255,0,30)); g2.fillrect(screenx, screeny - 15, (int)(gp.tilesize *((double)life/maxlife)), 10); } else{ hpbaron = false; hpbarcounter = 0; } } if(invicible){ hpbaron = true; changealphe(g2, 0.5f); } if(dying){ dyinganimation(g2); } g2.drawimage(image, screenx, screeny, gp.tilesize, gp.tilesize, null); changealphe(g2, 1f); } } public void setaction(){}; public void dyinganimation(graphics2d g2){ int i = 5; if(dyingcounter <= i){ changealphe(g2, 0f); } else if(dyingcounter <= i*2){ changealphe(g2, 1f); } else if(dyingcounter <= i*3){ changealphe(g2, 0f); } else if(dyingcounter <= i*4){ changealphe(g2, 1f); } else if(dyingcounter <= i*5){ changealphe(g2, 0f); } else if(dyingcounter <= i*6){ changealphe(g2, 1f); } else if(dyingcounter <= i*7){ changealphe(g2, 0f); } else if(dyingcounter <= i*8){ changealphe(g2, 1f); } } public void changealphe(graphics2d g2, float alphavalue){ g2.setcomposite(alphacomposite.getinstance(alphacomposite.src_over, alphavalue)); } public void update(){ setaction(); collisionon = false; gp.cchecker.checktile(this); boolean contactplayer = gp.cchecker.checkplayer(this); gp.cchecker.checkentity(this, gp.monsters); for(int i = 0; i < gp.ammos.size(); i++){ if(!(gp.ammos.get(i) instanceof acid) && gp.cchecker.checkammo(gp.ammos.get(i), this)){ gp.ammos.get(i).additionalfeature(this); shooted(gp.ammos.get(i).attack); if(!(gp.ammos.get(i) instanceof sniperammo)){ gp.ammos.set(i, null); gp.ammos.remove(i); } gp.playse(sound.zombie_hurt); } } if(this.type == 2 && contactplayer){ if(!gp.player.invicible){ gp.player.life -= attackentity; gp.player.invicible = true; gp.startscreenshake(8, 15); gp.playse(sound.player_hurt); } } if(!collisionon){ switch(direction){ case ""up"": worldy -= speed; break; case ""down"": worldy += speed; break; case ""left"": worldx -= speed; break; case ""right"": worldx += speed; break; } } spritecounter++; if(spritecounter > 12){ if(spritenum == 1){ spritenum = 2; } else if(spritenum == 2){ spritenum = 1; } spritecounter = 0; } if(invicible){ inviciblecounter++; if(inviciblecounter > 40){ invicible = false; inviciblecounter = 0; } } } public bufferedimage setup(string imagepath, int width, int height){ bufferedimage image = null; try{ image = imageio.read(getclass().getresourceasstream(""/bil211game/resources/"" + imagepath + "".png"")); image = utilitytool.scaleimage(image, width, height); } catch(ioexception e){ e.printstacktrace(); } return image; } public bufferedimage setupnew(string imagepath, int width, int height){ bufferedimage image = null; try{ image = imageio.read(getclass().getresourceasstream(""/bil211game2/resources/images/"" + imagepath + "".png"")); image = utilitytool.scaleimage(image, width, height); } catch(ioexception e){ e.printstacktrace(); } return image; } public void damagereaction(){} public void shooted(int damage){ invicible = true; life -= damage; damagereaction(); } public void updatedying() { dyingcounter++; int i = 5; if(dyingcounter > i*8) { dying = false; alive = false; } } } package bil211game2.game.entity; import bil211game2.game.main.gamepanel; import bil211game2.game.main.sound; import bil211game2.game.objects.ammos.acid; public class acidzombie extends zombie implements acidity{ boolean canshoot = true; int shootcounter = 0; int defaultspeed; int shootcooldown = 120; public acidzombie(gamepanel gp) { super(gp); type = 2; name = ""acid zombie""; speed = 2; maxlife = 2; life = maxlife; basescore = 7; attack = 1; solidarea.x = 3; solidarea.y = 10; solidarea.width = 42; solidarea.height = 30; solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; defaultspeed = speed; lootchance = 60; rifleammochance = 40; shotgunammochance = 40; sniperammochance = 10; rocketammochance = 10; getimage(); } public void getimage(){ up1 = setupnew(""zombies/turret zombie animation frames/up2"", gp.tilesize, gp.tilesize); up2 = setupnew(""zombies/turret zombie animation frames/up3"", gp.tilesize, gp.tilesize); down1 = setupnew(""zombies/turret zombie animation frames/down2"", gp.tilesize, gp.tilesize); down2 = setupnew(""zombies/turret zombie animation frames/down3"", gp.tilesize, gp.tilesize); left1 = setupnew(""zombies/turret zombie animation frames/left2"", gp.tilesize, gp.tilesize); left2 = setupnew(""zombies/turret zombie animation frames/left3"", gp.tilesize, gp.tilesize); right1 = setupnew(""zombies/turret zombie animation frames/right2"", gp.tilesize, gp.tilesize); right2 = setupnew(""zombies/turret zombie animation frames/right3"", gp.tilesize, gp.tilesize); } public void setaction(){ actionlockcounter++; if(actionlockcounter > 60){ boolean flag = false; // true : horizontal, false : vertical if(math.abs(gp.player.worldx - worldx) > math.abs(gp.player.worldy - worldy)){ flag = true; } if(flag){ if(gp.player.worldx - worldx > 0){ direction = ""right""; } else{ direction = ""left""; } } else{ if(gp.player.worldy - worldy > 0){ direction = ""down""; } else{ direction = ""up""; } } actionlockcounter = 0; } if(!canshoot) { shootcounter++; if(shootcounter >= shootcooldown) { canshoot = true; shootcounter = 0; } } else{ int xdistance = math.abs(gp.player.worldx - worldx); int ydistance = math.abs(gp.player.worldy - worldy); int totaldistance = (int) math.sqrt(xdistance * xdistance + ydistance * ydistance); // 8 tile menzil içindeyse ateş et if(totaldistance < 8 * gp.tilesize) { rangeattack(); canshoot = false; shootcounter = 0; } } } public void rangeattack(){ acid acid = shootammo(); if(acid != null) { gp.ammos.add(acid); } } @override public void damagereaction() { actionlockcounter = 0; direction = gp.player.direction; } public acid shootammo(){ acid acid = new acid(gp); int playerx = gp.player.worldx; int playery = gp.player.worldy; // mermi başlangıç pozisyonunu hesapla int ammox, ammoy; // yöne bağlı olarak mermi çıkış noktasını ayarla switch(direction) { case ""up"": ammox = worldx + gp.tilesize/2; ammoy = worldy - gp.tilesize/2; break; case ""down"": ammox = worldx + gp.tilesize/2; ammoy = worldy + gp.tilesize; break; case ""left"": ammox = worldx - gp.tilesize/2; ammoy = worldy + gp.tilesize/2; break; case ""right"": ammox = worldx + gp.tilesize; ammoy = worldy + gp.tilesize/2; break; default: ammox = worldx + gp.tilesize/2; ammoy = worldy + gp.tilesize/2; break; } acid.worldx = ammox; acid.worldy = ammoy; // hasarı ayarla acid.attack = attack; // oyuncuya doğru açıyı hesapla acid.rad = math.atan2(playery - ammoy, playerx - ammox); // açıya göre hızı hesapla acid.speedy = (int)(acid.defaultspeed*math.sin(acid.rad)); acid.speedx = (int)(acid.defaultspeed*math.cos(acid.rad)); // çarpışma alanını hareket yönüne göre ayarla - genel metodu kullan acid.setupsolidarea(gp.tilesize/2, gp.tilesize/2); acid.speedhandler(); gp.playse(sound.acid_zombie_acid_sound); return acid; } @override public void splash() { gp.animationmanager.addacidsplash(worldx, worldy); for(int i = 0; i < gp.monsters.size(); i++){ if(gp.monsters.get(i) != null && !gp.monsters.get(i).invicible){ monster monster = gp.monsters.get(i); int monsterx = monster.worldx; int monstery = monster.worldy; double distances = math.sqrt((monsterx - worldx) * (monsterx - worldx) + (monstery - worldy) * (monstery - worldy)); if(distances < 3 * gp.tilesize){ monster.damagereaction(); monster.invicible = true; monster.life -= attack; } } } if(gp.player != null && !gp.player.invicible){ int playerx = gp.player.worldx; int playery = gp.player.worldy; double distances = math.sqrt((playerx - worldx) * (playerx - worldx) + (playery - worldy) * (playery - worldy)); if(distances < 3 * gp.tilesize){ gp.player.invicible = true; gp.player.life -= attack; } } } @override public void kill() { gp.player.score += (gp.currentphase+1)*basescore; splash(); gp.animationmanager.addbloodsplash(worldx, worldy); gp.startscreenshake(20, 20); looting(); } } package bil211game2.game.entity; public interface acidity { public void splash(); } package bil211game2.game.entity; import java.util.random; import bil211game2.game.main.gamepanel; public class reptilezombie extends zombie implements jumpable{ boolean canjump = true; int jumpcounter = 0; int defaultspeed; boolean isjumping = false; boolean jumpflag = false; // sınıf üyesi olarak tanımlandı random random = new random(); public reptilezombie(gamepanel gp) { super(gp); type = 2; name = ""reptile zombie""; speed = 4; maxlife = 2; life = maxlife; basescore = 3; attack = 1; solidarea.x = 3; solidarea.y = 10; solidarea.width = 42; solidarea.height = 30; solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; defaultspeed = speed; lootchance = 40; rifleammochance = 80; shotgunammochance = 20; getimage(); } public void getimage(){ up1 = setupnew(""zombies/kid zombie animation frames/up2"", gp.tilesize, gp.tilesize); up2 = setupnew(""zombies/kid zombie animation frames/up3"", gp.tilesize, gp.tilesize); down1 = setupnew(""zombies/kid zombie animation frames/down2"", gp.tilesize, gp.tilesize); down2 = setupnew(""zombies/kid zombie animation frames/down3"", gp.tilesize, gp.tilesize); left1 = setupnew(""zombies/kid zombie animation frames/left2"", gp.tilesize, gp.tilesize); left2 = setupnew(""zombies/kid zombie animation frames/left3"", gp.tilesize, gp.tilesize); right1 = setupnew(""zombies/kid zombie animation frames/right2"", gp.tilesize, gp.tilesize); right2 = setupnew(""zombies/kid zombie animation frames/right3"", gp.tilesize, gp.tilesize); } public void setaction(){ actionlockcounter++; if(actionlockcounter > 60){ jumpflag = random.nextboolean(); boolean flag = false; // true : horizontal, false : vertical if(math.abs(gp.player.worldx - worldx) > math.abs(gp.player.worldy - worldy)){ flag = true; } if(flag){ if(gp.player.worldx - worldx > 0){ direction = ""right""; } else{ direction = ""left""; } } else{ if(gp.player.worldy - worldy > 0){ direction = ""down""; } else{ direction = ""up""; } } actionlockcounter = 0; } int xdistance = math.abs(gp.player.worldx - worldx); int ydistance = math.abs(gp.player.worldy - worldy); int totaldistance = (int) math.sqrt(xdistance * xdistance + ydistance * ydistance); if(isjumping) { jumpcounter++; if(jumpcounter > 5) { speed = defaultspeed; isjumping = false; } } else { if(!canjump) { jumpcounter++; if(jumpcounter > 300) { canjump = true; jumpcounter = 0; } } else if(totaldistance < gp.tilesize * 5 && canjump && jumpflag) { speed = defaultspeed * 5; isjumping = true; canjump = false; jumpcounter = 0; jumpflag = false; } } } @override public void damagereaction() { actionlockcounter = 0; direction = gp.player.direction; } @override public void jump() { // jumpable arayüzünden gelen metot, gerekirse içeriği doldurulabilir } @override public void kill() { gp.player.score += (gp.currentphase+1)*basescore; gp.animationmanager.addbloodsplash(worldx, worldy); looting(); } } package bil211game2.game.entity; import bil211game2.game.main.gamepanel; public class normalzombie extends zombie{ public normalzombie(gamepanel gp) { super(gp); type = 2; name = ""normal zombie""; speed = 2; maxlife = 4; life = maxlife; basescore = 1; attack = 1; solidarea.x = 3; solidarea.y = 10; solidarea.width = 42; solidarea.height = 30; solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; lootchance = 20; rifleammochance = 100; getimage(); } public void getimage(){ up1 = setupnew(""zombies/skinny walking zombie animation/up2"", gp.tilesize, gp.tilesize); up2 = setupnew(""zombies/skinny walking zombie animation/up3"", gp.tilesize, gp.tilesize); down1 = setupnew(""zombies/skinny walking zombie animation/down2"", gp.tilesize, gp.tilesize); down2 = setupnew(""zombies/skinny walking zombie animation/down3"", gp.tilesize, gp.tilesize); left1 = setupnew(""zombies/skinny walking zombie animation/left2"", gp.tilesize, gp.tilesize); left2 = setupnew(""zombies/skinny walking zombie animation/left3"", gp.tilesize, gp.tilesize); right1 = setupnew(""zombies/skinny walking zombie animation/right2"", gp.tilesize, gp.tilesize); right2 = setupnew(""zombies/skinny walking zombie animation/right3"", gp.tilesize, gp.tilesize); } public void setaction(){ actionlockcounter++; if(actionlockcounter > 60){ boolean flag = false; // true : horizontal, false : vertical if(math.abs(gp.player.worldx - worldx) > math.abs(gp.player.worldy - worldy)){ flag = true; } if(flag){ if(gp.player.worldx - worldx > 0){ direction = ""right""; } else{ direction = ""left""; } } else{ if(gp.player.worldy - worldy > 0){ direction = ""down""; } else{ direction = ""up""; } } actionlockcounter = 0; } } @override public void damagereaction() { actionlockcounter = 0; direction = gp.player.direction; } @override public void kill() { gp.player.score += (gp.currentphase+1)*basescore; gp.animationmanager.addbloodsplash(worldx, worldy); looting(); } } package bil211game2.game.entity; import java.util.random; import bil211game2.game.main.gamepanel; public abstract class monster extends entity{ public int basescore = 1; public int attack = 0; public int lootchance = 0; public int rifleammochance = 0; public int shotgunammochance = 0; public int sniperammochance = 0; public int rocketammochance = 0; public monster(gamepanel gp2) { super(gp2); } public abstract void kill(); @override public void update() { if(life <= 0){ kill(); dying = true; return; } super.update(); } public string lootammotype(){ random random = new random(); int lootfalled = random.nextint(101); boolean falled = false; if(100 - lootfalled > lootchance){ falled = true; } if(falled){ int ammotype = random.nextint(101); if(ammotype < rifleammochance){ return ""rifle""; } else if(ammotype < rifleammochance + shotgunammochance){ return ""shotgun""; } else if(ammotype < rifleammochance + shotgunammochance + sniperammochance){ return ""sniper""; } else{ return ""rocket""; } } return ""null""; } public void looting(){ string loot = lootammotype(); switch(loot){ case ""rifle"": gp.player.weapons[1].ammo += 5; break; case ""shotgun"": gp.player.weapons[2].ammo += 5; break; case ""sniper"": gp.player.weapons[3].ammo += 5; break; case ""rocket"": gp.player.weapons[4].ammo += 5; break; default: break; } } } package bil211game2.game.entity; import bil211game2.game.main.gamepanel; public class tankzombie extends zombie{ public tankzombie(gamepanel gp) { super(gp); type = 2; name = ""tank zombie""; speed = 1; maxlife = 4; life = maxlife; basescore = 5; attack = 2; attackentity = 2; solidarea.x = 3; solidarea.y = 10; solidarea.width = 42; solidarea.height = 30; solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; lootchance = 50; rifleammochance = 60; shotgunammochance = 30; sniperammochance = 10; getimage(); } public void getimage(){ up1 = setupnew(""zombies/big zombie walking animation frames/up2"", gp.tilesize, gp.tilesize); up2 = setupnew(""zombies/big zombie walking animation frames/up3"", gp.tilesize, gp.tilesize); down1 = setupnew(""zombies/big zombie walking animation frames/down2"", gp.tilesize, gp.tilesize); down2 = setupnew(""zombies/big zombie walking animation frames/down3"", gp.tilesize, gp.tilesize); left1 = setupnew(""zombies/big zombie walking animation frames/left2"", gp.tilesize, gp.tilesize); left2 = setupnew(""zombies/big zombie walking animation frames/left3"", gp.tilesize, gp.tilesize); right1 = setupnew(""zombies/big zombie walking animation frames/right2"", gp.tilesize, gp.tilesize); right2 = setupnew(""zombies/big zombie walking animation frames/right3"", gp.tilesize, gp.tilesize); } public void setaction(){ actionlockcounter++; if(actionlockcounter > 60){ boolean flag = false; // true : horizontal, false : vertical if(math.abs(gp.player.worldx - worldx) > math.abs(gp.player.worldy - worldy)){ flag = true; } if(flag){ if(gp.player.worldx - worldx > 0){ direction = ""right""; } else{ direction = ""left""; } } else{ if(gp.player.worldy - worldy > 0){ direction = ""down""; } else{ direction = ""up""; } } actionlockcounter = 0; } } @override public void damagereaction() { actionlockcounter = 0; direction = gp.player.direction; } @override public void kill() { gp.player.score += (gp.currentphase+1)*basescore; gp.animationmanager.addbloodsplash(worldx, worldy); looting(); } } package bil211game2.game.entity; import java.awt.alphacomposite; import java.awt.basicstroke; import java.awt.color; import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; import bil211game2.game.main.keyhandler; import bil211game2.game.main.gamepanel; import bil211game2.game.main.mousehandler; import bil211game2.game.main.sound; import bil211game2.game.main.utilitytool; import bil211game2.game.objects.ammos.acid; import bil211game2.game.objects.ammos.sniperammo; import bil211game2.game.objects.weapons.pistol; import bil211game2.game.objects.weapons.rifle; import bil211game2.game.objects.weapons.rocketlauncher; import bil211game2.game.objects.weapons.shotgun; import bil211game2.game.objects.weapons.sniper; import bil211game2.game.objects.weapons.weapon; public class player extends entity{ keyhandler keyh; mousehandler mouseh; int standcounter = 0; public boolean standing = false; int attackcounter = 0; boolean canattact = false; public int score = 0; public final int screenx, screeny; public int currentweaponindex; public weapon[] weapons = new weapon[5]; private monster closestzombie = null; private int zombiedetectiontimer = 0; private final int zombie_detection_duration = 180; private boolean zombiedetectionactive = false; public player(gamepanel gp, keyhandler keyh, mousehandler mouseh) { super(gp); this.keyh = keyh; this.mouseh = mouseh; screenx = gp.screenwidth/2 - (gp.tilesize/2); screeny = gp.screenheight/2 - (gp.tilesize/2); // override solid area solidarea = new rectangle(); solidarea.x = 8; solidarea.y = 16; solidarea.width = 32; solidarea.height = 32; solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; attackarea.width = 36; attackarea.height = 36; currentweaponindex = 0; weapons[0] = new pistol(gp); weapons[1] = new rifle(gp); weapons[2] = new shotgun(gp); weapons[3] = new sniper(gp); weapons[4] = new rocketlauncher(gp); setdefaultvalues(); getplayerimage(); //getplayerattackimage(); } public void setdefaultvalues(){ worldx = gp.tilesize * 23; worldy = gp.tilesize * 21; speed = 4; direction = ""down""; // player status maxlife = 6; life = maxlife; } public void getplayerimage(){ up1 = setupnew(""player/player character walking animation frames/up2"", gp.tilesize, gp.tilesize); up2 = setupnew(""player/player character walking animation frames/up3"", gp.tilesize, gp.tilesize); down1 = setupnew(""player/player character walking animation frames/down2"", gp.tilesize, gp.tilesize); down2 = setupnew(""player/player character walking animation frames/down3"", gp.tilesize, gp.tilesize); left1 = setupnew(""player/player character walking animation frames/left2"", gp.tilesize, gp.tilesize); left2 = setupnew(""player/player character walking animation frames/left3"", gp.tilesize, gp.tilesize); right1 = setupnew(""player/player character walking animation frames/right2"", gp.tilesize, gp.tilesize); right2 = setupnew(""player/player character walking animation frames/right3"", gp.tilesize, gp.tilesize); } public void getplayerattackimage(){ attackup1 = setupnew(""player/player character walking animation frames/up2"", gp.tilesize, gp.tilesize); attackup2 = setupnew(""player/player character walking animation frames/up3"", gp.tilesize, gp.tilesize); attackdown1 = setupnew(""player/player character walking animation frames/up3"", gp.tilesize, gp.tilesize); attackdown2 = setupnew(""player/player character walking animation frames/up3"", gp.tilesize, gp.tilesize); attackleft1 = setupnew(""player/player character walking animation frames/up3"", gp.tilesize, gp.tilesize); attackleft2 = setupnew(""player/player character walking animation frames/up3"", gp.tilesize, gp.tilesize); attackright1 = setupnew(""player/player character walking animation frames/up3"", gp.tilesize, gp.tilesize); attackright2 = setupnew(""player/player character walking animation frames/up3"", gp.tilesize, gp.tilesize); } @override public void update(){ if(life <= 0){ gp.gamestate = gp.finishstate; return; } if(keyh.hpressed && !zombiedetectionactive) { findclosestzombie(); zombiedetectiontimer = 0; zombiedetectionactive = true; } if(zombiedetectionactive) { zombiedetectiontimer++; if(zombiedetectiontimer > zombie_detection_duration) { zombiedetectionactive = false; closestzombie = null; } } attackcounter++; if(mouseh.mouseleftpressed){ if(attackcounter > 60/((double)weapons[currentweaponindex].firerate/60)){ canattact = true; attackcounter = 0; } else{ canattact = false; } } else{ canattact = false; } if(canattact){ attacking(mouseh.event.getx(), mouseh.event.gety()); } if(keyh.uppressed||keyh.downpressed||keyh.leftpressed||keyh.rightpressed){ if(keyh.uppressed){ direction = ""up""; } else if(keyh.downpressed){ direction = ""down""; } else if(keyh.rightpressed){ direction = ""right""; } else if(keyh.leftpressed){ direction = ""left""; } standing = true; collisionon = false; gp.cchecker.checktile(this); int monsterindex = gp.cchecker.checkentity(this, gp.monsters); contactmonster(monsterindex); gp.ehandler.checkevent(); for(int i = 0; i < gp.ammos.size(); i++){ if(gp.ammos.get(i) instanceof acid && gp.cchecker.checkammo(gp.ammos.get(i), this)){ life -= gp.ammos.get(i).attack; invicible = true; gp.ammos.set(i, null); gp.ammos.remove(i); gp.startscreenshake(12, 15); gp.playse(sound.player_hurt); } } if(!collisionon){ switch(direction){ case ""up"": worldy -= speed; break; case ""down"": worldy += speed; break; case ""left"": worldx -= speed; break; case ""right"": worldx += speed; break; } } spritecounter++; if(spritecounter > 12){ if(spritenum == 1){ spritenum = 2; } else if(spritenum == 2){ spritenum = 1; } spritecounter = 0; } } else{ for(int i = 0; i < gp.ammos.size(); i++){ if(gp.ammos.get(i) instanceof acid && gp.cchecker.checkammo(gp.ammos.get(i), this)){ life -= gp.ammos.get(i).attack; invicible = true; if(!(gp.ammos.get(i) instanceof sniperammo)){ gp.ammos.set(i, null); gp.ammos.remove(i); } gp.playse(sound.player_hurt); } } standing = false; standcounter++; if(standcounter == 20){ spritenum = 1; standcounter = 0; } } if(invicible){ inviciblecounter++; if(inviciblecounter > 60){ invicible = false; inviciblecounter = 0; } } } public void draw(graphics2d g2){ bufferedimage image = null; int tempscreenx = screenx; int tempscreeny = screeny; switch(direction){ case ""up"": if(attacking){ tempscreeny = tempscreeny - gp.tilesize; if(spritenum == 1){ image = attackup1; } if(spritenum == 2){ image = attackup2; } } else{ if(spritenum == 1){ image = up1; } if(spritenum == 2){ image = up2; } } break; case ""down"": if(attacking){ if(spritenum == 1){ image = attackdown1; } if(spritenum == 2){ image = attackdown2; } } else{ if(spritenum == 1){ image = down1; } if(spritenum == 2){ image = down2; } } break; case ""left"": if(attacking){ tempscreenx = tempscreenx - gp.tilesize; if(spritenum == 1){ image = attackleft1; } if(spritenum == 2){ image = attackleft2; } } else{ if(spritenum == 1){ image = left1; } if(spritenum == 2){ image = left2; } } break; case ""right"": if(attacking){ if(spritenum == 1){ image = attackright1; } if(spritenum == 2){ image = attackright2; } } else{ if(spritenum == 1){ image = right1; } if(spritenum == 2){ image = right2; } } break; } if(invicible){ g2.setcomposite(alphacomposite.getinstance(alphacomposite.src_over, 0.5f)); } g2.drawimage(image, tempscreenx, tempscreeny, null); g2.setcomposite(alphacomposite.getinstance(alphacomposite.src_over, 1f)); if(zombiedetectionactive && closestzombie != null) { drawdirectionarrow(g2); } } public void contactmonster(int index){ if(index != 999){ if(!invicible){ life--; invicible = true; gp.startscreenshake(8, 15); } } } public void attacking(int x, int y){ weapons[currentweaponindex].fire(worldx + x - gp.screenwidth/2, worldy + y - gp.screenheight/2); } public void changeweapon(int i){ if(gp.gamestate == gp.playstate){ if(i == 0){ currentweaponindex = 0; } else if(i == 1 && gp.currentphase > gp.phase1){ currentweaponindex = 1; } else if(i == 2 && gp.currentphase > gp.phase4){ currentweaponindex = 2; } else if(i == 3 && gp.currentphase > gp.phase6){ currentweaponindex = 3; } else if(i == 4 && gp.currentphase > gp.phase10){ currentweaponindex = 4; } } } public void damage(int i){ if(i != 999){ if(!gp.monsters.get(i).invicible){ gp.monsters.get(i).life--; gp.monsters.get(i).invicible = true; gp.monsters.get(i).damagereaction(); if(gp.monsters.get(i).life <= 0){ gp.monsters.get(i).kill(); gp.monsters.get(i).dying = true; } } } } private void findclosestzombie() { double closestdistance = double.max_value; closestzombie = null; for(int i = 0; i < gp.monsters.size(); i++) { monster monster = gp.monsters.get(i); if(monster != null && monster.alive && !monster.dying) { double distance = utilitytool.distancecalculator( worldx, worldy, monster.worldx, monster.worldy); if(distance < closestdistance) { closestdistance = distance; closestzombie = monster; } } } } public monster getclosestzombie() { return zombiedetectionactive ? closestzombie : null; } private void drawdirectionarrow(graphics2d g2) { if(closestzombie == null) return; // zombi ile oyuncu arasındaki açıyı hesapla int zombiex = closestzombie.worldx - gp.player.worldx; int zombiey = closestzombie.worldy - gp.player.worldy; double angle = math.atan2(zombiey, zombiex); // ok için parametreler int arrowlength = gp.tilesize; int arrowheadsize = gp.tilesize / 3; // okun başlangıç noktasını hesapla (oyuncunun merkezi) int startx = screenx + gp.tilesize / 2; int starty = screeny + gp.tilesize / 2; // okun bitiş noktasını hesapla int endx = startx + (int)(math.cos(angle) * arrowlength); int endy = starty + (int)(math.sin(angle) * arrowlength); // ok çiz g2.setcolor(new color(255, 0, 0, 180)); // ok başı çiz int[] xpoints = new int[3]; int[] ypoints = new int[3]; xpoints[0] = endx; ypoints[0] = endy; xpoints[1] = endx - (int)(math.cos(angle + math.pi/6) * arrowheadsize); ypoints[1] = endy - (int)(math.sin(angle + math.pi/6) * arrowheadsize); xpoints[2] = endx - (int)(math.cos(angle - math.pi/6) * arrowheadsize); ypoints[2] = endy - (int)(math.sin(angle - math.pi/6) * arrowheadsize); g2.fillpolygon(xpoints, ypoints, 3); // etrafında parlayan bir halka çiz (radar efekti) float pulsesize = 1.0f + 0.2f * (float)math.sin(system.currenttimemillis() * 0.005); int ringsize = (int)((gp.tilesize + gp.tilesize/3) * pulsesize); g2.setcolor(new color(255, 0, 0, 50)); // çok hafif kırmızı g2.setstroke(new basicstroke(2)); g2.drawoval(startx - ringsize/2, starty - ringsize/2, ringsize, ringsize); } } package bil211game2.game.entity; public interface jumpable { public void jump(); }"
8190737,4,"recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. import java.util.*; public class lab21q1 { public static int collatz(int i){ if(i == 1) return 0; if(i % 2 == 0) return 1 + collatz(i / 2); return 1 + collatz(3 * i + 1); } public static void main(string[] args) { scanner sc = new scanner(system.in); int i = sc.nextint(); system.out.println(collatz(i)); sc.close(); } } import java.util.*; public class lab21q2 { static boolean issorted(int[] arr){ int n = arr.length; for(int i = 1;i < n;i++){ if(arr[i-1] > arr[i]) return false; } return true; } static int[] coctailsort(int[] arr, boolean bubblebiggest){ if(issorted(arr)) return arr; int n = arr.length; for(int i = 1;i < n;i++){ if(bubblebiggest){ if(arr[i-1] > arr[i]){ int a1 = arr[i-1]; int a2 = arr[i]; arr[i-1] = a2; arr[i] = a1; } } else{ if(arr[i-1] < arr[i]){ int a1 = arr[i-1]; int a2 = arr[i]; arr[i-1] = a2; arr[i] = a1; } } } int[] rev = new int[n]; for(int i = 0;i < n;i++) rev[i] = arr[(n-1) - i]; return coctailsort(rev, !bubblebiggest); } public static void main(string[] args) { scanner sc = new scanner(system.in); int n = sc.nextint(); int[] arr = new int[n]; for(int i = 0;i < n;i++) arr[i] = sc.nextint(); arr = coctailsort(arr, true); for(int i = 0;i < n;i++) system.out.print("""" + arr[i] + "" ""); system.out.print(""\n""); sc.close(); } } import java.util.*; class sayac{ string str; sayac(string str){ this.str = str; } public int say(int idx){ if(idx == str.length()) return 0; if(str.charat(idx) == '1') return 1 + say(idx + 1); else return say(idx + 1); } public int say(){ return say(0); } } public class lab21q3 { public static void main(string[] args) { scanner sc = new scanner(system.in); string str1 = sc.next(); sayac say1 = new sayac(str1); system.out.println(say1.say()); string str2 = sc.next(); sayac say2 = new sayac(str2); system.out.println(say2.say()); sc.close(); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.*; public class musicplayer{ playingstrategy strategy; void setstrategy(playingstrategy strategy){ this.strategy = strategy; } void play(list<song> playlist){ strategy.play(playlist); } } import java.util.*; public class main { public static void main(string[] args) { scanner sc = new scanner(system.in); song s1 = new metal(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); song s2 = new metal(""voice of the soul"", ""death"", ""enstrumantal""); song s3 = new rock(""small mountain"", ""midlake""); song s4 = new rock(""ankara"", ""vega""); song s5 = new classic(""una mattina"", ""ludovico einaudi""); // songlari iceren calma listesi list<song> playlist = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi musicplayer musicplayer = new musicplayer(); // sirali calma stratejisi system.out.println(""sirali calma:""); musicplayer.setstrategy(new ordered()); musicplayer.play(playlist); // karisik calma stratejisi system.out.println(""karisik calma:""); musicplayer.setstrategy(new shuffled()); musicplayer.play(playlist); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); musicplayer.setstrategy(new rockspecial()); musicplayer.play(playlist); system.out.println(""metal ozellikleri:""); for (song song:playlist){ if(song instanceof metal){ metal metal = (metal)song; system.out.println(metal.singer + "" - "" + metal.name + "" [ozellik: "" + metal.metalproperties + ""]""); } } sc.close(); } } abstract class song{ string name; string singer; abstract void play(); } class metal extends song{ string name; string singer; string metalproperties; metal(string name, string singer, string metalproperties){ this.name = name; this.singer = singer; this.metalproperties = metalproperties; } void play(){ system.out.println(""[metal] "" + singer + "" - "" + name + "" ("" + metalproperties + "")""); } void showmetalproperties(){ system.out.println(metalproperties); } } class rock extends song{ string name; string singer; rock(string name, string singer){ this.name = name; this.singer = singer; } void play(){ system.out.println(""[rock] "" + singer + "" - "" + name + "" (huzurlu ve nostaljik)""); } } class classic extends song{ string name; string singer; classic(string name, string singer){ this.name = name; this.singer = singer; } void play(){ system.out.println(""[klasik] "" + singer + "" - "" + name + "" (hafif ve sakin)""); } } import java.util.*; interface playingstrategy{ public void play(list<song> playlist); } class ordered implements playingstrategy{ public void play(list<song> playlist){ for(song song:playlist){ song.play(); } system.out.println(""\n""); } } class shuffled implements playingstrategy{ public void play(list<song> playlist){ int length = playlist.size(); for(int i = length-1;i >= 0;i--){ int idx = (int)math.round(math.random() * i); song tempsong1 = playlist.get(idx); song tempsong2 = playlist.get(i); playlist.set(idx, tempsong2); playlist.set(i , tempsong1); } for(song song:playlist){ song.play(); } system.out.println(""\n""); } } class rockspecial implements playingstrategy{ public void play(list<song> playlist){ boolean playingrock = false; for(song song:playlist){ if(song instanceof rock && !playingrock){ system.out.println(""[bilgi] ses duzeyi: yuksek""); playingrock = true; } else if(!(song instanceof rock) && playingrock){ system.out.println(""[bilgi] ses duzeyi: normal""); playingrock = false; } song.play(); } system.out.println(""\n""); } } metin karşılaştırıcı bil 211 - lab 3 20 şubat 2025 1 giriş bulaboratuvarda fileio ve exceptions kullanarakbir metinkarşılaştırıcı geliştireceğiz. metinkarşılaştırıcı , verilen iki metin dosyasını karşılaştırarak ikinci metnin yalnızca yeni satırlar eklenerek oluşturulup oluştu- rulmadığını kontrol edecek ve gerektiğinde hangi satırdan sonra hangi eklemelerin yapıldığını belirleyecektir. 2 genel program program, çalıştırılırken komut satırından iki dosya adı alacaktır: - orijinal metin dosyası (ilk argüman) - değiştirilmiş metin dosyası (ikinci argüman) program şu şekilde çalıştırmalıdır (burada köşeli parantezler yerine dosyaların asıl adı gelmeli): java metinkarsilastirici [orijinal.txt] [degistirilmis.txt] program, ilk argümanda verilen dosyayı orijinal metin, ikinci argümandaki dosyayı değiştirilmiş metin olarak kabul edecek ve yalnızca yeni satırlar eklenerek oluşturulup oluşturulmadığını kontrol edecektir. eğer mümkünse, hangi satırdan sonra hangi eklemelerin yapıldığını tespit ederek bir çıktı dosyasına yazacaktır: -farklar.txt – yeni satırların hangi satırdan sonra eklendiğini gösteren çıktı dosyası. eğer dosya adları eksikse veya hatalı formatta verilmişse, program özel bir hata oluşturmalı ve stderr’e uygun bir mesaj yazmalıdır. 3 fileio program, dosyaokumaveyazmaişlemleriiçinjava’nın java.io paketindekisınıflarıkullanacaktır(örn., buf- ferredreader, scanner, printwriter). dosyaları okurken ve yazarken kullanacağınız fileio sınıflarının seçimi size bırakılmıştır. program, aşağıdaki olası dosya hatalarını atmalı ve stderr’e belirlenen hata mesajlarını yazmalıdır: - dosya bulunamıyorsa: ""hata: [dosya adı] bulunamadı."" - dosya boşsa: ""hata: [dosya adı] boş."" 4 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program hata kodu ile çıkış yapmalıdır (yani mainmetodunuz bu hataları atarak sonlanmalı) ve hatalar stderr’e yazılmalıdır (programınızı hata atarak sonlandırırsanız java bunu kendisi yapacaktır). belirtilen hata mesajları ile birlikte java’nın hata ile sonlanan programlar için oluşturduğu sınıf, metod, ve satır gibi bilgiler bulunabilir. 4.1 girdi hataları (inputexception class) bu kategori, programın giriş dosyalarıyla ilgili karşılaşabileceği tüm hataları kapsar. öğrenciler, dosya işlem- leriyle ilgili hata türlerini inputexception sınıfından türetmelidir. aşağıdaki özel hata türleri tanımlanmalıdır: 1 - yanlisargumanexception (extends inputexception): argümanlar eksik ya da fazlaysa atılacak hata. burada[argümanlar] yerine programın çalıştırıldığı argüman listesi yazılmalıdır. - hata mesajı: ""hata: hatalı argüman kullanımı: [argümanlar]. program argüman olarak 2 dosya ismi almalı."" - dosyabulunamadiexception (extends inputexception): dosya eksikse atılacak hata. - hata mesajı: ""hata: [dosya adı] bulunamadı."" - bosdosyaexception (extends inputexception): dosya boşsa atılacak hata. - hata mesajı: ""hata: [dosya adı] boş."" 4.2 geçersiz değişiklik hatası (gecersizdegisiklikexception class) eğerdegistirilmis.txt dosyası,orijinal.txt dosyasına yalnızca yeni satırlar eklenerek oluşturulamıy- orsa, program gecersizdegisiklikexception hatasını atmalıdır. bu hata oluştuğunda stderr’e şu mesaj yazılmalıdır: hata: [degistirilmis.txt] dosyası, [orijinal.txt] dosyasına yalnızca yeni satırlar eklenerek oluşturulmamış. 5 dosya formatları 5.1 girdi dosyaları 5.1.1orijinal.txt vedegistirilmis.txt formatı bu dosyalar, her satırın ayrı bir metin satırı olduğu düz metin formatında olmalıdır. örnek i̇çerik ( orijinal.txt ): merhaba dünya. bu bir test dosyasıdır. son satır budur. örnek i̇çerik ( degistirilmis.txt ): merhaba dünya. bu bir test dosyasıdır. eklenen yeni bir satır. son satır budur. yeni bir satır daha eklendi. 5.2 çıktı dosyası 5.2.1farklar.txt formatı farklar.txt dosyası, hangi satırdan sonra hangi yeni satırın eklendiğini gösterecek şekilde yapılandırıl- malıdır: örnek çıktı ( farklar.txt ): 2 -> eklenen yeni bir satır. 4 -> yeni bir satır daha eklendi. burada ‘2 ->‘ ifadesi, ""2. satırdan sonra eklenmiştir"" anlamına gelir. eğer aynı yere birden fazla satır eklenmişse aynı sayıyı tekrar ederek eklenme sırasında yazılmalı. 5.3 özel hata durumları ve çıktıları eğerdegistirilmis.txt ,orijinal.txt üzerine sadece yeni satırlar eklenerek oluşturulmamışsa stderr’e şu mesaj yazılmalıdır: hata: degistirilmis.txt dosyası, orijinal.txt dosyasına yalnızca yeni satırlar eklenerek oluşturulmamış. eğer dosya adları eksikse veya hatalıysa, stderr’e şu mesaj yazılmalıdır: hata: geçersiz dosya adı. 2 6 gönderim formatı - labı bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara şeklinde isimlendirin (örn., johnnash_181101014.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""lab3 gönderim"" başlıklı bir mail ile gönderin. metot açıklama string(string s) sile aynı değere sahip bir string oluşturur. string(char[] a) a[]dizisindeki karakterleri temsil eden bir string oluşturur. int length() string içindeki karakter sayısını döndürür. char charat(int i) belirtilen iindeksindeki karakteri döndürür. string substring(int i, int j) iilej-1arasındaki karakterleri içeren bir alt string döndürür. boolean contains(string substring) string’in substring içerip içermediğini kontrol eder. boolean startswith(string prefix) string’in prefixile başlayıp başlamadığını kontrol eder. boolean endswith(string postfix) string’in postfix ile bitip bitmediğini kontrol eder. int indexof(string pattern) pattern ifadesinin ilk geçtiği indeks değerini döndürür. int indexof(string pattern, int i) iindeksinden sonraki ilk pattern konumunu döndürür. string concat(string t) string’in sonuna teklenmiş halini döndürür. int compareto(string t) i̇ki string’i karşılaştırır (sözlük sırasına göre). string tolowercase() string’in tüm harflerini küçük harfe çevirir. string touppercase() string’in tüm harflerini büyük harfe çevirir. string replace(string a, string b) string içindeki a’larıbile değiştirir. string trim() string’in başındaki ve sonundaki boşlukları kaldırır. boolean matches(string regexp) string’in belirtilen regexle eşleşip eşleşmediğini kontrol eder. string[] split(string delimiter) string’idelimiter kullanarak böler ve bir dizi döndürür. boolean equals(object t) string’in değeri tile aynı mı diye kontrol eder. table 1: java string sınıfı metotları 3 import java.util.*; import java.io.*; public class main { public static void main(string[] args) throws inputexception{ if(args.length != 2){ string error = ""hata: hatali arguman kullanimi: [""; for(int i = 0;i < args.length;i++){ error = error + args[i]; if(i != args.length - 1) error = error + "", ""; } error = error + ""]. program arguman olarak 2 dosya ismi almali""; throw new wrongargumentexception(error); } scanner sc1 = null; scanner sc2 = null; try{ sc1 = new scanner(new file(args[0])); sc2 = new scanner(new file(args[1])); } catch(ioexception e){ throw new filenotfoundexception(e.tostring().split("" "")[1]); } if(!sc1.hasnextline()){ sc1.close(); sc2.close(); throw new fileempytexception(args[0]); } if(!sc2.hasnextline()){ sc1.close(); sc2.close(); throw new fileempytexception(args[1]); } string line1 = null, line2 = null; int lineidx = 0; filewriter writer = null; try{ writer = new filewriter(new file(""farklar.txt"")); } catch(ioexception e){ e.printstacktrace(); try{ sc1.close(); sc2.close(); } catch(exception ex){ ex.printstacktrace(); return; } return; } while(sc1.hasnextline() && sc2.hasnextline()){ line1 = sc1.nextline(); line2 = sc2.nextline(); while(!line1.equals(line2) && sc2.hasnextline()){ try{ writer.write(lineidx + "" -> "" + line2 + ""\n""); } catch(exception e){ e.printstacktrace(); } line2 = sc2.nextline(); } lineidx++; if(!line1.equals(line2)){ try{ sc1.close(); sc2.close(); writer.close(); } catch(exception ex){ ex.printstacktrace(); } throw new invalidchangeexception(args); } } if(sc1.hasnextline()){ try{ sc1.close(); sc2.close(); writer.close(); } catch(exception ex){ ex.printstacktrace(); } throw new invalidchangeexception(args); } while(sc2.hasnextline()){ try{ writer.write(lineidx + "" -> "" + sc2.nextline() + ""\n""); } catch(exception e){ e.printstacktrace(); } } try{ sc1.close(); sc2.close(); writer.close(); } catch(exception ex){ ex.printstacktrace(); return; } } } public class inputexception extends exception{ inputexception(string str){ super(str); } } class filenotfoundexception extends inputexception{ filenotfoundexception(string str){ super(""hata: "" + str + "" bulunamadi.""); printstacktrace(); } } class fileempytexception extends inputexception{ fileempytexception(string str){ super(""hata: "" + str + "" bos.""); printstacktrace(); } } class invalidchangeexception extends inputexception{ invalidchangeexception(string[] args){ super(""hata: "" + args[1] + "" dosyasi, "" + args[0] + ""dosyasina yalnizca yeni satirlar eklenerek olusturulmamis.""); printstacktrace(); } } public class wrongargumentexception extends inputexception{ wrongargumentexception(string error){ super(error); } } generic 1) envanter yönetim sistemi bu labda amacımı bir oyun için envanter sistemi eklemektir. item isminde bir arayüz tanımlayın: aşağıdaki metotları içermelidir: string getname() int getvalue() weapon sınıfı tanımlayın. bu sınıf item arayüzünü uygulamalıdır. int damage isimli bir özelliği olmalıdır. armor sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. int defense isimli bir değişkeni olmalıdır. potion sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. string effect isimli bir değişkeni olmalıdır. generic inventory<t> sınıfı bir arraylist kullanarak nesneleri saklamalıdır. void additem(t item): envantere istenilen eşyayı eklemeli void removeitem(t item): envanterden istenilen eşyayı silmeli void printinventory(): envanteri basmalı t mostvaluableitem(): en değerli eşyayı dönmeli t finditembyname(string name): verilen isme karşılık gelen eşyayı dönmeli. i̇simlerin unique olduğunu varsayabilirsiniz. eğer yoksa null dönün. list<t> finditemsbyvalue(int value): verilen değerden daha değerli eşyaarın listesini döndürür. int gettotalvalue(): envanterin toplam değerini döner. list<t> filterbytype(class<?> type): istenilen sınıfa ait ögeleri döner. int gettotalweapondamage(): weapon classına ait olan nesnelerin toplam hasarınıdöner. void sortbyvalue(): değeri azalan şekilde envanteri sıralamalıdır. public static void printmostvaluableitem(inventory<? extends item> inventory): verilen envanterdem en değerli eşayı ekrana basmalıdır. public static void transferarmor(inventory<? super armor> destination, inventory<armor> source): verilen hedef envantere zırhı taşımalıdır. driver class: main metodu burada olmalıdır. sadece weapon’dan oluşan ve itemdan oluşan invertory classı yazıp test ediniz. yardımcı olabilecek metotlar: class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon import java.util.*; interface item{ string getname(); int getvalue(); } class weapon implements item{ string name; int value; int damage; public weapon(string name, int value, int damage){ this.name = name; this.value = value; this.damage = damage; } public string getname(){ return name; } public int getvalue(){ return value; } } class armor implements item{ string name; int value; int defense; public armor(string name, int value, int defense){ this.name = name; this.value = value; this.defense = defense; } public string getname(){ return name; } public int getvalue(){ return value; } } class potion implements item{ string name; int value; string effect; public potion(string name, int value, string effect){ this.name = name; this.value = value; this.effect = effect; } public string getname(){ return name; } public int getvalue(){ return value; } } class inventory<t extends item>{ arraylist<t> list; public inventory(){ list = new arraylist<>(); } void additem(t item){ list.add(item); } void removeitem(t item){ list.remove(item); } void printinventory(){ for(t item:list){ system.out.println(item.getname()); } } t mostvaluableitem(){ if(list.size() == 0) return null; t ret = list.get(0); for(int i = 1;i < list.size();i++){ if(list.get(i).getvalue() > ret.getvalue()) ret = list.get(i); } return ret; } t finditembyname(string name){ for(t item:list){ if(item.getname().equals(name)) return item; } return null; } arraylist<t> finditemsbyvalue(int value){ arraylist<t> retlist = new arraylist<t>(); for(t item:list){ if(item.getvalue() > value) retlist.add(item); } return retlist; } int gettotalvalue(){ int total = 0; for(t item:list) total += item.getvalue(); return total; } arraylist<t> filterbytype(class<?> type){ arraylist<t> retlist = new arraylist<>(); for(t item:list){ class<?> currentclass = item.getclass(); if(type.getname().equals(currentclass.getname())) retlist.add(item); } return retlist; } int gettotalweapondamage(){ int total = 0; for(t item:list){ class<?> currentclass = item.getclass(); if(currentclass.getname().equals(""weapon"")) total += ((weapon)item).damage; } return total; } void sortbyvalue(){ for(int i = 0;i < list.size();i++){ for(int j = 1;j < list.size();j++){ t item1 = list.get(j-1); t item2 = list.get(j); if(item1.getvalue() < item2.getvalue()){ list.set(j-1, item2); list.set(j, item1); } } } } public static void printmostvaluableitem(inventory<? extends item> inventory){ system.out.println(inventory.mostvaluableitem().getname()); } public static void transferarmor(inventory<? super armor> destination, inventory<armor> source){ for(armor armor:source.list){ destination.additem(armor); } } } public class driver { public static void main(string[] args) { inventory<item> inventory = new inventory<>(); armor ar = new armor(""armor10"", 10, 20); inventory.additem(ar); inventory.additem(new weapon(""weapon11"", 11, 25)); inventory.additem(new potion(""potion12"", 12, ""potipoti"")); inventory.additem(new weapon(""weapon23"", 23, 51)); inventory.sortbyvalue(); inventory.printinventory(); inventory.printmostvaluableitem(inventory); system.out.println(inventory.gettotalweapondamage()); system.out.println(inventory.gettotalvalue()); system.out.println(""-------------------------""); class<?> cls = potion.class; arraylist<item> list = inventory.filterbytype(cls); for(item item:list){ system.out.println(item.getname()); } system.out.println(""-------------------------""); inventory.removeitem(ar); inventory.printinventory(); system.out.println(""-------------------------""); inventory<armor> armors = new inventory<>(); armors.additem(new armor(""a1"", 1, 1)); armors.additem(new armor(""a2"", 2, 2)); armors.additem(new armor(""a3"", 3, 3)); armors.additem(new armor(""a4"", 4, 4)); inventory.transferarmor(inventory, armors); inventory.printinventory(); item tt = inventory.finditembyname(""a4""); system.out.println(tt.getname() + "" "" + tt.getvalue()); system.out.println(""-------------------------""); list = inventory.finditemsbyvalue(3); for(item item:list){ system.out.println(item.getname()); } system.out.println(""-------------------------""); } } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. özyinelemedir. bir fonksiyon kendisini çağırıyorsa recursive olur recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. recursion'un bitirildiği case'dir. base case'e girince fonksiyon bir kez daha kendisini çağırmaz bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? sondaki harf + f(str.substring(0, uzunluk-1)). base case, stringing 0 uzunluğunda olduğu case olur recursive bir metotta base case olmazsa ne olur? sonsuza kadar kendini çağırmaya devam eder, stackoverflow olur recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. her bir çağırma, stack'e bir katman daha ekler. recursion bittiğinde ise katmanlar birer birer işlenir fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. n'inci fibonacci sayısı için 2^n kez fonksiyon çağırılır tail recursion nedir, kısaca açıklayınız. fonksiyonun en sonunda return ifadesi ile beraber recursionun çağırılmasıdır abstraction kavramını açıklayınız. bir nesnenin özelliklerini çıkartarak değişkenlerden ve metotlardan oluşan bir class/blueprint yaratmaktır ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? inheritance ilişkisi olduğunda ""is a"" olur. ""class a extends b"" ifadesiyle belirtilir bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? protected ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? a veya b java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? o class initialize edilmeden önce tüm ata class değişkenlerinin ve metotlarının setlenmesi gerekmektedir java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? hayır metot overriding ve overloading kavramlarını açıklayınız. override, ata classta tanımlı bir metot ile aynı signature'e sahip bir metodu child classta tanımlamaktır. overload ise aynı isme sahip ama farklı signature'u bulunan metotlar tanımlamaktır class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dog \n bark! class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? circle \n 8.0 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? kullanılacak metodun hangi tanıma göre kullanılacağını belirlemektir. statik ve dinamik olabilir hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? overriding olmayan veya override edilemeyen metodlarda static, overriding olan metodlarda dinamik binding yapılır. static binding için final keywordu kullanılır dinamik bağlamada jvm'nin görevi nedir? metodun tanımını runtime'da bulmaktır java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? kod daha yavaş çalışırdı java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? compiler error alırız java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. bir canlı yemek yiyebiliyorsa bir köpek de yemek yiyebilmelidir. protected bir metod public olarak override edilebilir class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? p.special() komutu çalışmayacaktır ve compiler error alınacaktır. bu satır silindikten sonra output ""child special"" olacaktır. dinamik binding bulunuyor java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? i̇çinde abstract metodların bulunduğu classlara abstract class denir. ikisinin de constructurları olamaz abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? evet. abstarct keywordu kullanılarak. fonksiyonun tanımı yapılmaz abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract metodları tanımı yapılmaz. concrete hale getirilmek istendiğinde yapılır. abstract classlar, atası olduğu classlara ""şunu şunu implement etmek zorundasın"" der. abstract classları polymorphism için kullanabiliriz abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract classlar bir classtır, extend edilirler. interfaceler class değildir. implement edilirler. evet type olarak kullanılabilir marker interface ve functional interface kavramları nedir, nasıl kullanılır? ( ´_ゝ`) marker interface bi blueprint görevi görür. i̇çindeki metodlar tanımsızdır. functional interface'in içinde tanımı olan metodlar bulunur bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? edebilir. edebilir abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? new animal() yerine new dog() yazarız. output: animal: buddy woof interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? etmez. birden fazla move() tanımı var. i̇kisinden birini silmemiz lazım. sonrasında hangisini sildiysek diğerini outputlar. java'da inner class nedir, avantajları nelerdir? class içindeki class'tır. class içinde tekrar tekrar kullanılan yapıları bir çatı altında toplamaya yarar statik ve statik olmayan (member) inner class arasındaki temel fark nedir? statik inner class objesini, class dışında, class objecti oluşturmadan oluşturabiliyoruz. statik değil ise inner class objesi oluşturmak için outet class objesi oluşturmamız gerekiyor anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? ismi olmayan ve tek bir obje özelinde oluşturulan classlardır. her türlü classtan ve interface'den oluşturulabilir. yeter ki gerekli metodlar tanımlansın inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? evet. evet. daha fazla fonksiyonalite sağlar statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? hayır. çünkü inner class static değil ise inner classın outer classından bir obje oluşturulmadığı sürece inner classın içindeki herhangi bir şey var olmayacağından dolayı static keywordunun bir anlamı kalmıyor anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? olamaz çünkü tek seferliktirler. inner class, outer class içinde başka bir classtır. anonymous class ise bir classın veya interface'in kullanılarsk tek bir seferlik bir obje üretilmesidir. hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? private olmayanlar class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? (new outer()).new inner() olması gerekiyor. output: value: 10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? hata yok gibi. output: count: 5 text file ile binary file arasındaki fark nedir? txt dosyası veriyi txt olarak okur binary dosya binary olarak bir dosyaya yazarken düzenli olarak flush yapmamak neye yol açabilir? cache'e fazla yüklenmiş oluruz binary bir dosyaya bir object yazdırırken bu objenin hangi interfaceyi implement etmesi gerekiyor? bu interfacenin metotlarını sıralayınız. bu interface functional veya marker bir interface midir? serializable, metodu yok, marker interface binary bir dosyaya primitive typeler (int, float, char etc.) yazılabilir mi, evet ise nasıl? evet. binary değerleri yazılır buffered reader ve scanner sınıfları ile dosya okurken dosyanın sonuna geldiğini nasıl kontrol edilir? read etmeye çalışmamıza rağmen null döndürüyosa sonundayızdır binary bir dosya okurken dosyanın sonuna gelindiği nasıl test edilir? read etmeye çalışmamıza rağmen null döndürüyosa sonundayızdır public class randomaccessdemo { public static void main(string[] args) throws exception { randomaccessfile raf = new randomaccessfile(""numbers.bin"", ""rw""); raf.writeint(10); raf.writeint(20); raf.seek(0); int a = raf.readint(); raf.seek(7); byte b = raf.readbyte(); system.out.println(a + "" "" + b); raf.close(); } } output? 10 + 20 public class demo { public static void main(string[] args) throws exception { try{ fileoutputstream fos = new fileoutputstream(""log.txt"", true); printwriter pw = new printwriter(fos); pw.println(""new log entry""); throw new exception(); } catch(exception e){ system.err(""oopps!""); } } } bu kod çalıştırıldığında log.txt dosyası nasıl etkilenir, açıklayınız. ""new log entry"" yazar what grade (a, b, c, d, or f) do you expect to earn by the end of this course? bb java'da generic kavramı nedir, bu kavramın temel amacı nedir? genel tipli classlar yazmaya yarayan bir araç. spesifik bir tip yerine initialization sürecinde belirlenecek bir tip ile class oluşturulmasına yarar bir wildcard'ı ne zaman sınırlamaya ihtiyaç duyarsınız, sınırlandığı ve sınırlanmadığı durumlar için birer örnek veriniz. boundları hangi keywordlerle ifade edersiniz? eğer belli bir classın altına veya üstüne ihtiyaç duyuyorsam sınırlandırırım <? extends class> ve <? super class> ile sınırlandırılabilir jenerik olmayan bir class jenerik bir metot içerebilir mi? açıklayınız. i̇çerebilir örneğin void foo<t>() mygenericclass<integer> ve mygenericclass<number> classları arasında kalıtım(child-parent) ilişkisi nasıldır, açıklayınız. number olan integer olanın parentıdır class node<t>{ t[] data = new t[10]; } //psvm node<string> stringnode = new node<>(); bu kodda bir hata var mı? (varsa) bu hata nedir, nedenini açıklayınız. (varsa) bu hata nasıl düzeltilmeli, kodun doğru halini yazınız. ? public _____________ { double sum = 0.0; for (t item : list) { sum += item.doublevalue(); } return sum / list.size(); } public static void main(string[] args) { list<integer> integers = arrays.aslist(1, 2, 3, 4); list<double> doubles = arrays.aslist(1.5, 2.5, 3.5); main m = new main(); system.out.println(average(integers)); system.out.println(average(doubles)); } yukarıda boşluk bırakılan yeri doldurun. not: metodun jenerik olduğuna, çağırılma biçimine ve jenerik tipine dikkat edin! boşluğu doldurduktan sonra programın çıktısı ne olur? average(list<? extends numbers> list) 2.5 2.5 aşağıda tanımı verilmiş node classının birbirlerine bağlanmış nodelerinden ilkini alan ve hepsini 1 defa sağa kaydıran metodu nasıl yazardınız, stratejiniz ne olurdu? peki ya n defa sağa kaydırma işlemini nasıl yapardınız? n defa kaydırma çözümünüz sizce optimal olan çözüm mü, neden? örnek: başlangıçta: a -> b -> c metodu a ile çağırdığıktan sonra: c -> a -> b ayrıca metot en başa gelen nodeyi dönmelidir (bu örnekte c dönmeli). class node{ int data; node next; } static node rotate(node head){...} node n1 = head, n2 = head.next (burads null olur mu diye ifle kontrol ederdim) .sonrasında n2.next null olana kadar {n1=n2, n2=n2.next}. sonra n1.next =null ve n2.next = head. return n2 arraylist ve linkedlist veri yapılarını kıyaslayınız, aralarındaki farkları açıklayınız. arraylist arraydir. veriler memoryde ardışıktır. linkedlistte veriler ardışık değildir. pointerla sonraki veriye geçilir collections interfacesindeki metotlar temel olarak hangi işlevleri yerine getiriyor? ekleme çıkarma var mı diye kontrol etme boyut verme vb kendi yazdığınız bir classta veri yapilarını istenilen şekilde (mesela hashset'te duplicate objelerin olmamasi) kullanabilmek için object classının hangi metotlarını override etmek gerekir, neden? add, remove check bir dijital kütüphane uygulaması geliştiriyorsunuz. bu uygulamada, öğrenciler araştırma projeleri için kaynak ekliyor ve sistem, en son eklenen kaynağı ilk olarak görüntülemek üzere tasarlanıyor. öğrenciler, ekledikleri kaynakların boyut sırasına göre tekrar gözden geçebilmek istiyorlar. bu durumda, hangi veri yapısını tercih edersiniz? neden? stack fifo nedir, açıklayınız ve aşağıdakı veri yapılarını fifo/lifo şeklinde sınıflandırınız: stack queue map priorityqueue first in first out lifo, fifo, ikisi de değil, ikisi de değil public class demo { public static void main(string[] args) { stack<integer> stack = new stack<>(); stack.push(10); stack.push(20); stack.push(30); system.out.println(stack.pop()); system.out.println(stack.peek()); system.out.println(stack.pop()); } } output? 30 20 20 public class test { public static void main(string[] args) { map<string, integer> scores = new hashmap<>(); scores.put(""alice"", 95); scores.put(""bob"", 85); scores.put(""charlie"", 90); scores.put(""alice"", 100); system.out.println(scores.get(""alice"")); system.out.println(scores.size()); } } output? 100 3 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.*; public class lab2q1 { public static boolean check(string str){ int cnt = 0; for(int i = 0;i < str.length();i++){ if(str.charat(i) == ')'){ if(cnt == 0) return false; cnt--; } else{ cnt++; } } if(cnt == 0) return true; return false; } public static void parantezbasiterative(int n){ int val = (int)math.pow(2, 2*n); for(int i = 0;i < val;i++){ string str = """"; for(int j = 0;j < 2*n;j++){ if(((int)math.pow(2, j) & i) == 0) str = str + '('; else str = str + ')'; } if(check(str)) system.out.println(str); } } public static void parantezbasrecursive(int n, string str){ if(str.length() == 2*n){ if(check(str)) system.out.println(str); return; } parantezbasrecursive(n, str + '('); parantezbasrecursive(n, str + ')'); } public static void main(string[] args) { scanner sc = new scanner(system.in); int n = sc.nextint(); parantezbasrecursive(n, """"); sc.close(); } } import java.util.*; class penguin{ private string name; private string species; private int age; private double weight; public penguin(){ this(""willy"", ""emperor"", 1, 5.0); } public penguin(string name, string species, int age, double weight){ setname(name); setspecies(species); setage(age); setweight(weight); } public void setname(string name){ this.name = name; } public void setspecies(string species){ this.species = species; } public void setage(int age){ this.age = age; } public void setweight(double weight){ this.weight = weight; } public string getname(){ return name; } public string getspecies(){ return species; } public int getage(){ return age; } public double getweight(){ return weight; } public void hunt(){ age++; } public void printpenguin(){ system.out.println(""penguin name: "" + name + ""\tspecies:"" + species + ""\tage:"" + age + ""years "" + ""\t weight:"" + weight + "" kg""); } } class habitat{ private string location; private double temperature; private arraylist<penguin> penguins; public habitat(string location, double temperature){ setlocation(location); settemperature(temperature); penguins = new arraylist<penguin>(); } public void setlocation(string location){ this.location = location; } public void settemperature(double temperature){ this.temperature = temperature; } public string getlocation(){ return location; } public double gettemperature(){ return temperature; } public void addpenguin(penguin penguin){ penguins.add(penguin); } public void printhabitat(){ system.out.println(""habitat location: "" + location); system.out.println(""average temperature: "" + temperature + ""°c""); system.out.println(""penguins living in here:""); for(penguin penguin:penguins){ penguin.printpenguin(); } } } public class lab2q2 { public static void main(string[] args) { scanner sc = new scanner(system.in); penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); habitat habitat = new habitat(""antarctica"", -15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); sc.close(); } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 import java.util.*; public class main { public static void main(string[] args) { scanner sc = new scanner(system.in); coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); machine.printcoffeecounter(); sc.close(); } } public interface coffeeaddon{ double getcost(); string getname(); } class milk implements coffeeaddon{ final double cost = 5; final string name = ""milk""; public double getcost(){ return cost; } public string getname(){ return name; } } class chocolate implements coffeeaddon{ final double cost = 7; final string name = ""chocolate""; public double getcost(){ return cost; } public string getname(){ return name; } } class vanillasyrup implements coffeeaddon{ final double cost = 6; final string name = ""vanillasyrup""; public double getcost(){ return cost; } public string getname(){ return name; } } class doubleshot implements coffeeaddon{ final double cost = 10; final string name = ""doubleshot""; public double getcost(){ return cost; } public string getname(){ return name; } } import java.util.*; public abstract class basecoffee{ protected arraylist<coffeeaddon> addons; basecoffee(){ addons = new arraylist<coffeeaddon>(); } public void addaddon(coffeeaddon addon){ addons.add(addon); }; public abstract double calculateprice(); public abstract string gettype(); } class espresso extends basecoffee{ private string type = ""espresso""; private boolean isheated = false; public string gettype(){ if(isheated) return type + "" (sicak fincan)""; else return type; } public void heatcup(){ isheated = true; } public double calculateprice(){ double price = 40; for(coffeeaddon addon:addons){ price += addon.getcost(); } return price; } } class latte extends basecoffee{ private string type = ""latte""; public string gettype(){ return type; } public double calculateprice(){ double price = 50; for(coffeeaddon addon:addons){ price += addon.getcost(); } return price; } } class americano extends basecoffee{ private string type = ""americano""; public string gettype(){ return type; } public double calculateprice(){ double price = 45; for(coffeeaddon addon:addons){ price += addon.getcost(); } return price; } } public class coffeemachine{ static int counter = 0; private boolean isaddoncompatible(basecoffee coffee, coffeeaddon addon){ if(coffee instanceof espresso){ return addon.getname().equals(""doubleshot"") || addon.getname().equals(""chocolate""); } if(coffee instanceof latte){ return addon.getname().equals(""milk"") || addon.getname().equals(""vanillasyrup"") || addon.getname().equals(""chocolate""); } if(coffee instanceof americano){ return addon.getname().equals(""milk"") || addon.getname().equals(""vanillasyrup""); } return false; } public void addaddontocoffee(basecoffee coffee, coffeeaddon addon){ if(!isaddoncompatible(coffee, addon)){ system.out.println(""[uyari]"" + coffee.gettype() + "" tipi kahveye "" + addon.getname() + "" eklenemez\n""); return; } coffee.addaddon(addon); } public void makecoffee(basecoffee coffee){ counter = counter + 1; system.out.print(""siparis: "" + coffee.gettype()); for(coffeeaddon addon:coffee.addons){ system.out.print("" + "" + addon.getname()); } system.out.println(""\ntoplam fiyat: "" + coffee.calculateprice() + ""\n""); } public void heatespressocup(basecoffee coffee){ if(coffee instanceof espresso){ ((espresso)coffee).heatcup(); system.out.println(""espresso kahve fincani isitildi \n""); return; } system.out.println(""[uyari] yalnizca espresso kahve fincanlari isitilabilir""); } public void printcoffeecounter(){ system.out.println(""tum kahve makineleri tarafindan toplam "" + counter + "" kahve uretildi""); } } bil211 quiz 4 section 1 quizleri uzak sistemine yükleyeceksiniz. q1: yalnızca tek sayıları saklayan liste oddnumberlist adında bir sınıf oluşturun. bu sınıf: ● add(t item) → yalnızca tek sayılar eklenebilir. çift sayı eklenmeye çalışılırsa hata mesajı basılır. ● addall(collection<t> collection) → sadece içindeki tek sayıları ekler. ● getoddnumbers() → i̇çerideki tüm tek sayıları liste olarak döndürür. ● sumofodds() → tüm tek sayıların toplamını döndürür. örnek kullanım: oddnumberlist list = new oddnumberlist(); list.add(5); list.add(3); list.add(8); // eklenmemeli system.out.println(list); // çıktı: [5, 3] q2: koleksiyondan tekrar edenleri kaldırma ● bir collection<t> içindeki tüm tekrar eden öğeleri kaldıran bir generic metod yazın. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> removeduplicates(collection<t> collection) { // metodu tamamlayın } örnek kullanım: list<string> words = arrays.aslist(""apple"", ""banana"", ""apple"", ""orange"", ""banana"", ""grape""); system.out.println(removeduplicates(words)); q3:aşağıdaki generic metodu tamamlayın. ● verilen list<t> içindeki tüm öğeleri büyük harfe çeviren (veya sayıysa olduğu gibi bırakan) bir metod yazın. ● eğer t bir string ise büyük harfe çevirmeli, değilse değiştirmemelidir. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> converttouppercaseifstring(list<t> list) { // metodu tamamlayın } örnek kullanım: list<object> items = arrays.aslist(""hello"", 123, ""world"", 456); system.out.println(converttouppercaseifstring(items)); import java.util.*; public class q2 { public static <t> list<t> removeduplicates(collection<t> collection){ arraylist<t> list = new arraylist<>(); for(t item:collection){ if(list.contains(item)) continue; list.add(item); } return (list<t>)list; } public static void main(string[] args){ list<string> words = arrays.aslist(""apple"", ""banana"", ""apple"", ""orange"", ""banana"",""grape""); system.out.println(removeduplicates(words)); } } import java.util.*; class oddnumberlist<t extends integer>{ arraylist<t> list; public oddnumberlist(){ list = new arraylist<>(); } public void add(t item){ if(item.intvalue() % 2 == 0){ system.err.println(""sadece tek sayilar eklenebilir""); return; } list.add(item); } public void addall(collection<t> collection){ for(t item:collection) add(item); } public list<t> getoddnumbers(){ return (list<t>)list; } public int sumofodds(){ int sum = 0; for(t item:list) sum += item.intvalue(); return sum; } public string tostring(){ string ret = ""[""; for(int i = 0;i < list.size();i++){ ret = ret + list.get(i); if(i != list.size() - 1) ret = ret + "", ""; } ret = ret + ""]""; return ret; } } public class q1 { public static void main(string[] args){ oddnumberlist<integer> list = new oddnumberlist<>(); list.add(5); list.add(3); list.add(8); system.out.println(list); } } import java.util.*; public class q3 { @suppresswarnings(""unchecked"") public static <t> list<t> converttouppercaseifstring(list<t> list) { arraylist<t> ret = new arraylist<>(); for(t item:list){ if(item instanceof string){ string string = new string((string) item); ret.add((t)string.touppercase()); } else ret.add(item); } return (list<t>)ret; } public static void main(string[] args){ list<object> items = arrays.aslist(""hello"", 123, ""world"", 456); system.out.println(converttouppercaseifstring(items)); } } //instanceof 4 kuş bakışı atış oyunu (top-down shooter) bil 211 - proje teslim tarihi: 27 mart 2025 23:59 1 amaç bu ödevde amacınız, java swing kullanarak kuş bakışı bir atış oyunu (top-down shooter) tasarlamaktır. oyunda, yönettiğimiz karakterin üzerine dalga dalga gelen çeşitli zombileri fare ile hedef alarak farklı silahlar kullanıp öldürmemiz gerekmektedir. karakterimiz öldüğünde oyun sona erecektir. her dalga başına ve öldürülen zombi başına kazanılan puan artacaktır. dalgalar ilerledikçe gelen zombilerin sayısı ve çeşitleri artarak zorluk seviyesi yükselecektir. 2 gereksinimler oyun derste öğrendiğiniz oop ilkelerine uygun sınıf/arayüz tasarımları ile geliştirilmelidir. - zorluk seviyesi arttıkça zombi sayısı ve çeşitliliği artmalıdır. - oyun duraklatılabilmeli ve kaydedilip tekrar yüklenilebilmelidir (fileio kullanılmalıdır). - sol üst köşede seçili silah ve kalan mermi miktarı gösterilmelidir. - sağ üst köşede oyuncunun canı ve toplam puanı gösterilmelidir. - oyunun duraklatılması, kaydedilmesi ve devam ettirilmesi için bir menü bulunmalıdır. 3 silahlar oyunda farklı silahlar bulunmaktadır. belirli zombi dalgaları temizlendikten sonra oyun ödül olarak yeni bir silahverecektir. hersilahınkendineözgübirçalışmamekanizmasıvardır. silahlarınşarjörkapasitesisınırlıdır ve şarjördeki mermiler bittiğinde tekrar doldurulmadan ateş edilemez. toplam mermi sayısı oyuncunun o silaha ait elinde ne kadar mermi olduğunu gösterir. r tuşuna basarak şarjör yeniden doldurulabilir. 3.1 tabanca - şarjör kapasitesi: 12 mermi - ateş hızı: 120 mermi/dakika - elde etme: oyuncu oyuna bu silahla başlar. - özellik: düz atış yapar, sapma yoktur. sınırsız yedek şarjör (diğer tüm silahlar için yedek şarjör ve mermiler rastgele bir şekilde dalga sırasında ve sonlarında zombilerden düşer). 3.2 piyade tüfeği - şarjör kapasitesi: 30 mermi - ateş hızı: 600 mermi/dakika - elde etme: 1. dalga tamamlandıktan sonra - özellik: düzatışyaparancak30derecesapmasıvardır. sapmaaçısı, karakterinbaktığıyöndemerminin her iki dönme yönüne de saçılabileceği maksimum açıdır. 1 3.3 pompalı tüfek - şarjör kapasitesi: 5 mermi - ateş hızı: 60 mermi/dakika - elde etme: 3. dalga tamamlandıktan sonra - özellik: her atış 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi atar (yani karakter merkezli mermi hız vektörleri arasında 5 derece açı olmalıdır). 3.4 keskin nişancı tüfeği - şarjör kapasitesi: 5 mermi - ateş hızı: 30 mermi/dakika - elde etme: 5. dalga tamamlandıktan sonra - özellik: mermileri zombileri delip arasındaki zombilere de hasar verir. 3.5 roketatar - şarjör kapasitesi: 1 roket - ateş hızı: 10 roket/dakika - elde etme: 10. dalga tamamlandıktan sonra - özellik: patlama etkisiyle birden fazla zombiye zarar verir. 4 zombiler zombiler oyundaki düşman tipleridir. zombiler oyuncuya doğru ilerlerler ve eğer oyuncuya temas ederlerse oyuncuya hasar verirler. zorluk seviyesi arttıkça zombilerin sayısı ve çeşitliliği artmaktadır. zombi tipleri birbirinden renk ya da şekil olarak ayırt edilebilmelidir. 4.1 normal zombi - can: orta - hız: yavaş - hasar: orta 4.2 sürünge zombi - can: düşük - hız: hızlı - hasar: orta - özellik: oyuncunun yakınına geldiğinde zıplar. 4.3 tank zombi - can: yüksek - hız: çok yavaş - hasar: yüksek 2 4.4 asit tüküren zombi - can: düşük - hız: yavaş - hasar: orta (uzaktan asit tükürebilir) - özellik: öldürüldüğünde yanındaki birimlere zarar verir. 5 rapor ve teslim formatı - oyun, oopprensiplerineuygunolaraktasarlanmalıvesınıfdiyagramları, arayüztasarımıfinalraporda sunulmalıdır. - oyun test edilerek ekran görüntüleri rapora eklenmelidir. - rapor pdf formatında olmalı ve ismi proje_rapor.pdf olmalıdır. - oyunun mainfonksiyonu gameisimli bir sınıf içinde bulunmalıdır ( java game komutuyla çalışmalı). - kaynak kodun tamamı source.zip (uzantı 7z, rar, tar.gz de olabilir) şeklinde sıkıştırılmış olmalıdır. - sıkıştırılmış kaynak kod ve rapor uzak sistemine yüklenmelidir. 6 yardımcı kaynaklar dahaöncehiçkuşbakışıatışoyunuoynamadıysanızaşağıdakioyunlarıreferansolarakalabilirsiniz. buradaki oyunlarıngrafikleriilemekaniklerisizdenbeklenendenfarklıolsadaharitatasarımı, karakterhareketi,kamera hareketi, ateş etme mekanikleri ve zombilerin yapay zekası ile ilgili temel fikirler edinebilirsiniz. - little top-down shooter: https://www.youtube.com/watch?v=pj3m3fu3i5a - super c - stage 2: https://www.youtube.com/watch?v=os2t_v5suj4 - neon chrome: https://www.youtube.com/watch?v=puhw1bevtro 3 //import javax.swing.*; import java.awt.*; //import java.awt.event.*; import java.util.arraylist; //import java.util.list; import java.time.localtime; class zombie extends circle{ double health, speed, damage, point; public zombie(double x, double y, double radius, color color, double health, double speed, double damage) { super(x, y, radius, color); this.health = health; this.speed = speed; this.damage = damage; } } class normalzombie extends zombie{ public normalzombie(double x, double y){ super(x, y, 20, new color(0x076208), 100, 2, 0.5); point = 10; } } class crawlerzombie extends zombie{ boolean isjumping = false; double jumptargetx, jumptargety; int lastjump = 0; public crawlerzombie(double x, double y){ super(x, y, 17, new color(0x6b9c10), 30, 1.5, 0.5); point = 15; } public void jump(player player){ if(localtime.now().tosecondofday() - lastjump < 10) return; isjumping = true; jumptargetx = player.x; jumptargety = player.y; color = color.black; lastjump = localtime.now().tosecondofday(); } } class tankzombie extends zombie{ public tankzombie(double x, double y){ super(x, y, 30, new color(0x172300), 500, 1, 3); point = 30; } } class spitterzombie extends zombie{ double spittingdistance = 50; int lastspit = 0; public spitterzombie(double x, double y){ super(x, y, 17, color.blue, 30, 1, 0.5); point = 25; } //public acidspit(double x, double y, double radius, color color, double damage, double speedx, double speedy, double maxdistance, int duration) { public void spit(arraylist<acidspit> spits, player player){ if(localtime.now().tosecondofday() - lastspit < 5) return; double vx = player.x - this.x; double vy = player.y - this.y; double distance = math.sqrt(vx * vx + vy * vy); double spitspeed = 1; vx *= spitspeed / distance; vy *= spitspeed / distance; acidspit spit = new acidspit(this.x, this.y, 5, new color(0x37f313), 0.2, vx, vy, distance, 10); spits.add(spit); lastspit = localtime.now().tosecondofday(); } } //import javax.swing.*; import java.awt.*; //import java.lang.reflect.array; //import java.awt.event.*; //import java.util.arraylist; //import java.util.list; import java.util.arraylist; import java.time.localtime; public abstract class gun extends line{ double damage, firerate, spreadangle, length; int magazinecap, totalbulletcount, bulletsinmag; long lastfired = 0; string name; public gun(double damage, double firerate, double spreadangle, int magazinecap, int totalbulletcount){ super(0, 0, 0, 0, 0, color.black); this.damage = damage; this.firerate = firerate; this.spreadangle = spreadangle; this.magazinecap = magazinecap; this.totalbulletcount = totalbulletcount; this.bulletsinmag = magazinecap; } public void rotate(double degree){ double radian = degree * math.pi / 180; double dx = length * math.cos(radian); double dy = length * math.sin(radian); x2 = x1 + dx; y2 = y1 + dy; } public void rotate(double mousex, double mousey){ double dx = mousex - x1; double dy = mousey - y1; double dist = math.sqrt(dx * dx + dy * dy); dx *= length / dist; dy *= length / dist; x2 = x1 + dx; y2 = y1 + dy; } public void reload(){ int required = magazinecap - bulletsinmag; int available = math.min(required, totalbulletcount); bulletsinmag += available; totalbulletcount -= available; } public abstract void fire(arraylist<bullet> bullets); } class pistol extends gun{ public pistol(double playerx, double playery){ super(30, 2, 0, 12, -1); x1 = playerx; y1 = playery; thickness = 5; length = 25; x2 = x1 + length; y2 = y1; color = color.black; name = ""pistol""; } public void reload(){ bulletsinmag = magazinecap; } public void fire(arraylist<bullet> bullets){ if(bulletsinmag == 0) return; if(localtime.now().tonanoofday() - lastfired < 1e9/firerate) return; double vx = x2 - x1; double vy = y2 - y1; double bulletspeed = 5; vx *= bulletspeed / length; vy *= bulletspeed / length; bullet bullet = new bullet(x1, y1, 2, color.black, damage, vx, vy, false, false); bullets.add(bullet); lastfired = localtime.now().tonanoofday(); bulletsinmag--; } } class rifle extends gun{ public rifle(double playerx, double playery){ super(45, 10, 30, 30, 60); x1 = playerx; y1 = playery; thickness = 6; length = 30; x2 = x1 + length; y2 = y1; name = ""rifle""; } public void fire(arraylist<bullet> bullets){ if(bulletsinmag == 0) return; if(localtime.now().tonanoofday() - lastfired < 1e9/firerate) return; double dx = x2 - x1; double dy = y2 - y1; double radius = math.atan2(dy, dx); radius += (math.random() - 0.5) * math.toradians(spreadangle); double bulletspeed = 10; double speedx = bulletspeed * math.cos(radius); double speedy = bulletspeed * math.sin(radius); bullet bullet = new bullet(x1, y1, 2.2, color.black, damage, speedx, speedy, false, false); bullets.add(bullet); lastfired = localtime.now().tonanoofday(); bulletsinmag--; } } class shotgun extends gun{ public shotgun(double playerx, double playery){ super(35, 1, 45, 5, 15); x1 = playerx; y1 = playery; thickness = 8; length = 28; x2 = x1 + length; y2 = y1; name = ""shotgun""; } public void fire(arraylist<bullet> bullets){ if(bulletsinmag == 0) return; if(localtime.now().tonanoofday() - lastfired < 1e9/firerate) return; double dx = x2 - x1; double dy = y2 - y1; double baseangle = math.atan2(dy, dx); int numberofpellets = 9; double totalspreadangledegrees = 45; double anglestepdegrees = totalspreadangledegrees / (numberofpellets - 1); double bulletspeed = 7; for (int i = 0; i < numberofpellets; i++) { double pelletangle = baseangle - math.toradians(totalspreadangledegrees / 2) + math.toradians(i * anglestepdegrees); double speedx = bulletspeed * math.cos(pelletangle); double speedy = bulletspeed * math.sin(pelletangle); bullet bullet = new bullet(x1, y1, 2.5, color.black, damage, speedx, speedy, false, false); bullets.add(bullet); } lastfired = localtime.now().tonanoofday(); bulletsinmag--; } } class sniper extends gun{ public sniper(double playerx, double playery){ super(80, 0.5, 0, 5, 10); x1 = playerx; y1 = playery; thickness = 6; length = 35; x2 = x1 + length; y2 = y1; name = ""sniper""; } public void fire(arraylist<bullet> bullets){ if(bulletsinmag == 0) return; if(localtime.now().tonanoofday() - lastfired < 1e9/firerate) return; double dx = x2 - x1; double dy = y2 - y1; double radius = math.atan2(dy, (dx + 1e-9)); radius += (math.random() - 0.5) * spreadangle; double bulletspeed = 12; double speedx = bulletspeed * math.cos(radius); double speedy = bulletspeed * math.sin(radius); bullet bullet = new sniperbullet(x1, y1, 2.3, color.black, damage, speedx, speedy, false, true); bullets.add(bullet); lastfired = localtime.now().tonanoofday(); bulletsinmag--; } } class rocketlauncher extends gun{ public rocketlauncher(double playerx, double playery){ super(120, 1.0/6, 0, 1, 3); x1 = playerx; y1 = playery; thickness = 10; length = 30; x2 = x1 + length; y2 = y1; name = ""rocket launcher""; } public void fire(arraylist<bullet> bullets){ if(bulletsinmag == 0) return; if(localtime.now().tonanoofday() - lastfired < 1e9/firerate) return; double dx = x2 - x1; double dy = y2 - y1; double radius = math.atan2(dy, dx); radius += (math.random() - 0.5) * spreadangle; double bulletspeed = 4; double speedx = bulletspeed * math.cos(radius); double speedy = bulletspeed * math.sin(radius); bullet bullet = new bullet(x1, y1, 4, color.red, damage, speedx, speedy, true, false); bullets.add(bullet); lastfired = localtime.now().tonanoofday(); bulletsinmag--; } } //import javax.swing.*; import java.awt.*; //import java.awt.event.*; //import java.util.arraylist; //import java.util.list; //import java.lang.reflect.array; import java.util.arraylist; public class bullet extends circle{ double damage, speedx, speedy; boolean ishit = false, isexplosive, canpenetrate; public bullet(double x, double y, double radius, color color, double damage, double speedx, double speedy, boolean isexplosive, boolean canpenetrate) { super(x, y, radius, color); this.damage = damage; this.speedx = speedx; this.speedy = speedy; this.isexplosive = isexplosive; this.canpenetrate = canpenetrate; } } class acidspit extends bullet{ double maxdistance; boolean hashitground = false; long timeofimpact = -1, duration; public acidspit(double x, double y, double radius, color color, double damage, double speedx, double speedy, double maxdistance, long duration) { super(x, y, radius, color, damage, speedx, speedy, false, false); this.damage = damage; this.speedx = speedx; this.speedy = speedy; this.duration = duration; this.maxdistance = maxdistance; } } class sniperbullet extends bullet{ arraylist<zombie> hits; public sniperbullet(double x, double y, double radius, color color, double damage, double speedx, double speedy, boolean isexplosive, boolean canpenetrate) { super(x, y, radius, color, damage, speedx, speedy, isexplosive, canpenetrate); hits = new arraylist<>(); } } //import javax.swing.*; import java.awt.*; //import java.awt.event.*; //import java.util.arraylist; //import java.util.list; public class circle{ double x, y, vx, vy, radius; color color; public circle(double x, double y){ this(x, y, 1e-8, color.black); } public circle(double x, double y, double radius, color color) { this.x = x; this.y = y; this.radius = radius; this.color = color; } public void draw(graphics2d g2d){ g2d.setcolor(color); g2d.filloval((int)math.round(x-radius), (int)math.round(y-radius), (int)(radius*2), (int)(radius*2)); } public double distance(circle othercircle){ double dx = this.x - othercircle.x; double dy = this.y - othercircle.y; return math.sqrt(dx * dx + dy * dy); } boolean intersects(circle othercircle){ double dx = this.x - othercircle.x; double dy = this.y - othercircle.y; double distance = math.sqrt(dx*dx + dy*dy); return distance < this.radius + othercircle.radius; } void handlecollision(circle othercircle){ double vx = this.x - othercircle.x; double vy = this.y - othercircle.y; double distance = math.sqrt(vx*vx + vy*vy); double collisionamount = (this.radius + othercircle.radius) - distance; vx *= collisionamount / distance; vy *= collisionamount / distance; if(this instanceof player){ othercircle.x -= 2 * vx; othercircle.y -= 2 * vy; } else if(othercircle instanceof player){ this.x += 2 * vx; this.y += 2 * vy; } else{ this.x += vx; this.y += vy; othercircle.x -= vx; othercircle.y -= vy; } } } import javax.swing.*; import java.awt.*; //import java.awt.renderinghints.key; import java.awt.event.*; import java.util.arraylist; import java.time.localtime; import java.awt.geom.roundrectangle2d; //import java.util.list; import java.io.bufferedreader; import java.io.filereader; import java.io.filewriter; import java.io.ioexception; import java.io.printwriter; public class game extends jpanel implements mouselistener, keylistener, mousemotionlistener{ final static private int width = 1200; final static private int height = 1000; private int wave = -1; private int[][] waves = { {10, 0, 0, 0}, {20, 0, 0, 0}, {15, 10, 0, 0}, {15, 15, 0, 0}, {20, 20, 5, 0}, {20, 15, 10, 0}, {20, 20, 15, 0}, {20, 15, 15, 5}, {20, 20, 10, 10}, {25, 20, 15, 10}, {25, 25, 15, 15}, {30, 25, 20, 20}, {35, 30, 25, 20}, {40, 30, 30, 25} }; private int point = 0; private boolean ispaused = false; private boolean iswon = false; private boolean isloading = false; private timer timer; private arraylist<zombie> zombies = new arraylist<>(); private arraylist<bullet> bullets = new arraylist<>(); private arraylist<acidspit> spits = new arraylist<>(); private arraylist<gun> guns = new arraylist<>(); private gun currentgun; private player player = new player(width/2, height/2, 20, color.black, 100, 3); public game(){ super(); //public gun(double damage, double firerate, double spreadangle, int magazinecap, int totalbulletcount, int bulletsinmag) //guns.add(new gun()); setbackground(color.white); this.setfocusable(true); this.addkeylistener(this); this.addmouselistener(this); this.addmousemotionlistener(this); guns.add(new pistol(player.x, player.y)); currentgun = guns.get(0); timer = new timer(10, _ -> { if(!ispaused && !iswon && !isloading){ if(zombies.size() == 0){ wave++; if(wave == 1) guns.add(new rifle(player.x, player.y)); if(wave == 3) guns.add(new shotgun(player.x, player.y)); if(wave == 5) guns.add(new sniper(player.x, player.y)); if(wave == 10) guns.add(new rocketlauncher(player.x, player.y)); if(wave == waves.length) iswon = true; else createzombiewave(waves[wave]); } updateplayermovement(); updatespits(); updatebullets(); updatezombies(); centerplayer(); } repaint(); }); timer.start(); } // --- mouselistener methods --- @override public void mouseclicked(mouseevent e) { } @override public void mousepressed(mouseevent e) { currentgun.fire(bullets); } @override public void mousereleased(mouseevent e) { } @override public void mouseentered(mouseevent e) { } @override public void mouseexited(mouseevent e) { } // --- mousemotionlistener methods --- @override public void mousemoved(mouseevent e) { for(gun gun:guns){ gun.rotate(e.getx(), e.gety()); } } @override public void mousedragged(mouseevent e) { } // --- keylistener methods --- @override public void keypressed(keyevent e){ if(e.getkeycode() == keyevent.vk_w) player.moveup = true; if(e.getkeycode() == keyevent.vk_s) player.movedown = true; if(e.getkeycode() == keyevent.vk_a) player.moveleft = true; if(e.getkeycode() == keyevent.vk_d) player.moveright = true; switch (e.getkeycode()){ case keyevent.vk_r: currentgun.reload(); break; case keyevent.vk_1: if(guns.size() >= 1) currentgun = guns.get(0); break; case keyevent.vk_2: if(guns.size() >= 2) currentgun = guns.get(1); break; case keyevent.vk_3: if(guns.size() >= 3) currentgun = guns.get(2); break; case keyevent.vk_4: if(guns.size() >= 4) currentgun = guns.get(3); break; case keyevent.vk_5: if(guns.size() >= 5) currentgun = guns.get(4); break; } } @override public void keyreleased(keyevent e) { if(e.getkeycode() == keyevent.vk_w) player.moveup = false; if(e.getkeycode() == keyevent.vk_s) player.movedown = false; if(e.getkeycode() == keyevent.vk_a) player.moveleft = false; if(e.getkeycode() == keyevent.vk_d) player.moveright = false; if(e.getkeycode() == keyevent.vk_escape){ if(ispaused) ispaused = false; else ispaused = true; } if(e.getkeycode() == keyevent.vk_s && ispaused) savegame(); if(e.getkeycode() == keyevent.vk_l && ispaused) loadgame(); } @override public void keytyped(keyevent e) { } @override protected void paintcomponent(graphics g) { super.paintcomponent(g); graphics2d g2d = (graphics2d) g; if(iswon){ g2d.setcolor(color.green); g2d.fillrect(0, 0, width, height); g2d.setcolor(color.white); g2d.drawstring(""you won"", width / 2, height / 2); g2d.drawstring(""point: "" + point, width / 2, height / 2 + 20); return; } if(player.health <= 0){ g2d.setcolor(color.black); g2d.fillrect(0, 0, width, height); g2d.setcolor(color.white); g2d.drawstring(""you died"", width / 2, height / 2); g2d.drawstring(""points: "" + point, width / 2, height / 2 + 20); return; } if(ispaused){ g2d.setcolor(color.black); g2d.fillrect(0, 0, width, height); g2d.setcolor(color.white); g2d.drawstring(""paused"", width / 2, height / 2); g2d.drawstring(""save (s)"", width / 2, height / 2 + 20); g2d.drawstring(""load (l)"", width / 2, height / 2 + 40); return; } for(acidspit spit:spits) spit.draw(g2d); for(bullet bullet:bullets) bullet.draw(g2d); for(zombie zombie:zombies) zombie.draw(g2d); player.draw(g2d); currentgun.draw(g2d); drawbeveledrectangle(g2d, -10, -10, 290, 90, 20, 20, color.white, color.black, 3); drawbeveledrectangle(g2d, 10, 10, (int)math.round(260 * (player.health / 100)), 20, 5, 5, new color(0x0fba2f), new color(0x0fba2f), 3); g2d.setcolor(color.black); g2d.drawstring("""" + currentgun.name, 10, 50); if(currentgun instanceof pistol) g2d.drawstring("""" + currentgun.bulletsinmag + ""/inf"", 10, 70); else g2d.drawstring("""" + currentgun.bulletsinmag + ""/"" + currentgun.totalbulletcount, 10, 70); g2d.drawstring(""wave"", 145, 50); g2d.drawstring("""" + (wave + 1), 145, 70); g2d.drawstring(""points"", 220, 50); g2d.drawstring("""" + point, 220, 70); } void createzombiewave(int[] zombiecount){ double zombiex, zombiey; zombie zombie; zombiex = (math.random() - 0.5) * (2 * width); zombiey = (math.random() - 0.5) * (2 * height); zombie = new normalzombie(zombiex, zombiey); while(zombiecount[0] > 0){ if(zombie.distance(player) > 500){ zombies.add(zombie); zombiecount[0]--; } zombiex = (math.random() - 0.5) * (2 * width); zombiey = (math.random() - 0.5) * (2 * height); zombie = new normalzombie(zombiex, zombiey); } zombiex = (math.random() - 0.5) * (2 * width); zombiey = (math.random() - 0.5) * (2 * height); zombie = new crawlerzombie(zombiex, zombiey); while(zombiecount[1] > 0){ if(zombie.distance(player) > 500){ zombies.add(zombie); zombiecount[1]--; } zombiex = (math.random() - 0.5) * (2 * width); zombiey = (math.random() - 0.5) * (2 * height); zombie = new crawlerzombie(zombiex, zombiey); } zombiex = (math.random() - 0.5) * (2 * width); zombiey = (math.random() - 0.5) * (2 * height); zombie = new tankzombie(zombiex, zombiey); while(zombiecount[2] > 0){ if(zombie.distance(player) > 500){ zombies.add(zombie); zombiecount[2]--; } zombiex = (math.random() - 0.5) * (2 * width); zombiey = (math.random() - 0.5) * (2 * height); zombie = new tankzombie(zombiex, zombiey); } zombiex = (math.random() - 0.5) * (2 * width); zombiey = (math.random() - 0.5) * (2 * height); zombie = new spitterzombie(zombiex, zombiey); while(zombiecount[3] > 0){ if(zombie.distance(player) > 500){ zombies.add(zombie); zombiecount[3]--; } zombiex = (math.random() - 0.5) * (2 * width); zombiey = (math.random() - 0.5) * (2 * height); zombie = new spitterzombie(zombiex, zombiey); } } void updateplayermovement(){ for(zombie zombie:zombies){ if(player.moveup) zombie.y += player.speed; if(player.movedown) zombie.y -= player.speed; if(player.moveleft) zombie.x += player.speed; if(player.moveright) zombie.x -= player.speed; if(zombie instanceof crawlerzombie){ crawlerzombie crawler = (crawlerzombie) zombie; if(player.moveup) crawler.jumptargety += player.speed; if(player.movedown) crawler.jumptargety -= player.speed; if(player.moveleft) crawler.jumptargetx += player.speed; if(player.moveright) crawler.jumptargetx -= player.speed; } } for(bullet bullet:bullets){ if(player.moveup) bullet.y += player.speed; if(player.movedown) bullet.y -= player.speed; if(player.moveleft) bullet.x += player.speed; if(player.moveright) bullet.x -= player.speed; } for(acidspit spit:spits){ if(player.moveup) spit.y += player.speed; if(player.movedown) spit.y -= player.speed; if(player.moveleft) spit.x += player.speed; if(player.moveright) spit.x -= player.speed; } } void updatezombies(){ // removing dead zombies for(int i = 0;i < zombies.size();i++){ if(zombies.get(i).health <= 0){ point += zombies.get(i).point; zombies.remove(i); i--; // randomly acquiring bullets from dead zombies if(guns.size() > 1 && math.random() < 0.2){ int guncount = guns.size() - 1; int gunindex = (int)math.floor(math.max(math.random() - 1e-9, 0) * guncount) + 1; gun gun = guns.get(gunindex); gun.totalbulletcount += 2 * gun.magazinecap; } } } for(zombie zombie:zombies) { if(zombie instanceof crawlerzombie && ((crawlerzombie)zombie).isjumping){ // handling jumping crawlers crawlerzombie crawler = (crawlerzombie) zombie; double vx = crawler.jumptargetx - crawler.x; double vy = crawler.jumptargety - crawler.y; double distance = math.sqrt(vx*vx + vy*vy); if(distance < 2 * crawler.speed){ crawler.x = crawler.jumptargetx; crawler.y = crawler.jumptargety; crawler.isjumping = false; crawler.color = new color(0x6b9c10); continue; } vx *= 2 * crawler.speed / distance; vy *= 2 * crawler.speed / distance; crawler.x += vx; crawler.y += vy; } else if(zombie instanceof spitterzombie && player.distance(zombie) < 200){ // handling spitters that are close to player ((spitterzombie)zombie).spit(spits, player); } else{ // moving zombies towards the character double vx = player.x - zombie.x; double vy = player.y - zombie.y; double distance = math.sqrt(vx*vx + vy*vy); vx /= distance; vy /= distance; zombie.x += vx * zombie.speed; zombie.y += vy * zombie.speed; if(zombie instanceof crawlerzombie && player.distance(zombie) < 200){ ((crawlerzombie)zombie).jump(player); } } } // handling collisions for(zombie zombie1:zombies){ for(zombie zombie2:zombies) if(zombie1 != zombie2 && zombie1.intersects(zombie2)){ zombie1.handlecollision(zombie2); } } // damage dealt to player for(zombie zombie:zombies){ if(player.intersects(zombie)){ player.health -= zombie.damage; zombie.handlecollision(player); } if(zombie instanceof crawlerzombie && player.distance(zombie) < 20){ ((crawlerzombie)zombie).jump(player); } } } void updatebullets(){ // updating bullet coordinates for(bullet bullet:bullets){ bullet.x += bullet.speedx; bullet.y += bullet.speedy; } // removing bullets that are too far away from player for(int i = 0;i < bullets.size();i++){ bullet bullet = bullets.get(i); double dx = player.x - bullet.x; double dy = player.y - bullet.y; double dist = math.sqrt(dx*dx + dy*dy); if(dist > 5000) bullets.remove(bullet); } // for each bullet, checking whether that bullet hits a zombie for(bullet bullet:bullets){ for(zombie zombie:zombies) if(bullet.ishit == false && bullet.intersects(zombie) && zombie.health > 0){ if(bullet instanceof sniperbullet && ((sniperbullet)bullet).hits.contains(zombie)) break; if(bullet.isexplosive){ circle blast = new circle(bullet.x, bullet.y, 70, color.red); blast.draw((graphics2d)this.getgraphics()); for(zombie zombie2:zombies){ if(blast.intersects(zombie2) && zombie2.health > 0){ zombie2.health -= bullet.damage; } } } else{ zombie.health -= bullet.damage; } if(!bullet.canpenetrate){ bullet.ishit = true; } if(bullet instanceof sniperbullet){ ((sniperbullet)bullet).hits.add(zombie); } break; } } // removing bullet that hit a zombie for(int i = 0;i < bullets.size();i++){ if(bullets.get(i).ishit){ bullets.remove(i); i--; } } } void updatespits(){ // removing expired spits for(int i = 0;i < spits.size();i++) if(spits.get(i).hashitground){ acidspit spit = spits.get(i); if(localtime.now().tosecondofday() - spit.timeofimpact >= spit.duration){ spits.remove(i); } } // updating bullet coordinates for(acidspit spit:spits) if(!spit.hashitground) { spit.x += spit.speedx; spit.y += spit.speedy; spit.maxdistance -= math.sqrt(spit.speedx * spit.speedx + spit.speedy * spit.speedy); if(spit.maxdistance < 0){ spit.radius = 30; spit.hashitground = true; spit.timeofimpact = localtime.now().tosecondofday(); } } // spits on the ground for(acidspit spit:spits) if(spit.hashitground) { if(player.intersects(spit)){ spit.hashitground = true; player.health -= spit.damage; } } // spits hitting player for(acidspit spit:spits) if(!spit.hashitground) { if(player.intersects(spit)){ spit.hashitground = true; player.health -= spit.damage; spit.timeofimpact = localtime.now().tosecondofday(); spit.radius = 30; } } } public void centerplayer(){ double dx = (width / 2) - player.x; double dy = (height/ 2) - player.y; player.x += dx; player.y += dy; for(zombie zombie:zombies) zombie.x += dx; for(zombie zombie:zombies) zombie.y += dy; for(bullet bullet:bullets) bullet.y += dy; for(bullet bullet:bullets) bullet.x += dx; for(acidspit spit:spits) spit.y += dy; for(acidspit spit:spits) spit.x += dx; } public static void drawbeveledrectangle(graphics2d g2d, int x, int y, int width, int height, int arcwidth, int archeight, color fillcolor, color outlinecolor, int outlinethickness) { roundrectangle2d.double roundedrectangle = new roundrectangle2d.double(x, y, width, height, arcwidth, archeight); g2d.setcolor(fillcolor); g2d.fill(roundedrectangle); g2d.setcolor(outlinecolor); g2d.setstroke(new basicstroke(outlinethickness)); g2d.draw(roundedrectangle); } public void savegame() { try (printwriter writer = new printwriter(new filewriter(""savegame.txt""))) { writer.println(""wave: "" + wave); writer.println(""point: "" + point); writer.println(""ispaused: "" + ispaused); writer.println(""iswon: "" + iswon); writer.println(""playerhealth: "" + player.health); writer.println(""currentgunindex: "" + guns.indexof(currentgun)); writer.println(""playerx: "" + player.x); writer.println(""playery: "" + player.y); writer.println(""guncount: "" + guns.size()); for (gun gun : guns) { writer.println(""guntype: "" + getguntypename(gun)); writer.println(""magazinecap: "" + gun.magazinecap); writer.println(""totalbulletcount: "" + gun.totalbulletcount); writer.println(""bulletsinmag: "" + gun.bulletsinmag); writer.println(""gunx1: "" + gun.x1); writer.println(""guny1: "" + gun.y1); writer.println(""gunx2: "" + gun.x2); writer.println(""guny2: "" + gun.y2); writer.println(""gunthickness: "" + gun.thickness); writer.println(""guncolorrgb: "" + gun.color.getrgb()); writer.println(""gundamage: "" + gun.damage); writer.println(""gunfirerate: "" + gun.firerate); writer.println(""gunspreadangle: "" + gun.spreadangle); writer.println(""gunlength: "" + gun.length); writer.println(""gunlastfired: "" + gun.lastfired); writer.println(""gunname: "" + gun.name); } writer.println(""zombiecount: "" + zombies.size()); for (zombie zombie : zombies) { writer.println(""zombietype: "" + getzombietypename(zombie)); writer.println(""zombiex: "" + zombie.x); writer.println(""zombiey: "" + zombie.y); writer.println(""zombiehealth: "" + zombie.health); writer.println(""zombieradius: "" + zombie.radius); writer.println(""zombiecolorrgb: "" + zombie.color.getrgb()); writer.println(""zombiespeed: "" + zombie.speed); writer.println(""zombiedamage: "" + zombie.damage); writer.println(""zombiepoint: "" + zombie.point); if (zombie instanceof crawlerzombie) { crawlerzombie crawler = (crawlerzombie) zombie; writer.println(""crawlerisjumping: "" + crawler.isjumping); writer.println(""crawlerjumptargetx: "" + crawler.jumptargetx); writer.println(""crawlerjumptargety: "" + crawler.jumptargety); writer.println(""crawlerlastjump: "" + crawler.lastjump); } else if (zombie instanceof spitterzombie) { spitterzombie spitter = (spitterzombie) zombie; writer.println(""spitterspittingdistance: "" + spitter.spittingdistance); writer.println(""spitterlastspit: "" + spitter.lastspit); } } writer.println(""bulletcount: "" + bullets.size()); for (bullet bullet : bullets) { writer.println(""bullettype: "" + getbullettypename(bullet)); writer.println(""bulletx: "" + bullet.x); writer.println(""bullety: "" + bullet.y); writer.println(""bulletradius: "" + bullet.radius); writer.println(""bulletcolorrgb: "" + bullet.color.getrgb()); writer.println(""bulletspeedx: "" + bullet.speedx); writer.println(""bulletspeedy: "" + bullet.speedy); writer.println(""bulletdamage: "" + bullet.damage); writer.println(""bulletishit: "" + bullet.ishit); writer.println(""bulletisexplosive: "" + bullet.isexplosive); writer.println(""bulletcanpenetrate: "" + bullet.canpenetrate); if (bullet instanceof acidspit) { acidspit spit = (acidspit) bullet; writer.println(""spitmaxdistance: "" + spit.maxdistance); writer.println(""spithashitground: "" + spit.hashitground); writer.println(""spittimeofimpact: "" + spit.timeofimpact); writer.println(""spitduration: "" + spit.duration); } else if (bullet instanceof sniperbullet) { } } writer.println(""spitcount: "" + spits.size()); for (acidspit spit : spits) { writer.println(""spitx: "" + spit.x); writer.println(""spity: "" + spit.y); writer.println(""spitradius: "" + spit.radius); writer.println(""spitcolorrgb: "" + spit.color.getrgb()); writer.println(""spitspeedx: "" + spit.speedx); writer.println(""spitspeedy: "" + spit.speedy); writer.println(""spitdamage: "" + spit.damage); writer.println(""spitduration: "" + spit.duration); writer.println(""spittimeofimpact: "" + spit.timeofimpact); writer.println(""spithashitground: "" + spit.hashitground); writer.println(""spitmaxdistance: "" + spit.maxdistance); } system.out.println(""game saved successfully!""); } catch (ioexception e) { system.err.println(""error saving game: "" + e.getmessage()); } } public void loadgame() { isloading = true; try (bufferedreader reader = new bufferedreader(new filereader(""savegame.txt""))) { string line; guns.clear(); zombies.clear(); bullets.clear(); spits.clear(); int loadedcurrentgunindex = -1; while ((line = reader.readline()) != null) { string[] parts = line.split(""\\s+""); if (parts.length < 2) continue; string label = parts[0]; string valuestr = parts[1]; if (label.equals(""wave:"")) { wave = integer.parseint(valuestr); } else if (label.equals(""point:"")) { point = integer.parseint(valuestr); } else if (label.equals(""ispaused:"")) { ispaused = boolean.parseboolean(valuestr); } else if (label.equals(""iswon:"")) { iswon = boolean.parseboolean(valuestr); } else if (label.equals(""playerhealth:"")) { player.health = double.parsedouble(valuestr); } else if (label.equals(""currentgunindex:"")) { loadedcurrentgunindex = integer.parseint(valuestr); } else if (label.equals(""playerx:"")) { player.x = double.parsedouble(valuestr); } else if (label.equals(""playery:"")) { player.y = double.parsedouble(valuestr); } else if (label.equals(""guncount:"")) { int guncount = integer.parseint(valuestr); for (int i = 0; i < guncount; i++) { gun gun = null; string guntype = reader.readline().split(""\\s+"")[1]; int magazinecap = integer.parseint(reader.readline().split(""\\s+"")[1]); int totalbulletcount = integer.parseint(reader.readline().split(""\\s+"")[1]); int bulletsinmag = integer.parseint(reader.readline().split(""\\s+"")[1]); double gunx1 = double.parsedouble(reader.readline().split(""\\s+"")[1]); double guny1 = double.parsedouble(reader.readline().split(""\\s+"")[1]); double gunx2 = double.parsedouble(reader.readline().split(""\\s+"")[1]); double guny2 = double.parsedouble(reader.readline().split(""\\s+"")[1]); int gunthickness = integer.parseint(reader.readline().split(""\\s+"")[1]); color guncolor = new color(integer.parseint(reader.readline().split(""\\s+"")[1])); double gundamage = double.parsedouble(reader.readline().split(""\\s+"")[1]); double gunfirerate = double.parsedouble(reader.readline().split(""\\s+"")[1]); double gunspreadangle = double.parsedouble(reader.readline().split(""\\s+"")[1]); double gunlength = double.parsedouble(reader.readline().split(""\\s+"")[1]); long gunlastfired = long.parselong(reader.readline().split(""\\s+"")[1]); string gunname = reader.readline().split(""\\s+"")[1]; if (guntype.equals(""pistol"")) { gun = new pistol(player.x, player.y); } else if (guntype.equals(""rifle"")) { gun = new rifle(player.x, player.y); } else if (guntype.equals(""shotgun"")) { gun = new shotgun(player.x, player.y); } else if (guntype.equals(""sniper"")) { gun = new sniper(player.x, player.y); } else if (guntype.equals(""rocketlauncher"")) { gun = new rocketlauncher(player.x, player.y); } if (gun != null) { gun.magazinecap = magazinecap; gun.totalbulletcount = totalbulletcount; gun.bulletsinmag = bulletsinmag; gun.x1 = gunx1; gun.y1 = guny1; gun.x2 = gunx2; gun.y2 = guny2; gun.thickness = gunthickness; gun.color = guncolor; gun.damage = gundamage; gun.firerate = gunfirerate; gun.spreadangle = gunspreadangle; gun.length = gunlength; gun.lastfired = gunlastfired; gun.name = gunname; guns.add(gun); } } if (loadedcurrentgunindex >= 0 && loadedcurrentgunindex < guns.size()) { currentgun = guns.get(loadedcurrentgunindex); } else if (!guns.isempty()) { currentgun = guns.get(0); } else { currentgun = null; } } else if (label.equals(""zombiecount:"")) { int zombiecount = integer.parseint(valuestr); for (int i = 0; i < zombiecount; i++) { zombie zombie = null; string zombietype = reader.readline().split(""\\s+"")[1]; double zombiex = double.parsedouble(reader.readline().split(""\\s+"")[1]); double zombiey = double.parsedouble(reader.readline().split(""\\s+"")[1]); double zombiehealth = double.parsedouble(reader.readline().split(""\\s+"")[1]); double zombieradius = double.parsedouble(reader.readline().split(""\\s+"")[1]); color zombiecolor = new color(integer.parseint(reader.readline().split(""\\s+"")[1])); double zombiespeed = double.parsedouble(reader.readline().split(""\\s+"")[1]); double zombiedamage = double.parsedouble(reader.readline().split(""\\s+"")[1]); double zombiepoint = double.parsedouble(reader.readline().split(""\\s+"")[1]); if (zombietype.equals(""normalzombie"")) { zombie = new normalzombie(0, 0); } else if (zombietype.equals(""crawlerzombie"")) { zombie = new crawlerzombie(0, 0); } else if (zombietype.equals(""tankzombie"")) { zombie = new tankzombie(0, 0); } else if (zombietype.equals(""spitterzombie"")) { zombie = new spitterzombie(0, 0); } if (zombie != null) { zombie.x = zombiex; zombie.y = zombiey; zombie.health = zombiehealth; zombie.radius = zombieradius; zombie.color = zombiecolor; zombie.speed = zombiespeed; zombie.damage = zombiedamage; zombie.point = zombiepoint; if (zombie instanceof crawlerzombie) { crawlerzombie crawler = (crawlerzombie) zombie; crawler.isjumping = boolean.parseboolean(reader.readline().split(""\\s+"")[1]); crawler.jumptargetx = double.parsedouble(reader.readline().split(""\\s+"")[1]); crawler.jumptargety = double.parsedouble(reader.readline().split(""\\s+"")[1]); crawler.lastjump = integer.parseint(reader.readline().split(""\\s+"")[1]); } else if (zombie instanceof spitterzombie) { spitterzombie spitter = (spitterzombie) zombie; spitter.spittingdistance = double.parsedouble(reader.readline().split(""\\s+"")[1]); spitter.lastspit = integer.parseint(reader.readline().split(""\\s+"")[1]); } zombies.add(zombie); } } } else if (label.startswith(""bulletcount:"")) { int bulletcount = integer.parseint(valuestr); for (int i = 0; i < bulletcount; i++) { bullet bullet = null; string bullettype = reader.readline().split(""\\s+"")[1]; double bulletx = double.parsedouble(reader.readline().split(""\\s+"")[1]); double bullety = double.parsedouble(reader.readline().split(""\\s+"")[1]); double bulletradius = double.parsedouble(reader.readline().split(""\\s+"")[1]); color bulletcolor = new color(integer.parseint(reader.readline().split(""\\s+"")[1])); double bulletspeedx = double.parsedouble(reader.readline().split(""\\s+"")[1]); double bulletspeedy = double.parsedouble(reader.readline().split(""\\s+"")[1]); double bulletdamage = double.parsedouble(reader.readline().split(""\\s+"")[1]); boolean bulletishit = boolean.parseboolean(reader.readline().split(""\\s+"")[1]); boolean bulletisexplosive = boolean.parseboolean(reader.readline().split(""\\s+"")[1]); boolean bulletcanpenetrate = boolean.parseboolean(reader.readline().split(""\\s+"")[1]); if (bullettype.equals(""bullet"")) { bullet = new bullet(0, 0, 0, color.black, 0, 0, 0, false, false); } else if (bullettype.equals(""acidspit"")) { bullet = new acidspit(0, 0, 0, color.black, 0, 0, 0, 0, 0); } else if (bullettype.equals(""sniperbullet"")) { bullet = new sniperbullet(0, 0, 0, color.black, 0, 0, 0, false, true); } if (bullet != null) { bullet.x = bulletx; bullet.y = bullety; bullet.radius = bulletradius; bullet.color = bulletcolor; bullet.speedx = bulletspeedx; bullet.speedy = bulletspeedy; bullet.damage = bulletdamage; bullet.ishit = bulletishit; bullet.isexplosive = bulletisexplosive; bullet.canpenetrate = bulletcanpenetrate; if (bullet instanceof acidspit) { acidspit spit = (acidspit) bullet; spit.maxdistance = double.parsedouble(reader.readline().split(""\\s+"")[1]); spit.hashitground = boolean.parseboolean(reader.readline().split(""\\s+"")[1]); spit.timeofimpact = long.parselong(reader.readline().split(""\\s+"")[1]); spit.duration = integer.parseint(reader.readline().split(""\\s+"")[1]); } else if (bullet instanceof sniperbullet) { } bullets.add(bullet); } } } else if (label.startswith(""spitcount:"")) { int spitcount = integer.parseint(valuestr); for (int i = 0; i < spitcount; i++) { double spitx = double.parsedouble(reader.readline().split(""\\s+"")[1]); double spity = double.parsedouble(reader.readline().split(""\\s+"")[1]); double spitradius = double.parsedouble(reader.readline().split(""\\s+"")[1]); color spitcolor = new color(integer.parseint(reader.readline().split(""\\s+"")[1])); double spitdamage = double.parsedouble(reader.readline().split(""\\s+"")[1]); double spitspeedx = double.parsedouble(reader.readline().split(""\\s+"")[1]); double spitspeedy = double.parsedouble(reader.readline().split(""\\s+"")[1]); long spitduration = long.parselong(reader.readline().split(""\\s+"")[1]); long spittimeofimpact = long.parselong(reader.readline().split(""\\s+"")[1]); boolean spithashitground = boolean.parseboolean(reader.readline().split(""\\s+"")[1]); double spitmaxdistance = double.parsedouble(reader.readline().split(""\\s+"")[1]); acidspit spit = new acidspit(spitx, spity, spitradius, spitcolor, spitdamage, spitspeedx, spitspeedy, spitmaxdistance, (int)spitduration); // dummy acidspit to overwrite values spit.timeofimpact = spittimeofimpact; spit.hashitground = spithashitground; spits.add(spit); } } } centerplayer(); requestfocusinwindow(); isloading = false; system.out.println(""game loaded successfully!""); } catch (ioexception e) { system.err.println(""error loading game: "" + e.getmessage()); } } private string getguntypename(gun gun) { if (gun instanceof pistol) return ""pistol""; if (gun instanceof rifle) return ""rifle""; if (gun instanceof shotgun) return ""shotgun""; if (gun instanceof sniper) return ""sniper""; if (gun instanceof rocketlauncher) return ""rocketlauncher""; return ""unknowngun""; } private string getzombietypename(zombie zombie) { if (zombie instanceof normalzombie) return ""normalzombie""; if (zombie instanceof crawlerzombie) return ""crawlerzombie""; if (zombie instanceof tankzombie) return ""tankzombie""; if (zombie instanceof spitterzombie) return ""spitterzombie""; return ""unknownzombie""; } private string getbullettypename(bullet bullet) { if (bullet instanceof acidspit) return ""acidspit""; if (bullet instanceof sniperbullet) return ""sniperbullet""; return ""bullet""; } public static void main(string[] args) { jframe frame = new jframe(""zombie game""); game game = new game(); frame.add(game); frame.setsize(width, height); frame.setdefaultcloseoperation(jframe.exit_on_close); frame.setlocationrelativeto(null); frame.setvisible(true); frame.setresizable(false); } } //import javax.swing.*; import java.awt.*; //import java.awt.event.*; //import java.util.arraylist; //import java.util.list; public class line{ double x1, y1, x2, y2; int thickness; color color; public line(double x1, double y1, double x2, double y2, int thickness, color color){ this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2; this.thickness = thickness; this.color = color; } public void draw(graphics2d g2d){ g2d.setcolor(color); g2d.setstroke(new basicstroke(thickness)); g2d.drawline((int)math.round(x1), (int)math.round(y1), (int)math.round(x2), (int)math.round(y2)); } } //import javax.swing.*; import java.awt.*; //import java.awt.event.*; //import java.util.arraylist; //import java.util.list; public class player extends circle{ double health, speed; double movex, movey; boolean moveup = false, movedown = false, moveleft = false, moveright = false; gun gun; public player(double x, double y, double radius, color color, double health, double speed) { super(x, y, radius, color); this.health = health; this.speed = speed; } }"
8964453,9,"müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.*; public class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { strateji =s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } import java.util.*; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki){ metalsarki metal = (metalsarki) sarki; metal.gostermetalozellikleri(); } } } } public class klasiksarki extends sarki{ public klasiksarki(string isim,string sanatci ) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (hafif ve sakin""); } } public class metalsarki extends sarki{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void gostermetalozellikleri() { system.out.println(sanatci + "" - "" + isim + "" [ozellik: "" + metalozellik + ""]""); } void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } } public class rocksarki extends sarki{ public rocksarki(string isim,string sanatci ) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[rock] "" +sanatci + "" - "" + isim + "" (huzurlu ve nostaljik""); } } import java.util.*; public class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { list<sarki> sarkilistcpy = new arraylist<>(sarkilistesi); collections.shuffle(sarkilistcpy); for(sarki x : sarkilistcpy) { x.oynat(); } } } import java.util.*; public class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for(sarki x : sarkilistesi) { x.oynat(); } } } public abstract class sarki{ string isim; string sanatci; void oynat(){} } import java.util.*; public class rockcuozelcalma implements calmastratejisi{ private boolean sesseviyesi = false; //false:normal true:yuksek public void cal(list<sarki> sarkilistesi) { for(sarki x : sarkilistesi) { if(x instanceof rocksarki) { if(sesseviyesi == false) { sesseviyesi = true; system.out.println(""[bilgi] ses duzeyi: yuksek""); } } else { if(sesseviyesi == true) { system.out.println(""[bilgi] ses duzeyi: normal""); sesseviyesi =false; } } x.oynat(); } } } import java.util.*; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } metin karşılaştırıcı bil 211 - lab 3 20 şubat 2025 1 giriş bulaboratuvarda fileio ve exceptions kullanarakbir metinkarşılaştırıcı geliştireceğiz. metinkarşılaştırıcı , verilen iki metin dosyasını karşılaştırarak ikinci metnin yalnızca yeni satırlar eklenerek oluşturulup oluştu- rulmadığını kontrol edecek ve gerektiğinde hangi satırdan sonra hangi eklemelerin yapıldığını belirleyecektir. 2 genel program program, çalıştırılırken komut satırından iki dosya adı alacaktır: - orijinal metin dosyası (ilk argüman) - değiştirilmiş metin dosyası (ikinci argüman) program şu şekilde çalıştırmalıdır (burada köşeli parantezler yerine dosyaların asıl adı gelmeli): java metinkarsilastirici [orijinal.txt] [degistirilmis.txt] program, ilk argümanda verilen dosyayı orijinal metin, ikinci argümandaki dosyayı değiştirilmiş metin olarak kabul edecek ve yalnızca yeni satırlar eklenerek oluşturulup oluşturulmadığını kontrol edecektir. eğer mümkünse, hangi satırdan sonra hangi eklemelerin yapıldığını tespit ederek bir çıktı dosyasına yazacaktır: -farklar.txt – yeni satırların hangi satırdan sonra eklendiğini gösteren çıktı dosyası. eğer dosya adları eksikse veya hatalı formatta verilmişse, program özel bir hata oluşturmalı ve stderr’e uygun bir mesaj yazmalıdır. 3 fileio program, dosyaokumaveyazmaişlemleriiçinjava’nın java.io paketindekisınıflarıkullanacaktır(örn., buf- ferredreader, scanner, printwriter). dosyaları okurken ve yazarken kullanacağınız fileio sınıflarının seçimi size bırakılmıştır. program, aşağıdaki olası dosya hatalarını atmalı ve stderr’e belirlenen hata mesajlarını yazmalıdır: - dosya bulunamıyorsa: ""hata: [dosya adı] bulunamadı."" - dosya boşsa: ""hata: [dosya adı] boş."" 4 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program hata kodu ile çıkış yapmalıdır (yani mainmetodunuz bu hataları atarak sonlanmalı) ve hatalar stderr’e yazılmalıdır (programınızı hata atarak sonlandırırsanız java bunu kendisi yapacaktır). belirtilen hata mesajları ile birlikte java’nın hata ile sonlanan programlar için oluşturduğu sınıf, metod, ve satır gibi bilgiler bulunabilir. 4.1 girdi hataları (inputexception class) bu kategori, programın giriş dosyalarıyla ilgili karşılaşabileceği tüm hataları kapsar. öğrenciler, dosya işlem- leriyle ilgili hata türlerini inputexception sınıfından türetmelidir. aşağıdaki özel hata türleri tanımlanmalıdır: 1 - yanlisargumanexception (extends inputexception): argümanlar eksik ya da fazlaysa atılacak hata. burada[argümanlar] yerine programın çalıştırıldığı argüman listesi yazılmalıdır. - hata mesajı: ""hata: hatalı argüman kullanımı: [argümanlar]. program argüman olarak 2 dosya ismi almalı."" - dosyabulunamadiexception (extends inputexception): dosya eksikse atılacak hata. - hata mesajı: ""hata: [dosya adı] bulunamadı."" - bosdosyaexception (extends inputexception): dosya boşsa atılacak hata. - hata mesajı: ""hata: [dosya adı] boş."" 4.2 geçersiz değişiklik hatası (gecersizdegisiklikexception class) eğerdegistirilmis.txt dosyası,orijinal.txt dosyasına yalnızca yeni satırlar eklenerek oluşturulamıy- orsa, program gecersizdegisiklikexception hatasını atmalıdır. bu hata oluştuğunda stderr’e şu mesaj yazılmalıdır: hata: [degistirilmis.txt] dosyası, [orijinal.txt] dosyasına yalnızca yeni satırlar eklenerek oluşturulmamış. 5 dosya formatları 5.1 girdi dosyaları 5.1.1orijinal.txt vedegistirilmis.txt formatı bu dosyalar, her satırın ayrı bir metin satırı olduğu düz metin formatında olmalıdır. örnek i̇çerik ( orijinal.txt ): merhaba dünya. bu bir test dosyasıdır. son satır budur. örnek i̇çerik ( degistirilmis.txt ): merhaba dünya. bu bir test dosyasıdır. eklenen yeni bir satır. son satır budur. yeni bir satır daha eklendi. 5.2 çıktı dosyası 5.2.1farklar.txt formatı farklar.txt dosyası, hangi satırdan sonra hangi yeni satırın eklendiğini gösterecek şekilde yapılandırıl- malıdır: örnek çıktı ( farklar.txt ): 2 -> eklenen yeni bir satır. 4 -> yeni bir satır daha eklendi. burada ‘2 ->‘ ifadesi, ""2. satırdan sonra eklenmiştir"" anlamına gelir. eğer aynı yere birden fazla satır eklenmişse aynı sayıyı tekrar ederek eklenme sırasında yazılmalı. 5.3 özel hata durumları ve çıktıları eğerdegistirilmis.txt ,orijinal.txt üzerine sadece yeni satırlar eklenerek oluşturulmamışsa stderr’e şu mesaj yazılmalıdır: hata: degistirilmis.txt dosyası, orijinal.txt dosyasına yalnızca yeni satırlar eklenerek oluşturulmamış. eğer dosya adları eksikse veya hatalıysa, stderr’e şu mesaj yazılmalıdır: hata: geçersiz dosya adı. 2 6 gönderim formatı - labı bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara şeklinde isimlendirin (örn., johnnash_181101014.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""lab3 gönderim"" başlıklı bir mail ile gönderin. metot açıklama string(string s) sile aynı değere sahip bir string oluşturur. string(char[] a) a[]dizisindeki karakterleri temsil eden bir string oluşturur. int length() string içindeki karakter sayısını döndürür. char charat(int i) belirtilen iindeksindeki karakteri döndürür. string substring(int i, int j) iilej-1arasındaki karakterleri içeren bir alt string döndürür. boolean contains(string substring) string’in substring içerip içermediğini kontrol eder. boolean startswith(string prefix) string’in prefixile başlayıp başlamadığını kontrol eder. boolean endswith(string postfix) string’in postfix ile bitip bitmediğini kontrol eder. int indexof(string pattern) pattern ifadesinin ilk geçtiği indeks değerini döndürür. int indexof(string pattern, int i) iindeksinden sonraki ilk pattern konumunu döndürür. string concat(string t) string’in sonuna teklenmiş halini döndürür. int compareto(string t) i̇ki string’i karşılaştırır (sözlük sırasına göre). string tolowercase() string’in tüm harflerini küçük harfe çevirir. string touppercase() string’in tüm harflerini büyük harfe çevirir. string replace(string a, string b) string içindeki a’larıbile değiştirir. string trim() string’in başındaki ve sonundaki boşlukları kaldırır. boolean matches(string regexp) string’in belirtilen regexle eşleşip eşleşmediğini kontrol eder. string[] split(string delimiter) string’idelimiter kullanarak böler ve bir dizi döndürür. boolean equals(object t) string’in değeri tile aynı mı diye kontrol eder. table 1: java string sınıfı metotları 3 public class gecersizdegisiklikexception extends exception { public gecersizdegisiklikexception(string dosya1, string dosya2) { super(""[hata] "" +dosya2+ "" dosyasi "" + dosya1 + ""dosyasına yalnızca yeni satırlar eklenerek oluşturulmamış""); } } import java.io.*; import java.util.*; public class main { public static void main(string[] args) { try { compare(""orijinal.txt"", ""degistirilmis.txt""); system.out.println(""*****[basarili]*****""); }catch (dosyabulunamadiexception | bosdosyaexception e) { e.getmessage(); e.printstacktrace(); system.err.println(e.getmessage()); } } public static void compare(string orj, string chan) throws dosyabulunamadiexception,bosdosyaexception { file orijinal = new file(orj); file changed = new file(chan); if (!orijinal.exists()) { throw new dosyabulunamadiexception(""orijinal""); } if (!changed.exists()) { throw new dosyabulunamadiexception(""degistirilmis""); } if (orijinal.length() == 0) { throw new bosdosyaexception(""orijinal""); } if (changed.length() == 0) { throw new bosdosyaexception(""degistirilmis""); } scanner cha_scan; scanner orj_scan; try { cha_scan = new scanner(changed); orj_scan = new scanner(orijinal); } catch (filenotfoundexception e) { throw new dosyabulunamadiexception(""orijinal""); } string orj_line; string chan_line; int index = 0; printwriter write; try{ write = new printwriter(""farklar.txt""); }catch (filenotfoundexception e){ throw new dosyabulunamadiexception(""farklar.txt""); } list<string> orj_list = new arraylist<>(); list<string> cha_list = new arraylist<>(); while (cha_scan.hasnextline()) { chan_line = cha_scan.nextline(); cha_list.add(chan_line); } while (orj_scan.hasnextline()) { orj_line = orj_scan.nextline(); orj_list.add(orj_line); } int j =0; for(int i =0;i<cha_list.size();i++) { if(j< orj_list.size()) { if(!cha_list.get(i).equals(orj_list.get(j))) { write.println(i + "" --> ""+ cha_list.get(i)); } else { j++; } } if(j<i) { write.println(i + "" --> ""+ cha_list.get(i)); } } write.close(); orj_scan.close(); cha_scan.close(); } } public class bosdosyaexception extends inputexception { public bosdosyaexception(string dosya_adi) { super(""[hata] "" + dosya_adi + "" bos!""); } } public class yanlisargumanexception extends inputexception{ public yanlisargumanexception(string arg1, string arg2){ super(""[hata] hatali arguman kullanimi: ["" + arg1 + "" "" + arg2 +""]""); } } public class inputexception extends exception{ public inputexception(string msg){ super(msg); } } public class dosyabulunamadiexception extends inputexception { public dosyabulunamadiexception(string dosya_adi) { super(""[hata] "" + dosya_adi + "" bulunamadi!""); } } generic 1) envanter yönetim sistemi bu labda amacımı bir oyun için envanter sistemi eklemektir. item isminde bir arayüz tanımlayın: aşağıdaki metotları içermelidir: string getname() int getvalue() weapon sınıfı tanımlayın. bu sınıf item arayüzünü uygulamalıdır. int damage isimli bir özelliği olmalıdır. armor sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. int defense isimli bir değişkeni olmalıdır. potion sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. string effect isimli bir değişkeni olmalıdır. generic inventory<t> sınıfı bir arraylist kullanarak nesneleri saklamalıdır. void additem(t item): envantere istenilen eşyayı eklemeli void removeitem(t item): envanterden istenilen eşyayı silmeli void printinventory(): envanteri basmalı t mostvaluableitem(): en değerli eşyayı dönmeli t finditembyname(string name): verilen isme karşılık gelen eşyayı dönmeli. i̇simlerin unique olduğunu varsayabilirsiniz. eğer yoksa null dönün. list<t> finditemsbyvalue(int value): verilen değerden daha değerli eşyaarın listesini döndürür. int gettotalvalue(): envanterin toplam değerini döner. list<t> filterbytype(class<?> type): istenilen sınıfa ait ögeleri döner. int gettotalweapondamage(): weapon classına ait olan nesnelerin toplam hasarınıdöner. void sortbyvalue(): değeri azalan şekilde envanteri sıralamalıdır. public static void printmostvaluableitem(inventory<? extends item> inventory): verilen envanterdem en değerli eşayı ekrana basmalıdır. public static void transferarmor(inventory<? super armor> destination, inventory<armor> source): verilen hedef envantere zırhı taşımalıdır. driver class: main metodu burada olmalıdır. sadece weapon’dan oluşan ve itemdan oluşan invertory classı yazıp test ediniz. yardımcı olabilecek metotlar: class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon import java.util.*; public class inventory<t extends item> { private arraylist<t> items = new arraylist<>(); public void additem(t item) { items.add(item); } public void removeitem(t item) { items.remove(item); } public void printinventory() { for (t item : items) { system.out.println(item.getname() + "" - value: "" + item.getvalue()); } } public t mostvaluableitem() { t mostvaluableitem = null; int mostvaluableitemindex = 0; for (t item : items) { if (item.getvalue() > mostvaluableitem.getvalue()) { mostvaluableitem = item; } } return (t) mostvaluableitem; } public t finditembyname(string name) { for (t item : items) { if (item.getname().equals(name)) { return item; } } return null; } public list<t> finditemsbyvalue(int value) { list<t> newlist = new arraylist<t>(); for (t item : items) { if (item.getvalue() == value) { newlist.add(item); } } return newlist; } public int gettotalvalue() { int totalvalue = 0; for (t item : items) { totalvalue += item.getvalue(); } return totalvalue; } public list<t> filterbytype(class<?> type) { list<t> newlist = new arraylist<>(); for(t item : items) { if(item.getclass().equals(type)) { newlist.add(item); } } return newlist; } public int gettotalweapondamage() { int totaldamage = 0; for (t item : items) { if(item instanceof weapon) { weapon x = (weapon) item; totaldamage += x.getvalue(); } } return totaldamage; } public void sortbyvalue() { t temp = null; for (int i =0; i<items.size(); i++) { for(int j=i+1; j<items.size(); j++) { if(items.get(i).getvalue() < items.get(j).getvalue()) { temp = items.get(j); items.set(j, items.get(i)); items.set(i, temp); } } } } public static void printmostvaluableitem(inventory<? extends item> list) { if(list.mostvaluableitem() != null) { system.out.println(list.mostvaluableitem()); } } public static void transferarmor(inventory<? super armor> destination, inventory<armor> source) { for(item item : source.items) { if(item instanceof armor) { destination.additem((armor) item); } } } } public class weapon implements item{ int damage; int value; string name; public weapon(string name, int value, int damage){ this.damage = damage; this.value = value; this.name = name; } public string getname() { return name; } public int getdamage() { return damage; } public int getvalue() { return value; } public string tostring() { return name + "" "" + value + "" "" + damage; } } public interface item { string getname(); int getvalue(); string tostring(); } public class armor implements item{ string name; int value; int defense; public armor(string name, int value, int defense) { this.name = name; this.value = value; this.defense = defense; } public string getname() { return name; } public int getvalue() { return value; } public string tostring() { return name + "" "" + value + "" "" + defense; } } public class potion implements item{ string name; int value; string effect; public potion(string name, int value, string effect) { this.name = name; this.value = value; this.effect = effect; } public string getname() { return name; } public int getvalue() { return value; } public string tostring(){ return name + "" "" + value + "" "" + effect; } } public class driver { public static void main(string[] args) { //weapon envanteri inventory<weapon> weaponinventory = new inventory<>(); weapon alpi = new weapon(""alpi"", 1000, 30000); weapon keles = new weapon(""keles"", 450, 1000); weaponinventory.additem(alpi); weaponinventory.additem(keles); system.out.println(""=== weapon inventory ===""); weaponinventory.printinventory(); system.out.println(""\naranan silah: alpi""); weapon foundweapon = weaponinventory.finditembyname(""alpi""); if (foundweapon != null) { system.out.println(""bulundu! "" + foundweapon.getname() + "" damage: "" + foundweapon.getdamage()); } else { system.out.println(""aranan silah envanterde bulunamadı.""); } system.out.println(""\n=== sınıf bilgileri ===""); system.out.println(""weapon sınıfı: "" + foundweapon.getclass()); } } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. yineleyen methodlardir. recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. base case dongunun duracagi yeri anladigi yerdir. sonsuz donguyu engeller bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? string uzunlugunun 0 veya 1 olmasi recursive bir metotta base case olmazsa ne olur? sonsuz dongu recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. her bir cagri stack frame olusturur, bunlar ust uste yazilmaya devam eder her iterasyonda fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. her bir iterasyonda alt sayilar tekrar tekrar hesaplanir anlamsizdir tail recursion nedir, kısaca açıklayınız. ciktinin tekrar girise girdigi base case e kadar ne olusuyorsa devam eden iterasyon method turudur abstraction kavramını açıklayınız. nesnenin istedigimiz ozelliklerini alip gerekmeyenleri veya gizlenmek istenenleri kullaniciya gostermemek ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? fox is a animal ifadesi dogrudur burdan fox classinin aninal classinin child classi oldugunu soyleyebiliriz bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? protected ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? a veya c java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? her classin parent classi object classidir, duzgun calisabilmesi icin object classinin constructoru da cagirilmalidir java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? hayir interface birden fazla extend edilebilir metot overriding ve overloading kavramlarını açıklayınız. override icin methodun signature i aynidir, ust classdan alt classa override edilebilir, overload ise ayni isimde bir methodu farkli parametrelerle yani farkli signature ile yeniden yazmak class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? animal bark! class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? generic circle 8.0 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? kodun ne zaman derlenecegini anlatir, early binding ile static binding cesitleridir hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? private metodlar, static methodlar, final methodlar early binding classa bagli nesne olusturulmadan calisirlar kalani static calisirlar dinamik bağlamada jvm'nin görevi nedir? polimorfizm kullanilan methodlarda overridelari takip edip istenilen methoda gitmesi. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? performans kaybi ve guven acikligi olusturur ongorulebilirligi azaltir java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? tip kontrolu yapmak icindir, implicit yaparsak class cast exception hatalari cikabilir java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. override edecegemiz methodu daha az gorunur yapamayiz fakat ust sinifa giderken access modifieri genisletilebilinir class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? bark meov dynamic binding gorulmektedir class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? p.special() da hata vardir parent classda bu method yoktur, dynamic binding gorulmektedir yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. 3 tip hata vardir, 1) syntax soz dizimi hatasi 2) logic hatasi mantiksal yaptigimiz hata 3) run time error program compile ettikden sonra cesitli sebeplerle 1/0 gibi sebeplerle ortaya cikar exception handlingin amacı nedir? programin calisma sirasinda cikabilecek hatalari ongorerek crashi engellemek ve olusabilecek hatalari onceden ayarlayarak cozmek. exception handlingde finally bloğunun amacı nedir? exception yakalandiktan sonra try catch icinde ne yapildigindan bagimsiz her turlu calisacak bir methoddur. yani her kosulda calismasini istedigimiz seyleri buraya yazariz. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? checked exceptions compile time sirasinda ortaya cikar ve crash yememek icin direk ele alinmalidir. unchecked exceptions run time sirasinda dizilerde vs ortaya cikar yani girilen inputlara gore cikabilir veya cikmayabilir. bunu da onceden ongorup halledilmelidir. java'da kendi exceptionunuzu nasıl tanımlarsınız? kendi exceptionumuzu sinifini yaratarak ve exception classindan miras alarak exceptionumuzu olustururuz. main metodu icinde veya farkli bir yerde try catch ile yakalariz ve cozeriz. java'da error ve exception arasındaki fark nedir, açıklayınız error jvm ile alakalidir, exception kodun icinde yaptigimiz seylerle alakalidir. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? hata bilgisini alt katmanlarda kaydetmek ve ust katmanlara iletmek, kullanici dostlugunu arttirmak. 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? alt siniftan daha genis bir exception firlatilamaz. static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? kod derlenmez, ozel exception once genel exception sonra kodda yer almalidir. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 text file ile binary file arasındaki fark nedir? text file insanlar tarafindan okunmasi icin, binary file makina diline daha yakindir, ve 01 lerden olusur. bir dosyaya yazarken düzenli olarak flush yapmamak neye yol açabilir? streamler akis tabanli veri akis setleridir denebilir, duzenli flush yaparak buffer temizlenir ve gereksiz veri akis veya hatalarinin onune gecmis olur. binary bir dosyaya bir object yazdırırken bu objenin hangi interfaceyi implement etmesi gerekiyor? bu interfacenin metotlarını sıralayınız. bu interface functional veya marker bir interface midir? javada bir nesneyi binary dosyaya yazmak icin serializable interfacenini implement etmek zorundadir. bir marker interface dir. herhangi bir method icermez constructoru vardir. binary bir dosyaya primitive typeler (int, float, char etc.) yazılabilir mi, evet ise nasıl? evet dataoutputstream javada primitive typelari binarye cevirip yazmak icin kullanilir. buffered reader ve scanner sınıfları ile dosya okurken dosyanın sonuna geldiğini nasıl kontrol edilir? readline() != null kontrolu yapilabilir binary bir dosya okurken dosyanın sonuna gelindiği nasıl test edilir? read() metodu -1 verir veya available() metodu denebilir. public class randomaccessdemo { public static void main(string[] args) throws exception { randomaccessfile raf = new randomaccessfile(""numbers.bin"", ""rw""); raf.writeint(10); raf.writeint(20); raf.seek(0); int a = raf.readint(); raf.seek(7); byte b = raf.readbyte(); system.out.println(a + "" "" + b); raf.close(); } } output? 10 0 public class demo { public static void main(string[] args) throws exception { try{ fileoutputstream fos = new fileoutputstream(""log.txt"", true); printwriter pw = new printwriter(fos); pw.println(""new log entry""); throw new exception(); } catch(exception e){ system.err(""oopps!""); } } } bu kod çalıştırıldığında log.txt dosyası nasıl etkilenir, açıklayınız. ilk derleme hatasi verir, eger compile edilebilecek duzeye gelirse log.txt de degisikligin meydana gelmemesi beklenir. kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public class latte extends basecoffee{ public string getname() { return ""latte""; } @override public double calculateprice() { double totalprice = 0; totalprice +=50; for(coffeeaddon x : addons) { totalprice += x.getcost(); } return totalprice; } } public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(""\n""); coffeemachine.totalcoffeemade(); } } import java.util.arraylist; public class espresso extends basecoffee{ private boolean isheated = false; public string getname() { if(isheated) { return ""espresso (sicak fincan)""; } else { return ""espresso""; } } @override public double calculateprice() { double totalprice = 0; totalprice +=40; for(coffeeaddon x : addons) { totalprice += x.getcost(); } return totalprice; } public void heatcup() { isheated = true; } } public class vanillasyrup implements coffeeaddon { @override public double getcost() { return 6; } public string getname() {return ""vanilla syrup"";} } public abstract interface coffeeaddon { double getcost(); string getname(); } import java.util.arraylist; public abstract class basecoffee { public abstract string getname(); protected arraylist<coffeeaddon> addons; basecoffee() { addons = new arraylist<coffeeaddon>(); } public void addaddon(coffeeaddon x){ addons.add(x); } public abstract double calculateprice(); } public class americano extends basecoffee{ public string getname() { return ""americano""; } public double calculateprice() { double totalprice = 0; totalprice +=45; for(coffeeaddon x : addons) { totalprice += x.getcost(); } return totalprice; } } public class coffeemachine { static int toplamkahveuretimi; public void addaddontocoffee(basecoffee coffee, coffeeaddon addon) { if(coffee instanceof espresso) { if(addon instanceof doubleshot || addon instanceof chocolate) { coffee.addaddon(addon); } else { system.out.println(""[uyari] "" + coffee.getname() + "" tipi kahveye "" + addon.getname() + "" eklenmez""); } } else if(coffee instanceof latte) { if(addon instanceof milk || addon instanceof chocolate || addon instanceof vanillasyrup) { coffee.addaddon(addon); } else { system.out.println(""[uyari] "" + coffee.getname() + "" tipi kahveye "" + addon.getname() + "" eklenmez""); } } else if(coffee instanceof americano) { if(addon instanceof milk || addon instanceof vanillasyrup) { coffee.addaddon(addon); } else { system.out.println(""[uyari] "" + coffee.getname() + "" tipi kahveye "" + addon.getname() + "" eklenmez""); } } } public void makecoffee(basecoffee coffee) { toplamkahveuretimi +=1; system.out.print(""siprais: "" + coffee.getname()); for(coffeeaddon x : coffee.addons) { system.out.print("" + ""); system.out.print(x.getname()); } system.out.println(); system.out.println(""toplam fiyat:"" + (int) coffee.calculateprice() + ""tl""); system.out.println(); } public void heatespressocup(basecoffee coffee) { if(coffee instanceof espresso) { system.out.println(""espresso kahve fincanı ısıtıldı""); ((espresso) coffee).heatcup(); } else { system.out.println(""[uyari] yalnızca espresso kahve fincanları ısıtılabilir""); } } public static void totalcoffeemade() { system.out.println(""tum fabrikalar kahve makineleri toplam ""+ toplamkahveuretimi + "" kahve uretildi""); } } public class milk implements coffeeaddon { public double getcost() { return 5; } public string getname() { return ""milk""; } } public class doubleshot implements coffeeaddon{ @override public double getcost() { return 10; } public string getname() { return ""double shot""; } } public class chocolate implements coffeeaddon { @override public double getcost() { return 7; } public string getname() { return ""chocolate""; } } bil211 quiz 4 section 1 quizleri uzak sistemine yükleyeceksiniz. q1: yalnızca tek sayıları saklayan liste oddnumberlist adında bir sınıf oluşturun. bu sınıf: ● add(t item) → yalnızca tek sayılar eklenebilir. çift sayı eklenmeye çalışılırsa hata mesajı basılır. ● addall(collection<t> collection) → sadece içindeki tek sayıları ekler. ● getoddnumbers() → i̇çerideki tüm tek sayıları liste olarak döndürür. ● sumofodds() → tüm tek sayıların toplamını döndürür. örnek kullanım: oddnumberlist list = new oddnumberlist(); list.add(5); list.add(3); list.add(8); // eklenmemeli system.out.println(list); // çıktı: [5, 3] q2: koleksiyondan tekrar edenleri kaldırma ● bir collection<t> içindeki tüm tekrar eden öğeleri kaldıran bir generic metod yazın. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> removeduplicates(collection<t> collection) { // metodu tamamlayın } örnek kullanım: list<string> words = arrays.aslist(""apple"", ""banana"", ""apple"", ""orange"", ""banana"", ""grape""); system.out.println(removeduplicates(words)); q3:aşağıdaki generic metodu tamamlayın. ● verilen list<t> içindeki tüm öğeleri büyük harfe çeviren (veya sayıysa olduğu gibi bırakan) bir metod yazın. ● eğer t bir string ise büyük harfe çevirmeli, değilse değiştirmemelidir. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> converttouppercaseifstring(list<t> list) { // metodu tamamlayın } örnek kullanım: list<object> items = arrays.aslist(""hello"", 123, ""world"", 456); system.out.println(converttouppercaseifstring(items)); import java.util.arraylist; import java.util.arrays; import java.util.collection; import java.util.list; public class main { public static void main(string[] args) { oddnumberlist list = new oddnumberlist(); list.add(5); list.add(8); list.add(3); system.out.println(""cift sayi girdin kanka""); system.out.println(list); list<string> words = arrays.aslist(""apple"", ""banana"", ""apple"", ""orange"", ""banana"", ""grape""); system.out.println(removeduplicates(words)); list<object> items = arrays.aslist(""hello"", 123, ""world"", 456); system.out.println(converttouppercaseifstring(items)); } public static <t> list<t> removeduplicates(collection<t> collection) { list<t> list; list = new arraylist<t>(); for (t t : collection) { if (!list.contains(t)) { list.add(t); } } return list; } public static <t> list<t> converttouppercaseifstring(list<t> list) { list<t> liste = new arraylist<t>(); for(t t : list) { if(t instanceof string) { liste.add((t) (((string) t).touppercase())); } } return liste; } } import java.util.arraylist; import java.util.collection; import java.util.list; public class oddnumberlist<t extends number> { private list<t> numbers; public oddnumberlist() { numbers = new arraylist<>(); } public void add(t number){ if(number.intvalue() % 2 != 0) numbers.add(number); else system.out.println(number + ""is even""); } public void addall(collection<t> collection) { for( t number : collection) { if(number.intvalue() %2 !=0) { numbers.add(number); } } } public list<t> getoddnumbers() { return numbers; } public int sumofodds() { int sum =0; for(t number : numbers) { sum += number.intvalue(); } return sum; } public string tostring() { return numbers.tostring(); } } 9 kuş bakışı atış oyunu (top-down shooter) bil 211 - proje teslim tarihi: 27 mart 2025 23:59 1 amaç bu ödevde amacınız, java swing kullanarak kuş bakışı bir atış oyunu (top-down shooter) tasarlamaktır. oyunda, yönettiğimiz karakterin üzerine dalga dalga gelen çeşitli zombileri fare ile hedef alarak farklı silahlar kullanıp öldürmemiz gerekmektedir. karakterimiz öldüğünde oyun sona erecektir. her dalga başına ve öldürülen zombi başına kazanılan puan artacaktır. dalgalar ilerledikçe gelen zombilerin sayısı ve çeşitleri artarak zorluk seviyesi yükselecektir. 2 gereksinimler oyun derste öğrendiğiniz oop ilkelerine uygun sınıf/arayüz tasarımları ile geliştirilmelidir. - zorluk seviyesi arttıkça zombi sayısı ve çeşitliliği artmalıdır. - oyun duraklatılabilmeli ve kaydedilip tekrar yüklenilebilmelidir (fileio kullanılmalıdır). - sol üst köşede seçili silah ve kalan mermi miktarı gösterilmelidir. - sağ üst köşede oyuncunun canı ve toplam puanı gösterilmelidir. - oyunun duraklatılması, kaydedilmesi ve devam ettirilmesi için bir menü bulunmalıdır. 3 silahlar oyunda farklı silahlar bulunmaktadır. belirli zombi dalgaları temizlendikten sonra oyun ödül olarak yeni bir silahverecektir. hersilahınkendineözgübirçalışmamekanizmasıvardır. silahlarınşarjörkapasitesisınırlıdır ve şarjördeki mermiler bittiğinde tekrar doldurulmadan ateş edilemez. toplam mermi sayısı oyuncunun o silaha ait elinde ne kadar mermi olduğunu gösterir. r tuşuna basarak şarjör yeniden doldurulabilir. 3.1 tabanca - şarjör kapasitesi: 12 mermi - ateş hızı: 120 mermi/dakika - elde etme: oyuncu oyuna bu silahla başlar. - özellik: düz atış yapar, sapma yoktur. sınırsız yedek şarjör (diğer tüm silahlar için yedek şarjör ve mermiler rastgele bir şekilde dalga sırasında ve sonlarında zombilerden düşer). 3.2 piyade tüfeği - şarjör kapasitesi: 30 mermi - ateş hızı: 600 mermi/dakika - elde etme: 1. dalga tamamlandıktan sonra - özellik: düzatışyaparancak30derecesapmasıvardır. sapmaaçısı, karakterinbaktığıyöndemerminin her iki dönme yönüne de saçılabileceği maksimum açıdır. 1 3.3 pompalı tüfek - şarjör kapasitesi: 5 mermi - ateş hızı: 60 mermi/dakika - elde etme: 3. dalga tamamlandıktan sonra - özellik: her atış 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi atar (yani karakter merkezli mermi hız vektörleri arasında 5 derece açı olmalıdır). 3.4 keskin nişancı tüfeği - şarjör kapasitesi: 5 mermi - ateş hızı: 30 mermi/dakika - elde etme: 5. dalga tamamlandıktan sonra - özellik: mermileri zombileri delip arasındaki zombilere de hasar verir. 3.5 roketatar - şarjör kapasitesi: 1 roket - ateş hızı: 10 roket/dakika - elde etme: 10. dalga tamamlandıktan sonra - özellik: patlama etkisiyle birden fazla zombiye zarar verir. 4 zombiler zombiler oyundaki düşman tipleridir. zombiler oyuncuya doğru ilerlerler ve eğer oyuncuya temas ederlerse oyuncuya hasar verirler. zorluk seviyesi arttıkça zombilerin sayısı ve çeşitliliği artmaktadır. zombi tipleri birbirinden renk ya da şekil olarak ayırt edilebilmelidir. 4.1 normal zombi - can: orta - hız: yavaş - hasar: orta 4.2 sürünge zombi - can: düşük - hız: hızlı - hasar: orta - özellik: oyuncunun yakınına geldiğinde zıplar. 4.3 tank zombi - can: yüksek - hız: çok yavaş - hasar: yüksek 2 4.4 asit tüküren zombi - can: düşük - hız: yavaş - hasar: orta (uzaktan asit tükürebilir) - özellik: öldürüldüğünde yanındaki birimlere zarar verir. 5 rapor ve teslim formatı - oyun, oopprensiplerineuygunolaraktasarlanmalıvesınıfdiyagramları, arayüztasarımıfinalraporda sunulmalıdır. - oyun test edilerek ekran görüntüleri rapora eklenmelidir. - rapor pdf formatında olmalı ve ismi proje_rapor.pdf olmalıdır. - oyunun mainfonksiyonu gameisimli bir sınıf içinde bulunmalıdır ( java game komutuyla çalışmalı). - kaynak kodun tamamı source.zip (uzantı 7z, rar, tar.gz de olabilir) şeklinde sıkıştırılmış olmalıdır. - sıkıştırılmış kaynak kod ve rapor uzak sistemine yüklenmelidir. 6 yardımcı kaynaklar dahaöncehiçkuşbakışıatışoyunuoynamadıysanızaşağıdakioyunlarıreferansolarakalabilirsiniz. buradaki oyunlarıngrafikleriilemekaniklerisizdenbeklenendenfarklıolsadaharitatasarımı, karakterhareketi,kamera hareketi, ateş etme mekanikleri ve zombilerin yapay zekası ile ilgili temel fikirler edinebilirsiniz. - little top-down shooter: https://www.youtube.com/watch?v=pj3m3fu3i5a - super c - stage 2: https://www.youtube.com/watch?v=os2t_v5suj4 - neon chrome: https://www.youtube.com/watch?v=puhw1bevtro 3 import java.awt.graphics2d; import java.awt.image; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; public class shellcasing { double x, y; double dx, dy; int life = 80; bufferedimage image; public shellcasing(int startx, int starty) { x = startx; y = starty; double angle = math.toradians(math.random() * 360); double speed = 1.0 + math.random() * 2.5; dx = math.cos(angle) * speed; dy = math.sin(angle) * speed; try { image = imageio.read(new file(""sprites/effects/shell.png"")); image = resizeimage(image, 3, 6); } catch (ioexception e) { system.out.println(""[hata] shell image yüklenemedi.""); } } public void update() { x += dx; y += dy; life--; } public boolean isalive() { return life > 0; } public void draw(graphics2d g2d) { g2d.drawimage(image, (int) x - image.getwidth() / 2, (int) y - image.getheight() / 2, null); } private bufferedimage resizeimage(bufferedimage originalimage, int targetwidth, int targetheight) { image scaledimage = originalimage.getscaledinstance(targetwidth, targetheight, image.scale_smooth); bufferedimage resizedimage = new bufferedimage(targetwidth, targetheight, bufferedimage.type_int_argb); graphics2d g2 = resizedimage.creategraphics(); g2.drawimage(scaledimage, 0, 0, null); g2.dispose(); return resizedimage; } } import java.awt.graphics2d; import java.awt.image; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import java.util.list; import javax.imageio.imageio; public abstract class zombie { protected int x, y; protected int health; protected double speed; protected int damage; protected boolean alive = true; protected boolean isattacking = false; protected int attackindex = 0, attackcounter = 0, attackdelay = 6; protected int walkindex = 0, walkcounter = 0, walkdelay = 10; protected int attackcooldown = 0; protected int defaultcooldown = 60; protected bufferedimage[] walkframes; protected bufferedimage[] attackframes; public zombie(int x, int y, int health, double speed, int damage) { this.x = x; this.y = y; this.health = health; this.speed = speed; this.damage = damage; } public int getx() { return x; } public int gety() { return y; } public abstract void draw(graphics2d g2d); public void takedamage(int amount) { health -= amount; if (health <= 0) { alive = false; ondeath(); } } public void takedamage(int amount, double pushangle) { takedamage(amount); x += (int) (math.cos(pushangle) * 8); y += (int) (math.sin(pushangle) * 8); } public boolean isalive() { return alive; } public boolean justdied() { return !alive && health <= 0; } protected void ondeath() { // override if needed } public boolean iscollidingwithplayer(player player) { rectangle zombierect = new rectangle(x, y, 32, 32); rectangle playerrect = new rectangle(player.getx(), player.gety(), player.getsize(), player.getsize()); return zombierect.intersects(playerrect); } protected bufferedimage resizeimage(bufferedimage original, int w, int h) { image scaled = original.getscaledinstance(w, h, image.scale_smooth); bufferedimage resized = new bufferedimage(w, h, bufferedimage.type_int_argb); graphics2d g2 = resized.creategraphics(); g2.drawimage(scaled, 0, 0, null); g2.dispose(); return resized; } public rectangle getbounds() { return new rectangle(x, y, 32, 32); } public abstract void update(player player, list<zombie> zombies, list<rectangle> obstacles); } class guts { private int x, y; private int duration = 120; // 3 saniye private bufferedimage sprite; public guts(int x, int y) { this.x = x; this.y = y; try { sprite = imageio.read(new file(""sprites/effects/guts.png"")); } catch (ioexception e) { system.out.println(""[hata] acid sprite yüklenemedi.""); } } public void update() { duration--; } public boolean isalive() { return duration > 0; } public rectangle getbounds() { return new rectangle(x, y, 16, 16); } public void draw(graphics2d g2d) { g2d.drawimage(sprite, x, y, 16, 16, null); } } import java.awt.*; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; public class piercingbullet extends bullet { private bufferedimage image; private final int width = 6, height = 6; private int lifetime = 120; // 2 saniye public piercingbullet(int x, int y, double angle) { super(x, y, angle); try { image = imageio.read(new file(""sprites/effects/bullet.png"")); } catch (ioexception e) { system.out.println(""[hata] piercingbullet görseli yok.""); } } @override public void update() { x += dx; y += dy; lifetime--; } public boolean isalive() { return lifetime > 0; } @override public rectangle getbounds() { return new rectangle(x, y, width, height); } @override public void draw(graphics2d g2d) { if (image != null) { g2d.drawimage(image, x, y, width, height, null); } else { g2d.setcolor(color.cyan); g2d.filloval(x, y, width, height); } } } import java.awt.*; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import java.util.random; import javax.imageio.imageio; public class playerblood { private int x, y; private int duration = 60; // kaç frame sonra kaybolsun private bufferedimage image; private static final int offset_range = 12; // +/- max offset private static final random rand = new random(); public playerblood(int x, int y) { int offsetx = rand.nextint(offset_range * 2 + 1) - offset_range; int offsety = rand.nextint(offset_range * 2 + 1) - offset_range; this.x = x + offsetx; this.y = y + offsety; try { image = imageio.read(new file(""sprites/effects/guts.png"")); } catch (ioexception e) { system.out.println(""[hata] player kan efekti yüklenemedi.""); } } public void update() { duration--; } public boolean isalive() { return duration > 0; } public void draw(graphics2d g2d) { if (image != null) g2d.drawimage(image, x, y, 8, 8, null); } } import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import java.util.list; import javax.imageio.imageio; public class acidzombie extends zombie { private final double attack_range = 20; public acidzombie(int x, int y) { super(x, y, 50, 1.1, 30); walkframes = new bufferedimage[4]; attackframes = new bufferedimage[6]; try { for (int i = 0; i < 4; i++) { string path = string.format(""sprites/zombie/acidzombie/acidzombie_walk/%02d_acidzombie_walk.png"", i); walkframes[i] = resizeimage(imageio.read(new file(path)), 32, 32); } for (int i = 0; i < 6; i++) { string path = string.format(""sprites/zombie/acidzombie/acidzombie_attack/%02d_acidzombie_attack.png"", i); attackframes[i] = resizeimage(imageio.read(new file(path)), 32, 32); } } catch (ioexception e) { system.out.println(""[hata] acidzombie sprite'ları yüklenemedi.""); } } @override protected void ondeath() { // ölünce yere asit bırakma kodu gamepanel'de yazılıyor } @override public void update(player player, list<zombie> zombies, list<rectangle> obstacles) { if (!alive) return; double dx = player.getx() - x; double dy = player.gety() - y; double distance = math.sqrt(dx * dx + dy * dy); // === saldiri === if (distance < attack_range) { if (attackcooldown <= 0) { player.takedamage(damage); attackcooldown = defaultcooldown; attackindex = 0; attackcounter = 0; isattacking = true; } } // === hareket === if (!isattacking && distance >= attack_range) { double nextx = x + speed * dx / distance; double nexty = y + speed * dy / distance; rectangle nextbounds = new rectangle((int) nextx, (int) nexty, 32, 32); boolean blocked = false; for (zombie other : zombies) { if (other != this && other.isalive() && nextbounds.intersects(other.getbounds())) { blocked = true; break; } } for (rectangle rect : obstacles) { if (nextbounds.intersects(rect)) { blocked = true; break; } } if (!blocked) { x = (int) nextx; y = (int) nexty; } } // === cooldown === if (attackcooldown > 0) attackcooldown--; // === ani̇masyon === if (isattacking) { attackcounter++; if (attackcounter >= attackdelay) { attackcounter = 0; attackindex++; if (attackindex >= attackframes.length) { attackindex = 0; isattacking = false; } } } else { walkcounter++; if (walkcounter >= walkdelay) { walkcounter = 0; walkindex = (walkindex + 1) % walkframes.length; } } } @override public void draw(graphics2d g2d) { bufferedimage frame = isattacking ? attackframes[attackindex] : walkframes[walkindex]; g2d.drawimage(frame, x, y, null); } } import java.util.list; public abstract class weapon { protected int magsize; protected int currentammo; protected int reserveammo; protected double firerate; protected long lastshottime = 0; public weapon(int magsize, int reserveammo, double firerate) { this.magsize = magsize; this.reserveammo = reserveammo; this.currentammo = magsize; this.firerate = firerate; } public boolean canshoot() { long now = system.currenttimemillis(); return currentammo > 0 && (now - lastshottime) >= (60000 / firerate); } public void shoot() { if (canshoot()) { currentammo--; lastshottime = system.currenttimemillis(); } } public void reload() { int needed = magsize - currentammo; int taken = math.min(needed, reserveammo); currentammo += taken; reserveammo -= taken; } public boolean needsreload() { return currentammo < magsize && reserveammo > 0; } public void addreserveammo(int amount) { reserveammo += amount; } public int getammo() { return currentammo; } public int getmagsize() { return magsize; } public int getreserveammo() { return reserveammo; } public abstract void fire(double angle, int x, int y, list<bullet> bullets, list<rocketammo> rockets, list<smokeeffect> smoke); public abstract string getname(); } // örnek handgun class handgun extends weapon { public handgun() { super(12, 9999, 120); } @override public void fire(double angle, int x, int y, list<bullet> bullets, list<rocketammo> rockets, list<smokeeffect> smoke) { if (!canshoot()) return; shoot(); bullets.add(new bullet(x, y, angle)); } @override public string getname() { return ""handgun""; } } // rifle class rifle extends weapon { public rifle() { super(30, 120, 600); } @override public void fire(double angle, int x, int y, list<bullet> bullets, list<rocketammo> rockets, list<smokeeffect> smoke) { if (!canshoot()) return; shoot(); double spread = math.toradians(30); double offset = (math.random() - 0.5) * spread; bullets.add(new bullet(x, y, angle + offset)); } @override public string getname() { return ""rifle""; } } // shotgun class shotgun extends weapon { public shotgun() { super(5, 25, 60); } @override public void fire(double angle, int x, int y, list<bullet> bullets, list<rocketammo> rockets, list<smokeeffect> smoke) { if (!canshoot()) return; shoot(); int pelletcount = 9; double totalspread = math.toradians(45); double delta = totalspread / (pelletcount - 1); for (int i = 0; i < pelletcount; i++) { double offset = -totalspread / 2 + delta * i; bullets.add(new bullet(x, y, angle + offset)); } } @override public string getname() { return ""shotgun""; } } // sniper => piercingbullet class sniper extends weapon { public sniper() { super(5, 15, 30); } @override public void fire(double angle, int x, int y, list<bullet> bullets, list<rocketammo> rockets, list<smokeeffect> smoke) { if (!canshoot()) return; shoot(); bullets.add(new piercingbullet(x, y, angle)); } @override public string getname() { return ""sniper""; } } // rocket => rocket ammo class rocket extends weapon { public rocket() { super(1, 5, 10); } @override public void fire(double angle, int x, int y, list<bullet> bullets, list<rocketammo> rockets, list<smokeeffect> smokelist) { if (!canshoot()) return; shoot(); rockets.add(new rocketammo(x, y, angle, smokelist)); } @override public string getname() { return ""rocket""; } } import java.awt.graphics2d; import java.awt.image; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; class bullet { int x, y; double dx, dy; int speed = 10; bufferedimage bulletimage; public bullet(int startx, int starty, double angle) { x = startx; y = starty; dx = math.cos(angle) * speed; dy = math.sin(angle) * speed; try { bulletimage = imageio.read(new file(""sprites/effects/shell.png"")); bulletimage = resizeimage(bulletimage, 2, 4); } catch (ioexception e) { system.out.println(""[hata] bullet shell yüklenemedi.""); } } public void update() { x += dx; y += dy; } public void draw(graphics2d g2d) { g2d.drawimage(bulletimage, x - bulletimage.getwidth() / 2, y - bulletimage.getheight() / 2, null); } private bufferedimage resizeimage(bufferedimage originalimage, int targetwidth, int targetheight) { image scaledimage = originalimage.getscaledinstance(targetwidth, targetheight, image.scale_smooth); bufferedimage resizedimage = new bufferedimage(targetwidth, targetheight, bufferedimage.type_int_argb); graphics2d g2d = resizedimage.creategraphics(); g2d.drawimage(scaledimage, 0, 0, null); g2d.dispose(); return resizedimage; } public rectangle getbounds() { return new rectangle(x, y, bulletimage.getwidth(), bulletimage.getheight()); } } import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; public class acid { private int x, y; private int duration = 180; // 3 saniye private bufferedimage sprite; public acid(int x, int y) { this.x = x; this.y = y; try { sprite = imageio.read(new file(""sprites/effects/acid.png"")); } catch (ioexception e) { system.out.println(""[hata] acid sprite yüklenemedi.""); } } public void update() { duration--; } public boolean isalive() { return duration > 0; } public rectangle getbounds() { return new rectangle(x, y, 32, 32); } public void draw(graphics2d g2d) { g2d.drawimage(sprite, x, y, 32, 32, null); } } import javax.swing.imageicon; import javax.swing.jframe; public class gamewindow extends jframe { private gamepanel panel; public gamewindow(boolean load) { settitle(""alpocalypse - in game""); panel = new gamepanel(this); if (load) { panel.loadgame(); } seticonimage(new imageicon(""sprites/menu/background.png"").getimage()); setdefaultcloseoperation(exit_on_close); setresizable(false); add(panel); pack(); setlocationrelativeto(null); setvisible(true); panel.startgamethread(); } public void returntomenu() { // panel istemciden ""game over"" verirse burası çağrılır dispose(); new mainmenu(); } } import java.awt.*; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import java.util.list; import javax.imageio.imageio; public class normalzombie extends zombie { public normalzombie(int x, int y) { super(x, y, 100, 1.3, 20); // can, hız, hasar walkframes = new bufferedimage[17]; attackframes = new bufferedimage[9]; try { for (int i = 0; i < 17; i++) { walkframes[i] = resizeimage(imageio.read(new file(string.format( ""sprites/zombie/normalzombie/move/skeleton-move_%d.png"", i))), 32, 32); } for (int i = 0; i < 9; i++) { attackframes[i] = resizeimage(imageio.read(new file(string.format( ""sprites/zombie/normalzombie/attack/skeleton-attack_%d.png"", i))), 32, 32); } } catch (ioexception e) { system.out.println(""[hata] normalzombie sprite'lari yüklenemedi.""); } } @override public void update(player player, list<zombie> zombies, list<rectangle> obstacles) { if (!alive) return; final double attack_range = 20; double dx = player.getx() - x; double dy = player.gety() - y; double distance = math.sqrt(dx * dx + dy * dy); if (distance <= attack_range) { if (attackcooldown <= 0) { player.takedamage(damage); attackcooldown = defaultcooldown; attackindex = 0; attackcounter = 0; isattacking = true; } } else if (!isattacking) { double nextx = x + speed * dx / distance; double nexty = y + speed * dy / distance; rectangle nextbounds = new rectangle((int) nextx, (int) nexty, 32, 32); boolean blocked = false; for (zombie z : zombies) { if (z != this && z.isalive() && nextbounds.intersects(z.getbounds())) { blocked = true; break; } } for (rectangle rect : obstacles) { if (nextbounds.intersects(rect)) { blocked = true; break; } } if (!blocked) { x = (int) nextx; y = (int) nexty; } } if (attackcooldown > 0) attackcooldown--; if (isattacking) { attackcounter++; if (attackcounter >= attackdelay) { attackcounter = 0; attackindex++; if (attackindex >= attackframes.length) { attackindex = 0; isattacking = false; } } } else { walkcounter++; if (walkcounter >= walkdelay) { walkcounter = 0; walkindex = (walkindex + 1) % walkframes.length; } } } @override public void draw(graphics2d g2d) { bufferedimage frame = isattacking ? attackframes[attackindex] : walkframes[walkindex]; g2d.drawimage(frame, x, y, null); } } import java.awt.*; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import java.util.list; import javax.imageio.imageio; public class rocketammo { public int x, y; public double dx, dy; private final int speed = 3; private boolean exploded = false; private bufferedimage image; private final int radius = 120; private int width = 20, height = 30; private list<smokeeffect> smokelist; public rocketammo(int startx, int starty, double angle, list<smokeeffect> smokelist) { x = startx; y = starty; dx = math.cos(angle) * speed; dy = math.sin(angle) * speed; this.smokelist = smokelist; try { image = imageio.read(new file(""sprites/effects/rocketammo.png"")); } catch (ioexception e) { system.out.println(""[hata] roket sprite yuklenemedi.""); } } public void update(list<zombie> zombies) { if (exploded) return; x += dx; y += dy; rectangle rocketrect = new rectangle(x, y, width, height); for (zombie z : zombies) { if (z.isalive() && rocketrect.intersects(z.getbounds())) { explode(zombies); break; } } } public void explode(list<zombie> zombies) { exploded = true; // roketin merkezini bulalım int rocketcenterx = x + width / 2; int rocketcentery = y + height / 2; // alan hasarı for (zombie z : zombies) { if (!z.isalive()) continue; int zx = z.getx() + 16; int zy = z.gety() + 16; double dist = point.distance(rocketcenterx, rocketcentery, zx, zy); if (dist <= radius) { z.takedamage(50); } } // duman if (smokelist != null) { smokelist.add(new smokeeffect(rocketcenterx, rocketcentery)); } } public boolean isexploded() { return exploded; } public void draw(graphics2d g2d) { if (!exploded && image != null) { g2d.drawimage(image, x, y, width, height, null); } } } import java.awt.*; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; public class smokeeffect { private int x, y; private int duration = 120; // kaç frame kalacak private bufferedimage image; public smokeeffect(int x, int y) { this.x = x; this.y = y; try { image = imageio.read(new file(""sprites/effects/smoke.png"")); } catch (ioexception e) { system.out.println(""[hata] duman efekti yüklenemedi.""); } } public void update() { duration--; } public boolean isalive() { return duration > 0; } public void draw(graphics2d g2d) { if (image != null) { g2d.drawimage(image, x - 16, y - 16, 16, 16, null); } } } import java.awt.graphics2d; import java.awt.image; import java.awt.image.bufferedimage; import java.io.file; import javax.swing.*; public class mainmenu extends jframe { private jbutton newgamebtn, loadgamebtn, scoreboardbtn, exitbtn; private jlabel backgroundlabel; public mainmenu() { settitle(""alpocalypse main menu""); setsize(600, 400); setdefaultcloseoperation(jframe.exit_on_close); seticonimage(new imageicon(""sprites/menu/background.png"").getimage()); setlayout(null); // arka plan resmi (isteğe bağlı) imageicon bgicon = new imageicon(""sprites/menu/background.png""); image bgscaled = bgicon.getimage().getscaledinstance(600, 400, image.scale_smooth); imageicon newbg = new imageicon(bgscaled); backgroundlabel = new jlabel(newbg); backgroundlabel.setbounds(0, 0, 600, 400); // new game butonu imageicon newgameicon = new imageicon(""sprites/menu/newgame.jpg""); image scalednew = newgameicon.getimage().getscaledinstance(150, 40, image.scale_smooth); imageicon scalednewicon = new imageicon(scalednew); newgamebtn = new jbutton(scalednewicon); newgamebtn.setbounds(50, 50, 150, 40); newgamebtn.setborderpainted(false); newgamebtn.setcontentareafilled(false); newgamebtn.setfocuspainted(false); newgamebtn.addactionlistener(e -> { startnewgame(); }); // load game butonu imageicon loadgameicon = new imageicon(""sprites/menu/loadgame.jpg""); image scaledload = loadgameicon.getimage().getscaledinstance(150, 40, image.scale_smooth); imageicon scaledloadicon = new imageicon(scaledload); loadgamebtn = new jbutton(scaledloadicon); loadgamebtn.setbounds(50, 110, 150, 40); loadgamebtn.setborderpainted(false); loadgamebtn.setcontentareafilled(false); loadgamebtn.setfocuspainted(false); loadgamebtn.addactionlistener(e -> { file f = new file(""savegame.txt""); if (!f.exists()) { joptionpane.showmessagedialog(this, ""no saved game found!""); return; } startloadedgame(); }); // scoreboard butonu imageicon scoregameicon = new imageicon(""sprites/menu/scoreboard.jpg""); image scaledscore = scoregameicon.getimage().getscaledinstance(150, 40, image.scale_smooth); imageicon scaledscoreicon = new imageicon(scaledscore); scoreboardbtn = new jbutton(scaledscoreicon); scoreboardbtn.setbounds(50, 170, 150, 40); scoreboardbtn.setborderpainted(false); scoreboardbtn.setcontentareafilled(false); scoreboardbtn.setfocuspainted(false); scoreboardbtn.addactionlistener(e -> { joptionpane.showmessagedialog(this, ""max score so far = "" + game.maxscore); }); // exit butonu imageicon exitgameicon = new imageicon(""sprites/menu/exit.jpg""); image scaledexit = exitgameicon.getimage().getscaledinstance(150, 40, image.scale_smooth); imageicon scaledexiticon = new imageicon(scaledexit); exitbtn = new jbutton(scaledexiticon); exitbtn.setbounds(50, 230, 150, 40); exitbtn.setborderpainted(false); exitbtn.setcontentareafilled(false); exitbtn.setfocuspainted(false); exitbtn.addactionlistener(e -> system.exit(0)); // ekleme sırası add(newgamebtn); add(loadgamebtn); add(scoreboardbtn); add(exitbtn); add(backgroundlabel); setlocationrelativeto(null); setvisible(true); } private void startnewgame() { new gamewindow(false); dispose(); // menüyü kapat } private void startloadedgame() { new gamewindow(true); dispose(); } protected bufferedimage resizeimage(bufferedimage original, int w, int h) { image scaled = original.getscaledinstance(w, h, image.scale_smooth); bufferedimage resized = new bufferedimage(w, h, bufferedimage.type_int_argb); graphics2d g2 = resized.creategraphics(); g2.drawimage(scaled, 0, 0, null); g2.dispose(); return resized; } } import java.awt.*; import java.awt.event.*; import java.awt.geom.affinetransform; import java.awt.image.bufferedimage; import java.io.file; import java.io.printwriter; import java.util.*; import java.util.list; import javax.swing.*; public class gamepanel extends jpanel implements keylistener, runnable, mousemotionlistener, mouselistener, mousewheellistener { public static final int swid = 1440; public static final int shei = 980; private thread gamethread; private final int fps = 60; private player player; private tilemanager mapper; private point aim = new point(swid / 2, shei / 2); private boolean gameovertriggered = false; private list<zombie> zombies = new arraylist<>(); private list<bullet> bullets = new arraylist<>(); private list<rocketammo> rockets = new arraylist<>(); private list<smokeeffect> smokelist = new arraylist<>(); private list<shellcasing> shells = new arraylist<>(); private list<muzzleflash> flashes = new arraylist<>(); private list<acid> acids = new arraylist<>(); private list<guts> guts = new arraylist<>(); private list<playerblood> playerbloods = new arraylist<>(); private list<rectangle> obstacles; private int score = 0; private int combo = 1; private int combotimer = 0; private final int combo_reset_time = 300; private double zoom = 2.5; private int currentlevel = 1; private final int[] zombiesperlevel = { 10, 15, 20, 25, 30 }; private final int max_level = 5; private random rand = new random(); private boolean paused = false; private gamewindow parentwindow; // referans public gamepanel(gamewindow parent) { this.parentwindow = parent; setpreferredsize(new dimension(swid, shei)); setfocusable(true); bufferedimage blankimg = new bufferedimage(16, 16, bufferedimage.type_int_argb); cursor blankcursor = toolkit.getdefaulttoolkit() .createcustomcursor(blankimg, new point(0, 0), ""blank cursor""); setcursor(blankcursor); // devam... addkeylistener(this); addmouselistener(this); addmousemotionlistener(this); addmousewheellistener(this); mapper = new tilemanager(); player = new player(32 * 25, 32 * 15); player.setbloodlist(playerbloods); obstacles = mapper.getsolidrectangles(); spawnzombiesforlevel(currentlevel); } private void spawnzombiesforlevel(int level) { zombies.clear(); int zombiecount = zombiesperlevel[level - 1]; int maph = mapper.maph; int mapw = mapper.mapw; // her zombi => random tile 0..maph-1,0..mapw-1 for (int i = 0; i < zombiecount; i++) { zombie z = createrandomzombie(); // tekrar dene 50 kez for (int tries = 0; tries < 50; tries++) { int r = rand.nextint(maph); int c = rand.nextint(mapw); int tile = mapper.getmap()[r][c]; if (tile == 0 || tile == 1 || tile == 2 || tile == 3) { // spawn z.x = c * 32; z.y = r * 32; break; } } zombies.add(z); } system.out.println(""[info] level "" + level + "" zombileri spawn: "" + zombiecount); } private zombie createrandomzombie() { int t = rand.nextint(4); switch (t) { case 0: return new normalzombie(0, 0); case 1: return new tankzombie(0, 0); case 2: return new acidzombie(0, 0); default: return new jumperzombie(0, 0); } } public void startgamethread() { gamethread = new thread(this); gamethread.start(); } @override public void run() { double interval = 1000000000.0 / fps; double nextdrawtime = system.nanotime() + interval; while (gamethread != null) { if (!paused) { updategame(); } repaint(); try { double remainingtime = nextdrawtime - system.nanotime(); remainingtime = math.max(remainingtime / 1_000_000, 0); thread.sleep((long) remainingtime); nextdrawtime += interval; } catch (interruptedexception e) { e.printstacktrace(); } } } public void updategame() { clampplayerposition(); player.update(aim, mapper); // karakter öldü mü? if (player.gethealth() <= 0) { if (!gameovertriggered) { gameovertriggered = true; // artık 2. kez girmesin system.out.println(""[info] player dead -> game over""); gameover(); } return; // updategame durdur } // zombie zombies.removeif(z -> { z.update(player, zombies, obstacles); if (!z.isalive()) { score += 10 * combo; combo++; combotimer = combo_reset_time; if (z instanceof acidzombie) { acids.add(new acid(z.getx(), z.gety())); } guts.add(new guts(z.getx(), z.gety())); return true; } return false; }); if (zombies.isempty()) { // dalga bitti => +50 ammo player.getallweapons().foreach(w -> w.addreserveammo(50)); currentlevel++; if (currentlevel <= max_level) { spawnzombiesforlevel(currentlevel); } else { system.out.println(""[info] tüm level bitti. oyun sonu.""); game.updatetotalscore(score); // kapat gameover(); return; } } // rockets rockets.foreach(r -> r.update(zombies)); rockets.removeif(r -> r.isexploded()); // smoke list<smokeeffect> tempsmoke = new arraylist<>(); for (smokeeffect s : smokelist) { s.update(); if (s.isalive()) tempsmoke.add(s); } smokelist = tempsmoke; // acid list<acid> tempacids = new arraylist<>(); for (acid a : acids) { a.update(); if (a.getbounds().intersects(player.getbounds())) { player.takedamage(5); playerbloods.add(new playerblood(player.getx(), player.gety())); } if (a.isalive()) tempacids.add(a); } acids = tempacids; // guts list<guts> tempguts = new arraylist<>(); for (guts g : guts) { g.update(); if (g.isalive()) tempguts.add(g); } guts = tempguts; // bullets bullets.foreach(bullet::update); for (int i = 0; i < bullets.size(); i++) { bullet b = bullets.get(i); if (b instanceof piercingbullet) { piercingbullet pb = (piercingbullet) b; for (zombie z : zombies) { if (z.isalive() && z.getbounds().intersects(pb.getbounds())) { double angle = math.atan2(z.gety() - b.y, z.getx() - b.x); z.takedamage(10, angle); } } if (!pb.isalive()) { bullets.remove(i); i--; } } else { boolean hit = false; for (zombie z : zombies) { if (z.isalive() && z.getbounds().intersects(b.getbounds())) { double angle = math.atan2(z.gety() - b.y, z.getx() - b.x); z.takedamage(10, angle); hit = true; break; } } if (hit) { bullets.remove(i); i--; } } } // playerblood playerbloods.removeif(pb -> { pb.update(); return !pb.isalive(); }); shells.removeif(sh -> { sh.update(); return !sh.isalive(); }); flashes.removeif(f -> { f.update(); return !f.isalive(); }); checkitempickup(); if (combotimer > 0) combotimer--; else combo = 1; } private void gameover() { game.updatetotalscore(score); joptionpane.showmessagedialog( this, ""game over!\nyour score = "" + score + ""\nyou reached level "" + currentlevel); // ana menüye dön parentwindow.returntomenu(); } private void clampplayerposition() { int mapwidth = mapper.getmapwidth(); int mapheight = mapper.getmapheight(); int psize = player.getsize(); int minpos = mapper.gettilesize(); if (player.getx() < minpos) player.setx(minpos); if (player.gety() < minpos) player.sety(minpos); if (player.getx() > mapwidth - psize - minpos) player.setx(mapwidth - psize - minpos); if (player.gety() > mapheight - psize - minpos) player.sety(mapheight - psize - minpos); } private void checkitempickup() { int tilesize = mapper.gettilesize(); rectangle bounds = player.getbounds(); int starttilex = bounds.x / tilesize; int starttiley = bounds.y / tilesize; int endtilex = (bounds.x + bounds.width - 1) / tilesize; int endtiley = (bounds.y + bounds.height - 1) / tilesize; int maxcol = mapper.getmap()[0].length - 1; int maxrow = mapper.getmap().length - 1; for (int ty = starttiley; ty <= endtiley; ty++) { for (int tx = starttilex; tx <= endtilex; tx++) { int clampedtx = math.max(0, math.min(tx, maxcol)); int clampedty = math.max(0, math.min(ty, maxrow)); int tile = mapper.gettile(clampedtx, clampedty); if (tile == 6) { player.heal(20); mapper.settile(clampedtx, clampedty, 4); } else if (tile == 7) { player.getallweapons().foreach(w -> w.addreserveammo(30)); mapper.settile(clampedtx, clampedty, 4); } } } } public void savegame() { try (printwriter pw = new printwriter(""savegame.txt"")) { pw.println(currentlevel); pw.println(score); pw.println(player.getx()); pw.println(player.gety()); pw.println(player.gethealth()); int[][] mapdata = mapper.getmap(); pw.println(mapdata.length + "" "" + mapdata[0].length); for (int r = 0; r < mapdata.length; r++) { for (int c = 0; c < mapdata[0].length; c++) { pw.print(mapdata[r][c] + "" ""); } pw.println(); } system.out.println(""[info] game saved!""); } catch (exception ex) { ex.printstacktrace(); } } public void loadgame() { file f = new file(""savegame.txt""); if (!f.exists()) { system.out.println(""[info] no savegame found!""); return; } try (scanner sc = new scanner(f)) { currentlevel = sc.nextint(); score = sc.nextint(); int px = sc.nextint(); int py = sc.nextint(); int hp = sc.nextint(); player.setx(px); player.sety(py); int rows = sc.nextint(); int cols = sc.nextint(); int[][] mapdata = new int[rows][cols]; for (int r = 0; r < rows; r++) { for (int c = 0; c < cols; c++) { mapdata[r][c] = sc.nextint(); } } mapper.setmap(mapdata); obstacles = mapper.getsolidrectangles(); spawnzombiesforlevel(currentlevel); system.out.println(""[info] loaded game from savegame.txt""); } catch (exception e) { e.printstacktrace(); } } private void handlepausemenuinput(int keycode) { if (keycode == keyevent.vk_escape) { paused = false; } else if (keycode == keyevent.vk_s) { savegame(); } else if (keycode == keyevent.vk_e) { system.exit(0); } } @override public void paintcomponent(graphics g) { super.paintcomponent(g); if (!paused) { drawgame((graphics2d) g); } else { drawgame((graphics2d) g); drawpausemenu((graphics2d) g); } } private void drawgame(graphics2d g2dmaster) { graphics2d g2d = (graphics2d) g2dmaster.create(); g2d.setcolor(color.dark_gray); g2d.fillrect(0, 0, getwidth(), getheight()); double camx = player.getx() + player.getsize() / 2.0 - (swid / 2.0) / zoom; double camy = player.gety() + player.getsize() / 2.0 - (shei / 2.0) / zoom; int mapwidth = mapper.getmapwidth(); int mapheight = mapper.getmapheight(); double viewwidth = swid / zoom; double viewheight = shei / zoom; int margin = mapper.gettilesize(); if (mapwidth - 2 * margin >= viewwidth) { if (camx < margin) camx = margin; else if (camx > mapwidth - viewwidth - margin) camx = mapwidth - viewwidth - margin; } else { camx = (mapwidth - viewwidth) / 2.0; } if (mapheight - 2 * margin >= viewheight) { if (camy < margin) camy = margin; else if (camy > mapheight - viewheight - margin) camy = mapheight - viewheight - margin; } else { camy = (mapheight - viewheight) / 2.0; } g2d.scale(zoom, zoom); g2d.translate(-camx, -camy); mapper.draw(g2d, camx, camy, zoom); for (guts gobj : guts) gobj.draw(g2d); acids.foreach(a -> a.draw(g2d)); rockets.foreach(r -> r.draw(g2d)); shells.foreach(s -> s.draw(g2d)); flashes.foreach(f -> f.draw(g2d)); bullets.foreach(b -> b.draw(g2d)); zombies.foreach(z -> z.draw(g2d)); player.draw(g2d); playerbloods.foreach(pb -> pb.draw(g2d)); smokelist.foreach(sm -> sm.draw(g2d)); g2d.settransform(new affinetransform()); drawhud(g2d); g2d.dispose(); } private void drawhud(graphics2d g2d) { g2d.setfont(new font(""arial"", font.bold, 18)); fontmetrics fm = g2d.getfontmetrics(); int leftx = 20; int lefty = 30; int lineheight = 22; g2d.setcolor(color.white); g2d.drawstring(""weapon: "" + player.getcurrentweapon().getname(), leftx, lefty); g2d.drawstring(""ammo: "" + player.getcurrentammo() + "" / "" + player.getmaxammo(), leftx, lefty + lineheight); g2d.drawstring(""reserve: "" + player.getcurrentweapon().getreserveammo(), leftx, lefty + lineheight * 2); // hp, score, level kısımları string healthtext = ""hp: "" + player.gethealth(); string scoretext = ""score: "" + score; string leveltext = ""level: "" + currentlevel; int rightmargin = 20; int rightx = getwidth() - fm.stringwidth(healthtext) - rightmargin; int righty = 30; g2d.drawstring(healthtext, rightx + 720, righty); rightx = getwidth() - fm.stringwidth(scoretext) - rightmargin; righty += lineheight; g2d.drawstring(scoretext, rightx + 720, righty); rightx = getwidth() - fm.stringwidth(leveltext) - rightmargin; righty += lineheight; g2d.drawstring(leveltext, rightx + 720, righty); // === combo display === if (combo > 1) { // örneğin combo'yu sol tarafta, ammo/reserve altına yazarız g2d.setcolor(color.yellow); g2d.drawstring(""combo x"" + combo, leftx, lefty + lineheight * 4); g2d.setcolor(color.white); } } private void drawpausemenu(graphics2d g2d) { g2d.setcolor(new color(0, 0, 0, 150)); g2d.fillrect(0, 0, getwidth(), getheight()); g2d.setcolor(color.white); g2d.setfont(new font(""arial"", font.bold, 24)); string pausedtext = ""game paused (esc->resume, s->save, e->exit)""; int strw = g2d.getfontmetrics().stringwidth(pausedtext); g2d.drawstring(pausedtext, (getwidth() - strw) / 2, getheight() / 2); } // mouse @override public void mousewheelmoved(mousewheelevent e) { if (paused) return; int notches = e.getwheelrotation(); if (notches > 0) { player.nextweapon(); } else if (notches < 0) { player.previousweapon(); } } @override public void keypressed(keyevent e) { if (!paused) { player.keypressed(e); if (e.getkeycode() == keyevent.vk_r) { if (player.getcurrentweapon().needsreload() && !player.isreloading()) { player.startreload(); } } else if (e.getkeycode() == keyevent.vk_escape) { paused = true; } } else { handlepausemenuinput(e.getkeycode()); } } @override public void keyreleased(keyevent e) { player.keyreleased(e); } @override public void keytyped(keyevent e) { } @override public void mouseclicked(mouseevent e) { if (paused) return; if (player.isreloading()) return; point muzzle = player.getmuzzleposition(); double angle = player.getangletomouse(); weapon weapon = player.getcurrentweapon(); if (!weapon.canshoot()) return; weapon.fire(angle, muzzle.x, muzzle.y, bullets, rockets, smokelist); if (!(weapon instanceof rocket)) { flashes.add(new muzzleflash(muzzle.x, muzzle.y, angle)); shells.add(new shellcasing(muzzle.x, muzzle.y)); } player.setstate(player.playerstate.shoot); } @override public void mousemoved(mouseevent e) { if (!paused) { aim = getmouseworldposition(e.getpoint()); } } @override public void mousedragged(mouseevent e) { mousemoved(e); } @override public void mousepressed(mouseevent e) { } @override public void mousereleased(mouseevent e) { } @override public void mouseentered(mouseevent e) { } @override public void mouseexited(mouseevent e) { } public point getmouseworldposition(point screenmouse) { double camx = player.getx() + player.getsize() / 2.0 - (swid / 2.0) / zoom; double camy = player.gety() + player.getsize() / 2.0 - (shei / 2.0) / zoom; return new point( (int) ((screenmouse.x / zoom) + camx), (int) ((screenmouse.y / zoom) + camy)); } } import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import java.util.list; import javax.imageio.imageio; public class jumperzombie extends zombie { private boolean jumping = false; private int jumpcooldown = 120; // 2 saniye bekleme private int jumptimer = 0; private int jumpduration = 12; private int jumpframe = 0; private final double attack_range = 20; public jumperzombie(int x, int y) { super(x, y, 70, 1.7, 30); walkframes = new bufferedimage[9]; attackframes = new bufferedimage[9]; try { for (int i = 0; i < 9; i++) { walkframes[i] = resizeimage(imageio.read(new file(string.format( ""sprites/zombie/jumperzombie/walk/%02d_walk.png"", i))), 32, 32); attackframes[i] = resizeimage(imageio.read(new file(string.format( ""sprites/zombie/jumperzombie/attack/%02d_attack.png"", i))), 32, 32); } } catch (ioexception e) { system.out.println(""[hata] jumperzombie sprite'ları yüklenemedi.""); } } @override public void update(player player, list<zombie> zombies, list<rectangle> obstacles) { if (!alive) return; double dx = player.getx() - x; double dy = player.gety() - y; double distance = math.sqrt(dx * dx + dy * dy); // === saldırı === if (distance < attack_range) { if (attackcooldown <= 0) { player.takedamage(damage); attackcooldown = defaultcooldown; attackindex = 0; attackcounter = 0; isattacking = true; } } // === zıplama hareketi === if (!isattacking && distance >= attack_range) { if (!jumping && jumptimer <= 0) { jumping = true; jumpframe = 0; } if (jumping) { double movex = speed * 3 * dx / distance; double movey = speed * 3 * dy / distance; rectangle nextbounds = new rectangle((int) (x + movex), (int) (y + movey), 32, 32); boolean blocked = false; for (zombie z : zombies) { if (z != this && z.isalive() && nextbounds.intersects(z.getbounds())) { blocked = true; break; } } for (rectangle r : obstacles) { if (nextbounds.intersects(r)) { blocked = true; break; } } if (!blocked) { x += movex; y += movey; } walkcounter++; if (walkcounter >= walkdelay) { walkcounter = 0; walkindex = (walkindex + 1) % walkframes.length; } jumpframe++; if (jumpframe >= jumpduration) { jumping = false; jumptimer = jumpcooldown; } } else { jumptimer--; } } // === cooldown yönetimi === if (attackcooldown > 0) attackcooldown--; // === animasyonlar === if (isattacking) { attackcounter++; if (attackcounter >= attackdelay) { attackcounter = 0; attackindex++; if (attackindex >= attackframes.length) { attackindex = 0; isattacking = false; } } } } @override public void draw(graphics2d g2d) { bufferedimage frame = isattacking ? attackframes[attackindex] : walkframes[walkindex]; g2d.drawimage(frame, x, y, null); } } import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import java.util.list; import javax.imageio.imageio; public class tankzombie extends zombie { private final double attack_range = 20; public tankzombie(int x, int y) { super(x, y, 300, 1.0, 25); walkframes = new bufferedimage[12]; attackframes = new bufferedimage[9]; try { for (int i = 0; i < 12; i++) { string path = string.format(""sprites/zombie/tankzombie/tankwalk/%02d_tankzombie_walk.png"", i); walkframes[i] = resizeimage(imageio.read(new file(path)), 32, 32); } for (int i = 0; i < 9; i++) { string path = string.format(""sprites/zombie/tankzombie/tankattack/%02d_tankzombie_hit.png"", i); attackframes[i] = resizeimage(imageio.read(new file(path)), 32, 32); } } catch (ioexception e) { system.out.println(""[hata] tankzombie sprite'ları yüklenemedi.""); } } @override public void update(player player, list<zombie> zombies, list<rectangle> obstacles) { if (!alive) return; double dx = player.getx() - x; double dy = player.gety() - y; double distance = math.sqrt(dx * dx + dy * dy); // === saldiri === if (distance <= attack_range) { if (attackcooldown <= 0) { player.takedamage(damage); attackcooldown = defaultcooldown; attackindex = 0; attackcounter = 0; isattacking = true; } } // === hareket === if (!isattacking && distance > attack_range) { double nextx = x + speed * dx / distance; double nexty = y + speed * dy / distance; rectangle nextbounds = new rectangle((int) nextx, (int) nexty, 32, 32); boolean blocked = false; for (zombie z : zombies) { if (z != this && z.isalive() && nextbounds.intersects(z.getbounds())) { blocked = true; break; } } for (rectangle rect : obstacles) { if (nextbounds.intersects(rect)) { blocked = true; break; } } if (!blocked) { x = (int) nextx; y = (int) nexty; } } // === saldiri cooldown === if (attackcooldown > 0) attackcooldown--; // === ani̇masyon === if (isattacking) { attackcounter++; if (attackcounter >= attackdelay) { attackcounter = 0; attackindex++; if (attackindex >= attackframes.length) { attackindex = 0; isattacking = false; } } } else { walkcounter++; if (walkcounter >= walkdelay) { walkcounter = 0; walkindex = (walkindex + 1) % walkframes.length; } } } @override public void draw(graphics2d g2d) { bufferedimage frame = isattacking ? attackframes[attackindex] : walkframes[walkindex]; g2d.drawimage(frame, (int) x, (int) y, null); } } import java.awt.graphics2d; import java.awt.image; import java.awt.geom.affinetransform; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; public class muzzleflash { private int x, y; private int life = 3; private double angle; private bufferedimage flashimage; public muzzleflash(int x, int y, double angle) { this.x = x; this.y = y; this.angle = angle; try { flashimage = imageio.read(new file(""sprites/effects/bullet.png"")); flashimage = resizeimage(flashimage, 16, 16); } catch (ioexception e) { system.out.println(""[hata] muzzle flash yüklenemedi.""); } } public void update() { life--; } public boolean isalive() { return life > 0; } public void draw(graphics2d g) { affinetransform old = g.gettransform(); g.rotate(angle, x, y); g.drawimage(flashimage, x - flashimage.getwidth() / 2, y - flashimage.getheight() / 2, null); g.settransform(old); } private bufferedimage resizeimage(bufferedimage originalimage, int targetwidth, int targetheight) { image scaledimage = originalimage.getscaledinstance(targetwidth, targetheight, image.scale_smooth); bufferedimage resizedimage = new bufferedimage(targetwidth, targetheight, bufferedimage.type_int_argb); graphics2d g2d = resizedimage.creategraphics(); g2d.drawimage(scaledimage, 0, 0, null); g2d.dispose(); return resizedimage; } } public class game { public static int totalscore = 0; public static int maxscore = 0; public static void main(string[] args) { new mainmenu(); } public static void updatetotalscore(int localscore) { totalscore += localscore; if (localscore > maxscore) { maxscore = localscore; } } } import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.ioexception; import java.util.arraylist; import java.util.list; import javax.imageio.imageio; public class tilemanager { int[][] map; bufferedimage[] tiles; boolean[] solid; final int tilesize = 32; int mapw = 45; int maph = 30; public tilemanager() { generaterandommap(); loadtiles(); } private void generaterandommap() { map = new int[maph][mapw]; for (int row = 0; row < maph; row++) { for (int col = 0; col < mapw; col++) { double random = math.random(); if (random < 0.1) { map[row][col] = 0; } else if (random < 0.15) { map[row][col] = 1; } else if (random < 0.5) { map[row][col] = 2; } else if (random < 0.97) { map[row][col] = 3; } else if (random < 0.99) { map[row][col] = 4; } else if (random < 1.00) { map[row][col] = 5; } } } for (int i = 0; i < 5; i++) { int r = (int) (math.random() * maph); int c = (int) (math.random() * mapw); if (map[r][c] != 4 && map[r][c] != 5) { map[r][c] = 6; // medkit } } for (int i = 0; i < 5; i++) { int r = (int) (math.random() * maph); int c = (int) (math.random() * mapw); if (map[r][c] != 4 && map[r][c] != 5) map[r][c] = 7; // ammo } for (int row = 13; row <= 16; row++) { for (int col = 23; col <= 26; col++) { map[row][col] = 0; } } system.out.println(""[success] map generated succesfully!""); } private void loadtiles() { tiles = new bufferedimage[8]; solid = new boolean[8]; try { tiles[0] = imageio.read(getclass().getresource(""/sprites/grounds/0.jpg"")); solid[0] = false; tiles[1] = imageio.read(getclass().getresource(""/sprites/grounds/1.jpg"")); solid[1] = false; tiles[2] = imageio.read(getclass().getresource(""/sprites/grounds/2.jpg"")); solid[2] = false; tiles[3] = imageio.read(getclass().getresource(""/sprites/grounds/3.jpg"")); solid[3] = false; tiles[4] = imageio.read(getclass().getresource(""/sprites/grounds/4.png"")); solid[4] = true; tiles[5] = imageio.read(getclass().getresource(""/sprites/grounds/5.png"")); solid[5] = true; tiles[6] = imageio.read(getclass().getresource(""/sprites/grounds/6.png"")); solid[6] = false; tiles[7] = imageio.read(getclass().getresource(""/sprites/grounds/7.png"")); solid[7] = false; } catch (ioexception e) { system.out.println(""[hata] tile map yükleni̇rken file io hata oluştu!""); } } public void setmap(int[][] newmap) { this.map = newmap; } // dış alanları da bir border tile (örneğin tiles[0]) ile dolduruyoruz public void draw(graphics2d g2d, double camx, double camy, double zoom) { int startcol = (int) (camx / tilesize); int startrow = (int) (camy / tilesize); int endcol = startcol + (int) (gamepanel.swid / tilesize / zoom) + 2; int endrow = startrow + (int) (gamepanel.shei / tilesize / zoom) + 2; for (int row = startrow; row < endrow; row++) { for (int col = startcol; col < endcol; col++) { int x = col * tilesize; int y = row * tilesize; bufferedimage tileimage; if (row >= 0 && row < map.length && col >= 0 && col < map[0].length) { int tilenum = map[row][col]; tileimage = tiles[tilenum]; } else { // eğer map dışındaysa, border tile olarak tiles[0] kullanıyoruz. tileimage = tiles[4]; } g2d.drawimage(tileimage, x, y, null); } } } public list<rectangle> getsolidrectangles() { list<rectangle> list = new arraylist<>(); for (int y = 0; y < maph; y++) { for (int x = 0; x < mapw; x++) { int tile = map[y][x]; if (tile == 4 || tile == 5) { list.add(new rectangle(x * tilesize, y * tilesize, tilesize, tilesize)); } } } return list; } public int[][] getmap() { return map; } public boolean issolid(int x, int y) { int col = x / tilesize; int row = y / tilesize; if (row < 0 || col < 0 || row >= maph || col >= mapw) return true; return solid[map[row][col]]; } public int gettile(int x, int y) { int col = x / tilesize; int row = y / tilesize; if (row < 0 || col < 0 || row >= maph || col >= mapw) return -1; return map[row][col]; } public void settile(int x, int y, int value) { int col = x / tilesize; int row = y / tilesize; if (row >= 0 && col >= 0 && row < maph && col < mapw) { map[row][col] = value; } } // piksel cinsinden harita genişliği public int getmapwidth() { return map[0].length * tilesize; } // piksel cinsinden harita yüksekliği public int getmapheight() { return map.length * tilesize; } public int gettilesize() { return tilesize; } } import java.awt.*; import java.awt.event.keyevent; import java.awt.geom.affinetransform; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import java.util.*; import java.util.list; import javax.imageio.imageio; public class player { private int x, y; private final int speed = 3; private int health = 100; private final int size = 32; private boolean isdead = false; private boolean up, down, left, right; private int frameindex = 0, framecounter = 0, framedelay = 8; private double anglemouse = 0; private int centerx, centery; private list<weapon> allweapons = new arraylist<>(); private weapon currentweapon; private int currentweaponindex = 0; private playerstate currentstate = playerstate.idle; private boolean isreloading = false; private int reloadframe = 0; private final map<string, map<playerstate, bufferedimage[]>> animations = new hashmap<>(); public enum playerstate { idle, move, shoot, reload } private list<playerblood> bloodlist; public void setbloodlist(list<playerblood> bloodlist) { this.bloodlist = bloodlist; } public player(int x, int y) { this.x = x; this.y = y; // farkli si̇lahlar allweapons.add(new shotgun()); allweapons.add(new rifle()); allweapons.add(new handgun()); allweapons.add(new sniper()); allweapons.add(new rocket()); currentweapon = allweapons.get(2); loadallanimations(); } private void loadallanimations() { try { loadweaponanimations(""handgun"", 20, 3, 15); loadweaponanimations(""rifle"", 20, 3, 20); loadweaponanimations(""shotgun"", 20, 3, 20); loadweaponanimations(""rocket"", 20, 3, 20); loadweaponanimations(""sniper"", 20, 3, 20); } catch (ioexception e) { system.out.println(""[hata] görseller yüklenemedi̇!""); } system.out.println(""[check] player animation successfully uploaded""); } private void loadweaponanimations(string weapon, int idlemove, int shoot, int reload) throws ioexception { map<playerstate, bufferedimage[]> map = new hashmap<>(); map.put(playerstate.idle, loadframes(weapon, ""idle"", idlemove)); map.put(playerstate.move, loadframes(weapon, ""move"", idlemove)); map.put(playerstate.shoot, loadframes(weapon, ""shoot"", shoot)); map.put(playerstate.reload, loadframes(weapon, ""reload"", reload)); animations.put(weapon.tolowercase(), map); } private bufferedimage[] loadframes(string weapon, string state, int count) throws ioexception { bufferedimage[] frames = new bufferedimage[count]; for (int i = 0; i < count; i++) { string path = string.format(""sprites/player/%s/%s/survivor-%s_%s_%d.png"", weapon, state, state, weapon, i); file f = new file(path); if (!f.exists()) break; // tolerans bufferedimage original = imageio.read(f); frames[i] = resizeimage(original, size, size); } return frames; } private bufferedimage resizeimage(bufferedimage original, int w, int h) { if (original == null) return null; image scaled = original.getscaledinstance(w, h, image.scale_smooth); bufferedimage resized = new bufferedimage(w, h, bufferedimage.type_int_argb); graphics2d g2d = resized.creategraphics(); g2d.drawimage(scaled, 0, 0, null); g2d.dispose(); return resized; } public void update(point mousepos, tilemanager tilemanager) { int nextx = x + (right ? speed : 0) - (left ? speed : 0); int nexty = y + (down ? speed : 0) - (up ? speed : 0); if (!isblocked(nextx, y, tilemanager)) x = nextx; if (!isblocked(x, nexty, tilemanager)) y = nexty; centerx = x + size / 2; centery = y + size / 2; anglemouse = math.atan2(mousepos.y - centery, mousepos.x - centerx); if (isreloading) { reloadframe++; string name = currentweapon.getname().tolowercase(); map<playerstate, bufferedimage[]> map = animations.get(name); if (map != null) { bufferedimage[] reloadframes = map.get(playerstate.reload); if (reloadframes != null && reloadframe >= reloadframes.length * framedelay) { isreloading = false; currentweapon.reload(); } } } framecounter++; if (framecounter >= framedelay) { framecounter = 0; string animkey = currentweapon.getname().tolowercase().replace("" "", ""_""); map<playerstate, bufferedimage[]> statemap = animations.get(animkey); if (statemap != null) { bufferedimage[] frames = statemap.get(currentstate); if (frames != null && frames.length > 0) { frameindex = (frameindex + 1) % frames.length; } } } if (!isreloading) { if (up || down || left || right) { setstate(playerstate.move); } else { setstate(playerstate.idle); } } else { setstate(playerstate.reload); } } private boolean isblocked(int testx, int testy, tilemanager map) { return map.issolid(testx, testy) || map.issolid(testx + size - 1, testy) || map.issolid(testx, testy + size - 1) || map.issolid(testx + size - 1, testy + size - 1); } public void draw(graphics2d g2d) { string animkey = currentweapon.getname().tolowercase().replace("" "", ""_""); bufferedimage frame = null; map<playerstate, bufferedimage[]> statemap = animations.get(animkey); if (statemap != null) { bufferedimage[] frames = statemap.get(currentstate); if (frames != null && frames.length > 0) { frame = frames[frameindex % frames.length]; } } if (frame == null) { // system.out.println(""[hata] frame bulunamadı: "" + animkey + "" "" + // currentstate); return; } affinetransform old = g2d.gettransform(); g2d.rotate(anglemouse, centerx, centery); g2d.drawimage(frame, x, y, null); g2d.settransform(old); } // scroll public void nextweapon() { if (!allweapons.isempty()) { currentweaponindex = (currentweaponindex + 1) % allweapons.size(); setweapon(allweapons.get(currentweaponindex)); } } public void previousweapon() { if (!allweapons.isempty()) { currentweaponindex = (currentweaponindex - 1 + allweapons.size()) % allweapons.size(); setweapon(allweapons.get(currentweaponindex)); } } private void setweapon(weapon w) { currentweapon = w; int idx = allweapons.indexof(w); if (idx >= 0) currentweaponindex = idx; frameindex = 0; } public void keypressed(keyevent e) { switch (e.getkeycode()) { case keyevent.vk_w: up = true; break; case keyevent.vk_s: down = true; break; case keyevent.vk_a: left = true; break; case keyevent.vk_d: right = true; break; } } public void keyreleased(keyevent e) { switch (e.getkeycode()) { case keyevent.vk_w: up = false; break; case keyevent.vk_s: down = false; break; case keyevent.vk_a: left = false; break; case keyevent.vk_d: right = false; break; } } public void setstate(playerstate s) { if (currentstate != s) { currentstate = s; frameindex = 0; } } public void startreload() { if (!isreloading && currentweapon.needsreload()) { isreloading = true; setstate(playerstate.reload); reloadframe = 0; } } // get/set public weapon getcurrentweapon() { return currentweapon; } public list<weapon> getallweapons() { return allweapons; } public int getcurrentammo() { return currentweapon.getammo(); } public int getmaxammo() { return currentweapon.getmagsize(); } public int getx() { return x; } public int gety() { return y; } public void setx(int val) { x = val; } public void sety(int val) { y = val; } public int getsize() { return size; } public int gethealth() { return health; } public boolean isreloading() { return isreloading; } public double getangletomouse() { return anglemouse; } public void heal(int amount) { health = math.min(100, health + amount); } public void takedamage(int dmg) { health -= dmg; if (health <= 0) { isdead = true; } if (bloodlist != null) { bloodlist.add(new playerblood(x, y)); } } public point getmuzzleposition() { int offsetx = 15, offsety = 10; double rx = math.cos(anglemouse) * offsetx - math.sin(anglemouse) * offsety; double ry = math.sin(anglemouse) * offsetx + math.cos(anglemouse) * offsety; return new point((int) (x + size / 2 + rx), (int) (y + size / 2 + ry)); } public rectangle getbounds() { return new rectangle(x, y, size, size); } }"
2384475,2,"2384475 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q2 { public static void main(string[] args) { int arr[] = { 5, 4, 1, 2 }; cocktailsort(arr, true); for (int i = 0; i < arr.length; i++) { system.out.println(arr[i]); } } public static void cocktailsort(int[] arr, boolean x) { for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } if (arr.length < 2) return; { if (x) { arr = bubble1(arr); x = false; } else { arr = bubble2(arr); x = true; } cocktailsort(arr, x); } } public static int[] bubble1(int[] arr) { int newarr[] = new int[arr.length - 1]; for (int i = 0; i < arr.length - 1; i++) { newarr[i] = arr[i]; } for (int i = 0; i < newarr.length - 1; i++) { if (newarr[i] > newarr[i + 1]) { int temp = newarr[i]; newarr[i] = newarr[i + 1]; newarr[i + 1] = temp; } } return newarr; } public static int[] bubble2(int[] arr) { int newarr[] = new int[arr.length - 1]; for (int i = 0; i < arr.length - 1; i++) { newarr[i] = arr[i]; } for (int i = newarr.length - 1; i > 0; i--) { if (newarr[i] < newarr[i - 1]) { int temp = newarr[i]; newarr[i] = newarr[i - 1]; newarr[i - 1] = temp; } } return newarr; } } public class lab1q1 { public static void main(string[] args) { system.out.println(collatz(2)); } public static int collatz(int i) { int count = 0; if (i == 1) return count; if (i % 2 == 0) count = 1 + collatz(i / 2); else if (i % 2 == 1) count = 1 + collatz(i * 3 + 1); return count; } } class sayac { public string x; public sayac(string x) { this.x = x; } public int say() { int res = say2(x); return res; } public int say2(string x) { int res = 0; if (x.length() < 1) return res; if (x.charat(0) != '1') { res = res + say2(x.substring(1)); } else if (x.charat(0) == '1') res = res + 1 + say2(x.substring(1)); return res; } public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; import java.util.*; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { metalsarki met = (metalsarki) sarki; system.out.println(sarki.sanatci + ""-"" + sarki.isim + "" [ozellik: "" + met.metalozellik + ""]""); } // bu kismi cikti ornegini saglayacak sekilde doldurun } } } abstract class sarki { string isim; string sanatci; sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } abstract void oynat(); } class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { super(isim, sanatci); this.metalozellik = metalozellik; } @override void oynat() { } void gostermetalozellikleri() { system.out.println(metalozellik); } } class rocksarki extends sarki { string rocko; rocksarki(string isim, string sanatci) { super(isim, sanatci); this.rocko = ""huzurlu ve nostaljik""; } @override void oynat() { } } class klasiksarki extends sarki { string klasiko; klasiksarki(string isim, string sanatci) { super(isim, sanatci); this.klasiko = ""hafif ve sakin""; } @override void oynat() { } } interface calmastratejisi { void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki) { rocksarki r = (rocksarki) sarki; system.out.println( ""[rock] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + r.rocko + "")""); } else if (sarki instanceof metalsarki) { metalsarki met = (metalsarki) sarki; system.out.println(""[metal] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + met.metalozellik + "")""); } else if (sarki instanceof klasiksarki) { klasiksarki k = (klasiksarki) sarki; system.out.println( ""[klasik] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + k.klasiko + "")""); } } } } class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { // karısık calma yapamadım :( tersten caldırdım. sarkilistesi = sarkilistesi.reversed(); for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki) { rocksarki r = (rocksarki) sarki; system.out.println( ""[rock] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + r.rocko + "")""); } else if (sarki instanceof metalsarki) { metalsarki met = (metalsarki) sarki; system.out.println(""[metal] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + met.metalozellik + "")""); } else if (sarki instanceof klasiksarki) { klasiksarki k = (klasiksarki) sarki; system.out.println( ""[klasik] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + k.klasiko + "")""); } } } } class rockcuozelcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki) { rocksarki r = (rocksarki) sarki; system.out.println(""[bilgi] ses duzeyi : yuksek""); system.out.println( ""[rock] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + r.rocko + "")""); system.out.println(""[bilgi] ses duzeyi : normal""); } else if (sarki instanceof metalsarki) { metalsarki met = (metalsarki) sarki; system.out.println(""[metal] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + met.metalozellik + "")""); } else if (sarki instanceof klasiksarki) { klasiksarki k = (klasiksarki) sarki; system.out.println( ""[klasik] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + k.klasiko + "")""); } } } } class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { this.strateji = s; } void muzikcal(list<sarki> sarkilistesi) { if (strateji instanceof siralicalma) { strateji.cal(sarkilistesi); } else if (strateji instanceof karisikcalma) { strateji.cal(sarkilistesi); } else if (strateji instanceof rockcuozelcalma) { strateji.cal(sarkilistesi); } } } kelime sayıcı bil 211 - lab 3 20 şubat 2025 1 giriş bu laboratuvarda fileioveexceptions kullanarak bir kelime sayıcı geliştireceğiz. kelime sayıcı , verilen birmetindosyasındakibelirlikelimelerinkaçkezgeçtiğinisayarakbirçıktıdosyasınakaydedecekvebelirlenen hata durumlarında uygun çıktılar oluşturacaktır. 2 genel program program, aşağıdaki sabit isimlere sahip iki giriş dosyası ile çalışacaktır: -kelimeler.txt – aranacak kelimeleri içeren dosya. -metin.txt – kelimelerin aranacağı metnin bulunduğu dosya. program, kelimeler.txt dosyasındaki her kelimenin metin.txt içinde kaç kez geçtiğini sayacak ve sonucu bir çıktı dosyasına kaydedecektir: -sonuc.txt – her kelimenin kaç kez geçtiğini içeren çıktı dosyası. dosyalar,programınçalıştırıldığıdizindebulunmalıdır. dosyaisimlerideğiştirilemez,programsadeceyukarıda belirtilen isimlerle çalışacaktır. eğerkelimeler.txt içinde bulunan herhangi bir kelime, metin.txt içinde hiç geçmiyorsa, program bir hata oluşturmalı ve stderr’e uygun bir mesaj yazmalıdır. 3 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları kullanacaktır (örn., bufferredreader, scanner, printwriter). dosyaları okurken ve yazarken kullanacağınız fileio sınıflarının seçimi size bırakılmıştır. i̇şlenmesi gereken dosyalar şunlardır: -kelimeler.txt dosyası okunmalıdır. -metin.txt dosyası okunmalıdır. -sonuc.txt dosyası oluşturulup yazılmalıdır. program,aşağıdakiolasıdosyahatalarınıoluşturmalıvehatalaroluştuğundastderr’ebelirlenenhatamesajlarını yazmalıdır: - dosyabulunamıyorsa: ""hata: kelimeler.txt bulunamadı."" veya""hata: metin.txt bulunamadı."" - dosya boşsa: ""hata: kelimeler.txt boş."" veya""hata: metin.txt boş."" 4 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program hata kodu ile çıkış yapmalıdır (yani mainmetodunuz bu hataları atarak sonlanmalı) ve hatalar stderr’e yazılmalıdır (programınızı hata atarak sonlandırırsanız java bunu kendisi yapacaktır). belirtilen hata mesajları ile birlikte java’nın hata ile sonlanan programlar için oluşturduğu sınıf, metod, ve satır gibi bilgiler bulunabilir. 1 4.1 girdi hataları (inputexception class) bu kategori, programın giriş dosyalarıyla ilgili karşılaşabileceği tüm hataları kapsar. öğrenciler, dosya işlem- leriyle ilgili hata türlerini inputexception sınıfından türetmelidir. aşağıdaki özel hata türleri tanımlanmalıdır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: [dosya adı] bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: [dosya adı] boş."" 4.2 kelime bulunamadı hatası (kelimebulunamadiexception class) eğerkelimeler.txt içinde bulunan en az bir kelime, metin.txt dosyasında hiç geçmiyorsa, program kelimebulunamadiexception hatasını atmalıdır. hata yalnızca kelimeler.txt dosyasında bulunamayan ilk kelime için atılır ve program sonlanır. bu hata oluştuğunda stderr’e şu mesaj yazılmalıdır: -""hata: [kelime] metinde bulunamadı."" bu hata, doğrudan exception sınıfından türetilecek ve inputexception ile bağlantılı olmayacaktır. 5 dosya formatları program üç farklı dosya ile çalışacaktır: kelimeler.txt (girdi),metin.txt (girdi) ve sonuc.txt (çıktı). bu dosyaların formatı aşağıda belirtilmiştir. 5.1 girdi dosyaları girdi dosyaları düz metin ( .txt) formatında olacaktır ve her biri aşağıdaki gibi yapılandırılmış olmalıdır. 5.1.1kelimeler.txt formatı kelimeler.txt dosyası, her satırda bir kelime olacak şekilde düzenlenmelidir. dosyada yalnızca harf karak- terleri bulunur. kelimeler büyük/küçük harf duyarsız olarak aranacaktır. örnek i̇çerik: elma armut üzüm eğer dosya boşsa, program şu hatayı vermelidir: hata: kelimeler.txt boş. 5.1.2metin.txt formatı metin.txt dosyası, içinde aranacak kelimelerin geçebileceği serbest formatlı bir metin içermelidir. dosya içinde noktalama işaretleri ve boşluklar bulunabilir. örnek i̇çerik: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. eğer dosya boşsa, program şu hatayı vermelidir: hata: metin.txt boş. 5.2 çıktı dosyası program, kelimelerin kaç kez geçtiğini gösteren bir çıktı dosyası ( sonuc.txt ) oluşturmalıdır. 2 5.2.1sonuc.txt formatı sonuc.txt dosyası, her satırda kelimenin adı ve kaç kez geçtiği bilgisi olacak şekilde düzenlenmelidir. format şu şekilde olmalıdır: [kelime] [geçme sayısı] kelime ve geçme sayısı arasında tek bir boşluk olmalıdır. örnek çıktı ( sonuc.txt ): elma 2 armut 2 üzüm 1 5.3 özel hata durumları ve çıktıları eğerkelimeler.txt içindekiherhangibirkelime metin.txt içindebulunamazsa, kelimebulunamadiexception hatası atılmalıdır ve stderr’e şu mesaj yazılmalıdır: hata: üzüm metinde bulunamadı. bu hata oluştuğunda, yine de sonuc.txt dosyası oluşturulmalı ve bulunan kelimeler için normal çıktı yazıl- malıdır. ancak bulunamayan kelimeler çıktı dosyasına eklenmemelidir. örnek durum: eğerkelimeler.txt şu şekildeyse: elma armut muz vemetin.txt şu şekildeyse: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. o zaman sonuc.txt şu şekilde olmalıdır: elma 2 armut 2 ve stderr’e şu mesaj yazılmalıdır: hata: muz metinde bulunamadı. 6 gönderim formatı - labı bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara şeklinde isimlendirin (örn., johnnash_181101014.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""lab3 gönderim"" başlıklı bir mail ile gönderin. 3 metot açıklama string(string s) sile aynı değere sahip bir string oluşturur. string(char[] a) a[]dizisindeki karakterlerle bir string oluşturur. int length() string içindeki karakter sayısını döndürür. char charat(int i) belirtilen iindeksindeki karakteri döndürür. string substring(int i, int j) iilej-1arasındaki karakterleri içeren bir alt string döndürür. boolean contains(string substring) string’in substring ’i içerip içermediğini kontrol eder. boolean startswith(string prefix) string’in prefixile başlayıp başlamadığını kontrol eder. boolean endswith(string postfix) string’in postfix ile bitip bitmediğini kontrol eder. int indexof(string pattern) pattern ifadesinin ilk geçtiği indeks değerini döndürür. int indexof(string pattern, int i) iindeksinden sonraki ilk pattern konumunu döndürür. string concat(string t) string’in sonuna teklenmiş halini döndürür. int compareto(string t) i̇ki string’i karşılaştırır (sözlük sırasına göre). string tolowercase() string’in tüm harflerini küçük harfe çevirir. string touppercase() string’in tüm harflerini büyük harfe çevirir. string replace(string a, string b) string içindeki a’larıbile değiştirir. string trim() string’in başındaki ve sonundaki boşlukları kaldırır. boolean matches(string regex) string’in belirtilen regexle eşleşip eşleşmediğini kontrol eder. string[] split(string delimiter) string’idelimiter kullanarak böler ve bir dizi döndürür. boolean equals(object t) string’in değeri tile aynı mı diye kontrol eder. table 1: java string sınıfı metotları 4 package bil211lab3; import java.io.file; import java.io.fileinputstream; import java.io.fileoutputstream; import java.io.printwriter; import java.util.arraylist; import java.util.scanner; public class kelimesayaci { public static void main(string[] args) { file file = new file(""bil211lab3\\kelimeler.txt""); file file2 = new file(""bil211lab3\\metin.txt""); arraylist<string> klmlist = readkelime(file); arraylist<string> mtnlist = readmetin(file2); writesonuc(""bil211lab3\\sonuc.txt"", klmlist, method(klmlist, mtnlist)); } static arraylist<string> readkelime(file filename) { arraylist<string> strlist = new arraylist<string>(); scanner scan = null; try { scan = new scanner(new fileinputstream(filename)); if (!filename.exists()) { throw new dosyabulunamadiexception(filename.getname() + ""bulunamadı""); } while (scan.hasnext()) { string x = scan.next().tolowercase(); strlist.add(x); } return strlist; } catch (dosyabulunamadiexception e) { system.out.println(""hata: "" + e.getmessage()); } catch (exception e) { system.out.println(""error "" + e.getmessage()); } finally { scan.close(); } return strlist; } static arraylist<string> readmetin(file filename) { arraylist<string> strlist = new arraylist<string>(); arraylist<string> strlist2 = new arraylist<string>(); scanner scan = null; try { scan = new scanner(new fileinputstream(filename)); if (!filename.exists()) { throw new dosyabulunamadiexception(filename.getname() + ""bulunamadı""); } while (scan.hasnext()) { string x = scan.next().tolowercase(); strlist.add(x); } for (string s : strlist) { s = s.replaceall(""\\p{punct}"", """"); strlist2.add(s); } return strlist2; } catch (dosyabulunamadiexception e) { system.out.println(""hata: "" + e.getmessage()); } catch (exception e) { system.out.println(""error "" + e.getmessage()); } finally { scan.close(); } return strlist2; } static void writesonuc(string filename, arraylist<string> klmlist, int[] c) { printwriter p = null; try { p = new printwriter(new fileoutputstream(filename)); for (int i = 0; i < klmlist.size(); i++) { if (c[i] == 0) { throw new kelimebulunamadiexception(klmlist.get(i) + "" metinde bulunamadı.""); } else { p.println(klmlist.get(i) + "" "" + c[i]); } } } catch (kelimebulunamadiexception e) { p.println(""hata: "" + e.getmessage()); } catch (exception e) { system.out.println(""error""); } finally { p.close(); } } static int[] method(arraylist<string> klmlist, arraylist<string> mtnlist) { int[] count = new int[klmlist.size()]; for (int j = 0; j < klmlist.size(); j++) { for (int i = 0; i < mtnlist.size(); i++) { if (mtnlist.get(i).equals(klmlist.get(j))) { count[j]++; } } } return count; } } class inputexception extends exception { public inputexception(string message) { super(message); } } class dosyabulunamadiexception extends inputexception { public dosyabulunamadiexception(string message) { super(message); } } class bosdosyaexception extends inputexception { public bosdosyaexception(string message) { super(message); } } class kelimebulunamadiexception extends exception { public kelimebulunamadiexception(string message) { super(message); } } generic 1) envanter yönetim sistemi bu labda amacımı bir oyun için envanter sistemi eklemektir. item isminde bir arayüz tanımlayın: aşağıdaki metotları içermelidir: string getname() int getvalue() weapon sınıfı tanımlayın. bu sınıf item arayüzünü uygulamalıdır. int damage isimli bir özelliği olmalıdır. armor sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. int defense isimli bir değişkeni olmalıdır. potion sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. string effect isimli bir değişkeni olmalıdır. generic inventory<t> sınıfı bir arraylist kullanarak nesneleri saklamalıdır. void additem(t item): envantere istenilen eşyayı eklemeli void removeitem(t item): envanterden istenilen eşyayı silmeli void printinventory(): envanteri basmalı t mostvaluableitem(): en değerli eşyayı dönmeli t finditembyname(string name): verilen isme karşılık gelen eşyayı dönmeli. i̇simlerin unique olduğunu varsayabilirsiniz. eğer yoksa null dönün. list<t> finditemsbyvalue(int value): verilen değerden daha değerli eşyaarın listesini döndürür. int gettotalvalue(): envanterin toplam değerini döner. list<t> filterbytype(class<?> type): istenilen sınıfa ait ögeleri döner. int gettotalweapondamage(): weapon classına ait olan nesnelerin toplam hasarınıdöner. void sortbyvalue(): değeri azalan şekilde envanteri sıralamalıdır. public static void printmostvaluableitem(inventory<? extends item> inventory): verilen envanterdem en değerli eşayı ekrana basmalıdır. public static void transferarmor(inventory<? super armor> destination, inventory<armor> source): verilen hedef envantere zırhı taşımalıdır. driver class: main metodu burada olmalıdır. sadece weapon’dan oluşan ve itemdan oluşan invertory classı yazıp test ediniz. yardımcı olabilecek metotlar: class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon package bil211lab4; import java.nio.file.watchevent; import java.util.arraylist; import java.util.collection; import java.util.collections; import java.util.comparator; import java.util.list; public class driver { public static void main(string[] args) { class<weapon> weaponclass = weapon.class; system.out.println("": "" + weaponclass.getname()); weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); inventory<item> envantor = new inventory<>(); item w = new weapon(""a"", 100, 100); item a = new armor(""b"", 200, 700); item p = new potion(""c"", 150, ""effect""); envantor.additem(sword); envantor.additem(w); envantor.additem(a); envantor.additem(p); envantor.printinventory(); system.out.println(""most valuable: "" + envantor.mostvaluableitem().getname()); system.out.println(envantor.finditembyname(""b"").tostring()); system.out.println(envantor.finditemsbyvalue(130)); system.out.println(envantor.gettotalvalue()); system.out.println(envantor.filterbytype(clazz)); envantor.sortbyvalue(); envantor.printinventory(); inventory.printmostvaluableitem(envantor); } } interface item { string getname(); int getvalue(); } class weapon implements item { string name; int value; int damage; weapon(string name, int value, int damage) { this.name = name; this.value = value; this.damage = damage; } public string getname() { return name; } public int getvalue() { return value; } public int getdamage() { return damage; } } class armor implements item { string name; int value; int defense; armor(string name, int value, int defense) { this.name = name; this.value = value; this.defense = defense; } public string getname() { return name; } public int getvalue() { return value; } public int getdefense() { return defense; } } class potion implements item { string name; int value; string effect; potion(string name, int value, string effect) { this.name = name; this.value = value; this.effect = effect; } public string getname() { return name; } public int getvalue() { return value; } public string geteffect() { return effect; } } class inventory<t extends item> { t item; list<t> liste = new arraylist<t>(); void additem(t item) { liste.add(item); } void removeitem(t item) { liste.remove(item); } void printinventory() { for (t item : liste) { if (item instanceof weapon) { system.out.println(""name: "" + item.getname() + "" value: "" + item.getvalue() + "" damage: "" + ((weapon) item).getdamage()); } else if (item instanceof armor) { system.out.println(""name: "" + item.getname() + "" value: "" + item.getvalue() + "" damage: "" + ((armor) item).getdefense()); } else if (item instanceof potion) { system.out.println(""name: "" + item.getname() + "" value: "" + item.getvalue() + "" damage: "" + ((potion) item).geteffect()); } } } t mostvaluableitem() { t mostv = null; int max = 0; for (t item : liste) { if (item.getvalue() > max) { mostv = item; } } return mostv; } t finditembyname(string name) { for (t item : liste) { if (item.getname() == name) { return item; } } return null; } list<t> finditemsbyvalue(int value) { list<t> lst = new arraylist<t>(); for (t item : liste) { if (item.getvalue() > value) { lst.add(item); } } return lst; } int gettotalvalue() { int totalv = 0; for (t item : liste) { totalv += item.getvalue(); } return totalv; } list<t> filterbytype(class<?> type) { list<t> lst = new arraylist<t>(); for (t item : liste) { if (item.getclass() == type) { lst.add(item); } } return lst; } int gettotalweapondamage() { int totald = 0; for (t item : liste) { if (item instanceof weapon) { totald += ((weapon) item).getdamage(); } } return totald; } void sortbyvalue() { for (int i = 0; i < liste.size(); i++) { for (int j = 0; j < liste.size() - 1; j++) { if (liste.get(j).getvalue() < liste.get(j + 1).getvalue()) { t temp = liste.get(j); liste.set(j, liste.get(j + 1)); liste.set(j + 1, temp); } } } } public static void printmostvaluableitem(inventory<? extends item> inventory) { item x = inventory.mostvaluableitem(); if (x instanceof weapon) { system.out.println( ""name: "" + x.getname() + "" value: "" + x.getvalue() + "" damage: "" + ((weapon) x).getdamage()); } else if (x instanceof armor) { system.out.println( ""name: "" + x.getname() + "" value: "" + x.getvalue() + "" damage: "" + ((armor) x).getdefense()); } else if (x instanceof potion) { system.out.println( ""name: "" + x.getname() + "" value: "" + x.getvalue() + "" damage: "" + ((potion) x).geteffect()); } } public static void transferarmor(inventory<? super armor> destination, inventory<armor> source) { for (int i = 0; i < source.liste.size(); i++) { destination.liste.add(source.liste.get(i)); } } } abstraction kavramını açıklayınız. i̇htiyacımız olan şeylerin dışındakileri yok saymaktır. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür cünkü hourlye is a e ama tam tersi degil cunku e is not a hourlye. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? package access daha yakındır. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? üst classların instance variablelarını parametre olarak gecirmek icin. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır,mümkün değil. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? verilen objenin bizim istedigimiz türden bir obje olup olmadigini kontrol eder. b objesi a objesiyle ayni class a aittir. metot overriding ve overloading kavramlarını açıklayınız. overriding signature ı aynı olan metotlar icin kullanılır. overlode ismi aynı ama parametreleri farkli metotlar icin kullanilir. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? 10 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? signatureları farklı olan methodlarda static binding aynı olanlarda dynamic binding kullanılır. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? bu metotlar değiştirilemez ve override edilemez. bu yüzden static bindingle bağlanır. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloadingde static binding overridingde dynamic binding gerçekleşir. dinamik bağlamada jvm'nin görevi nedir? run time sırasında karar verir. java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? ana classın referans variable ı alt classın objesini refer ettiği için. downcast implicit yapılamaz. typecating ile yapılır. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? run time sırasında vakit kaybederdik. class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child dinamik bağlama class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book dinamik bağlama java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? i̇çinde abstract method(implement edilmemis) bulunduran ya da bulundarmayan classlardır. abstract classlarda constructur olabilir.interfacde olamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? bir abstract classın methodu başka bir abstract classda implement edilebilir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. daha sonra kesin olarak implement edileceğini bildiğimiz bir methodu tanımlamamızı sağlar. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interfaceler class değil bir tiptir. abstract classlardan obje üretilmez. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interfacelerin içi boştur. functionallarda implement edilmeyi bekleyen methodlar vardır. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? classlar birden fazla interface implement edebilir. i̇nterface başka bir interfacei extend edebilir. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abstract classtan obje üretilmez. shape c = new circle(); olmalı drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? edilemez çünkü hangisini çalıştiracagıni bilemez. super olmamalıydı. new b().show; yapabiliriz. output: b java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 2 çeşittir. io ve runtime exception java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? trowable olmak zorundadır ve override edildiğinde kendisi ve subclassları throws edilebilir. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? her koşulda kod bloğunu çalıştırır. exception atılıp atılmaması önemli değildir. java'da kendi exceptionunuzu nasıl tanımlarsınız? i̇stediğimiz türdeki exception classını extend ederiz ve şu koşul gerçekleşirse exception fırlat deriz. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? . static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done -1 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? normalde specific olandan olmayana doğru catch ederiz ama böylede çalışır trying m1 caught2 finally text file ile binary file arasındaki fark nedir? text file primitive typelar ile olur. binary file ascii değerleri ile olur. binary file daha az yer kaplar ve daha hızlıdır. bir dosyaya yazarken düzenli olarak flush yapmamak neye yol açabilir? flush verilerin çıktı dosyasına yazdırılmasını zorlar. flush edilmezse veri kaybı olabilir. binary bir dosyaya bir object yazdırırken bu objenin hangi interfaceyi implement etmesi gerekiyor? bu interfacenin metotlarını sıralayınız. bu interface functional veya marker bir interface midir? serializable ı implement eder. i̇çi boş bir interfacedir. methodu yoktur. marker interfacedir. binary bir dosyaya primitive typeler (int, float, char etc.) yazılabilir mi, evet ise nasıl? evet. out.writeint out.writechar gibi methodlarla yazılır. buffered reader ve scanner sınıfları ile dosya okurken dosyanın sonuna geldiğini nasıl kontrol edilir? .next methodu ile kontrol eder. binary bir dosya okurken dosyanın sonuna gelindiği nasıl test edilir? avaliable ile kontrol eder. public class randomaccessdemo { public static void main(string[] args) throws exception { _______ f = new _______(""numbers.bin"", ""____""); f.writeint(10); f.writeint(20); int a = f.readint(); f.seek(_____________); int b = f.readint(); system.out.println(a + b); f.close(); } } boşluklara sırasıyla ne gelmelidir? output? randomaccessfile randomaccessfile rw a 10 public class demo { public static void main(string[] args) throws exception { fileoutputstream fos = new fileoutputstream(""log.txt"", true); ______________ pw = new ______________(fos); pw.println(""new log entry""); pw.close(); } } boşluklara sırasıyla ne gelmelidir? bu kod çalıştırıldığında log.txt dosyası nasıl etkilenir? printwriter printwriter var olanın üstüne ""new log entry"" ekler. what grade (a, b, c, d, or f) do you expect to earn by the end of this course? cb java'da generic kavramı nedir, bu kavramın temel amacı nedir? biter type datayı başka bir classda tutmak upper bound ve lower bound wildcardları nasıl ifade edersiniz? upper ve lower boundun kullanılacağı durumlara birer tane örnek veriniz. upper ı ""? extends t"" ile lower ı ""? super t"" ile yaparız. generic bir classın constructorunda type parametresi bulunur mu, neden? bulunmayabilir. mygenericclass<a> ve mygenericclass<object> classları arasında kalıtım (child-parent) ilişkisi nasıldır, açıklayınız. ikiside tüm typelarde generic alabilir class node<t>{ t[] data = new t[10]; } //psvm node<string> stringnode = new node<>(); bu kodda bir hata var mı? (varsa) bu hata nedir, nedenini açıklayınız. (varsa) bu hata nasıl düzeltilmeli, kodun doğru halini yazınız. t data array olmamalı. t data = new t; swapheadandtail metodu aşağıda tanımı verilmiş node classının birbirlerine bağlanmış nodelerinden ilkini alan ve baştaki node ile sondaki node'yi değiştiren metottur. örnek: başlangıçta: a -> b -> c metodu a ile çağırdığıktan sonra: c -> b -> a ayrıca metot en başa gelen nodeyi dönmelidir (bu örnekte c dönmeli). class node{ int data; node next; } static node swapheadandtail(node head) { node a = head; node b = head.next; node c = head; node d = null; while (____ != null) { d = c; c = c.next; } c.next = ____; d.next = ____; a.next = ____; return ____; } buna göre boşluklara neler gelmelidir? head head.next head.next.next head public _________ { public void sırala(list<t> liste) { // sıralama algoritmanız } } yaptığınız uzun çalışmalar sonucu yeni bir sıralama algoritması buldunuz. bunu implement etmek için bir class yazmalısınız. bu classın declarationunu nasıl yapardınız neden, boşluğu buna göre doldurun. mysortclass<? extends comparable> map ve set veri yapılarını kıyaslayınız, aralarındaki farkları açıklayınız. . collections interfacesindeki metotlar temel olarak hangi işlevleri yerine getiriyor? . i̇ki objenin equals metodu true dönüyorsa bu iki objenin hash codeleri aynıdır, bunun nedenini açıklayınız; eğer bu sağlanmazsa hangi veri yapıları istenilen şekilde sağlanır? kendi yazdığınız classlarda bunu sağlamak için hangi metotları override etmelisiniz, neden? . bir öğrenci kulübü, yılsonu etkinliği için sınırlı kontenjana sahip bir kayıt sistemi oluşturuyor. sistem, öğrenci kayıtlarını ""ilk gelen ilk hizmet alır"" prensibiyle yönetiyor. ancak, bazı öğrenciler kaydını iptal edebiliyor ve boş kalan yerler otomatik olarak sıradaki öğrenciye veriliyor. bu senaryoda, kayıt sırasını ve iptal durumlarını etkin bir şekilde yönetebilmek için hangi veri yapısını tercih edersiniz? neden? linkedlist sıralı olarak ilerliyor ve çıkanın yerini bir sonraki alıyor. fifo nedir, açıklayınız ve aşağıdakı veri yapılarını fifo/lifo şeklinde sınıflandırınız: stack queue map priorityqueue . public class main { public static void main(string[] args) { map<string, integer> scores = new hashmap<>(); scores.put(""alice"", 95); scores.put(""bob"", 80); scores.put(""alice"", 100); set<string> keys = scores.keyset(); int sum = 0; for (string key : keys) { sum += scores.get(key); } system.out.println(""number of entries: "" + scores.size()); system.out.println(""sum of scores: "" + sum); } } output? number of entries: 2 sum of scores: 180 public class main { public static void main(string[] args) { list<string> list = new arraylist<>(); list.add(""apple""); list.add(""banana""); list.add(1, ""cherry""); list.remove(""banana""); list.add(""apple""); system.out.println(list.size()); system.out.println(list.indexof(""apple"") + "" "" + list.lastindexof(""apple"")); } } output? 0 2 ara sınavdan yaklaşık hangi notu bekliyorsun (0-100)? 68 java gui'leri bağlamında olay güdümlü (event driven) programlamayı tanımlayın. bir frame açılır ve dışarıdan bizim yaptığımız etkinlikleri klavye, mouse vb. araçlarla algılar. geleneksel sıralı programlama ile olay güdümlü (event driven) programlama arasındaki temel fark nedir? event driven bizim kararlarımıza bağlıdır. borderlayout yöneticisi, bir konteynerdeki bileşenleri nasıl düzenler? 3 parçaya böler. north, south, center java gui uygulamalarında jpanel'in amacı nedir? jframe component eklemek. java'daki gui programları neden tipik olarak sonsuz bir olay döngüsü çalıştırır ve bu durum sistem veya uygulama tarafından tetiklenen yeniden çizim (repaint) olaylarıyla nasıl ilişkilidir? . bir swing uygulamasında repaint() metodunu çağırmanın etkisi nedir? paint değiştirdiğimizde uygulanır. aşağıdaki kodun çalışmasını izleyin ve düğmeye tıklandığında ne olduğunu belirleyin: public class simplegui extends jframe implements actionlistener { public simplegui() { setsize(200, 100); setdefaultcloseoperation(jframe.exit_on_close); jbutton button = new jbutton(""click me""); button.addactionlistener(this); add(button); setvisible(true); } public void actionperformed(actionevent e) { joptionpane.showmessagedialog(this, ""button was clicked!""); system.exit(0); } public static void main(string[] args) { new simplegui(); } } butona basıldığında frame e ""button was clicked!"" yazdırır. aşağıdaki kod parçasını inceleyin: import javax.swing.*; import java.awt.*; public class layoutexample { public static void main(string[] args) { jframe frame = new jframe(""layout test""); frame.setsize(400, 300); frame.setdefaultcloseoperation(jframe.exit_on_close); frame.setlayout(new borderlayout()); frame.add(new jlabel(""n""), borderlayout.north); frame.add(new jbutton(""s""), borderlayout.south); frame.add(new jpanel(), borderlayout.center); frame.setvisible(true); } } bu program çalıştığında bileşenlerin nasıl düzenlendiğini açıklayın. i̇smi layout test olan bir frame oluşur. northa ismi n olan label , southa üstünde s olan buton, centera bir panel ekler ve görünür yapar. bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class quiz1q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55, true); robot r3 = new robot(""r2-d2"", ""astromech"", 80, true); int i = 0; factory.addrobot(r1, i++); factory.addrobot(r2, i++); factory.addrobot(r3, i++); factory.printfactory(); } } class factory { private string name; private string location; private robot[] robots = new robot[100]; public factory(string name, string location) { this.name = name; this.location = location; } public factory() { this.name = ""factory1""; this.location = ""moon""; } public void addrobot(robot robot, int index) { robots[index] = robot; } public void chargeallrobots() { for (int i = 0; i < robots.length; i++) { robots[i].charge(); } } public void printfactory() { system.out.println(""factory name: "" + getname1() + "" location: "" + getlocation1()); for (int i = 0; i < robots.length; i++) { if (robots[i] != null) system.out.println("" robot name: "" + robots[i].getname() + "" robot type: "" + robots[i].gettype() + "" battery level: "" + robots[i].getbattery() + "" is operational: "" + robots[i].getopera()); } } public void work() { for (int i = 0; i < robots.length; i++) { int x = robots[i].getbattery() - 15; system.out.println(x); } } public string getname1() { return name; } public string getlocation1() { return location; } } class robot { private string name; private string type; private int batterylevel; // 100 ile 0 arasında bir değer private boolean isoperational;// bataryası varsa true robot() { this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } robot(string name, string type, int batterylevel, boolean isoperational) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = isoperational; } public void charge() { batterylevel = 100; } public void printrobot() { system.out.println(); } public string getname() { return name; } public string gettype() { return type; } public int getbattery() { return batterylevel; } public boolean getopera() { return isoperational; } } public class quiz1q1 { public static void main(string[] args) { string x = ""a1b2""; string[] ar = method(x); for (int i = 0; i < ar.length; i++) { system.out.println(ar[i]); } } public static string[] method(string x) { x = x.touppercase(); string[] arr = new string[2 ^ (x.length() / 2)]; for (int i = 0; i < arr.length; i++) { arr[i] = x.substring(0, i) + x.substring(i).tolowercase(); } return arr; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 package robot; public interface withbattery { int getbatterylife(); void recharge(); } package robot; public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public abstract void performtask(); public int getbatterylife() { return batterylife; } public void recharge() { final int temp = batterylife; this.batterylife = temp; system.out.println(batterylife); } } package robot; public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.robotnumber(); // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } package robot; public class securityrobot extends abstractrobot { private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } @override public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] scanning for threats... armed:"" + isarmed); batterylife = batterylife - 10; } else { system.out.println(""["" + modelname + ""] not enough battery to scan threats...""); } } public void togglearmedmode() { isarmed = !isarmed; } public boolean getisarmed() { return isarmed; } } package robot; public class cleaningrobot extends abstractrobot { private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } @override public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] cleaning in progress... cleaning power:"" + cleaningpower); batterylife = batterylife - 10; } else { system.out.println(""["" + modelname + ""] not enough battery to clean...""); } } public void boostcleaningpower() { cleaningpower = cleaningpower + 10; } public int getcleaningpower() { return cleaningpower; } } package robot; import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; static int number; robotfactory() { robots = new arraylist<abstractrobot>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { cleaningrobot x = new cleaningrobot(modelname, batterylife, cleaningpower); number++; robots.add(x); } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { securityrobot x = new securityrobot(modelname, batterylife, isarmed); number++; robots.add(x); } public void performalltasks() { for (abstractrobot r : robots) { r.performtask(); } } public void displayrobots() { for (abstractrobot r : robots) { if (r instanceof cleaningrobot) { cleaningrobot x = (cleaningrobot) r; system.out.println(""- model: "" + x.modelname + "", battery: "" + x.batterylife + "", cleaning power: "" + x.getcleaningpower()); } else if (r instanceof securityrobot) { securityrobot x = (securityrobot) r; system.out.println( ""- model: "" + x.modelname + "", battery: "" + x.batterylife + "", armed: "" + x.getisarmed()); } } } public void upgradecleaningrobots(int miktar) { for (abstractrobot r : robots) { if (r instanceof cleaningrobot) { cleaningrobot x = (cleaningrobot) r; x.boostcleaningpower(); system.out .println(""cleaningrobot - "" + x.modelname + "" now has cleaning power: "" + x.getcleaningpower()); } } } public void togglesecurityrobotsmode() { for (abstractrobot r : robots) { if (r instanceof securityrobot) { securityrobot x = (securityrobot) r; x.togglearmedmode(); system.out.print(""securityrobot - "" + x.modelname + "" is now ""); if (x.getisarmed()) { system.out.println(""armed""); } else { system.out.println(""unarmed""); } } } } public static void robotnumber() { system.out.println(""tum fabrikalar tarafindan toplam "" + number + "" robot uretildi""); } } bil211 quiz 4 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: undoablelist<t> adında bir sınıf oluşturun. bu sınıf, bir arraylist'i genişletmeli ve aşağıdaki ek özelliklere sahip olmalıdır: ● undolast() metodu, en son eklenen öğeyi kaldırmalıdır. ● getlastadded() → son eklenen öğeyi listeyi değiştirmeden döndürür. ● eğer liste boşsa, undolast() bir hata vermemeli, sadece hiçbir şey yapmamalıdır. örnek kullanım: undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] q2: aşağıdaki generic metodu tamamlayın. ● verilen bir collection<t> içinde minimum veya maksimum öğeyi bulan bir metod yazın. ● boolean parametresi true ise maksimumu, false ise minimumu döndürmelidir. ● t öğeleri comparable<t> arabirimini uygulamalıdır. public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { // metodu tamamlayın } örnek kullanım: list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) q3: belirli türdeki elemanları filtreleme ● bir collection<?> içindeki belirli bir türdeki öğeleri filtreleyen bir generic metod yazın. ● class<t> tür filtresi olarak kullanılmalıdır. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { // metodu tamamlayın } örnek kullanım: list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] import java.util.arrays; import java.util.collection; import java.util.list; import java.util.collections; public class q2 { public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { t value = null; if (findmax == true) { value = collections.max(collection); } else if (findmax == false) { value = collections.min(collection); } return value; } public static void main(string[] args) { list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) system.out.println(); list<integer> numbers2 = arrays.aslist(3, 9, 1, 6, 15, 12, 20, 0); system.out.println(findextreme(numbers2, true)); // çıktı: 20 (maksimum) system.out.println(findextreme(numbers2, false)); // çıktı: 0 (minimum) } } import java.util.arraylist; import java.util.arrays; import java.util.collection; import java.util.list; public class q3 { public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { list<t> col = (list<t>) collection; list<t> lst = new arraylist<>(); for (int i = 0; i < col.size(); i++) { t value = col.get(i); class<t> coltype = (class<t>) value.getclass(); if (coltype == type) { lst.add(value); } } return lst; } public static void main(string[] args) { list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); list<object> mixed2 = arrays.aslist(2, ""melih"", 5.5, ""/meltla/"", 7, true, ""türker"", false); system.out.println(filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] system.out.println(filterbytype(mixed, boolean.class)); system.out.println(filterbytype(mixed, double.class)); system.out.println(); system.out.println(filterbytype(mixed2, string.class)); system.out.println(filterbytype(mixed2, integer.class)); system.out.println(filterbytype(mixed2, boolean.class)); system.out.println(filterbytype(mixed2, double.class)); } } import java.util.arraylist; public class undoablelist<t> extends arraylist<t> { public void undolast() { if (size() == 0) { return; } else { remove(size() - 1); } } public t getlastadded() { return get(size() - 1); } public static void main(string[] args) { undoablelist<string> list = new undoablelist<>(); undoablelist<string> list2 = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.add(""d""); list.add(""e""); list.add(""f""); list.add(""g""); system.out.println(list.getlastadded()); list.undolast(); // ""g"" kaldırılmalı system.out.println(list); system.out.println(list.getlastadded()); system.out.println(list); list2.undolast();// hata vermemeli } } 2 kuş bakışı atış oyunu (top-down shooter) bil 211 - proje teslim tarihi: 27 mart 2025 23:59 1 amaç bu ödevde amacınız, java swing kullanarak kuş bakışı bir atış oyunu (top-down shooter) tasarlamaktır. oyunda, yönettiğimiz karakterin üzerine dalga dalga gelen çeşitli zombileri fare ile hedef alarak farklı silahlar kullanıp öldürmemiz gerekmektedir. karakterimiz öldüğünde oyun sona erecektir. her dalga başına ve öldürülen zombi başına kazanılan puan artacaktır. dalgalar ilerledikçe gelen zombilerin sayısı ve çeşitleri artarak zorluk seviyesi yükselecektir. 2 gereksinimler oyun derste öğrendiğiniz oop ilkelerine uygun sınıf/arayüz tasarımları ile geliştirilmelidir. - zorluk seviyesi arttıkça zombi sayısı ve çeşitliliği artmalıdır. - oyun duraklatılabilmeli ve kaydedilip tekrar yüklenilebilmelidir (fileio kullanılmalıdır). - sol üst köşede seçili silah ve kalan mermi miktarı gösterilmelidir. - sağ üst köşede oyuncunun canı ve toplam puanı gösterilmelidir. - oyunun duraklatılması, kaydedilmesi ve devam ettirilmesi için bir menü bulunmalıdır. 3 silahlar oyunda farklı silahlar bulunmaktadır. belirli zombi dalgaları temizlendikten sonra oyun ödül olarak yeni bir silahverecektir. hersilahınkendineözgübirçalışmamekanizmasıvardır. silahlarınşarjörkapasitesisınırlıdır ve şarjördeki mermiler bittiğinde tekrar doldurulmadan ateş edilemez. toplam mermi sayısı oyuncunun o silaha ait elinde ne kadar mermi olduğunu gösterir. r tuşuna basarak şarjör yeniden doldurulabilir. 3.1 tabanca - şarjör kapasitesi: 12 mermi - ateş hızı: 120 mermi/dakika - elde etme: oyuncu oyuna bu silahla başlar. - özellik: düz atış yapar, sapma yoktur. sınırsız yedek şarjör (diğer tüm silahlar için yedek şarjör ve mermiler rastgele bir şekilde dalga sırasında ve sonlarında zombilerden düşer). 3.2 piyade tüfeği - şarjör kapasitesi: 30 mermi - ateş hızı: 600 mermi/dakika - elde etme: 1. dalga tamamlandıktan sonra - özellik: düzatışyaparancak30derecesapmasıvardır. sapmaaçısı, karakterinbaktığıyöndemerminin her iki dönme yönüne de saçılabileceği maksimum açıdır. 1 3.3 pompalı tüfek - şarjör kapasitesi: 5 mermi - ateş hızı: 60 mermi/dakika - elde etme: 3. dalga tamamlandıktan sonra - özellik: her atış 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi atar (yani karakter merkezli mermi hız vektörleri arasında 5 derece açı olmalıdır). 3.4 keskin nişancı tüfeği - şarjör kapasitesi: 5 mermi - ateş hızı: 30 mermi/dakika - elde etme: 5. dalga tamamlandıktan sonra - özellik: mermileri zombileri delip arasındaki zombilere de hasar verir. 3.5 roketatar - şarjör kapasitesi: 1 roket - ateş hızı: 10 roket/dakika - elde etme: 10. dalga tamamlandıktan sonra - özellik: patlama etkisiyle birden fazla zombiye zarar verir. 4 zombiler zombiler oyundaki düşman tipleridir. zombiler oyuncuya doğru ilerlerler ve eğer oyuncuya temas ederlerse oyuncuya hasar verirler. zorluk seviyesi arttıkça zombilerin sayısı ve çeşitliliği artmaktadır. zombi tipleri birbirinden renk ya da şekil olarak ayırt edilebilmelidir. 4.1 normal zombi - can: orta - hız: yavaş - hasar: orta 4.2 sürünge zombi - can: düşük - hız: hızlı - hasar: orta - özellik: oyuncunun yakınına geldiğinde zıplar. 4.3 tank zombi - can: yüksek - hız: çok yavaş - hasar: yüksek 2 4.4 asit tüküren zombi - can: düşük - hız: yavaş - hasar: orta (uzaktan asit tükürebilir) - özellik: öldürüldüğünde yanındaki birimlere zarar verir. 5 rapor ve teslim formatı - oyun, oopprensiplerineuygunolaraktasarlanmalıvesınıfdiyagramları, arayüztasarımıfinalraporda sunulmalıdır. - oyun test edilerek ekran görüntüleri rapora eklenmelidir. - rapor pdf formatında olmalı ve ismi proje_rapor.pdf olmalıdır. - oyunun mainfonksiyonu gameisimli bir sınıf içinde bulunmalıdır ( java game komutuyla çalışmalı). - kaynak kodun tamamı source.zip (uzantı 7z, rar, tar.gz de olabilir) şeklinde sıkıştırılmış olmalıdır. - sıkıştırılmış kaynak kod ve rapor uzak sistemine yüklenmelidir. 6 yardımcı kaynaklar dahaöncehiçkuşbakışıatışoyunuoynamadıysanızaşağıdakioyunlarıreferansolarakalabilirsiniz. buradaki oyunlarıngrafikleriilemekaniklerisizdenbeklenendenfarklıolsadaharitatasarımı, karakterhareketi,kamera hareketi, ateş etme mekanikleri ve zombilerin yapay zekası ile ilgili temel fikirler edinebilirsiniz. - little top-down shooter: https://www.youtube.com/watch?v=pj3m3fu3i5a - super c - stage 2: https://www.youtube.com/watch?v=os2t_v5suj4 - neon chrome: https://www.youtube.com/watch?v=puhw1bevtro 3 import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.io.*; import java.util.hashtable; public class gamewindow extends jframe { private gamepanel gamepanel; private jmenubar menubar; private jmenu gamemenu; private jmenuitem pausemenuitem; private jmenuitem savemenuitem; private jmenuitem loadmenuitem; private jmenuitem exitmenuitem; private settingsmanager settingsmanager; public gamewindow() { settitle(""deadpool vs zombies""); setdefaultcloseoperation(jframe.exit_on_close); setsize(800, 600); setlocationrelativeto(null); settingsmanager = settingsmanager.getinstance(); createmenubar(); showmainmenu(); addkeylistener(new keyadapter() { @override public void keypressed(keyevent e) { if (gamepanel != null) { gamepanel.keypressed(e); } } @override public void keyreleased(keyevent e) { if (gamepanel != null) { gamepanel.keyreleased(e); } } }); addmouselistener(new mouseadapter() { @override public void mousepressed(mouseevent e) { if (gamepanel != null) { gamepanel.mousepressed(e); } } @override public void mousereleased(mouseevent e) { if (gamepanel != null) { gamepanel.mousereleased(e); } } }); addmousemotionlistener(new mousemotionadapter() { @override public void mousemoved(mouseevent e) { if (gamepanel != null) { gamepanel.mousemoved(e); } } }); addwindowlistener(new windowadapter() { @override public void windowclosing(windowevent e) { if (gamepanel != null) { gamepanel.cleanup(); } settingsmanager.savesettings(); } }); setfocusable(true); requestfocus(); } private void createmenubar() { menubar = new jmenubar(); gamemenu = new jmenu(""oyun""); pausemenuitem = new jmenuitem(""duraklat (p)""); pausemenuitem.addactionlistener(e -> { if (gamepanel != null) { gamepanel.togglepause(); } }); savemenuitem = new jmenuitem(""kaydet""); savemenuitem.addactionlistener(e -> { jfilechooser filechooser = new jfilechooser(); if (filechooser.showsavedialog(this) == jfilechooser.approve_option) { file file = filechooser.getselectedfile(); if (gamepanel != null) { gamepanel.savegame(file); } } }); loadmenuitem = new jmenuitem(""yükle""); loadmenuitem.addactionlistener(e -> { jfilechooser filechooser = new jfilechooser(); if (filechooser.showopendialog(this) == jfilechooser.approve_option) { file file = filechooser.getselectedfile(); if (gamepanel != null) { gamepanel.loadgame(file); } } }); exitmenuitem = new jmenuitem(""çıkış""); exitmenuitem.addactionlistener(e -> system.exit(0)); gamemenu.add(pausemenuitem); gamemenu.add(savemenuitem); gamemenu.add(loadmenuitem); gamemenu.addseparator(); gamemenu.add(exitmenuitem); menubar.add(gamemenu); setjmenubar(menubar); } public void showmainmenu() { if (gamepanel != null) { gamepanel.cleanup(); remove(gamepanel); gamepanel = null; } getcontentpane().removeall(); jpanel mainmenupanel = new jpanel(); mainmenupanel.setlayout(new boxlayout(mainmenupanel, boxlayout.y_axis)); mainmenupanel.setbackground(color.dark_gray); jlabel titlelabel = new jlabel(""deadpool vs zombies""); titlelabel.setfont(new font(""arial"", font.bold, 28)); titlelabel.setforeground(color.red); titlelabel.setalignmentx(component.center_alignment); mainmenupanel.add(box.createverticalstrut(100)); mainmenupanel.add(titlelabel); mainmenupanel.add(box.createverticalstrut(50)); jbutton startbutton = createmenubutton(""yeni oyun""); startbutton.addactionlistener(e -> startnewgame()); jbutton settingsbutton = createmenubutton(""ayarlar""); settingsbutton.addactionlistener(e -> showsettingsmenu()); jbutton exitbutton = createmenubutton(""çıkış""); exitbutton.addactionlistener(e -> { settingsmanager.savesettings(); system.exit(0); }); mainmenupanel.add(startbutton); mainmenupanel.add(box.createverticalstrut(20)); mainmenupanel.add(settingsbutton); mainmenupanel.add(box.createverticalstrut(20)); mainmenupanel.add(exitbutton); add(mainmenupanel); validate(); repaint(); } private jbutton createmenubutton(string text) { jbutton button = new jbutton(text); button.setalignmentx(component.center_alignment); button.setmaximumsize(new dimension(200, 50)); button.setfont(new font(""arial"", font.bold, 16)); return button; } private void startnewgame() { getcontentpane().removeall(); gamepanel = new gamepanel(this); add(gamepanel); if (gamepanel.soundmanager != null) { settingsmanager.applysettings(gamepanel.soundmanager); } gamepanel.requestfocusinwindow(); validate(); repaint(); } private void showsettingsmenu() { getcontentpane().removeall(); jpanel settingspanel = new jpanel(); settingspanel.setlayout(new boxlayout(settingspanel, boxlayout.y_axis)); settingspanel.setbackground(color.dark_gray); jlabel titlelabel = new jlabel(""ayarlar""); titlelabel.setfont(new font(""arial"", font.bold, 24)); titlelabel.setforeground(color.white); titlelabel.setalignmentx(component.center_alignment); settingspanel.add(box.createverticalstrut(50)); settingspanel.add(titlelabel); settingspanel.add(box.createverticalstrut(50)); boolean sfxenabled = settingsmanager.issfxenabled(); boolean musicenabled = settingsmanager.ismusicenabled(); int sfxvalue = (int) (settingsmanager.getsfxvolume() * 100); int musicvalue = (int) (settingsmanager.getmusicvolume() * 100); jcheckbox sfxtogglebox = new jcheckbox(""ses efektleri aktif"", sfxenabled); sfxtogglebox.setfont(new font(""arial"", font.bold, 16)); sfxtogglebox.setforeground(color.white); sfxtogglebox.setbackground(color.dark_gray); sfxtogglebox.setalignmentx(component.center_alignment); settingspanel.add(sfxtogglebox); settingspanel.add(box.createverticalstrut(10)); jlabel sfxlabel = new jlabel(""ses efektleri seviyesi""); sfxlabel.setfont(new font(""arial"", font.bold, 18)); sfxlabel.setforeground(color.white); sfxlabel.setalignmentx(component.center_alignment); settingspanel.add(sfxlabel); jslider sfxslider = new jslider(jslider.horizontal, 0, 100, sfxvalue); setupslider(sfxslider); settingspanel.add(sfxslider); settingspanel.add(box.createverticalstrut(30)); jcheckbox musictogglebox = new jcheckbox(""müzik aktif"", musicenabled); musictogglebox.setfont(new font(""arial"", font.bold, 16)); musictogglebox.setforeground(color.white); musictogglebox.setbackground(color.dark_gray); musictogglebox.setalignmentx(component.center_alignment); settingspanel.add(musictogglebox); settingspanel.add(box.createverticalstrut(10)); jlabel musiclabel = new jlabel(""müzik seviyesi""); musiclabel.setfont(new font(""arial"", font.bold, 18)); musiclabel.setforeground(color.white); musiclabel.setalignmentx(component.center_alignment); settingspanel.add(musiclabel); jslider musicslider = new jslider(jslider.horizontal, 0, 100, musicvalue); setupslider(musicslider); settingspanel.add(musicslider); settingspanel.add(box.createverticalstrut(30)); // save button jbutton savebutton = createmenubutton(""kaydet""); savebutton.addactionlistener(e -> { settingsmanager.setsfxenabled(sfxtogglebox.isselected()); settingsmanager.setmusicenabled(musictogglebox.isselected()); settingsmanager.setsfxvolume(sfxslider.getvalue() / 100.0f); settingsmanager.setmusicvolume(musicslider.getvalue() / 100.0f); settingsmanager.savesettings(); if (gamepanel != null && gamepanel.soundmanager != null) { settingsmanager.applysettings(gamepanel.soundmanager); } system.out.println(""ayarlar kaydedildi""); showmainmenu(); }); settingspanel.add(savebutton); settingspanel.add(box.createverticalstrut(20)); jbutton backbutton = createmenubutton(""geri""); backbutton.addactionlistener(e -> showmainmenu()); settingspanel.add(backbutton); add(settingspanel); validate(); repaint(); } private void setupslider(jslider slider) { slider.setmajortickspacing(25); slider.setminortickspacing(5); slider.setpaintticks(true); slider.setpaintlabels(true); slider.setalignmentx(component.center_alignment); slider.setmaximumsize(new dimension(300, 50)); slider.setpreferredsize(new dimension(300, 50)); // add custom labels hashtable<integer, jlabel> labeltable = new hashtable<>(); labeltable.put(0, createsliderlabel(""kapalı"")); labeltable.put(50, createsliderlabel(""orta"")); labeltable.put(100, createsliderlabel(""yüksek"")); slider.setlabeltable(labeltable); } private jlabel createsliderlabel(string text) { jlabel label = new jlabel(text); label.setforeground(color.white); return label; } public static void main(string[] args) { swingutilities.invokelater(() -> new gamewindow()); } } import javax.swing.*; import entitys.*; import entitys.zombie.*; import java.awt.*; import java.awt.event.*; import java.io.*; import java.util.arraylist; import java.util.list; import java.util.random; import silah.*; import mermi.*; public class gamepanel extends jpanel implements runnable, mouselistener, keylistener { private gamewindow gamewindow; private thread gamethread; private boolean running = false; private boolean paused = false; private player player; private list<zombie> zombies; private list<bullet> bullets; private list<weapon> playerweapons; private list<ammopickup> ammopickups; private int currentwave = 0; private int zombieskilled = 0; private int totalscore = 0; private random random; private string currentmessage = """"; private long messagedisplaytime = 0; private boolean gameovermenushown = false; private static final int map_width = 1600; private static final int map_height = 1200; private double camerax = 0; private double cameray = 0; // ui bilgileri private font uifont = new font(""arial"", font.bold, 14); public soundmanager soundmanager; public gamepanel(gamewindow gamewindow) { this.gamewindow = gamewindow; setpreferredsize(new dimension(map_width, map_height)); setbackground(color.dark_gray); setfocusable(true); this.addmouselistener(this); random = new random(); initializegame(); // oyun döngüsünü başlatma startgameloop(); } public void initializegame() { imageutils.ensureimagefolderexists(); currentwave = 0; zombieskilled = 0; totalscore = 0; player = new player(400, 300); zombies = new arraylist<>(); bullets = new arraylist<>(); ammopickups = new arraylist<>(); // sadece başlangıç tabancasını oluştur playerweapons = new arraylist<weapon>(); weapon pistol = new pistol(); playerweapons.add(pistol); player.setcurrentweapon(playerweapons.get(0)); // keylistener ekleme this.addkeylistener(this); // ilk dalgayı başlatma startnextwave(); // soundmanager başlatma soundmanager = new soundmanager(); // ses efektlerini yükleme soundmanager.loadsoundeffect(""wave_start"", ""sounds\\newwave.wav""); soundmanager.loadsoundeffect(""gameover"", ""sounds\\gameover.wav""); // oyun müziğini yükleme try { soundmanager.loadbackgroundmusic(""sounds\\gamebackground.wav""); system.out.println(""müzik başarıyla yüklendi""); } catch (exception e) { system.err.println(""müzik yüklenirken hata: "" + e.getmessage()); e.printstacktrace(); } // ses ayarlarını uygula soundmanager.togglesoundeffects(true); // oyun başladığında müziği çal startgamemusic(); system.out.println(""müzik başladı""); } public void startgamemusic() { if (soundmanager != null) { system.out.println(""müzik başlatılıyor...""); soundmanager.togglemusic(true); } else { system.out.println(""soundmanager null.""); } } public void stopgamemusic() { if (soundmanager != null) { soundmanager.togglemusic(false); } } private void startgameloop() { if (gamethread != null && gamethread.isalive()) { running = false; try { gamethread.join(1000); } catch (interruptedexception e) { e.printstacktrace(); } } running = true; gamethread = new thread(this); gamethread.start(); } @override public void run() { // oyun döngüsü long lasttime = system.nanotime(); double amountofticks = 60.0; double ns = 1000000000 / amountofticks; double delta = 0; while (running) { long now = system.nanotime(); delta += (now - lasttime) / ns; lasttime = now; while (delta >= 1) { if (!paused) { update(); } delta--; } repaint(); try { thread.sleep(10); } catch (interruptedexception e) { e.printstacktrace(); } } } private void update() { // player güncellemesi player.update(); // zombi güncellemeleri for (int i = zombies.size() - 1; i >= 0; i--) { zombie zombie = zombies.get(i); zombie.update(player); // player ile çarpışma kontrolü if (zombie.intersects(player)) { player.takedamage(zombie.getdamage()); double centerplayerx = player.getx() + player.getwidth() / 2; double centerplayery = player.gety() + player.getheight() / 2; double centerzombiex = zombie.getx() + zombie.getwidth() / 2; double centerzombiey = zombie.gety() + zombie.getheight() / 2; double angle = math.atan2(centerzombiey - centerplayery, centerzombiex - centerplayerx); // zombiyi geri it zombie.x += math.cos(angle) * 10; zombie.y += math.sin(angle) * 10; // hasar sonrası kontrol etme if (player.gethealth() <= 0) { gameover(); break; } } } // mermi güncellemeleri for (int i = bullets.size() - 1; i >= 0; i--) { bullet bullet = bullets.get(i); bullet.update(); // merminin ekran dışına çıkma kontrolü if (bullet.isoutofbounds()) { bullets.remove(i); continue; } // zombiler ile çarpışma kontrolü for (int j = zombies.size() - 1; j >= 0; j--) { zombie zombie = zombies.get(j); if (bullet.intersects(zombie)) { zombie.takedamage(bullet.getdamage()); // keskin nişancı tüfeği ile merminin zombileri delmesi if (!(bullet.getweapontype() == weapontype.sniperrifle)) { bullets.remove(i); break; } // zombi ölü mü if (zombie.gethealth() <= 0) { handlezombiedeath(zombie); zombieskilled++; totalscore += (currentwave * 10); // dalga numarasına göre puan ver // tüm zombiler öldü mü if (zombies.isempty()) { startnextwave(); } } } } } // cephane toplama güncellemeleri for (int i = ammopickups.size() - 1; i >= 0; i--) { ammopickup ammo = ammopickups.get(i); if (player.intersects(ammo)) { player.collectammo(ammo); ammopickups.remove(i); } } updatezombies(); } private void handlezombiedeath(zombie zombie) { zombies.remove(zombie); // asit tüküren zombi için özel efekt(diger zombilere hasar) if (zombie instanceof acidzombie) { for (zombie nearzombie : zombies) { if (zombie.getdistance(nearzombie) < 50) { nearzombie.takedamage(20); } } } if (random.nextdouble() < 0.3) { ammopickup ammo = new ammopickup(zombie.getx(), zombie.gety(), weapontype.values()[random.nextint(weapontype.values().length)]); ammopickups.add(ammo); } } private void startnextwave() { currentwave++; player.sethealth(100); playsoundeffect(""wave_start""); // her dalga sonunda yeni silah verme if (currentwave == 1) { // ilk dalgada sadece başlangıç tabancası olsun showmessage(""dalga "" + currentwave + "" başladı!""); } else if (currentwave == 2) { playerweapons.add(new assaultrifle()); showmessage(""piyade tüfeği kazandınız!""); } else if (currentwave == 3) { playerweapons.add(new shotgun()); showmessage(""pompalı tüfek kazandınız!""); } else if (currentwave == 4) { playerweapons.add(new sniperrifle()); showmessage(""keskin nişancı tüfeği kazandınız!""); } else if (currentwave == 5) { playerweapons.add(new rocketlauncher()); showmessage(""roketatar kazandınız!""); } else if (currentwave > 5) { showmessage(""dalga "" + currentwave + "" başladı!""); } // dalgaya göre zombileri oluştur createzombiesforwave(); } private void createzombiesforwave() { int basezombiecount = 5; int zombiecount = basezombiecount + (currentwave * 2); for (int i = 0; i < zombiecount; i++) { // geniş harita için spawn int x = random.nextint(map_width); int y = random.nextint(map_height); // playerdan belirli bir mesafede spawn ol while (math.abs(x - player.getx()) < 300 && math.abs(y - player.gety()) < 300) { x = random.nextint(map_width); y = random.nextint(map_height); } zombie zombie = createzombiebasedonwave(x, y); zombies.add(zombie); } } private zombie createzombiebasedonwave(int x, int y) { double zombietype = random.nextdouble(); if (currentwave >= 7 && zombietype < 0.2) { return new acidzombie((double) x, (double) y); } else if (currentwave >= 5 && zombietype < 0.4) { return new tankzombie((double) x, (double) y); } else if (currentwave >= 3 && zombietype < 0.6) { return new crawlerzombie((double) x, (double) y); } else { return new normalzombie((double) x, (double) y); } } private void showmessage(string message) { currentmessage = message; messagedisplaytime = system.currenttimemillis() + 3000; this.requestfocusinwindow(); } private void gameover() { running = false; gameovermenushown = true; if (soundmanager != null) { soundmanager.stopmusic(); soundmanager.playsoundeffect(""gameover""); system.out.println(""gameover sound played""); } repaint(); } public void keypressed(keyevent e) { if (gameovermenushown) { if (e.getkeycode() == keyevent.vk_escape) { gamewindow.showmainmenu(); } return; } if (e.getkeycode() == keyevent.vk_escape || e.getkeycode() == keyevent.vk_p) { togglepause(); return; } if (paused) { if (e.getkeycode() == keyevent.vk_escape || e.getkeycode() == keyevent.vk_p) { togglepause(); } return; } // silah değiştirme tuşları (1-5 arası rakamlar) if (e.getkeycode() >= keyevent.vk_1 && e.getkeycode() <= keyevent.vk_5) { int weaponindex = e.getkeycode() - keyevent.vk_1; if (weaponindex < playerweapons.size()) { player.setcurrentweapon(playerweapons.get(weaponindex)); showmessage(playerweapons.get(weaponindex).getname() + "" seçildi!""); } } // r tuşu ile yeniden doldurma if (e.getkeycode() == keyevent.vk_r) { if (player.getcurrentweapon() != null) { weapon currentweapon = player.getcurrentweapon(); int ammoneeded = currentweapon.getsarjorsize() - currentweapon.getcurrentammo(); if (ammoneeded > 0 && currentweapon.gettotalammo() > 0) { if (currentweapon.gettotalammo() >= ammoneeded) { currentweapon.setcurrentammo(currentweapon.getsarjorsize()); currentweapon.settotalammo(currentweapon.gettotalammo() - ammoneeded); } else { currentweapon.setcurrentammo(currentweapon.getcurrentammo() + currentweapon.gettotalammo()); currentweapon.settotalammo(0); } showmessage(currentweapon.getname() + "" yeniden dolduruldu!""); } } } player.keypressed(e); } public void keyreleased(keyevent e) { player.keyreleased(e); } @override public void mousepressed(mouseevent e) { if (!gameovermenushown) { player.mousepressed(e, bullets); } } @override public void mousereleased(mouseevent e) { if (!gameovermenushown) { player.mousereleased(e); } } public void mousemoved(mouseevent e) { player.mousemoved(e); } public void togglepause() { paused = !paused; if (soundmanager != null) { if (paused) { soundmanager.pausemusic(); showmessage(""oyun duraklatıldı""); } else { if (soundmanager.ismusicenabled()) { soundmanager.resumemusic(); } showmessage(""oyun devam ediyor""); } } } public void savegame(file file) { try (objectoutputstream oos = new objectoutputstream(new fileoutputstream(file))) { gamestate gamestate = new gamestate( player, zombies, bullets, playerweapons, ammopickups, currentwave, zombieskilled, totalscore); oos.writeobject(gamestate); showmessage(""oyun kaydedildi!""); } catch (ioexception e) { e.printstacktrace(); showmessage(""oyun kaydedilemedi!""); } } public void loadgame(file file) { try (objectinputstream ois = new objectinputstream(new fileinputstream(file))) { gamestate gamestate = (gamestate) ois.readobject(); player = gamestate.getplayer(); zombies = gamestate.getzombies(); bullets = gamestate.getbullets(); playerweapons = gamestate.getplayerweapons(); ammopickups = gamestate.getammopickups(); currentwave = gamestate.getcurrentwave(); zombieskilled = gamestate.getzombieskilled(); totalscore = gamestate.gettotalscore(); for (weapon weapon : playerweapons) { weapon.setbulletlist(bullets); } if (player.getcurrentweapon() == null && !playerweapons.isempty()) { player.setcurrentweapon(playerweapons.get(0)); } if (!player.isimageloaded()) { player.loadplayerimage(); } showmessage(""oyun yüklendi!""); } catch (ioexception | classnotfoundexception e) { e.printstacktrace(); showmessage(""oyun yüklenemedi!""); } } @override protected void paintcomponent(graphics g) { super.paintcomponent(g); graphics2d g2d = (graphics2d) g; g2d.translate(-camerax, -cameray); g2d.setcolor(color.dark_gray); g2d.fillrect(0, 0, getwidth(), getheight()); // zombileri çiz for (zombie zombie : zombies) { zombie.draw(g2d); } // mermileri çiz for (bullet bullet : bullets) { bullet.draw(g2d); } for (ammopickup ammo : ammopickups) { ammo.draw(g2d); } // oyuncuyu çiz player.draw(g2d); // ui bilgilerini çiz g2d.translate(camerax, cameray); drawui(g2d); // mini haritayı çiz (ui elemanlarının üzerine) drawminimap(g2d); if (!currentmessage.isempty() && system.currenttimemillis() < messagedisplaytime) { g2d.setcolor(new color(0, 0, 0, 150)); g2d.fillrect(getwidth() / 4, getheight() / 3, getwidth() / 2, 40); g2d.setcolor(color.white); g2d.setfont(new font(""arial"", font.bold, 18)); int textwidth = g2d.getfontmetrics().stringwidth(currentmessage); g2d.drawstring(currentmessage, (getwidth() - textwidth) / 2, getheight() / 3 + 28); } // duraklatma if (paused) { g2d.setcolor(new color(0, 0, 0, 150)); g2d.fillrect(0, 0, getwidth(), getheight()); g2d.setcolor(color.white); g2d.setfont(new font(""arial"", font.bold, 36)); string pausetext = ""duraklatildi""; int textwidth = g2d.getfontmetrics().stringwidth(pausetext); g2d.drawstring(pausetext, (getwidth() - textwidth) / 2, getheight() / 2); } if (gameovermenushown) { g2d.setcolor(new color(0, 0, 0, 180)); g2d.fillrect(0, 0, getwidth(), getheight()); g2d.setcolor(color.white); g2d.setfont(new font(""arial"", font.bold, 36)); string gameovertext = ""oyun bi̇tti̇""; string scoretext = ""toplam puan: "" + totalscore; int gameoverwidth = g2d.getfontmetrics().stringwidth(gameovertext); int scorewidth = g2d.getfontmetrics(g2d.getfont()).stringwidth(scoretext); g2d.drawstring(gameovertext, (getwidth() - gameoverwidth) / 2, getheight() / 2 - 30); g2d.setfont(new font(""arial"", font.bold, 24)); g2d.drawstring(scoretext, (getwidth() - scorewidth) / 2 + 50, getheight() / 2 + 20); drawbutton(g2d, ""yeniden başla"", getwidth() / 2 - 100, getheight() / 2 + 70, 200, 50); drawbutton(g2d, ""ana menü"", getwidth() / 2 - 100, getheight() / 2 + 140, 200, 50); } } private void drawui(graphics2d g2d) { g2d.setfont(uifont); // sol üst köşe ve silah bilgisi g2d.setcolor(color.white); g2d.drawstring(""silah: "" + player.getcurrentweapon().getname(), 10, 20); g2d.drawstring(""şarjör: "" + player.getcurrentweapon().getcurrentammo() + "" / "" + player.getcurrentweapon().getsarjorsize(), 10, 40); g2d.drawstring(""toplam mermi: "" + player.getcurrentweapon().gettotalammo(), 10, 60); // envanterdeki silahları göster g2d.drawstring(""silahlar:"", 10, 80); for (int i = 0; i < playerweapons.size(); i++) { weapon weapon = playerweapons.get(i); g2d.drawstring((i + 1) + "": "" + weapon.getname(), 10, 100 + (i * 20)); } // sağ üst köşe ve player bilgisi string healthtext = ""can: "" + player.gethealth(); string scoretext = ""puan: "" + totalscore; string wavetext = ""dalga: "" + currentwave; int healthwidth = g2d.getfontmetrics().stringwidth(healthtext); int scorewidth = g2d.getfontmetrics().stringwidth(scoretext); int wavewidth = g2d.getfontmetrics().stringwidth(wavetext); g2d.drawstring(healthtext, getwidth() - healthwidth - 10, 20); g2d.drawstring(scoretext, getwidth() - scorewidth - 10, 40); g2d.drawstring(wavetext, getwidth() - wavewidth - 10, 60); } private void updatezombies() { list<zombie> zombiestoremove = new arraylist<>(); for (zombie zombie : zombies) { zombie.update(player); if (zombie.gethealth() <= 0) { zombiestoremove.add(zombie); zombieskilled++; totalscore += (currentwave * 10); } } zombies.removeall(zombiestoremove); if (!zombiestoremove.isempty() && zombies.isempty()) { startnextwave(); } if (!zombiestoremove.isempty()) { system.out.println(zombiestoremove.size() + "" zombi öldürüldü. kalan zombi: "" + zombies.size()); } } private void drawbutton(graphics2d g2d, string text, int x, int y, int width, int height) { g2d.setcolor(new color(80, 80, 80)); g2d.fillrect(x, y, width, height); g2d.setcolor(color.black); g2d.drawrect(x, y, width, height); g2d.setcolor(color.white); g2d.setfont(new font(""arial"", font.bold, 18)); int textwidth = g2d.getfontmetrics().stringwidth(text); g2d.drawstring(text, x + (width - textwidth) / 2, y + height / 2 + 5); } @override public void mouseclicked(mouseevent e) { if (gameovermenushown) { int mousex = e.getx(); int mousey = e.gety(); if (mousex >= getwidth() / 2 - 100 && mousex <= getwidth() / 2 + 100 && mousey >= getheight() / 2 + 70 && mousey <= getheight() / 2 + 120) { system.out.println(""yeniden başla clicked""); gameovermenushown = false; initializegame(); startgameloop(); this.requestfocusinwindow(); } if (mousex >= getwidth() / 2 - 100 && mousex <= getwidth() / 2 + 100 && mousey >= getheight() / 2 + 140 && mousey <= getheight() / 2 + 190) { system.out.println(""ana menü clicked""); gameovermenushown = false; gamewindow.showmainmenu(); } } } @override public void mouseentered(mouseevent e) { } @override public void mouseexited(mouseevent e) { } @override public void keytyped(keyevent e) { } // mi̇ni̇map private void drawminimap(graphics2d g2d) { int minimapwidth = 150; int minimapheight = 100; g2d.setcolor(new color(0, 0, 0, 150)); g2d.fillrect(205, 10, minimapwidth, minimapheight); g2d.setcolor(color.green); int playerminix = 205 + (int) ((player.getx() / map_width) * minimapwidth); int playerminiy = 10 + (int) ((player.gety() / map_height) * minimapheight); g2d.filloval(playerminix, playerminiy, 5, 5); g2d.setcolor(color.red); for (zombie zombie : zombies) { int zombieminix = 205 + (int) ((zombie.getx() / map_width) * minimapwidth); int zombieminiy = 10 + (int) ((zombie.gety() / map_height) * minimapheight); g2d.filloval(zombieminix, zombieminiy, 3, 3); } } public void playsoundeffect(string name) { if (soundmanager != null) { soundmanager.playsoundeffect(name); } } public void cleanup() { stopgamemusic(); if (soundmanager != null) { soundmanager.cleanup(); } } } import java.io.*; import java.util.properties; public class settingsmanager { private static final string settings_file = ""gamesettings.properties""; // default settings private static final boolean default_sfx_enabled = true; private static final boolean default_music_enabled = true; private static final float default_sfx_volume = 0.6f; private static final float default_music_volume = 0.3f; private boolean sfxenabled; private boolean musicenabled; private float sfxvolume; private float musicvolume; private static settingsmanager instance; public static settingsmanager getinstance() { if (instance == null) { instance = new settingsmanager(); } return instance; } private settingsmanager() { loadsettings(); } public void loadsettings() { properties props = new properties(); file settingsfile = new file(settings_file); if (settingsfile.exists()) { try (fileinputstream in = new fileinputstream(settingsfile)) { props.load(in); sfxenabled = boolean .parseboolean(props.getproperty(""sfx_enabled"", string.valueof(default_sfx_enabled))); musicenabled = boolean .parseboolean(props.getproperty(""music_enabled"", string.valueof(default_music_enabled))); sfxvolume = float.parsefloat(props.getproperty(""sfx_volume"", string.valueof(default_sfx_volume))); musicvolume = float.parsefloat(props.getproperty(""music_volume"", string.valueof(default_music_volume))); system.out.println(""settings loaded: "" + ""sfx="" + sfxenabled + "", sfx volume="" + sfxvolume + "", music="" + musicenabled + "", music volume="" + musicvolume); } catch (ioexception e) { system.err.println(""error loading settings: "" + e.getmessage()); usedefaultsettings(); } catch (numberformatexception e) { system.err.println(""invalid number in settings file: "" + e.getmessage()); usedefaultsettings(); } } else { usedefaultsettings(); savesettings(); } } public void savesettings() { properties props = new properties(); props.setproperty(""sfx_enabled"", string.valueof(sfxenabled)); props.setproperty(""music_enabled"", string.valueof(musicenabled)); props.setproperty(""sfx_volume"", string.valueof(sfxvolume)); props.setproperty(""music_volume"", string.valueof(musicvolume)); try (fileoutputstream out = new fileoutputstream(settings_file)) { props.store(out, ""game settings""); system.out.println(""settings saved successfully!""); } catch (ioexception e) { system.err.println(""error saving settings: "" + e.getmessage()); } } private void usedefaultsettings() { sfxenabled = default_sfx_enabled; musicenabled = default_music_enabled; sfxvolume = default_sfx_volume; musicvolume = default_music_volume; system.out.println(""using default settings""); } public void applysettings(soundmanager soundmanager) { if (soundmanager != null) { soundmanager.togglesoundeffects(sfxenabled); soundmanager.togglemusic(musicenabled); soundmanager.seteffectsvolume(sfxvolume); soundmanager.setmusicvolume(musicvolume); } } public boolean issfxenabled() { return sfxenabled; } public void setsfxenabled(boolean sfxenabled) { this.sfxenabled = sfxenabled; } public boolean ismusicenabled() { return musicenabled; } public void setmusicenabled(boolean musicenabled) { this.musicenabled = musicenabled; } public float getsfxvolume() { return sfxvolume; } public void setsfxvolume(float sfxvolume) { if (sfxvolume < 0f) sfxvolume = 0f; if (sfxvolume > 1.0f) sfxvolume = 1.0f; this.sfxvolume = sfxvolume; } public float getmusicvolume() { return musicvolume; } public void setmusicvolume(float musicvolume) { if (musicvolume < 0f) musicvolume = 0f; if (musicvolume > 1.0f) musicvolume = 1.0f; this.musicvolume = musicvolume; } } public class game { public static void main(string[] args) { // oyunu başlatma gamewindow gamewindow = new gamewindow(); gamewindow.setvisible(true); } } import javax.sound.sampled.*; import java.io.file; import java.io.ioexception; import java.util.hashmap; import java.util.map; public class soundmanager { private clip backgroundmusic; private map<string, clip> soundeffects; private boolean musicenabled = true; private boolean soundeffectsenabled = true; private float musicvolume = 1.0f; // 1.0 = 100% private float effectsvolume = 1.0f; private boolean wasmusicplaying = false; public soundmanager() { soundeffects = new hashmap<>(); } public void loadbackgroundmusic(string filepath) { try { if (backgroundmusic != null) { backgroundmusic.close(); } system.out.println(""müzik dosyası yükleniyor: "" + filepath); file musicfile = new file(filepath); if (!musicfile.exists()) { system.err.println(""müzik dosyası bulunamadı: "" + musicfile.getabsolutepath()); return; } audioinputstream audiostream = audiosystem.getaudioinputstream(musicfile); backgroundmusic = audiosystem.getclip(); backgroundmusic.open(audiostream); backgroundmusic.loop(clip.loop_continuously); setmusicvolume(musicvolume); system.out.println(""müzik dosyası başarıyla yüklendi!""); } catch (unsupportedaudiofileexception | ioexception | lineunavailableexception e) { system.err.println(""müzik yüklenirken hata: "" + e.getmessage()); e.printstacktrace(); } } public void loadsoundeffect(string name, string filepath) { try { file soundfile = new file(filepath); audioinputstream audiostream = audiosystem.getaudioinputstream(soundfile); clip clip = audiosystem.getclip(); clip.open(audiostream); soundeffects.put(name, clip); } catch (unsupportedaudiofileexception | ioexception | lineunavailableexception e) { system.err.println(""error loading sound effect: "" + e.getmessage()); e.printstacktrace(); } } public void playsoundeffect(string name) { if (!soundeffectsenabled) return; clip clip = soundeffects.get(name); if (clip != null) { clip.stop(); clip.setframeposition(0); setclipvolume(clip, effectsvolume); clip.start(); } } public void togglemusic(boolean enabled) { musicenabled = enabled; if (backgroundmusic != null) { if (musicenabled) { try { backgroundmusic.setframeposition(0); backgroundmusic.start(); wasmusicplaying = true; setmusicvolume(musicvolume); system.out.println(""müzik başlatıldı, ses seviyesi: "" + musicvolume); } catch (exception e) { system.err.println(""müzik başlatılırken hata: "" + e.getmessage()); e.printstacktrace(); } } else { backgroundmusic.stop(); wasmusicplaying = false; system.out.println(""müzik durduruldu""); } } else { system.out.println(""backgroundmusic null - müzik çalınamıyor!""); } } public void togglesoundeffects(boolean enabled) { soundeffectsenabled = enabled; system.out.println(""ses efektleri "" + (enabled ? ""açıldı"" : ""kapatıldı"")); } public void setmusicvolume(float volume) { if (volume < 0f) volume = 0f; if (volume > 1.0f) volume = 1.0f; this.musicvolume = volume; system.out.println(""müzik ses seviyesi ayarlandı: "" + volume); if (backgroundmusic != null) { setclipvolume(backgroundmusic, volume); } } public void seteffectsvolume(float volume) { if (volume < 0f) volume = 0f; if (volume > 1.0f) volume = 1.0f; this.effectsvolume = volume; system.out.println(""efekt ses seviyesi ayarlandı: "" + volume); for (clip clip : soundeffects.values()) { if (clip != null) { setclipvolume(clip, volume); } } } public void setallvolumes(float volume) { setmusicvolume(volume); seteffectsvolume(volume); } private void setclipvolume(clip clip, float volume) { try { if (clip.iscontrolsupported(floatcontrol.type.master_gain)) { floatcontrol gaincontrol = (floatcontrol) clip.getcontrol(floatcontrol.type.master_gain); float db = (volume > 0) ? 20f * (float) math.log10(volume) : -80.0f; float min = gaincontrol.getminimum(); float max = gaincontrol.getmaximum(); db = math.max(min, math.min(max, db)); gaincontrol.setvalue(db); system.out.println(""clip ses seviyesi ayarlandı: "" + volume + "" ("" + db + "" db)""); } else { system.out.println(""bu clip için ses kontrolü desteklenmiyor!""); } } catch (exception e) { system.err.println(""ses seviyesi ayarlanırken hata: "" + e.getmessage()); e.printstacktrace(); } } public boolean ismusicenabled() { return musicenabled; } public boolean issoundeffectsenabled() { return soundeffectsenabled; } public float getmusicvolume() { return musicvolume; } public float geteffectsvolume() { return effectsvolume; } public void cleanup() { if (backgroundmusic != null) { backgroundmusic.stop(); backgroundmusic.close(); } for (clip clip : soundeffects.values()) { if (clip != null) { clip.stop(); clip.close(); } } } public void pausemusic() { if (backgroundmusic != null && backgroundmusic.isrunning()) { wasmusicplaying = true; backgroundmusic.stop(); system.out.println(""müzik duraklatıldı""); } else { wasmusicplaying = false; } } public void resumemusic() { if (backgroundmusic != null && wasmusicplaying && musicenabled) { backgroundmusic.start(); system.out.println(""müzik devam ediyor""); } } public void stopmusic() { if (backgroundmusic != null) { backgroundmusic.stop(); backgroundmusic.setframeposition(0); wasmusicplaying = false; system.out.println(""müzik durduruldu ve sıfırlandı""); } } } import java.io.file; public class imageutils { public static boolean ensureimagefolderexists() { file imagefolder = new file(""images""); if (!imagefolder.exists()) { boolean created = imagefolder.mkdir(); if (created) { system.out.println(""images klasörü oluşturuldu.""); return true; } else { system.err.println(""images klasörü oluşturulamadı!""); return false; } } else { file playerimage = new file(""images/player.png""); if (!playerimage.exists()) { system.out.println( ""uyarı: images/player.png bulunamadı. oyuncu resim olarak varsayılan oval kullanılacak.""); } return true; } } } import java.io.serializable; import java.util.list; import entitys.*; import entitys.zombie.*; import silah.*; import mermi.*; public class gamestate implements serializable { private static final long serialversionuid = 1l; private player player; private list<zombie> zombies; private list<bullet> bullets; private list<weapon> playerweapons; private list<ammopickup> ammopickups; private int currentwave; private int zombieskilled; private int totalscore; public gamestate(player player, list<zombie> zombies, list<bullet> bullets, list<weapon> playerweapons, list<ammopickup> ammopickups, int currentwave, int zombieskilled, int totalscore) { this.player = player; this.zombies = zombies; this.bullets = bullets; this.playerweapons = playerweapons; this.ammopickups = ammopickups; this.currentwave = currentwave; this.zombieskilled = zombieskilled; this.totalscore = totalscore; } public player getplayer() { return player; } public list<zombie> getzombies() { return zombies; } public list<bullet> getbullets() { return bullets; } public list<weapon> getplayerweapons() { return playerweapons; } public list<ammopickup> getammopickups() { return ammopickups; } public int getcurrentwave() { return currentwave; } public int getzombieskilled() { return zombieskilled; } public int gettotalscore() { return totalscore; } public void resolvereferences() { for (weapon weapon : playerweapons) { weapon.setbulletlist(bullets); } if (!playerweapons.isempty()) { player.setcurrentweapon(playerweapons.get(0)); } } } package mermi; import java.awt.*; import entitys.*; import silah.*; public class bullet implements entity { private static final long serialversionuid = 1l; protected double x, y; protected double velox, veloy; protected double angle; protected double speed = 10.0; protected int width = 4; protected int height = 4; protected int damage; protected weapontype weapontype; protected boolean ispenetrating = false; // keskin nişancı tüfeği private static final int map_width = 1600; private static final int map_height = 1200; public bullet(double x, double y, double angle, int damage, weapontype weapontype) { this.x = x; this.y = y; this.angle = angle; this.damage = damage; this.weapontype = weapontype; velox = math.cos(angle) * speed; veloy = math.sin(angle) * speed; } @override public void update() { x += velox; y += veloy; } @override public void draw(graphics2d g2d) { g2d.setcolor(getbulletcolor()); g2d.filloval((int) x - width / 2, (int) y - height / 2, width, height); } public boolean isoutofbounds() { return x < 0 || x > map_width || y < 0 || y > map_height; } private color getbulletcolor() { switch (weapontype) { case pistol: return color.yellow; case assaultrifle: return color.orange; case shotgun: return color.red; case sniperrifle: return color.white; case rocketlauncher: return color.red; default: return color.white; } } @override public double getx() { return x; } @override public double gety() { return y; } @override public int getwidth() { return width; } @override public int getheight() { return height; } public int getdamage() { return damage; } public weapontype getweapontype() { return weapontype; } public boolean ispenetrating() { return ispenetrating; } public void setpenetrating(boolean penetrating) { this.ispenetrating = penetrating; } @override public boolean intersects(entity other) { return x - width / 2 < other.getx() + other.getwidth() && x + width / 2 > other.getx() && y - height / 2 < other.gety() + other.getheight() && y + height / 2 > other.gety(); } @override public double getdistance(entity other) { double centerx = x; double centery = y; double othercenterx = other.getx() + other.getwidth() / 2; double othercentery = other.gety() + other.getheight() / 2; return math.sqrt(math.pow(centerx - othercenterx, 2) + math.pow(centery - othercentery, 2)); } } package mermi; import java.awt.*; import java.util.list; import entitys.*; import entitys.zombie.*; import silah.*; public class rocket extends bullet { private static final long serialversionuid = 1l; private int explosionradius = 100; private color trailcolor = new color(255, 140, 0, 150); public rocket(double x, double y, double angle, int damage, weapontype weapontype) { super(x, y, angle, damage, weapontype); this.speed = 5.0; this.width = 8; this.height = 8; } @override public void draw(graphics2d g2d) { g2d.setcolor(color.red); g2d.filloval((int) x - width / 2, (int) y - height / 2, width, height); // efekt bırakma g2d.setcolor(trailcolor); double traillength = 20.0; double trailx = x - math.cos(angle) * traillength; double traily = y - math.sin(angle) * traillength; g2d.drawline((int) x, (int) y, (int) trailx, (int) traily); } public void explode(list<zombie> zombies) { for (zombie zombie : zombies) { double distance = getdistance(zombie); if (distance <= explosionradius) { double damagemultiplier = 1.0 - (distance / explosionradius); int explosiondamage = (int) (damage * damagemultiplier); zombie.takedamage(explosiondamage); } } } } package mermi; import java.awt.*; import entitys.*; import silah.*; public class ammopickup implements entity { private static final long serialversionuid = 1l; private double x, y; private int width = 15; private int height = 15; private weapontype weapontype; private int amount; public ammopickup(double x, double y, weapontype weapontype) { this.x = x; this.y = y; this.weapontype = weapontype; switch (weapontype) { case pistol: amount = 12; break; case assaultrifle: amount = 30; break; case shotgun: amount = 5; break; case sniperrifle: amount = 5; break; case rocketlauncher: amount = 1; break; default: amount = 10; } } @override public void update() { } @override public void draw(graphics2d g2d) { g2d.setcolor(getammocolor()); g2d.fillrect((int) x, (int) y, width, height); g2d.setcolor(color.black); g2d.drawrect((int) x, (int) y, width, height); } private color getammocolor() { switch (weapontype) { case pistol: return color.yellow; case assaultrifle: return color.orange; case shotgun: return color.red; case sniperrifle: return color.white; case rocketlauncher: return new color(128, 0, 0); default: return color.gray; } } @override public double getx() { return x; } @override public double gety() { return y; } @override public int getwidth() { return width; } @override public int getheight() { return height; } public weapontype getweapontype() { return weapontype; } public int getamount() { return amount; } @override public boolean intersects(entity other) { return x < other.getx() + other.getwidth() && x + width > other.getx() && y < other.gety() + other.getheight() && y + height > other.gety(); } @override public double getdistance(entity other) { double centerx = x + width / 2; double centery = y + height / 2; double othercenterx = other.getx() + other.getwidth() / 2; double othercentery = other.gety() + other.getheight() / 2; return math.sqrt(math.pow(centerx - othercenterx, 2) + math.pow(centery - othercentery, 2)); } } package entitys; import java.awt.graphics2d; import java.io.serializable; public interface entity extends serializable { void update(); void draw(graphics2d g2d); double getx(); double gety(); int getwidth(); int getheight(); boolean intersects(entity other); double getdistance(entity other); } package entitys; import java.awt.*; import java.awt.event.*; import java.io.file; import java.io.ioexception; import java.util.list; import java.awt.image.bufferedimage; import javax.imageio.imageio; import entitys.zombie.*; import silah.*; import mermi.*; public class player implements entity { private static final long serialversionuid = 1l; private double x, y; private double velox, veloy; private int width = 20, height = 20; private int health = 100; private double angle = 0; private boolean moveup, movedown, moveleft, moveright; private boolean isshooting; private weapon currentweapon; private long lastshottime; private static final int map_width = 1600; private static final int map_height = 1200; private transient bufferedimage playerimage; private boolean imageloaded = false; // ölçeklendirme faktörü - görüntüyü küçültmek için private double scalecarpan = 0.7; // görüntüyü %70 boyutuna küçültür public player(double x, double y) { this.x = x; this.y = y; loadplayerimage(); } public void loadplayerimage() { try { playerimage = imageio.read(new file(""images\\dp_player.png"")); width = (int) (playerimage.getwidth() * scalecarpan); height = (int) (playerimage.getheight() * scalecarpan); imageloaded = true; system.out.println(""oyuncu görüntüsü başarıyla yüklendi.""); } catch (ioexception e) { system.err.println(""oyuncu görüntüsü yüklenirken hata: "" + e.getmessage()); // default değerler width = 30; height = 30; imageloaded = false; } } @override public void update() { // hareket işlemi velox = 0; veloy = 0; double speed = 3.0; if (moveup) veloy -= speed; if (movedown) veloy += speed; if (moveleft) velox -= speed; if (moveright) velox += speed; if ((moveup || movedown) && (moveleft || moveright)) { double diagonal = math.sqrt(2); velox /= diagonal; veloy /= diagonal; } // yeni konum double newx = x + velox; double newy = y + veloy; setposition(newx, newy); // ateş etme if (isshooting && currentweapon != null) { long currenttime = system.currenttimemillis(); long firerate = (long) (60000 / currentweapon.getfirerate()); // dakikada mermi ms cinsinden if (currenttime - lastshottime >= firerate && currentweapon.getcurrentammo() > 0) { shoot(); lastshottime = currenttime; } } } private void shoot() { if (currentweapon != null && currentweapon.getcurrentammo() > 0) { currentweapon.fire(this, angle); } } public void reloadweapon() { if (currentweapon != null) { currentweapon.reload(); } } public void takedamage(int damage) { health -= damage; if (health < 0) health = 0; } public void collectammo(ammopickup ammo) { if (currentweapon != null && currentweapon.gettype() == ammo.getweapontype()) { currentweapon.addammo(ammo.getamount()); } } public void keypressed(keyevent e) { switch (e.getkeycode()) { case keyevent.vk_w: moveup = true; break; case keyevent.vk_s: movedown = true; break; case keyevent.vk_a: moveleft = true; break; case keyevent.vk_d: moveright = true; break; } } public void keyreleased(keyevent e) { switch (e.getkeycode()) { case keyevent.vk_w: moveup = false; break; case keyevent.vk_s: movedown = false; break; case keyevent.vk_a: moveleft = false; break; case keyevent.vk_d: moveright = false; break; } } public void mousepressed(mouseevent e, list<bullet> bullets) { isshooting = true; double mousex = e.getx(); double mousey = e.gety(); updateangle(mousex, mousey); if (currentweapon != null) { currentweapon.setbulletlist(bullets); } } public void mousereleased(mouseevent e) { isshooting = false; } public void mousemoved(mouseevent e) { double mousex = e.getx(); double mousey = e.gety(); updateangle(mousex, mousey); } private void updateangle(double mousex, double mousey) { // karakterin merkezi double centerx = x + width / 2; double centery = y + height / 2; // fare ile karakter merkezi arasındaki açıyı hesapla angle = math.atan2(mousey - centery, mousex - centerx); } @override public void draw(graphics2d g2d) { // oyuncuyu çiz - görüntü veya varsayılan oval if (imageloaded) { g2d.drawimage(playerimage, (int) x, (int) y, width, height, null); // karakterin baktığı yönü gösteren ve silahı temsil eden çizgi double centerx = x + width / 2; double centery = y + height / 2; double linelength = 20; double endx = centerx + math.cos(angle) * linelength; double endy = centery + math.sin(angle) * linelength; g2d.setcolor(color.white); g2d.drawline((int) centerx, (int) centery, (int) endx, (int) endy); } else { // image yüklenemezse default mavi daire çiz g2d.setcolor(color.blue); g2d.filloval((int) x, (int) y, width, height); // karakterin baktığı yönü gösteren ve silahı temsil eden çizgi double centerx = x + width / 2; double centery = y + height / 2; double linelength = 20; double endx = centerx + math.cos(angle) * linelength; double endy = centery + math.sin(angle) * linelength; g2d.setcolor(color.white); g2d.drawline((int) centerx, (int) centery, (int) endx, (int) endy); } } @override public double getx() { return x; } @override public double gety() { return y; } @override public int getwidth() { return width; } @override public int getheight() { return height; } public void sethealth(int health) { this.health = health; } public double getangle() { return angle; } public int gethealth() { return health; } public weapon getcurrentweapon() { return currentweapon; } public void setcurrentweapon(weapon weapon) { this.currentweapon = weapon; } @override public boolean intersects(entity other) { return x < other.getx() + other.getwidth() && x + width > other.getx() && y < other.gety() + other.getheight() && y + height > other.gety(); } @override public double getdistance(entity other) { double centerx = x + width / 2; double centery = y + height / 2; double othercenterx = other.getx() + other.getwidth() / 2; double othercentery = other.gety() + other.getheight() / 2; return math.sqrt(math.pow(centerx - othercenterx, 2) + math.pow(centery - othercentery, 2)); } public void setposition(double x, double y) { this.x = math.max(0, math.min(x, map_width - width)); this.y = math.max(0, math.min(y, map_height - height)); } // görüntü değiştirme metodu - farklı karakterler veya durumlar için public void changeplayerimage(string imagepath) { try { playerimage = imageio.read(new file(imagepath)); imageloaded = true; system.out.println(""oyuncu görüntüsü değiştirildi: "" + imagepath); } catch (ioexception e) { system.err.println(""görüntü değiştirilirken hata: "" + e.getmessage()); imageloaded = false; } } // harita sınırları içinde hareket kontrolü public boolean iswithinmapbounds(double newx, double newy) { return newx >= 0 && newx <= map_width - width && newy >= 0 && newy <= map_height - height; } public string getmapposition() { return string.format(""konum: (%.2f, %.2f) - harita boyutu: %dx%d"", x, y, map_width, map_height); } private void readobject(java.io.objectinputstream in) throws ioexception, classnotfoundexception { in.defaultreadobject(); loadplayerimage(); } public boolean isimageloaded() { return imageloaded; } } package entitys.zombie; import java.awt.*; import java.io.serializable; import entitys.*; public abstract class zombie implements entity, serializable { private static final long serialversionuid = 1l; public double x, y; protected double velox, veloy; protected int width = 25; protected int height = 25; protected int health; protected int damage; protected double speed; protected color color; public zombie(double x, double y, int health, int damage, double speed, color color) { this.x = x; this.y = y; this.health = health; this.damage = damage; this.speed = speed; this.color = color; } public void update(player player) { // oyuncuya doğru hareket etme double playerx = player.getx() + player.getwidth() / 2; double playery = player.gety() + player.getheight() / 2; double centerx = x + width / 2; double centery = y + height / 2; double angle = math.atan2(playery - centery, playerx - centerx); velox = math.cos(angle) * speed; veloy = math.sin(angle) * speed; x += velox; y += veloy; } @override public void draw(graphics2d g2d) { g2d.setcolor(color); g2d.filloval((int) x, (int) y, width, height); // can barı int healthbarwidth = width; int healthbarheight = 5; int healthpercentage = (int) ((double) health / getmaxhealth() * healthbarwidth); g2d.setcolor(color.red); g2d.fillrect((int) x, (int) y - healthbarheight - 2, healthbarwidth, healthbarheight); g2d.setcolor(color.green); g2d.fillrect((int) x, (int) y - healthbarheight - 2, healthpercentage, healthbarheight); } public void takedamage(int damage) { health -= damage; if (health < 0) health = 0; } public abstract int getmaxhealth(); @override public double getx() { return x; } @override public double gety() { return y; } @override public int getwidth() { return width; } @override public int getheight() { return height; } public int gethealth() { return health; } public int getdamage() { return damage; } @override public boolean intersects(entity other) { return x < other.getx() + other.getwidth() && x + width > other.getx() && y < other.gety() + other.getheight() && y + height > other.gety(); } @override public double getdistance(entity other) { double centerx = x + width / 2; double centery = y + height / 2; double othercenterx = other.getx() + other.getwidth() / 2; double othercentery = other.gety() + other.getheight() / 2; return math.sqrt(math.pow(centerx - othercenterx, 2) + math.pow(centery - othercentery, 2)); } } package entitys.zombie; import java.awt.color; import java.util.random; import entitys.*; public class acidzombie extends zombie { private static final long serialversionuid = 1l; private static final int max_health = 40; private int tukcooldown = 0; private static final int tuk_cooldown_max = 120; // sıklık private int spitrange = 200; // tükürme menzili private int spitdamage = 5; // tükürme hasarı private random random; public acidzombie(double x, double y) { super(x, y, max_health, 10, 0.48, new color(0, 100, 0)); // koyu yeşil this.random = new random(); } @override public void update(player player) { super.update(player); // asit tükürme mekanizması if (tukcooldown <= 0) { double distance = getdistance(player); if (distance <= spitrange) { tukacid(player); tukcooldown = tuk_cooldown_max; ; } } else { tukcooldown--; } } private void tukacid(player player) { double distance = getdistance(player); double hitchance = 1.0 - (distance / spitrange); if (random.nextdouble() < hitchance) { player.takedamage(spitdamage); } } @override public int getmaxhealth() { return max_health; } @override public void update() { } } package entitys.zombie; import java.awt.color; public class normalzombie extends zombie { private static final long serialversionuid = 1l; private static final int max_health = 50; public normalzombie(double x, double y) { super(x, y, max_health, 10, 0.6, color.green); } @override public int getmaxhealth() { return max_health; } @override public void update() { } } package entitys.zombie; import java.awt.color; import entitys.*; public class crawlerzombie extends zombie { private static final long serialversionuid = 1l; private static final int max_health = 30; private boolean isjumping = false; private int jumpcooldown = 0; private static final int jump_cooldown_max = 60; // sıklık public crawlerzombie(double x, double y) { super(x, y, max_health, 10, 0.9, color.yellow); } @override public void update(player player) { double distance = getdistance(player); // yakında olduğunda atlama if (distance < 50 && jumpcooldown <= 0 && !isjumping) { isjumping = true; jumpcooldown = jump_cooldown_max; speed *= 2; } if (isjumping) { jumpcooldown--; if (jumpcooldown <= 0) { isjumping = false; speed = 0.9; } } else if (jumpcooldown > 0) { jumpcooldown--; } super.update(player); } @override public int getmaxhealth() { return max_health; } @override public void update() { } } package entitys.zombie; import java.awt.color; public class tankzombie extends zombie { private static final long serialversionuid = 1l; private static final int max_health = 150; public tankzombie(double x, double y) { super(x, y, max_health, 20, 0.3, color.gray); this.width = 35; this.height = 35; } @override public int getmaxhealth() { return max_health; } @override public void update() { } } package silah; import java.io.serializable; import java.util.list; import entitys.*; import mermi.*; public abstract class weapon implements serializable { private static final long serialversionuid = 1l; protected string name; protected int sarjorsize; protected int currentammo; protected int totalammo; protected double firerate; // dakikada atış sayısı protected int damage; protected weapontype type; protected list<bullet> bulletlist; public weapon(string name, int sarjorsize, double firerate, int damage, weapontype type) { this.name = name; this.sarjorsize = sarjorsize; this.currentammo = sarjorsize; this.totalammo = 10000;// başlangıç yedek mermi sayısı this.firerate = firerate; this.damage = damage; this.type = type; } public abstract void fire(player player, double angle); public void reload() { if (totalammo > 0) { int ammoneeded = sarjorsize - currentammo; int ammotoload = math.min(ammoneeded, totalammo); currentammo += ammotoload; totalammo -= ammotoload; } } public void addammo(int amount) { totalammo += amount; } // getter ve setter metodları public string getname() { return name; } public int getsarjorsize() { return sarjorsize; } public int getcurrentammo() { return currentammo; } public int gettotalammo() { return totalammo; } public double getfirerate() { return firerate; } public int getdamage() { return damage; } public weapontype gettype() { return type; } public void setbulletlist(list<bullet> bulletlist) { this.bulletlist = bulletlist; } public void setcurrentammo(int currentammo) { // negatif değer olmaması için kontrol if (currentammo < 0) { this.currentammo = 0; } else if (currentammo > sarjorsize) { // şarjör kapasitesini aşmaması için kontrol this.currentammo = sarjorsize; } else { this.currentammo = currentammo; } } public void settotalammo(int totalammo) { // negatif değer olmaması için kontrol if (totalammo < 0) { this.totalammo = 0; } else { this.totalammo = totalammo; } } } package silah; import entitys.*; import mermi.*; public class shotgun extends weapon { private static final long serialversionuid = 1l; public shotgun() { super(""pompalı tüfek"", 5, 60, 8, weapontype.shotgun); } @override public void fire(player player, double angle) { if (currentammo > 0) { double bulletx = player.getx() + player.getwidth() / 2; double bullety = player.gety() + player.getheight() / 2; // 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi double yayılmaangle = math.toradians(45); double teksacmaangle = yayılmaangle / 8; // 8 aralık 9 mermi for (int i = 0; i < 9; i++) { double currentangle = angle - (yayılmaangle / 2) + (i * teksacmaangle); bullet bullet = new bullet(bulletx, bullety, currentangle, damage, type); bulletlist.add(bullet); } currentammo--; } } } package silah; public enum weapontype { pistol, assaultrifle, shotgun, sniperrifle, rocketlauncher } package silah; import entitys.*; import mermi.*; public class sniperrifle extends weapon { private static final long serialversionuid = 1l; public sniperrifle() { super(""keskin nişancı tüfeği"", 5, 30, 50, weapontype.sniperrifle); } @override public void fire(player player, double angle) { if (currentammo > 0) { double bulletx = player.getx() + player.getwidth() / 2; double bullety = player.gety() + player.getheight() / 2; // mermi zombileri delip geçer bullet bullet = new bullet(bulletx, bullety, angle, damage, type); bullet.setpenetrating(true); bulletlist.add(bullet); currentammo--; } } } package silah; import entitys.*; import mermi.*; public class pistol extends weapon { private static final long serialversionuid = 1l; public pistol() { super(""tabanca"", 12, 120, 15, weapontype.pistol); this.totalammo = integer.max_value; // sınırsız yedek şarjör } @override public void fire(player player, double angle) { if (currentammo > 0) { double bulletx = player.getx() + player.getwidth() / 2; double bullety = player.gety() + player.getheight() / 2; bullet bullet = new bullet(bulletx, bullety, angle, damage, type); bulletlist.add(bullet); currentammo--; } } } package silah; import java.util.random; import entitys.*; import mermi.*; public class assaultrifle extends weapon { private static final long serialversionuid = 1l; private random random; public assaultrifle() { super(""piyade tüfeği"", 30, 600, 10, weapontype.assaultrifle); this.random = new random(); } @override public void fire(player player, double angle) { if (currentammo > 0) { double bulletx = player.getx() + player.getwidth() / 2; double bullety = player.gety() + player.getheight() / 2; // 30 derece sapma double sapma = math.toradians(30); double randomsapma = (random.nextdouble() - 0.5) * sapma; bullet bullet = new bullet(bulletx, bullety, angle + randomsapma, damage, type); bulletlist.add(bullet); currentammo--; } } } package silah; import entitys.*; import mermi.*; public class rocketlauncher extends weapon { private static final long serialversionuid = 1l; public rocketlauncher() { super(""roketatar"", 1, 10, 100, weapontype.rocketlauncher); } @override public void fire(player player, double angle) { if (currentammo > 0) { double bulletx = player.getx() + player.getwidth() / 2; double bullety = player.gety() + player.getheight() / 2; rocket rocket = new rocket(bulletx, bullety, angle, damage, type); bulletlist.add(rocket); currentammo--; } } }"
4540765,10,"4540765 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. package quiz1bil211nebiyanar; public class main { public static int collatz(int i,int count) { if(i==1) { return count ; } else if(i%2==0) { return collatz(i/2,count+1); } else { return collatz(3*i+1,count+1); } } public static void cocktailsort(int[] arr,int iteration) { //iteration 0 başlatılacak if(iteration==arr.length-1) { } else { if(iteration%2==0) { for(int i=0;i<arr.length-1;i++) { if(arr[i]>arr[i+1]) { int temp=arr[i]; arr[i]=arr[i+1]; arr[i+1]=temp; } } cocktailsort(arr, iteration+1); } else { for(int i=arr.length-1;i>0;i--) { if(arr[i-1]>arr[i]) { int temp=arr[i-1]; arr[i-1]=arr[i]; arr[i]=temp; } } cocktailsort(arr, iteration+1); } } } public static void main(string[] args) { //system.out.println(collatz(5,0)); sayac sayac=new sayac(""10001""); //system.out.println(sayac.say()); int[] arr1= {1,4,5,7,3,2}; cocktailsort(arr1, 0); for(int i=0;i<arr1.length;i++) { system.out.println(arr1[i]); } } } package quiz1bil211nebiyanar; public class sayac { static string str1; public sayac(string str) { str1=str; } public static int say() { return say(str1); } public static int say(string str1) { if(str1.length()==0) return 0; else { if(str1.charat(0)=='1') return 1+ say(str1.substring(1)); else { return say(str1.substring(1)); } } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 package lab2bil211nebiyanar; import java.util.list; public class muzikcalar { private calmastratejisi strateji; public void setstrateji(calmastratejisi strateji) { this.strateji = strateji; } public void muzikcal(list<sarki> sarkilistesi) { if (strateji != null) { strateji.cal(sarkilistesi); } } } package lab2bil211nebiyanar; import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki) ((metalsarki) sarki).gostermetalozellikleri(); } } } package lab2bil211nebiyanar; public class klasiksarki extends sarki { public klasiksarki(string isim,string sanatci) { this.isim=isim; this.sanatci=sanatci; // todo auto-generated constructor stub } void oynat() { system.out.println(""[klasi̇k] -""+sanatci+"" -""+isim+"" - (hafif ve sakin)""); } } package lab2bil211nebiyanar; public class metalsarki extends sarki { string metalozellik; public metalsarki(string isim,string sanatci,string metalozellik) { this.isim=isim; this.sanatci=sanatci; this.metalozellik=metalozellik; // todo auto-generated constructor stub } void gostermetalozellikleri() { system.out.println(""[metal] -""+sanatci+"" -""+isim+"" ""+""[ozellik: ""+metalozellik+""]""); } void oynat() { system.out.println(""[metal] -""+sanatci+"" -""+isim+"" -""+""(""+metalozellik+"")""); } } package lab2bil211nebiyanar; public class rocksarki extends sarki { public rocksarki(string isim,string sanatci) { this.isim=isim; this.sanatci=sanatci; // todo auto-generated constructor stub } void oynat() { system.out.println(""[rock] -""+sanatci+"" -""+isim+"" -(huzurlu ve nostaljik)""); } } package lab2bil211nebiyanar; import java.util.arraylist; import java.util.collections; import java.util.list; public class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { list<sarki> karisikliste = new arraylist<>(sarkilistesi); collections.shuffle(karisikliste); for (int i=0;i<karisikliste.size();i++) { karisikliste.get(i).oynat(); } } } package lab2bil211nebiyanar; import java.util.list; public class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (int i=0;i<sarkilistesi.size();i++) { sarkilistesi.get(i).oynat(); } } } package lab2bil211nebiyanar; public abstract class sarki { string isim; string sanatci; abstract void oynat(); } package lab2bil211nebiyanar; import java.util.list; public class rockcuozelcalma implements calmastratejisi { public void cal(list <sarki> sarkilistesi) { boolean isrock=false; for(int i=0;i<sarkilistesi.size();i++) { if(sarkilistesi.get(i) instanceof rocksarki && !isrock) { system.out.println(""[bilgi] ses duzeyi̇ yuksek""); isrock=true; } else if(!(sarkilistesi.get(i) instanceof rocksarki && isrock)) { system.out.println(""[bilgi] ses duzeyi̇ normal""); isrock=false; } sarkilistesi.get(i).oynat(); } } } package lab2bil211nebiyanar; import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } kelime sayıcı bil 211 - lab 3 20 şubat 2025 1 giriş bu laboratuvarda fileioveexceptions kullanarak bir kelime sayıcı geliştireceğiz. kelime sayıcı , verilen birmetindosyasındakibelirlikelimelerinkaçkezgeçtiğinisayarakbirçıktıdosyasınakaydedecekvebelirlenen hata durumlarında uygun çıktılar oluşturacaktır. 2 genel program program, aşağıdaki sabit isimlere sahip iki giriş dosyası ile çalışacaktır: -kelimeler.txt – aranacak kelimeleri içeren dosya. -metin.txt – kelimelerin aranacağı metnin bulunduğu dosya. program, kelimeler.txt dosyasındaki her kelimenin metin.txt içinde kaç kez geçtiğini sayacak ve sonucu bir çıktı dosyasına kaydedecektir: -sonuc.txt – her kelimenin kaç kez geçtiğini içeren çıktı dosyası. dosyalar,programınçalıştırıldığıdizindebulunmalıdır. dosyaisimlerideğiştirilemez,programsadeceyukarıda belirtilen isimlerle çalışacaktır. eğerkelimeler.txt içinde bulunan herhangi bir kelime, metin.txt içinde hiç geçmiyorsa, program bir hata oluşturmalı ve stderr’e uygun bir mesaj yazmalıdır. 3 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları kullanacaktır (örn., bufferredreader, scanner, printwriter). dosyaları okurken ve yazarken kullanacağınız fileio sınıflarının seçimi size bırakılmıştır. i̇şlenmesi gereken dosyalar şunlardır: -kelimeler.txt dosyası okunmalıdır. -metin.txt dosyası okunmalıdır. -sonuc.txt dosyası oluşturulup yazılmalıdır. program,aşağıdakiolasıdosyahatalarınıoluşturmalıvehatalaroluştuğundastderr’ebelirlenenhatamesajlarını yazmalıdır: - dosyabulunamıyorsa: ""hata: kelimeler.txt bulunamadı."" veya""hata: metin.txt bulunamadı."" - dosya boşsa: ""hata: kelimeler.txt boş."" veya""hata: metin.txt boş."" 4 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program hata kodu ile çıkış yapmalıdır (yani mainmetodunuz bu hataları atarak sonlanmalı) ve hatalar stderr’e yazılmalıdır (programınızı hata atarak sonlandırırsanız java bunu kendisi yapacaktır). belirtilen hata mesajları ile birlikte java’nın hata ile sonlanan programlar için oluşturduğu sınıf, metod, ve satır gibi bilgiler bulunabilir. 1 4.1 girdi hataları (inputexception class) bu kategori, programın giriş dosyalarıyla ilgili karşılaşabileceği tüm hataları kapsar. öğrenciler, dosya işlem- leriyle ilgili hata türlerini inputexception sınıfından türetmelidir. aşağıdaki özel hata türleri tanımlanmalıdır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: [dosya adı] bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: [dosya adı] boş."" 4.2 kelime bulunamadı hatası (kelimebulunamadiexception class) eğerkelimeler.txt içinde bulunan en az bir kelime, metin.txt dosyasında hiç geçmiyorsa, program kelimebulunamadiexception hatasını atmalıdır. hata yalnızca kelimeler.txt dosyasında bulunamayan ilk kelime için atılır ve program sonlanır. bu hata oluştuğunda stderr’e şu mesaj yazılmalıdır: -""hata: [kelime] metinde bulunamadı."" bu hata, doğrudan exception sınıfından türetilecek ve inputexception ile bağlantılı olmayacaktır. 5 dosya formatları program üç farklı dosya ile çalışacaktır: kelimeler.txt (girdi),metin.txt (girdi) ve sonuc.txt (çıktı). bu dosyaların formatı aşağıda belirtilmiştir. 5.1 girdi dosyaları girdi dosyaları düz metin ( .txt) formatında olacaktır ve her biri aşağıdaki gibi yapılandırılmış olmalıdır. 5.1.1kelimeler.txt formatı kelimeler.txt dosyası, her satırda bir kelime olacak şekilde düzenlenmelidir. dosyada yalnızca harf karak- terleri bulunur. kelimeler büyük/küçük harf duyarsız olarak aranacaktır. örnek i̇çerik: elma armut üzüm eğer dosya boşsa, program şu hatayı vermelidir: hata: kelimeler.txt boş. 5.1.2metin.txt formatı metin.txt dosyası, içinde aranacak kelimelerin geçebileceği serbest formatlı bir metin içermelidir. dosya içinde noktalama işaretleri ve boşluklar bulunabilir. örnek i̇çerik: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. eğer dosya boşsa, program şu hatayı vermelidir: hata: metin.txt boş. 5.2 çıktı dosyası program, kelimelerin kaç kez geçtiğini gösteren bir çıktı dosyası ( sonuc.txt ) oluşturmalıdır. 2 5.2.1sonuc.txt formatı sonuc.txt dosyası, her satırda kelimenin adı ve kaç kez geçtiği bilgisi olacak şekilde düzenlenmelidir. format şu şekilde olmalıdır: [kelime] [geçme sayısı] kelime ve geçme sayısı arasında tek bir boşluk olmalıdır. örnek çıktı ( sonuc.txt ): elma 2 armut 2 üzüm 1 5.3 özel hata durumları ve çıktıları eğerkelimeler.txt içindekiherhangibirkelime metin.txt içindebulunamazsa, kelimebulunamadiexception hatası atılmalıdır ve stderr’e şu mesaj yazılmalıdır: hata: üzüm metinde bulunamadı. bu hata oluştuğunda, yine de sonuc.txt dosyası oluşturulmalı ve bulunan kelimeler için normal çıktı yazıl- malıdır. ancak bulunamayan kelimeler çıktı dosyasına eklenmemelidir. örnek durum: eğerkelimeler.txt şu şekildeyse: elma armut muz vemetin.txt şu şekildeyse: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. o zaman sonuc.txt şu şekilde olmalıdır: elma 2 armut 2 ve stderr’e şu mesaj yazılmalıdır: hata: muz metinde bulunamadı. 6 gönderim formatı - labı bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara şeklinde isimlendirin (örn., johnnash_181101014.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""lab3 gönderim"" başlıklı bir mail ile gönderin. 3 metot açıklama string(string s) sile aynı değere sahip bir string oluşturur. string(char[] a) a[]dizisindeki karakterlerle bir string oluşturur. int length() string içindeki karakter sayısını döndürür. char charat(int i) belirtilen iindeksindeki karakteri döndürür. string substring(int i, int j) iilej-1arasındaki karakterleri içeren bir alt string döndürür. boolean contains(string substring) string’in substring ’i içerip içermediğini kontrol eder. boolean startswith(string prefix) string’in prefixile başlayıp başlamadığını kontrol eder. boolean endswith(string postfix) string’in postfix ile bitip bitmediğini kontrol eder. int indexof(string pattern) pattern ifadesinin ilk geçtiği indeks değerini döndürür. int indexof(string pattern, int i) iindeksinden sonraki ilk pattern konumunu döndürür. string concat(string t) string’in sonuna teklenmiş halini döndürür. int compareto(string t) i̇ki string’i karşılaştırır (sözlük sırasına göre). string tolowercase() string’in tüm harflerini küçük harfe çevirir. string touppercase() string’in tüm harflerini büyük harfe çevirir. string replace(string a, string b) string içindeki a’larıbile değiştirir. string trim() string’in başındaki ve sonundaki boşlukları kaldırır. boolean matches(string regex) string’in belirtilen regexle eşleşip eşleşmediğini kontrol eder. string[] split(string delimiter) string’idelimiter kullanarak böler ve bir dizi döndürür. boolean equals(object t) string’in değeri tile aynı mı diye kontrol eder. table 1: java string sınıfı metotları 4 package lab3bil211nebiyanar; import java.io.file; import java.io.fileinputstream; import java.io.filenotfoundexception; import java.io.filewriter; import java.io.ioexception; import java.io.inputstream; import java.io.printwriter; import java.util.arraylist; import java.util.scanner; public class main { public static void main(string[] args) { try { dosyametodlari.kelimeoku(); dosyametodlari.kelimesay(); dosyametodlari.sonucyaz(); } catch (inputexception | kelimebulunamadiexception e) { // todo auto-generated catch block e.printstacktrace(); } } } package lab3bil211nebiyanar; public class kelimebulunamadiexception extends exception { public kelimebulunamadiexception(string kelime) { system.out.println(""hata ""+kelime+"" bulunamadi""); } } package lab3bil211nebiyanar; import java.lang.classfile.superclass; public class bosdosyaexception extends inputexception { public bosdosyaexception(string filename) { super(""hata: "" + filename + "" bos.""); } } package lab3bil211nebiyanar; import java.io.file; import java.io.filenotfoundexception; import java.io.filewriter; import java.io.ioexception; import java.io.printwriter; import java.util.arraylist; import java.util.scanner; public class dosyametodlari { static arraylist<string> aranankelimeler = new arraylist<>(); static arraylist<integer> kelimesayilari = new arraylist<>(); public static void kelimeoku() throws inputexception { file dosya = new file(""kelimeler.txt""); if (!dosya.exists()) throw new dosyabulunamadiexception(""kelimeler.txt""); try (scanner scanner = new scanner(dosya)) { if (!scanner.hasnext()) throw new bosdosyaexception(""kelimeler.txt""); while (scanner.hasnextline()) { string kelime = scanner.nextline().trim().tolowercase(); if (!kelime.isempty()) { aranankelimeler.add(kelime); kelimesayilari.add(0); } } } catch (filenotfoundexception e) { throw new dosyabulunamadiexception(""kelimeler.txt""); } } public static void kelimesay() throws inputexception, kelimebulunamadiexception { file dosya = new file(""metin.txt""); if (!dosya.exists()) throw new dosyabulunamadiexception(""metin.txt""); try (scanner scanner = new scanner(dosya)) { if (!scanner.hasnext()) throw new bosdosyaexception(""metin.txt""); while (scanner.hasnextline()) { string satir = scanner.nextline().tolowercase(); string removed=satir.replace(""\\p{punct}"",""""); string[] kelimeler = satir.split("" ""); for (string kelime : kelimeler) { for (int i = 0; i < aranankelimeler.size(); i++) { if (aranankelimeler.get(i).equals(kelime)) { kelimesayilari.set(i, kelimesayilari.get(i) + 1); } } } } } catch (filenotfoundexception e) { throw new dosyabulunamadiexception(""metin.txt""); } for (int i = 0; i < aranankelimeler.size(); i++) { if (kelimesayilari.get(i) == 0) { throw new kelimebulunamadiexception(aranankelimeler.get(i)); } } } public static void sonucyaz() { try (printwriter writer = new printwriter(new filewriter(""sonuc.txt""))) { for (int i = 0; i < aranankelimeler.size(); i++) { if (kelimesayilari.get(i) > 0) { writer.println(aranankelimeler.get(i) + "" "" + kelimesayilari.get(i)); } } } catch (ioexception e) { system.err.println(""hata: sonuc.txt dosyasına yazılamadı.""); } } } package lab3bil211nebiyanar; public class inputexception extends exception { public inputexception(string message) { super(message); } } package lab3bil211nebiyanar; public class dosyabulunamadiexception extends inputexception { public dosyabulunamadiexception(string filename) { super(""hata: "" + filename + "" bulunamadı.""); } } generic 1) envanter yönetim sistemi bu labda amacımı bir oyun için envanter sistemi eklemektir. item isminde bir arayüz tanımlayın: aşağıdaki metotları içermelidir: string getname() int getvalue() weapon sınıfı tanımlayın. bu sınıf item arayüzünü uygulamalıdır. int damage isimli bir özelliği olmalıdır. armor sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. int defense isimli bir değişkeni olmalıdır. potion sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. string effect isimli bir değişkeni olmalıdır. generic inventory<t> sınıfı bir arraylist kullanarak nesneleri saklamalıdır. void additem(t item): envantere istenilen eşyayı eklemeli void removeitem(t item): envanterden istenilen eşyayı silmeli void printinventory(): envanteri basmalı t mostvaluableitem(): en değerli eşyayı dönmeli t finditembyname(string name): verilen isme karşılık gelen eşyayı dönmeli. i̇simlerin unique olduğunu varsayabilirsiniz. eğer yoksa null dönün. list<t> finditemsbyvalue(int value): verilen değerden daha değerli eşyaarın listesini döndürür. int gettotalvalue(): envanterin toplam değerini döner. list<t> filterbytype(class<?> type): istenilen sınıfa ait ögeleri döner. int gettotalweapondamage(): weapon classına ait olan nesnelerin toplam hasarınıdöner. void sortbyvalue(): değeri azalan şekilde envanteri sıralamalıdır. public static void printmostvaluableitem(inventory<? extends item> inventory): verilen envanterdem en değerli eşayı ekrana basmalıdır. public static void transferarmor(inventory<? super armor> destination, inventory<armor> source): verilen hedef envantere zırhı taşımalıdır. driver class: main metodu burada olmalıdır. sadece weapon’dan oluşan ve itemdan oluşan invertory classı yazıp test ediniz. yardımcı olabilecek metotlar: class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon package lab4nebiyanarbil211; import java.util.arraylist; import java.util.list; public class inventory<t extends item> { private arraylist<t> items = new arraylist<>(); public void additem(t item) { items.add(item); } public void removeitem(t item) { items.remove(item); } public void printinventory() { for (t item : items) { system.out.println(item.getname() + "" - değer: "" + item.getvalue()); } } public t mostvaluableitem(){ int maxind=0; int i=0; int max=-99; for (t item : items) { if(item.getvalue()>max) { max=item.getvalue(); maxind=i; } i++; } return items.get(maxind); } public t finditembyname(string name) { for (t item : items) { if(item.getname().equals(name)) { return item; } } return null; } list<t> finditemsbyvalue(int value){ arraylist<t>mynewlist=new arraylist<t>(); for(t item:items) { if(item.getvalue()>value); mynewlist.addlast(item); } return mynewlist; } int gettotalvalue() { int sum=0; for(t item:items) { sum+=item.getvalue(); } return sum; } public list<t> filterbytype(class<?> type) { list<t> filtereditems = new arraylist<>(); for (t item : items) { if ((type == weapon.class && item instanceof weapon) || (type == armor.class && item instanceof armor) || (type == potion.class && item instanceof potion)) { filtereditems.add(item); } } return filtereditems; } int gettotalweapondamage() { int sum=0; for(t item:items) { if(item instanceof weapon) { sum+=((weapon) item).getdamage(); } } return sum; } public void sortbyvalue() { int n = items.size(); for (int i = 0; i < n - 1; i++) { for (int j = 0; j < n - i - 1; j++) { if (items.get(j).getvalue() < items.get(j + 1).getvalue()) { t temp = items.get(j); items.set(j, items.get(j + 1)); items.set(j + 1, temp); } } } } public static void printmostvaluableitem(inventory<? extends item> inventory) { item item = inventory.mostvaluableitem(); if (item != null) { system.out.println(""en değerli eşya: "" + item.getname() + "" - değer: "" + item.getvalue()); } } public static void transferarmor(inventory<? super armor> destination,inventory<armor> source) { for (armor armor : new arraylist<>(source.items)) { destination.additem(armor); source.removeitem(armor); } } } package lab4nebiyanarbil211; public class weapon implements item { private string name; private int value; private int damage; public weapon(string name, int value, int damage) { this.name = name; this.value = value; this.damage = damage; } @override public string getname() { // todo auto-generated method stub return name; } public int getvalue() { // todo auto-generated method stub return value; } public int getdamage() { return damage; } } package lab4nebiyanarbil211; public interface item { string getname(); int getvalue(); } package lab4nebiyanarbil211; public class armor implements item { private string name; private int value; private int defense; public armor(string name, int value, int defense) { this.name = name; this.value = value; this.defense = defense; } public int getdefense() { return defense; } @override public string getname() { return name; } @override public int getvalue() { return value; } } package lab4nebiyanarbil211; public class potion implements item { private string effect; private string name; private int value; public potion(string name,int value,string effect) { this.value=value; this.name=name; this.effect=effect; } public string getname() { // todo auto-generated method stub return name; } @override public int getvalue() { // todo auto-generated method stub return value; } public string geteffect() { return effect; } } package lab4nebiyanarbil211; import java.util.arraylist; import java.util.list; public class driver { public static void main(string[] args) { inventory<item> generalinventory = new inventory<>(); inventory<weapon> weaponinventory = new inventory<>(); weapon sword = new weapon(""silah1"", 1000, 100); armor shield = new armor(""kalkan1"", 800, 50); potion potion = new potion(""i̇ksir1"", 300, ""can artışı oldu""); weapon shotgunweapon = new weapon(""sawed-off"", 2000, 1905); weapon taramaliweapon=new weapon(""m4a1"", 550, 770); generalinventory.additem(sword); generalinventory.additem(shield); generalinventory.additem(potion); generalinventory.additem(shotgunweapon); generalinventory.additem(taramaliweapon); weaponinventory.additem(sword); weaponinventory.additem(shotgunweapon); weaponinventory.additem(taramaliweapon); generalinventory.printinventory(); system.out.println(""en degerli item: "" + generalinventory.mostvaluableitem().getname()); inventory.printmostvaluableitem(generalinventory); list<item> weapons = generalinventory.filterbytype(weapon.class); system.out.println(""filtrelenmiş silahlar:""); for (item item : weapons) { system.out.println(item.getname() + "" - deger: "" + item.getvalue()); } } } bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true package q1bil211nebiyanar; public class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public robot() { this.name=""wall-e""; this.type=""trash""; this.batterylevel=100; this.isoperational=true; } public robot(string name,string type,int batterylevel) { this.name=name; this.type=type; this.batterylevel=batterylevel; if(this.batterylevel>0) { this.isoperational=true; } else { this.isoperational=false; } } public string getname() { return name; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public boolean isoperational() { return isoperational; } public void setoperational(boolean isoperational) { this.isoperational = isoperational; } public void charge() { this.batterylevel=100; } public void printrobot() { system.out.println(string.format(""robot name:%s robot type:%s trash battery level:"" + ""%d isoperational:%b"",name,type,batterylevel,isoperational)); } } package q1bil211nebiyanar; public class main { public static void main(string[] args) { factory factory=new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } package q1bil211nebiyanar; import java.security.permission; public class soru1 { public static void perm(string str,int index) { system.out.println(str); if(str.length()-1==index) { } else { if((str.charat(index)>=65&&str.charat(index)<=90)) { index++; perm(str.substring(0, index+1).tolowercase()+str.substring(index+1),index); } else if(str.charat(index)>=48 && str.charat(index)<=57) { index++; perm(str.substring(0, index+1).touppercase()+str.substring(index+1),index); } } } public static void main(string[] args) { perm(""a1b"", 0); } } package q1bil211nebiyanar; import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory() { this.name=""factory1""; this.location=""moon""; this.robots=arraylist <robot>(); } public factory(string name,string location) { this.name=name; this.location=location; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getlocation() { return location; } public void setlocation(string location) { this.location = location; } public arraylist<robot> getrobots() { return robots; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public void addrobot(robot robots1) { robots.addlast(robots1); } public void chargeallrobots() { for(int i=0;i<robots.size();i++) { robots.get(i).setbatterylevel(100); } } public void printfactory() { system.out.println(""factory name:""+name+"" location:""+location); for(int i=0;i<robots.size();i++) { robots.get(i).printrobot(); } } public void works() { for(int i=0;i<robots.size();i++) { robots.get(i).setbatterylevel(robots.get(i).getbatterylevel()-15); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 package q2bil211nebiyanar; public interface withbattery { int getbatterylife(); void recharge(); } package q2bil211nebiyanar; public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; int maxbattery; public abstractrobot(string modelname,int batterylife) { this.modelname=modelname; this.batterylife=batterylife; this.maxbattery=batterylife; } public string getmodelname() { return modelname; } public void recharge() { if(maxbattery<100) { this.batterylife=100; } else { this.batterylife=maxbattery; } } public int getbatterylife() { return batterylife; } public abstract void performtask(); } package q2bil211nebiyanar; public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.totalrobotproduced(); } } package q2bil211nebiyanar; public class securityrobot extends abstractrobot { private boolean isarmed; public securityrobot(string modelname,int batterylife,boolean isarmed) { super(modelname, batterylife); this.isarmed=isarmed; } public void performtask() { if(batterylife<10) { system.out.println(""[""+modelname+""] not enough battery to scan threads""); } else { system.out.println(""[""+modelname+""]"" + ""scanning for threads... armed:""+isarmed); batterylife-=10; } } public void tooglearmedmode() { if(isarmed) { isarmed=false; system.out.println(""securityrobot - ""+this.modelname+ "" is now unarmed""); } else { isarmed=true; system.out.println(""securityrobot - ""+this.modelname+ "" is now unarmed""); } } public boolean isarmed() { return isarmed; } public void setarmed(boolean isarmed) { this.isarmed = isarmed; } } package q2bil211nebiyanar; public class cleaningrobot extends abstractrobot { private int cleaningpower; public cleaningrobot(string modelname,int batterylife,int cleaningpower) { super(modelname, batterylife); this.cleaningpower=cleaningpower; } public int getcleaningpower() { return cleaningpower; } public void setcleaningpower(int cleaningpower) { this.cleaningpower = cleaningpower; } public void performtask() { if(batterylife<10) { system.out.println(""[""+modelname+""] not enough battery to clean""); } else { system.out.println(""[""+modelname+""] cleaning in progress .. cleaning power:""+cleaningpower); batterylife-=10; } } public void boostcleaningpower(int miktar) { this.cleaningpower+=miktar; system.out.println(""cleaningrobot - ""+this.modelname+"" now has cleaning power:""+this.cleaningpower); } } package q2bil211nebiyanar; import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots=new arraylist<abstractrobot>(); static int n=0; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); n++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); n++; } public void performalltasks() { for(int i=0;i<robots.size();i++) { robots.get(i).performtask(); } } public void displayrobots() { for(int i=0;i<robots.size();i++) { if(robots.get(i) instanceof cleaningrobot) { cleaningrobot r1=(cleaningrobot) robots.get(i); system.out.println(""cleaningrobot - model: ""+r1.getmodelname() +"", battery:""+r1.getbatterylife()+"", cleaning power:""+r1.getcleaningpower()); } else if(robots.get(i) instanceof securityrobot) { securityrobot r1=(securityrobot) robots.get(i); system.out.println(""securityrobot - model: ""+r1.getmodelname() +"", battery:""+r1.getbatterylife()+"", armed:""+r1.isarmed()); } } } public void upgradecleaningrobots(int miktar) { for(int i=0;i<robots.size();i++) { if(robots.get(i) instanceof cleaningrobot) { cleaningrobot r1=(cleaningrobot) robots.get(i); r1.boostcleaningpower( miktar); } } } public void togglesecurityrobotsmode() { for(int i=0;i<robots.size();i++) { if(robots.get(i) instanceof securityrobot) { securityrobot r1=(securityrobot) robots.get(i); r1.tooglearmedmode(); } } } public static void totalrobotproduced() { system.out.println(""tum fabrikalar tarafından ""+n+"" robot uretildi""); } } bil211 quiz 4 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: undoablelist<t> adında bir sınıf oluşturun. bu sınıf, bir arraylist'i genişletmeli ve aşağıdaki ek özelliklere sahip olmalıdır: ● undolast() metodu, en son eklenen öğeyi kaldırmalıdır. ● getlastadded() → son eklenen öğeyi listeyi değiştirmeden döndürür. ● eğer liste boşsa, undolast() bir hata vermemeli, sadece hiçbir şey yapmamalıdır. örnek kullanım: undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] q2: aşağıdaki generic metodu tamamlayın. ● verilen bir collection<t> içinde minimum veya maksimum öğeyi bulan bir metod yazın. ● boolean parametresi true ise maksimumu, false ise minimumu döndürmelidir. ● t öğeleri comparable<t> arabirimini uygulamalıdır. public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { // metodu tamamlayın } örnek kullanım: list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) q3: belirli türdeki elemanları filtreleme ● bir collection<?> içindeki belirli bir türdeki öğeleri filtreleyen bir generic metod yazın. ● class<t> tür filtresi olarak kullanılmalıdır. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { // metodu tamamlayın } örnek kullanım: list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] package q4bil211nebiyanar; import java.util.arraylist; import java.util.collection; import java.util.list; public class q3 { public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { list<t> filteredlist = new arraylist<>(); for (object myobj : collection) { if (type.isinstance(myobj)) { filteredlist.add((t) myobj); } } return filteredlist; } } package q4bil211nebiyanar; import java.util.collection; import java.util.iterator; public class q2 { public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { if (collection == null || collection.isempty()) { return null; } t extreme = null; for (t element : collection) { if (extreme == null) { extreme = element; } else { int compare = element.compareto(extreme); if (findmax && compare > 0) { extreme = element; } else if (!findmax && compare < 0) { extreme = element; } } } return extreme; } } package q4bil211nebiyanar; import java.util.arrays; import java.util.list; public class test { public static void main(string[] args) { // todo auto-generated method stub undoablelist<string> list = new undoablelist<>(); //q1 list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] system.out.println(""""); //q2 list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(q2.findextreme(numbers, true)); system.out.println(q2.findextreme(numbers, false)); system.out.println(""""); // q3 list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(q3.filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(q3.filterbytype(mixed, integer.class)); // çıktı: [1, 3] } } package q4bil211nebiyanar; import java.util.arraylist; //q1 public class undoablelist<t> extends arraylist<t> { public void undolast() { if(!this.isempty()) { this.remove(this.size()-1); //size-1 son indekse ulaş } } public t getlastadded() { if(!this.isempty()) { return this.get(this.size()-1); } return null; } } 10 kuş bakışı atış oyunu (top-down shooter) bil 211 - proje teslim tarihi: 27 mart 2025 23:59 1 amaç bu ödevde amacınız, java swing kullanarak kuş bakışı bir atış oyunu (top-down shooter) tasarlamaktır. oyunda, yönettiğimiz karakterin üzerine dalga dalga gelen çeşitli zombileri fare ile hedef alarak farklı silahlar kullanıp öldürmemiz gerekmektedir. karakterimiz öldüğünde oyun sona erecektir. her dalga başına ve öldürülen zombi başına kazanılan puan artacaktır. dalgalar ilerledikçe gelen zombilerin sayısı ve çeşitleri artarak zorluk seviyesi yükselecektir. 2 gereksinimler oyun derste öğrendiğiniz oop ilkelerine uygun sınıf/arayüz tasarımları ile geliştirilmelidir. - zorluk seviyesi arttıkça zombi sayısı ve çeşitliliği artmalıdır. - oyun duraklatılabilmeli ve kaydedilip tekrar yüklenilebilmelidir (fileio kullanılmalıdır). - sol üst köşede seçili silah ve kalan mermi miktarı gösterilmelidir. - sağ üst köşede oyuncunun canı ve toplam puanı gösterilmelidir. - oyunun duraklatılması, kaydedilmesi ve devam ettirilmesi için bir menü bulunmalıdır. 3 silahlar oyunda farklı silahlar bulunmaktadır. belirli zombi dalgaları temizlendikten sonra oyun ödül olarak yeni bir silahverecektir. hersilahınkendineözgübirçalışmamekanizmasıvardır. silahlarınşarjörkapasitesisınırlıdır ve şarjördeki mermiler bittiğinde tekrar doldurulmadan ateş edilemez. toplam mermi sayısı oyuncunun o silaha ait elinde ne kadar mermi olduğunu gösterir. r tuşuna basarak şarjör yeniden doldurulabilir. 3.1 tabanca - şarjör kapasitesi: 12 mermi - ateş hızı: 120 mermi/dakika - elde etme: oyuncu oyuna bu silahla başlar. - özellik: düz atış yapar, sapma yoktur. sınırsız yedek şarjör (diğer tüm silahlar için yedek şarjör ve mermiler rastgele bir şekilde dalga sırasında ve sonlarında zombilerden düşer). 3.2 piyade tüfeği - şarjör kapasitesi: 30 mermi - ateş hızı: 600 mermi/dakika - elde etme: 1. dalga tamamlandıktan sonra - özellik: düzatışyaparancak30derecesapmasıvardır. sapmaaçısı, karakterinbaktığıyöndemerminin her iki dönme yönüne de saçılabileceği maksimum açıdır. 1 3.3 pompalı tüfek - şarjör kapasitesi: 5 mermi - ateş hızı: 60 mermi/dakika - elde etme: 3. dalga tamamlandıktan sonra - özellik: her atış 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi atar (yani karakter merkezli mermi hız vektörleri arasında 5 derece açı olmalıdır). 3.4 keskin nişancı tüfeği - şarjör kapasitesi: 5 mermi - ateş hızı: 30 mermi/dakika - elde etme: 5. dalga tamamlandıktan sonra - özellik: mermileri zombileri delip arasındaki zombilere de hasar verir. 3.5 roketatar - şarjör kapasitesi: 1 roket - ateş hızı: 10 roket/dakika - elde etme: 10. dalga tamamlandıktan sonra - özellik: patlama etkisiyle birden fazla zombiye zarar verir. 4 zombiler zombiler oyundaki düşman tipleridir. zombiler oyuncuya doğru ilerlerler ve eğer oyuncuya temas ederlerse oyuncuya hasar verirler. zorluk seviyesi arttıkça zombilerin sayısı ve çeşitliliği artmaktadır. zombi tipleri birbirinden renk ya da şekil olarak ayırt edilebilmelidir. 4.1 normal zombi - can: orta - hız: yavaş - hasar: orta 4.2 sürünge zombi - can: düşük - hız: hızlı - hasar: orta - özellik: oyuncunun yakınına geldiğinde zıplar. 4.3 tank zombi - can: yüksek - hız: çok yavaş - hasar: yüksek 2 4.4 asit tüküren zombi - can: düşük - hız: yavaş - hasar: orta (uzaktan asit tükürebilir) - özellik: öldürüldüğünde yanındaki birimlere zarar verir. 5 rapor ve teslim formatı - oyun, oopprensiplerineuygunolaraktasarlanmalıvesınıfdiyagramları, arayüztasarımıfinalraporda sunulmalıdır. - oyun test edilerek ekran görüntüleri rapora eklenmelidir. - rapor pdf formatında olmalı ve ismi proje_rapor.pdf olmalıdır. - oyunun mainfonksiyonu gameisimli bir sınıf içinde bulunmalıdır ( java game komutuyla çalışmalı). - kaynak kodun tamamı source.zip (uzantı 7z, rar, tar.gz de olabilir) şeklinde sıkıştırılmış olmalıdır. - sıkıştırılmış kaynak kod ve rapor uzak sistemine yüklenmelidir. 6 yardımcı kaynaklar dahaöncehiçkuşbakışıatışoyunuoynamadıysanızaşağıdakioyunlarıreferansolarakalabilirsiniz. buradaki oyunlarıngrafikleriilemekaniklerisizdenbeklenendenfarklıolsadaharitatasarımı, karakterhareketi,kamera hareketi, ateş etme mekanikleri ve zombilerin yapay zekası ile ilgili temel fikirler edinebilirsiniz. - little top-down shooter: https://www.youtube.com/watch?v=pj3m3fu3i5a - super c - stage 2: https://www.youtube.com/watch?v=os2t_v5suj4 - neon chrome: https://www.youtube.com/watch?v=puhw1bevtro 3 /** * */ /** * */ module assignment { requires java.desktop; } package game; import java.awt.rectangle; public class sniper extends gun { public sniper() { super(5, 30, 0); this.reloadperbullet=500; } @override public void fire(float x, float y, float angle, handler handler) { if (!canfire()) return; bullet piercingbullet = new bullet(x, y, id.bullet, handler) { private float damage = 100f; private java.util.set<zombie> hitzombies = new java.util.hashset<>(); @override public void tick() { x += velx; y += vely; for (gameobject obj : new java.util.linkedlist<>(handler.object)) { if (obj instanceof zombie zombie && !hitzombies.contains(zombie)) { if (getbounds().intersects(zombie.getbounds())) { zombie.health -= damage; hitzombies.add(zombie); if (zombie.health <= 0) { handler.removeobject(zombie); game.killedzombies++; } damage *= 0.5f; if (damage < 10) { handler.removeobject(this); break; } } } } } @override public rectangle getbounds() { return new rectangle((int)x, (int)y, 8, 8); } }; piercingbullet.velx = (float)(15 * math.cos(angle)); piercingbullet.vely = (float)(15 * math.sin(angle)); handler.addobject(piercingbullet); currentammo--; lastfiredtime = system.currenttimemillis(); } } package game; import java.awt.color; import java.awt.graphics; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; //entityler olusturulmadan once test i̇ci̇n kullani̇lan bir class public class box extends gameobject { private player player; private camera cam; private bufferedimage zombieimage; public box(float x, float y, id id,camera cam,player player) { super(x, y, id); this.maxhealth = 100; this.health = maxhealth; this.cam=cam; this.player=player; try { file file = new file(""src/game/zomb.png""); // yol doğru olmalı zombieimage = imageio.read(file); system.out.println(""zombi resmi yüklendi!""); } catch (ioexception e) { system.out.println(""zombi resmi yüklenemedi!""); e.printstacktrace(); } } @override public void tick() { float dx = player.getx() - x; float dy = player.gety() - y; float distance = (float)math.sqrt(dx*dx + dy*dy); if (distance != 0) { float speed = 1.0f; // zombi hızı velx = (dx / distance) * speed; vely = (dy / distance) * speed; } x += velx; y += vely; // harita dışına çıkmasın x = math.max(0, math.min(x, cam.getworldwidth() - 32)); y = math.max(0, math.min(y, cam.getworldheight() - 32)); } @override public void render(graphics g) { if (zombieimage != null) { g.drawimage(zombieimage, (int)x, (int)y, 32, 32, null); } else { g.setcolor(color.red); g.fillrect((int)x, (int)y, 32, 32); } renderhealthbar(g, 32); } public rectangle getbounds() { return new rectangle((int)x, (int)y, 32, 32); } } package game; import java.awt.graphics; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; public abstract class zombie extends gameobject { protected player player; protected camera cam; protected bufferedimage image; protected int damage; public zombie(float x, float y, id id, camera cam, player player) { super(x, y, id); this.player = player; this.cam = cam; } @override public void render(graphics g) { if (image != null) { g.drawimage(image, (int) x, (int) y, 32, 32, null); } else { g.fillrect((int) x, (int) y, 32, 32); } renderhealthbar(g, 32); } @override public rectangle getbounds() { return new rectangle((int) x, (int) y, 44, 44); } public rectangle getattackbounds() { return new rectangle((int) x + 16, (int) y + 16, 16, 16); } protected void followplayer(float speed) { float dx = player.getx() - x; float dy = player.gety() - y; float distance = (float) math.sqrt(dx * dx + dy * dy); if (distance == 0) return; float dirx = dx / distance; float diry = dy / distance; float tryx = x + dirx * speed; float tryy = y + diry * speed; rectangle testbounds = new rectangle((int) tryx, (int) tryy, 32, 32); tilemanager tm = game.instance.gethandler().gettilemanager(); if (tm == null) return; //nullsa hata atmadan returnla if (!tm.hascollision(testbounds)) { x = tryx; y = tryy; return; } tryx = x + dirx * speed; testbounds = new rectangle((int) tryx, (int) y, 32, 32); if (!tm.hascollision(testbounds)) { x = tryx; return; } tryy = y + diry * speed; testbounds = new rectangle((int) x, (int) tryy, 32, 32); if (!tm.hascollision(testbounds)) { y = tryy; } } } package game; public enum difficulty { easy, medium, hard, test } package game; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; import java.awt.rectangle; import java.awt.graphics; import java.awt.image.bufferedimage; public class acidzombie extends zombie { private long lastspittime = 0; private long spitcooldown = 2000; // 2 saniye private float spitrange = 200f; private bufferedimage acidimage; public acidzombie(float x, float y, camera cam, player player) { super(x, y, id.zombie, cam, player); this.maxhealth = 50; this.health = maxhealth; this.damage = 30; try { image = imageio.read(new file(""src/game/zomb1.1.png"")); acidimage = imageio.read(new file(""src/game/acid.png"")); } catch (ioexception e) { system.out.println(""asit zombi veya asit resmi yüklenemedi!""); } } @override public void tick() { float dx = player.getx() + 16 - x; float dy = player.gety() + 16 - y; followplayer(0.8f); // yavaş hareket // asit tükür long now = system.currenttimemillis(); float distance = (float) math.sqrt(dx * dx + dy * dy); if (distance <= spitrange && now - lastspittime > spitcooldown) { float angle = (float) math.atan2(dy, dx); shootacid(angle); lastspittime = now; } if (this.health <= 0) { system.out.println(""zombi oldu""); explodenearby(); cam.gethandler().removeobject(this); // zombiyi kaldır game.killedzombies++; } } private void shootacid(float angle) { bullet acid = new bullet(x, y, id.bullet, cam.gethandler()) { @override public void tick() { x += velx; y += vely; if (getbounds().intersects(player.getbounds())) { player.takedamage(15); cam.gethandler().removeobject(this); } } @override public void render(graphics g) { if (acidimage != null) { g.drawimage(acidimage, (int)x, (int)y, 10, 10, null); } } @override public rectangle getbounds() { return new rectangle((int)x, (int)y, 10, 10); } }; acid.velx = (float) (6 * math.cos(angle)); acid.vely = (float) (6 * math.sin(angle)); cam.gethandler().addobject(acid); } private void explodenearby() { system.out.println(""[asit zombi] patladı! yakındakilere hasar veriliyor...""); handler h = cam.gethandler(); system.out.println(""[asit zombi] patladı! yakındaki objelere hasar veriliyor...""); //yakındaki zombi hasarı for (gameobject obj : new java.util.linkedlist<>(h.object)) { double dist = math.hypot(obj.getx() - x, obj.gety() - y); if (dist < 50) { if (obj instanceof zombie z && obj != this) { z.health -= 80; if (z.health <= 0) { h.removeobject(z); game.killedzombies++; } } else if (obj instanceof box box) { box.health -= 20; } } } } } package game; public abstract class gun { protected int magazinesize; protected int currentammo; protected int reserveammo; protected int firerate; // mermi/dk protected long lastfiredtime = 0; protected boolean isreloading = false; protected long reloadstarttime = 0; protected long reloadduration = 2000; // 2 sn protected int reloadperbullet = 300; // 0.3 sn public void setcurrentammo(int ammo) { this.currentammo = ammo; } public void setreserveammo(int ammo) { this.reserveammo = ammo; } public boolean isreloading() { return isreloading; } public float getreloadprogress() { if (!isreloading) return 0; return math.min(1f, (system.currenttimemillis() - reloadstarttime) / (float)reloadduration); } public gun(int magazinesize, int firerate, int reserveammo) { this.magazinesize = magazinesize; this.firerate = firerate; this.reserveammo = reserveammo; this.currentammo = magazinesize; } public void addammo(int amount) { reserveammo += amount; } public boolean canfire() { long currenttime = system.currenttimemillis(); return currentammo > 0 && currenttime - lastfiredtime >= (60000 / firerate) && !isreloading; } public void reload() { if (currentammo == magazinesize || reserveammo == 0 || isreloading) return; int needed = magazinesize - currentammo; int toreload = math.min(needed, reserveammo); isreloading = true; reloadstarttime = system.currenttimemillis(); reloadduration = math.min(toreload * reloadperbullet, 2500); } public void cancelreload() { isreloading = false; reloadstarttime = 0; reloadduration = 0; } public void completereload() { int needed = magazinesize - currentammo; int toreload = math.min(needed, reserveammo); currentammo += toreload; reserveammo -= toreload; isreloading = false; } public abstract void fire(float x, float y, float angle, handler handler); public int getcurrentammo() { return currentammo; } public int getreserveammo() { return reserveammo; } } package game; import java.awt.color; import java.awt.graphics; import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; public class bullet extends gameobject { private handler handler; private static bufferedimage bulletimage; static { try { bulletimage = imageio.read(new file(""src/game/bullet.png"")); } catch (ioexception e) { system.out.println(""bullet görseli yüklenemedi!""); } } public bullet(float x, float y, id id, handler handler) { super(x, y, id); this.handler = handler; } @override public void tick() { x += velx; y += vely; for (int i = 0; i < handler.object.size(); i++) { gameobject obj = handler.object.get(i); if (obj instanceof zombie zombie) { if (getbounds().intersects(zombie.getbounds())) { zombie.health -= 25; //system.out.println("">> mermi zombiye çarptı: "" + zombie.getclass().getsimplename() + "" | yeni can: "" + zombie.health); if (zombie.health <= 0) { if (zombie instanceof acidzombie) { } else { handler.removeobject(zombie); game.killedzombies++; if (zombie instanceof normalzombie) game.score += 10; else if (zombie instanceof tankzombie) game.score += 30; else if (zombie instanceof crawlerzombie) game.score += 15; if (game.player != null) { player p = game.player; java.util.list<gun> availableguns = new java.util.arraylist<>(); if (p.rifle != null) availableguns.add(p.rifle); if (p.shotgun != null) availableguns.add(p.shotgun); if (p.sniper != null) availableguns.add(p.sniper); if (p.rocketlauncher != null) availableguns.add(p.rocketlauncher); if (!availableguns.isempty()) { gun selectedgun = availableguns.get(new java.util.random().nextint(availableguns.size())); if (selectedgun instanceof rifle) selectedgun.addammo(10); else if (selectedgun instanceof shotgun) selectedgun.addammo(2); else if (selectedgun instanceof sniper) selectedgun.addammo(1); else if (selectedgun instanceof rocketlauncher) selectedgun.addammo(1); system.out.println(selectedgun.getclass().getsimplename() + "" için mermi düştü!""); } } } } handler.removeobject(this); break; } } } } @override public void render(graphics g) { if (bulletimage != null) { graphics2d g2d = (graphics2d) g.create(); int drawx = (int) x; int drawy = (int) y; int w = 24, h = 24; float centerx = drawx + w / 2f; float centery = drawy + h / 2f; //açı hesap algoritması double angle = math.atan2(vely, velx); g2d.rotate(angle, centerx, centery); g2d.drawimage(bulletimage, drawx, drawy, w, h, null); g2d.dispose(); } else { g.setcolor(color.yellow); g.fillrect((int)x, (int)y, 8, 8); } } @override public rectangle getbounds() { return new rectangle((int)x-2, (int)y-2, 12, 12); } } package game; import java.awt.color; import java.awt.graphics; import java.awt.rectangle; public class shotgun extends gun { public shotgun() { super(5, 60, 0); // şarjör: 5, ateş hızı: 60, yedek: 25 mermi this.reloadperbullet=400; } @override public void fire(float x, float y, float angle, handler handler) { if (!canfire()) return; int pelletcount = 9; float spread = (float) math.toradians(45); // 9x5 45 derece dagil float startangle = angle - spread / 2; for (int i = 0; i < pelletcount; i++) { float pelletangle = startangle + i * (spread / (pelletcount - 1)); bullet pellet = new bullet(x, y, id.bullet, handler) { private final float startx = x; private final float starty = y; @override public void tick() { x += velx; y += vely; for (gameobject obj : new java.util.linkedlist<>(handler.object)) { if (obj instanceof zombie zombie) { if (getbounds().intersects(zombie.getbounds())) { float dx = x - startx; float dy = y - starty; float distance = (float) math.sqrt(dx * dx + dy * dy); //mesafeye göre logaritmik hasar algoritmasi float basedamage = 50f; float mindamage = 5f; float logfactor = (float) math.log(distance + 2); float actualdamage = math.max(mindamage, basedamage / (0.5f + logfactor)); zombie.health -= actualdamage; if (zombie.health <= 0) { handler.removeobject(zombie); game.killedzombies++; } handler.removeobject(this); break; } } } } @override public void render(graphics g) { g.setcolor(new color(139, 69, 19)); g.fillrect((int) x, (int) y, 4, 4); } @override public rectangle getbounds() { return new rectangle((int) x, (int) y, 4, 4); } }; pellet.velx = (float) (10 * math.cos(pelletangle)); pellet.vely = (float) (10 * math.sin(pelletangle)); handler.addobject(pellet); } currentammo--; lastfiredtime = system.currenttimemillis(); } } package game; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; public class normalzombie extends zombie { public normalzombie(float x, float y, camera cam, player player) { super(x, y, id.zombie, cam, player); this.maxhealth = 100; this.health = maxhealth; this.damage = 30; try { image = imageio.read(new file(""src/game/zomb1.3.png"")); } catch (ioexception e) { system.out.println(""normal zombi resmi yüklenemedi!""); } } @override public void tick() { float dx = player.getx() + 16 - x; float dy = player.gety() + 16 - y; followplayer(1.0f); // yavaş } } package game; public enum id { player(), zombie(), block(), bullet(), particle(); } package game; import java.awt.event.keyadapter; import java.awt.event.keyevent; public class keyinput extends keyadapter { private player player; public boolean keys[] = new boolean[4]; // d, a, w, s public void setplayer(player player) { this.player = player; } @override public void keypressed(keyevent e) { int key = e.getkeycode(); // kontrol için system.out.println(""tuş basıldı: "" + key); // save alma if (key == keyevent.vk_m) { game.instance.savegame(); game.instance.showsavemenu = true; game.instance.savemenustarttime = system.currenttimemillis(); // system.out.println(""m başarili""); return; } // f music kapa aç if (key == keyevent.vk_f) { game.instance.musicon = !game.instance.musicon; if (game.instance.backgroundmusic != null) { if (game.instance.musicon) { game.instance.backgroundmusic.start(); // system.out.println(""music acildi); } else { game.instance.backgroundmusic.stop(); //system.out.println("" music kapandi""); } } return; } // heal menü // heal menü if (game.openhealthmenu) { if (player == null) return; switch (key) { case keyevent.vk_k -> { if ((game.score - game.spentscore) >= 100 && player.gethealth() < player.getmaxhealth()) { player.heal(20); game.spentscore += 100; } } case keyevent.vk_l -> { if ((game.score - game.spentscore) >= 250) { player.increasemaxhealth(20); game.spentscore += 250; } } case keyevent.vk_u -> { if ((game.score - game.spentscore) >= 150 && player.gethealth() < player.getmaxhealth()) { player.heal(player.getmaxhealth() - player.gethealth()); game.spentscore += 150; } } case keyevent.vk_o -> { game.openhealthmenu = false; game.instance.togglepause(); } } return; } // movement if (key == keyevent.vk_d) keys[0] = true; if (key == keyevent.vk_a) keys[1] = true; if (key == keyevent.vk_w) keys[2] = true; if (key == keyevent.vk_s) keys[3] = true; // silah degisimi ve reload if (player != null) { switch (key) { case keyevent.vk_1 -> player.setcurrentgun(player.pistol); case keyevent.vk_2 -> { if (player.rifle != null) player.setcurrentgun(player.rifle); } case keyevent.vk_3 -> { if (player.shotgun != null) player.setcurrentgun(player.shotgun); } case keyevent.vk_4 -> { if (player.sniper != null) player.setcurrentgun(player.sniper); } case keyevent.vk_5 -> { if (player.rocketlauncher != null) player.setcurrentgun(player.rocketlauncher); } case keyevent.vk_r -> { gun gun = player.getcurrentgun(); if (gun.isreloading()) { gun.cancelreload(); // system.out.println("" reload iptal ""); } else { gun.reload(); //system.out.println("" reload başladı.""); } } case keyevent.vk_h -> { game.openhealthmenu = true; game.instance.togglepause(); //system.out.println(""health menu acildi""); } } } } @override public void keyreleased(keyevent e) { int key = e.getkeycode(); if (key == keyevent.vk_d) keys[0] = false; if (key == keyevent.vk_a) keys[1] = false; if (key == keyevent.vk_w) keys[2] = false; if (key == keyevent.vk_s) keys[3] = false; } } package game; public class pistol extends gun { public pistol() { super(12, 120, integer.max_value); // sınırsız yedek şarjör this.reloadperbullet=150; } @override public void fire(float x, float y, float angle, handler handler) { if (!canfire()) return; bullet bullet = new bullet(x, y, id.bullet,handler); bullet.velx = (float) (10 * math.cos(angle)); bullet.vely = (float) (10 * math.sin(angle)); handler.addobject(bullet); currentammo--; lastfiredtime = system.currenttimemillis(); } } package game; import java.awt.graphics; import java.awt.rectangle; import java.util.linkedlist; public class handler { public linkedlist<gameobject> object = new linkedlist<>(); private tilemanager tilemanager; public void settilemanager(tilemanager tilemanager) { this.tilemanager = tilemanager; } public tilemanager gettilemanager() { return tilemanager; } public void tick() { for (int i = 0; i < object.size(); i++) { gameobject obj = object.get(i); obj.tick(); // collision checkliyoruz burda ve aşşağılarda if (tilemanager != null && obj.getid() != id.bullet) { if (tilemanager.hascollision(obj.getbounds())) { //algoritma obj.setx(obj.getx() - obj.velx); obj.sety(obj.gety() - obj.vely); obj.velx = 0; obj.vely = 0; } } } } public int zombiecount() { int count = 0; for (gameobject obj : object) { if (obj instanceof zombie) count++; } return count; } public void render(graphics g) { for (int i = 0; i < object.size(); i++) { object.get(i).render(g); } for (int i = 0; i < object.size(); i++) { gameobject obj = object.get(i); if (obj.getid() == id.bullet) { rectangle bulletbounds = obj.getbounds(); for (int j = 0; j < object.size(); j++) { gameobject obj2 = object.get(j); if (obj2.getid() == id.block) { rectangle boxbounds = obj2.getbounds(); if (bulletbounds.intersects(boxbounds)) { box box = (box) obj2; box.health -= 50; removeobject(obj); if (box.health <= 0) { removeobject(box); game.killedboxes++; } break; } } } if (tilemanager != null && tilemanager.hascollision(bulletbounds)) { removeobject(obj); } } } } public gameobject addobject(gameobject tempobject) { object.add(tempobject); return tempobject; } public void removeobject(gameobject tempobject) { object.remove(tempobject); } } package game; import java.util.random; public class rifle extends gun { private random rand = new random(); public rifle() { super(30, 600, 0); // 30 elde 600 hızında this.reloadperbullet=100; } @override public void fire(float x, float y, float angle, handler handler) { if (!canfire()) return; float deviation = (float) math.toradians(rand.nextfloat() * 30 - 15); float finalangle = angle + deviation; bullet bullet = new bullet(x, y, id.bullet,handler); bullet.velx = (float) (10 * math.cos(finalangle)); bullet.vely = (float) (10 * math.sin(finalangle)); handler.addobject(bullet); currentammo--; lastfiredtime = system.currenttimemillis(); } } package game; import java.awt.color; import java.awt.graphics; import java.awt.graphics2d; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; public class crawlerzombie extends zombie { private boolean leaped = false; private float angle = 0; //radyan public crawlerzombie(float x, float y, camera cam, player player) { super(x, y, id.zombie, cam, player); this.maxhealth = 60; this.health = maxhealth; this.damage = 30; try { image = imageio.read(new file(""src/game/crawl zombie.png"")); } catch (ioexception e) { system.out.println(""sürünge zombi resmi yüklenemedi!""); } } @override public void render(graphics g) { if (image != null) { graphics2d g2d = (graphics2d) g.create(); float dx = player.getx() - x; float dy = player.gety() - y; int drawx = (int) x; int drawy = (int) y; int width = 32; int height = 32; if (math.abs(dx) > math.abs(dy)) { if (dx > 0) { //sağ g2d.drawimage(image, drawx, drawy, width, height, null); } else { // sol g2d.drawimage(image, drawx + width, drawy, -width, height, null); } } else { if (dy > 0) { // aşağı g2d.rotate(math.pi / 2, drawx + width / 2.0, drawy + height / 2.0); g2d.drawimage(image, drawx, drawy, width, height, null); } else { // yukarı g2d.rotate(-math.pi / 2, drawx + width / 2.0, drawy + height / 2.0); g2d.drawimage(image, drawx, drawy, width, height, null); } } g2d.dispose(); } else { g.setcolor(color.green); g.fillrect((int) x, (int) y, 32, 32); } renderhealthbar(g, 32); } @override public void tick() { float dx = player.getx() + 16 - x; float dy = player.gety() + 16 - y; float distance = (float)math.sqrt(dx * dx + dy * dy); // eğer 1.5 tile (48px) veya daha yakınsa ve henüz atlamadıysa if (distance <= 48 && !leaped) { //jump özelliği yazıldı //system.out.println(""atladi""); float boost = 6.0f; // zıplama hızı jump için velx = dx / distance * boost; vely = dy / distance * boost; x += velx; y += vely; leaped = true; } else { followplayer(2.0f); // normal hiz } } } package game; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; public class tankzombie extends zombie { public tankzombie(float x, float y, camera cam, player player) { super(x, y, id.zombie, cam, player); this.maxhealth = 300; this.health = maxhealth; this.damage = 60; try { image = imageio.read(new file(""src/game/zomb1.4.png"")); } catch (ioexception e) { system.out.println(""tank zombi resmi yüklenemedi!""); } } @override public void tick() { float dx = player.getx() + 16 - x; float dy = player.gety() + 16 - y; followplayer(0.5f); // çok yavaş } } package game; import java.awt.canvas; import javax.sound.sampled.*; import java.awt.color; import java.awt.font; import java.awt.graphics; import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferstrategy; import java.awt.image.bufferedimage; import java.io.*; import javax.imageio.imageio; public class game extends canvas implements runnable { public final static int width = 800; public final static int height = 600; string title = ""after the apocalypse""; static protected int killedboxes = 0; public static int killedzombies = 0; public static int score = 0; public static boolean gameover = false; private int frames = 0; private int fps = 0; public static difficulty difficulty = difficulty.medium; public static boolean openhealthmenu = false; public static game instance; private boolean bonusgiven = false; private tilemanager tilemanager; private bufferedimage menubackground, startbuttonimg, exitbuttonimg, musicbuttonimg,loadbuttonimg; rectangle startbutton; rectangle exitbutton; rectangle musicbutton; rectangle loadbutton; public boolean musicon = true; public clip backgroundmusic; public boolean showdifficultymenu = false; public rectangle easybutton = new rectangle(300, 240, 200, 40); public rectangle mediumbutton = new rectangle(300, 300, 200, 40); public rectangle hardbutton = new rectangle(300, 360, 200, 40); public rectangle testbutton = new rectangle(300, 420, 200, 40); // yeni test butonu public static int spentscore = 0; public boolean gamestarted = false; public boolean isloadinggame = false; public boolean openescapemenu = false; public boolean showsavemenu = false; long savemenustarttime = 0; private thread thread; private boolean isrunning = false; private keyinput input; private mouseinput minput; private handler handler; camera cam; public static player player; private bufferedimage backgroundimage; private boolean ispaused = false; private int currentwave = 1; private long wavestarttime = system.currenttimemillis(); private boolean waveinprogress = false; private long wavedelay = 2000; private long lastwavetime = 0; private boolean showwavetext = false; public boolean openmainmenu = false; public rectangle savebuttonrect = new rectangle(300, 250, 200, 40); public rectangle loadbuttonrect = new rectangle(300, 310, 200, 40); public game() { new window(width, height, title, this); instance=this; init(); start(); } public handler gethandler() { return handler; } public void startgame() { gamestarted = true; showdifficultymenu = false; openmainmenu = false; ispaused = false; gameover = false; init(); } public void initmusic() { try { audioinputstream audiostream = audiosystem.getaudioinputstream(new file(""src/game/backgroundmus.wav"")); backgroundmusic = audiosystem.getclip(); backgroundmusic.open(audiostream); backgroundmusic.loop(clip.loop_continuously); floatcontrol gaincontrol = (floatcontrol) backgroundmusic.getcontrol(floatcontrol.type.master_gain); gaincontrol.setvalue(1); } catch (exception e) { e.printstacktrace(); } } private void init() { if (!isloadinggame) { killedzombies = 0; score = (difficulty == difficulty.test) ? 500 : 0; currentwave = 1; bonusgiven = false; } isloadinggame = false; if (musicon && backgroundmusic == null) { try { audioinputstream audiostream = audiosystem.getaudioinputstream(new file(""src/game/backgroundmus.wav"")); backgroundmusic = audiosystem.getclip(); backgroundmusic.open(audiostream); backgroundmusic.loop(clip.loop_continuously); floatcontrol gaincontrol = (floatcontrol) backgroundmusic.getcontrol(floatcontrol.type.master_gain); gaincontrol.setvalue(1); } catch (exception e) { e.printstacktrace(); } } try { menubackground = imageio.read(new file(""src/game/anaekran.png"")); startbuttonimg = imageio.read(new file(""src/game/startgame.png"")); exitbuttonimg = imageio.read(new file(""src/game/exit.png"")); musicbuttonimg = imageio.read(new file(""src/game/music.png"")); loadbuttonimg = imageio.read(new file(""src/game/loadgame.png"")); } catch (ioexception e) { e.printstacktrace(); } startbutton = new rectangle(300, 220, 200, 30); loadbutton = new rectangle(300, 270, 200, 30); musicbutton = new rectangle(300, 320, 200, 30); exitbutton = new rectangle(300, 370, 200, 30); if (!gamestarted) { openmainmenu = true; } try { file file = new file(""src/game/bckg2.jpg""); backgroundimage = imageio.read(file); system.out.println(""arka plan yüklendi!""); } catch (ioexception e) { e.printstacktrace(); } handler = new handler(); tilemanager = new tilemanager(); handler.settilemanager(tilemanager); input = new keyinput(); for (var l : this.getkeylisteners()) this.removekeylistener(l); this.addkeylistener(input); cam = new camera(0, 0, handler, backgroundimage); minput = new mouseinput(handler, cam); for (var l : this.getmouselisteners()) this.removemouselistener(l); this.addmouselistener(minput); float spawnx = 300, spawny = 300; while (tilemanager.hascollision(new rectangle((int)spawnx, (int)spawny, 32, 32))) { spawnx += 32; // bloklarda sıkışmaması için } player = new player(spawnx, spawny, id.player, input, handler, cam); game.player = player; input.setplayer(player); handler.addobject(player); minput.findplayer(); } private synchronized void start() { if (isrunning) return; thread = new thread(this); thread.start(); isrunning = true; } private synchronized void stop() { try { if (backgroundmusic != null) backgroundmusic.stop(); thread.join(); } catch (interruptedexception e) { e.printstacktrace(); } isrunning = false; } public void run() { this.setfocusable(true); this.requestfocus(); this.requestfocus(); long lasttime = system.nanotime(); double amountofticks = 60.0; double ns = 1000000000 / amountofticks; double delta = 0; long timer = system.currenttimemillis(); while (isrunning) { long now = system.nanotime(); delta += (now - lasttime) / ns; lasttime = now; while (delta >= 1) { tick(); delta--; } render(); frames++; if (system.currenttimemillis() - timer > 1000) { timer += 1000; fps = frames; frames = 0; } } stop(); } public void togglemainmenu() { if (showdifficultymenu) return; openmainmenu = !openmainmenu; ispaused = openmainmenu; } private void tick() { if (gameover) return; if (openmainmenu || openescapemenu) return; if (showsavemenu && system.currenttimemillis() - savemenustarttime > 2000) { showsavemenu = false; // 2 saniye sonra kapat } if (ispaused || gameover) return; handler.tick(); cam.tick(); minput.tick(); gun gun = player.getcurrentgun(); if (gun.isreloading() && system.currenttimemillis() - gun.reloadstarttime >= gun.reloadduration) { gun.completereload(); } if (player.gethealth() <= 0) { gameover = true; return; } if (currentwave <= 12 && getremainingzombies() == 0 && !waveinprogress) { if (!bonusgiven && currentwave > 1) { int bonus = 75+(currentwave - 1) * 50; game.score += bonus; system.out.println((currentwave - 1) + "". dalga tamamlandı! +"" + bonus + "" skor.""); bonusgiven = true; } spawnwave(currentwave); if (currentwave == 2) player.unlockrifle(); if (currentwave == 4) player.unlockshotgun(); if (currentwave == 6) player.unlocksniper(); if (currentwave == 11) player.unlockrocketlauncher(); showwavetext = true; currentwave++; waveinprogress = true; wavestarttime = system.currenttimemillis(); } if (currentwave > 12 && getremainingzombies() == 0 && !waveinprogress) { gameover = true; system.out.println(""tüm dalgalar tamamlandı!""); } if (system.currenttimemillis() - wavestarttime > wavedelay) { waveinprogress = false; showwavetext = false; } } private int getremainingzombies() { int count = 0; for (gameobject obj : handler.object) { if (obj instanceof zombie) { count++; } } return count; } private void spawnwave(int wave) { int totalzombies; switch (difficulty) { case easy -> totalzombies = (wave <= 10) ? 2 : 4; case medium -> totalzombies = 3 + wave * 2; case hard -> totalzombies = (int) ((3 + wave * 2) * 1.5); case test -> totalzombies = (wave < 12) ? 1 : 4; default -> totalzombies = 3 + wave * 2; } for (int i = 0; i < totalzombies; i++) { float x = 0, y = 0; rectangle zombiebox; int attempts = 0; // en fazla 10 deneme yeterli olacaktır daha iyi olsun istersek arttırırız do { x = (float) (math.random() * cam.getworldwidth()); y = (float) (math.random() * cam.getworldheight()); zombiebox = new rectangle((int)x, (int)y, 32, 32); attempts++; } while ( (math.hypot(player.getx() - x, player.gety() - y) < 100 || tilemanager.hascollision(zombiebox) || !tilemanager.isspawnable(zombiebox)) && attempts < 10 ); // uygun değilse kaydır if (tilemanager.hascollision(zombiebox)) { int[] dx = {0, 32, -32, 0, 0}; int[] dy = {0, 0, 0, -32, 32}; for (int j = 0; j < dx.length; j++) { float newx = x + dx[j]; float newy = y + dy[j]; rectangle tryrect = new rectangle((int)newx, (int)newy, 32, 32); if (!tilemanager.hascollision(tryrect)) { x = newx; y = newy; break; } } } zombie z = (difficulty == difficulty.test && wave == 12) ? switch (i) { case 0 -> new normalzombie(x, y, cam, player); case 1 -> new tankzombie(x, y, cam, player); case 2 -> new crawlerzombie(x, y, cam, player); case 3 -> new acidzombie(x, y, cam, player); default -> new normalzombie(x, y, cam, player); } : switch (i % 4) { case 0 -> new normalzombie(x, y, cam, player); case 1 -> new tankzombie(x, y, cam, player); case 2 -> new crawlerzombie(x, y, cam, player); case 3 -> new acidzombie(x, y, cam, player); default -> new normalzombie(x, y, cam, player); }; handler.addobject(z); } waveinprogress = false; lastwavetime = system.currenttimemillis(); } private void render() { bufferstrategy bs = this.getbufferstrategy(); if (bs == null) { this.createbufferstrategy(3); return; } graphics g = bs.getdrawgraphics(); graphics2d g2d = (graphics2d) g; // giriş arayüzü if (!gamestarted && openmainmenu && !showdifficultymenu) { if (menubackground != null) g.drawimage(menubackground, 0, 0, game.width, game.height, null); else { g.setcolor(color.black); g.fillrect(0, 0, game.width, game.height); } if (startbuttonimg != null) g.drawimage(startbuttonimg, startbutton.x, startbutton.y, startbutton.width, startbutton.height, null); if (exitbuttonimg != null) g.drawimage(exitbuttonimg, exitbutton.x, exitbutton.y, exitbutton.width, exitbutton.height, null); if (musicbuttonimg != null) g.drawimage(musicbuttonimg, musicbutton.x, musicbutton.y, musicbutton.width, musicbutton.height, null); if (loadbuttonimg != null) g.drawimage(loadbuttonimg, loadbutton.x, loadbutton.y, loadbutton.width, loadbutton.height, null); g.dispose(); bs.show(); return; } if (showdifficultymenu) { g.setcolor(new color(0, 0, 0, 180)); g.fillrect(100, 100, 600, 400); g.setcolor(color.white); g.setfont(new font(""arial"", font.bold, 32)); g.drawstring(""zorluk seç"", 310, 160); g.setfont(new font(""arial"", font.plain, 20)); g.drawrect(easybutton.x, easybutton.y, easybutton.width, easybutton.height); g.drawstring(""kolay"", easybutton.x + 70, easybutton.y + 25); g.drawrect(mediumbutton.x, mediumbutton.y, mediumbutton.width, mediumbutton.height); g.drawstring(""orta"", mediumbutton.x + 75, mediumbutton.y + 25); g.drawrect(hardbutton.x, hardbutton.y, hardbutton.width, hardbutton.height); g.drawstring(""zor"", hardbutton.x + 80, hardbutton.y + 25); g.drawrect(testbutton.x, testbutton.y, testbutton.width, testbutton.height); g.drawstring(""test"", testbutton.x + 75, testbutton.y + 25); g.dispose(); bs.show(); return; } // oyun g2d.translate(-cam.getx(), -cam.gety()); if (tilemanager != null) tilemanager.render(g2d); handler.render(g2d); g2d.translate(cam.getx(), cam.gety()); g.setcolor(color.white); g.setfont(new font(""arial"", font.bold, 16)); string controlstext = ""h: health menu | m: save""; int texttwidth = g.getfontmetrics().stringwidth(controlstext); g.drawstring(controlstext, (game.width - texttwidth) / 2 + 20, 20); string musictext = ""f: music on/off""; int musictextwidth = g.getfontmetrics().stringwidth(musictext); g.drawstring(musictext, (game.width - musictextwidth) / 2 + 20, 40); string biltext = ""nebi̇ yanar 231301037""; int biltextwidth = g.getfontmetrics().stringwidth(biltext); g.drawstring(biltext, (game.width - biltextwidth) / 2 + 20, 55); // üst yazılar g.setcolor(color.white); g.setfont(new font(""arial"", font.bold, 20)); g.drawstring(""killed zombies: "" + killedzombies, game.width - 190, 20); int netscore = score - spentscore; g.drawstring(""score: "" + netscore + ""/"" + score, game.width - 190, 40); gun gun = player.getcurrentgun(); g.drawstring(""weapon: "" + gun.getclass().getsimplename(), 15, 20); g.drawstring(""ammo: "" + gun.getcurrentammo() + ""/"" + gun.getreserveammo(), 15, 40); g.setcolor(color.red); g.fillrect(10, 50, player.gethealth() * 2, 20); g.setcolor(color.white); g.setfont(new font(""arial"", font.bold, 15)); g.drawstring(""health: "" + player.gethealth(), 15, 65); if (gun.isreloading()) { int radius = 12; int centerx = (int) (player.getx() - cam.getx() + 16); int centery = (int) (player.gety() - cam.gety() + 16); g.setcolor(color.white); g.drawoval(centerx - radius, centery - radius, radius * 2, radius * 2); float progress = gun.getreloadprogress(); //geçiş algoritması(r -> g) int red = (int) (255 * (1 - progress)); int green = (int) (255 * progress); g.setcolor(new color(red, green, 0)); g.fillarc(centerx - radius, centery - radius, radius * 2, radius * 2, 90, -(int) (360 * progress)); } if (showwavetext && currentwave > 1 && currentwave <= 13) { g.setfont(new font(""arial"", font.bold, 40)); g.setcolor(color.yellow); string text = (currentwave - 1) + "". dalga""; int textwidth = g.getfontmetrics().stringwidth(text); g.drawstring(text, game.width / 2 - textwidth / 2, game.height / 2 - 100); } // heal menu if (openhealthmenu) { g.setcolor(new color(0, 0, 0, 180)); g.fillrect(100, 100, 600, 400); g.setcolor(color.white); g.setfont(new font(""arial"", font.bold, 24)); g.drawstring(""sağlik menüsü"", 310, 140); g.setfont(new font(""arial"", font.plain, 20)); g.drawstring(""[k] 100 skor → +20 can"", 240, 200); g.drawstring(""[l] 250 skor → +20 max can && anlık +20 regen "", 240, 240); g.drawstring(""[u] 150 skor → full can (regen)"", 240, 280); g.drawstring(""[o] menüden çık"", 240, 320); } // m ile save if (showsavemenu) { g.setcolor(new color(0, 0, 0, 180)); g.fillrect(250, 200, 300, 150); g.setcolor(color.white); g.setfont(new font(""arial"", font.bold, 24)); g.drawstring(""oyun kaydedildi!"", 290, 260); g.setfont(new font(""arial"", font.plain, 16)); g.drawstring(""save alindi"", 270, 300); } // oyunun iki türlü bitmesi if (gameover) { g.setcolor(color.black); g.setfont(new font(""arial"", font.bold, 50)); if (player.gethealth() <= 0) g.drawstring(""you died!"", game.width / 2 - 130, game.height / 2); else g.drawstring(""tüm dalgalar tamamlandi!"", game.width / 2 - 390, game.height / 2); } // fps g.setcolor(color.green); g.setfont(new font(""arial"", font.plain, 14)); g.drawstring(""fps: "" + fps, game.width - 100, 70); g.dispose(); bs.show(); } public void togglepause() { ispaused = !ispaused; system.out.println(""pause durumu: "" + (ispaused ? ""durduruldu"" : ""devam ediyor"")); } public void savegame() { try { filewriter writer = new filewriter(""savegame.txt""); // dosyaya zombi player ve gun infoları yaz tekrar okuyacağız writer.write(""player,"" + player.getx() + "","" + player.gety() + "","" + player.gethealth() + "","" + player.getmaxhealth() + "","" + killedzombies + "","" + score + "","" + spentscore + "","" + currentwave + "","" + (player.rifle != null) + "","" + (player.shotgun != null) + "","" + (player.sniper != null) + "","" + (player.rocketlauncher != null) + "","" + (player.rifle != null ? player.rifle.getcurrentammo() : -1) + "","" + (player.rifle != null ? player.rifle.getreserveammo() : -1) + "","" + (player.shotgun != null ? player.shotgun.getcurrentammo() : -1) + "","" + (player.shotgun != null ? player.shotgun.getreserveammo() : -1) + "","" + (player.sniper != null ? player.sniper.getcurrentammo() : -1) + "","" + (player.sniper != null ? player.sniper.getreserveammo() : -1) + "","" + (player.rocketlauncher != null ? player.rocketlauncher.getcurrentammo() : -1) + "","" + (player.rocketlauncher != null ? player.rocketlauncher.getreserveammo() : -1) + "","" + player.pistol.getcurrentammo() + "","" + player.pistol.getreserveammo() + "","" + game.difficulty.name() + ""\n""); for (gameobject obj : handler.object) { if (obj instanceof zombie zombie) { writer.write(""zombie,"" + zombie.getclass().getsimplename() + "","" + zombie.getx() + "","" + zombie.gety() + "","" + zombie.health + ""\n""); } } writer.close(); system.out.println(""oyun başarıyla kaydedildi!""); } catch (ioexception e) { e.printstacktrace(); } } public void loadgame() { isloadinggame = true; try { bufferedreader reader = new bufferedreader(new filereader(""savegame.txt"")); string line; handler = new handler(); tilemanager = new tilemanager(); handler.settilemanager(tilemanager); input = new keyinput(); for (var l : this.getkeylisteners()) this.removekeylistener(l); this.addkeylistener(input); cam = new camera(0, 0, handler, backgroundimage); minput = new mouseinput(handler, cam); this.minput = minput; for (var l : this.getmouselisteners()) this.removemouselistener(l); this.addmouselistener(minput); minput.findplayer(); player = new player(0, 0, id.player, input, handler, cam); game.player = player; input.setplayer(player); minput.findplayer(); handler.addobject(player); while ((line = reader.readline()) != null) { string[] data = line.split("",""); if (data[0].equals(""player"")) { float savedx = float.parsefloat(data[1]); float savedy = float.parsefloat(data[2]); int savedhealth = integer.parseint(data[3]); int savedmaxhealth = integer.parseint(data[4]); killedzombies = integer.parseint(data[5]); if (data.length >= 24) { //zorluga gelcek try { game.difficulty = difficulty.valueof(data[23]); system.out.println(""yüklenen zorluk seviyesi: "" + game.difficulty); } catch (exception ex) { system.out.println(""zorluk seviyesi okunamadı, varsayılan medium kullanılacak.""); game.difficulty = difficulty.medium; } } score = integer.parseint(data[6]); spentscore = (data.length >= 24) ? integer.parseint(data[7]) : 0; currentwave = integer.parseint(data[8]); player.setx(savedx); player.sety(savedy); rectangle checkrect = new rectangle((int) savedx, (int) savedy, 32, 32); tilemanager tilemanager = handler.gettilemanager(); // stuck kalcak şekilde doğduysa kaydır if (tilemanager != null && tilemanager.hascollision(checkrect)) { boolean found = false; int[] dx = {0, 32, -32, 0, 0}; // sağ, sol, yukarı, aşağı int[] dy = {0, 0, 0, -32, 32}; for (int i = 0; i < dx.length; i++) { float newx = savedx + dx[i]; float newy = savedy + dy[i]; rectangle tryrect = new rectangle((int) newx, (int) newy, 32, 32); if (!tilemanager.hascollision(tryrect)) { player.setx(newx); player.sety(newy); found = true; break; } } } player.setmaxhealth(savedmaxhealth); player.takedamage(player.gethealth() - savedhealth); player.pistol.setcurrentammo(integer.parseint(data[21])); player.pistol.setreserveammo(integer.parseint(data[22])); // silahlar boolean hasrifle = boolean.parseboolean(data[9]); boolean hasshotgun = boolean.parseboolean(data[10]); boolean hassniper = boolean.parseboolean(data[11]); boolean hasrocket = boolean.parseboolean(data[12]); if (hasrifle) { player.unlockrifle(); player.rifle.setcurrentammo(integer.parseint(data[13])); player.rifle.setreserveammo(integer.parseint(data[14])); } if (hasshotgun) { player.unlockshotgun(); player.shotgun.setcurrentammo(integer.parseint(data[15])); player.shotgun.setreserveammo(integer.parseint(data[16])); } if (hassniper) { player.unlocksniper(); player.sniper.setcurrentammo(integer.parseint(data[17])); player.sniper.setreserveammo(integer.parseint(data[18])); } if (hasrocket) { player.unlockrocketlauncher(); player.rocketlauncher.setcurrentammo(integer.parseint(data[19])); player.rocketlauncher.setreserveammo(integer.parseint(data[20])); } } else if (data[0].equals(""zombie"")) { string type = data[1]; float x = float.parsefloat(data[2]); float y = float.parsefloat(data[3]); int health = integer.parseint(data[4]); rectangle zombierect = new rectangle((int)x, (int)y, 32, 32); tilemanager tilemanager = handler.gettilemanager(); // 10 kez dene daha iyi olsun istersek arttırırız int attempts = 0; while ((tilemanager.hascollision(zombierect) || !tilemanager.isspawnable(zombierect)) && attempts < 10) { x = (float) (math.random() * cam.getworldwidth()); y = (float) (math.random() * cam.getworldheight()); zombierect = new rectangle((int)x, (int)y, 32, 32); attempts++; } // yukardaki playerin aynisi if (tilemanager.hascollision(zombierect)) { int[] dx = {0, 32, -32, 0, 0}; int[] dy = {0, 0, 0, -32, 32}; for (int i = 0; i < dx.length; i++) { float newx = x + dx[i]; float newy = y + dy[i]; rectangle tryrect = new rectangle((int)newx, (int)newy, 32, 32); if (!tilemanager.hascollision(tryrect)) { x = newx; y = newy; break; } } } zombie z = switch (type) { case ""normalzombie"" -> new normalzombie(x, y, cam, player); case ""tankzombie"" -> new tankzombie(x, y, cam, player); case ""crawlerzombie"" -> new crawlerzombie(x, y, cam, player); case ""acidzombie"" -> new acidzombie(x, y, cam, player); default -> null; }; if (z != null) { z.health = health; handler.addobject(z); } } } reader.close(); gamestarted = true; openmainmenu = false; showdifficultymenu = false; ispaused = false; system.out.println(""kayıtlı oyun yüklendi!""); } catch (ioexception e) { system.out.println(""kayıtlı oyun bulunamadı!""); } minput.findplayer(); } public static void main(string[] args) { new game(); } } package game; import java.awt.point; import java.awt.mouseinfo; import java.awt.event.mouseadapter; import java.awt.event.mouseevent; public class mouseinput extends mouseadapter { private handler handler; private camera cam; private gameobject tempplayer = null; private boolean shooting = false; public mouseinput(handler handler, camera cam) { this.handler = handler; this.cam = cam; } public void findplayer() { for (int i = 0; i < handler.object.size(); i++) { if (handler.object.get(i).getid() == id.player) { tempplayer = handler.object.get(i); break; } } } @override public void mousepressed(mouseevent e) { shooting = true; int mx = e.getx(); int my = e.gety(); point click = new point(mx, my); // === ana menü === if (game.instance.openmainmenu) { if (game.instance.startbutton.contains(click)) { game.instance.openmainmenu = false; game.instance.showdifficultymenu = true; } else if (game.instance.loadbutton.contains(click)) { game.instance.loadgame(); } else if (game.instance.exitbutton.contains(click)) { system.exit(0); } else if (game.instance.musicbutton.contains(click)) { game.instance.musicon = !game.instance.musicon; if (game.instance.musicon) { if (game.instance.backgroundmusic != null) { game.instance.backgroundmusic.start(); } else { game.instance.initmusic(); } } else { if (game.instance.backgroundmusic != null) { game.instance.backgroundmusic.stop(); } } } return; } // difficulty sec if (game.instance.showdifficultymenu) { if (game.instance.easybutton.contains(click)) { game.difficulty = difficulty.easy; game.instance.startgame(); } else if (game.instance.mediumbutton.contains(click)) { game.difficulty = difficulty.medium; game.instance.startgame(); } else if (game.instance.hardbutton.contains(click)) { game.difficulty = difficulty.hard; game.instance.startgame(); } else if (game.instance.testbutton.contains(click)) { game.difficulty = difficulty.test; game.instance.startgame(); } return; } } @override public void mousereleased(mouseevent e) { shooting = false; } public void tick() { if (tempplayer == null) findplayer(); if (!shooting || tempplayer == null) return; player p = (player) tempplayer; gun gun = p.getcurrentgun(); if (gun.isreloading()) { gun.cancelreload(); // önce reload'u iptal et } if (gun.canfire()) { try { point mousepos = mouseinfo.getpointerinfo().getlocation(); point gamepos = game.instance.getlocationonscreen(); int mx = mousepos.x - gamepos.x; int my = mousepos.y - gamepos.y; float[] guntip = p.getguntipposition(); float dx = mx - (guntip[0] - cam.getx()); float dy = my - (guntip[1] - cam.gety()); float angle = (float) math.atan2(dy, dx); gun.fire(guntip[0], guntip[1], angle, handler); } catch (exception e) { } } } } package game; import java.awt.image.bufferedimage; public class camera { private float x, y; private handler handler; private gameobject tempplayer = null; private int worldwidth, worldheight; public handler gethandler() { return handler; } public int getworldwidth() { return worldwidth; } public int getworldheight() { return worldheight; } public camera(float x, float y, handler handler, bufferedimage backgroundimage) { this.x = x; this.y = y; this.handler = handler; findplayer(); this.worldwidth = tilemanager.width * tilemanager.tile_size; this.worldheight = tilemanager.height * tilemanager.tile_size; } public void findplayer() { for (int i = 0; i < handler.object.size(); i++) { if (handler.object.get(i).getid() == id.player) { tempplayer = handler.object.get(i); break; } } } public void tick() { if (tempplayer != null) { float newx = tempplayer.getx() - game.width / 2 + 16; float newy = tempplayer.gety() - game.height / 2 + 16; x += (newx - x) * 0.1; y += (newy - y) * 0.1; } else { findplayer(); } //camera limitleri x = clamp(x, worldwidth - game.width, 0); y = clamp(y, worldheight - game.height + tilemanager.tile_size, 0); } public int getx() { return (int) x; } public int gety() { return (int) y; } private float clamp(float value, float max, float min) { if (value < min) return min; if (value > max) return max; return value; } } package game; import java.awt.color; import java.awt.graphics; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; public class rocketlauncher extends gun { private static bufferedimage rocketimage; //static yaptık her seferde olusturmasin diye static { try { rocketimage = imageio.read(new file(""src/game/rocketlauncherbullet.png"")); } catch (ioexception e) { system.out.println(""rocket bullet görseli yüklenemedi!""); } } public rocketlauncher() { super(1, 10, 0); // 1 roket, 10 hızında, 3 yedek this.reloadperbullet=1000; } @override public void fire(float x, float y, float angle, handler handler) { if (!canfire()) return; bullet rocket = new bullet(x, y, id.bullet,handler) { @override public void tick() { x += velx; y += vely; //collision baktık for (gameobject obj : handler.object) { if (obj.getid() == id.zombie) { if (getbounds().intersects(obj.getbounds())) { explode(); handler.removeobject(this); break; } } } } private void explode() { for (gameobject obj : new java.util.linkedlist<>(handler.object)) { if (obj instanceof zombie zomb) { double dist = math.hypot(zomb.getx() - x, zomb.gety() - y); if (dist < 70) { zomb.health -= 150; if (zomb.health <= 0) { handler.removeobject(zomb); game.killedzombies++; } } } } } @override public void render(graphics g) { if (rocketimage != null) { g.drawimage(rocketimage, (int) x, (int) y, 12, 12, null); } else { g.setcolor(java.awt.color.orange); g.fillrect((int) x, (int) y, 12, 12); } } @override public rectangle getbounds() { return new rectangle((int)x, (int)y, 12, 12); } }; rocket.velx = (float) (7 * math.cos(angle)); rocket.vely = (float) (7 * math.sin(angle)); handler.addobject(rocket); currentammo--; lastfiredtime = system.currenttimemillis(); } } package game; import java.awt.*; import java.awt.image.bufferedimage; import javax.imageio.imageio; import java.io.file; import java.io.ioexception; import java.util.hashset; import java.util.random; import java.util.set; public class tilemanager { public static final int tile_size = 32; public static final int width = 40; public static final int height = 30; private tile[][] tiles = new tile[width][height]; private set<point> occupied = new hashset<>(); public enum tiletype { grass(""grass.png"", false), bush(""bush.png"", false), tree(""tree.png"", true), haybale(""haybale.png"", true), // mapte çok collision alan olacagi icin brick(""brick.png"", true), // kullanilmadi stone(""stone.png"", true), lava(""lava.png"", false), water(""water.png"", false); public final string filename; public final boolean hascollision; tiletype(string filename, boolean hascollision) { this.filename = filename; this.hascollision = hascollision; } } public static class tile { tiletype type; bufferedimage image; tile(tiletype type) { this.type = type; try { image = imageio.read(new file(""src/game/"" + type.filename)); } catch (ioexception e) { system.out.println(""görsel yüklenemedi: "" + type.filename); } } void render(graphics g, int x, int y) { if (image != null) g.drawimage(image, x, y, tile_size, tile_size, null); } boolean hascollision() { return type.hascollision; } tiletype gettype() { return type; } } public tilemanager() { generatemap(); } public void generatemap() { for (int x = 0; x < width; x++) { for (int y = 0; y < height; y++) { settile(x, y, tiletype.grass); } } for (int x = 0; x < width; x++) { settile(x, 0, tiletype.brick); settile(x, height - 1, tiletype.brick); } for (int y = 0; y < height; y++) { settile(0, y, tiletype.brick); settile(width - 1, y, tiletype.brick); } int wx = 2, wy = 2; placearea(wx, wy, tiletype.water); surroundarea(wx, wy, tiletype.stone); int lx = width - 5, ly = height - 5; placearea(lx, ly, tiletype.lava); surroundarea(lx, ly, tiletype.stone); random rand = new random(); int treecount = 60; int bushcount = 100; for (int i = 0; i < treecount;) { int x = rand.nextint(width - 2) + 1; int y = rand.nextint(height - 2) + 1; if (canplacetree(x, y)) { settile(x, y, tiletype.tree); marksurroundingoccupied(x, y); i++; } } for (int i = 0; i < bushcount;) { int x = rand.nextint(width - 2) + 1; int y = rand.nextint(height - 2) + 1; point p = new point(x, y); if (!occupied.contains(p) && !isspecialtile(x, y)) { settile(x, y, tiletype.bush); i++; } } } private boolean canplacetree(int x, int y) { if (isspecialtile(x, y)) return false; for (int dx = -1; dx <= 1; dx++) { for (int dy = -1; dy <= 1; dy++) { point p = new point(x + dx, y + dy); if (occupied.contains(p)) return false; } } return true; } private void marksurroundingoccupied(int cx, int cy) { for (int dx = -1; dx <= 1; dx++) { for (int dy = -1; dy <= 1; dy++) { int x = cx + dx; int y = cy + dy; if (x > 0 && y > 0 && x < width && y < height) { occupied.add(new point(x, y)); } } } } private void placearea(int startx, int starty, tiletype type) { for (int x = startx; x < startx + 2; x++) { for (int y = starty; y < starty + 2; y++) { settile(x, y, type); occupied.add(new point(x, y)); } } } private void surroundarea(int startx, int starty, tiletype type) { for (int x = startx - 1; x <= startx + 2; x++) { for (int y = starty - 1; y <= starty + 2; y++) { if (x >= 0 && y >= 0 && x < width && y < height) { if (!occupied.contains(new point(x, y))) settile(x, y, type); } } } } private boolean isspecialtile(int x, int y) { tiletype t = gettiletypeat(x, y); return t == tiletype.water || t == tiletype.lava || t == tiletype.stone || t == tiletype.brick; } public void settile(int x, int y, tiletype type) { if (x >= 0 && x < width && y >= 0 && y < height) { tiles[x][y] = new tile(type); } } public void render(graphics g) { for (int x = 0; x < width; x++) { for (int y = 0; y < height; y++) { tiles[x][y].render(g, x * tile_size, y * tile_size); } } } public boolean hascollision(float x, float y) { int tilex = (int)(x / tile_size); int tiley = (int)(y / tile_size); if (tilex < 0 || tiley < 0 || tilex >= width || tiley >= height) return true; return tiles[tilex][tiley].hascollision(); } public boolean hascollision(rectangle bounds) { int left = bounds.x; int right = bounds.x + bounds.width; int top = bounds.y; int bottom = bounds.y + bounds.height; return hascollision(left, top) || hascollision(right, top) || hascollision(left, bottom) || hascollision(right, bottom); } public tiletype gettiletypeat(int x, int y) { if (x >= 0 && x < width && y >= 0 && y < height) { return tiles[x][y].type; } return tiletype.grass; } // iyi bir spawn yeri mi public boolean isspawnable(rectangle rect) { int left = rect.x / tile_size; int top = rect.y / tile_size; int right = (rect.x + rect.width) / tile_size; int bottom = (rect.y + rect.height) / tile_size; for (int x = left; x <= right; x++) { for (int y = top; y <= bottom; y++) { if (x < 0 || y < 0 || x >= width || y >= height) return false; tile tile = tiles[x][y]; tiletype type = tile.gettype(); if (type == tiletype.lava || type == tiletype.water || type == tiletype.brick || type == tiletype.stone || tile.hascollision()) { return false; } } } return true; } } package game; import java.awt.dimension; import java.awt.image; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; import javax.swing.jframe; public class window { private jframe frame; public window(int width, int height, string title, game game) { frame = new jframe(title); try { image icon = imageio.read(new file(""src/game/icon.png"")); frame.seticonimage(icon); } catch (ioexception e) { system.out.println(""i̇kon yüklenemedi!""); } frame.setpreferredsize(new dimension(width, height)); frame.setmaximumsize(new dimension(width, height)); frame.setminimumsize(new dimension(width, height)); frame.setdefaultcloseoperation(jframe.exit_on_close); frame.setresizable(false); frame.setlocationrelativeto(null); frame.add(game); game.requestfocus(); frame.setvisible(true); } } package game; import java.awt.color; import java.awt.graphics; import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.file; import java.io.ioexception; import javax.imageio.imageio; public class player extends gameobject { private float _acc = 1f; private float _dcc = 0.5f; private keyinput input; private int health = 150; private handler handler; private camera cam; private int maxhealth = 150; private bufferedimage pistolimg, rifleimg, shotgunimg, sniperimg, rocketimg; private bufferedimage idleimage; private bufferedimage[] runframes = new bufferedimage[8]; private int animationindex = 0; private long lastframetime = 0; private long framedelay = 100; private string direction = ""down""; private long lastdamagetime = 0; private long damagecooldown = 1000; private gun currentgun; public gun pistol = new pistol(); public gun rifle = null; public gun shotgun = null; public gun sniper = null; public gun rocketlauncher = null; public void heal(int amount) { health = math.min(health + amount, maxhealth); } public int getmaxhealth() { return maxhealth; } public void setmaxhealth(int maxhealth) { this.maxhealth = maxhealth; } public void increasemaxhealth(int amount) { maxhealth += amount; health += amount; } public player(float x, float y, id id, keyinput input, handler handler, camera cam) { super(x, y, id); this.input = input; this.handler = handler; this.cam = cam; this.currentgun = pistol; velx = 0; vely = 0; try { idleimage = imageio.read(new file(""src/game/idle1.png"")); for (int i = 0; i < 8; i++) { runframes[i] = imageio.read(new file(""src/game/run"" + (i + 1) + "".png"")); } system.out.println(""tüm sprite'lar başarıyla yüklendi!""); } catch (ioexception e) { system.out.println(""sprite yüklenirken hata oluştu!""); } try { pistolimg = imageio.read(new file(""src/game/pistol.png"")); rifleimg = imageio.read(new file(""src/game/assault_rifle.png"")); shotgunimg = imageio.read(new file(""src/game/shotgun.png"")); sniperimg = imageio.read(new file(""src/game/sniper.png"")); rocketimg = imageio.read(new file(""src/game/rocketlauncher.png"")); } catch (ioexception e) { system.out.println(""silah görselleri yüklenemedi!""); } } //silah hizalama public float[] getguntipposition() { float gunx = x; float guny = y; int offsetx = 16; int offsety = 16; int gunlength = switch (currentgun.getclass().getsimplename()) { case ""pistol"" -> 16; case ""rifle"" -> 20; case ""shotgun"" -> 18; case ""sniper"" -> 24; case ""rocketlauncher"" -> 26; default -> 16; }; switch (direction) { case ""right"" -> { gunx += offsetx + gunlength; guny += offsety; } case ""left"" -> { gunx += offsetx - gunlength; guny += offsety; } case ""up"" -> { gunx += offsetx; guny += offsety - gunlength; } case ""down"" -> { gunx += offsetx; guny += offsety + gunlength; } } return new float[]{gunx, guny}; } @override public void tick() { gun gun = getcurrentgun(); if (gun.isreloading() && system.currenttimemillis() - gun.reloadstarttime >= gun.reloadduration) { gun.completereload(); } // movement için if (input.keys[0]) { velx += _acc; direction = ""right""; } else if (input.keys[1]) { velx -= _acc; direction = ""left""; } else { if (velx > 0) velx -= _dcc; else if (velx < 0) velx += _dcc; } if (input.keys[2]) { vely -= _acc; direction = ""up""; } else if (input.keys[3]) { vely += _acc; direction = ""down""; } else { if (vely > 0) vely -= _dcc; else if (vely < 0) vely += _dcc; } velx = clamp(velx, 5, -5); vely = clamp(vely, 5, -5); float nextx = x + velx; float nexty = y + vely; rectangle nextbounds = new rectangle((int) nextx, (int) nexty, 32, 32); if (handler.gettilemanager() == null || !handler.gettilemanager().hascollision(nextbounds)) { x = nextx; y = nexty; } else { velx = 0; vely = 0; } long now = system.currenttimemillis(); if (ismoving() && now - lastframetime > framedelay) { animationindex = (animationindex + 1) % runframes.length; lastframetime = now; } for (gameobject obj : handler.object) { if (obj instanceof zombie z && z.getattackbounds().intersects(getbounds())) { if (now - lastdamagetime >= damagecooldown) { takedamage(z.damage); lastdamagetime = now; } } } } private boolean ismoving() { return input.keys[0] || input.keys[1] || input.keys[2] || input.keys[3]; } private float clamp(float value, float max, float min) { if (value > max) return max; else if (value < min) return min; return value; } @override public void render(graphics g) { bufferedimage frame = runframes[animationindex]; if (!ismoving()) { g.drawimage(idleimage, (int) x, (int) y, 32, 32, null); } else { switch (direction) { case ""right"" -> g.drawimage(frame, (int) x, (int) y, 32, 32, null); case ""left"" -> g.drawimage(frame, (int) x + 32, (int) y, -32, 32, null); case ""up"", ""down"" -> g.drawimage(frame, (int) x, (int) y, 32, 32, null); } } bufferedimage gunimage = null; if (currentgun instanceof pistol) gunimage = pistolimg; else if (currentgun instanceof rifle) gunimage = rifleimg; else if (currentgun instanceof shotgun) gunimage = shotgunimg; else if (currentgun instanceof sniper) gunimage = sniperimg; else if (currentgun instanceof rocketlauncher) gunimage = rocketimg; if (gunimage != null) { int gunwidth = 20, gunheight = 20; int gunoffsetx = 0, gunoffsety = 0; switch (direction) { case ""right"" -> { gunoffsetx = 22; gunoffsety = 14; g.drawimage(gunimage, (int) x + gunoffsetx, (int) y + gunoffsety, gunwidth, gunheight, null); } case ""left"" -> { gunoffsetx = -10; gunoffsety = 14; g.drawimage(gunimage, (int) x + gunoffsetx + gunwidth, (int) y + gunoffsety, -gunwidth, gunheight, null); } case ""up"", ""down"" -> { graphics2d g2d = (graphics2d) g.create(); double angle = direction.equals(""up"") ? -math.pi / 2 : math.pi / 2; gunoffsetx = 6; gunoffsety = direction.equals(""up"") ? -5 : 20; int centerx = (int) x + gunoffsetx + gunwidth / 2; int centery = (int) y + gunoffsety + gunheight / 2; g2d.rotate(angle, centerx, centery); g2d.drawimage(gunimage, (int) x + gunoffsetx, (int) y + gunoffsety, gunwidth, gunheight, null); g2d.dispose(); } } } renderhealthbar(g, 32); } @override public rectangle getbounds() { return new rectangle((int) x, (int) y, 32, 32); } public int gethealth() { return health; } public void takedamage(int damage) { health -= damage; if (health <= 0) { health = 0; system.out.println(""you died""); game.gameover = true; } } public gun getcurrentgun() { return currentgun; } public void setcurrentgun(gun gun) { if (currentgun != null) currentgun.cancelreload(); this.currentgun = gun; } public void unlockrifle() { if (rifle == null) rifle = new rifle(); } public void unlockshotgun() { if (shotgun == null) shotgun = new shotgun(); } public void unlocksniper() { if (sniper == null) sniper = new sniper(); } public void unlockrocketlauncher() { if (rocketlauncher == null) rocketlauncher = new rocketlauncher(); } } package game; import java.awt.color; import java.awt.graphics; import java.awt.rectangle; public abstract class gameobject { protected float x,y; protected float velx,vely; protected id id; protected int health; protected int maxhealth; public gameobject(float x,float y,id id) { this.x=x; this.y=y; this.id=id; } public abstract rectangle getbounds(); public abstract void tick(); public abstract void render(graphics g); public void renderhealthbar(graphics g, int width) { g.setcolor(color.green); int barwidth = (int)(width * ((float)health / maxhealth)); g.fillrect((int)x, (int)y - 10, barwidth, 5); if(health<= maxhealth*0.5) { g.setcolor(color.red); g.fillrect((int)x, (int)y - 10, barwidth, 5); } } public float getx() { return x; } public void setx(float x) { this.x = x; } public float gety() { return y; } public void sety(float y) { this.y = y; } public float getvelx() { return velx; } public void setvelx(float velx) { this.velx = velx; } public float getvely() { return vely; } public void setvely(float vely) { this.vely = vely; } public id getid() { return id; } public void setid(id id) { this.id = id; } }"
6418019,4,"6418019 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. package bil211_lab; public class sayac { string str; public sayac(string str){ this.str = str; } public int say1(string input){ if(input.length() == 0){ return 0; } if(input.charat(0) == '1'){ return 1 + say1(input.substring(1)); } else{ return say1(input.substring(1)); } } public int say(){ return say1(str); } } package bil211_lab; public class lab1 { public static void main(string[] args) { system.out.println(collatz(5)); int[] ar = {5, 4, 1, 2}; cocktailsort(ar); for(int i = 0; i<ar.length; i++){ system.out.println(ar[i]); } sayac s1 = new sayac(""10001""); system.out.println(s1.say()); } public static int collatz(int i){ if(i == 1){ return 0; } if(i%2 == 0){ return 1 + collatz(i/2); } else{ return 1 + collatz(i*3 + 1); } } public static void cocktailsort(int[] arr){ sort2(arr, 0, arr.length - 1, false); } public static void sort2(int[] array, int start, int end, boolean direction){ if(start >= end){ return; } if(direction == false){ for(int i = start; i < end; i++){ if(array[i] > array[i+1]){ int buyuk = array[i]; array[i] = array[i+1]; array[i+1] = buyuk; } } end--; } else{ for(int i = end; i>0; i-- ){ if(array[i] < array[i-1]){ int kucuk = array[i]; array[i] = array[i-1]; array[i-1] = kucuk; } } start++; } sort2( array,start, end, !direction); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arraylist; import java.util.arrays; import java.util.collections; import java.util.list; import javax.sound.sampled.sourcedataline; public class lab2 { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); arraylist<sarki> sarkilistesi = (arraylist)arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri:""); for(int i = 0; i < sarkilistesi.size(); i++){ sarki s = sarkilistesi.get(i); if(s instanceof metalsarki){ system.out.println( ((metalsarki)s).getisim + "" - "" + ((metalsarki)s).getsanatci ; } } } } abstract class sarki{ protected string isim; protected string sanatci; public string getisim() { return isim; } public string getsanatci() { return sanatci; } public void setisim(string isim) { this.isim = isim; } public void setsanatci(string sanatci) { this.sanatci = sanatci; } public abstract void oynat(); } class metalsarki extends sarki{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik){ setisim(isim); setsanatci(sanatci); this.metalozellik = metalozellik; } public void gostermetalozellikler(){ system.out.println(metalozellik); } public void oynat(){ system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" "" + ""("" + metalozellik + "")""); } } class rocksarki extends sarki{ public rocksarki(string isim, string sanatci){ setisim(isim); setsanatci(sanatci); } public void oynat(){ system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci){ setisim(isim); setsanatci(sanatci); } public void oynat(){ system.out.println(""[klasi̇k] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } interface calmastratejisi{ void cal(arraylist<sarki> sarkilistesi); } class siralicalma implements calmastratejisi{ public void cal(arraylist<sarki> sarkilistesi){ system.out.println(""sirali calma""); for(int i = 0; i<sarkilistesi.size(); i++){ sarki s = sarkilistesi.get(i); if(s instanceof metalsarki){ ((metalsarki)s).oynat(); } else if(s instanceof rocksarki){ ((rocksarki)s).oynat(); } else if(s instanceof klasiksarki){ ((klasiksarki)s).oynat(); } } } } class karisikcalma implements calmastratejisi{ public void cal(arraylist<sarki> sarkilistesi){ collections.shuffle(sarkilistesi); system.out.println(""karisik calma""); for(int i = 0; i<sarkilistesi.size(); i++){ sarki s = sarkilistesi.get(i); if(s instanceof metalsarki){ ((metalsarki)s).oynat(); } else if(s instanceof rocksarki){ ((rocksarki)s).oynat(); } else if(s instanceof klasiksarki){ ((klasiksarki)s).oynat(); } } } } class rockcuozelcalma implements calmastratejisi{ public void cal(arraylist<sarki> sarkilistesi){ boolean sesduzeyi = false; system.out.println(""rockcuozelcalma calma""); for(int i = 0; i<sarkilistesi.size(); i++){ sarki s = sarkilistesi.get(i); if(s instanceof metalsarki){ ((metalsarki)s).oynat(); } else if(s instanceof rocksarki && sesduzeyi == false){ sesduzeyi = true; system.out.println(""[bi̇lgi̇] ses duzeyi: yuksek""); ((rocksarki)s).oynat(); } else if(s instanceof rocksarki && sesduzeyi == true){ ((rocksarki)s).oynat(); system.out.println(""[bi̇lgi̇] ses duzeyi: normal""); } else if(s instanceof klasiksarki){ ((klasiksarki)s).oynat(); } } } } class muzikcalar{ calmastratejisi strateji; public void setstrateji(calmastratejisi strateji){ this.strateji = strateji; } public void muzikcal(arraylist<sarki> sarkilistesi){ if(strateji instanceof siralicalma){ siralicalma sira = (siralicalma) strateji; sira.cal(sarkilistesi); } else if(strateji instanceof karisikcalma){ karisikcalma karisik = (karisikcalma) strateji; karisik.cal(sarkilistesi); } } } kelime sayıcı bil 211 - lab 3 20 şubat 2025 1 giriş bu laboratuvarda fileioveexceptions kullanarak bir kelime sayıcı geliştireceğiz. kelime sayıcı , verilen birmetindosyasındakibelirlikelimelerinkaçkezgeçtiğinisayarakbirçıktıdosyasınakaydedecekvebelirlenen hata durumlarında uygun çıktılar oluşturacaktır. 2 genel program program, aşağıdaki sabit isimlere sahip iki giriş dosyası ile çalışacaktır: -kelimeler.txt – aranacak kelimeleri içeren dosya. -metin.txt – kelimelerin aranacağı metnin bulunduğu dosya. program, kelimeler.txt dosyasındaki her kelimenin metin.txt içinde kaç kez geçtiğini sayacak ve sonucu bir çıktı dosyasına kaydedecektir: -sonuc.txt – her kelimenin kaç kez geçtiğini içeren çıktı dosyası. dosyalar,programınçalıştırıldığıdizindebulunmalıdır. dosyaisimlerideğiştirilemez,programsadeceyukarıda belirtilen isimlerle çalışacaktır. eğerkelimeler.txt içinde bulunan herhangi bir kelime, metin.txt içinde hiç geçmiyorsa, program bir hata oluşturmalı ve stderr’e uygun bir mesaj yazmalıdır. 3 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları kullanacaktır (örn., bufferredreader, scanner, printwriter). dosyaları okurken ve yazarken kullanacağınız fileio sınıflarının seçimi size bırakılmıştır. i̇şlenmesi gereken dosyalar şunlardır: -kelimeler.txt dosyası okunmalıdır. -metin.txt dosyası okunmalıdır. -sonuc.txt dosyası oluşturulup yazılmalıdır. program,aşağıdakiolasıdosyahatalarınıoluşturmalıvehatalaroluştuğundastderr’ebelirlenenhatamesajlarını yazmalıdır: - dosyabulunamıyorsa: ""hata: kelimeler.txt bulunamadı."" veya""hata: metin.txt bulunamadı."" - dosya boşsa: ""hata: kelimeler.txt boş."" veya""hata: metin.txt boş."" 4 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program hata kodu ile çıkış yapmalıdır (yani mainmetodunuz bu hataları atarak sonlanmalı) ve hatalar stderr’e yazılmalıdır (programınızı hata atarak sonlandırırsanız java bunu kendisi yapacaktır). belirtilen hata mesajları ile birlikte java’nın hata ile sonlanan programlar için oluşturduğu sınıf, metod, ve satır gibi bilgiler bulunabilir. 1 4.1 girdi hataları (inputexception class) bu kategori, programın giriş dosyalarıyla ilgili karşılaşabileceği tüm hataları kapsar. öğrenciler, dosya işlem- leriyle ilgili hata türlerini inputexception sınıfından türetmelidir. aşağıdaki özel hata türleri tanımlanmalıdır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: [dosya adı] bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: [dosya adı] boş."" 4.2 kelime bulunamadı hatası (kelimebulunamadiexception class) eğerkelimeler.txt içinde bulunan en az bir kelime, metin.txt dosyasında hiç geçmiyorsa, program kelimebulunamadiexception hatasını atmalıdır. hata yalnızca kelimeler.txt dosyasında bulunamayan ilk kelime için atılır ve program sonlanır. bu hata oluştuğunda stderr’e şu mesaj yazılmalıdır: -""hata: [kelime] metinde bulunamadı."" bu hata, doğrudan exception sınıfından türetilecek ve inputexception ile bağlantılı olmayacaktır. 5 dosya formatları program üç farklı dosya ile çalışacaktır: kelimeler.txt (girdi),metin.txt (girdi) ve sonuc.txt (çıktı). bu dosyaların formatı aşağıda belirtilmiştir. 5.1 girdi dosyaları girdi dosyaları düz metin ( .txt) formatında olacaktır ve her biri aşağıdaki gibi yapılandırılmış olmalıdır. 5.1.1kelimeler.txt formatı kelimeler.txt dosyası, her satırda bir kelime olacak şekilde düzenlenmelidir. dosyada yalnızca harf karak- terleri bulunur. kelimeler büyük/küçük harf duyarsız olarak aranacaktır. örnek i̇çerik: elma armut üzüm eğer dosya boşsa, program şu hatayı vermelidir: hata: kelimeler.txt boş. 5.1.2metin.txt formatı metin.txt dosyası, içinde aranacak kelimelerin geçebileceği serbest formatlı bir metin içermelidir. dosya içinde noktalama işaretleri ve boşluklar bulunabilir. örnek i̇çerik: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. eğer dosya boşsa, program şu hatayı vermelidir: hata: metin.txt boş. 5.2 çıktı dosyası program, kelimelerin kaç kez geçtiğini gösteren bir çıktı dosyası ( sonuc.txt ) oluşturmalıdır. 2 5.2.1sonuc.txt formatı sonuc.txt dosyası, her satırda kelimenin adı ve kaç kez geçtiği bilgisi olacak şekilde düzenlenmelidir. format şu şekilde olmalıdır: [kelime] [geçme sayısı] kelime ve geçme sayısı arasında tek bir boşluk olmalıdır. örnek çıktı ( sonuc.txt ): elma 2 armut 2 üzüm 1 5.3 özel hata durumları ve çıktıları eğerkelimeler.txt içindekiherhangibirkelime metin.txt içindebulunamazsa, kelimebulunamadiexception hatası atılmalıdır ve stderr’e şu mesaj yazılmalıdır: hata: üzüm metinde bulunamadı. bu hata oluştuğunda, yine de sonuc.txt dosyası oluşturulmalı ve bulunan kelimeler için normal çıktı yazıl- malıdır. ancak bulunamayan kelimeler çıktı dosyasına eklenmemelidir. örnek durum: eğerkelimeler.txt şu şekildeyse: elma armut muz vemetin.txt şu şekildeyse: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. o zaman sonuc.txt şu şekilde olmalıdır: elma 2 armut 2 ve stderr’e şu mesaj yazılmalıdır: hata: muz metinde bulunamadı. 6 gönderim formatı - labı bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara şeklinde isimlendirin (örn., johnnash_181101014.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""lab3 gönderim"" başlıklı bir mail ile gönderin. 3 metot açıklama string(string s) sile aynı değere sahip bir string oluşturur. string(char[] a) a[]dizisindeki karakterlerle bir string oluşturur. int length() string içindeki karakter sayısını döndürür. char charat(int i) belirtilen iindeksindeki karakteri döndürür. string substring(int i, int j) iilej-1arasındaki karakterleri içeren bir alt string döndürür. boolean contains(string substring) string’in substring ’i içerip içermediğini kontrol eder. boolean startswith(string prefix) string’in prefixile başlayıp başlamadığını kontrol eder. boolean endswith(string postfix) string’in postfix ile bitip bitmediğini kontrol eder. int indexof(string pattern) pattern ifadesinin ilk geçtiği indeks değerini döndürür. int indexof(string pattern, int i) iindeksinden sonraki ilk pattern konumunu döndürür. string concat(string t) string’in sonuna teklenmiş halini döndürür. int compareto(string t) i̇ki string’i karşılaştırır (sözlük sırasına göre). string tolowercase() string’in tüm harflerini küçük harfe çevirir. string touppercase() string’in tüm harflerini büyük harfe çevirir. string replace(string a, string b) string içindeki a’larıbile değiştirir. string trim() string’in başındaki ve sonundaki boşlukları kaldırır. boolean matches(string regex) string’in belirtilen regexle eşleşip eşleşmediğini kontrol eder. string[] split(string delimiter) string’idelimiter kullanarak böler ve bir dizi döndürür. boolean equals(object t) string’in değeri tile aynı mı diye kontrol eder. table 1: java string sınıfı metotları 4 import java.io.*; import java.util.*; public class kelimesayaci { public static void main(string[] args) { } public static void readfromfile(string filename){ try{ scanner scan = new scanner(new fileinputstream(filename)); while(scan.hasnextline()){ } } catch(dosyabulunamadiexception e){ system.out.println(e.getmessage()); } catch(bosdosyaexception e){ system.out.println(e.getmessage()); } } public void writetofile() throws dosyabulunamadiexception{ try{ printwriter writer = new printwriter(new fileoutputstream(""sonuc.txt"")); } catch(filenotfoundexception e){ throw new dosyabulunamadiexception(""[hata]: sonuc.txt bulunamadı""); } } } class inputexception extends exception{ private string message; public inputexception(string message){ super(message); } } class kelimebulunamadiexception extends exception{ private string message; public kelimebulunamadiexception(string message){ super(message); } } class dosyabulunamadiexception extends inputexception{ private string message; public dosyabulunamadiexception(string message){ super(message); } } class bosdosyaexception extends inputexception{ private string message; public bosdosyaexception(string message){ super(message); } } generic 1) envanter yönetim sistemi bu labda amacımı bir oyun için envanter sistemi eklemektir. item isminde bir arayüz tanımlayın: aşağıdaki metotları içermelidir: string getname() int getvalue() weapon sınıfı tanımlayın. bu sınıf item arayüzünü uygulamalıdır. int damage isimli bir özelliği olmalıdır. armor sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. int defense isimli bir değişkeni olmalıdır. potion sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. string effect isimli bir değişkeni olmalıdır. generic inventory<t> sınıfı bir arraylist kullanarak nesneleri saklamalıdır. void additem(t item): envantere istenilen eşyayı eklemeli void removeitem(t item): envanterden istenilen eşyayı silmeli void printinventory(): envanteri basmalı t mostvaluableitem(): en değerli eşyayı dönmeli t finditembyname(string name): verilen isme karşılık gelen eşyayı dönmeli. i̇simlerin unique olduğunu varsayabilirsiniz. eğer yoksa null dönün. list<t> finditemsbyvalue(int value): verilen değerden daha değerli eşyaarın listesini döndürür. int gettotalvalue(): envanterin toplam değerini döner. list<t> filterbytype(class<?> type): istenilen sınıfa ait ögeleri döner. int gettotalweapondamage(): weapon classına ait olan nesnelerin toplam hasarınıdöner. void sortbyvalue(): değeri azalan şekilde envanteri sıralamalıdır. public static void printmostvaluableitem(inventory<? extends item> inventory): verilen envanterdem en değerli eşayı ekrana basmalıdır. public static void transferarmor(inventory<? super armor> destination, inventory<armor> source): verilen hedef envantere zırhı taşımalıdır. driver class: main metodu burada olmalıdır. sadece weapon’dan oluşan ve itemdan oluşan invertory classı yazıp test ediniz. yardımcı olabilecek metotlar: class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon import java.nio.channels.pipe.sourcechannel; import java.util.arraylist; import java.util.list; import javax.print.attribute.standard.destination; public class driver{ public static void main(string[] args) { inventory<weapon> weapon = new inventory<>(); inventory<item> item = new inventory<>(); weapon sword = new weapon(""excalibur"", 1000, 100); weapon sword2 = new weapon(""sword2"", 500, 50); weapon sword3 = new weapon(""weapon3"", 600, 120); weapon.additem(sword); weapon.additem(sword2); weapon.additem(sword3); armor armor1 = new armor(""armor1"", 400, 40); potion potion1 = new potion(""potion1"", 470, ""kill""); item.additem(armor1); item.additem(potion1); item.additem(sword); item.additem(sword2); system.out.println(""printinventor metodu:""); item.printinventort(); system.out.println(""find item has name armor1""); system.out.println(item.finditembyname(""armor1"")); system.out.println(""item that has value 400""); system.out.println(item.finditemsbyvalue(400)); system.out.println(""most valuable inventory in item""); system.out.println(item.mostvaluableitem()); system.out.println(""most valuable item in item inventory""); inventory.printmostvaluableitem(item); system.out.println(""total weapon damage""); system.out.println(item.gettotalweapondamage()); ; } } interface item{ string getname(); int getvalue(); } class weapon implements item{ string name; int value; int damage; public weapon(string name, int value, int damage){ this.name = name; this.value = value; this.damage = damage; } public string getname(){ return name; } public int getvalue(){ return value; } public int getdamage(){ return damage; } public string tostring(){ return ""name: "" + name + "" value: "" + value + "" damage: "" + damage; } } class armor implements item{ string name; int value; int defense; public armor(string name, int value, int defense){ this.name = name; this.value = value; this.defense = defense; } public string getname(){ return name; } public int getvalue(){ return value; } public int getdefense(){ return defense; } public string tostring(){ return ""name: "" + name + "" value: "" + value + "" defense: "" + defense; } } class potion implements item{ string name; int value; string effect ; public potion(string name, int value, string effect){ this.name = name; this.value = value; this.effect = effect; } public string getname(){ return name; } public int getvalue(){ return value; } public string geteffect(){ return effect; } public string tostring(){ return ""name: "" + name + "" value: "" + value + "" effect: "" + effect; } } class inventory<t> { arraylist<t> list; public inventory(){ list = new arraylist<>(); } void additem(t item){ list.add(item); } void removeitem(t item){ list.remove(item); } void printinventort(){ for(t element : list){ system.out.println(element); } } t mostvaluableitem(){ int mostvaluable = 0; int index = 0; for(int i = 0; i<list.size(); i++){ if(((item) list.get(i)).getvalue() > mostvaluable){ mostvaluable = ((item) list.get(i)).getvalue(); index = i; } } return list.get(index); } t finditembyname(string name){ for(int i = 0; i<list.size(); i++){ if(name.equals(((item) list.get(i)).getname())){ return list.get(i); } } return null; } list<t> finditemsbyvalue(int value){ list<t> morevaluable = new arraylist<>(); for(int i = 0; i<list.size(); i++){ if(value > ((item) list.get(i)).getvalue()){ morevaluable.add(list.get(i)); } } return morevaluable; } int gettotalvalue(){ int totalvalue = 0; for(t elements : list){ totalvalue += ((item)elements).getvalue(); } return totalvalue; } list<t> filterbytype(class<?> type){ list<t> filteredlist = new arraylist<>(); for(t elements : list){ if(type == ((item) elements).getclass()){ filteredlist.add(elements); } } return filteredlist; } int gettotalweapondamage(){ int totaldamage = 0; for(t elements : list){ if(elements.getclass() == weapon.class){ totaldamage += ((weapon)elements).getdamage(); } } return totaldamage; } void sortbyvalue(){ for(int i = 0; i<list.size(); i++){ for(int j = i+1; j<list.size()-1; j++){ if(((item) list.get(i)).getvalue() < ((item) list.get(j)).getvalue()){ t temp = list.get(i); t temp2 = list.get(j); list.set(i,temp2); list.remove(i+1); list.set(j, temp); list.remove(j+1); } } } } public static void printmostvaluableitem(inventory<? extends item>inventory){ item a = inventory.mostvaluableitem(); system.out.println(""name : "" + a.getname() + ""value : "" + a.getvalue()); if(a instanceof weapon){ system.out.println(""damage: "" + ((weapon)a).getdamage()); } else if(a instanceof armor){ system.out.println(""defense: "" + ((armor)a).getdefense()); } else if(a instanceof potion){ system.out.println(""effect: "" + ((potion)a).geteffect()); } } public static void transferarmor(inventory<? super armor> destination,inventory<armor> source){ list<armor> armors = source.filterbytype(armor.class); for(armor armor : armors){ destination.additem(armor); source.removeitem(armor); } } } ""recursion"" kavramı nedir, kısaca açıklayınız. bir methodunun kendi kendini çağırması recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base durum: recursion a girmeden en basit case, decomposition: problemi daha küçük problemlere ayrıdığımız kısım, composition: jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. - int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. iteratif olarak for döngüsü yerine recursive yapmak daha verimlidir bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? - stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. recursionun sonsuz bir döngüye girmesi tail recursion nedir, kısaca açıklayınız. - abstraction kavramını açıklayınız. gerekli bilgileri alıp geri kalan bilgileri gizlemek, blackbox a almak dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür cünkü employee hourlyemployee nin atasıdır. tersi mümkün degildir protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? protected java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? ata class ın constructorını çağırmak ve bilgilerli almak için java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? mümkün değildir, her class bir üstündeki classı extend etmeli java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? verilen değişkenlerin typelarının aynı olup olmadıgına ve aralarında kalıtım ilişkisi var mı ona bakar. aralarındaki ilişki: typeları aynıdır ve b, a nın atasıdır metot overriding ve overloading kavramlarını açıklayınız. overriding: metotların signatureları aynıdır, metodu child classın özelliklerine göre tekrar düzenleriz. overloading: metotların isimleri aynıdır ama parametreler farklıdır. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? - class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class içinde normal metod ya da abstract metod olabilir. abstract metodun gövdesi olmaz ve bu bu classı extend eden classta abstract metodlar override edilmelidir. abstract classtan bir obje yaratamayız. abstract classların constructoru olabilir ama interfacelerin olmaz abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? abstarct classi extend eden baska bir abstarct classta implement edilebilir abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract metodun body si olmaz abstract class icinde abstract olmayan metod ya yazabiliriz abstract classlar sayesinde subclasslara abstarct metodlari zorunlu kılmış oluruz abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract classlar tip olarak kullanılamaz ama interfaceler kullanılabilir. interfacelerde metodlar otomatik public abstract olarak tanımlanır marker interface ve functional interface kavramları nedir, nasıl kullanılır? - bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? bir class birden çok interface implement edebilir. bir interface baska bir interfacei implement edebilir. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abstarct classtan obje yaratamayiz, circle c = new circle(); yaparız output: drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? - java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 3 çeşittir: compile time error: syntax hataları örneğin parantezin unutulması, runtime error: sıfıra bölme , logical error: programın çalışıp istenilen sonucu vermemesi. java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? checked türündeki hatalar icin kullanılır. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? - java'da kendi exceptionunuzu nasıl tanımlarsınız? o exception adı ile bir class oluştururum. bu class exception classını override etmelidir. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? - static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught -1 finally oops done static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? - what grade (a, b, c, d, or f) do you expect to earn by the end of this course? cc java'da generic kavramı nedir, bu kavramın temel amacı nedir? bir classı veya metodu generic olarak tanımlamak daha flexible kod yazmamızı ve type safety sağlar upper bound ve lower bound wildcardları nasıl ifade edersiniz? upper ve lower boundun kullanılacağı durumlara birer tane örnek veriniz. upper bound, type parametresinin upper bound olan class ve onun subclasslarından biri olması gerektiğini söyler, lower bound ise type parametresinin lower bound olan class ya da o classın üst classlarından birisi olması gerekitigini söyler. generic bir classın constructorunda type parametresi bulunur mu, neden? hayır bulunmaz mygenericclass<a> ve mygenericclass<object> classları arasında kalıtım (child-parent) ilişkisi nasıldır, açıklayınız. - class node<t>{ t[] data = new t[10]; } //psvm node<string> stringnode = new node<>(); bu kodda bir hata var mı? (varsa) bu hata nedir, nedenini açıklayınız. (varsa) bu hata nasıl düzeltilmeli, kodun doğru halini yazınız. hata yok swapheadandtail metodu aşağıda tanımı verilmiş node classının birbirlerine bağlanmış nodelerinden ilkini alan ve baştaki node ile sondaki node'yi değiştiren metottur. örnek: başlangıçta: a -> b -> c metodu a ile çağırdığıktan sonra: c -> b -> a ayrıca metot en başa gelen nodeyi dönmelidir (bu örnekte c dönmeli). class node{ int data; node next; } static node swapheadandtail(node head) { node a = head; node b = head.next; node c = head; node d = null; while (____ != null) { d = c; c = c.next; } c.next = ____; d.next = ____; a.next = ____; return ____; } buna göre boşluklara neler gelmelidir? b, , , , node public _________ { public void sırala(list<t> liste) { // sıralama algoritmanız } } yaptığınız uzun çalışmalar sonucu yeni bir sıralama algoritması buldunuz. bunu implement etmek için bir class yazmalısınız. bu classın declarationunu nasıl yapardınız neden, boşluğu buna göre doldurun. class_name <t> şeklinde olurdu, çünkü metodun parametresinden generic var bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public robot(string name,string type, int batterylevel, boolean isoperational ){ this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = isoperational; } public robot(){ this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public string getname(){ return name; } public void setname(string name){ this.name = name; } public string gettype(){ return type; } public void settype(string type){ this.type = type; } public int getbatterylevel(){ return batterylevel; } public void setbatterylevel(int batterylevel){ this.batterylevel = batterylevel; } public boolean getisoperational(){ return isoperational; } public void setisoperational(boolean isoperational){ this.isoperational = isoperational; } public void charge(){ batterylevel = 100; } public void printrobot(){ system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + "" isoperational: "" + isoperational); } } public class q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55, true); robot r3 = new robot(""r2-d2"", ""astromech"", 80, true); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name, string location){ this.name = name; this.location = location; } public factory(){ this.name = ""factory1""; this.location = ""moon""; } public string getname(){ return name; } public void setname(string name){ this.name = name; } public string getlocation(){ return location; } public void setlocation(string location){ this.location = location; } public void addrobot(robot robot){ robots.addlast(robot); } public void chargeallrobots(){ for(int i=0; i<robots.size(); i++){ robots.get(i).setbatterylevel(100); } } public void printfactory(){ for(int i=0; i<robots.size(); i++){ robots.get(i).printrobot();; } } public void work(){ for(int i=0; i<robots.size(); i++){ int a = robots.get(i).getbatterylevel(); robots.get(i).setbatterylevel((a*75)/100); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife){ this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname(){ return modelname; } public int getbatterylife() { return batterylife; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); int sayi = robotfactory.sayi; system.out.println(""tüm fabrikalar tarafindan toplam "" + sayi + "" robot üretildi""); } } public class securityrobot extends abstractrobot { private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed){ super(modelname, batterylife); this.isarmed = isarmed; } public boolean isarmed() { return isarmed; } public void recharge(){ batterylife = 100; } public void performtask(){ if(batterylife >= 10){ system.out.println(""["" + modelname + ""]"" + "" scanning for threats... "" + "" armed:"" + isarmed); batterylife = batterylife - 10; } else{ system.out.println(""["" + modelname + ""]"" + "" not enough battery to scan threats...""); } } public void togglearmedmode(){ isarmed = !isarmed; } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; public cleaningrobot(string modelname, int batterylife, int cleaningpower){ super(modelname, batterylife); this.cleaningpower = cleaningpower; } public int getcleaningpower() { return cleaningpower; } public void setcleaningpower(int cleaningpower) { this.cleaningpower = cleaningpower; } public void recharge(){ batterylife = 100; } public void performtask(){ if(batterylife >= 10){ system.out.println(""["" + modelname + ""]"" + "" cleaning in progress..."" + "" cleaning power:"" + cleaningpower); batterylife = batterylife - 10; } else{ system.out.println(""["" + modelname + ""]"" + "" not enough battery to clean...""); } } public void boostcleaningpower(){ cleaningpower = cleaningpower + 20; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; static int sayi; public robotfactory(){ robots = new arraylist<>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ cleaningrobot newcleaningrobot = new cleaningrobot(modelname, batterylife, cleaningpower); robots.add(newcleaningrobot); sayi++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ securityrobot newsecurityrobot = new securityrobot(modelname, batterylife, isarmed); robots.add(newsecurityrobot); sayi++; } public void performalltasks(){ for(int i=0; i<robots.size(); i++){ robots.get(i).performtask(); } } public void displayrobots(){ for(int i = 0; i<robots.size(); i++){ if(robots.get(i) instanceof cleaningrobot){ cleaningrobot c = (cleaningrobot) robots.get(i); system.out.println(""cleaningrobot - model: "" + c.getmodelname()+ "", battery: "" + c.getbatterylife() + "", cleaning power: "" + c.getcleaningpower()); } else if(robots.get(i) instanceof securityrobot){ securityrobot s = (securityrobot) robots.get(i); system.out.println(""securityrobot - model: "" + s.getmodelname()+ "", battery: "" + s.getbatterylife() + "", armed: "" + s.isarmed()); } } } public void upgradecleaningrobots(int miktar){ for(int i = 0; i<robots.size(); i++){ if(robots.get(i) instanceof cleaningrobot){ cleaningrobot c = (cleaningrobot) robots.get(i); int power = c.getcleaningpower() + miktar; c.setcleaningpower(power); system.out.println(""cleaningrobot - "" + c.getmodelname() + "" now has cleaning power: "" + c.getcleaningpower() ); } } } public void togglesecurityrobotsmode(){ for(int i = 0; i<robots.size(); i++){ if(robots.get(i) instanceof securityrobot){ securityrobot s = (securityrobot) robots.get(i); s.togglearmedmode(); if(s.isarmed() == false){ system.out.println(""securityrobot - "" + s.getmodelname() + "" is now unarmed "" ); } else{ system.out.println(""securityrobot - "" + s.getmodelname() + "" is now armed "" ); } } } } } envanter takip sistemi bil 211 - quiz 3 27 şubat 2025 1 giriş bu quizde, fileioveexceptions kullanarak basit bir envanter takip sistemi uygulaması geliştireceğiz. uygulama, interaktif bir terminal menüsü üzerinden, tek bir eşyanın ve stoğunun tutulduğu kayıtların yönetilmesini (eşya ekleme, çıkarma ve stok güncelleme) sağlayacaktır. ayrıca, envanter verileri sabit isimli bir dosyaya kaydedilebilecek ve bu dosyadan geri yüklenebilecektir. 2 genel program program konsol tabanlı bir kullanıcı arayüzü ile envanter takibi gerçekleştirmelidir. arayüz özellikleri aşağı- daki gibidir. -terminal menüsü: kullanıcıya aşağıdaki seçenekleri sunacaktır: – eşya ekleme: yeni bir eşya kaydı oluşturulur. her kayıt, eşya adı ve başlangıç stoğu bilgilerini içerir. eğer çoktan var olan bir eşya eklenmeye çalışılırsa program otomatik olarak önceki kaydın stoğunu güncellemelidir (yani aynı isimde iki kayıt oluşmamalı). – eşya çıkarma: mevcut envanterden istenilen eşya silinir. – stok güncelleme: kayıtlı bir eşyanın stoğu artırılabilir ya da azaltılabilir. i̇şlem sonucunda stok miktarı negatif olmamalıdır. – envanter listeleme: mevcut envanter kayıtları ekrana listelenir. – dosyaya kaydetme: güncel envanter verileri sabit isimli dosyaya kaydedilir. – dosyadan geri yükleme: daha önce kaydedilmiş envanter verileri dosyadan okunarak geri yüklenir. – çıkış: program sonlandırılır. 3envanterkaydi sınıfı değişkenler: -isim(private string) eşyanın adını tutar. -stok(private int) eşyanın stok miktarını tutar. metotlar: -public envanterkaydi(string isim, int stok) constructor; eşya adı ve stok miktarını başlatır. -public void stokguncelle(int miktar) stok miktarını günceller; negatif sonuç oluşmaması kontrol edilmelidir. - stokguncelle dışında ihtiyacınıza göre private değişkenler için getter ve setter tanımlayabilirsiniz. 4 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları (örn., bufferedreader , scanner,printwriter ) kullanacaktır. dosya işlemleri sırasında aşağıdaki hata durumları için uygun mesajlar verilmelidir: - dosya bulunamazsa: ""hata: envanter dosyası bulunamadı."" - dosya boşsa: ""hata: envanter dosyası boş."" 1 5 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program, hata kodu ile sonlanmalı ve ilgili hata mesajları stderr’e yazdırılmalıdır. 5.1 girdi hataları (inputexception class) dosya işlemleriyle ilgili hatalar için kendi tanımlayacağınız inputexception sınıfından türeyen özel hata sınıfları oluşturulacaktır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: envanter dosyası bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: envanter dosyası boş."" 5.2 envanter i̇şlemleri hataları envanter işlemleri sırasında oluşabilecek hatalar için aşağıdaki özel hata türleri tanımlanacaktır: -stoknegatifexception (extends exception) : stok güncelleme işlemi sonucunda, eşyanın stoğu negatif bir değere düşerse atılacak hata. - hata mesajı: ""hata: stok miktarı negatif olamaz."" -esyayokexception (extends exception) : çıkarma veya güncelleme işlemi yapılmak istenen eşya envanterde bulunmuyorsa atılacak hata. - hata mesajı: ""hata: i̇stenen eşya envanterde mevcut değil."" -ozellikhatasiexception (extends exception) : eşya ekleme sırasında girilen bilgilerde hata veya eksiklik varsa atılacak hata. - hata mesajı: ""hata: eşya bilgileri hatalı veya eksik."" 6 gönderim formatı - quizinizi bitirdiğinizde asistanlarınızdan birisine kodunuzu ve çıktısını gösterip puanlatın. - asistan labınızı puanladığında tüm kaynak dosyalarını ve bu dökümantasyonu bir arşiv dosyası (zip, rar, 7z, tar, tar.gz) halinde sıkıştırın. - arşiv dosyasının isim_numara formatında isimlendirin (örn., sebnemferah_181101014.zip). - i̇simlendirdiğiniz arşiv dosyasını uzak sistemindeki quiz alanına yükleyin. 2 import java.io.fileinputstream; import java.io.fileoutputstream; import java.io.ioexception; import java.io.objectinput; import java.io.objectinputstream; import java.io.objectoutputstream; import java.io.serializable; import java.util.arraylist; import java.util.scanner; import java.io.file; public class quiz3 { public static void main(string[] args) { scanner scan = new scanner(system.in); arraylist<envanterkaydi> esyalar = new arraylist<>(); boolean a = true; try{ while(a == true){ int islem = scan.nextint(); if(islem == 1){ // esya ekleme esyaekle(esyalar, ""buzdolabı"", 5); } else if(islem == 2){ // esya cıkarma esyacikar(esyalar, ""buzdolabı""); } else if(islem == 3){ // stok guncelleme stokguncelle(esyalar, ""buzdolabı"", 6); } else if(islem == 4){ // envanter listeleme for(envanterkaydi e : esyalar){ system.out.println(""isim: "" + e.getisim() + "" stok: "" + e.getstok()); } } else if(islem == 5){ // dosyaya kaydetme try{ objectoutputstream oos = new objectoutputstream(new fileoutputstream(""sabit.txt"", true)); for(envanterkaydi e : esyalar){ oos.writeobject(e); } oos.close(); } catch(ioexception e){ system.out.println(e.getmessage()); } } else if(islem == 6){ // dosyadan geri yükleme try{ file file = new file(""sabit.txt""); if(file.exists() == false){ throw new dosyabulunamadiexception(); } objectinputstream ois = new objectinputstream(new fileinputstream(""sabit.txt"")); arraylist<envanterkaydi> ek = new arraylist<>(); for(envanterkaydi e : ek){ object o = ois.readobject(); ek.add((envanterkaydi) o); } ois.close();; } catch(ioexception e ){ system.out.println(e.getmessage()); } } else if( islem == 7){ // çıkış a = false; } } } catch(dosyabulunamadiexception e){ system.out.println(e.getmessage()); } catch(classnotfoundexception e){ system.out.println(e.getmessage()); } } public static arraylist<envanterkaydi> esyaekle(arraylist<envanterkaydi> arr, string esyaismi, int miktar){ boolean esyazatenvarmi = false; try{ if(esyaismi == null){ throw new ozellikhatasiexception(); } for(envanterkaydi e : arr){ if(e.getisim().equals(esyaismi)){ esyazatenvarmi = true; e.stokguncelle(e.getstok()); } } if(esyazatenvarmi == false){ arr.add(new envanterkaydi(esyaismi, miktar)); } } catch(ozellikhatasiexception e){ system.out.println(e.getmessage()); } return arr; } public static arraylist<envanterkaydi> esyacikar(arraylist<envanterkaydi> arr, string esyaismi){ boolean esyazatenvarmi = false; try{ for(envanterkaydi e : arr){ if(esyaismi.equals(e.getisim())){ esyazatenvarmi = true; arr.remove(e); } } if(esyazatenvarmi == false){ throw new esyayokexception(); } } catch(esyayokexception e){ system.out.println(e.getmessage()); } return arr; } public static arraylist<envanterkaydi> stokguncelle(arraylist<envanterkaydi> arr, string esyaismi, int miktar ){ boolean esyazatenvarmi = false; try{ for(envanterkaydi e : arr){ if(esyaismi.equals(e.getisim())){ esyazatenvarmi = true; e.stokguncelle(miktar); } } if(esyazatenvarmi == false){ throw new esyayokexception(); } } catch(esyayokexception e){ system.out.println(e.getmessage()); } return arr; } } class inputexception extends exception{ public inputexception(string message){ super(message); } } class dosyabulunamadiexception extends inputexception{ public dosyabulunamadiexception(){ super(""hata: envanter dosyası bulunamadı.""); } } class bosdosyaexception extends inputexception{ public bosdosyaexception(){ super(""hata: envanter dosyası boş.""); } } class stoknegatifexception extends exception{ public stoknegatifexception(){ super(""hata: stok miktarı negatif olamaz.""); } } class esyayokexception extends exception{ public esyayokexception(){ super(""hata: i̇stenen eşya envanterde mevcut değil."") } } class ozellikhatasiexception extends exception{ public ozellikhatasiexception(){ super(""hata: eşya bilgileri hatalı veya eksik""); } } class envanterkaydi implements serializable{ private string isim; private int stok; public envanterkaydi(string isim, int stok){ this.isim = isim; this.stok = stok; } public string getisim() { return isim; } public int getstok() { return stok; } public void setisim(string isim) { this.isim = isim; } public void setstok(int stok) { this.stok = stok; } public void stokguncelle(int miktar){ try{ this.stok = miktar; if(stok < 0 ){ throw new stoknegatifexception(); } } catch(stoknegatifexception e){ system.out.println(e.getmessage()); } } } bil211 quiz 4 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: undoablelist<t> adında bir sınıf oluşturun. bu sınıf, bir arraylist'i genişletmeli ve aşağıdaki ek özelliklere sahip olmalıdır: ● undolast() metodu, en son eklenen öğeyi kaldırmalıdır. ● getlastadded() → son eklenen öğeyi listeyi değiştirmeden döndürür. ● eğer liste boşsa, undolast() bir hata vermemeli, sadece hiçbir şey yapmamalıdır. örnek kullanım: undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] q2: aşağıdaki generic metodu tamamlayın. ● verilen bir collection<t> içinde minimum veya maksimum öğeyi bulan bir metod yazın. ● boolean parametresi true ise maksimumu, false ise minimumu döndürmelidir. ● t öğeleri comparable<t> arabirimini uygulamalıdır. public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { // metodu tamamlayın } örnek kullanım: list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) q3: belirli türdeki elemanları filtreleme ● bir collection<?> içindeki belirli bir türdeki öğeleri filtreleyen bir generic metod yazın. ● class<t> tür filtresi olarak kullanılmalıdır. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { // metodu tamamlayın } örnek kullanım: list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] import java.util.arraylist; import java.util.arrays; import java.util.collection; import java.util.list; public class quiz4 { public static void main(string[] args) { undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); system.out.println(list); list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); system.out.println(findextreme(numbers, false)); list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(filterbytype(mixed, string.class)); system.out.println(filterbytype(mixed, integer.class)); } //soru 2 public static <t extends comparable<t>> t findextreme(collection<t> collection,boolean findmax){ if(collection.isempty()== true){ return null; } t ext = null; for (t element : collection) { if (ext == null){ ext = element; } else{ if(findmax) { if(element.compareto(ext) > 0){ ext = element; } } else if(!findmax){ if(element.compareto(ext) < 0){ ext = element; } } } } return ext; } //soru 3 public static <t> list<t> filterbytype(collection<?> collection, class<t> type){ if(collection.isempty() == true){ return null; } list<t> filtered = new arraylist<>(); for(object o : collection){ if(type.isinstance(o)){ filtered.add((t) o); } } return filtered; } } //soru 1 class undoablelist<t> extends arraylist<t>{ public void undolast(){ this.remove(getlast()); } public t getlastadded(){ if(this.isempty()){ return null; } else{ return this.getlast(); } } } 4 kuş bakışı atış oyunu (top-down shooter) bil 211 - proje teslim tarihi: 27 mart 2025 23:59 1 amaç bu ödevde amacınız, java swing kullanarak kuş bakışı bir atış oyunu (top-down shooter) tasarlamaktır. oyunda, yönettiğimiz karakterin üzerine dalga dalga gelen çeşitli zombileri fare ile hedef alarak farklı silahlar kullanıp öldürmemiz gerekmektedir. karakterimiz öldüğünde oyun sona erecektir. her dalga başına ve öldürülen zombi başına kazanılan puan artacaktır. dalgalar ilerledikçe gelen zombilerin sayısı ve çeşitleri artarak zorluk seviyesi yükselecektir. 2 gereksinimler oyun derste öğrendiğiniz oop ilkelerine uygun sınıf/arayüz tasarımları ile geliştirilmelidir. - zorluk seviyesi arttıkça zombi sayısı ve çeşitliliği artmalıdır. - oyun duraklatılabilmeli ve kaydedilip tekrar yüklenilebilmelidir (fileio kullanılmalıdır). - sol üst köşede seçili silah ve kalan mermi miktarı gösterilmelidir. - sağ üst köşede oyuncunun canı ve toplam puanı gösterilmelidir. - oyunun duraklatılması, kaydedilmesi ve devam ettirilmesi için bir menü bulunmalıdır. 3 silahlar oyunda farklı silahlar bulunmaktadır. belirli zombi dalgaları temizlendikten sonra oyun ödül olarak yeni bir silahverecektir. hersilahınkendineözgübirçalışmamekanizmasıvardır. silahlarınşarjörkapasitesisınırlıdır ve şarjördeki mermiler bittiğinde tekrar doldurulmadan ateş edilemez. toplam mermi sayısı oyuncunun o silaha ait elinde ne kadar mermi olduğunu gösterir. r tuşuna basarak şarjör yeniden doldurulabilir. 3.1 tabanca - şarjör kapasitesi: 12 mermi - ateş hızı: 120 mermi/dakika - elde etme: oyuncu oyuna bu silahla başlar. - özellik: düz atış yapar, sapma yoktur. sınırsız yedek şarjör (diğer tüm silahlar için yedek şarjör ve mermiler rastgele bir şekilde dalga sırasında ve sonlarında zombilerden düşer). 3.2 piyade tüfeği - şarjör kapasitesi: 30 mermi - ateş hızı: 600 mermi/dakika - elde etme: 1. dalga tamamlandıktan sonra - özellik: düzatışyaparancak30derecesapmasıvardır. sapmaaçısı, karakterinbaktığıyöndemerminin her iki dönme yönüne de saçılabileceği maksimum açıdır. 1 3.3 pompalı tüfek - şarjör kapasitesi: 5 mermi - ateş hızı: 60 mermi/dakika - elde etme: 3. dalga tamamlandıktan sonra - özellik: her atış 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi atar (yani karakter merkezli mermi hız vektörleri arasında 5 derece açı olmalıdır). 3.4 keskin nişancı tüfeği - şarjör kapasitesi: 5 mermi - ateş hızı: 30 mermi/dakika - elde etme: 5. dalga tamamlandıktan sonra - özellik: mermileri zombileri delip arasındaki zombilere de hasar verir. 3.5 roketatar - şarjör kapasitesi: 1 roket - ateş hızı: 10 roket/dakika - elde etme: 10. dalga tamamlandıktan sonra - özellik: patlama etkisiyle birden fazla zombiye zarar verir. 4 zombiler zombiler oyundaki düşman tipleridir. zombiler oyuncuya doğru ilerlerler ve eğer oyuncuya temas ederlerse oyuncuya hasar verirler. zorluk seviyesi arttıkça zombilerin sayısı ve çeşitliliği artmaktadır. zombi tipleri birbirinden renk ya da şekil olarak ayırt edilebilmelidir. 4.1 normal zombi - can: orta - hız: yavaş - hasar: orta 4.2 sürünge zombi - can: düşük - hız: hızlı - hasar: orta - özellik: oyuncunun yakınına geldiğinde zıplar. 4.3 tank zombi - can: yüksek - hız: çok yavaş - hasar: yüksek 2 4.4 asit tüküren zombi - can: düşük - hız: yavaş - hasar: orta (uzaktan asit tükürebilir) - özellik: öldürüldüğünde yanındaki birimlere zarar verir. 5 rapor ve teslim formatı - oyun, oopprensiplerineuygunolaraktasarlanmalıvesınıfdiyagramları, arayüztasarımıfinalraporda sunulmalıdır. - oyun test edilerek ekran görüntüleri rapora eklenmelidir. - rapor pdf formatında olmalı ve ismi proje_rapor.pdf olmalıdır. - oyunun mainfonksiyonu gameisimli bir sınıf içinde bulunmalıdır ( java game komutuyla çalışmalı). - kaynak kodun tamamı source.zip (uzantı 7z, rar, tar.gz de olabilir) şeklinde sıkıştırılmış olmalıdır. - sıkıştırılmış kaynak kod ve rapor uzak sistemine yüklenmelidir. 6 yardımcı kaynaklar dahaöncehiçkuşbakışıatışoyunuoynamadıysanızaşağıdakioyunlarıreferansolarakalabilirsiniz. buradaki oyunlarıngrafikleriilemekaniklerisizdenbeklenendenfarklıolsadaharitatasarımı, karakterhareketi,kamera hareketi, ateş etme mekanikleri ve zombilerin yapay zekası ile ilgili temel fikirler edinebilirsiniz. - little top-down shooter: https://www.youtube.com/watch?v=pj3m3fu3i5a - super c - stage 2: https://www.youtube.com/watch?v=os2t_v5suj4 - neon chrome: https://www.youtube.com/watch?v=puhw1bevtro 3 package entity; import main.gamepanel; public class crawlingzombie extends entity{ gamepanel gp; public crawlingzombie(gamepanel gp){ super(gp); this.gp = gp; direction = ""down""; speed = 2; damage = 1; maxlife = 1; life = maxlife; point = 100; solidarea.x = 3; solidarea.y = 18; solidarea.width = 42; solidarea.height = 30; solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; getimage(); } public void getimage(){ up1 = setup(""/npc/crawling_z_right1"", gp.tilesize, gp.tilesize); up2 = setup(""/npc/crawling_z_right2"", gp.tilesize, gp.tilesize); down1 = setup(""/npc/crawling_z_left1"", gp.tilesize, gp.tilesize); down2 = setup(""/npc/crawling_z_left2"", gp.tilesize, gp.tilesize); left1 = setup(""/npc/crawling_z_left1"", gp.tilesize, gp.tilesize); left2 = setup(""/npc/crawling_z_left2"", gp.tilesize, gp.tilesize); right1 = setup(""/npc/crawling_z_right1"", gp.tilesize, gp.tilesize); right2 = setup(""/npc/crawling_z_right2"", gp.tilesize, gp.tilesize); } public void setaction() { int dx = gp.player.worldx - worldx; int dy = gp.player.worldy - worldy; if (math.abs(dx) > math.abs(dy)) { if (dx > 0) { direction = ""right""; } else { direction = ""left""; } } else { if (dy > 0) { direction = ""down""; } else { direction = ""up""; } } } } package entity; import java.awt.alphacomposite; import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.ioexception; import javax.imageio.imageio; import main.gamepanel; import main.utilitytool; public class entity { gamepanel gp; public int worldx, worldy; public int speed; public bufferedimage up1, up2, down1, down2, left1, left2, right1, right2; public string direction; public int spritecounter = 0; public int spritenum = 1; //public rectangle attackarea = new rectangle(0, 0, 0, 0); public rectangle solidarea = new rectangle(0, 0, 48, 48); public int solidareadefaultx, solidareadefaulty; public boolean collisionon = false; public int actionlockcounter = 0; public boolean invincible = false; public int invinciblecounter = 0; public boolean gunattack = false; //character status public int maxlife; public int life; public int wave; public int damage; public int point = 0; public entity(gamepanel gp){ this.gp = gp; } public void setaction(){} public void update(){ setaction(); collisionon = false; gp.cchecker.checktile(this); int npcindex = gp.cchecker.checkentity(this, gp.npc); boolean contactplayer = gp.cchecker.checkplayer(this); if(contactplayer){ if(!gp.player.invincible && npcindex != 999){ int damage = gp.npc[npcindex].damage; if(damage < 0){ damage = 0; } gp.player.life -= damage; gp.player.invincible = true; } } if(collisionon == false){ switch(direction){ case ""up"": worldy -= speed; break; case ""down"": worldy += speed; break; case ""left"": worldx -= speed; break; case ""right"": worldx += speed; break; } } spritecounter++; if(spritecounter > 12){ if(spritenum == 1){ spritenum = 2; } else if(spritenum == 2){ spritenum = 1; } spritecounter = 0; } if(invincible){ invinciblecounter++; if(invinciblecounter > 40){ invincible = false; invinciblecounter = 0; } } } public void draw(graphics2d g2){ bufferedimage image = null; int screenx = worldx - gp.player.worldx + gp.player.screenx; int screeny = worldy - gp.player.worldy + gp.player.screeny; if(worldx + gp.tilesize > gp.player.worldx - gp.player.screenx && worldx - gp.tilesize < gp.player.worldx + gp.player.screenx && worldy + gp.tilesize > gp.player.worldy - gp.player.screeny && worldy - gp.tilesize < gp.player.worldy + gp.player.screeny ){ switch(direction){ case ""up"": if(spritenum == 1){ image = up1; } if(spritenum == 2){ image = up2; } break; case ""down"": if(spritenum == 1){ image = down1; } if(spritenum == 2){ image = down2; } break; case ""left"": if(spritenum == 1){ image = left1; } if(spritenum == 2){ image = left2; } break; case ""right"": if(spritenum == 1){ image = right1; } if(spritenum == 2){ image = right2; } break; } if(invincible){ g2.setcomposite(alphacomposite.getinstance(alphacomposite.src_over, 0.3f)); } g2.drawimage(image, screenx, screeny, null); g2.setcomposite(alphacomposite.getinstance(alphacomposite.src_over, 1f)); } } public bufferedimage setup(string imagepath, int widht, int height){ utilitytool utool = new utilitytool(); bufferedimage image = null; try{ image = imageio.read(getclass().getresourceasstream( imagepath + "".png"")); image = utool.scaleimage(image, widht, height); } catch(ioexception e){ e.printstacktrace(); } return image; } } package entity; import main.gamepanel; public class acidzombie extends entity { gamepanel gp; private int acidattackcounter; private final int acidattackinterval = 480; public acidzombie(gamepanel gp) { super(gp); this.gp = gp; direction = ""down""; speed = 1; damage = 1; maxlife = 1; life = maxlife; point = 150; acidattackcounter = 0; solidarea.x = 3; solidarea.y = 18; solidarea.width = 42; solidarea.height = 30; solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; getimage(); } public void getimage() { up1 = setup(""/npc/acid_z_up1"", gp.tilesize, gp.tilesize); up2 = setup(""/npc/acid_z_up2"", gp.tilesize, gp.tilesize); down1 = setup(""/npc/acid_z_down1"", gp.tilesize, gp.tilesize); down2 = setup(""/npc/acid_z_down2"", gp.tilesize, gp.tilesize); left1 = setup(""/npc/acid_z_left1"", gp.tilesize, gp.tilesize); left2 = setup(""/npc/acid_z_left2"", gp.tilesize, gp.tilesize); right1 = setup(""/npc/acid_z_right1"", gp.tilesize, gp.tilesize); right2 = setup(""/npc/acid_z_right2"", gp.tilesize, gp.tilesize); } public void setaction() { acidattackcounter++; int diffx = gp.player.worldx - worldx; int diffy = gp.player.worldy - worldy; double distance = math.sqrt(diffx * diffx + diffy * diffy); if(acidattackcounter >= acidattackinterval) { spitacid(); acidattackcounter = 0; } if(math.abs(diffx) > math.abs(diffy)) { direction = (diffx > 0) ? ""right"" : ""left""; } else { direction = (diffy > 0) ? ""down"" : ""up""; } } public int[] getacidspawnposition() { int spawnx = worldx + gp.tilesize / 2; int spawny = worldy + gp.tilesize / 2; switch(direction) { case ""up"": spawny -= 10; break; case ""down"": spawny += 10; break; case ""left"": spawnx -= 10; break; case ""right"": spawnx += 10; break; case ""upright"": { spawnx += 7; spawny -= 7; break; } case ""upleft"": { spawnx -= 7; spawny -= 7; break; } case ""downright"":{ spawnx += 7; spawny += 7; break; } case ""downleft"": { spawnx -= 7; spawny += 7; break; } } return new int[]{spawnx, spawny}; } public void spitacid() { int[] spawnpos = getacidspawnposition(); int startx = spawnpos[0]; int starty = spawnpos[1]; int targetx = gp.player.worldx + gp.tilesize / 2; int targety = gp.player.worldy + gp.tilesize / 2; acidbullet acid = new acidbullet(gp, startx, starty, targetx, targety); gp.acidbulletlist.add(acid); } } package entity; import main.gamepanel; import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; public class bullet extends entity { public int dx; public int dy; public int bulletspeed = 8; public int damage = 1; public boolean explosive = false; public int explosionradius = 20; public int explosiontimer = 30; public bufferedimage bulletimage; public boolean piercing = false; public bullet(gamepanel gp, int startx, int starty, int targetx, int targety) { super(gp); this.worldx = startx; this.worldy = starty; int diffx = targetx - startx; int diffy = targety - starty; double distance = math.sqrt(diffx * diffx + diffy * diffy); if (distance == 0) distance = 1; // bölme hatasını önlemek için this.dx = (int) math.round((diffx / distance) * bulletspeed); this.dy = (int) math.round((diffy / distance) * bulletspeed); setupbulletimage(); } private void setupbulletimage() { bulletimage = setup(""/bullet/bullet"", gp.tilesize, gp.tilesize); } public void update() { worldx += dx; worldy += dy; } public void draw(graphics2d g2) { int screenx = worldx - gp.player.worldx + gp.player.screenx; int screeny = worldy - gp.player.worldy + gp.player.screeny; g2.drawimage(bulletimage, screenx, screeny, null); } public rectangle getsolidarea() { return new rectangle(worldx, worldy, bulletimage.getwidth(), bulletimage.getheight()); } } package entity; import main.gamepanel; public class normalzombie extends entity{ gamepanel gp; public normalzombie(gamepanel gp){ super(gp); this.gp = gp; direction = ""down""; speed = 1; damage = 1; maxlife = 2; life = maxlife; point = 50; solidarea.x = 3; solidarea.y = 18; solidarea.width = 42; solidarea.height = 30; solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; getimage(); } public void getimage(){ up1 = setup(""/npc/normal_z_up1"", gp.tilesize, gp.tilesize); up2 = setup(""/npc/normal_z_up2"", gp.tilesize, gp.tilesize); down1 = setup(""/npc/normal_z_down1"", gp.tilesize, gp.tilesize); down2 = setup(""/npc/normal_z_down2"", gp.tilesize, gp.tilesize); left1 = setup(""/npc/normal_z_left1"", gp.tilesize, gp.tilesize); left2 = setup(""/npc/normal_z_left2"", gp.tilesize, gp.tilesize); right1 = setup(""/npc/normal_z_right1"", gp.tilesize, gp.tilesize); right2 = setup(""/npc/normal_z_right2"", gp.tilesize, gp.tilesize); } public void setaction() { int dx = gp.player.worldx - worldx; int dy = gp.player.worldy - worldy; if (math.abs(dx) > math.abs(dy)) { if (dx > 0) { direction = ""right""; } else { direction = ""left""; } } else { if (dy > 0) { direction = ""down""; } else { direction = ""up""; } } } } package entity; import java.awt.graphics2d; import java.awt.image.bufferedimage; import java.io.ioexception; import javax.imageio.imageio; import main.gamepanel; import main.utilitytool; public class rocketbullet extends bullet { public int damage = 5; public int speed = 10; public bufferedimage rocketimage; public rocketbullet(gamepanel gp, int startx, int starty, int targetx, int targety) { super(gp, startx, starty, targetx, targety); this.bulletspeed = speed; int diffx = targetx - startx; int diffy = targety - starty; double distance = math.sqrt(diffx * diffx + diffy * diffy); if(distance == 0) distance = 1; this.dx = (int)math.round((diffx / distance) * speed); this.dy = (int)math.round((diffy / distance) * speed); setuprocketimage(); } public void setuprocketimage() { try { rocketimage = imageio.read(getclass().getresourceasstream(""/bullet/rocketbullet.png"")); rocketimage = new utilitytool().scaleimage(rocketimage, gp.tilesize * 2, gp.tilesize * 2); } catch(ioexception e) { e.printstacktrace(); } if(rocketimage == null) { system.out.println(""rocketbullet resmi yüklenemedi!""); } else { system.out.println(""rocketbullet resmi yüklendi, boyut: "" + rocketimage.getwidth() + ""x"" + rocketimage.getheight()); } } @override public void draw(graphics2d g2) { int screenx = worldx - gp.player.worldx + gp.player.screenx; int screeny = worldy - gp.player.worldy + gp.player.screeny; g2.drawimage(rocketimage, screenx, screeny, null); } @override public java.awt.rectangle getsolidarea() { return new java.awt.rectangle(worldx, worldy, rocketimage.getwidth(), rocketimage.getheight()); } } package entity; import main.gamepanel; public class tankzombie extends entity { gamepanel gp; public tankzombie(gamepanel gp){ super(gp); this.gp = gp; direction = ""down""; speed = 1; damage = 2; maxlife = 3; life = maxlife; point = 200; solidarea.x = 3; solidarea.y = 18; solidarea.width = 42; solidarea.height = 30; solidareadefaultx = solidarea.x; solidareadefaulty = solidarea.y; getimage(); } public void getimage(){ up1 = setup(""/npc/tank_z_up1"", gp.tilesize, gp.tilesize); up2 = setup(""/npc/tank_z_up2"", gp.tilesize, gp.tilesize); down1 = setup(""/npc/tank_z_down1"", gp.tilesize, gp.tilesize); down2 = setup(""/npc/tank_z_down2"", gp.tilesize, gp.tilesize); left1 = setup(""/npc/tank_z_left1"", gp.tilesize, gp.tilesize); left2 = setup(""/npc/tank_z_left2"", gp.tilesize, gp.tilesize); right1 = setup(""/npc/tank_z_right1"", gp.tilesize, gp.tilesize); right2 = setup(""/npc/tank_z_right2"", gp.tilesize, gp.tilesize); } public void setaction() { int dx = gp.player.worldx - worldx; int dy = gp.player.worldy - worldy; if (math.abs(dx) > math.abs(dy)) { if (dx > 0) { direction = ""right""; } else { direction = ""left""; } } else { if (dy > 0) { direction = ""down""; } else { direction = ""up""; } } } } package entity; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.io.ioexception; import javax.imageio.imageio; import java.awt.graphics2d; import main.gamepanel; import main.utilitytool; public class acidbullet extends entity { public int worldx, worldy; public int dx, dy; public int speed = 5; public int damage = 1; public bufferedimage acidimage; public rectangle solidarea; public acidbullet(gamepanel gp, int startx, int starty, int targetx, int targety) { super(gp); this.worldx = startx; this.worldy = starty; int diffx = targetx - startx; int diffy = targety - starty; double distance = math.sqrt(diffx*diffx + diffy*diffy); dx = (int)math.round(diffx / distance * speed); dy = (int)math.round(diffy / distance * speed); setupacidimage(); system.out.println(""acidbullet oluşturuldu: startx="" + startx + "", starty="" + starty + "", targetx="" + targetx + "", targety="" + targety); } public void setupacidimage() { try { acidimage = imageio.read(getclass().getresourceasstream(""/bullet/aciddbullet.png"")); acidimage = new utilitytool().scaleimage(acidimage, gp.tilesize, gp.tilesize); } catch(ioexception e) { e.printstacktrace(); } if(acidimage == null) { system.out.println(""acidbullet resmi yüklenemedi!""); } else { system.out.println(""acidbullet resmi yüklendi, boyut: "" + acidimage.getwidth() + ""x"" + acidimage.getheight()); } } public void update() { worldx += dx; worldy += dy; } public void draw(graphics2d g2) { int screenx = worldx - gp.player.worldx + gp.player.screenx; int screeny = worldy - gp.player.worldy + gp.player.screeny; g2.drawimage(acidimage, screenx, screeny, null); } public java.awt.rectangle getsolidarea() { return new java.awt.rectangle(worldx, worldy, acidimage.getwidth(), acidimage.getheight()); } } package entity; import main.keyhandler; import weapons.gun; import weapons.weapons; import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; import java.util.arraylist; import main.gamepanel; public class player extends entity{ keyhandler keyh; public weapons currentweapon; public arraylist<weapons> weaponinventory; public int currentweaponindex; public final int screenx; public final int screeny; public int attacktimer = 0; public int totalpoint = 0; public player(gamepanel gp, keyhandler keyh){ super(gp); this.keyh = keyh; screenx = gp.screenwidth/2 - (gp.tilesize/2); screeny = gp.screenheight/2 - (gp.tilesize/2); solidarea = new rectangle(); solidarea.x = 8; solidarea.y = 16; solidarea.width = 32; solidarea.height = 32; currentweapon = new gun(gp, gp.fps); weaponinventory = new arraylist<>(); weaponinventory.add(new gun(gp, gp.fps)); currentweaponindex = 0; currentweapon = weaponinventory.get(currentweaponindex); setdefaultvalues(); getplayerimage(); } public void setdefaultvalues(){ worldx = gp.tilesize * 24; worldy = gp.tilesize * 23; speed = 4; direction = ""down""; //player status wave = 1; totalpoint = 0; maxlife = 6; life = maxlife; } public void resetposition(){ worldx = gp.tilesize * 24; worldy = gp.tilesize * 23; } public void getplayerimage(){ up1 = setup(""/player/boy_up_1"", gp.tilesize, gp.tilesize); up2 = setup(""/player/boy_up_2"", gp.tilesize, gp.tilesize); down1 = setup(""/player/boy_down_1"", gp.tilesize, gp.tilesize); down2 = setup(""/player/boy_down_2"", gp.tilesize, gp.tilesize); left1 = setup(""/player/boy_left_1"", gp.tilesize, gp.tilesize); left2 = setup(""/player/boy_left_2"", gp.tilesize, gp.tilesize); right1 = setup(""/player/boy_right_1"", gp.tilesize, gp.tilesize); right2 = setup(""/player/boy_right_2"", gp.tilesize, gp.tilesize); } public void switchweapon(int index){ if(index >= 0 && index < weaponinventory.size()){ currentweaponindex = index; currentweapon = weaponinventory.get(currentweaponindex); } } public void nextweapon(){ currentweaponindex = (currentweaponindex + 1) % weaponinventory.size(); currentweapon = weaponinventory.get(currentweaponindex); } public void previousweapon(){ currentweaponindex = (currentweaponindex - 1 + weaponinventory.size()) % weaponinventory.size(); currentweapon = weaponinventory.get(currentweaponindex); } public void update(){ currentweapon.cooldownupdate(); if(gunattack){ gunattacking(); } else if(keyh.uppressed || keyh.downpressed || keyh.leftpressed || keyh.rightpressed || keyh.spacepressed){ if(keyh.uppressed){ direction = ""up""; } else if(keyh.downpressed){ direction = ""down""; } else if(keyh.leftpressed){ direction = ""left""; } else if(keyh.rightpressed){ direction = ""right""; } //check tile collision collisionon = false; gp.cchecker.checktile(this); //check npc collision int npcindex = gp.cchecker.checkentity(this, gp.npc); //interactnpc(npcindex); contactzombie(npcindex); //if collision is false, player can move if(collisionon == false){ switch(direction){ case ""up"": worldy -= speed; break; case ""down"": worldy += speed; break; case ""left"": worldx -= speed; break; case ""right"": worldx += speed; break; } } spritecounter++; if(spritecounter > 12){ if(spritenum == 1){ spritenum = 2; } else if(spritenum == 2){ spritenum = 1; } spritecounter = 0; } } if(invincible){ invinciblecounter++; if(invinciblecounter > 60){ invincible = false; invinciblecounter = 0; } } if(life <= 0){ gp.gamestate = gp.gameoverstate; } } public void contactzombie(int i){ if(i != 999){ if(!invincible){ int damage = gp.npc[i].damage; if(damage < 0){ damage = 0; } life -= damage; invincible = true; } } } public void damagezombie(int i){ if(i != 999){ if(!(gp.npc[i].invincible)){ gp.npc[i].life -= 1; gp.npc[i].invincible = true; if(gp.npc[i].life <= 0){ gp.npc[i] = null; } } } } public void gunattacking(){ spritecounter++; if(spritecounter <= 10){ spritenum = 1; } else if(spritecounter <= 30){ spritenum = 2; } else{ spritenum = 1; spritecounter = 0; gunattack = false; } } public int[] getguntipposition() { // başlangıç olarak, oyuncunun ""worldx"" ve ""worldy"" si, // sprite’ın sol üst köşesini temsil eder. int spawnx = worldx; int spawny = worldy; switch(direction) { case ""up"": // yukarı bakarken sprite 16 genişlik, 32 yükseklik // karakterin merkezini bul, sonra biraz yukarı kaydır spawnx += gp.tilesize / 2 - 16; // ortalamak için spawny -= 8; // kılıç ucunu yakalamak için break; case ""down"": spawnx += gp.tilesize / 2 - 20; // aşağıya bakarken en alt tarafa inmek için tilesize kadar + ufak offset spawny += gp.tilesize + 8; break; case ""left"": // sola bakarken sprite 32 genişlik, 16 yükseklik // soldan biraz dışarı spawnx -= 8; spawny += gp.tilesize / 2 - 15; break; case ""right"": spawnx += gp.tilesize + 8; spawny += gp.tilesize / 2 - 15; break; } return new int[]{spawnx, spawny}; } public void draw(graphics2d g2){ bufferedimage image = null; int tempscreenx = screenx; int tempscreeny = screeny; switch(direction){ case ""up"": if(!gunattack){ if(spritenum == 1){image = up1;} if(spritenum == 2){image = up2;} } if(gunattack){ tempscreeny = screeny - gp.tilesize; if(spritenum == 1){image = currentweapon.weaponup1;} if(spritenum == 2){image = currentweapon.weaponup2;} } break; case ""down"": if(!gunattack){ if(spritenum == 1){image = down1;} if(spritenum == 2){image = down2;} } if(gunattack){ if(spritenum == 1){image = currentweapon.weapondown1;} if(spritenum == 2){image = currentweapon.weapondown2;} } break; case ""left"": if(!gunattack){ if(spritenum == 1){image = left1;} if(spritenum == 2){image = left2;} } if(gunattack){ tempscreenx = screenx - gp.tilesize; if(spritenum == 1){image = currentweapon.weaponleft1;} if(spritenum == 2){image = currentweapon.weaponleft2;} } break; case ""right"": if(!gunattack){ if(spritenum == 1){image = right1;} if(spritenum == 2){image = right2;} } if(gunattack){ if(spritenum == 1){image = currentweapon.weaponright1;} if(spritenum == 2){image = currentweapon.weaponright2;} } break; } g2.drawimage(image, tempscreenx, tempscreeny, null); } } package main; import java.util.random; import entity.crawlingzombie; import entity.acidzombie; import entity.entity; import entity.normalzombie; import entity.tankzombie; import weapons.rifle; import weapons.rocketlauncher; import weapons.sniper; import weapons.weapons; import weapons.shotgun; public class wavemanager { gamepanel gp; public int currentwave = 0; public wavemanager(gamepanel gp){ this.gp = gp; } public void startwave(){ int numberofzombies = 5 + currentwave*3; gp.npc = new entity[numberofzombies]; random rnd = new random(); int minx = gp.tilesize * 3; int maxx = gp.worldwidth - gp.tilesize*3; int miny = gp.tilesize * 3; int maxy = gp.worldheight - gp.tilesize*3; for (int i = 0; i < numberofzombies; i++) { int worldx = rnd.nextint(maxx - minx) + minx; int worldy = rnd.nextint(maxy - miny) + miny; if (currentwave < 3) { gp.npc[i] = new normalzombie(gp); } else if (currentwave < 6) { if (rnd.nextboolean()) { gp.npc[i] = new normalzombie(gp); } else { gp.npc[i] = new crawlingzombie(gp); } } else if (currentwave < 9) { if (rnd.nextint(100) < 50) { gp.npc[i] = new crawlingzombie(gp); } else { gp.npc[i] = new tankzombie(gp); } } else { int type = rnd.nextint(100); if (type < 40) { gp.npc[i] = new crawlingzombie(gp); } else if (type < 80) { gp.npc[i] = new tankzombie(gp); } else { gp.npc[i] = new acidzombie(gp); } } gp.npc[i].worldx = worldx; gp.npc[i].worldy = worldy; } system.out.println(""dalga "" + currentwave + "" başladı. zombi sayısı: "" + numberofzombies); } public boolean iswavefinished() { for (int i = 0; i < gp.npc.length; i++) { if (gp.npc[i] != null) { return false; } } return true; } public void nextwave() { if(currentwave >= 12) { gp.gamestate = gp.winstate; system.out.println(""tebrikler! oyunu kazandınız. dalga "" + currentwave + "" tamamlandı.""); return; } currentwave++; weapons newweapon = null; if (currentwave == 2) { newweapon = new rifle(gp, gp.fps); } else if (currentwave == 4) { newweapon = new shotgun(gp, gp.fps); } else if (currentwave == 6) { newweapon = new sniper(gp, gp.fps); } else if (currentwave == 11) { newweapon = new rocketlauncher(gp, gp.fps); } if(newweapon != null) { gp.player.weaponinventory.add(newweapon); gp.player.currentweapon = newweapon; gp.player.currentweaponindex = gp.player.weaponinventory.size() - 1; gp.newweaponmessage = ""new weapon: "" + newweapon.getclass().getsimplename(); gp.newweaponmessagetimer = gp.fps * 2; } gp.wavetext = ""wave "" + currentwave; gp.wavetexttime = gp.fps * 2; gp.player.resetposition(); // yeni dalgayı başlat startwave(); } } package main; import java.awt.graphics2d; import java.awt.image.bufferedimage; public class utilitytool { public bufferedimage scaleimage(bufferedimage original, int width, int height){ bufferedimage scaledimage = new bufferedimage(width, height, original.gettype()); graphics2d g2 = scaledimage.creategraphics(); g2.drawimage(original, 0, 0, width, height, null); g2.dispose(); return scaledimage; } } package main; import java.awt.event.mouseadapter; import java.awt.event.mouseevent; import java.awt.image.bufferedimage; import java.util.arraylist; import java.awt.color; import java.awt.dimension; import java.awt.graphics; import java.awt.graphics2d; import java.awt.rectangle; import java.util.collections; import java.util.comparator; import javax.swing.jpanel; import data.saveload; import entity.acidbullet; import entity.bullet; import entity.entity; import entity.player; import entity.rocketbullet; import tile.tilemanager; import weapons.gun; public class gamepanel extends jpanel implements runnable{ final int originaltilesize = 16; final int scale = 3; public final int tilesize = originaltilesize*scale; public final int maxscreencol = 16; public final int maxscreenrow = 12; public final int screenwidth = tilesize*maxscreencol; public final int screenheight = tilesize*maxscreenrow; //world settings public final int maxworldcol = 50; public final int maxworldrow = 50; public final int worldwidth = tilesize * maxworldcol; public final int worldheight = tilesize * maxworldrow; //for full screen int screenwidth2 = screenwidth; int screenheight2 = screenheight; bufferedimage tempscreen; graphics2d g2; public int fps = 60; tilemanager tilem = new tilemanager(this); saveload saveload = new saveload(this); keyhandler keyh = new keyhandler(this); public string wavetext = """"; public int wavetexttime = 0; public string newweaponmessage = """"; public int newweaponmessagetimer = 0; public wavemanager wavemanager; public collisionchecker cchecker = new collisionchecker(this); public ui ui = new ui(this); thread gamethread; public player player = new player(this, keyh); public assetsetter asetter = new assetsetter(this); //npc public int initialnpcarraysize = 10; public entity npc[] = new entity[10]; arraylist<entity> entitylist = new arraylist<>(); //game state public int gamestate; public final int titlestate = 0; public final int playstate = 1; public final int pausestate = 2; public final int characterstate = 3; public final int gameoverstate = 4; public final int winstate = 5; //bullet public arraylist<bullet> bulletlist = new arraylist<>(); public int mousex, mousey; public arraylist<acidbullet> acidbulletlist = new arraylist<>(); public arraylist<rocketbullet> rocketbulletlist = new arraylist<>(); public gamepanel(){ this.setpreferredsize(new dimension(screenwidth, screenheight)); this.setbackground(color.black); this.setdoublebuffered(true); this.addkeylistener(keyh); wavemanager = new wavemanager(this); this.setfocusable(true); this.addmouselistener(new mouseadapter() { @override public void mousepressed(mouseevent e) { if(e.getbutton() == mouseevent.button1) { int mousex = e.getx(); int mousey = e.gety(); int[] spawnpos = player.getguntipposition(); int targetx = player.worldx + (mousex - player.screenx); int targety = player.worldy + (mousey - player.screeny); player.gunattack = true; arraylist<bullet> bullets = player.currentweapon.attacktozombie(gamepanel.this, spawnpos[0], spawnpos[1], targetx, targety); for(bullet b : bullets) { bulletlist.add(b); } } } }); } public void setupgame(){ asetter.setnpc(); gamestate = titlestate; wavemanager.nextwave(); } public void resetgame(){ player.setdefaultvalues(); player.totalpoint = 0; player.weaponinventory.clear(); player.weaponinventory.add(new gun(this, fps)); player.currentweaponindex = 0; player.currentweapon = player.weaponinventory.get(0); wavemanager.currentwave = 1; wavetext = ""wave "" + wavemanager.currentwave; wavetexttime = fps * 3; wavemanager.startwave(); bulletlist.clear(); acidbulletlist.clear(); } public void startgamethread(){ gamethread = new thread(this); gamethread.start(); } @override public void run() { double drawinterval = 1000000000/fps; double delta = 0; long lasttime =system.nanotime(); long currenttime; while(gamethread != null){ currenttime = system.nanotime(); delta += (currenttime - lasttime) / drawinterval; lasttime = currenttime; if(delta >= 1){ update(); repaint(); delta--; } } } public void update(){ if(gamestate == playstate){ //player player.update(); if(wavetexttime <= 0){ for(int i = 0; i<npc.length; i++){ if(npc[i] != null){ npc[i].update(); } } } for (int i = bulletlist.size() - 1; i >= 0; i--) { bullet b = bulletlist.get(i); b.update(); if(b.explosive){ int bulletcenterx = b.worldx + b.bulletimage.getwidth() / 2; int bulletcentery = b.worldy + b.bulletimage.getheight() / 2; for (int j = 0; j < npc.length; j++) { if (npc[j] != null) { int zombiecenterx = npc[j].worldx + npc[j].solidarea.x + npc[j].solidarea.width / 2; int zombiecentery = npc[j].worldy + npc[j].solidarea.y + npc[j].solidarea.height / 2; double distance = math.sqrt(math.pow(bulletcenterx - zombiecenterx, 2) + math.pow(bulletcentery - zombiecentery, 2)); if (distance <= b.explosionradius) { npc[j].life -= b.damage; if (npc[j].life <= 0) { player.totalpoint += npc[j].point; npc[j] = null; } } } } if(b.explosiontimer > 0) { b.explosiontimer--; } else { bulletlist.remove(i); } } else{ for (int j = 0; j < npc.length; j++) { if(npc[j] != null) { rectangle npcrect = new rectangle( npc[j].worldx + npc[j].solidarea.x, npc[j].worldy + npc[j].solidarea.y, npc[j].solidarea.width, npc[j].solidarea.height ); if(b.getsolidarea().intersects(npcrect)) { npc[j].life -= b.damage; if(npc[j].life <= 0) { player.totalpoint += npc[j].point; npc[j] = null; } if(!b.piercing){ bulletlist.remove(i); break; } } } } } } for (int i = acidbulletlist.size() - 1; i >= 0; i--) { acidbullet ab = acidbulletlist.get(i); ab.update(); java.awt.rectangle acidrect = ab.getsolidarea(); java.awt.rectangle playerrect = new java.awt.rectangle( player.worldx + player.solidarea.x, player.worldy + player.solidarea.y, player.solidarea.width, player.solidarea.height ); if(acidrect.intersects(playerrect)) { if(!player.invincible) { player.life -= ab.damage; player.invincible = true; } acidbulletlist.remove(i); continue; } } for (int i = rocketbulletlist.size() - 1; i >= 0; i--) { rocketbullet rb = rocketbulletlist.get(i); rb.update(); if(rb.worldx < 0 || rb.worldx > worldwidth || rb.worldy < 0 || rb.worldy > worldheight) { rocketbulletlist.remove(i); continue; } } if(wavemanager.iswavefinished()){ wavemanager.nextwave(); } } if(gamestate == pausestate){ } } public void paintcomponent(graphics g){ super.paintcomponent(g); graphics2d g2 = (graphics2d)g; //title screen if(gamestate == titlestate){ ui.draw(g2); } //others else{ //tile tilem.draw(g2); //add entities to the list entitylist.add(player); for(int i = 0; i<npc.length; i++){ if(npc[i] != null){ entitylist.add(npc[i]); } } //sort collections.sort(entitylist, new comparator<entity>() { @override public int compare(entity e1, entity e2) { int result = integer.compare(e1.worldy, e2.worldy); return result; } }); //draw entities for(int i = 0; i<entitylist.size(); i++){ entitylist.get(i).draw(g2); } //empty entity list entitylist.clear(); for(bullet b: bulletlist){ b.draw(g2); } for (acidbullet ab : acidbulletlist) { ab.draw(g2); } for(rocketbullet rb : rocketbulletlist) { rb.draw(g2); } //ui ui.draw(g2); } g2.dispose(); } } package main; import java.awt.basicstroke; import java.awt.color; import java.awt.font; import java.awt.graphics2d; import java.awt.image.bufferedimage; import java.io.ioexception; import javax.imageio.imageio; import weapons.weapons; public class ui { gamepanel gp; font arial; graphics2d g2; public int commandnum = 0; bufferedimage heartfull, hearthalf, heartempty; public ui(gamepanel gp){ this.gp = gp; arial = new font(""arial"", font.bold, 27); loadheartimages(); } public void draw(graphics2d g2){ this.g2 = g2; g2.setfont(arial); g2.setcolor(color.white); //title state if(gp.gamestate == gp.titlestate){ drawtitlescreen(); } //play state if(gp.gamestate == gp.playstate){ drawplayerlife(); drawgunandremainingbullet(); drawpoint(); drawwavetext(); drawnewweaponmessage(); } //pause state if(gp.gamestate == gp.pausestate){ drawplayerlife(); drawpausescreen(); } //character state if(gp.gamestate == gp.characterstate){ drawcharacterscreen(); } //game over state if(gp.gamestate == gp.gameoverstate){ drawgameoverscreen(); } //win state if(gp.gamestate == gp.winstate){ drawwinstate(); } } public void drawgameoverscreen(){ g2.setcolor(new color(0,0,0,150)); g2.fillrect(0, 0, gp.screenwidth, gp.screenheight); int x ; int y ; string text; g2.setfont(g2.getfont().derivefont(font.bold, 90f)); text = ""game over""; g2.setcolor(color.black); x = getxforcenteredtext(text); y = gp.tilesize*5; g2.drawstring(text, x, y); g2.setcolor(color.white); g2.drawstring(text, x-4, y-4); //back to main menu g2.setfont(g2.getfont().derivefont(35f)); text = ""main menu""; x = getxforcenteredtext(text); y += gp.tilesize*4; g2.drawstring(text, x, y); if(commandnum == 0){ g2.drawstring("">"", x-40, y); } //exit text = ""exit""; x = getxforcenteredtext(text); y += 55; g2.drawstring(text, x, y); if(commandnum == 1){ g2.drawstring("">"", x-40, y); } } public void drawwinstate(){ g2.setcolor(new color(0,0,0,150)); g2.fillrect(0, 0, gp.screenwidth, gp.screenheight); int x ; int y ; string text; g2.setfont(g2.getfont().derivefont(font.bold, 90f)); text = ""you win!""; g2.setcolor(color.yellow); x = getxforcenteredtext(text); y = gp.tilesize*5; g2.drawstring(text, x, y); g2.setcolor(color.white); g2.drawstring(text, x-4, y-4); //back to main menu g2.setfont(g2.getfont().derivefont(35f)); text = ""main menu""; x = getxforcenteredtext(text); y += gp.tilesize*4; g2.drawstring(text, x, y); if(commandnum == 0){ g2.drawstring("">"", x-40, y); } //exit text = ""exit""; x = getxforcenteredtext(text); y += 55; g2.drawstring(text, x, y); if(commandnum == 1){ g2.drawstring("">"", x-40, y); } } public void drawgunandremainingbullet(){ int x = 20; int y = 40; g2.setcolor(color.white); g2.setfont(g2.getfont().derivefont(font.bold, 25)); string weaponname = gp.player.currentweapon.getclass().getsimplename(); int remainingbullet = gp.player.currentweapon.getremainingbullet(); string text = ""weapon: "" + weaponname + "" | bullet: "" + remainingbullet; g2.drawstring(text, x, y); } public void drawpoint(){ string point = ""total point: "" + gp.player.totalpoint; int heartareax = gp.screenwidth - (gp.tilesize * (gp.player.maxlife / 2)) - gp.tilesize; int x = heartareax; int y = (gp.tilesize / 2) - 2; g2.setcolor(color.white); g2.setfont(g2.getfont().derivefont(font.bold, 21)); g2.drawstring(point, x, y); } public void drawplayerlife(){ int x = gp.screenwidth - (gp.tilesize * (gp.player.maxlife / 2)) - gp.tilesize; int y = gp.tilesize/2; int i=0; //draw max life while(i < gp.player.maxlife/2){ g2.drawimage(heartempty, x, y, null); i++; x += gp.tilesize; } //reset x = gp.screenwidth - (gp.tilesize * (gp.player.maxlife / 2)) - gp.tilesize; y = gp.tilesize/2; i=0; //draw current life while(i < gp.player.life){ g2.drawimage(hearthalf, x, y, null); i++; if(i < gp.player.life){ g2.drawimage(heartfull, x, y, null); } i++; x += gp.tilesize; } } public void loadheartimages(){ heartfull = setup(""/heart/full_heart""); hearthalf = setup(""/heart/half_heart""); heartempty = setup(""/heart/empty_heart""); } public bufferedimage setup(string imagepath){ utilitytool utool = new utilitytool(); bufferedimage image = null; try{ image = imageio.read(getclass().getresourceasstream( imagepath + "".png"")); image = utool.scaleimage(image, gp.tilesize, gp.tilesize); } catch(ioexception e){ e.printstacktrace(); } return image; } public void drawtitlescreen(){ g2.setcolor(new color(0,0,0)); g2.fillrect(0, 0, gp.screenwidth, gp.screenheight); //title name g2.setfont(g2.getfont().derivefont(font.italic, 70)); string text = ""top-down shooter""; int x = getxforcenteredtext(text); int y = gp.tilesize*3; //shadow g2.setcolor(color.gray); g2.drawstring(text, x+4, y+4); //main color g2.setcolor(color.white); g2.drawstring(text, x, y); //zombie image x = gp.screenwidth/2 - (gp.tilesize*2)/2; y += gp.tilesize*2; g2.drawimage(gp.player.down1, x, y, gp.tilesize*2, gp.tilesize*2, null); //menu g2.setfont(g2.getfont().derivefont(font.bold, 36)); text = ""new game""; x = getxforcenteredtext(text); y += gp.tilesize*3; g2.drawstring(text, x, y); if(commandnum == 0){ g2.drawstring("">"", x - gp.tilesize, y); } text = ""load game""; x = getxforcenteredtext(text); y += gp.tilesize; g2.drawstring(text, x, y); if(commandnum == 1){ g2.drawstring("">"", x - gp.tilesize, y); } text = ""quit""; x = getxforcenteredtext(text); y += gp.tilesize; g2.drawstring(text, x, y); if(commandnum == 2){ g2.drawstring("">"", x - gp.tilesize, y); } } public void drawpausescreen(){ color c = new color(0, 0, 0, 185); g2.setcolor(c); g2.fillrect(0, 0, gp.screenwidth, gp.screenheight); g2.setfont(g2.getfont().derivefont(font.bold, 70)); string text = ""paused""; int x = getxforcenteredtext(text); int y = gp.tilesize*3; g2.setcolor(color.gray); g2.drawstring(text, x+4, y+4); g2.setcolor(color.white); g2.drawstring(text, x, y); g2.setfont(g2.getfont().derivefont(font.bold, 36)); text = ""resume""; x = getxforcenteredtext(text); y += gp.tilesize*3; g2.drawstring(text, x, y); if(commandnum == 0){ g2.drawstring("">"", x - gp.tilesize, y); } text = ""save game""; x = getxforcenteredtext(text); y += gp.tilesize; g2.drawstring(text, x, y); if(commandnum == 1){ g2.drawstring("">"", x - gp.tilesize, y); } text = ""exit""; x = getxforcenteredtext(text); y += gp.tilesize; g2.drawstring(text, x, y); if(commandnum == 2){ g2.drawstring("">"", x - gp.tilesize, y); } } public int getxforcenteredtext(string text){ int length = (int)g2.getfontmetrics().getstringbounds(text, g2).getwidth(); int x = gp.screenwidth/2 - length/2; return x; } public void drawwavetext(){ if(gp.wavetexttime > 0){ g2.setfont(g2.getfont().derivefont(font.bold, 70)); g2.setcolor(new color(204, 0, 3)); string text = gp.wavetext; int x = getxforcenteredtext(text); int y = gp.screenheight / 3; g2.drawstring(text, x, y); gp.wavetexttime--; } } public void drawnewweaponmessage(){ if(gp.newweaponmessagetimer > 0) { g2.setfont(g2.getfont().derivefont(font.bold, 40f)); g2.setcolor(color.black); int x = getxforcenteredtext(gp.newweaponmessage); int y = gp.tilesize + 50; g2.drawstring(gp.newweaponmessage, x, y); gp.newweaponmessagetimer--; } } public void drawcharacterscreen() { final int framex = gp.tilesize; final int framey = gp.tilesize; final int framewidth = gp.tilesize * 7; final int frameheight = gp.tilesize * 10; drawsubwindow(framex, framey, framewidth, frameheight); g2.setcolor(color.white); g2.setfont(g2.getfont().derivefont(20f)); int textx = framex + 20; int texty = framey + gp.tilesize; final int lineheight = 35; // tail x (sağ hizalama için) int tailx = (framex + framewidth) - 30; // 1) wave g2.drawstring(""wave"", textx, texty); string value = string.valueof(gp.wavemanager.currentwave); int xaligned = getxforaligntorighttext(value, tailx); g2.drawstring(value, xaligned, texty); texty += lineheight; // 2) life g2.drawstring(""life"", textx, texty); value = string.valueof(gp.player.life); xaligned = getxforaligntorighttext(value, tailx); g2.drawstring(value, xaligned, texty); texty += lineheight; // 3) weapon g2.drawstring(""weapon"", textx, texty); value = gp.player.currentweapon.getclass().getsimplename(); xaligned = getxforaligntorighttext(value, tailx); g2.drawstring(value, xaligned, texty); texty += lineheight; // 4) available weapons g2.drawstring(""available weapons"", textx, texty); texty += lineheight; int weaponlistx = textx + 20; for (weapons w : gp.player.weaponinventory) { string weaponname = w.getclass().getsimplename(); g2.drawstring(weaponname, weaponlistx, texty); texty += lineheight; } // 5) total point g2.drawstring(""total point"", textx, texty); value = string.valueof(gp.player.totalpoint); xaligned = getxforaligntorighttext(value, tailx); g2.drawstring(value, xaligned, texty); } public void drawsubwindow(int x, int y, int widht, int height){ color c = new color(0, 0, 0, 210); g2.setcolor(c); g2.fillroundrect(x, y, widht, height, 35, 35); c = new color(255, 255, 255); g2.setcolor(c); g2.setstroke(new basicstroke(5)); g2.drawroundrect(x+5, y+5, widht-10, height-10, 25, 25); } public int getxforaligntorighttext(string text, int tailx){ int length = (int)g2.getfontmetrics().getstringbounds(text, g2).getwidth(); int x = tailx - length; return x; } } package main; import entity.crawlingzombie; import entity.normalzombie; import entity.acidzombie; public class assetsetter { gamepanel gp; public assetsetter(gamepanel gp){ this.gp = gp; } public void setnpc(){ gp.npc[0] = new normalzombie(gp); gp.npc[0].worldx = gp.tilesize*21; gp.npc[0].worldy = gp.tilesize*21; gp.npc[1] = new normalzombie(gp); gp.npc[1].worldx = gp.tilesize*11; gp.npc[1].worldy = gp.tilesize*21; gp.npc[2] = new normalzombie(gp); gp.npc[2].worldx = gp.tilesize*31; gp.npc[2].worldy = gp.tilesize*21; gp.npc[3] = new crawlingzombie(gp); gp.npc[3].worldx = gp.tilesize*38; gp.npc[3].worldy = gp.tilesize*21; gp.npc[4] = new crawlingzombie(gp); gp.npc[4].worldx = gp.tilesize*43; gp.npc[4].worldy = gp.tilesize*21; gp.npc[5] = new acidzombie(gp); gp.npc[5].worldx = gp.tilesize*2; gp.npc[5].worldy = gp.tilesize*21; gp.npc[7] = new acidzombie(gp); gp.npc[7].worldx = gp.tilesize*25; gp.npc[7].worldy = gp.tilesize*25; } } package main; import java.awt.event.keyevent; import java.awt.event.keylistener; public class keyhandler implements keylistener{ gamepanel gp; public boolean uppressed, downpressed, leftpressed, rightpressed, enterpressed, spacepressed; public keyhandler(gamepanel gp){ this.gp = gp; } @override public void keytyped(keyevent e) { } public boolean attackrequested = false; @override public void keypressed(keyevent e) { int code = e.getkeycode(); // getkeycode returns the number of the key that was pressed //title state if(gp.gamestate == gp.titlestate){ if(code == keyevent.vk_w){ gp.ui.commandnum--; if(gp.ui.commandnum < 0){ gp.ui.commandnum = 2; } } if(code == keyevent.vk_s){ gp.ui.commandnum++; if(gp.ui.commandnum > 2){ gp.ui.commandnum = 0; } } if(code == keyevent.vk_enter){ if(gp.ui.commandnum == 0){ gp.resetgame(); gp.gamestate = gp.playstate; } if(gp.ui.commandnum == 1){ gp.saveload.load(); gp.gamestate = gp.playstate; } if(gp.ui.commandnum == 2){ system.exit(0); } } } //play state else if(gp.gamestate == gp.playstate){ if(code == keyevent.vk_w){ uppressed = true; } if(code == keyevent.vk_a){ leftpressed = true; } if(code == keyevent.vk_s){ downpressed = true; } if(code == keyevent.vk_d){ rightpressed = true; } if(code == keyevent.vk_p){ gp.gamestate = gp.pausestate; } if(code == keyevent.vk_space){ spacepressed = true; attackrequested = true; } if(code == keyevent.vk_r){ gp.player.currentweapon.reloadmagazine(); } if(code == keyevent.vk_q){ gp.player.previousweapon(); } if(code == keyevent.vk_e){ gp.player.nextweapon(); } if(code == keyevent.vk_c){ gp.gamestate = gp.characterstate; } } //pause state else if(gp.gamestate == gp.pausestate){ if(code == keyevent.vk_p){ gp.gamestate = gp.playstate; } if(code == keyevent.vk_w){ gp.ui.commandnum--; if(gp.ui.commandnum < 0){ gp.ui.commandnum = 2; } } if(code == keyevent.vk_s){ gp.ui.commandnum++; if(gp.ui.commandnum > 2){ gp.ui.commandnum = 0; } } if(code == keyevent.vk_enter){ if(gp.ui.commandnum == 0){ gp.gamestate = gp.playstate; } else if(gp.ui.commandnum == 1){ gp.saveload.save(); } else if(gp.ui.commandnum == 2){ system.exit(0); } } } //character state else if(gp.gamestate == gp.characterstate){ if(code == keyevent.vk_c){ gp.gamestate = gp.playstate; } } //game over state else if(gp.gamestate == gp.gameoverstate){ if(code == keyevent.vk_w){ gp.ui.commandnum--; if(gp.ui.commandnum < 0){ gp.ui.commandnum = 1; } } if(code == keyevent.vk_s){ gp.ui.commandnum++; if(gp.ui.commandnum < 1){ gp.ui.commandnum = 0; } } if(code == keyevent.vk_enter){ if(gp.ui.commandnum == 0){ gp.gamestate = gp.titlestate; } else if(gp.ui.commandnum == 1){ system.exit(0); } } } //game win state else if(gp.gamestate == gp.winstate){ if(code == keyevent.vk_w){ gp.ui.commandnum--; if(gp.ui.commandnum < 0){ gp.ui.commandnum = 1; } } if(code == keyevent.vk_s){ gp.ui.commandnum++; if(gp.ui.commandnum < 1){ gp.ui.commandnum = 0; } } if(code == keyevent.vk_enter){ if(gp.ui.commandnum == 0){ gp.gamestate = gp.titlestate; } else if(gp.ui.commandnum == 1){ system.exit(0); } } } } @override public void keyreleased(keyevent e) { int code = e.getkeycode(); if(code == keyevent.vk_w){ uppressed = false; } if(code == keyevent.vk_a){ leftpressed = false; } if(code == keyevent.vk_s){ downpressed = false; } if(code == keyevent.vk_d){ rightpressed = false; } if(code == keyevent.vk_enter){ enterpressed = false; } if(code == keyevent.vk_space){ spacepressed = false; } } } package main; import javax.swing.jframe; public class game { public static void main(string[] args) { jframe window = new jframe(); window.setdefaultcloseoperation(jframe.exit_on_close); window.setresizable(false); window.settitle(""top_down_shooter""); gamepanel gamepanel = new gamepanel(); window.add(gamepanel); window.pack(); window.setlocationrelativeto(null); window.setvisible(true); gamepanel.setupgame(); gamepanel.startgamethread(); } } package main; import entity.entity; public class collisionchecker { gamepanel gp; public collisionchecker(gamepanel gp){ this.gp = gp; } public void checktile(entity entity){ int entityleftworldx = entity.worldx + entity.solidarea.x; int entityrightworldx = entity.worldx + entity.solidarea.x + entity.solidarea.width; int entitytopworldy = entity.worldy + entity.solidarea.y; int entitybottomworldy = entity.worldy + entity.solidarea.y + entity.solidarea.height; int entityleftcol = entityleftworldx/gp.tilesize; int entityrightcol = entityrightworldx/gp.tilesize; int entitytoprow = entitytopworldy/gp.tilesize; int entitybottomrow = entitybottomworldy/gp.tilesize; int tilenum1; int tilenum2; if(entityleftcol < 0 || entityrightcol >= gp.maxworldcol || entitytoprow < 0 || entitybottomrow >= gp.maxworldrow){ entity.collisionon = true; return; } switch(entity.direction){ case ""up"": entitytoprow = (entitytopworldy - entity.speed)/gp.tilesize; tilenum1 = gp.tilem.maptilenum[entityleftcol][entitytoprow]; tilenum2 = gp.tilem.maptilenum[entityrightcol][entitytoprow]; if(gp.tilem.tile[tilenum1].collision == true || gp.tilem.tile[tilenum2].collision == true){ entity.collisionon = true; } break; case ""down"": entitybottomrow = (entitybottomworldy + entity.speed)/gp.tilesize; tilenum1 = gp.tilem.maptilenum[entityleftcol][entitybottomrow]; tilenum2 = gp.tilem.maptilenum[entityrightcol][entitybottomrow]; if(gp.tilem.tile[tilenum1].collision == true || gp.tilem.tile[tilenum2].collision == true){ entity.collisionon = true; } break; case ""left"": entityleftcol = (entityleftworldx - entity.speed)/gp.tilesize; tilenum1 = gp.tilem.maptilenum[entityleftcol][entitytoprow]; tilenum2 = gp.tilem.maptilenum[entityleftcol][entitybottomrow]; if(gp.tilem.tile[tilenum1].collision == true || gp.tilem.tile[tilenum2].collision == true){ entity.collisionon = true; } break; case ""right"": entityrightcol = (entityrightworldx + entity.speed)/gp.tilesize; tilenum1 = gp.tilem.maptilenum[entityrightcol][entitytoprow]; tilenum2 = gp.tilem.maptilenum[entityrightcol][entitybottomrow]; if(gp.tilem.tile[tilenum1].collision == true || gp.tilem.tile[tilenum2].collision == true){ entity.collisionon = true; } break; } } public int checkentity(entity entity, entity[] target){ int index = 999; for(int i= 0; i < target.length; i++){ if(target[i] != null){ entity.solidarea.x = entity.worldx + entity.solidarea.x; entity.solidarea.y = entity.worldy + entity.solidarea.y; target[i].solidarea.x = target[i].worldx + target[i].solidarea.x; target[i].solidarea.y = target[i].worldy + target[i].solidarea.y; switch(entity.direction){ case ""up"": entity.solidarea.y -= entity.speed; break; case ""down"": entity.solidarea.y += entity.speed; break; case ""left"": entity.solidarea.x -= entity.speed; break; case ""right"": entity.solidarea.x += entity.speed; break; } if(entity.solidarea.intersects(target[i].solidarea)){ if(target[i] != entity){ entity.collisionon = true; index = i; } } entity.solidarea.x = entity.solidareadefaultx; entity.solidarea.y = entity.solidareadefaulty; target[i].solidarea.x = target[i].solidareadefaultx; target[i].solidarea.y = target[i].solidareadefaulty; } } return index; } public boolean checkplayer(entity entity){ boolean contactplayer = false; entity.solidarea.x = entity.worldx + entity.solidarea.x; entity.solidarea.y = entity.worldy + entity.solidarea.y; gp.player.solidarea.x = gp.player.worldx + gp.player.solidarea.x; gp.player.solidarea.y = gp.player.worldy + gp.player.solidarea.y; switch(entity.direction){ case ""up"": entity.solidarea.y -= entity.speed; break; case ""down"": entity.solidarea.y += entity.speed; break; case ""left"": entity.solidarea.x -= entity.speed; break; case ""right"": entity.solidarea.x += entity.speed; break; } if(entity.solidarea.intersects(gp.player.solidarea)){ entity.collisionon = true; contactplayer = true; } entity.solidarea.x = entity.solidareadefaultx; entity.solidarea.y = entity.solidareadefaulty; gp.player.solidarea.x = gp.player.solidareadefaultx; gp.player.solidarea.y = gp.player.solidareadefaulty; return contactplayer; } } package weapons; import java.util.arraylist; import entity.bullet; import main.gamepanel; public class sniper extends weapons { public sniper(gamepanel gp, int fps) { super(gp, 5, 30, fps); getweaponimage(); } public void getweaponimage(){ weaponup1 = setup(""/player/boy_sniper_up"", gp.tilesize, gp.tilesize*2); weaponup2 = setup(""/player/boy_sniper_up"", gp.tilesize, gp.tilesize*2); weapondown1 = setup(""/player/boy_sniper_down"", gp.tilesize, gp.tilesize*2); weapondown2 = setup(""/player/boy_sniper_down"", gp.tilesize, gp.tilesize*2); weaponleft1 = setup(""/player/boy_sniper_left"", gp.tilesize*2, gp.tilesize); weaponleft2 = setup(""/player/boy_sniper_left"", gp.tilesize*2, gp.tilesize); weaponright1 = setup(""/player/boy_sniper_right"", gp.tilesize*2, gp.tilesize); weaponright2 = setup(""/player/boy_sniper_right"", gp.tilesize*2, gp.tilesize); } public arraylist<bullet> attacktozombie(gamepanel gp, int startx, int starty, int targetx, int targety) { arraylist<bullet> firedbullets = new arraylist<>(); if(!canfire()){ return firedbullets; } remainingbulletnum--; currentcooldown = cooldownframes; bullet newbullet = new bullet(gp, startx, starty, targetx, targety); newbullet.damage = 1; newbullet.piercing = true; firedbullets.add(newbullet); return firedbullets; } } package weapons; import java.util.arraylist; import entity.bullet; import main.gamepanel; public class gun extends weapons{ public gun(gamepanel gp, int fps){ super(gp, 12, 120, fps); getweaponimage(); } public void getweaponimage(){ weaponup1 = setup(""/player/boy_gun_up1"", gp.tilesize, gp.tilesize*2); weaponup2 = setup(""/player/boy_gun_up2"", gp.tilesize, gp.tilesize*2); weapondown1 = setup(""/player/boy_gun_down1"", gp.tilesize, gp.tilesize*2); weapondown2 = setup(""/player/boy_gun_down2"", gp.tilesize, gp.tilesize*2); weaponleft1 = setup(""/player/boy_gun_left1"", gp.tilesize*2, gp.tilesize); weaponleft2 = setup(""/player/boy_gun_left2"", gp.tilesize*2, gp.tilesize); weaponright1 = setup(""/player/boy_gun_right1"", gp.tilesize*2, gp.tilesize); weaponright2 = setup(""/player/boy_gun_right2"", gp.tilesize*2, gp.tilesize); } public arraylist<bullet> attacktozombie(gamepanel gp, int startx, int starty, int targetx, int targety){ arraylist<bullet> firedbullets = new arraylist<>(); if(!canfire()){ return firedbullets; } remainingbulletnum--; currentcooldown = cooldownframes; bullet newbullet = new bullet(gp, startx, starty, targetx, targety); firedbullets.add(newbullet); return firedbullets; } } package weapons; import java.util.arraylist; import entity.bullet; import main.gamepanel; public class shotgun extends weapons{ public shotgun(gamepanel gp, int fps){ super(gp,5, 60, fps); getweaponimage(); } public void getweaponimage(){ weaponup1 = setup(""/player/boy_shotgun_up"", gp.tilesize, gp.tilesize*2); weaponup2 = setup(""/player/boy_shotgun_up"", gp.tilesize, gp.tilesize*2); weapondown1 = setup(""/player/boy_shotgun_down"", gp.tilesize, gp.tilesize*2); weapondown2 = setup(""/player/boy_shotgun_down"", gp.tilesize, gp.tilesize*2); weaponleft1 = setup(""/player/boy_shotgun_left"", gp.tilesize*2, gp.tilesize); weaponleft2 = setup(""/player/boy_shotgun_left"", gp.tilesize*2, gp.tilesize); weaponright1 = setup(""/player/boy_shotgun_right"", gp.tilesize*2, gp.tilesize); weaponright2 = setup(""/player/boy_shotgun_right"", gp.tilesize*2, gp.tilesize); } public arraylist<bullet> attacktozombie(gamepanel gp, int startx, int starty, int targetx, int targety){ arraylist<bullet> firedbullets = new arraylist<>(); if(!canfire()){ return firedbullets; } int pelletcount = 9; double diffx = targetx - startx; double diffy = targety - starty; double baseangle = math.atan2(diffy, diffx); int midindex = pelletcount / 2; for (int i = 0; i < pelletcount; i++) { double angleoffset = (i - midindex) * 5.0; double finalangle = baseangle + math.toradians(angleoffset); int newtargetx = startx + (int)(math.cos(finalangle) * 1000); int newtargety = starty + (int)(math.sin(finalangle) * 1000); bullet newbullet = new bullet(gp, startx, starty, newtargetx, newtargety); firedbullets.add(newbullet); } remainingbulletnum--; system.out.println(""kalan mermi: "" + remainingbulletnum); currentcooldown = cooldownframes; return firedbullets; } } package weapons; import java.util.arraylist; import javax.imageio.imageio; import java.awt.image.bufferedimage; import java.io.ioexception; import entity.bullet; import main.gamepanel; import main.utilitytool; public abstract class weapons { gamepanel gp; public int magazinecapacity; public int remainingbulletnum; public int firerate; public int cooldownframes; public int currentcooldown = 0; public int fps; public bufferedimage weaponup1, weaponup2, weapondown1, weapondown2, weaponleft1, weaponleft2, weaponright1, weaponright2; public weapons(gamepanel gp, int magazinecapacity, int firerate, int fps){ this.gp = gp; this.magazinecapacity = magazinecapacity; this.remainingbulletnum = magazinecapacity; this.firerate = firerate; this.fps = fps; this.cooldownframes = (fps * 60) / firerate; } public void cooldownupdate() { if (currentcooldown > 0) { currentcooldown--; } } public boolean canfire(){ if(currentcooldown == 0 && remainingbulletnum > 0){ return true; } else{ return false; } } public bufferedimage setup(string imagepath, int widht, int height){ utilitytool utool = new utilitytool(); bufferedimage image = null; try{ image = imageio.read(getclass().getresourceasstream( imagepath + "".png"")); image = utool.scaleimage(image, widht, height); } catch(ioexception e){ e.printstacktrace(); } return image; } public abstract void getweaponimage(); public abstract arraylist<bullet> attacktozombie(gamepanel gp, int startx, int starty, int targetx, int targety); public void reloadmagazine(){ remainingbulletnum = magazinecapacity; } public int getmagazinecapacity(){ return magazinecapacity; } public int getremainingbullet(){ return remainingbulletnum; } public string tostring(){ return getclass().getsimplename(); } } package weapons; import java.util.arraylist; import java.util.random; import entity.bullet; import main.gamepanel; public class rifle extends weapons { public rifle(gamepanel gp, int fps) { super(gp, 30, 600, fps); getweaponimage(); } public void getweaponimage(){ weaponup1 = setup(""/player/boy_rifle_up"", gp.tilesize, gp.tilesize*2); weaponup2 = setup(""/player/boy_rifle_up"", gp.tilesize, gp.tilesize*2); weapondown1 = setup(""/player/boy_rifle_down"", gp.tilesize, gp.tilesize*2); weapondown2 = setup(""/player/boy_rifle_down"", gp.tilesize, gp.tilesize*2); weaponleft1 = setup(""/player/boy_rifle_left"", gp.tilesize*2, gp.tilesize); weaponleft2 = setup(""/player/boy_rifle_left"", gp.tilesize*2, gp.tilesize); weaponright1 = setup(""/player/boy_rifle_right"", gp.tilesize*2, gp.tilesize); weaponright2 = setup(""/player/boy_rifle_right"", gp.tilesize*2, gp.tilesize); } public arraylist<bullet> attacktozombie(gamepanel gp, int startx, int starty, int targetx, int targety) { arraylist<bullet> firedbullets = new arraylist<>(); if(!canfire()){ return firedbullets; } remainingbulletnum--; currentcooldown = cooldownframes; double diffx = targetx - startx; double diffy = targety - starty; double baseangle = math.atan2(diffy, diffx); random rand = new random(); int deviationdegrees = rand.nextint(61) - 30; double finalangle = baseangle + math.toradians(deviationdegrees); int newtargetx = startx + (int)(math.cos(finalangle) * 1000); int newtargety = starty + (int)(math.sin(finalangle) * 1000); bullet newbullet = new bullet(gp, startx, starty, newtargetx, newtargety); firedbullets.add(newbullet); return firedbullets; } } package weapons; import java.util.arraylist; import entity.bullet; import entity.rocketbullet; import main.gamepanel; public class rocketlauncher extends weapons{ public rocketlauncher(gamepanel gp, int fps) { super(gp, 1, 10, fps); // şarjör kapasitesi: 1, ateş hızı: 10 roket/dakika getweaponimage(); } public void getweaponimage(){ weaponup1 = setup(""/player/boy_rocket_up"", gp.tilesize, gp.tilesize*2); weaponup2 = setup(""/player/boy_rocket_up"", gp.tilesize, gp.tilesize*2); weapondown1 = setup(""/player/boy_rocket_down"", gp.tilesize, gp.tilesize*2); weapondown2 = setup(""/player/boy_rocket_down"", gp.tilesize, gp.tilesize*2); weaponleft1 = setup(""/player/boy_rocket_left"", gp.tilesize*2, gp.tilesize); weaponleft2 = setup(""/player/boy_rocket_left"", gp.tilesize*2, gp.tilesize); weaponright1 = setup(""/player/boy_rocket_right"", gp.tilesize*2, gp.tilesize); weaponright2 = setup(""/player/boy_rocket_right"", gp.tilesize*2, gp.tilesize); } public arraylist<bullet> attacktozombie(gamepanel gp, int startx, int starty, int targetx, int targety) { arraylist<bullet> firedbullets = new arraylist<>(); if (!canfire()) { return firedbullets; } remainingbulletnum--; currentcooldown = cooldownframes; rocketbullet rocketbullet = new rocketbullet(gp, startx, starty, targetx, targety); rocketbullet.damage = 4; firedbullets.add(rocketbullet); system.out.println(""rocket fired. remaining rockets: "" + remainingbulletnum); return firedbullets; } } package data; import java.io.serializable; import java.util.arraylist; public class datastorage implements serializable { public int maxlife; public int life; public int currentwave; public int point; public int worldx; public int worldy; arraylist<string> weaponnames = new arraylist<>(); } package data; import java.io.file; import java.io.fileinputstream; import java.io.fileoutputstream; import java.io.objectinputstream; import java.io.objectoutputstream; import main.gamepanel; import weapons.gun; import weapons.rocketlauncher; import weapons.shotgun; import weapons.sniper; import weapons.rifle; import weapons.weapons; public class saveload { gamepanel gp; public saveload(gamepanel gp){ this.gp = gp; } public weapons getobject(string weaponname){ weapons obj = null; switch(weaponname){ case ""gun"" : obj = new gun(gp, gp.fps); break; case ""rifle"" : obj = new rifle(gp, gp.fps); break; case ""shotgun"" : obj = new shotgun(gp, gp.fps); break; case ""sniper"" : obj = new sniper(gp, gp.fps); break; case ""rocketlauncher"" : obj = new rocketlauncher(gp, gp.fps); break; } return obj; } public void save(){ try{ file file = new file(""save.dat""); if(!file.exists()){ // dosya mevcut değilse oluşturur file.createnewfile(); } objectoutputstream oos = new objectoutputstream(new fileoutputstream(new file(""save.dat""))); datastorage ds = new datastorage(); ds.maxlife = gp.player.maxlife; ds.life = gp.player.life; ds.currentwave = gp.wavemanager.currentwave; ds.point = gp.player.totalpoint; ds.worldx = gp.player.worldx; ds.worldy = gp.player.worldy; for(int i = 0; i < gp.player.weaponinventory.size(); i++){ ds.weaponnames.add(gp.player.weaponinventory.get(i).getclass().getsimplename()); } oos.writeobject(ds); oos.close(); } catch(exception e){ system.out.println(""save exception""); e.printstacktrace(); } } public void load(){ try{ system.out.println(""load işlemi başlatıldı.""); objectinputstream ois = new objectinputstream(new fileinputstream(new file(""save.dat""))); datastorage ds = (datastorage)ois.readobject(); ois.close(); gp.player.maxlife = ds.maxlife; gp.player.life = ds.life; gp.wavemanager.currentwave = ds.currentwave; gp.wavetext = ""wave "" + ds.currentwave; gp.player.totalpoint = ds.point; gp.player.worldx = ds.worldx; gp.player.worldy = ds.worldy; gp.player.weaponinventory.clear(); for(int i = 0; i < ds.weaponnames.size(); i++){ gp.player.weaponinventory.add(getobject(ds.weaponnames.get(i))); } } catch(exception e){ system.out.println(""load exception""); e.printstacktrace(); } } } package tile; import java.awt.image.bufferedimage; public class tile { public bufferedimage image; public boolean collision = false; } package tile; import java.awt.graphics2d; import java.io.bufferedreader; import java.io.ioexception; import java.io.inputstream; import java.io.inputstreamreader; import javax.imageio.imageio; import main.gamepanel; import main.utilitytool; public class tilemanager { gamepanel gp; public tile[] tile; public int maptilenum[][]; public tilemanager(gamepanel gp){ this.gp = gp; tile = new tile[10]; maptilenum = new int[gp.maxworldcol][gp.maxworldrow]; gettileimage(); loadmap(""/maps/map.txt""); } public void gettileimage(){ setup(0, ""ground"", false); setup(1, ""grass"", true); setup(2, ""stone"", false); setup(3, ""tree"", true); setup(4, ""tree2"", true); setup(5, ""light_left"", true); setup(6, ""light_right"", true); } public void setup(int index, string imagename, boolean collision){ utilitytool utool = new utilitytool(); try{ tile[index] = new tile(); tile[index].image = imageio.read(getclass().getresourceasstream(""/tiles/"" + imagename + "".png"")); tile[index].image = utool.scaleimage(tile[index].image, gp.tilesize, gp.tilesize); tile[index].collision = collision; } catch(ioexception e){ e.printstacktrace(); } } public void loadmap(string filepath){ try{ inputstream is = getclass().getresourceasstream(filepath); bufferedreader br = new bufferedreader(new inputstreamreader(is)); int col = 0; int row = 0; while(col < gp.maxworldcol && row < gp.maxworldrow ){ string line = br.readline(); while(col < gp.maxworldcol){ string numbers[] = line.split("" ""); int num = integer.parseint(numbers[col]); maptilenum[col][row] = num; col++; } if(col == gp.maxworldcol){ col = 0; row++; } } br.close(); } catch(exception e){ } } public void draw(graphics2d g2){ int worldcol = 0; int worldrow= 0; while(worldcol < gp.maxworldcol && worldrow < gp.maxworldrow){ int tilenum = maptilenum[worldcol][worldrow]; int worldx = worldcol * gp.tilesize; int worldy = worldrow * gp.tilesize; int screenx = worldx - gp.player.worldx + gp.player.screenx; int screeny = worldy - gp.player.worldy + gp.player.screeny; if(worldx + gp.tilesize > gp.player.worldx - gp.player.screenx && worldx - gp.tilesize < gp.player.worldx + gp.player.screenx && worldy + gp.tilesize > gp.player.worldy - gp.player.screeny && worldy - gp.tilesize < gp.player.worldy + gp.player.screeny ){ g2.drawimage(tile[tilenum].image, screenx, screeny, null); } worldcol++; if(worldcol == gp.maxworldcol){ worldcol = 0; worldrow++; } } } }"
4114373,2,"4114373 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q3 { public static void main(string[] args){ sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); } } class sayac{ string str; public sayac(string str){ this.str = str; } public int say(){ if(str.indexof('1')==-1){ return 0; } else{ str = str.substring(str.indexof('1')+1, str.length()); return say() + 1; } } } public class lab1q2 { public static void main(string[] args){ int[] a = {5,4,1,2}; cocktailsort(a); } public static void cocktailsort(int[] arr){ boolean flag = false; for(int i = 1; i < arr.length; i++){ if(arr[i-1]>arr[i]){ int temp = arr[i]; arr[i] = arr[i-1]; arr[i-1] = temp; flag = true; } } if(!flag){ for(int i = 0; i < arr.length; i++){ system.out.print(arr[i] + "" ""); } } else{ cocktailsort(arr); } } } public class lab1q1 { public static void main(string[] args){ system.out.println(collatz(5)); } public static int collatz(int i){ if(i == 1){ return 0; } if(i%2==0){ return collatz(i/2) + 1; } else{ return collatz(3*i + 1) + 1; } } } kelime sayıcı bil 211 - lab 3 20 şubat 2025 1 giriş bu laboratuvarda fileioveexceptions kullanarak bir kelime sayıcı geliştireceğiz. kelime sayıcı , verilen birmetindosyasındakibelirlikelimelerinkaçkezgeçtiğinisayarakbirçıktıdosyasınakaydedecekvebelirlenen hata durumlarında uygun çıktılar oluşturacaktır. 2 genel program program, aşağıdaki sabit isimlere sahip iki giriş dosyası ile çalışacaktır: -kelimeler.txt – aranacak kelimeleri içeren dosya. -metin.txt – kelimelerin aranacağı metnin bulunduğu dosya. program, kelimeler.txt dosyasındaki her kelimenin metin.txt içinde kaç kez geçtiğini sayacak ve sonucu bir çıktı dosyasına kaydedecektir: -sonuc.txt – her kelimenin kaç kez geçtiğini içeren çıktı dosyası. dosyalar,programınçalıştırıldığıdizindebulunmalıdır. dosyaisimlerideğiştirilemez,programsadeceyukarıda belirtilen isimlerle çalışacaktır. eğerkelimeler.txt içinde bulunan herhangi bir kelime, metin.txt içinde hiç geçmiyorsa, program bir hata oluşturmalı ve stderr’e uygun bir mesaj yazmalıdır. 3 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları kullanacaktır (örn., bufferredreader, scanner, printwriter). dosyaları okurken ve yazarken kullanacağınız fileio sınıflarının seçimi size bırakılmıştır. i̇şlenmesi gereken dosyalar şunlardır: -kelimeler.txt dosyası okunmalıdır. -metin.txt dosyası okunmalıdır. -sonuc.txt dosyası oluşturulup yazılmalıdır. program,aşağıdakiolasıdosyahatalarınıoluşturmalıvehatalaroluştuğundastderr’ebelirlenenhatamesajlarını yazmalıdır: - dosyabulunamıyorsa: ""hata: kelimeler.txt bulunamadı."" veya""hata: metin.txt bulunamadı."" - dosya boşsa: ""hata: kelimeler.txt boş."" veya""hata: metin.txt boş."" 4 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program hata kodu ile çıkış yapmalıdır (yani mainmetodunuz bu hataları atarak sonlanmalı) ve hatalar stderr’e yazılmalıdır (programınızı hata atarak sonlandırırsanız java bunu kendisi yapacaktır). belirtilen hata mesajları ile birlikte java’nın hata ile sonlanan programlar için oluşturduğu sınıf, metod, ve satır gibi bilgiler bulunabilir. 1 4.1 girdi hataları (inputexception class) bu kategori, programın giriş dosyalarıyla ilgili karşılaşabileceği tüm hataları kapsar. öğrenciler, dosya işlem- leriyle ilgili hata türlerini inputexception sınıfından türetmelidir. aşağıdaki özel hata türleri tanımlanmalıdır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: [dosya adı] bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: [dosya adı] boş."" 4.2 kelime bulunamadı hatası (kelimebulunamadiexception class) eğerkelimeler.txt içinde bulunan en az bir kelime, metin.txt dosyasında hiç geçmiyorsa, program kelimebulunamadiexception hatasını atmalıdır. hata yalnızca kelimeler.txt dosyasında bulunamayan ilk kelime için atılır ve program sonlanır. bu hata oluştuğunda stderr’e şu mesaj yazılmalıdır: -""hata: [kelime] metinde bulunamadı."" bu hata, doğrudan exception sınıfından türetilecek ve inputexception ile bağlantılı olmayacaktır. 5 dosya formatları program üç farklı dosya ile çalışacaktır: kelimeler.txt (girdi),metin.txt (girdi) ve sonuc.txt (çıktı). bu dosyaların formatı aşağıda belirtilmiştir. 5.1 girdi dosyaları girdi dosyaları düz metin ( .txt) formatında olacaktır ve her biri aşağıdaki gibi yapılandırılmış olmalıdır. 5.1.1kelimeler.txt formatı kelimeler.txt dosyası, her satırda bir kelime olacak şekilde düzenlenmelidir. dosyada yalnızca harf karak- terleri bulunur. kelimeler büyük/küçük harf duyarsız olarak aranacaktır. örnek i̇çerik: elma armut üzüm eğer dosya boşsa, program şu hatayı vermelidir: hata: kelimeler.txt boş. 5.1.2metin.txt formatı metin.txt dosyası, içinde aranacak kelimelerin geçebileceği serbest formatlı bir metin içermelidir. dosya içinde noktalama işaretleri ve boşluklar bulunabilir. örnek i̇çerik: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. eğer dosya boşsa, program şu hatayı vermelidir: hata: metin.txt boş. 5.2 çıktı dosyası program, kelimelerin kaç kez geçtiğini gösteren bir çıktı dosyası ( sonuc.txt ) oluşturmalıdır. 2 5.2.1sonuc.txt formatı sonuc.txt dosyası, her satırda kelimenin adı ve kaç kez geçtiği bilgisi olacak şekilde düzenlenmelidir. format şu şekilde olmalıdır: [kelime] [geçme sayısı] kelime ve geçme sayısı arasında tek bir boşluk olmalıdır. örnek çıktı ( sonuc.txt ): elma 2 armut 2 üzüm 1 5.3 özel hata durumları ve çıktıları eğerkelimeler.txt içindekiherhangibirkelime metin.txt içindebulunamazsa, kelimebulunamadiexception hatası atılmalıdır ve stderr’e şu mesaj yazılmalıdır: hata: üzüm metinde bulunamadı. bu hata oluştuğunda, yine de sonuc.txt dosyası oluşturulmalı ve bulunan kelimeler için normal çıktı yazıl- malıdır. ancak bulunamayan kelimeler çıktı dosyasına eklenmemelidir. örnek durum: eğerkelimeler.txt şu şekildeyse: elma armut muz vemetin.txt şu şekildeyse: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. o zaman sonuc.txt şu şekilde olmalıdır: elma 2 armut 2 ve stderr’e şu mesaj yazılmalıdır: hata: muz metinde bulunamadı. 6 gönderim formatı - labı bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara şeklinde isimlendirin (örn., johnnash_181101014.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""lab3 gönderim"" başlıklı bir mail ile gönderin. 3 metot açıklama string(string s) sile aynı değere sahip bir string oluşturur. string(char[] a) a[]dizisindeki karakterlerle bir string oluşturur. int length() string içindeki karakter sayısını döndürür. char charat(int i) belirtilen iindeksindeki karakteri döndürür. string substring(int i, int j) iilej-1arasındaki karakterleri içeren bir alt string döndürür. boolean contains(string substring) string’in substring ’i içerip içermediğini kontrol eder. boolean startswith(string prefix) string’in prefixile başlayıp başlamadığını kontrol eder. boolean endswith(string postfix) string’in postfix ile bitip bitmediğini kontrol eder. int indexof(string pattern) pattern ifadesinin ilk geçtiği indeks değerini döndürür. int indexof(string pattern, int i) iindeksinden sonraki ilk pattern konumunu döndürür. string concat(string t) string’in sonuna teklenmiş halini döndürür. int compareto(string t) i̇ki string’i karşılaştırır (sözlük sırasına göre). string tolowercase() string’in tüm harflerini küçük harfe çevirir. string touppercase() string’in tüm harflerini büyük harfe çevirir. string replace(string a, string b) string içindeki a’larıbile değiştirir. string trim() string’in başındaki ve sonundaki boşlukları kaldırır. boolean matches(string regex) string’in belirtilen regexle eşleşip eşleşmediğini kontrol eder. string[] split(string delimiter) string’idelimiter kullanarak böler ve bir dizi döndürür. boolean equals(object t) string’in değeri tile aynı mı diye kontrol eder. table 1: java string sınıfı metotları 4 import java.io.file; import java.io.printstream; import java.util.arraylist; import java.util.scanner; class inputexception extends exception{ public inputexception(string e){ super(e); } } class dosyabulunamadiexception extends inputexception{ public dosyabulunamadiexception(string e){ super(e); } } class bosdosyaexception extends inputexception{ public bosdosyaexception(string e){ super(e); } } class kelimebulunamadiexception extends exception{ public kelimebulunamadiexception(string e){ super(e); } } public class lab3q1{ public static void main(string[] args){ try{ file kelimeler = new file(""kelimeler.txt""); file metin = new file(""metin.txt""); file sonuc = new file(""sonuc.txt""); kelimesay(kelimeler, metin, sonuc); } catch(kelimebulunamadiexception e){ system.err.println(e.getmessage()); } catch(dosyabulunamadiexception e){ system.out.println(""hata: "" + e.getmessage()); } catch(bosdosyaexception e){ system.out.println(""hata: "" + e.getmessage()); } catch(exception e){ system.out.println(""hata.""); } } public static void kelimesay(file kelimeler, file metin, file sonuc) throws exception{ if(!kelimeler.exists()){ throw new dosyabulunamadiexception(""kelimeler.txt bulunamadı.""); } if(!metin.exists()){ throw new dosyabulunamadiexception(""metin.txt bulunamadı.""); } if(!sonuc.exists()){ throw new dosyabulunamadiexception(""sonuc.txt bulunamadı.""); } scanner sc = new scanner(kelimeler); arraylist<string> kelimelerarraylist = new arraylist<>(); while(sc.hasnext()){ kelimelerarraylist.add(sc.next().replaceall(""\\p{punct}"", """")); } if(kelimelerarraylist.size()==0){ throw new bosdosyaexception(""kelimeler.txt boş.""); } int[] kelimesayilari = new int[kelimelerarraylist.size()]; scanner sc2 = new scanner(metin); string metinstring = """"; while(sc2.hasnext()){ metinstring += sc2.next().replaceall(""\\p{punct}"", """").tolowercase() + "" ""; } if(metinstring.length()==0){ throw new bosdosyaexception(""metin.txt boş.""); } boolean flag = false; boolean flag2 = true; while(!flag){ flag2 = true; for(int i = 0; i < kelimelerarraylist.size(); i++){ if(metinstring.contains(kelimelerarraylist.get(i))){ kelimesayilari[i] += 1; metinstring = metinstring.substring(0, metinstring.indexof(kelimelerarraylist.get(i))) + metinstring.substring(metinstring.indexof(kelimelerarraylist.get(i)) + kelimelerarraylist.get(i).length(), metinstring.length()); flag2 = false; } } if(flag2){ flag = true; } } printstream printstream = new printstream(sonuc); system.setout(printstream); //system.out sonuc.txt'e yazacak şekilde ayarlandı. for(int i = 0; i<kelimesayilari.length; i++){ if(kelimesayilari[i]>0){ system.out.println(kelimelerarraylist.get(i) + "" "" + kelimesayilari[i]); } } for(int i = 0; i < kelimesayilari.length; i++){ if(checkzeros(kelimesayilari)[i] == 1){ throw new kelimebulunamadiexception(""hata: "" + kelimelerarraylist.get(i) + "" metinde bulunamadı.""); } } } public static int[] checkzeros(int[] kelimesayilari){ int[] a = new int[kelimesayilari.length]; for(int i = 0; i < kelimesayilari.length; i++){ if(kelimesayilari[i]==0){ a[i] = 1; } } return a; } } generic 1) envanter yönetim sistemi bu labda amacımı bir oyun için envanter sistemi eklemektir. item isminde bir arayüz tanımlayın: aşağıdaki metotları içermelidir: string getname() int getvalue() weapon sınıfı tanımlayın. bu sınıf item arayüzünü uygulamalıdır. int damage isimli bir özelliği olmalıdır. armor sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. int defense isimli bir değişkeni olmalıdır. potion sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. string effect isimli bir değişkeni olmalıdır. generic inventory<t> sınıfı bir arraylist kullanarak nesneleri saklamalıdır. void additem(t item): envantere istenilen eşyayı eklemeli void removeitem(t item): envanterden istenilen eşyayı silmeli void printinventory(): envanteri basmalı t mostvaluableitem(): en değerli eşyayı dönmeli t finditembyname(string name): verilen isme karşılık gelen eşyayı dönmeli. i̇simlerin unique olduğunu varsayabilirsiniz. eğer yoksa null dönün. list<t> finditemsbyvalue(int value): verilen değerden daha değerli eşyaarın listesini döndürür. int gettotalvalue(): envanterin toplam değerini döner. list<t> filterbytype(class<?> type): istenilen sınıfa ait ögeleri döner. int gettotalweapondamage(): weapon classına ait olan nesnelerin toplam hasarınıdöner. void sortbyvalue(): değeri azalan şekilde envanteri sıralamalıdır. public static void printmostvaluableitem(inventory<? extends item> inventory): verilen envanterdem en değerli eşayı ekrana basmalıdır. public static void transferarmor(inventory<? super armor> destination, inventory<armor> source): verilen hedef envantere zırhı taşımalıdır. driver class: main metodu burada olmalıdır. sadece weapon’dan oluşan ve itemdan oluşan invertory classı yazıp test ediniz. yardımcı olabilecek metotlar: class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon import java.util.arraylist; import java.util.list; public class inventory<t> { arraylist<t> items = new arraylist<>(); void additem(t item){ items.add(item); } void removeitem(t item){ items.remove(item); } void printinventory(){ for(int i = 0; i < items.size(); i++){ system.out.println(items.get(i)); } } t mostvaluableitem(){ t most = items.get(0); for(int i = 1; i < items.size(); i++){ item item = (item)items.get(i); if(item.getvalue()>((item)most).getvalue()){ most = items.get(i); } } return most; } t finditembyname(string name){ t foundeditem = null; for(int i = 0; i < items.size(); i++){ item item = (item)items.get(i); if(item.getname().equals(name)){ foundeditem = items.get(i); } } return foundeditem; } list<t> finditemsbyvalue(int value){ arraylist<t> list = new arraylist<>(); for(int i = 0; i < items.size(); i++){ item item = (item)items.get(i); if(item.getvalue()>value){ list.add(items.get(i)); } } return list; } int gettotalvalue(){ int totalvalue = 0; for(int i = 0; i<items.size();i++){ item item = (item)items.get(i); totalvalue += item.getvalue(); } return totalvalue; } //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! list<t> filterbytype(class<?> type){ arraylist<t> list = new arraylist<>(); class<?> class1 = type; for(int i = 0; i<items.size(); i++){ if(items.get(i).getclass().equals(class1)){ list.add(items.get(i)); } } return list; } int gettotalweapondamage(){ class<weapon> weaponclass = weapon.class; int totalweapondamage = 0; for(int i = 0; i < items.size(); i++){ if(items.get(i).getclass() == weaponclass){ weapon weapon = (weapon)items.get(i); totalweapondamage += weapon.getdamage(); } } return totalweapondamage; } void sortbyvalue(){ for(int i = 0; i < items.size(); i++){ for(int j = i; j < items.size(); j++){ item item1 = (item)items.get(i); item item2 = (item)items.get(j); if(item1.getvalue()<item2.getvalue()){ t temp = items.get(i); items.set(i, items.get(j)); items.set(j, temp); } } } } public static void printmostvaluableitem(inventory<? extends item> inventory){ system.out.println(inventory.mostvaluableitem()); } public static void transferarmor(inventory<? super armor> destination, inventory<armor> source){ for(int i = 0; i<source.items.size(); i++){ destination.additem(source.items.get(i)); } } } public class weapon implements item{ int damage; string name; int value; public weapon(string name, int value, int damage){ this.damage = damage; this.name = name; this.value = value; } public string getname(){ return name; } public int getvalue(){ return value; } public int getdamage(){ return damage; } public string tostring(){ return name + "" "" + value + "" "" + damage; } } public interface item { string getname(); int getvalue(); } public class armor implements item{ int defense; int value; string name; public armor(string name, int value, int defense){ this.defense = defense; this.name = name; this.value = value; } public string getname(){ return name; } public int getvalue(){ return value; } public int getdefense(){ return defense; } public string tostring(){ return name + "" "" + value + "" "" + defense; } } public class potion implements item{ string effect; int value; string name; public potion(string name, int value, string effect){ this.effect = effect; this.name = name; this.value = value; } public string getname(){ return name; } public int getvalue(){ return value; } public string geteffect(){ return effect; } public string tostring(){ return name + "" "" + value + "" "" + effect; } } import java.util.list; public class driver { public static void main(string[] args){ inventory<weapon> weaponinventory = new inventory<>(); weaponinventory.additem(new weapon(""sniper rifle"", 700, 70)); weaponinventory.additem(new weapon(""pistol"", 200, 20)); weaponinventory.additem(new weapon(""rocket launcher"", 1000, 100)); weaponinventory.additem(new weapon(""rifle"", 400, 40)); system.out.println(""total weapon damage: ""); int totalweapondamage = weaponinventory.gettotalweapondamage(); system.out.println(totalweapondamage); system.out.println(); inventory<item> iteminventory = new inventory<>(); iteminventory.additem(new potion(""speed potion"", 500, ""gives speed"")); item goldenchestplate = new armor(""golden chestplate"", 250, 25); iteminventory.additem(goldenchestplate); iteminventory.additem(new weapon(""diamond sword"", 1000, 100)); iteminventory.additem(new armor(""iron boots"", 300, 30)); iteminventory.additem(new potion(""invisibility potion"", 2000, ""makes you invisible"")); iteminventory.additem(new armor(""diamond leggings"", 600, 60)); iteminventory.additem(new weapon(""iron sword"", 750, 75)); iteminventory.removeitem(goldenchestplate); system.out.println(""item inventory: ""); iteminventory.printinventory(); system.out.println(); system.out.println(""most valuable item of item inventory: ""); system.out.println(iteminventory.mostvaluableitem()); system.out.println(); system.out.println(""armor 'iron boots' in item inventory""); system.out.println(iteminventory.finditembyname(""iron boots"")); system.out.println(); system.out.println(""items that have more value than 400: ""); list<item> valuableitems = iteminventory.finditemsbyvalue(400); for(int i = 0; i<valuableitems.size();i++){ system.out.println(valuableitems.get(i)); } system.out.println(); system.out.println(""total value of item inventory: ""); system.out.println(iteminventory.gettotalvalue()); system.out.println(); system.out.println(""just weapon items in item inventory: ""); class<weapon> weaponclass = weapon.class; list<item> weapons = iteminventory.filterbytype(weaponclass); for(int i = 0; i<weapons.size();i++){ system.out.println(weapons.get(i)); } system.out.println(); system.out.println(""just armor items in item inventory: ""); class<armor> armorclass = armor.class; list<item> armors = iteminventory.filterbytype(armorclass); for(int i = 0; i<armors.size();i++){ system.out.println(armors.get(i)); } system.out.println(); iteminventory.sortbyvalue(); system.out.println(""sorted inventory: ""); iteminventory.printinventory(); system.out.println(); system.out.println(""most valuable item in item inventory: ""); inventory.printmostvaluableitem(iteminventory); system.out.println(); system.out.println(""most valuable item in weapon inventory: ""); inventory.printmostvaluableitem(weaponinventory); system.out.println(); inventory<armor> armorinventory = new inventory<>(); armorinventory.additem(new armor(""emerald boots"", 1000, 100)); armorinventory.additem(new armor(""emerald leggings"", 1000, 100)); armorinventory.additem(new armor(""emerald chestplate"", 1000, 100)); inventory.transferarmor(iteminventory, armorinventory); system.out.println(""item inventory with armor inventory armors: ""); iteminventory.printinventory(); } } ""recursion"" kavramı nedir, kısaca açıklayınız. recursion, aynı fonksiyonun kendi içerisinde base condition sağlanana kadar çağırılmasıdır. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. recursive metod, fonksiyonun halletmesi gereken ana problem, diğer fonksiyona(aynı fonksiyon) yollayacağı problem ve en son da çözecek bir şey kalmayınca çıkması gereken kısım olan base conditiondan oluşur. jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. . bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? string'in ölçecek elemanının kalmaması (0'a eşit olması) stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack kod içerisinde çağırdığımız fonksiyonun içindeki verileri ilk çağırılandan son çağırılana kadar çağırması, ve eğer recursion yaparken base condition hiçbir zaman sağlanmazsa stack sonsuza kadar dolmaya devam eder ve stack overflow olmuş olur. tail recursion nedir, kısaca açıklayınız. tail recursion, recursion'un her defasında return olması yerine en son çağırdığımız fonksiyonda return edip en başa dönmesidir. abstraction kavramını açıklayınız. abstraction bir işlevin nasıl çalıştığına değil ne yaptığına bakan, gereksiz detaylara boğulmadan istenileni vermesine denilen kavramdır. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? employee, hourlyemployee'nin parenti oldugu için hourlyemployee is a employee deriz yani mümkün olur ama employee is hourlyemployee olmadığı için mümkün olmaz. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? protected: class, package ve subclass default: class ve package olduğundan dolayı default private'e daha yakındır. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? çünkü parentta bulunan her şey child'da da vardır ve bu yüzden objeyi oluştururken tüm değişkenleri ayarlamak istiyorsak bi üstteki parent'in constructerini çağırmak zorundayız. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır mümkün değildir çünkü b'de ve c'de aynı metotlar veya değişkenler olabilir. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? getclass() gibi class'ın kendisine de bakıp aynı zamanda parent'larının da eşit olmasını döndürür metot overriding ve overloading kavramlarını açıklayınız. metot override: tamamen aynı olan metotlar, metot overloading: dönüş tipi hariç her şeyi aynı olan metotlar class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? output: class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? eğer metot override edilmişse dynamic binding, edilmemişse static binding yapilir. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? çünkü static, private ve final metotlara override yapılmaz bu yüzden de dynamic binding'e gerek olmaz. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? dynamic binding gerçekleşir çünkü aynı adda olan iki ayrı metotu çağırırken java'nın hangi metodu çağırmasını hesaplaması gerekiyor. dinamik bağlamada jvm'nin görevi nedir? jvm'nin görevi referans edilen en parent class'tan başlayarak oluşturulan child objesine doğru gelerek her class'ta metodun override edilmiş olup olmadığını hesaplayıp bularak, doğru metodu çağırmasıdır. java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? parent objenin içerdiği her şeyi child obje içerir fakat child objenin içerdiği her şeyi (metod, değişken vs.) parent obje içermez. bu yüzden parent p = new child(); yapılabilirken child c = new parent(); yapılamaz. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? tüm bindingler dinamik olsaydı child classta çağırdığımız ve child class'a özgü olan bir override metodu çağıramazdık. class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? parent referansıyla bir child object oluşturulduğu için o referanstan çağırdığımız child objesinin parenttaki metod yerine child'daki override edilmiş metodu çağırmasını istediğimiz için dinamik bağlama. class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? i̇lk objede statik bağlama, ikinci objede dinamik bağlama java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class o class içerisine daha sonra implement etmek istediğimiz özellikleri önceden yazabilmemizi sağlayan class türüdür. constructor'u olamaz çünkü abstract class'tan obje oluşturulamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? eğer parent class içerisinde tanimladigimiz abstract metodlarin hepsini child classin içinde implement etmek istemiyorsak child class olrak abstract metodlar harici olusturdugumuz bir abstract class var olabilir. bu class'ta parent class içinde yaptığımız abstract metotlari implement edebiliriz. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract metotlar programın daha iyi okunmasını sağlar. aynı zamanda program için bir şema görevi görür. abstract class ile farklı insanlar aynı proje içinde daha kolay çalışabilirler çünkü abstract class'larin içindeki her metodu bilmek zorunda kalmazlar, herkes kendi bildiği/yapması gereken yeri yaparak işbirliği içinde çalışabilir. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract class veya interface'lerden obje oluşturulamaz. i̇nterface'in abstract class'tan farkı ise içerisindeki tüm metotların/degiskenlerin tanimlanmayacak oluşudur. yani bir abstract class tamamen abstract metotlar içermek zorunda değildir ama interface tamamen bir kara kutu gibi çalışır, yani içerisinde hiçbir şey yoktur, isimlerden başka. marker interface ve functional interface kavramları nedir, nasıl kullanılır? - bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? bir class birden fazla interface'i implement edemez. bir interface başka bir interface'i implement edebilir. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abstract olan bir class'tan obje oluşturulamaz. eğer abstract classi aktardığımız class'tan bir obje oluşturmak istiyorsak ""circle c = new circle();"" kullanabiliriz. hata duzeldikten sonra da, ""drawing circle \n displaying"" yazılır. interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? interface'lerin içindeki metotların ne yaptığı interface içinde tanımlanamaz. ayrıca class c'deki public void show() metodu implement ettiği iki interface'in hangisinin çağırılacağını bilemez. bu yüzden class c'deki metotta direkt olarak ""a"" veya ""b"" yazdıran bir metot yazılabilir. java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. - java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? throws kullanırken child classi yazarsak catch içinde parent class'i cagiramayiz. bu yüzden eğer birden fazla hata catch etmek istiyorsak tüm hataların ortak atasını(parentini) throws ile almalıyız finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally bloğundaki kodlar, try'da throw edilen hata catch'de yakalansa da yakalanmasa da çağrılır java'da kendi exceptionunuzu nasıl tanımlarsınız? bir class oluşturarak, ismine oluşturmak istedigimiz hata adını yazarak throwable classini extend edip, olusturmak istediğimiz durumu if'le yazdıktan sonra o durumun içinde hatamızı tanımlıyoruz, daha sonra o hatanin olup olmadığı yerde kontrol için yazdigimiz classta olusturdugumuz hata classini 'throws' ile alıp, catch içinde o hatayı tanimlayarak yazıyoruz. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? o class tam olarak o sorunu çözememiş ise bir sonraki parent'a fırlatır ve hata orda çözülür static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught -1 finally oops done static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? burada m1()deki ioexception m2() içerisine gittiğinde catch'de ilk olarak exception olarak yakalanır bu yüzden de caught1 yazar yani caught2 yazmamış olur, çünkü try catch okunurken yukardan başlanarak aşağı inilir text file ile binary file arasındaki fark nedir? text file direkt string şekilde yazarken binary file byte byte yazar. bir dosyaya yazarken düzenli olarak flush yapmamak neye yol açabilir? buffer'ın kapanmamasına sebep olur binary bir dosyaya bir object yazdırırken bu objenin hangi interfaceyi implement etmesi gerekiyor? bu interfacenin metotlarını sıralayınız. bu interface functional veya marker bir interface midir? - binary bir dosyaya primitive typeler (int, float, char etc.) yazılabilir mi, evet ise nasıl? 4byte'lık verilerle yazılabilir. buffered reader ve scanner sınıfları ile dosya okurken dosyanın sonuna geldiğini nasıl kontrol edilir? hasnext() metoduyla, false döndürürse dosya bitmiştir binary bir dosya okurken dosyanın sonuna gelindiği nasıl test edilir? - public class randomaccessdemo { public static void main(string[] args) throws exception { _______ f = new _______(""numbers.bin"", ""____""); f.writeint(10); f.writeint(20); int a = f.readint(); f.seek(_____________); int b = f.readint(); system.out.println(a + b); f.close(); } } boşluklara sırasıyla ne gelmelidir? output? randomaccessfile, randomaccessfile, true, 4, output: 30 public class demo { public static void main(string[] args) throws exception { fileoutputstream fos = new fileoutputstream(""log.txt"", true); ______________ pw = new ______________(fos); pw.println(""new log entry""); pw.close(); } } boşluklara sırasıyla ne gelmelidir? bu kod çalıştırıldığında log.txt dosyası nasıl etkilenir? printwriter, printwriter, log.txt: new log entry what grade (a, b, c, d, or f) do you expect to earn by the end of this course? cb java'da generic kavramı nedir, bu kavramın temel amacı nedir? generic, javada bir class'in içine veya bir metodun içerisine birbirinden farklı tipte değişkenleri koymamızı sağlar upper bound ve lower bound wildcardları nasıl ifade edersiniz? upper ve lower boundun kullanılacağı durumlara birer tane örnek veriniz. upper bound <? super ...> ile yani o classin extend olduğu classlari icine alirken, lower bound <? extend ...> şeklinde olduğu için o classtan extend edilen classlari içine alabilir. generic bir classın constructorunda type parametresi bulunur mu, neden? type parametresi class içerisinde nasıl tanımlandıysa, örneğin t değişkeni ile tanimlandiysa t type olmuş olur. mygenericclass<a> ve mygenericclass<object> classları arasında kalıtım (child-parent) ilişkisi nasıldır, açıklayınız. - class node<t>{ t[] data = new t[10]; } //psvm node<string> stringnode = new node<>(); bu kodda bir hata var mı? (varsa) bu hata nedir, nedenini açıklayınız. (varsa) bu hata nasıl düzeltilmeli, kodun doğru halini yazınız. - swapheadandtail metodu aşağıda tanımı verilmiş node classının birbirlerine bağlanmış nodelerinden ilkini alan ve baştaki node ile sondaki node'yi değiştiren metottur. örnek: başlangıçta: a -> b -> c metodu a ile çağırdığıktan sonra: c -> b -> a ayrıca metot en başa gelen nodeyi dönmelidir (bu örnekte c dönmeli). class node{ int data; node next; } static node swapheadandtail(node head) { node a = head; node b = head.next; node c = head; node d = null; while (____ != null) { d = c; c = c.next; } c.next = ____; d.next = ____; a.next = ____; return ____; } buna göre boşluklara neler gelmelidir? head.next.next() head head.next() public _________ { public void sırala(list<t> liste) { // sıralama algoritmanız } } yaptığınız uzun çalışmalar sonucu yeni bir sıralama algoritması buldunuz. bunu implement etmek için bir class yazmalısınız. bu classın declarationunu nasıl yapardınız neden, boşluğu buna göre doldurun. class<t extend collections> ara sınavdan yaklaşık hangi notu bekliyorsun (0-100)? 70 java gui'leri bağlamında olay güdümlü (event driven) programlamayı tanımlayın. event driven programlama program akışını kullanıcının kontroluyle devam ettirebilir. kullanıcının girdilerine göre değişen program akışıdır. geleneksel sıralı programlama ile olay güdümlü (event driven) programlama arasındaki temel fark nedir? geleneksel sıralı programlamada program akışı, programı yazan tarafından önceden belirlenmiştir ve buna göre çalışır fakat event driven'da çeşitli olaylara karşılık çeşitli fonksiyonlar vardır ve bu fonksiyonlar kullanicinin girdilerine göre çalışır. borderlayout yöneticisi, bir konteynerdeki bileşenleri nasıl düzenler? içerisinde çeşitli metodlar ve parametreler vardır ve içerisine yazdığımız contentleri yönlere göre atayabilir north south center gibi java gui uygulamalarında jpanel'in amacı nedir? jpanel, ekleyeceğimiz componentleri tutan bir paneldir. olusturdugumuz window içerisine çeşitli paneller ekleyerek katmanlara göre farklı componentler ekleyebiliriz. java'daki gui programları neden tipik olarak sonsuz bir olay döngüsü çalıştırır ve bu durum sistem veya uygulama tarafından tetiklenen yeniden çizim (repaint) olaylarıyla nasıl ilişkilidir? program kullanıcı programı kapatmadigi sürece tüm girdileri ölçmek zorundadır ve buna göre tepki vermek zorundadır. örneğin bir oyunda karakterin yürümesini istiyorsak arkaplanda program sürekli bizim klavyemize basıp basmadigimizi kontrol etmesi gerekiyor ve bunu aynı zamanda ekrana çizmesi gerekiyor. bir swing uygulamasında repaint() metodunu çağırmanın etkisi nedir? repaint() belli aralıklarla ekrana gosterilen icerikleri gunceller, eğer bir metod ekranda değişiklik yapıyorsa, metottan sonra repaint() bu değişiklikleri sürekli olarak ekrana verir. aşağıdaki kodun çalışmasını izleyin ve düğmeye tıklandığında ne olduğunu belirleyin: public class simplegui extends jframe implements actionlistener { public simplegui() { setsize(200, 100); setdefaultcloseoperation(jframe.exit_on_close); jbutton button = new jbutton(""click me""); button.addactionlistener(this); add(button); setvisible(true); } public void actionperformed(actionevent e) { joptionpane.showmessagedialog(this, ""button was clicked!""); system.exit(0); } public static void main(string[] args) { new simplegui(); } } program basladiginda simplegui() objesi yaratır ve 200 100 boyutlarinda bir pencere açar ve pencerenin içinde ""click me"" yazan buton vardır. butona basıldığında ""button was clicked"" gösterilir ve system.exit(0) ile programdan çıkılır. aşağıdaki kod parçasını inceleyin: import javax.swing.*; import java.awt.*; public class layoutexample { public static void main(string[] args) { jframe frame = new jframe(""layout test""); frame.setsize(400, 300); frame.setdefaultcloseoperation(jframe.exit_on_close); frame.setlayout(new borderlayout()); frame.add(new jlabel(""n""), borderlayout.north); frame.add(new jbutton(""s""), borderlayout.south); frame.add(new jpanel(), borderlayout.center); frame.setvisible(true); } } bu program çalıştığında bileşenlerin nasıl düzenlendiğini açıklayın. program calistiginda layout test yazan bir frame oluşur 400 300 boyutlarinda ve framein layoutu ayarlanir, kuzeye n, güneye s, ve ortaya panel objesi ekler ve frame'in gorunurlugunu true olarak ayarlar. bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true import java.util.arraylist; public class quiz1q2 { public static void main(string[] args){ factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } class robot{ private string name; private string type; private int batterylevel; private boolean isoperational; public robot(){ this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public robot(string name, string type, int batterylevel){ this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = true; } public void printrobot(){ system.out.print(""robot name: "" + name); system.out.print("" robot type: "" + type); system.out.print("" battery level: "" + batterylevel + ""%""); system.out.print("" is operational: "" + isoperational); } public string getname(){ return name; } public string gettype(){ return type; } public int getbatterylevel(){ return batterylevel; } public boolean getisoperational(){ return isoperational; } public void setname(string name){ this.name = name; } public void settype(string type){ this.type = type; } public void setbatterylevel(int batterylevel){ this.batterylevel = batterylevel; } public void setisoperational(boolean isoperational){ this.isoperational = isoperational; } public void charge(){ batterylevel = 100; } } class factory{ private string name; private string location; private arraylist<robot> robots = new arraylist<robot>(); public factory(){ this.name = ""factory1""; this.location = ""moon""; } public factory(string name, string location){ this.name = name; this.location = location; } public string getname(){ return name; } public string getlocation(){ return location; } public arraylist getrobots(){ return robots; } public void setname(string name){ this.name = name; } public void setlocation(string location){ this.location = location; } public void addrobot(robot robot){ robots.add(robot); } public void chargeallrobots(){ for(int i = 0; i < robots.size(); i++){ robots.get(i).setbatterylevel(100); } } public void printfactory(){ system.out.println(""factory name: "" + name + "" location: "" + location); system.out.println(""robots operating here:""); for(int i = 0; i < robots.size(); i++){ robots.get(i).printrobot(); system.out.println(); } } public void work(){ for(int i = 0; i < robots.size(); i++){ robots.get(i).setbatterylevel(robots.get(i).getbatterylevel()-15); } } } import java.util.arraylist; public class quiz1q1 { public static void main(string[] args){ system.out.println(combination(""a1b2"").tostring()); } public static arraylist combination(string s){ int c = 0; for(int i = 0; i < s.length(); i++){ if((s.charat(i)>=65 && s.charat(i)<91) || (s.charat(i)>=97 && s.charat(i)<123)){ c += 1; } } arraylist<string> a = new arraylist<string>(); boolean flag = true; while(flag){ for(int i = 0; i < s.length(); i++){ if(s.charat(i)>=65 && s.charat(i)<91){ if(!a.contains(s)){ a.add(s); } else{ s = s.substring(0, i+1) + s.substring(i+1,s.length()).tolowercase(); } s = s.substring(0, i) + (char)(s.charat(i)+32) + s.substring(i+1, s.length()); } else if(s.charat(i)>=97 && s.charat(i)<123){ if(!a.contains(s)){ a.add(s); } else{ s = s.substring(0, i+1) + s.substring(i+1,s.length()).touppercase(); } s = s.substring(0, i) + (char)(s.charat(i)-32) + s.substring(i+1, s.length()); } } if(a.size()==math.pow(2, c)){ flag = false; } } return a; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery{ protected string modelname; protected int defaultbattery; protected int batterylife; public abstractrobot(string modelname, int batterylife){ this.modelname = modelname; this.batterylife = batterylife; this.defaultbattery = batterylife; } public string getmodelname(){ return modelname; } public int getbatterylife(){ return batterylife; } public void recharge(){ this.batterylife = defaultbattery; } public abstract void performtask(); public abstract void boostcleaningpower(int miktar); public abstract void togglearmedmode(); public abstract string tostring(); public abstract int getcleaningpower(); public abstract boolean getarmedmode(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.printnumberofrobots(); } } public class securityrobot extends abstractrobot{ private boolean isarmed; public boolean getarmedmode(){ return isarmed; } public securityrobot(string modelname, int batterylife, boolean isarmed){ super(modelname, batterylife); this.isarmed = isarmed; } public void performtask(){ if(batterylife>=10){ system.out.println(""["" + modelname + ""] "" + ""scanning for threats... armed: "" + isarmed); batterylife -= 10; } else{ system.out.println(""["" + modelname + ""] not enough battery to scan threats...""); } } public void togglearmedmode(){ if(isarmed){ isarmed = false; } else{ isarmed = true; } } public string tostring(){ return ""security robot - model: "" + modelname + "", battery: "" + batterylife + "", armed: "" + isarmed + ""\n""; } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; public int getcleaningpower(){ return cleaningpower; } cleaningrobot(string modelname, int batterylife, int cleaningpower){ super(modelname, batterylife); this.cleaningpower = cleaningpower; } public void performtask(){ if(batterylife>=10){ system.out.println(""["" + modelname + ""] "" + ""cleaning in progress... cleaning power: "" + cleaningpower); batterylife -= 10; } else{ system.out.println(""["" + modelname + ""] not enough battery to clean...""); } } public void boostcleaningpower(int power){ this.cleaningpower += power; } public string tostring(){ return ""cleaning robot - model: "" + modelname + "", battery: "" + batterylife + "", cleaning power: "" + cleaningpower + ""\n""; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); public static int robotsayisi = 0; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); robotsayisi += 1; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ robots.add(new securityrobot(modelname, batterylife, isarmed)); robotsayisi += 1; } public void performalltasks(){ for(int i = 0; i < robots.size(); i++){ robots.get(i).performtask(); } } public void displayrobots(){ for(int i = 0; i < robots.size(); i++){ system.out.print(robots.get(i).tostring()); } } public void upgradecleaningrobots(int miktar){ for(int i = 0; i < robots.size(); i++){ if(robots.get(i) instanceof cleaningrobot){ robots.get(i).boostcleaningpower(miktar); system.out.println(""cleaning robot - "" + robots.get(i).modelname + "" now has cleaning power: "" + robots.get(i).getcleaningpower()); } } } public void togglesecurityrobotsmode(){ for(int i = 0; i < robots.size(); i++){ if(robots.get(i) instanceof securityrobot){ robots.get(i).togglearmedmode(); if(robots.get(i).getarmedmode()){ system.out.println(""security robot - "" + robots.get(i).modelname + "" is now armed""); } else{ system.out.println(""security robot - "" + robots.get(i).modelname + "" is now unarmed""); } } } } public static void printnumberofrobots(){ system.out.println(""tüm fabrikalar tarafından toplam "" + robotsayisi + "" robot üretildi.""); } } envanter takip sistemi bil 211 - quiz 3 27 şubat 2025 1 giriş bu quizde, fileioveexceptions kullanarak basit bir envanter takip sistemi uygulaması geliştireceğiz. uygulama, interaktif bir terminal menüsü üzerinden, tek bir eşyanın ve stoğunun tutulduğu kayıtların yönetilmesini (eşya ekleme, çıkarma ve stok güncelleme) sağlayacaktır. ayrıca, envanter verileri sabit isimli bir dosyaya kaydedilebilecek ve bu dosyadan geri yüklenebilecektir. 2 genel program program konsol tabanlı bir kullanıcı arayüzü ile envanter takibi gerçekleştirmelidir. arayüz özellikleri aşağı- daki gibidir. -terminal menüsü: kullanıcıya aşağıdaki seçenekleri sunacaktır: – eşya ekleme: yeni bir eşya kaydı oluşturulur. her kayıt, eşya adı ve başlangıç stoğu bilgilerini içerir. eğer çoktan var olan bir eşya eklenmeye çalışılırsa program otomatik olarak önceki kaydın stoğunu güncellemelidir (yani aynı isimde iki kayıt oluşmamalı). – eşya çıkarma: mevcut envanterden istenilen eşya silinir. – stok güncelleme: kayıtlı bir eşyanın stoğu artırılabilir ya da azaltılabilir. i̇şlem sonucunda stok miktarı negatif olmamalıdır. – envanter listeleme: mevcut envanter kayıtları ekrana listelenir. – dosyaya kaydetme: güncel envanter verileri sabit isimli dosyaya kaydedilir. – dosyadan geri yükleme: daha önce kaydedilmiş envanter verileri dosyadan okunarak geri yüklenir. – çıkış: program sonlandırılır. 3envanterkaydi sınıfı değişkenler: -isim(private string) eşyanın adını tutar. -stok(private int) eşyanın stok miktarını tutar. metotlar: -public envanterkaydi(string isim, int stok) constructor; eşya adı ve stok miktarını başlatır. -public void stokguncelle(int miktar) stok miktarını günceller; negatif sonuç oluşmaması kontrol edilmelidir. - stokguncelle dışında ihtiyacınıza göre private değişkenler için getter ve setter tanımlayabilirsiniz. 4 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları (örn., bufferedreader , scanner,printwriter ) kullanacaktır. dosya işlemleri sırasında aşağıdaki hata durumları için uygun mesajlar verilmelidir: - dosya bulunamazsa: ""hata: envanter dosyası bulunamadı."" - dosya boşsa: ""hata: envanter dosyası boş."" 1 5 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program, hata kodu ile sonlanmalı ve ilgili hata mesajları stderr’e yazdırılmalıdır. 5.1 girdi hataları (inputexception class) dosya işlemleriyle ilgili hatalar için kendi tanımlayacağınız inputexception sınıfından türeyen özel hata sınıfları oluşturulacaktır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: envanter dosyası bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: envanter dosyası boş."" 5.2 envanter i̇şlemleri hataları envanter işlemleri sırasında oluşabilecek hatalar için aşağıdaki özel hata türleri tanımlanacaktır: -stoknegatifexception (extends exception) : stok güncelleme işlemi sonucunda, eşyanın stoğu negatif bir değere düşerse atılacak hata. - hata mesajı: ""hata: stok miktarı negatif olamaz."" -esyayokexception (extends exception) : çıkarma veya güncelleme işlemi yapılmak istenen eşya envanterde bulunmuyorsa atılacak hata. - hata mesajı: ""hata: i̇stenen eşya envanterde mevcut değil."" -ozellikhatasiexception (extends exception) : eşya ekleme sırasında girilen bilgilerde hata veya eksiklik varsa atılacak hata. - hata mesajı: ""hata: eşya bilgileri hatalı veya eksik."" 6 gönderim formatı - quizinizi bitirdiğinizde asistanlarınızdan birisine kodunuzu ve çıktısını gösterip puanlatın. - asistan labınızı puanladığında tüm kaynak dosyalarını ve bu dökümantasyonu bir arşiv dosyası (zip, rar, 7z, tar, tar.gz) halinde sıkıştırın. - arşiv dosyasının isim_numara formatında isimlendirin (örn., sebnemferah_181101014.zip). - i̇simlendirdiğiniz arşiv dosyasını uzak sistemindeki quiz alanına yükleyin. 2 import java.io.fileinputstream; import java.io.filenotfoundexception; import java.io.fileoutputstream; import java.io.printwriter; import java.util.arraylist; import java.util.inputmismatchexception; import java.util.scanner; public class quiz3q1 extends exception{ public static arraylist<envanterkaydi> esyalar = new arraylist<>(); public static void main(string[] args){ while(true){ system.out.println(""-----terminal menüsü-----""); system.out.println(""1. eşya ekleme\n2. eşya çıkarma\n3. stok güncelleme\n4. envanter listeleme\n5. dosyaya kaydetme\n6. dosyadan geri yükleme\n7. çıkış""); scanner kullanici = new scanner(system.in); try{ int karar = kullanici.nextint(); if(karar==1){ system.out.println(""eklemek istediğiniz eşyayı giriniz: ""); string esya = kullanici.next(); kullanici.nextline(); system.out.println(""bu eşyadan eklemek istediğiniz stok miktarını giriniz: ""); int miktar = kullanici.nextint(); try{ esyaekle(esya, miktar); } catch(stoknegatifexception e){ system.out.println(e.getmessage()); } catch(ozellikhatasiexception e){ system.out.println(e.getmessage()); } } else if(karar==2){ system.out.println(""çıkarmak istediğiniz eşyayı giriniz: ""); string esya = kullanici.next(); kullanici.nextline(); try{ esyacikar(esya); } catch(esyayokexception e){ system.out.println(e.getmessage()); } } else if(karar==3){ system.out.println(""güncellemek istediğiniz eşyayı giriniz: ""); string esya = kullanici.next(); kullanici.nextline(); system.out.println(""güncellemek istediğiniz miktarı giriniz: ""); int miktar = kullanici.nextint(); try{ stokguncelle(esya, miktar); } catch(stoknegatifexception e){ system.out.println(e.getmessage()); } catch(esyayokexception e){ system.out.println(e.getmessage()); } } else if(karar==4){ envanterilistele(); } else if(karar==5){ try{ dosyayakaydet(); } catch(dosyabulunamadiexception e){ system.out.println(e.getmessage()); } } else if(karar==6){ try{ dosyadanyukle(); } catch(dosyabulunamadiexception e){ system.out.println(e.getmessage()); } catch(bosdosyaexception e){ system.out.println(e.getmessage()); } } else if(karar==7){ cikis(); } } catch(inputmismatchexception e){ system.out.println(""lütfen bir sayı giriniz!""); } } } public static void esyaekle(string esya, int miktar) throws stoknegatifexception, ozellikhatasiexception{ if(miktar<0){ throw new stoknegatifexception(""hata: stok miktarı negatif olamaz.""); } boolean flag = false; for(int i = 0; i < esyalar.size(); i++){ if(esyalar.get(i).getisim().equals(esya)){ flag = true; } } if(flag){ throw new ozellikhatasiexception(""hata: eklemeye çalıştığınız eşya zaten envanterde mevcut.""); } envanterkaydi e = new envanterkaydi(esya, miktar); esyalar.add(e); system.out.println(miktar + "" tane "" + esya + "" başarıyla eklendi!""); } public static void esyacikar(string esya) throws esyayokexception{ boolean flag = false; for(int i = 0; i < esyalar.size(); i++){ if(esyalar.get(i).getisim().equals(esya)){ flag = true; } } if(!flag){ throw new esyayokexception(""hata: istenen eşya envanterde mevcut değil.""); } int index = 0; for(int i = 0; i < esyalar.size(); i++){ if(esyalar.get(i).getisim()==esya){ index = i; } } esyalar.remove(index); system.out.println(esya + "" başarıyla envanterden silindi.""); } public static void stokguncelle(string esya, int miktar) throws stoknegatifexception, esyayokexception{ if(miktar<0){ throw new stoknegatifexception(""hata: stok miktarı negatif olamaz.""); } boolean flag = false; for(int i = 0; i < esyalar.size(); i++){ if((esyalar.get(i).getisim().equals(esya))){ flag = true; } } if(!flag){ throw new esyayokexception(""hata: istenen eşya envanterde mevcut değil.""); } int index = 0; for(int i = 0; i < esyalar.size(); i++){ if(esyalar.get(i).getisim()==esya){ index = i; } } esyalar.get(index).stokguncelle(miktar); system.out.println(esya + "" eşyasının sayısı başarıyla "" + miktar + "" olarak güncellendi.""); } public static void envanterilistele(){ if(esyalar.isempty()){ system.out.println(""envanterde eşya yok.""); } for(int i = 0; i < esyalar.size(); i++){ system.out.println((i+1) + "". "" + esyalar.get(i)); } } public static void dosyayakaydet() throws dosyabulunamadiexception{ try{ fileoutputstream k = new fileoutputstream(""envanter.txt""); printwriter pw = new printwriter(k); for(int i = 0; i < esyalar.size(); i++){ pw.println(esyalar.get(i)); system.out.println(i); } pw.flush(); pw.close(); system.out.println(""veriler envanter.txt'ye başarıyla kaydedildi.""); } catch(filenotfoundexception e){ throw new dosyabulunamadiexception(""hata: envanter dosyası bulunamadı.""); } } public static void dosyadanyukle() throws dosyabulunamadiexception, bosdosyaexception{ esyalar.clear(); try{ fileinputstream envanter = new fileinputstream(""envanter.txt""); scanner yukleme = new scanner(envanter); if(!yukleme.hasnext()){ throw new bosdosyaexception(""hata: envanter dosyası boş.""); } while(yukleme.hasnext()){ string esya = yukleme.next(); int miktar = yukleme.nextint(); envanterkaydi e = new envanterkaydi(esya, miktar); esyalar.add(e); } system.out.println(""veriler envanter.txt'den başarıyla yüklendi.""); } catch (filenotfoundexception e){ throw new dosyabulunamadiexception(""hata: envanter dosyası bulunamadı.""); } } public static void cikis(){ system.exit(0); } } class inputexception extends exception{ public inputexception(string e){ super(e); } } class dosyabulunamadiexception extends inputexception{ public dosyabulunamadiexception(string e){ super(e); } } class bosdosyaexception extends inputexception{ public bosdosyaexception(string e){ super(e); } } class stoknegatifexception extends exception{ public stoknegatifexception(string e){ super(e); } } class esyayokexception extends exception{ public esyayokexception(string e){ super(e); } } class ozellikhatasiexception extends exception{ public ozellikhatasiexception(string e){ super(e); } } class envanterkaydi{ private string isim; private int stok; public envanterkaydi(string isim, int stok){ this.isim = isim; this.stok = stok; } public void stokguncelle(int miktar){ this.stok = miktar; } public string getisim(){ return isim; } public int getstok(){ return stok; } public string tostring(){ return isim + "" "" + stok; } } bil211 quiz 4 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: undoablelist<t> adında bir sınıf oluşturun. bu sınıf, bir arraylist'i genişletmeli ve aşağıdaki ek özelliklere sahip olmalıdır: ● undolast() metodu, en son eklenen öğeyi kaldırmalıdır. ● getlastadded() → son eklenen öğeyi listeyi değiştirmeden döndürür. ● eğer liste boşsa, undolast() bir hata vermemeli, sadece hiçbir şey yapmamalıdır. örnek kullanım: undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] q2: aşağıdaki generic metodu tamamlayın. ● verilen bir collection<t> içinde minimum veya maksimum öğeyi bulan bir metod yazın. ● boolean parametresi true ise maksimumu, false ise minimumu döndürmelidir. ● t öğeleri comparable<t> arabirimini uygulamalıdır. public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { // metodu tamamlayın } örnek kullanım: list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) q3: belirli türdeki elemanları filtreleme ● bir collection<?> içindeki belirli bir türdeki öğeleri filtreleyen bir generic metod yazın. ● class<t> tür filtresi olarak kullanılmalıdır. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { // metodu tamamlayın } örnek kullanım: list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] package q3; import java.util.arraylist; import java.util.arrays; import java.util.collection; import java.util.iterator; import java.util.list; import java.util.vector; public class main { public static void main(string[] args) { list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(filterbytype(mixed, string.class)); // çıktı: [hello, world] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] system.out.println(); system.out.println(""ek testler: ""); arraylist<integer> arraylist = new arraylist<>(); //filterbytype'da kullanmak için arraylist.add(1); arraylist.add(2); arraylist.add(3); list<object> mixed2 = arrays.aslist(17, ""merhaba"", 5.2, ""dünya"", 66, false, arraylist, new vector<>(), 'c', ""!"", true); system.out.println(filterbytype(mixed2, string.class)); // çıktı: [merhaba, dünya, !] system.out.println(filterbytype(mixed2, integer.class)); // çıktı: [17, 66] system.out.println(filterbytype(mixed2, arraylist.class)); // çıktı: [[1, 2, 3]] system.out.println(filterbytype(mixed2, vector.class)); // çıktı: [[]] system.out.println(filterbytype(mixed2, character.class)); // çıktı: [c] system.out.println(filterbytype(mixed2, boolean.class)); // çıktı: [false, true] } public static <t> list<t> filterbytype(collection<?> collection, class<t> type){ iterator<?> iterator = collection.iterator(); list<t> list1 = new arraylist<>(); class<t> class1 = type; while(iterator.hasnext()){ t next = (t)iterator.next(); if(next.getclass().equals(class1)){ list1.add(next); } } return list1; } } package q1; public class main { public static void main(string[] args) { undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); string a = list.getlastadded(); list.undolast(); system.out.println(a); system.out.println(list); } } package q1; import java.util.arraylist; public class undoablelist<t> extends arraylist<t> { public void undolast(){ if(!isempty()){ remove(get(size()-1)); } } public t getlastadded(){ return get(size()-1); } } package q2; import java.util.arrays; import java.util.collection; import java.util.iterator; import java.util.list; public class main { public static void main(string[] args) { list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(""for 'numbers' list: ""); system.out.println(""max value: "" + findextreme(numbers, true)); //max system.out.println(""min value: "" + findextreme(numbers, false)); //min list<integer> numbers2 = arrays.aslist(4,8,15,16,23,42); system.out.println(); system.out.println(""(ek test) for 'numbers2' list: ""); system.out.println(""max value: "" + findextreme(numbers2, true)); //max system.out.println(""min value: "" + findextreme(numbers2, false)); //min } public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax){ iterator<t> iterator = collection.iterator(); if(findmax){ t max = iterator.next(); while(iterator.hasnext()){ t next = iterator.next(); if(next.compareto(max)>0){ max = next; } } return max; } else{ t min = iterator.next(); while(iterator.hasnext()){ t next = iterator.next(); if(next.compareto(min)<0){ min = next; } } return min; } } } 2 kuş bakışı atış oyunu (top-down shooter) bil 211 - proje teslim tarihi: 27 mart 2025 23:59 1 amaç bu ödevde amacınız, java swing kullanarak kuş bakışı bir atış oyunu (top-down shooter) tasarlamaktır. oyunda, yönettiğimiz karakterin üzerine dalga dalga gelen çeşitli zombileri fare ile hedef alarak farklı silahlar kullanıp öldürmemiz gerekmektedir. karakterimiz öldüğünde oyun sona erecektir. her dalga başına ve öldürülen zombi başına kazanılan puan artacaktır. dalgalar ilerledikçe gelen zombilerin sayısı ve çeşitleri artarak zorluk seviyesi yükselecektir. 2 gereksinimler oyun derste öğrendiğiniz oop ilkelerine uygun sınıf/arayüz tasarımları ile geliştirilmelidir. - zorluk seviyesi arttıkça zombi sayısı ve çeşitliliği artmalıdır. - oyun duraklatılabilmeli ve kaydedilip tekrar yüklenilebilmelidir (fileio kullanılmalıdır). - sol üst köşede seçili silah ve kalan mermi miktarı gösterilmelidir. - sağ üst köşede oyuncunun canı ve toplam puanı gösterilmelidir. - oyunun duraklatılması, kaydedilmesi ve devam ettirilmesi için bir menü bulunmalıdır. 3 silahlar oyunda farklı silahlar bulunmaktadır. belirli zombi dalgaları temizlendikten sonra oyun ödül olarak yeni bir silahverecektir. hersilahınkendineözgübirçalışmamekanizmasıvardır. silahlarınşarjörkapasitesisınırlıdır ve şarjördeki mermiler bittiğinde tekrar doldurulmadan ateş edilemez. toplam mermi sayısı oyuncunun o silaha ait elinde ne kadar mermi olduğunu gösterir. r tuşuna basarak şarjör yeniden doldurulabilir. 3.1 tabanca - şarjör kapasitesi: 12 mermi - ateş hızı: 120 mermi/dakika - elde etme: oyuncu oyuna bu silahla başlar. - özellik: düz atış yapar, sapma yoktur. sınırsız yedek şarjör (diğer tüm silahlar için yedek şarjör ve mermiler rastgele bir şekilde dalga sırasında ve sonlarında zombilerden düşer). 3.2 piyade tüfeği - şarjör kapasitesi: 30 mermi - ateş hızı: 600 mermi/dakika - elde etme: 1. dalga tamamlandıktan sonra - özellik: düzatışyaparancak30derecesapmasıvardır. sapmaaçısı, karakterinbaktığıyöndemerminin her iki dönme yönüne de saçılabileceği maksimum açıdır. 1 3.3 pompalı tüfek - şarjör kapasitesi: 5 mermi - ateş hızı: 60 mermi/dakika - elde etme: 3. dalga tamamlandıktan sonra - özellik: her atış 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi atar (yani karakter merkezli mermi hız vektörleri arasında 5 derece açı olmalıdır). 3.4 keskin nişancı tüfeği - şarjör kapasitesi: 5 mermi - ateş hızı: 30 mermi/dakika - elde etme: 5. dalga tamamlandıktan sonra - özellik: mermileri zombileri delip arasındaki zombilere de hasar verir. 3.5 roketatar - şarjör kapasitesi: 1 roket - ateş hızı: 10 roket/dakika - elde etme: 10. dalga tamamlandıktan sonra - özellik: patlama etkisiyle birden fazla zombiye zarar verir. 4 zombiler zombiler oyundaki düşman tipleridir. zombiler oyuncuya doğru ilerlerler ve eğer oyuncuya temas ederlerse oyuncuya hasar verirler. zorluk seviyesi arttıkça zombilerin sayısı ve çeşitliliği artmaktadır. zombi tipleri birbirinden renk ya da şekil olarak ayırt edilebilmelidir. 4.1 normal zombi - can: orta - hız: yavaş - hasar: orta 4.2 sürünge zombi - can: düşük - hız: hızlı - hasar: orta - özellik: oyuncunun yakınına geldiğinde zıplar. 4.3 tank zombi - can: yüksek - hız: çok yavaş - hasar: yüksek 2 4.4 asit tüküren zombi - can: düşük - hız: yavaş - hasar: orta (uzaktan asit tükürebilir) - özellik: öldürüldüğünde yanındaki birimlere zarar verir. 5 rapor ve teslim formatı - oyun, oopprensiplerineuygunolaraktasarlanmalıvesınıfdiyagramları, arayüztasarımıfinalraporda sunulmalıdır. - oyun test edilerek ekran görüntüleri rapora eklenmelidir. - rapor pdf formatında olmalı ve ismi proje_rapor.pdf olmalıdır. - oyunun mainfonksiyonu gameisimli bir sınıf içinde bulunmalıdır ( java game komutuyla çalışmalı). - kaynak kodun tamamı source.zip (uzantı 7z, rar, tar.gz de olabilir) şeklinde sıkıştırılmış olmalıdır. - sıkıştırılmış kaynak kod ve rapor uzak sistemine yüklenmelidir. 6 yardımcı kaynaklar dahaöncehiçkuşbakışıatışoyunuoynamadıysanızaşağıdakioyunlarıreferansolarakalabilirsiniz. buradaki oyunlarıngrafikleriilemekaniklerisizdenbeklenendenfarklıolsadaharitatasarımı, karakterhareketi,kamera hareketi, ateş etme mekanikleri ve zombilerin yapay zekası ile ilgili temel fikirler edinebilirsiniz. - little top-down shooter: https://www.youtube.com/watch?v=pj3m3fu3i5a - super c - stage 2: https://www.youtube.com/watch?v=os2t_v5suj4 - neon chrome: https://www.youtube.com/watch?v=puhw1bevtro 3 import java.io.file; import javax.swing.imageicon; public class sniper extends weapon{ gamepanel game; public sniper(gamepanel game){ capacity = 5; currentcapacity = 5; shootspeed = 30; wave = 6; reloadcooldown = 5000; this.game = game; name = ""sniper rifle""; image = new imageicon(""textures/weapons/sniper rifle.png""); bulletimage = new imageicon(this.getclass().getresource(""/textures/weapons/rifle_bullet.png"")); soundpath = new file(""snipersound.wav""); } void shoot(int mousex, int mousey) { if(currentcapacity>0){ if(settings.volume){ playsound(); } currentcapacity -= 1; game.addbullet(mousex, mousey); } } } import java.awt.color; import java.awt.font; import java.awt.graphics; import java.awt.graphics2d; import java.awt.toolkit; import java.awt.event.keyevent; import java.io.file; import java.io.ioexception; import java.awt.event.keyadapter; import javax.sound.sampled.audioinputstream; import javax.sound.sampled.audiosystem; import javax.sound.sampled.clip; import javax.sound.sampled.lineunavailableexception; import javax.sound.sampled.unsupportedaudiofileexception; import javax.swing.imageicon; import javax.swing.joptionpane; import javax.swing.jpanel; class menu extends jpanel { private mouseinput mouseinput = new mouseinput(this); window window; public uielement startbuttonelement, settingsbuttonelement, quitbuttonelement = new uielement(0, 0, 0, 0, null); imageicon bgimage = new imageicon(this.getclass().getresource(""/textures/ui/bg.png "")); imageicon titleimage = new imageicon(this.getclass().getresource(""/textures/ui/title2.png"")); imageicon startbutton = new imageicon(this.getclass().getresource(""/textures/ui/start_button.png"")); imageicon settingsbutton = new imageicon(this.getclass().getresource(""/textures/ui/settings_button.png"")); imageicon quitbutton = new imageicon(this.getclass().getresource(""/textures/ui/quit_button.png"")); imageicon gif = new imageicon(this.getclass().getresource(""/textures/ui/rain.gif"")); boolean settingson; private boolean rainmode = true; private boolean extrememode = false; private boolean volume = true; private boolean fullscreen = false; file rainsound = new file(""rain.wav""); audioinputstream raininput; clip rainclip; keyinput keyinput = new keyinput(); private mousecursor mousecursor = new mousecursor(0, 0, 32, 32); gamesavemanager savemanager = new gamesavemanager(); public menu(window window) throws unsupportedaudiofileexception, ioexception, lineunavailableexception{ this.window = window; setfocusable(true); requestfocus(); setlayout(null); addkeylistener(keyinput); addmousemotionlistener(mouseinput); addmouselistener(mouseinput); savemanager.loadsettings(); raininput = audiosystem.getaudioinputstream(rainsound); rainclip = audiosystem.getclip(); rainclip.open(raininput); rainclip.setframeposition(0); rainmode = settings.rain; extrememode = settings.extreme; volume = settings.volume; fullscreen = settings.fullscreen; setfocusable(true); addkeylistener(new keyadapter() { @override public void keypressed(keyevent e) { if (settingson) { if (e.getkeycode() == keyevent.vk_z) { volume = !volume; settings.volume = volume; if(!volume){ rainclip.stop(); } else{ rainclip.start(); rainclip.loop(clip.loop_continuously); } savemanager.savesettings(); } if (e.getkeycode() == keyevent.vk_r) { rainmode = !rainmode; settings.rain = rainmode; savemanager.savesettings(); } if (e.getkeycode() == keyevent.vk_e) { extrememode = !extrememode; settings.extreme = extrememode; savemanager.savesettings(); } if (e.getkeycode() == keyevent.vk_f5) { fullscreen = !fullscreen; settings.fullscreen = fullscreen; savemanager.savesettings(); if(fullscreen){ window.fullscreen(); window.changesize((int)toolkit.getdefaulttoolkit().getscreensize().getwidth(), (int)toolkit.getdefaulttoolkit().getscreensize().getheight()); } else{ window.changesize(960, 540); window.fullscreen(); } } if (e.getkeycode() == keyevent.vk_k) { savemanager.savesettings(); } repaint(); } if (e.getkeycode() == keyevent.vk_escape) { settingson = !settingson; repaint(); } } }); } public void paintcomponent(graphics g) { g.drawimage(bgimage.getimage(), 0, 0, getwidth(), getheight(), null); if(settings.rain){ g.drawimage(gif.getimage(), 0, 0, getwidth(), getheight(), null); if(settings.volume){ rainclip.loop(clip.loop_continuously); } } g.setcolor(new color(0, 0, 0, 100)); g.fillrect(0, 0, getwidth(), getheight()); g.setcolor(new color(255, 128, 0, 25)); g.filloval(mouseinput.getmousex() - 75, mouseinput.getmousey() - 75, 150, 150); g.drawimage(titleimage.getimage(), getwidth() / 2 - getwidth() / 8, getheight() / 9 - getheight() / 16, getwidth() / 4, getheight() / 8, null); startbuttonelement = new uielement(getwidth() / 2 - getwidth() / 12, getheight() / 2 - getheight() / 12, getwidth() / 6, getheight() / 6, startbutton); settingsbuttonelement = new uielement(getwidth() / 2 - getwidth() / 12, (int) (getheight() / 1.6) - getheight() / 12, getwidth() / 6, getheight() / 6, settingsbutton); quitbuttonelement = new uielement(getwidth() / 2 - getwidth() / 12, (int) (getheight() / 1.33) - getheight() / 12, getwidth() / 6, getheight() / 6, quitbutton); startbuttonelement.draw((graphics2d) g); settingsbuttonelement.draw((graphics2d) g); quitbuttonelement.draw((graphics2d) g); if(settingson){ g.setcolor(new color(0, 0, 0, 150)); int leftpanelx = getwidth() / 18; int leftpanely = getheight() / 8; int leftpanelwidth = (int) (getwidth() / 3.5); int leftpanelheight = (int) (getheight() / 1.3); g.fillrect(leftpanelx, leftpanely, leftpanelwidth, leftpanelheight); g.setcolor(color.white); g.setfont(new font(""courier new"", font.bold, getwidth()/60)); g.drawstring(""game modes"", leftpanelx + 20, leftpanely + 40); g.drawstring(""[r] rain mod: "" + (rainmode ? ""on"" : ""off""), leftpanelx + 20, leftpanely + 100); g.drawstring(""[e] extreme mod: "" + (extrememode ? ""on"" : ""off""), leftpanelx + 20, leftpanely + 150); int rightpanelx = getwidth() - getwidth() / 3; int rightpanely = getheight() / 8; int rightpanelwidth = (int) (getwidth() / 3.5); int rightpanelheight = (int) (getheight() / 1.3); g.setcolor(new color(0, 0, 0, 150)); g.fillrect(rightpanelx, rightpanely, rightpanelwidth, rightpanelheight); g.setcolor(color.white); g.drawstring(""audio and visual"", rightpanelx + 20, rightpanely + 40); g.drawstring(""[z] sound: "" + (volume ? ""on"" : ""off""), rightpanelx + 20, rightpanely + 100); g.drawstring(""[f5] fullscreen: "" + (fullscreen ? ""on"" : ""off""), rightpanelx + 20, rightpanely + 170); } mousecursor.draw((graphics2d) g, mouseinput.getmousex(), mouseinput.getmousey()); } public void update() { repaint(); mouseinput.update(); mousecursor.update(); if(mouseinput.ismousepressed){ if((mouseinput.getmousex() > quitbuttonelement.getx() && mouseinput.getmousex() < quitbuttonelement.getx() + quitbuttonelement.getwidth()) && (mouseinput.getmousey() > quitbuttonelement.gety() && mouseinput.getmousey() < quitbuttonelement.gety() + quitbuttonelement.getheight())) { sureexit(); mouseinput.ismousepressed = false; } if((mouseinput.getmousex() > settingsbuttonelement.getx() && mouseinput.getmousex() < settingsbuttonelement.getx() + settingsbuttonelement.getwidth()) && (mouseinput.getmousey() > settingsbuttonelement.gety() && mouseinput.getmousey() < settingsbuttonelement.gety() + settingsbuttonelement.getheight())) { mouseinput.ismousepressed = false; if(settingson){ settingson = false; } else{ settingson = true; } } if((mouseinput.getmousex() > startbuttonelement.getx() && mouseinput.getmousex() < startbuttonelement.getx() + startbuttonelement.getwidth()) && (mouseinput.getmousey() > startbuttonelement.gety() && mouseinput.getmousey() < startbuttonelement.gety() + startbuttonelement.getheight())) { startgame(); mouseinput.ismousepressed = false; } } } public void sureexit() { int result = joptionpane.showconfirmdialog(null, ""sure? you want to exit?"", ""exit"",joptionpane.yes_no_option,joptionpane.question_message); if (result == joptionpane.yes_option) { system.exit(0); } } public void startgame(){ rainclip.stop(); rainclip = null; savemanager.savesettings(); window.gameon = true; system.out.println(window.gameon); game.close(); game.create(); } } import java.awt.graphics2d; import java.util.arraylist; import java.util.list; import java.util.random; public class wavemanager { public int wave = 0; arraylist<zombie> zombies; random rand; healthkit healthkit; magazine magazine; arraylist<healthkit> healthkits = new arraylist<>(); arraylist<magazine> magazines = new arraylist<>(); public int zombiecount; public double mult; public int dead; arraylist<acidarea> acidareas = new arraylist<>(); arraylist<double> acidtimes = new arraylist<>(); long last_time = system.nanotime(); double currenttime; public wavemanager(gamepanel game){ this.game = game; this.zombies = new arraylist<>(); this.rand = new random(); if(settings.extreme){ mult = 20.0; } else{ mult = 10.0; } } public gamepanel game; boolean validspawn(zombie zombie){ for(building building: game.buildings){ if(zombie.checkcollusion(game.camera, building)){ return false; } } return true; } public void spawnzombies(){ zombies.clear(); if(dead >= wave*mult){ dead = 0; } zombiecount = (int)(wave * mult) - dead; arraylist<class<? extends zombie>> availablezombies = new arraylist<>(); availablezombies.add(normalzombie.class); if(wave >= 4){ availablezombies.add(reptilezombie.class); } if(wave >= 7){ availablezombies.add(tankzombie.class); } if(wave >= 10){ availablezombies.add(acidzombie.class); } for(int i = 0; i < zombiecount; i++){ int x = rand.nextint(0, game.bg.width); int y = rand.nextint(0, game.bg.height); system.out.println(x + "" "" + y); class<? extends zombie> zombietype = availablezombies.get(rand.nextint(availablezombies.size())); try { zombie zombie = zombietype.getdeclaredconstructor(int.class, int.class, player.class, camera.class).newinstance(x, y, game.player, game.camera); if(validspawn(zombie)){ zombies.add(zombie); zombie.definemanager(this); } else{ i--; } } catch (exception e) { e.printstacktrace(); } } } public void update(){ currenttime = system.currenttimemillis(); long time = system.nanotime(); int delta_time = (int) ((time - last_time) / 1000000); last_time = time; for (int i = 0; i < zombies.size(); i++) { if (zombies.get(i).isdead()) { dead += 1; game.player.score += wave; if(zombies.get(i) instanceof acidzombie){ acidareas.add(new acidarea(zombies.get(i).x - 64, zombies.get(i).y - 64, 128, 128)); acidtimes.add(currenttime); } int r = rand.nextint(0,20); if(r==1 || r==2){ healthkit = new healthkit(zombies.get(i).x, zombies.get(i).y, 48, 48); healthkits.add(healthkit); } if(r==3 || r==4 || r==5){ magazine = new magazine(zombies.get(i).x, zombies.get(i).y, 48, 48); magazines.add(magazine); } zombies.remove(i); i--; } } if(zombies.isempty()){ nextwave(); } for(zombie z: zombies){ z.update(); } for(int i = 0; i < acidareas.size(); i++){ if(currenttime - acidtimes.get(i) > 3000){ acidareas.remove(i); acidtimes.remove(i); } } for(zombie z: zombies){ for(acidarea area: acidareas){ if(area.checkcollusion(game.camera, z)){ z.health -= delta_time / 30.0; system.out.println(delta_time); } } } } public void render(graphics2d g, camera cam) { for (zombie z : zombies) { z.draw2(g); } for(healthkit hk: healthkits){ hk.draw2(g, cam); } for(magazine mg: magazines){ mg.draw2(g, cam); } for(acidarea area: acidareas){ area.draw2(g, cam); } } public void nextwave() { wave += 1; spawnzombies(); } public list<zombie> getzombies() { return zombies; } } import java.awt.graphics2d; import javax.swing.imageicon; public class mousecursor extends gameobject{ private imageicon mouseicon = new imageicon(this.getclass().getresource(""/textures/cursor.png"")); public mousecursor(int x, int y, int width, int height) { super(x, y, width, height); } public void update() { } public void draw(graphics2d g) { } public void draw(graphics2d g, int x, int y) { g.drawimage(mouseicon.getimage(), x-16, y-16, width, height, null); } } import java.awt.graphics2d; import java.awt.rectangle; import javax.swing.imageicon; public class building extends gameobject{ player player; imageicon[] buildingimages = new imageicon[14]; imageicon buildingimage = buildingimages[11] = new imageicon(this.getclass().getresource(""/textures/tilesets/city/house1.png""));; int wbuilding; { for(int i = 0; i < 11; i++){ buildingimages[i] = new imageicon(this.getclass().getresource(""/textures/tilesets/city/house"" + (int)(i+1) + "".png"")); } buildingimages[11] = new imageicon(this.getclass().getresource(""/textures/tilesets/city/building1.png"")); buildingimages[12] = new imageicon(this.getclass().getresource(""/textures/tilesets/city/building2.png"")); buildingimages[13] = new imageicon(this.getclass().getresource(""/textures/tilesets/city/building3.png"")); } public building(int x, int y, int width, int height){ super(x, y, width, height); } public void setbuilding(int i){ buildingimage = buildingimages[i]; } public void getplayer(player player){ this.player = player; } public void draw(graphics2d g) { g.drawimage(buildingimage.getimage(), x, y, width, height, null); rectangle bounds1 = new rectangle((int) x, (int) y, width, height); //g.draw(bounds1); } } import java.awt.graphics2d; public abstract class zombie extends gameobject{ public zombie(int x, int y, int width, int height) { super(x, y, width, height); } public boolean isdead() { return health <= 0; } wavemanager wavemanager; gamepanel game; public double health, speed; public double damage; public double velx, vely; boolean isjumping; double speed2 = speed; public boolean collusion = false; abstract void attack(); player player; camera camera; void definemanager(wavemanager wm){ wavemanager = wm; game = wm.game; } boolean isnearplayer; abstract void draw2(graphics2d g); public void movetowardsplayer() { double playercenterx = player.getx() + player.getwidth() / 2.0; double playercentery = player.gety() + player.getheight() / 2.0; double zombiecenterx = x + width / 2.0; double zombiecentery = y + height / 2.0; double dx = playercenterx - zombiecenterx; double dy = playercentery - zombiecentery; double distance = math.sqrt(dx * dx + dy * dy); if(isjumping){ speed2 = 10; } double angle = math.atan2(dy, dx); velx = math.cos(angle) * speed2; vely = math.sin(angle) * speed2; if(distance >= 50){ if(!isjumping){ speed2 = speed; } isnearplayer = false; } if(distance < 50){ speed2 = 0; isnearplayer = true; } collusion = false; for(building building: game.buildings){ if(checkcollusion(camera, building)){ collusion = true; if (velx > 0) { x -= velx; velx = 0; } else if (velx < 0) { x += math.abs(velx); velx = 0; } if (vely > 0) { y -= vely; vely = 0; } else if (vely < 0) { y += math.abs(vely); vely = 0; } } } x += velx; y += vely; } } import java.awt.alphacomposite; import java.awt.color; import java.awt.font; import java.awt.graphics2d; import javax.swing.imageicon; public class pause extends gameobject{ int a; private font uifont; imageicon pauseicon = new imageicon(this.getclass().getresource(""/textures/ui/pause.png"")); public pause(int x, int y, int width, int height) { super(x, y, width, height); } public void set(int w, int h){ width = w; height = h; uifont = new font(""courier new"", font.bold, w/40); } public void update(){ if(a<150) a += 3; } public void draw(graphics2d g) { g.setcolor(new color(0,0,0,a)); g.fillrect(0, 0, width , height); g.setcolor(new color(255,255,255)); g.setfont(uifont); float alpha = a/150.0f; alphacomposite ac = alphacomposite.getinstance(alphacomposite.src_over,alpha); g.setcomposite(ac); g.drawimage(pauseicon.getimage(), width/3, width/8,width/3,width/18, null); g.drawstring(""press 'p' for unpause"", width/2 - (int)(width/6.5), height/2); g.drawstring(""press 'esc' for main menu"", width/2 - (int)(width/5.5), (int)(height/1.5)); } } import java.awt.color; import java.awt.graphics2d; import java.awt.geom.affinetransform; import java.util.arraylist; import javax.swing.imageicon; public class acidzombie extends zombie{ private imageicon acidzombieimage = new imageicon(this.getclass().getresource(""/textures/zombies/acidzombie.png"")); arraylist<acid> acids = new arraylist<>(); double currenttime; double acidtime; public acidzombie(int x, int y, player player, camera camera){ super(x,y,80,80); this.health = 10; this.speed = 4; this.damage = 0.2; this.player = player; this.camera = camera; this.visible = true; } void attack() { if(currenttime - acidtime > 600){ acids.add(new acid((int)(x + width/2 - camera.x),(int)(y + height/2 - camera.y),(int)(player.getx() + player.getwidth() / 2.0 - camera.x), (int)(player.gety() + player.getheight() / 2.0 - camera.y))); acidtime = currenttime; } } public void update() { for(acid acid: acids){ acid.update(); } for(int i = 0; i < acids.size(); i++){ if(player.checkcollusion(camera, acids.get(i))){ acids.remove(i); if(player.isplayerattackable()){ player.sethealth(player.gethealth() - 5); } } } double dx = player.x - x; double dy = player.y - y; currenttime = system.currenttimemillis(); double distance = math.sqrt(dx * dx + dy * dy); if(distance < 1000 && distance > 200){ movetowardsplayer(); } if(distance <= 200){ attack(); } } public void draw2(graphics2d g) { for(acid acid: acids){ acid.draw(g); } if (visible) { double dx = player.getx() + player.getwidth() / 2.0 - (x + width/2); double dy = player.gety() + player.getheight() / 2.0 - (y + height/2); double angle = math.atan2(dy, dx) + math.pi / 2; g.translate(x - camera.getx() + width/2, y - camera.gety() + height/2); g.rotate(angle); g.drawimage(acidzombieimage.getimage(), -width/2, -height/2, width, height, null); g.settransform(new affinetransform()); g.setcolor(new color(215,0,0)); g.fillrect(x - camera.getx() + 15, y - camera.gety(), (int)((width-30) * (health / 10)), 5); g.setcolor(new color(255,255,255)); g.drawrect(x - camera.getx() + 15, y - camera.gety(), (width-30), 5); } } public void draw(graphics2d g) { } } import java.io.file; import javax.sound.sampled.audioinputstream; import javax.sound.sampled.audiosystem; import javax.sound.sampled.clip; import javax.swing.imageicon; public abstract class weapon { public int capacity; public int currentcapacity; public int shootspeed; public int wave; public int reloadcooldown; public string name; public int speed = 50; public int magazine = capacity; public file soundpath; public file reloadpath = new file(""reloadsound.wav""); public audioinputstream audioinput; public clip clip; public void playsound(){ new thread(() -> { try{ audioinput = audiosystem.getaudioinputstream(soundpath); clip = audiosystem.getclip(); clip.open(audioinput); clip.setframeposition(0); clip.start(); system.out.println(""bang""); } catch(exception e){ } }).start(); } public void reloadsound(){ new thread(() -> { try{ audioinput = audiosystem.getaudioinputstream(reloadpath); clip = audiosystem.getclip(); clip.open(audioinput); clip.setframeposition(0); clip.start(); system.out.println(""r""); } catch(exception e){ } }).start(); } imageicon image,bulletimage; abstract void shoot(int mousex, int mousey); public void reload(){ if(magazine > capacity){ magazine -= capacity - currentcapacity; currentcapacity = capacity; } else{ currentcapacity += magazine; magazine = 0; } system.out.println(magazine); system.out.println(capacity - currentcapacity); if(settings.volume){ reloadsound(); } } } import java.awt.graphics2d; import java.awt.geom.affinetransform; import javax.swing.imageicon; public class bullet extends gameobject{ private double velx, vely; private double speed = 50.0; private double angle; public boolean enabled; private imageicon bulletimage; wavemanager wavemanager; camera camera; explosion explosion = null; weapon weapon; double exptime = 0; double currenttime; long last_time = system.nanotime(); public bullet(int startx, int starty, int targetx, int targety, weapon weapon, double ang, wavemanager wm, camera cam) { super(startx, starty, 8, 8); enabled = true; camera = cam; wavemanager = wm; this.weapon = weapon; speed = weapon.speed; double diffx = targetx - startx; double diffy = targety - starty; double distance = math.sqrt(diffx * diffx + diffy * diffy); double ang2 = math.toradians(ang); angle = math.atan2(diffy, diffx) + ang2; if (distance != 0) { velx = math.cos(angle) * speed; vely = math.sin(angle) * speed; } else { velx = 0; vely = 0; } bulletimage = weapon.bulletimage; } public void update() { currenttime = system.currenttimemillis(); long time = system.nanotime(); int delta_time = (int) ((time - last_time) / 1000000); last_time = time; x += velx; y += vely; for(zombie z: wavemanager.zombies){ if(checkcollusion(camera, z) && !(weapon instanceof rocketlauncher)){ z.health -= 5; if(!(weapon instanceof sniper)){ enabled = false; } else{ z.health -= 5; enabled = true; } } } for(zombie z: wavemanager.zombies){ if(checkcollusion(camera, z)){ if(weapon instanceof rocketlauncher){ if(explosion==null){ explosion = new explosion(x + camera.x - 128, y + camera.y - 128, 256, 256); velx = 0; vely = 0; exptime = currenttime; } } } } for(building b: wavemanager.game.buildings){ if(checkcollusion(camera, b)){ if(weapon instanceof rocketlauncher){ if(explosion==null){ explosion = new explosion(x + camera.x - 128, y + camera.y - 128, 256, 256); velx = 0; vely = 0; exptime = currenttime; } } else{ enabled = false; } } } if(explosion!=null){ for(zombie z: wavemanager.zombies){ if(explosion.checkcollusion(camera, z)){ z.health -= delta_time * 10; } } } } public void draw(graphics2d g) { affinetransform transform = new affinetransform(); transform.translate(x, y); transform.rotate(angle + math.pi, bulletimage.getimage().getwidth(null) / 20, bulletimage.getimage().getheight(null) / 20); if(weapon instanceof rocketlauncher){ transform.scale(0.15, 0.15); } else{ transform.scale(0.05, 0.05); } g.drawimage(bulletimage.getimage(), transform, null); if(explosion != null){ explosion.draw2(g, camera); } if(currenttime - exptime >= 750 && explosion != null){ exptime = 0; explosion = null; enabled = false; } } public boolean isoutofbounds() { return x < 0 || x > 4000 || y < 0 || y > 3000; } } import java.io.file; import javax.swing.imageicon; public class shotgun extends weapon{ gamepanel game; public shotgun(gamepanel game){ capacity = 5; currentcapacity = 5; shootspeed = 60; wave = 4; reloadcooldown = 5000; this.game = game; name = ""shotgun""; image = new imageicon(""textures/weapons/shotgun.png""); bulletimage = new imageicon(this.getclass().getresource(""/textures/weapons/rifle_bullet.png"")); soundpath = new file(""shotgunsound.wav""); } void shoot(int mousex, int mousey) { if(currentcapacity>0){ if(settings.volume){ playsound(); } currentcapacity -= 1; game.addbullet(mousex, mousey); } } } import java.awt.graphics2d; public class acid extends gameobject{ double angle; double speed = 10; public acid(int startx, int starty, int targetx, int targety){ super(startx, starty, 6, 6); double diffx = targetx - startx; double diffy = targety - starty; double distance = math.sqrt(diffx * diffx + diffy * diffy); angle = math.atan2(diffy, diffx); if (distance != 0) { velx = math.cos(angle) * speed; vely = math.sin(angle) * speed; } else { velx = 0; vely = 0; } } public void update(){ x += velx; y += vely; } public void draw(graphics2d g) { g.filloval(x, y, width, height); } } import java.awt.color; import java.awt.graphics2d; import java.awt.rectangle; import java.awt.geom.affinetransform; import javax.swing.imageicon; public class reptilezombie extends zombie{ private imageicon reptilezombieimage = new imageicon(this.getclass().getresource(""/textures/zombies/reptilezombie.png"")); public reptilezombie(int x, int y, player player, camera camera){ super(x,y,64,64); this.health = 10; this.speed = 4; this.damage = 0.2; this.player = player; this.camera = camera; this.visible = true; } void attack() { if (isnearplayer && player.isplayerattackable()) { player.sethealth(player.gethealth()-damage); //system.out.println(""attack "" + player.gethealth()); } } private boolean canjump = true; private long lastjumptime = 0; private final long jumpcooldown = 2000; public void update() { double dx = player.x - x; double dy = player.y - y; double distance = math.sqrt(dx * dx + dy * dy); if(distance < 1000){ movetowardsplayer(); } attack(); checkjump(); } public void checkjump(){ double playercenterx = player.getx() + player.getwidth() / 2.0; double playercentery = player.gety() + player.getheight() / 2.0; double zombiecenterx = x + width / 2.0; double zombiecentery = y + height / 2.0; double dx = playercenterx - zombiecenterx; double dy = playercentery - zombiecentery; double distance = math.sqrt(dx * dx + dy * dy); if (distance < 100) { if (canjump) { isjumping = true; canjump = false; lastjumptime = system.currenttimemillis(); } } if(distance < 50){ isjumping = false; } if (!canjump && system.currenttimemillis() - lastjumptime > jumpcooldown) { canjump = true; } } public void draw2(graphics2d g) { if (visible) { double dx = player.getx() + player.getwidth() / 2.0 - (x + width/2); double dy = player.gety() + player.getheight() / 2.0 - (y + height/2); double angle = math.atan2(dy, dx) + math.pi / 2; g.translate(x - camera.getx() + width/2, y - camera.gety() + height/2); g.rotate(angle); g.drawimage(reptilezombieimage.getimage(), -width/2, -height/2, width, height, null); g.settransform(new affinetransform()); g.setcolor(new color(215,0,0)); g.fillrect(x - camera.getx() + 15, y - camera.gety(), (int)((width-30) * (health / 10)), 5); g.setcolor(new color(255,255,255)); g.drawrect(x - camera.getx() + 15, y - camera.gety(), (width-30), 5); } rectangle bounds1 = new rectangle((int) x - camera.x, (int) y - camera.y, width, height); //g.draw(bounds1); } public void draw(graphics2d g) { } } import java.awt.color; import java.awt.graphics2d; import java.awt.image; import java.awt.rectangle; import java.awt.geom.affinetransform; import javax.swing.imageicon; public class normalzombie extends zombie{ imageicon normalzombieimage = new imageicon(this.getclass().getresource(""/textures/zombies/normalzombie.png"")); public normalzombie(int x, int y, player player, camera camera){ super(x,y,80,80); this.health = 20; this.speed = 2; this.damage = 0.2; this.player = player; this.camera = camera; this.visible = true; } void attack() { if (isnearplayer && player.isplayerattackable()) { player.sethealth(player.gethealth()-damage); //system.out.println(""attack "" + player.gethealth()); } } public void update() { double dx = player.x - x; double dy = player.y - y; double distance = math.sqrt(dx * dx + dy * dy); if(distance < 1000){ movetowardsplayer(); } attack(); } public void draw2(graphics2d g) { if (visible) { double dx = player.getx() + player.getwidth() / 2.0 - (x + width/2); double dy = player.gety() + player.getheight() / 2.0 - (y + height/2); double angle = math.atan2(dy, dx) + math.pi / 2; g.translate(x - camera.getx() + width/2, y - camera.gety() + height/2); g.rotate(angle); g.drawimage(normalzombieimage.getimage(), -width/2, -height/2, width, height, null); g.settransform(new affinetransform()); g.setcolor(new color(215,0,0)); g.fillrect(x - camera.getx() + 15, y - camera.gety(), (int)((width-30) * (health / 20)), 5); g.setcolor(new color(255,255,255)); g.drawrect(x - camera.getx() + 15, y - camera.gety(), (width-30), 5); } rectangle bounds1 = new rectangle((int) x - camera.x, (int) y - camera.y, width, height); //g.draw(bounds1); } public void draw(graphics2d g) { } } import java.awt.graphics2d; import javax.swing.imageicon; public class magazine extends gameobject{ imageicon magazine = new imageicon(this.getclass().getresource(""/textures/zombies/magazine.gif"")); public magazine(int x, int y, int width, int height) { super(x, y, width, height); } public void draw2(graphics2d g, camera cam) { g.drawimage(magazine.getimage(), x - cam.x, y - cam.y, width, height, null); } public void draw(graphics2d g) { } } import java.awt.event.keyevent; import java.awt.event.keylistener; public class keyinput implements keylistener { private boolean up, down, left, right,shift,q,r,t,k,p,num1,num2,num3,num4,num5,f5,esc; public boolean isup(){ return up; } public boolean isdown(){ return down; } public boolean isleft(){ return left; } public boolean isright(){ return right; } public boolean isshift(){ return shift; } public boolean isq(){ return q; } public boolean isr(){ return r; } public boolean ist(){ return t; } public boolean isk(){ return k; } public boolean isp(){ return p; } public boolean is1(){ return num1; } public boolean is2(){ return num2; } public boolean is3(){ return num3; } public boolean is4(){ return num4; } public boolean is5(){ return num5; } public boolean isf5(){ return f5; } public boolean isesc(){ return esc; } public void keypressed(keyevent e) { int key = e.getkeycode(); if (key == keyevent.vk_w) up = true; if (key == keyevent.vk_s) down = true; if (key == keyevent.vk_a) left = true; if (key == keyevent.vk_d) right = true; if (key == keyevent.vk_shift) shift = true; if (key == keyevent.vk_q) q = true; if (key == keyevent.vk_r) r = true; if (key == keyevent.vk_t) t = true; if (key == keyevent.vk_k) k = true; if (key == keyevent.vk_p) p = true; if (key == keyevent.vk_1) num1 = true; if (key == keyevent.vk_2) num2 = true; if (key == keyevent.vk_3) num3 = true; if (key == keyevent.vk_4) num4 = true; if (key == keyevent.vk_5) num5 = true; if (key == keyevent.vk_f5) f5 = true; if (key == keyevent.vk_escape) esc = true; } public void keyreleased(keyevent e) { int key = e.getkeycode(); if (key == keyevent.vk_w) up = false; if (key == keyevent.vk_s) down = false; if (key == keyevent.vk_a) left = false; if (key == keyevent.vk_d) right = false; if (key == keyevent.vk_shift) shift = false; if (key == keyevent.vk_q) q = false; if (key == keyevent.vk_r) r = false; if (key == keyevent.vk_t) t = false; if (key == keyevent.vk_k) k = false; if (key == keyevent.vk_p) p = false; if (key == keyevent.vk_1) num1 = false; if (key == keyevent.vk_2) num2 = false; if (key == keyevent.vk_3) num3 = false; if (key == keyevent.vk_4) num4 = false; if (key == keyevent.vk_5) num5 = false; if (key == keyevent.vk_f5) f5 = false; if (key == keyevent.vk_escape) esc = false; } public void keytyped(keyevent e) { } } import java.io.*; public class gamesavemanager { private gamepanel gamepanel; public gamesavemanager(gamepanel gamepanel) { this.gamepanel = gamepanel; } public gamesavemanager() { } public void savesettings(){ try (bufferedwriter writer = new bufferedwriter(new filewriter(""settings.txt""))) { writer.write(""rain="" + settings.rain); writer.newline(); writer.write(""extreme="" + settings.extreme); writer.newline(); writer.write(""fullscreen="" + settings.fullscreen); writer.newline(); writer.write(""volume="" + settings.volume); writer.newline(); } catch (ioexception e) { e.printstacktrace(); } } public void loadsettings(){ try (bufferedreader reader = new bufferedreader(new filereader(""settings.txt""))) { string line; while ((line = reader.readline()) != null) { string[] parts = line.split(""=""); string key = parts[0]; string value = parts[1]; switch (key) { case ""rain"": settings.rain = boolean.parseboolean(value); break; case ""extreme"": settings.extreme = boolean.parseboolean(value); break; case ""fullscreen"": settings.fullscreen = boolean.parseboolean(value); break; case ""volume"": settings.volume = boolean.parseboolean(value); break; } } system.out.println(""loadsettings""); } catch (ioexception e) { e.printstacktrace(); } } public void savegame() { try (bufferedwriter writer = new bufferedwriter(new filewriter(""save.txt""))) { writer.write(""wave="" + (gamepanel.wavemanager.wave-1)); writer.newline(); writer.write(""playerx="" + gamepanel.player.getx()); writer.newline(); writer.write(""playery="" + gamepanel.player.gety()); writer.newline(); writer.write(""players="" + gamepanel.player.score); writer.newline(); writer.write(""playerh="" + gamepanel.player.gethealth()); writer.newline(); writer.write(""playerf="" + gamepanel.player.getfatigue()); writer.newline(); writer.write(""camerax="" + gamepanel.camera.getx()); writer.newline(); writer.write(""cameray="" + gamepanel.camera.gety()); writer.newline(); writer.write(""deadzombies="" + gamepanel.wavemanager.dead); writer.newline(); writer.write(""magazine2="" + gamepanel.rifle.magazine); writer.newline(); writer.write(""capacity2="" + gamepanel.rifle.currentcapacity); writer.newline(); writer.write(""magazine3="" + gamepanel.shotgun.magazine); writer.newline(); writer.write(""capacity3="" + gamepanel.shotgun.currentcapacity); writer.newline(); writer.write(""magazine4="" + gamepanel.sniper.magazine); writer.newline(); writer.write(""capacity4="" + gamepanel.sniper.currentcapacity); writer.newline(); writer.write(""magazine5="" + gamepanel.rocket.magazine); writer.newline(); writer.write(""capacity5="" + gamepanel.rocket.currentcapacity); writer.newline(); system.out.println(""saved""); } catch (ioexception e) { e.printstacktrace(); } } public void loadgame() { try (bufferedreader reader = new bufferedreader(new filereader(""save.txt""))) { string line; while ((line = reader.readline()) != null) { string[] parts = line.split(""=""); string key = parts[0]; string value = parts[1]; switch (key) { case ""wave"": gamepanel.wavemanager.wave = integer.parseint(value); break; case ""rain"": settings.rain = boolean.parseboolean(value); break; case ""extreme"": settings.extreme = boolean.parseboolean(value); break; case ""playerx"": gamepanel.player.setx(integer.parseint(value)); break; case ""playery"": gamepanel.player.sety(integer.parseint(value)); break; case ""players"": gamepanel.player.score = integer.parseint(value); break; case ""playerh"": gamepanel.player.sethealth(double.parsedouble(value)); break; case ""playerf"": gamepanel.player.setfatigue(double.parsedouble(value)); break; case ""camerax"": gamepanel.camera.setx(integer.parseint(value)); break; case ""cameray"": gamepanel.camera.sety(integer.parseint(value)); break; case ""deadzombies"": gamepanel.wavemanager.dead = integer.parseint(value); break; case ""magazine2"": gamepanel.rifle.magazine = integer.parseint(value); break; case ""capacity2"": gamepanel.rifle.currentcapacity = integer.parseint(value); break; case ""magazine3"": gamepanel.shotgun.magazine = integer.parseint(value); break; case ""capacity3"": gamepanel.shotgun.currentcapacity = integer.parseint(value); break; case ""magazine4"": gamepanel.sniper.magazine = integer.parseint(value); break; case ""capacity4"": gamepanel.sniper.currentcapacity = integer.parseint(value); break; case ""magazine5"": gamepanel.rocket.magazine = integer.parseint(value); break; case ""capacity5"": gamepanel.rocket.currentcapacity = integer.parseint(value); break; } } system.out.println(""load""); } catch (ioexception e) { e.printstacktrace(); } } } import java.io.file; import javax.swing.imageicon; public class pistol extends weapon{ gamepanel game; public pistol(gamepanel game){ capacity = 12; currentcapacity = 12; shootspeed = 120; magazine = integer.max_value; wave = 0; reloadcooldown = 5000; this.game = game; name = ""pistol""; image = new imageicon(""textures/weapons/pistol.png""); bulletimage = new imageicon(this.getclass().getresource(""/textures/weapons/pistol_bullet.png"")); soundpath = new file(""pistolsound.wav""); } void shoot(int mousex, int mousey) { if(currentcapacity>0){ if(settings.volume){ playsound(); } currentcapacity -= 1; game.addbullet(mousex, mousey); } } } import java.awt.color; import java.awt.dimension; import java.awt.font; import java.awt.graphics; import java.awt.graphics2d; import java.awt.image; import java.io.file; import java.io.ioexception; import java.util.arraylist; import java.util.random; import javax.sound.sampled.audioinputstream; import javax.sound.sampled.audiosystem; import javax.sound.sampled.clip; import javax.sound.sampled.lineunavailableexception; import javax.sound.sampled.unsupportedaudiofileexception; import javax.swing.imageicon; import javax.swing.jpanel; class gamepanel extends jpanel{ public arraylist<bullet> bullets = new arraylist<>(); int playerwidth = 96; int playerheight = 96; int playerspeed = 5; public player player = new player(480, 270, playerwidth, playerheight, playerspeed, this); public camera camera = new camera(0, 0, 0, 0); public background bg = new background(0, 0, 6144, 3456); private mousecursor mousecursor = new mousecursor(0, 0, 32, 32); arraylist<building> buildings = new arraylist<>(); imageicon gif = new imageicon(this.getclass().getresource(""/textures/ui/rain.gif"")); pistol pistol = new pistol(this); rifle rifle = new rifle(this); shotgun shotgun = new shotgun(this); sniper sniper = new sniper(this); rocketlauncher rocket = new rocketlauncher(this); weapon currentweapon = pistol; protected double mouseangle = 0; private keyinput keyinput = new keyinput(); private mouseinput mouseinput; int active = 0; private image playerimage = new imageicon(""textures/player/player_icon.png"").getimage(); private image weaponimage; private font uifont; public long lastreloadtime = 0; public long currenttime = 0; public long deadtime = 0; long pausetime = 0; gameover gameover = new gameover(0, 0, 0, 0); pause pause = new pause(0, 0, 0, 0); int panelheight; int panelwidth; file rainsound = new file(""rain.wav""); audioinputstream raininput; clip rainclip; file musicsound = new file(""music.wav""); audioinputstream musicinput; clip musicclip; boolean ispaused; wavemanager wavemanager = new wavemanager(this); private gamesavemanager savemanager; window window; public gamepanel(window window) throws unsupportedaudiofileexception, ioexception, lineunavailableexception{ this.window = window; setfocusable(true); requestfocus(); setlayout(null); player.setvisible(true); addkeylistener(keyinput); raininput = audiosystem.getaudioinputstream(rainsound); rainclip = audiosystem.getclip(); rainclip.open(raininput); rainclip.setframeposition(0); musicinput = audiosystem.getaudioinputstream(musicsound); musicclip = audiosystem.getclip(); musicclip.open(musicinput); musicclip.setframeposition(0); if(settings.volume){ musicclip.loop(clip.loop_continuously); if(settings.rain){ rainclip.loop(clip.loop_continuously); } } for(int i = 0; i < 23; i++){ buildings.add(new building(0, 0, 512, 512)); } for(building building: buildings){ building.getplayer(player); } currentweapon = pistol; player.changeimage(currentweapon); lastreloadtime = system.currenttimemillis(); weaponimage = currentweapon.image.getimage(); mouseinput = new mouseinput(this, currentweapon); addmousemotionlistener(mouseinput); addmouselistener(mouseinput); savemanager = new gamesavemanager(this); savemanager.loadgame(); savemanager.loadsettings(); setbuildings(); } public void mousepressed(int mousex, int mousey){ addbullet(mousex, mousey); } private void renderui(graphics g, int w, int h) { graphics2d g2d = (graphics2d) g; uifont = new font(""courier new"", font.bold, w/60); g2d.setfont(uifont); g2d.setcolor(new color(0, 0, 0, 150)); g2d.fillroundrect(w - (int)(w/3.8) - (int)(w/100), (int)(w/100), (int)(w/3.8), w/14, 20, 20); g2d.fillroundrect((int)(w/100), (int)(w/100), (int)(w/4.5), w/20, 20, 20); g2d.drawimage(playericon(player.gethealth()).getimage(), w - w/16 - w/72, w/72, w/16, w/16, null); g2d.setcolor(color.white); g2d.drawstring(""score:"" + player.score, w - w/4, w/15); uifont = new font(""courier new"", font.bold, w/80); g2d.setfont(uifont); g2d.drawimage(weaponimage, w/55, w/65, w/24, w/24, null); g2d.setcolor(color.red); g2d.fillrect(w - w/6 - w/12, w/48, (int)(player.gethealth()*w/6/100), w/96); g2d.setcolor(color.white); g2d.drawrect(w - w/6 - w/12, w/48, w/6, w/96); g2d.setcolor(new color(0,75,150)); g2d.fillrect(w - w/6 - w/12, w/32, (int)(player.getfatigue()*w/6/100), w/96); g2d.setcolor(color.white); g2d.drawrect(w- w/6 - w/12, w/32, w/6, w/96); int reloadbar = (int)((currenttime-lastreloadtime)*currentweapon.reloadcooldown/7/w/24); if(reloadbar>w/24){ reloadbar = w/24; } g2d.setcolor(new color(75,150,0)); g2d.fillrect(w/55, w/60, reloadbar, w/160); g2d.setcolor(color.white); g2d.drawrect(w/55, w/60, w/24, w/160); g2d.setcolor(color.white); g2d.drawstring(""bullet: "" + currentweapon.currentcapacity + ""/"" + currentweapon.magazine, w/15, w/20); g2d.drawstring(""weapon: "" + currentweapon.name, w/15, w/35); g2d.setcolor(new color(200,100,0,255)); g2d.fillrect(w/3, w/50, (int)(((double)(wavemanager.zombies.size())/wavemanager.wave/wavemanager.mult)*w/3), w/50); g2d.setcolor(color.white); g2d.drawrect(w/3, w/50, w/3, w/50); g2d.drawstring(""wave: "" + wavemanager.wave, w/3, w/50); string str = wavemanager.zombies.size() + ""/"" + (int)(wavemanager.wave*wavemanager.mult); g2d.drawstring(str, w/3 + w/3 - str.length()*w/130, w/25); g2d.drawstring(""press 'k' to save the game"", w - w/5, h - h/35); } public imageicon playericon(double health){ if(health>80){ return new imageicon(""textures/player/player_icon.png""); } else if(health>60){ return new imageicon(""textures/player/player_icon2.png""); } else if(health>40){ return new imageicon(""textures/player/player_icon3.png""); } else if(health>20){ return new imageicon(""textures/player/player_icon4.png""); } else{ return new imageicon(""textures/player/player_icon5.png""); } } public int getrandomnumber(int min, int max) { return (int) ((math.random() * (max - min)) + min); } public void addbullet(int x, int y){ double ang = 0; if(currentweapon instanceof pistol){ ang = 0; bullets.add(new bullet(player.getx() - camera.getx() + player.getwidth()/2, player.gety() - camera.gety() + player.getheight()/2, x, y, currentweapon, ang, wavemanager, camera)); } else if(currentweapon instanceof rifle){ ang = getrandomnumber(-15, 15); bullets.add(new bullet(player.getx() - camera.getx() + player.getwidth()/2, player.gety() - camera.gety() + player.getheight()/2, x, y, currentweapon, ang, wavemanager, camera)); } else if(currentweapon instanceof shotgun){ ang = -22.5; for(int i = 0; i < 9; i++){ bullets.add(new bullet(player.getx() - camera.getx() + player.getwidth()/2, player.gety() - camera.gety() + player.getheight()/2, x, y, currentweapon, ang, wavemanager, camera)); ang += 5.0; } } else if(currentweapon instanceof sniper){ ang = 0; bullets.add(new bullet(player.getx() - camera.getx() + player.getwidth()/2, player.gety() - camera.gety() + player.getheight()/2, x, y, currentweapon, ang, wavemanager, camera)); } else if(currentweapon instanceof rocketlauncher){ ang = 0; bullets.add(new bullet(player.getx() - camera.getx() + player.getwidth()/2, player.gety() - camera.gety() + player.getheight()/2, x, y, currentweapon, ang, wavemanager, camera)); } } public void setbuildings(){ int a = 64; buildings.get(0).setx(bg.x+2*a); buildings.get(0).sety(bg.y+6*a); buildings.get(0).setbuilding(0); buildings.get(1).setx(bg.x+2*a); buildings.get(1).sety(bg.y+17*a); buildings.get(1).setbuilding(6); buildings.get(2).setx(bg.x+2*a); buildings.get(2).sety(bg.y+27*a); buildings.get(2).setbuilding(13); buildings.get(3).setx(bg.x+2*a); buildings.get(3).sety(bg.y+44*a); buildings.get(3).setbuilding(3); buildings.get(4).setx(bg.x+19*a); buildings.get(4).sety(bg.y+2*a); buildings.get(4).setbuilding(3); buildings.get(5).setx(bg.x+19*a); buildings.get(5).sety(bg.y+12*a); buildings.get(5).setbuilding(11); buildings.get(6).setx(bg.x+19*a); buildings.get(6).sety(bg.y+29*a); buildings.get(6).setbuilding(2); buildings.get(7).setx(bg.x+19*a); buildings.get(7).sety(bg.y+39*a); buildings.get(7).setbuilding(1); buildings.get(8).setx(bg.x+29*a); buildings.get(8).sety(bg.y+2*a); buildings.get(8).setbuilding(7); buildings.get(9).setx(bg.x+29*a); buildings.get(9).sety(bg.y+12*a); buildings.get(9).setbuilding(4); buildings.get(10).setx(bg.x+29*a); buildings.get(10).sety(bg.y+29*a); buildings.get(10).setbuilding(7); buildings.get(11).setx(bg.x+29*a); buildings.get(11).sety(bg.y+39*a); buildings.get(11).setbuilding(5); buildings.get(12).setx(bg.x+39*a); buildings.get(12).sety(bg.y+29*a); buildings.get(12).setbuilding(3); buildings.get(13).setx(bg.x+39*a); buildings.get(13).sety(bg.y+39*a); buildings.get(13).setbuilding(9); buildings.get(14).setx(bg.x+46*a); buildings.get(14).sety(bg.y+2*a); buildings.get(14).setbuilding(6); buildings.get(15).setx(bg.x+46*a); buildings.get(15).sety(bg.y+12*a); buildings.get(15).setbuilding(9); buildings.get(16).setx(bg.x+56*a); buildings.get(16).sety(bg.y+29*a); buildings.get(16).setbuilding(2); buildings.get(17).setx(bg.x+56*a); buildings.get(17).sety(bg.y+39*a); buildings.get(17).setbuilding(12); buildings.get(18).setx(bg.x+73*a); buildings.get(18).sety(bg.y+29*a); buildings.get(18).setbuilding(8); buildings.get(19).setx(bg.x+73*a); buildings.get(19).sety(bg.y+46*a); buildings.get(19).setbuilding(3); buildings.get(20).setx(bg.x+83*a); buildings.get(20).sety(bg.y+12*a); buildings.get(20).setbuilding(5); buildings.get(21).setx(bg.x+83*a); buildings.get(21).sety(bg.y+29*a); buildings.get(21).setbuilding(10); buildings.get(22).setx(bg.x+83*a); buildings.get(22).sety(bg.y+46*a); buildings.get(22).setbuilding(7); } protected void paintcomponent(graphics g){ super.paintcomponent(g); panelheight = getheight(); panelwidth = getwidth(); setpreferredsize(new dimension(panelwidth,panelheight)); g.setcolor(new color(237,201,175)); g.fillrect(0, 0, panelwidth, panelheight); camera.follow(player, panelwidth, panelheight, 6144,3456); bg.setx(-camera.getx()); bg.sety(-camera.gety()); graphics2d g2d = (graphics2d)g; bg.draw(g); if((!(bg.x>0) && (!(bg.x<-4280)))|| (!(bg.y<-2430) && !(bg.y>0))){ setbuildings(); } for (building building : buildings) { building.draw((graphics2d)g); } g2d.translate(player.getx() - camera.getx() + player.getwidth()/2, player.gety() - camera.gety() + player.getheight()/2); g2d.rotate(mouseangle); player.draw(g2d); wavemanager.render((graphics2d)g, camera); for (bullet bullet : bullets) { bullet.draw((graphics2d)g); } mousecursor.draw((graphics2d)g, mouseinput.getmousex(), mouseinput.getmousey()); if(settings.rain){ g.drawimage(gif.getimage(), 0, 0, panelwidth, panelheight, null); } g.setcolor(new color(0,0,0,150-(int)player.getfatigue())); g.fillrect(0,0,panelwidth,panelheight); g.setcolor(new color(128,0,0,50-(int)player.gethealth()/2)); g.fillrect(0,0,panelwidth,panelheight); renderui(g, panelwidth, panelheight); if(player.isdead()){ gameover.set(panelwidth, panelheight); gameover.draw((graphics2d)g); } if(ispaused){ pause.set(panelwidth, panelheight); pause.draw((graphics2d)g); } } public void update(){ if(!ispaused){ update2(); } else{ if(keyinput.isesc()){ rainclip.stop(); musicclip.stop(); musicclip = null; rainclip = null; window.switchtomenu(); } } currenttime = system.currenttimemillis(); pause.update(); repaint(); if(keyinput.isp() && currenttime - pausetime > 1000){ pausetime = currenttime; ispaused = !ispaused; } } public void update2(){ repaint(); //system.out.println(""player position - x: "" + player.getx() + "", y: "" + player.gety()); //system.out.println(bg.getx()); //system.out.println(bg.y); //system.out.println(camera.gety()); if(!player.isdead()){ player.update(); mouseinput.update(); mousecursor.update(); mouseangle = math.pi/2 + math.atan2(mouseinput.getmousey() - (player.gety() - camera.gety() + player.getheight()/2) , mouseinput.getmousex() - (player.getx() - camera.getx() + player.getwidth()/2)); } else{ gameover.update(); } if (player.getx() < 0) { player.setx(0); } if (player.gety() < 0) { player.sety(0); } if (player.getx() + player.getwidth() > bg.getwidth()) { player.setx(bg.getwidth() - player.getwidth()); } if (player.gety() + player.getheight() > bg.getheight()) { player.sety(bg.getheight() - player.getheight()); } wavemanager.update(); for (int i = 0; i < bullets.size(); i++) { bullet b = bullets.get(i); b.update(); if (b.isoutofbounds()) { b.enabled = false; } if(!b.enabled){ bullets.remove(i); i--; } } if(keyinput.isdown()){ player.vely = player.getspeed(); } else if(!keyinput.isup()){ player.vely = 0; } if(keyinput.isup()){ player.vely = player.getspeed() * -1; } else if(!keyinput.isdown()){ player.vely = 0; } if(keyinput.isleft()){ player.velx = player.getspeed() * -1; } else if(!keyinput.isright()){ player.velx = 0; } if(keyinput.isright()){ player.velx = player.getspeed(); } else if(!keyinput.isleft()){ player.velx = 0; } if(keyinput.isr()){ if(currenttime - lastreloadtime > currentweapon.reloadcooldown){ if(currentweapon.magazine>0){ currentweapon.reload(); lastreloadtime = currenttime; } } } if(keyinput.ist() && player.isdead()){ player.sethealth(100); player.setfatigue(100); deadtime = currenttime; gameover = new gameover(0, 0, 0, 0); player.score -= 50 * wavemanager.wave; } if(keyinput.isk()){ savemanager.savegame(); } if(keyinput.isp()){ pause = new pause(0, 0, 0, 0); } if(keyinput.is1()){ currentweapon = pistol; player.changeimage(currentweapon); weaponimage = currentweapon.image.getimage(); mouseinput = new mouseinput(this, currentweapon); addmousemotionlistener(mouseinput); addmouselistener(mouseinput); } if(keyinput.is2() && wavemanager.wave >= rifle.wave){ currentweapon = rifle; player.changeimage(currentweapon); weaponimage = currentweapon.image.getimage(); mouseinput = new mouseinput(this, currentweapon); addmousemotionlistener(mouseinput); addmouselistener(mouseinput); } if(keyinput.is3() && wavemanager.wave >= shotgun.wave){ currentweapon = shotgun; player.changeimage(currentweapon); weaponimage = currentweapon.image.getimage(); mouseinput = new mouseinput(this, currentweapon); addmousemotionlistener(mouseinput); addmouselistener(mouseinput); } if(keyinput.is4() && wavemanager.wave >= sniper.wave){ currentweapon = sniper; player.changeimage(currentweapon); weaponimage = currentweapon.image.getimage(); mouseinput = new mouseinput(this, currentweapon); addmousemotionlistener(mouseinput); addmouselistener(mouseinput); } if(keyinput.is5() && wavemanager.wave >= rocket.wave){ currentweapon = rocket; player.changeimage(currentweapon); weaponimage = currentweapon.image.getimage(); mouseinput = new mouseinput(this, currentweapon); addmousemotionlistener(mouseinput); addmouselistener(mouseinput); } if(bg.getx()>1){ bg.setx(0); } if(bg.gety()>1){ bg.sety(0); } if(bg.getx()<-4281){ bg.setx(-4280); } if(bg.gety()<-2431){ bg.sety(-2430); } if(keyinput.isshift() && !player.isdead()){ if(player.getfatigue()>0){ player.setspeed(10); player.setfatigue(player.getfatigue()-0.25); } else{ player.setspeed(5); } } else{ player.setspeed(5); player.setfatigue(player.getfatigue()+0.5); } } } import java.awt.graphics2d; import javax.swing.imageicon; public class uielement extends gameobject { imageicon button; public uielement(int x, int y, int width, int height, imageicon imageicon) { super(x, y, width, height); button = imageicon; } public void draw(graphics2d g) { g.drawimage(button.getimage(), x, y, width, height, null); } } import java.awt.graphics2d; import javax.swing.imageicon; public class healthkit extends gameobject{ imageicon healthkit = new imageicon(this.getclass().getresource(""/textures/zombies/healthkit.gif"")); public healthkit(int x, int y, int width, int height) { super(x, y, width, height); } public void draw2(graphics2d g, camera cam) { g.drawimage(healthkit.getimage(), x - cam.x, y - cam.y, width, height, null); } public void draw(graphics2d g) { throw new unsupportedoperationexception(""unimplemented method 'draw'""); } } import java.io.file; import javax.swing.imageicon; public class rifle extends weapon{ gamepanel game; public rifle(gamepanel game){ capacity = 30; currentcapacity = 30; shootspeed = 600; wave = 2; reloadcooldown = 5000; this.game = game; name = ""rifle""; image = new imageicon(""textures/weapons/rifle.png""); bulletimage = new imageicon(this.getclass().getresource(""/textures/weapons/rifle_bullet.png"")); soundpath = new file(""riflesound.wav""); } void shoot(int mousex, int mousey) { if(currentcapacity>0){ if(settings.volume){ playsound(); } currentcapacity -= 1; game.addbullet(mousex, mousey); } } } import java.awt.graphics2d; import java.awt.image; import java.awt.toolkit; import java.io.file; import javax.sound.sampled.audioinputstream; import javax.sound.sampled.audiosystem; import javax.sound.sampled.clip; public class explosion extends gameobject{ image explosion; public file explosionpath = new file(""explosionsound.wav""); public audioinputstream audioinput; public clip clip; public explosion(int x, int y, int width, int height) { super(x, y, width, height); explosion = toolkit.getdefaulttoolkit().createimage(this.getclass().getresource(""/textures/weapons/explosion.gif"")); if(settings.volume){ try{ audioinput = audiosystem.getaudioinputstream(explosionpath); clip = audiosystem.getclip(); clip.open(audioinput); clip.setframeposition(0); clip.start(); system.out.println(""e""); } catch(exception e){ } } } public void draw2(graphics2d g, camera cam) { g.drawimage(explosion, x - cam.x, y - cam.y, width, height, null); } public void draw(graphics2d g) { } public void update() { } } import java.awt.graphics; import java.awt.graphics2d; import javax.swing.imageicon; public class background extends gameobject { public imageicon backgroundimage1 = new imageicon(this.getclass().getresource(""/textures/backgrounds/city.png"")); public imageicon black = new imageicon(this.getclass().getresource(""/textures/backgrounds/bg2.png"")); public background(int x, int y, int width, int height){ super(x, y, width, height); } public void update() { } public void draw(graphics2d g) { } public void draw(graphics g) { g.drawimage(backgroundimage1.getimage(), x, y, width, height, null); g.drawimage(black.getimage(), x, y, width, height, null); } } import java.awt.color; import java.awt.graphics2d; import java.awt.rectangle; import java.awt.geom.affinetransform; import javax.swing.imageicon; public class tankzombie extends zombie{ private imageicon tankzombieimage = new imageicon(this.getclass().getresource(""/textures/zombies/tankzombie.png"")); public tankzombie(int x, int y, player player, camera camera){ super(x,y,96,96); this.health = 40; this.speed = 2; this.damage = 0.3; this.player = player; this.camera = camera; this.visible = true; } void attack() { if (isnearplayer && player.isplayerattackable()) { player.sethealth(player.gethealth()-damage); //system.out.println(""attack "" + player.gethealth()); } } public void update() { double dx = player.x - x; double dy = player.y - y; // i̇ki nokta arasındaki mesafe double distance = math.sqrt(dx * dx + dy * dy); if(distance < 1000){ movetowardsplayer(); } attack(); } public void draw2(graphics2d g) { if (visible) { // oyuncunun merkezi ile zombinin merkezi arasındaki açı double dx = player.getx() + player.getwidth() / 2.0 - (x + width/2); double dy = player.gety() + player.getheight() / 2.0 - (y + height/2); double angle = math.atan2(dy, dx) + math.pi / 2; g.translate(x - camera.getx() + width/2, y - camera.gety() + height/2); g.rotate(angle); g.drawimage(tankzombieimage.getimage(), -width/2, -height/2, width, height, null); g.settransform(new affinetransform()); g.setcolor(new color(215,0,0)); g.fillrect(x - camera.getx() + 15, y - camera.gety(), (int)((width-30) * (health / 40)), 5); g.setcolor(new color(255,255,255)); g.drawrect(x - camera.getx() + 15, y - camera.gety(), (width-30), 5); } rectangle bounds1 = new rectangle((int) x - camera.x, (int) y - camera.y, width, height); //g.draw(bounds1); } @override public void draw(graphics2d g) { // todo auto-generated method stub throw new unsupportedoperationexception(""unimplemented method 'draw'""); } } import java.awt.graphics2d; import java.awt.image; import java.awt.toolkit; import java.io.file; import javax.sound.sampled.audioinputstream; import javax.sound.sampled.audiosystem; import javax.sound.sampled.clip; public class acidarea extends gameobject{ image acid; public file acidpath = new file(""acid.wav""); public audioinputstream audioinput; public clip clip; public acidarea(int x, int y, int width, int height) { super(x, y, width, height); acid = toolkit.getdefaulttoolkit().createimage(this.getclass().getresource(""/textures/zombies/acid.gif"")); if(settings.volume){ try{ audioinput = audiosystem.getaudioinputstream(acidpath); clip = audiosystem.getclip(); clip.open(audioinput); clip.setframeposition(0); clip.start(); system.out.println(""e""); } catch(exception e){ } } } public void draw2(graphics2d g, camera cam) { g.drawimage(acid, x - cam.x, y - cam.y, (int)(width*1.5), (int)(height*1.5), null); } public void draw(graphics2d g) { } public void update() { } } import java.awt.alphacomposite; import java.awt.color; import java.awt.font; import java.awt.graphics2d; import javax.swing.imageicon; public class gameover extends gameobject{ int a; private font uifont; imageicon deadicon = new imageicon(this.getclass().getresource(""/textures/ui/dead.png"")); public gameover(int x, int y, int width, int height) { super(x, y, width, height); } public void set(int w, int h){ width = w; height = h; uifont = new font(""courier new"", font.bold, w/40); } public void update(){ if(a<150) a += 3; } public void draw(graphics2d g) { g.setcolor(new color(0,0,0,a)); g.fillrect(0, 0, width , height); g.setcolor(new color(255,255,255)); g.setfont(uifont); float alpha = a/150.0f; alphacomposite ac = alphacomposite.getinstance(alphacomposite.src_over,alpha); g.setcomposite(ac); g.drawimage(deadicon.getimage(), width/3, width/8,width/3,width/18, null); g.drawstring(""press 't' for respawn"", width/2 - (int)(width/6.5), height/2); } } import java.awt.cursor; import java.awt.image; import java.awt.point; import java.awt.toolkit; import java.awt.image.memoryimagesource; import java.io.ioexception; import javax.sound.sampled.lineunavailableexception; import javax.sound.sampled.unsupportedaudiofileexception; import javax.swing.imageicon; import javax.swing.jframe; public class game{ static window window; public static void main(string[] args) throws ioexception{ create(); } public static void create(){ try { window = new window(); window.start(); window.run(); } catch (unsupportedaudiofileexception e) { e.printstacktrace(); } catch (ioexception e) { e.printstacktrace(); } catch (lineunavailableexception e) { e.printstacktrace(); } } public static void close(){ window.dispose(); } } class window extends jframe{ private gamepanel gamepanel; private menu menupanel; private thread thread; private boolean running = false; public static int width = 960; public static int height = 540; public static boolean gameon = false; public static boolean fs = false; public void start(){ running = true; thread = new thread(); thread.start(); } public void run(){ while(running){ update(); repaint(); try{ thread.sleep(16); } catch(interruptedexception e){ e.printstacktrace(); } } } private void update(){ if(gameon && gamepanel!=null){ gamepanel.update(); } else{ menupanel.update(); } setsize(width,height); } public cursor pointer(){ int[] pixels = new int[16 * 16]; image image = toolkit.getdefaulttoolkit().createimage(new memoryimagesource(16, 16, pixels, 0, 16)); cursor transparentcursor = toolkit.getdefaulttoolkit().createcustomcursor(image, new point(0, 0), ""invisiblecursor""); return transparentcursor; } gamesavemanager savemanager = new gamesavemanager(); public window() throws unsupportedaudiofileexception, ioexception, lineunavailableexception{ if(gameon){ gamepanel = new gamepanel(this); add(gamepanel); } else{ menupanel = new menu(this); add(menupanel); } imageicon gameicon = new imageicon(this.getclass().getresource(""/textures/icon.png"")); setsize(width,height); setlocation((int)toolkit.getdefaulttoolkit().getscreensize().getwidth()/2 - width/2, (int)toolkit.getdefaulttoolkit().getscreensize().getheight()/2 - height/2); //setextendedstate(jframe.maximized_both); //tam ekran i̇çi̇n setundecorated(fs); setdefaultcloseoperation(exit_on_close); settitle(""gravewave""); seticonimage(gameicon.getimage()); setcursor(pointer()); setvisible(true); setresizable(false); savemanager.loadsettings(); if(settings.fullscreen){ fs = false; fullscreen(); changesize((int)toolkit.getdefaulttoolkit().getscreensize().getwidth(), (int)toolkit.getdefaulttoolkit().getscreensize().getheight()); } else{ fs = true; changesize(960, 540); fullscreen(); } } public void switchtomenu() { gameon = false; game.close(); game.create(); } public void changesize(int w, int h){ width = w; height = h; } public void fullscreen(){ if(!fs){ dispose(); fs = true; setundecorated(true); setextendedstate(maximized_both); setvisible(true); } else{ dispose(); fs = false; setundecorated(false); setlocationrelativeto(null); setvisible(true); } } } import java.awt.event.mouseadapter; import java.awt.event.mouseevent; import javax.swing.jpanel; public class mouseinput extends mouseadapter{ private int mousex, mousey; private jpanel game; public boolean ismousepressed; weapon weapon; private long lastbullettime = 0; public static long bulletfireinterval = 500; public void update(){ long currenttime = system.currenttimemillis(); if(ismousepressed && game instanceof gamepanel){ if(currenttime - lastbullettime >= bulletfireinterval){ lastbullettime = currenttime; weapon.shoot(mousex, mousey); } } } public mouseinput(jpanel game, weapon weapon){ this.game = game; this.weapon = weapon; bulletfireinterval = (long)(60.0/weapon.shootspeed*1000); } public mouseinput(jpanel game){ this.game = game; } public int getmousex(){ return mousex; } public int getmousey(){ return mousey; } public void mousemoved(mouseevent e) { mousex = e.getx(); mousey = e.gety(); } public void mousedragged(mouseevent e) { mousex = e.getx(); mousey = e.gety(); } public void mousepressed(mouseevent e) { ismousepressed = true; } public void mousereleased(mouseevent e){ ismousepressed = false; } } import java.awt.graphics2d; public class camera extends gameobject{ public camera(int x, int y, int width, int height) { super(x, y, width, height); } public void update() { } public void draw(graphics2d g) { } public void follow(gameobject gameobject, int panelwidth, int panelheight, int bgwidth, int bgheight) { x += ((gameobject.getx() - x) - panelwidth / 2 + gameobject.getwidth() / 2) * 0.05f; y += ((gameobject.gety() - y) - panelheight / 2 + gameobject.getheight() / 2) * 0.05f; if (x < 0) { x = 0; } if (x > bgwidth - panelwidth) { x = bgwidth - panelwidth; } if (y < 0) { y = 0; } if (y > bgheight - panelheight) { y = bgheight - panelheight; } } } import java.io.file; import javax.swing.imageicon; public class rocketlauncher extends weapon{ gamepanel game; public rocketlauncher(gamepanel game){ capacity = 1; currentcapacity = 1; shootspeed = 10; speed = 10; wave = 11; reloadcooldown = 5000; this.game = game; name = ""rocket launcher""; image = new imageicon(""textures/weapons/rocket launcher.png""); bulletimage = new imageicon(this.getclass().getresource(""/textures/weapons/rocket_bullet.png"")); soundpath = new file(""rocketsound.wav""); } void shoot(int mousex, int mousey) { if(currentcapacity>0){ if(settings.volume){ playsound(); } currentcapacity -= 1; game.addbullet(mousex, mousey); } } } public class settings { public static boolean fullscreen, rain = true, extreme, volume = true; } import java.awt.graphics2d; import java.awt.rectangle; import java.awt.geom.affinetransform; import java.io.file; import javax.sound.sampled.audioinputstream; import javax.sound.sampled.audiosystem; import javax.sound.sampled.clip; import javax.swing.imageicon; public class player extends gameobject { private int speed; private imageicon playerimage = new imageicon(this.getclass().getresource(""/textures/player/player_pistol.png"")); private imageicon pistolplayer = new imageicon(this.getclass().getresource(""/textures/player/player_pistol.png"")); private imageicon rifleplayer = new imageicon(this.getclass().getresource(""/textures/player/player_rifle.png"")); private imageicon shotgunplayer = new imageicon(this.getclass().getresource(""/textures/player/player_shotgun.png"")); private imageicon sniperplayer = new imageicon(this.getclass().getresource(""/textures/player/player_sniper.png"")); private imageicon rocketplayer = new imageicon(this.getclass().getresource(""/textures/player/player_rocket.png"")); public double velx, vely; private double health; private double fatigue; private gamepanel gamepanel; public boolean collusion = false; public int score; public file path = new file(""collectsound.wav""); public audioinputstream audioinput; public clip clip; public player(int x, int y, int width, int height, int speed, gamepanel gamepanel) { super(x, y, width, height); this.speed = speed; this.gamepanel = gamepanel; health = 100; fatigue = 100; } public void changeimage(weapon weapon){ if(weapon instanceof pistol){ playerimage = pistolplayer; } if(weapon instanceof rifle){ playerimage = rifleplayer; } if(weapon instanceof shotgun){ playerimage = shotgunplayer; } if(weapon instanceof sniper){ playerimage = sniperplayer; } if(weapon instanceof rocketlauncher){ playerimage = rocketplayer; } } public boolean isplayerattackable(){ return gamepanel.currenttime - gamepanel.deadtime > 3000; } public void update() { if(health > 100){ health = 100; } if(health < 0){ health = 0; } x += velx; y += vely; collusion = false; for(building building: gamepanel.buildings){ if(checkcollusion(gamepanel.camera, building)){ collusion = true; if (velx > 0) { x -= velx; velx = 0; } if (velx < 0) { x -= velx; velx = 0; } if (vely > 0) { y -= vely; vely = 0; } if (vely < 0) { y -= vely; vely = 0; } } } for(int i = 0; i < gamepanel.wavemanager.healthkits.size(); i++){ if(checkcollusion(gamepanel.camera, gamepanel.wavemanager.healthkits.get(i))){ gamepanel.wavemanager.healthkits.remove(gamepanel.wavemanager.healthkits.get(i)); health += 10; score += gamepanel.wavemanager.wave*3; i--; if(settings.volume){ new thread(() -> { try{ audioinput = audiosystem.getaudioinputstream(path); clip = audiosystem.getclip(); clip.open(audioinput); clip.setframeposition(0); clip.start(); system.out.println(""c""); } catch(exception e){ } }).start(); } } } for(int i = 0; i < gamepanel.wavemanager.magazines.size(); i++){ if(checkcollusion(gamepanel.camera, gamepanel.wavemanager.magazines.get(i))){ gamepanel.wavemanager.magazines.remove(gamepanel.wavemanager.magazines.get(i)); if(!(gamepanel.currentweapon instanceof pistol)){ gamepanel.currentweapon.magazine += gamepanel.currentweapon.capacity; } score += gamepanel.wavemanager.wave *3; i--; if(settings.volume){ new thread(() -> { try{ audioinput = audiosystem.getaudioinputstream(path); clip = audiosystem.getclip(); clip.open(audioinput); clip.setframeposition(0); clip.start(); system.out.println(""c""); } catch(exception e){ } }).start(); } } } //system.out.println(x); //system.out.println(gamepanel.buildings.get(0).getx() + "" "" + gamepanel.buildings.get(0).gety()); } public int getspeed(){ return speed; } public void setspeed(int speed){ this.speed = speed; } public void draw(graphics2d g) { if(visible){ g.drawimage(playerimage.getimage(), -width/2, -height/2, width, height, null); g.settransform(new affinetransform()); } rectangle bounds1 = new rectangle((int) x - gamepanel.camera.x + (int)velx, (int) y - gamepanel.camera.y + (int)vely, width, height); //g.draw(bounds1); } public double gethealth(){ return health; } public void sethealth(double health){ this.health = health; } public double getfatigue(){ return fatigue; } public void setfatigue(double fatigue){ if(this.fatigue<=100){ this.fatigue = fatigue; } if(this.fatigue>100){ this.fatigue = 100; } } public boolean isdead(){ return health<=0; } } import java.awt.graphics2d; import java.awt.rectangle; public abstract class gameobject { protected int x, y; protected int width, height; protected boolean visible; protected double velx, vely; public gameobject(int x, int y, int width, int height){ this.x = x; this.y = y; this.width = width; this.height = height; this.visible = true; } public abstract void update(); public abstract void draw(graphics2d g); public boolean isvisible(){ return visible; } public void setvisible(boolean visible){ this.visible = visible; } public int getx(){ return x; } public int gety(){ return y; } public void setx(int x){ this.x = x; } public void sety(int y){ this.y = y; } public void setwidth(int width){ this.width = width; } public void setheight(int height){ this.height = height; } public int getwidth(){ return width; } public int getheight(){ return height; } public boolean checkcollusion(camera camera, gameobject other) { rectangle bounds1 = new rectangle((int) x, (int) y, width, height); rectangle bounds2 = new rectangle((int) other.getx(), (int) other.gety(), other.getwidth(), other.getheight()); if(this instanceof player && other instanceof building){ bounds1 = new rectangle((int) x - camera.x + (int)velx*2, (int) y - camera.y + (int)vely*2, width, height); bounds2 = new rectangle((int) other.getx(), (int) other.gety(), other.getwidth(), other.getheight()); } if(other instanceof zombie && this instanceof bullet){ bounds2 = new rectangle((int) other.getx() - camera.x, (int) other.gety() - camera.y, other.getwidth(), other.getheight()); } if(this instanceof zombie && other instanceof building){ bounds1 = new rectangle((int) x - camera.x + (int)velx*2, (int) y - camera.y + (int)vely*2, width - 10, height - 10); bounds2 = new rectangle((int) other.getx(), (int) other.gety(), other.getwidth(), other.getheight()); } if(this instanceof bullet && other instanceof building){ bounds1 = new rectangle((int) x, (int) y, width, height); bounds2 = new rectangle((int) other.getx(), (int) other.gety(), other.getwidth(), other.getheight()); } if(this instanceof player && (other instanceof healthkit || other instanceof magazine)){ bounds1 = new rectangle((int) x, (int) y, width, height); bounds2 = new rectangle((int) other.getx(), (int) other.gety(), other.getwidth(), other.getheight()); } if(this instanceof explosion && other instanceof zombie){ bounds1 = new rectangle((int) x, (int) y, width, height); bounds2 = new rectangle((int) other.getx(), (int) other.gety(), other.getwidth(), other.getheight()); } if(this instanceof acidarea && other instanceof zombie){ bounds1 = new rectangle((int) x, (int) y, width, height); bounds2 = new rectangle((int) other.getx(), (int) other.gety(), other.getwidth(), other.getheight()); } if(this instanceof player && other instanceof acid){ bounds1 = new rectangle((int) x - camera.x, (int) y - camera.y, width, height); bounds2 = new rectangle((int) other.getx(), (int) other.gety(), other.getwidth(), other.getheight()); } return bounds1.intersects(bounds2); } }"
5281670,5,"5281670 müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar{ calmastratejisi strateji ; void setstrateji(calmastratejisi s){ strateji = s; } void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki){ metalsarki castedotherobj = (metalsarki) sarki; castedotherobj.gostermetalozellikleri(); } } } } public class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci) { super(isim, sanatci); } @override void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } public class metalsarki extends sarki{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(isim,sanatci); this.metalozellik = metalozellik; } @override void oynat(){ system.out.println(""[metal] "" + sanatci + "" - "" + isim +"" (enstrumantal)""); } void gostermetalozellikleri(){ system.out.println(sanatci + "" - "" + isim + "" [ozellik: ]"" + metalozellik); } } public class rocksarki extends sarki{ public rocksarki(string isim, string sanatci) { super(isim, sanatci); } @override void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } import java.util.arraylist; import java.util.collection; import java.util.collections; import java.util.list; import java.util.random; public class karisikcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { list<integer> numbers = new arraylist<>(); for (int i = 0; i < sarkilistesi.size(); i++) { numbers.add(i); } collections.shuffle(numbers); for (int index : numbers) { sarkilistesi.get(index).oynat(); } } } import java.util.list; public class siralicalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { for(int i = 0; i < sarkilistesi.size() ; i++){ sarkilistesi.get(i).oynat(); } } } abstract public class sarki { string isim; string sanatci; public sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { for(int i = 1; i < sarkilistesi.size() ; ++i){ if(sarkilistesi.get(i) instanceof rocksarki ){ system.out.println(""[bilgi] ses duzeyi : yuksek""); sarkilistesi.get(i).oynat(); if(sarkilistesi.get(i + 1) instanceof rocksarki){ sarkilistesi.get(i).oynat(); system.out.println(""[bilgi] ses duzeyi : normal""); ++i; } } sarkilistesi.get(i).oynat(); } } } import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } kelime sayıcı bil 211 - lab 3 20 şubat 2025 1 giriş bu laboratuvarda fileioveexceptions kullanarak bir kelime sayıcı geliştireceğiz. kelime sayıcı , verilen birmetindosyasındakibelirlikelimelerinkaçkezgeçtiğinisayarakbirçıktıdosyasınakaydedecekvebelirlenen hata durumlarında uygun çıktılar oluşturacaktır. 2 genel program program, aşağıdaki sabit isimlere sahip iki giriş dosyası ile çalışacaktır: -kelimeler.txt – aranacak kelimeleri içeren dosya. -metin.txt – kelimelerin aranacağı metnin bulunduğu dosya. program, kelimeler.txt dosyasındaki her kelimenin metin.txt içinde kaç kez geçtiğini sayacak ve sonucu bir çıktı dosyasına kaydedecektir: -sonuc.txt – her kelimenin kaç kez geçtiğini içeren çıktı dosyası. dosyalar,programınçalıştırıldığıdizindebulunmalıdır. dosyaisimlerideğiştirilemez,programsadeceyukarıda belirtilen isimlerle çalışacaktır. eğerkelimeler.txt içinde bulunan herhangi bir kelime, metin.txt içinde hiç geçmiyorsa, program bir hata oluşturmalı ve stderr’e uygun bir mesaj yazmalıdır. 3 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları kullanacaktır (örn., bufferredreader, scanner, printwriter). dosyaları okurken ve yazarken kullanacağınız fileio sınıflarının seçimi size bırakılmıştır. i̇şlenmesi gereken dosyalar şunlardır: -kelimeler.txt dosyası okunmalıdır. -metin.txt dosyası okunmalıdır. -sonuc.txt dosyası oluşturulup yazılmalıdır. program,aşağıdakiolasıdosyahatalarınıoluşturmalıvehatalaroluştuğundastderr’ebelirlenenhatamesajlarını yazmalıdır: - dosyabulunamıyorsa: ""hata: kelimeler.txt bulunamadı."" veya""hata: metin.txt bulunamadı."" - dosya boşsa: ""hata: kelimeler.txt boş."" veya""hata: metin.txt boş."" 4 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program hata kodu ile çıkış yapmalıdır (yani mainmetodunuz bu hataları atarak sonlanmalı) ve hatalar stderr’e yazılmalıdır (programınızı hata atarak sonlandırırsanız java bunu kendisi yapacaktır). belirtilen hata mesajları ile birlikte java’nın hata ile sonlanan programlar için oluşturduğu sınıf, metod, ve satır gibi bilgiler bulunabilir. 1 4.1 girdi hataları (inputexception class) bu kategori, programın giriş dosyalarıyla ilgili karşılaşabileceği tüm hataları kapsar. öğrenciler, dosya işlem- leriyle ilgili hata türlerini inputexception sınıfından türetmelidir. aşağıdaki özel hata türleri tanımlanmalıdır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: [dosya adı] bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: [dosya adı] boş."" 4.2 kelime bulunamadı hatası (kelimebulunamadiexception class) eğerkelimeler.txt içinde bulunan en az bir kelime, metin.txt dosyasında hiç geçmiyorsa, program kelimebulunamadiexception hatasını atmalıdır. hata yalnızca kelimeler.txt dosyasında bulunamayan ilk kelime için atılır ve program sonlanır. bu hata oluştuğunda stderr’e şu mesaj yazılmalıdır: -""hata: [kelime] metinde bulunamadı."" bu hata, doğrudan exception sınıfından türetilecek ve inputexception ile bağlantılı olmayacaktır. 5 dosya formatları program üç farklı dosya ile çalışacaktır: kelimeler.txt (girdi),metin.txt (girdi) ve sonuc.txt (çıktı). bu dosyaların formatı aşağıda belirtilmiştir. 5.1 girdi dosyaları girdi dosyaları düz metin ( .txt) formatında olacaktır ve her biri aşağıdaki gibi yapılandırılmış olmalıdır. 5.1.1kelimeler.txt formatı kelimeler.txt dosyası, her satırda bir kelime olacak şekilde düzenlenmelidir. dosyada yalnızca harf karak- terleri bulunur. kelimeler büyük/küçük harf duyarsız olarak aranacaktır. örnek i̇çerik: elma armut üzüm eğer dosya boşsa, program şu hatayı vermelidir: hata: kelimeler.txt boş. 5.1.2metin.txt formatı metin.txt dosyası, içinde aranacak kelimelerin geçebileceği serbest formatlı bir metin içermelidir. dosya içinde noktalama işaretleri ve boşluklar bulunabilir. örnek i̇çerik: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. eğer dosya boşsa, program şu hatayı vermelidir: hata: metin.txt boş. 5.2 çıktı dosyası program, kelimelerin kaç kez geçtiğini gösteren bir çıktı dosyası ( sonuc.txt ) oluşturmalıdır. 2 5.2.1sonuc.txt formatı sonuc.txt dosyası, her satırda kelimenin adı ve kaç kez geçtiği bilgisi olacak şekilde düzenlenmelidir. format şu şekilde olmalıdır: [kelime] [geçme sayısı] kelime ve geçme sayısı arasında tek bir boşluk olmalıdır. örnek çıktı ( sonuc.txt ): elma 2 armut 2 üzüm 1 5.3 özel hata durumları ve çıktıları eğerkelimeler.txt içindekiherhangibirkelime metin.txt içindebulunamazsa, kelimebulunamadiexception hatası atılmalıdır ve stderr’e şu mesaj yazılmalıdır: hata: üzüm metinde bulunamadı. bu hata oluştuğunda, yine de sonuc.txt dosyası oluşturulmalı ve bulunan kelimeler için normal çıktı yazıl- malıdır. ancak bulunamayan kelimeler çıktı dosyasına eklenmemelidir. örnek durum: eğerkelimeler.txt şu şekildeyse: elma armut muz vemetin.txt şu şekildeyse: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. o zaman sonuc.txt şu şekilde olmalıdır: elma 2 armut 2 ve stderr’e şu mesaj yazılmalıdır: hata: muz metinde bulunamadı. 6 gönderim formatı - labı bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara şeklinde isimlendirin (örn., johnnash_181101014.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""lab3 gönderim"" başlıklı bir mail ile gönderin. 3 metot açıklama string(string s) sile aynı değere sahip bir string oluşturur. string(char[] a) a[]dizisindeki karakterlerle bir string oluşturur. int length() string içindeki karakter sayısını döndürür. char charat(int i) belirtilen iindeksindeki karakteri döndürür. string substring(int i, int j) iilej-1arasındaki karakterleri içeren bir alt string döndürür. boolean contains(string substring) string’in substring ’i içerip içermediğini kontrol eder. boolean startswith(string prefix) string’in prefixile başlayıp başlamadığını kontrol eder. boolean endswith(string postfix) string’in postfix ile bitip bitmediğini kontrol eder. int indexof(string pattern) pattern ifadesinin ilk geçtiği indeks değerini döndürür. int indexof(string pattern, int i) iindeksinden sonraki ilk pattern konumunu döndürür. string concat(string t) string’in sonuna teklenmiş halini döndürür. int compareto(string t) i̇ki string’i karşılaştırır (sözlük sırasına göre). string tolowercase() string’in tüm harflerini küçük harfe çevirir. string touppercase() string’in tüm harflerini büyük harfe çevirir. string replace(string a, string b) string içindeki a’larıbile değiştirir. string trim() string’in başındaki ve sonundaki boşlukları kaldırır. boolean matches(string regex) string’in belirtilen regexle eşleşip eşleşmediğini kontrol eder. string[] split(string delimiter) string’idelimiter kullanarak böler ve bir dizi döndürür. boolean equals(object t) string’in değeri tile aynı mı diye kontrol eder. table 1: java string sınıfı metotları 4 import java.io.*; import java.util.*; public class main { public static void main(string[] args) { try { list<string> kelimeler = dosyaoku(""kelimeler.txt""); list<string> metin = dosyaoku(""metin.txt""); int[] kelimesayisi = kelimelerisay(kelimeler, metin); dosyayaz(""sonuc.txt"", kelimeler, kelimesayisi); } catch (inputexception e) { system.err.println(e.getmessage()); } } public static int[] kelimelerisay(list<string> kelimeler, list<string> metin) throws kelimebulunamadiexception { int[] kelimesayisi = new int[kelimeler.size()]; for (string satir : metin) { string[] kelimelerdizisi = satir.tolowercase().split(""\\p{punct}""); for (int i = 0; i < kelimelerdizisi.length-1; i++) { string removed = kelimelerdizisi[i].replaceall(""\\p{punct}"" , """"); for (int j = 0; j < kelimeler.size(); j++) { if (removed.equals(kelimeler.get(j))) { kelimesayisi[j]++; } } } } for (int i = 0; i < kelimeler.size(); i++) { if (kelimesayisi[i] == 0) { throw new kelimebulunamadiexception(kelimeler.get(i)); } } return kelimesayisi; } public static list<string> dosyaoku(string dosyaadi) throws inputexception { file dosya = new file(dosyaadi); list<string> satirlar = new arraylist<>(); try (bufferedreader reader = new bufferedreader(new filereader(dosya))) { string satir; while ((satir = reader.readline()) != null) { satir = satir.tolowercase(); if (!satir.isempty()) { satirlar.add(satir); } } } catch (ioexception e) { system.err.println(""dosya okunurken hata oldu""); } if (satirlar.isempty()) { throw new bosdosyaexception(dosyaadi); } return satirlar; } public static void dosyayaz(string dosyaadi, list<string> kelimeler, int[] kelimesayilari) { try (printwriter writer = new printwriter(new filewriter(dosyaadi))) { for (int i = 0; i < kelimeler.size(); i++) { if (kelimesayilari[i] > 0) { writer.println(kelimeler.get(i) + "" "" + kelimesayilari[i]); } } } catch (ioexception e) { system.err.println(""dosya yazilirken hata oldu""); } } } class kelimebulunamadiexception extends inputexception{ public kelimebulunamadiexception(string kelime) { super(""hata: "" + kelime + "" metinde bulunamadi""); } } class bosdosyaexception extends inputexception{ public bosdosyaexception(string dosyaadi) { super(""hata: "" + dosyaadi + "" bos""); } } public class inputexception extends exception{ public inputexception(string message){ super(message); } } public class dosyabulunamadiexception extends inputexception{ public dosyabulunamadiexception(string dosyaadi) { super(""hata: "" + dosyaadi + "" bulunamadi""); } } generic 1) envanter yönetim sistemi bu labda amacımı bir oyun için envanter sistemi eklemektir. item isminde bir arayüz tanımlayın: aşağıdaki metotları içermelidir: string getname() int getvalue() weapon sınıfı tanımlayın. bu sınıf item arayüzünü uygulamalıdır. int damage isimli bir özelliği olmalıdır. armor sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. int defense isimli bir değişkeni olmalıdır. potion sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. string effect isimli bir değişkeni olmalıdır. generic inventory<t> sınıfı bir arraylist kullanarak nesneleri saklamalıdır. void additem(t item): envantere istenilen eşyayı eklemeli void removeitem(t item): envanterden istenilen eşyayı silmeli void printinventory(): envanteri basmalı t mostvaluableitem(): en değerli eşyayı dönmeli t finditembyname(string name): verilen isme karşılık gelen eşyayı dönmeli. i̇simlerin unique olduğunu varsayabilirsiniz. eğer yoksa null dönün. list<t> finditemsbyvalue(int value): verilen değerden daha değerli eşyaarın listesini döndürür. int gettotalvalue(): envanterin toplam değerini döner. list<t> filterbytype(class<?> type): istenilen sınıfa ait ögeleri döner. int gettotalweapondamage(): weapon classına ait olan nesnelerin toplam hasarınıdöner. void sortbyvalue(): değeri azalan şekilde envanteri sıralamalıdır. public static void printmostvaluableitem(inventory<? extends item> inventory): verilen envanterdem en değerli eşayı ekrana basmalıdır. public static void transferarmor(inventory<? super armor> destination, inventory<armor> source): verilen hedef envantere zırhı taşımalıdır. driver class: main metodu burada olmalıdır. sadece weapon’dan oluşan ve itemdan oluşan invertory classı yazıp test ediniz. yardımcı olabilecek metotlar: class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon import java.util.arraylist; import java.util.list; class inventory<t extends item> {//asistan ok dedi private list<t> items = new arraylist<>(); public void additem(t item){ items.add(item); } public void removeitem(t item){ items.remove(item); } public void printinventory(){ for(t item : items){ system.out.println(item.getname()); } } int max = integer.min_value; t maxitem; public t mostvalueableitem(){ for(t item : items){ if(item.getvalue() > max){ max = item.getvalue(); maxitem = item; } } return maxitem; } public t finditembyname(string name){ for(t item : items){ if(item.getname().equals(name)){ return item; } } return null; } public list<t> finditemsbyvalue(int value) { list<t> valuelist = new arraylist<>(); for(t item : items){ if(item.getvalue() > value){ valuelist.add(item); } } return valuelist; } public int gettotalvalue(){ int sum = 0; for(t item : items){ sum += item.getvalue(); } return sum; } public list<t> filterbytype(class<?> type){ list<t> filteritems = new arraylist<>(); for (t item : items) { if (type.isinstance(item)) { filteritems.add(item); } } return filteritems; } public int gettotalweapondamage(){ int sum = 0; for (t item : items) { if (item instanceof weapon) { sum += item.getvalue(); } } return sum; } public void sortbyvalue(){ for (int i = 0; i < items.size() - 1; i++) { for (int j = 0; j < items.size()-1-i; j++) { // jnin sinirindan emiin degilim kontrol et!! if (items.get(j).getvalue() < items.get(j + 1).getvalue()) { t temp = items.get(j); items.set(j, items.get(j + 1)); items.set(j + 1, temp); } } } } public static void printmostvaluableitem(inventory<? extends item>inventory){ inventory.sortbyvalue(); // azalan sekilde siraliyor ilk eleman en buyuk olan olur system.out.println(inventory.items.get(0).getname()); } public static void transferarmor(inventory<? super armor> destination,inventory<armor> source){ list<armor> armors = source.filterbytype(armor.class); for (armor armor : armors) { destination.additem(armor); } source.items.removeall(armors); // source da bir inventory o yuzden yapabildin } } public class weapon implements item { private string name; private int value; private int damage; public weapon(string name, int value, int damage) { this.name = name; this.value = value; this.damage = damage; } @override public string getname() { return name; } @override public int getvalue() { return value; } } interface item{ string getname(); int getvalue(); } public class armor implements item{ private string name; private int value; private int defense; public armor(string name, int value, int defense) { this.name = name; this.value = value; this.defense = defense; } @override public string getname() { return name; } @override public int getvalue() { return value; } } public class potion implements item{ private string name; private int value; private string effect; public potion(string name, int value, string effect) { this.name = name; this.value = value; this.effect = effect; } @override public string getname() { return name; } @override public int getvalue() { return value; } } //tum metotlar calısıyor asistan hepsini mainde gostermek zorunda degilsiniz dedigi icin birkacini gosterdim public class driver { public static void main(string[] args) { class<weapon> weaponclass = weapon.class; system.out.println(""sinif adi: "" + weaponclass.getname()); weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon //itemdan olusan inventory<item> inventory = new inventory<>(); inventory.additem(new weapon(""kilic"", 600, 500)); inventory.additem(new armor(""kalkan"", 400, 400)); inventory.additem(new potion(""zehir"", 100, ""zehirle"")); inventory.additem(new weapon(""kilic2"", 100, 9)); inventory.additem(sword); inventory.additem(new weapon(""iclal"",2900 , 8)); inventory.removeitem(sword); system.out.println(""envanter:""); inventory.printinventory(); system.out.println(""en degerli item:""); inventory.printmostvaluableitem(inventory); system.out.println(""toplam weapon damage:""); system.out.println(inventory.gettotalweapondamage()); system.out.println(""toplam value: "" + inventory.gettotalvalue()); system.out.println(""olmayan bir itemi bul""); system.out.println(inventory.finditembyname(""yok"")); system.out.println(); //weapondan olusan inventory<weapon> inventory2 = new inventory<>(); inventory2.additem(new weapon(""kilic2"", 100, 9)); inventory2.additem(sword); inventory2.additem(new weapon(""iclal"",2900 , 8)); system.out.println(""envanter2:""); inventory2.printinventory(); system.out.println(""en degerli item:""); inventory.printmostvaluableitem(inventory2); system.out.println(""toplam weapon damage:""); system.out.println(inventory2.gettotalweapondamage()); system.out.println(""toplam value: "" + inventory2.gettotalvalue()); system.out.println(); //tranforarmor inventory<? super armor> inventory3 = new inventory<>(); inventory<armor> inventory4 = new inventory<>(); inventory4.additem(new armor(""zirh1"" , 100 , 20)); inventory4.additem(new armor(""zirh2"" ,200 , 20)); inventory4.additem(new armor(""zirh3"" , 300 , 20)); inventory4.additem(new armor(""zirh4"" , 400 , 20)); inventory3.additem(new armor(""kalkan"", 400, 400)); system.out.println(""transferden önce inventory3""); inventory3.printinventory(); system.out.println(""transferden önce inventory4""); inventory4.printinventory(); inventory.transferarmor(inventory3, inventory4); system.out.println(""transferden sonra inventory3""); inventory3.printinventory(); system.out.println(""transferden sonra inventory4""); inventory4.printinventory(); } } ""recursion"" kavramı nedir, kısaca açıklayınız. recursion bir methodun kendini çağırması kavramıdır recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case recursive call jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. her bir call yapıldığında stacke o methodun variableları ve kendisi çağrılır ve en baştan başlayarak methodlar çalıştırılır int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. iteratif olarak yapmak daha az yer ve zaman kullanımına sebep olacaktır bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? stringin uzunluğunun sıfıra eşit olup olmadığına bakmak stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack metod çağrıldığında variablelarının saklandığı ve kullanımı bitince çıktığı yerdir eşer method çok kez çağrılırsa stack overflow olur tail recursion nedir, kısaca açıklayınız. - java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? static binding compiler time dynamic run time java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? çünkü override edilemezler dolayısı ile derleme zamanında sınıf üzerinden çözülür overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overriding run time overloading compile time dinamik bağlamada jvm'nin görevi nedir? hangi metotun çağrılacağını nesnenin gerçek türüne göre belirlemek java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? upcasting bir child class nesnesinin üst sınıfın referansında saklanmasıdır downcastibg bir üst sınıf referansının alt sonıf türüne çevirmektir java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? override edilme özelliği kaybolurdu , gereksiz bellek kullanımı olurdu class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child // dynamic class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book // dynamic java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract classlardan nesne oluşturulamaz , evet olabilir abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? hayır yapılamaz abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. genellikle bi şablon görevi görürler , tamamen veya kısmen tamamlanmış metotlar içerebilirler, abstract classlardan nesne oluşturulamaz abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interfacelerde değişkenler final değerlerini alırlar abstract classlar isle sonradan implement edilebilecek şablonlar gibi düşünülebilir o yüzden böyle bi zorunluluk yoktur , abstract classlar kullanılabilir interfaceler kullanılamaz marker interface ve functional interface kavramları nedir, nasıl kullanılır? - bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet ikisi de mümkündür abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? c is a shape ama shape in draw metodu implement edilmemiş bunun yerine circle c = new circle() denilirse drawing circle displaying çıktısı verir interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? - text file ile binary file arasındaki fark nedir? text dosyaları insan tarafından okunabilir karakterler içerir, binary dosyalar ise makine tarafından okunabilen 0 ve 1lerden oluşan veri saklar. bir dosyaya yazarken düzenli olarak flush yapmamak neye yol açabilir? veri kaybına yazma işlemi tamamlanmadan programın kapanması durumunda eksikliğe yol açabilir binary bir dosyaya bir object yazdırırken bu objenin hangi interfaceyi implement etmesi gerekiyor? bu interfacenin metotlarını sıralayınız. bu interface functional veya marker bir interface midir? serializable interfacei metodu yoktur çünkü marker binary bir dosyaya primitive typeler (int, float, char etc.) yazılabilir mi, evet ise nasıl? evet dataoutputstream veya objectoutputstream kullanarak buffered reader ve scanner sınıfları ile dosya okurken dosyanın sonuna geldiğini nasıl kontrol edilir? bufferedreader.readline() ve scanner.hasnext() metotları ile binary bir dosya okurken dosyanın sonuna gelindiği nasıl test edilir? -- public class randomaccessdemo { public static void main(string[] args) throws exception { _______ f = new _______(""numbers.bin"", ""____""); f.writeint(10); f.writeint(20); int a = f.readint(); f.seek(_____________); int b = f.readint(); system.out.println(a + b); f.close(); } } boşluklara sırasıyla ne gelmelidir? output? randomaccessfile , new randomaccessfile(""numbers.bin"", ""rw"") ,4 output 30 public class demo { public static void main(string[] args) throws exception { fileoutputstream fos = new fileoutputstream(""log.txt"", true); ______________ pw = new ______________(fos); pw.println(""new log entry""); pw.close(); } } boşluklara sırasıyla ne gelmelidir? bu kod çalıştırıldığında log.txt dosyası nasıl etkilenir? printwriter , printwriter(fos) new log entry append edilir what grade (a, b, c, d, or f) do you expect to earn by the end of this course? cc java'da generic kavramı nedir, bu kavramın temel amacı nedir? generic kavramı tipe bağlı olmadan metot ya da class tanımlamaktır , amaç kod döngüsünü sağlamaktır upper bound ve lower bound wildcardları nasıl ifade edersiniz? upper ve lower boundun kullanılacağı durumlara birer tane örnek veriniz. — generic bir classın constructorunda type parametresi bulunur mu, neden? bulunamaz mygenericclass<a> ve mygenericclass<object> classları arasında kalıtım (child-parent) ilişkisi nasıldır, açıklayınız. object olan a olanın parentıdır. java’da her şey obje classından türer class node<t>{ t[] data = new t[10]; } //psvm node<string> stringnode = new node<>(); bu kodda bir hata var mı? (varsa) bu hata nedir, nedenini açıklayınız. (varsa) bu hata nasıl düzeltilmeli, kodun doğru halini yazınız. tnin array şeklinde başlatılmış olması hata. swapheadandtail metodu aşağıda tanımı verilmiş node classının birbirlerine bağlanmış nodelerinden ilkini alan ve baştaki node ile sondaki node'yi değiştiren metottur. örnek: başlangıçta: a -> b -> c metodu a ile çağırdığıktan sonra: c -> b -> a ayrıca metot en başa gelen nodeyi dönmelidir (bu örnekte c dönmeli). class node{ int data; node next; } static node swapheadandtail(node head) { node a = head; node b = head.next; node c = head; node d = null; while (____ != null) { d = c; c = c.next; } c.next = ____; d.next = ____; a.next = ____; return ____; } buna göre boşluklara neler gelmelidir? a b a null public _________ { public void sırala(list<t> liste) { // sıralama algoritmanız } } yaptığınız uzun çalışmalar sonucu yeni bir sıralama algoritması buldunuz. bunu implement etmek için bir class yazmalısınız. bu classın declarationunu nasıl yapardınız neden, boşluğu buna göre doldurun. list<t> bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot { //a=65 a=97 private string name; private string type; private int batterylevel; // 100 ile 0 arasında bir değer private boolean isoperational; // bataryası varsa true public robot(){ this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public robot(string name, string type, int batterylevel){ this.name = name; this.type = type; this.batterylevel = batterylevel; if(batterylevel > 0){ isoperational = true; } else{ isoperational = false; } } public string getname() { return name ; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbattery() { return batterylevel ; } public void setbattery(int batterylevel) { this.batterylevel = batterylevel ; } public boolean getisop() { return isoperational; } public void setisop(boolean isoperational ) { this.isoperational = isoperational; } public void charge(){ this.batterylevel = 100; } public void printrobot(){ system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + ""% "" + "" is\r\n"" + // ""operational:"" + isoperational); } } public class main { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } public class question1 { //q1 dedigimde compiler sorun cikardi caner hoca sebebnini bilmiyorum dedigi icin question1 seklinde adlandirdim public static void main(string[] args) { string s = findperm(""abc"" , 0); system.out.println(s); string s1 = findperm(""ab"" , 0); system.out.println(s1); string s2 = findperm(""a12b"" , 0); system.out.println(s2); } public static string findperm(string s , int i){ char c = 'x'; if(i >= s.length()) return """"; if(s.charat(i) != '0' && s.charat(i) != '1' && s.charat(i) != '2' && s.charat(i) != '3' && s.charat(i) != '4' && s.charat(i) != '5' && s.charat(i) != '6' && s.charat(i) != '7' && s.charat(i) != '8' && s.charat(i) != '9' ){ if(s.charat(i) <= 'z' && s.charat(i) >= 'a'){ c = (char) (s.charat(i) - 'a'); return c + findperm(s.substring(i+1) , i+1) ; } if(s.charat(i) <= 'z' && s.charat(i) >= 'a'){ c = (char) (s.charat(i) + 32); return c + findperm(s.substring(i+1) , i+1); } } else{ return s.charat(i) + findperm(s.substring(i+1) , i+2) ; } return """"; } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name, string location){ this.name = name; this.location = location; this.robots = new arraylist<>(); } public factory(){ this.name = ""factory1""; this.location = ""moon""; this.robots = new arraylist<>(); } public string getname() { return name ; } public void setname(string name) { this.name = name; } public string getloc() { return location ; } public void setloc(string location) { this.location = location; } public void addrobot(robot robot){ this.robots.add(robot); } public void chargeallrobots(){ for(int i = 0 ; i < robots.size(); i++){ robots.get(i).charge(); } } public void printfactory(){ system.out.println(""factory name: "" + name + "" location: "" + location); system.out.println(""robots operating here:""); for(int i = 0 ; i < robots.size(); i++){ robots.get(i).printrobot(); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery{ int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); //??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz factory.allrobots(); } } public class securityrobot extends abstractrobot{ private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } @override public int getbatterylife() { return this.batterylife; } int keeper = getbatterylife(); @override public void recharge() { this.batterylife = keeper; } @override public void performtask() { if(this.batterylife >= 10){ system.out.println(""["" + modelname + ""]"" + "" scanning for threats... armed: "" + isarmed); this.batterylife-=10; } else if(this.batterylife < 10){ system.out.println(""["" + modelname + ""]"" + "" not enough battery to scan threats...""); } } public void togglearmedmode(){ if(this.isarmed){ this.isarmed = false; } else{ this.isarmed = true; } } public boolean isarmed() { return isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; int keeper = getbatterylife(); public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } public int getbatterylife() { return this.batterylife; } @override public void recharge() { this.batterylife = keeper; } @override public void performtask() { if(this.batterylife >= 10){ system.out.println(""["" + modelname + ""]"" + "" cleaning in progress... cleaning power: "" + cleaningpower); this.batterylife-=10; } else if(this.batterylife < 10){ system.out.println(""["" + modelname + ""]"" + "" not enough battery to clean..."" ); } } public void boostcleaningpower(){ this.cleaningpower += 50; } public int getcleaningpower() { return cleaningpower; } public void setcleaningpower(int cleaningpower) { this.cleaningpower = cleaningpower; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; static int totalproduced = 0; public robotfactory() { robots = new arraylist<>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ totalproduced++; robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ totalproduced++; robots.add(new securityrobot(modelname, batterylife, isarmed)); } public void performalltasks(){ for(int i= 0; i < robots.size(); i++){ robots.get(i).performtask(); } } public void displayrobots(){ for(int i= 0; i < robots.size(); i++){ if(robots.get(i) instanceof securityrobot){ system.out.println(""securityrobot - model: "" + robots.get(i).getmodelname() + "", battery: "" + robots.get(i).getbatterylife() + "", armed: "" + ((securityrobot) robots.get(i)).isarmed()); } if(robots.get(i) instanceof cleaningrobot){ system.out.println(""cleaningrobot - model: "" + robots.get(i).getmodelname() + "", battery: "" + robots.get(i).getbatterylife() + "", cleaning power: "" + ((cleaningrobot) robots.get(i)).getcleaningpower()); } } } public void upgradecleaningrobots(int miktar){ for(int i= 0; i < robots.size(); i++){ if(robots.get(i) instanceof cleaningrobot){ ((cleaningrobot) robots.get(i)).setcleaningpower(((cleaningrobot) robots.get(i)).getcleaningpower() + miktar); system.err.println(""cleaningrobot - "" + robots.get(i).getmodelname() +"" now has cleaning power: "" + ((cleaningrobot) robots.get(i)).getcleaningpower()); } } } public void togglesecurityrobotsmode(){ for(int i= 0; i < robots.size(); i++){ if(robots.get(i) instanceof securityrobot){ securityrobot s = (securityrobot)robots.get(i); s.togglearmedmode(); if(s.isarmed()){ system.out.println(""securityrobot - "" + s.getmodelname() + "" is now armed""); } else{ system.out.println(""securityrobot - "" + s.getmodelname() + "" is now unarmed""); } } } } public void allrobots(){ system.out.println(""tum fabrikalar tarafindan toplam "" + totalproduced + "" robot uretildi\r""); } } envanter takip sistemi bil 211 - quiz 3 27 şubat 2025 1 giriş bu quizde, fileioveexceptions kullanarak basit bir envanter takip sistemi uygulaması geliştireceğiz. uygulama, interaktif bir terminal menüsü üzerinden, tek bir eşyanın ve stoğunun tutulduğu kayıtların yönetilmesini (eşya ekleme, çıkarma ve stok güncelleme) sağlayacaktır. ayrıca, envanter verileri sabit isimli bir dosyaya kaydedilebilecek ve bu dosyadan geri yüklenebilecektir. 2 genel program program konsol tabanlı bir kullanıcı arayüzü ile envanter takibi gerçekleştirmelidir. arayüz özellikleri aşağı- daki gibidir. -terminal menüsü: kullanıcıya aşağıdaki seçenekleri sunacaktır: – eşya ekleme: yeni bir eşya kaydı oluşturulur. her kayıt, eşya adı ve başlangıç stoğu bilgilerini içerir. eğer çoktan var olan bir eşya eklenmeye çalışılırsa program otomatik olarak önceki kaydın stoğunu güncellemelidir (yani aynı isimde iki kayıt oluşmamalı). – eşya çıkarma: mevcut envanterden istenilen eşya silinir. – stok güncelleme: kayıtlı bir eşyanın stoğu artırılabilir ya da azaltılabilir. i̇şlem sonucunda stok miktarı negatif olmamalıdır. – envanter listeleme: mevcut envanter kayıtları ekrana listelenir. – dosyaya kaydetme: güncel envanter verileri sabit isimli dosyaya kaydedilir. – dosyadan geri yükleme: daha önce kaydedilmiş envanter verileri dosyadan okunarak geri yüklenir. – çıkış: program sonlandırılır. 3envanterkaydi sınıfı değişkenler: -isim(private string) eşyanın adını tutar. -stok(private int) eşyanın stok miktarını tutar. metotlar: -public envanterkaydi(string isim, int stok) constructor; eşya adı ve stok miktarını başlatır. -public void stokguncelle(int miktar) stok miktarını günceller; negatif sonuç oluşmaması kontrol edilmelidir. - stokguncelle dışında ihtiyacınıza göre private değişkenler için getter ve setter tanımlayabilirsiniz. 4 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları (örn., bufferedreader , scanner,printwriter ) kullanacaktır. dosya işlemleri sırasında aşağıdaki hata durumları için uygun mesajlar verilmelidir: - dosya bulunamazsa: ""hata: envanter dosyası bulunamadı."" - dosya boşsa: ""hata: envanter dosyası boş."" 1 5 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program, hata kodu ile sonlanmalı ve ilgili hata mesajları stderr’e yazdırılmalıdır. 5.1 girdi hataları (inputexception class) dosya işlemleriyle ilgili hatalar için kendi tanımlayacağınız inputexception sınıfından türeyen özel hata sınıfları oluşturulacaktır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: envanter dosyası bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: envanter dosyası boş."" 5.2 envanter i̇şlemleri hataları envanter işlemleri sırasında oluşabilecek hatalar için aşağıdaki özel hata türleri tanımlanacaktır: -stoknegatifexception (extends exception) : stok güncelleme işlemi sonucunda, eşyanın stoğu negatif bir değere düşerse atılacak hata. - hata mesajı: ""hata: stok miktarı negatif olamaz."" -esyayokexception (extends exception) : çıkarma veya güncelleme işlemi yapılmak istenen eşya envanterde bulunmuyorsa atılacak hata. - hata mesajı: ""hata: i̇stenen eşya envanterde mevcut değil."" -ozellikhatasiexception (extends exception) : eşya ekleme sırasında girilen bilgilerde hata veya eksiklik varsa atılacak hata. - hata mesajı: ""hata: eşya bilgileri hatalı veya eksik."" 6 gönderim formatı - quizinizi bitirdiğinizde asistanlarınızdan birisine kodunuzu ve çıktısını gösterip puanlatın. - asistan labınızı puanladığında tüm kaynak dosyalarını ve bu dökümantasyonu bir arşiv dosyası (zip, rar, 7z, tar, tar.gz) halinde sıkıştırın. - arşiv dosyasının isim_numara formatında isimlendirin (örn., sebnemferah_181101014.zip). - i̇simlendirdiğiniz arşiv dosyasını uzak sistemindeki quiz alanına yükleyin. 2 import java.io.*; import java.util.*; public class main { public static void main(string[] args) throws exception { try (scanner scanner = new scanner(system.in)) { list<envanterkaydi> envanter = new arraylist<>(); while (true) { system.out.println(""\n1. eşya ekleme""); system.out.println(""2. eşya çikarma""); system.out.println(""3. stok güncelleme""); system.out.println(""4. envanter listeleme""); system.out.println(""5. dosyaya kaydetme""); system.out.println(""6. dosyadan geri yükle""); system.out.println(""7. çikiş""); system.out.print(""seçim: ""); int secim = scanner.nextint(); scanner.nextline(); try{ if(secim == 1){ system.out.print(""eşya adi: ""); string isim = scanner.nextline(); system.out.print(""başlangiçtaki stoğu: ""); int stok = scanner.nextint(); boolean varmi = false; for(int i=0 ; i < envanter.size(); i++){ if(envanter.get(i).getisim().equals(isim)){ varmi = true; envanter.get(i).stokguncelle(stok); } } if(!varmi){ envanter.add(new envanterkaydi(isim, stok)); } } if(secim == 2){ system.out.print(""çikarilacak eşya adi: ""); string isim = scanner.nextline(); boolean varmi = false; for(int i=0 ; i < envanter.size(); i++){ if(envanter.get(i).getisim().equals(isim)){ varmi = true; envanter.remove(i); break; } } if(!varmi){ system.out.println(""böyle bir eşya yok""); } } if(secim == 3){ system.out.print(""eşya adi: ""); string isim = scanner.nextline(); system.out.print(""stokta olacak miktar değişimi: ""); int stok = scanner.nextint(); boolean varmi = false; for(int i=0 ; i < envanter.size(); i++){ if(envanter.get(i).getisim().equals(isim)){ varmi = true; envanter.get(i).stokguncelle(stok); } } if (!varmi) { system.err.println(""öyle bir eşya envanterde yok""); } } if(secim == 4){ if (envanter.isempty()) { system.out.println(""envanterde esya yok.""); } else { for (envanterkaydi esya : envanter) { system.out.println(""isim: "" + esya.getisim() + "" stok: "" + esya.getstok()); } } } if(secim ==5){ try (printwriter pw = new printwriter(new filewriter(""envanter.txt""))) { for(int i=0 ; i < envanter.size(); i++){ pw.println(envanter.get(i).getisim() + "" : "" + envanter.get(i).getstok()); } } catch (ioexception e) { system.err.println(""yazarken hata oldu ""); } } if(secim == 6){ try (bufferedreader br = new bufferedreader(new filereader(""envanter.txt""))) { string satir; envanter.clear(); while ((satir = br.readline()) != null) { string[] oku = satir.split("" : ""); envanter.add(new envanterkaydi(oku[0], integer.parseint(oku[1]))); } } catch (ioexception e) { //system.err.println(""okurken hata oldu: ""); throw new bosdosyaexception(); } } if(secim == 7){ system.out.println(""envanterden çikiliyor""); return; } } catch(exception e){ throw new exception(e.getmessage()); } } } } } public class esyayokexception extends exception { public esyayokexception() { super(""hata: i̇stenen eşya envanterde mevcut değil.""); } } public class ozellikhatasiexception extends exception { public ozellikhatasiexception() { super(""hata: eşya bilgileri hatali veya eksik.""); } } public class envanterkaydi { private string isim; private int stok; public envanterkaydi(string isim, int stok) { this.isim = isim; this.stok = stok; } public string getisim() { return isim; } public int getstok() { return stok; } public void stokguncelle(int miktar) throws stoknegatifexception { if (this.stok + miktar < 0) { throw new stoknegatifexception(""hata: stok miktari negatif olamaz.""); } this.stok += miktar; } } public class bosdosyaexception extends inputexception { public bosdosyaexception() { super(""hata: envanter dosyasi boş.""); } } public class stoknegatifexception extends exception { public stoknegatifexception(string message) { super(message); } } public class inputexception extends exception { public inputexception(string message) { super(message); } //gecen haftaki gibi unutma! } public class dosyabulunamadiexception extends inputexception { public dosyabulunamadiexception() { super(""hata: envanter dosyasi bulunamadi.""); } } bil211 quiz 4 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: undoablelist<t> adında bir sınıf oluşturun. bu sınıf, bir arraylist'i genişletmeli ve aşağıdaki ek özelliklere sahip olmalıdır: ● undolast() metodu, en son eklenen öğeyi kaldırmalıdır. ● getlastadded() → son eklenen öğeyi listeyi değiştirmeden döndürür. ● eğer liste boşsa, undolast() bir hata vermemeli, sadece hiçbir şey yapmamalıdır. örnek kullanım: undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] q2: aşağıdaki generic metodu tamamlayın. ● verilen bir collection<t> içinde minimum veya maksimum öğeyi bulan bir metod yazın. ● boolean parametresi true ise maksimumu, false ise minimumu döndürmelidir. ● t öğeleri comparable<t> arabirimini uygulamalıdır. public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { // metodu tamamlayın } örnek kullanım: list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) q3: belirli türdeki elemanları filtreleme ● bir collection<?> içindeki belirli bir türdeki öğeleri filtreleyen bir generic metod yazın. ● class<t> tür filtresi olarak kullanılmalıdır. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { // metodu tamamlayın } örnek kullanım: list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] import java.util.arraylist; import java.util.arrays; import java.util.collection; import java.util.arraylist; import java.util.list; public class main { public static void main(string[] args) { list<integer> numbers = arrays.aslist(3, 9, 1, 6,11,13,0,89,-1); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, ""sanane"" , 33,true); system.out.println(filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] } public static <t extends comparable<t>> t findextreme(collection<t> collection,boolean findmax) { //comparable comprareto kullancan unutma if(collection.isempty()){ return null; } arraylist<t> liste = new arraylist<>(collection); t karsilastir = liste.get(0); for(int i = 1; i < liste.size(); i++){ if(findmax && liste.get(i).compareto(karsilastir) > 0){ karsilastir = liste.get(i); } else if(!findmax && liste.get(i).compareto(karsilastir) < 0){ karsilastir = liste.get(i); } } return karsilastir; } public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { arraylist<t> res = new arraylist<>(); for (object obj : collection) { if (type.isinstance(obj)) { res.add((t)(obj)); } } return res; } } class undoablelist<t> extends arraylist<t> { public void undolast() { if (!this.isempty()) { this.remove(this.size() - 1); } } public t getlastadded() { if (!this.isempty()) { return this.get(this.size() - 1); } else{ return null; } } } 5 kuş bakışı atış oyunu (top-down shooter) bil 211 - proje teslim tarihi: 27 mart 2025 23:59 1 amaç bu ödevde amacınız, java swing kullanarak kuş bakışı bir atış oyunu (top-down shooter) tasarlamaktır. oyunda, yönettiğimiz karakterin üzerine dalga dalga gelen çeşitli zombileri fare ile hedef alarak farklı silahlar kullanıp öldürmemiz gerekmektedir. karakterimiz öldüğünde oyun sona erecektir. her dalga başına ve öldürülen zombi başına kazanılan puan artacaktır. dalgalar ilerledikçe gelen zombilerin sayısı ve çeşitleri artarak zorluk seviyesi yükselecektir. 2 gereksinimler oyun derste öğrendiğiniz oop ilkelerine uygun sınıf/arayüz tasarımları ile geliştirilmelidir. - zorluk seviyesi arttıkça zombi sayısı ve çeşitliliği artmalıdır. - oyun duraklatılabilmeli ve kaydedilip tekrar yüklenilebilmelidir (fileio kullanılmalıdır). - sol üst köşede seçili silah ve kalan mermi miktarı gösterilmelidir. - sağ üst köşede oyuncunun canı ve toplam puanı gösterilmelidir. - oyunun duraklatılması, kaydedilmesi ve devam ettirilmesi için bir menü bulunmalıdır. 3 silahlar oyunda farklı silahlar bulunmaktadır. belirli zombi dalgaları temizlendikten sonra oyun ödül olarak yeni bir silahverecektir. hersilahınkendineözgübirçalışmamekanizmasıvardır. silahlarınşarjörkapasitesisınırlıdır ve şarjördeki mermiler bittiğinde tekrar doldurulmadan ateş edilemez. toplam mermi sayısı oyuncunun o silaha ait elinde ne kadar mermi olduğunu gösterir. r tuşuna basarak şarjör yeniden doldurulabilir. 3.1 tabanca - şarjör kapasitesi: 12 mermi - ateş hızı: 120 mermi/dakika - elde etme: oyuncu oyuna bu silahla başlar. - özellik: düz atış yapar, sapma yoktur. sınırsız yedek şarjör (diğer tüm silahlar için yedek şarjör ve mermiler rastgele bir şekilde dalga sırasında ve sonlarında zombilerden düşer). 3.2 piyade tüfeği - şarjör kapasitesi: 30 mermi - ateş hızı: 600 mermi/dakika - elde etme: 1. dalga tamamlandıktan sonra - özellik: düzatışyaparancak30derecesapmasıvardır. sapmaaçısı, karakterinbaktığıyöndemerminin her iki dönme yönüne de saçılabileceği maksimum açıdır. 1 3.3 pompalı tüfek - şarjör kapasitesi: 5 mermi - ateş hızı: 60 mermi/dakika - elde etme: 3. dalga tamamlandıktan sonra - özellik: her atış 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi atar (yani karakter merkezli mermi hız vektörleri arasında 5 derece açı olmalıdır). 3.4 keskin nişancı tüfeği - şarjör kapasitesi: 5 mermi - ateş hızı: 30 mermi/dakika - elde etme: 5. dalga tamamlandıktan sonra - özellik: mermileri zombileri delip arasındaki zombilere de hasar verir. 3.5 roketatar - şarjör kapasitesi: 1 roket - ateş hızı: 10 roket/dakika - elde etme: 10. dalga tamamlandıktan sonra - özellik: patlama etkisiyle birden fazla zombiye zarar verir. 4 zombiler zombiler oyundaki düşman tipleridir. zombiler oyuncuya doğru ilerlerler ve eğer oyuncuya temas ederlerse oyuncuya hasar verirler. zorluk seviyesi arttıkça zombilerin sayısı ve çeşitliliği artmaktadır. zombi tipleri birbirinden renk ya da şekil olarak ayırt edilebilmelidir. 4.1 normal zombi - can: orta - hız: yavaş - hasar: orta 4.2 sürünge zombi - can: düşük - hız: hızlı - hasar: orta - özellik: oyuncunun yakınına geldiğinde zıplar. 4.3 tank zombi - can: yüksek - hız: çok yavaş - hasar: yüksek 2 4.4 asit tüküren zombi - can: düşük - hız: yavaş - hasar: orta (uzaktan asit tükürebilir) - özellik: öldürüldüğünde yanındaki birimlere zarar verir. 5 rapor ve teslim formatı - oyun, oopprensiplerineuygunolaraktasarlanmalıvesınıfdiyagramları, arayüztasarımıfinalraporda sunulmalıdır. - oyun test edilerek ekran görüntüleri rapora eklenmelidir. - rapor pdf formatında olmalı ve ismi proje_rapor.pdf olmalıdır. - oyunun mainfonksiyonu gameisimli bir sınıf içinde bulunmalıdır ( java game komutuyla çalışmalı). - kaynak kodun tamamı source.zip (uzantı 7z, rar, tar.gz de olabilir) şeklinde sıkıştırılmış olmalıdır. - sıkıştırılmış kaynak kod ve rapor uzak sistemine yüklenmelidir. 6 yardımcı kaynaklar dahaöncehiçkuşbakışıatışoyunuoynamadıysanızaşağıdakioyunlarıreferansolarakalabilirsiniz. buradaki oyunlarıngrafikleriilemekaniklerisizdenbeklenendenfarklıolsadaharitatasarımı, karakterhareketi,kamera hareketi, ateş etme mekanikleri ve zombilerin yapay zekası ile ilgili temel fikirler edinebilirsiniz. - little top-down shooter: https://www.youtube.com/watch?v=pj3m3fu3i5a - super c - stage 2: https://www.youtube.com/watch?v=os2t_v5suj4 - neon chrome: https://www.youtube.com/watch?v=puhw1bevtro 3 import java.awt.*; /** * hiz * can * hasar */ public abstract class zombie { protected string name; protected double x, y; protected int health; protected double speed; protected int damage; protected color color; public zombie(string name, double x, double y, int health, double speed, int damage, color color) { this.name = name; this.x = x; this.y = y; this.health = health; this.speed = speed; this.damage = damage; this.color = color; } // zombilerin oyuncuya dogru hareket etmesi icin oyuncunun konumlarını alıp zombiyi ona gore guncellicez // burada zombimiz surunge mi diye kontrol etmeliyiz oyle ise yaklasinca ziplayacak (yani hizlanacak) public void update(double px, double py) { double distancex = px - x; double distancey = py - y; double dist = distancex*distancex + distancey*distancey; double angle = math.atan2(py - y, px - x); // once aralarindaki aciyi radyan cinsinden bulcaz if(this.name.equals(""crawlerzombie "")){ if(dist < (150*150)){ x += (1.10)*speed * math.cos(angle); // x bileseni y += (1.10)*speed * math.sin(angle); // y bileseni } } x += speed * math.cos(angle); // x bileseni y += speed * math.sin(angle); // y bilesini } public void draw(graphics g) { g.setcolor(color); g.filloval((int)x - 15, (int)y - 15, 30, 30); } // oyuncu ile collision oldu mu public boolean collideswith(player p) { double distancex = p.x - x; double distancey = p.y - y; double dist = distancex*distancex + distancey*distancey; // aralarındaki mesafenin kareleri toplamı // eger 35 unitten kucukse demekki artık collision oldu return dist < (35*35); // 40 iken tam uc uca degme oluyordu o yuzden 35 yaptim } // mermi ile collison oldu mu oyuncu ile ayni mantik public boolean ishitbybullet(bullet b) { // eger bir roketatar ise bu kisim game panelde handle ettin unutma /* if (b.getexplosionradius() > 0) { double dx = (x - b.x); double dy = (y - b.y); double distsq = dx*dx + dy*dy; if (distsq < (b.getexplosionradius()*b.getexplosionradius())) { return true; } }*/ double dx = (x - b.x); double dy = (y - b.y); double dist = dx*dx + dy*dy; return dist < (15*15); } public void takedamage(int dmg) { health -= dmg; } public boolean isalive() { return health > 0; } public int getdamage() { return damage; } // zombilerin ozelliklerini txt dosyasina kaydedebilmek icin override edicez public abstract string tosave(); public static zombie fromsave(string line) { // kaydettigimiz sira ile geri okuyacagiz // ""tur"" + x + "" "" + y + "" "" + health; try { string[] arr = line.split("" ""); string type = arr[0]; double zx = double.parsedouble(arr[1]); double zy = double.parsedouble(arr[2]); int zh = integer.parseint(arr[3]); switch(type) { case ""normalzombie"": { normalzombie nz = new normalzombie(zx, zy); nz.health = zh; return nz; } case ""crawlerzombie"": { crawlerzombie cz = new crawlerzombie(zx, zy); cz.health = zh; return cz; } case ""tankzombie"": { tankzombie tz = new tankzombie(zx, zy); tz.health = zh; return tz; } case ""spitterzombie"": { spitterzombie sz = new spitterzombie(zx, zy); sz.health = zh; return sz; } } } catch (exception e) { e.printstacktrace(); } return null; } } import java.awt.*; /* * zombi olunce arkasinda mermi kutusu bırakır icinde random sayida mermi olan */ public class ammodrop { double x, y; int amount; boolean iscollected = false; public ammodrop(double x, double y, int amount) { this.x = x; this.y = y; this.amount = amount; } public void draw(graphics g) { g.setcolor(color.yellow); g.fillrect((int)x - 5, (int)y - 5, 10, 10); } public boolean collideswith(player player) { double dx = player.x - x; double dy = player.y - y; return dx*dx + dy*dy < (20*20); } } import javax.imageio.imageio; import java.awt.*; import java.io.*; import java.util.arraylist; import java.util.list; public class gamemap { private int[][] mapdata; private int rows, cols; private final int tilesize = 16; private image grassimage; public gamemap(string mapfilepath) { loadmap(mapfilepath); loadimages(); } private void loadmap(string mapfilepath) { list<string> lines = new arraylist<>(); // haritadan bilgileri okumak try (inputstream is = getclass().getresourceasstream(""map.txt""); bufferedreader reader = new bufferedreader(new inputstreamreader(is))) { string line; while ((line = reader.readline()) != null) { // if (!line.trim().isempty()) { lines.add(line); } } rows = lines.size(); if (rows > 0) { // bosuk ile ayirdigimiz icin string[] tokens = lines.get(0).split(""\\s+""); cols = tokens.length; } mapdata = new int[rows][cols]; for (int i = 0; i < rows; i++) { string[] tokens = lines.get(i).split(""\\s+""); for (int j = 0; j < cols; j++) { mapdata[i][j] = integer.parseint(tokens[j]); } } } catch (ioexception ex) { ex.printstacktrace(); } } private void loadimages() { try { grassimage = imageio.read(getclass().getresource(""grass.png"")); } catch (ioexception ex) { ex.printstacktrace(); } } public void draw(graphics g) { for (int row = 0; row < rows; row++) { for (int col = 0; col < cols; col++) { int x = col * tilesize; int y = row * tilesize; g.drawimage(grassimage, x, y, tilesize, tilesize, null); } } } /* * oyuncu sinirlar ile collide edecek mi kontrolü yapar bunun icin map e 1 degerleri ekledik */ public boolean checkcollision(rectangle rect) { int startcol = rect.x / tilesize; int endcol = (rect.x + rect.width) / tilesize; int startrow = rect.y / tilesize; int endrow = (rect.y + rect.height) / tilesize; for (int row = startrow; row <= endrow; row++) { for (int col = startcol; col <= endcol; col++) { if (row >= 0 && row < rows && col >= 0 && col < cols && mapdata[row][col] == 1) { rectangle tilerect = new rectangle(col * tilesize, row * tilesize, tilesize, tilesize); if (rect.intersects(tilerect)) { return true; } } } } return false; } public int gettilesize() { return tilesize; } } import java.util.list; /* sarjor kapasitesi * ates hizi * toplam mermi sayisi (bazilari sonsuz) */ public abstract class weapon { protected string name; protected int magazinecapacity; //sarjor kapasitesi protected int currentmagazine; protected int totalammo; // toplam mermi sayisi protected int firerate; // ates hizi protected long lastfiretime; public weapon(string name, int capacity, int totalammo, int firerate) { this.name = name; this.magazinecapacity = capacity; // baslangicta full this.currentmagazine = capacity; this.totalammo = totalammo; this.firerate = firerate; this.lastfiretime = 0; } /* * (sx, sy) den (tx, ty) ye ates edilecek * bu metod list of bullets donecek cunku her silah sadece bir adet mermi ateslemiyor */ public abstract list<bullet> fire(double sx, double sy, double tx, double ty); // getterlar public void setcurrentmagazine(int cm) { currentmagazine = cm; } public string getname() { return name; } public int getmagazinecapacity() { return magazinecapacity; } public int getcurrentmagazine() { return currentmagazine; } public int gettotalammo() { return totalammo; } public void settotalammo(int ta) { totalammo = ta; } public void reload() { // keyhandle yaparken r tusuna basilirsa bu metotu cagir int need = magazinecapacity - currentmagazine; if (totalammo >= need) { totalammo -= need; currentmagazine = magazinecapacity; } else { currentmagazine += totalammo; totalammo = 0; } } public void addammo(int amount) { totalammo += amount; } protected boolean canfire() { long msbetweenshots = 60000 / firerate; // mermi/dakika long now = system.currenttimemillis(); long timesincelastshot = now - lastfiretime; if (timesincelastshot < msbetweenshots) {// yeteri kadar sure gecti mi return false; } else { return true; } } } import java.awt.*; public class bullet { public double x, y; public double angle; public double speed; public int damage; private boolean canpassthrough; private double explosionradius; private boolean isenemybullet = false; public bullet(double sx, double sy, double angle, double speed, int dmg, boolean canpassthrough, boolean isenemybullet) { this.x = sx; this.y = sy; this.angle = angle; this.speed = speed; this.damage = dmg; this.canpassthrough = canpassthrough; this.explosionradius = 0; this.isenemybullet = isenemybullet; } public boolean isenemybullet() { return isenemybullet; } public void update() { x += speed * math.cos(angle); y += speed * math.sin(angle); } public void draw(graphics g) { if (isenemybullet) { g.setcolor(color.green); // asit tukuren zombinin } else { g.setcolor(color.yellow); // oyuncu mermisi } g.filloval((int)x - 3, (int)y - 3, 6, 6); } public int getdamage() { return damage; } public boolean canpassthrough() { return canpassthrough; } public void setexplosionradius(double r) { explosionradius = r; } public double getexplosionradius() { return explosionradius; } } import java.util.arraylist; import java.util.collections; import java.util.list; /** * pompalı tüfek * fire rate 60 */ public class shotgun extends weapon { public shotgun() { super(""pompalı tüfek"", 5, 30, 60); } @override public list<bullet> fire(double sx, double sy, double tx, double ty) { if (!canfire()) return collections.emptylist(); if (currentmagazine <= 0) return collections.emptylist(); lastfiretime = system.currenttimemillis(); currentmagazine--; list<bullet> bullets = new arraylist<>(); double baseangle = math.atan2(ty - sy, tx - sx); // once her zaman duz bulunur double totalspread = math.toradians(45); double ith = totalspread / 8; // 9 mermi 8 aralik double start = baseangle - (totalspread / 2); for (int i = 0; i < 9; i++) { double angle = start + i * ith; // 45 derece (radyan cinsinden) / 8 ile aradaki her bir mesafeyi bulmus gibi olduk bullet bullet = new bullet(sx, sy, angle, 10, 10, false,false); bullets.add(bullet); } return bullets; } } import java.awt.color; import java.awt.graphics; public class spit { public double x, y; private double angle; private double speed; private int damage; private int size = 8; public spit(double x, double y, double angle, double speed, int damage) { this.x = x; this.y = y; this.angle = angle; this.speed = speed; this.damage = damage; } public void update() { x += speed * math.cos(angle); y += speed * math.sin(angle); } public void draw(graphics g) { g.setcolor(color.green); g.filloval((int) (x - size / 2), (int) (y - size / 2), size, size); } public int getdamage() { return damage; } // oyuncuya dogru hareket public boolean collideswith(player player) { double dx = player.x - x; double dy = player.y - y; double distance = math.sqrt(dx * dx + dy * dy); return distance < (35); } } import javax.swing.*; import java.awt.*; import java.awt.event.actionevent; import java.awt.event.actionlistener; public class gamewindow extends jframe { private gamepanel gamepanel; public gamewindow() { settitle(""zombastik""); // isme karar ver unutma !! setdefaultcloseoperation(jframe.exit_on_close); setsize(1024, 768); setlocationrelativeto(null); gamepanel = new gamepanel(); add(gamepanel, borderlayout.center); menubar(); setvisible(true); //oyunu baslat gamepanel.startgame(); } private void menubar() { jmenubar menubar = new jmenubar(); jmenu gamemenu = new jmenu(""menu""); jmenuitem pauseitem = new jmenuitem(""pause""); jmenuitem resumeitem = new jmenuitem(""resume""); jmenuitem saveitem = new jmenuitem(""save""); jmenuitem loaditem = new jmenuitem(""load""); pauseitem.addactionlistener(new actionlistener() { @override public void actionperformed(actionevent e) { gamepanel.pausegame(); } }); resumeitem.addactionlistener(new actionlistener() { @override public void actionperformed(actionevent e) { gamepanel.resumegame(); } }); saveitem.addactionlistener(new actionlistener() { @override public void actionperformed(actionevent e) { gamepanel.savegame(); } }); loaditem.addactionlistener(new actionlistener() { @override public void actionperformed(actionevent e) { gamepanel.loadgame(); } }); gamemenu.add(pauseitem); gamemenu.add(resumeitem); gamemenu.add(saveitem); gamemenu.add(loaditem); menubar.add(gamemenu); setjmenubar(menubar); } } import java.awt.color; /* * normal zombi * can: orta- hız: yavaş- hasar: orta */ public class normalzombie extends zombie { public normalzombie(double x, double y) { super(""normalzombie "", x, y, 50, 1.0, 10, color.green); } @override public string tosave() { return ""normalzombie "" + x + "" "" + y + "" "" + health; } } import java.util.arraylist; import java.util.collections; import java.util.list; /** * keskin nişancı tüfeği * fire rate 30 * bu can pass through */ public class sniperrifle extends weapon { public sniperrifle() { super(""keskin nişancı tüfeği"", 5, 20, 30); } @override public list<bullet> fire(double sx, double sy, double tx, double ty) { if (!canfire()) return collections.emptylist(); if (currentmagazine <= 0) return collections.emptylist(); lastfiretime = system.currenttimemillis(); currentmagazine--; double angle = math.atan2(ty - sy, tx - sx); // duz ates bullet bullet = new bullet(sx, sy, angle, 15, 25, true,false); list<bullet> bullets = new arraylist<>(); bullets.add(bullet); return bullets; } } import java.util.arraylist; import java.util.list; /* tabanca : default silah bu * sinirsiz ammo * atan2 methodu : returns the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta) * bu methodu cok kullanicaz */ public class pistol extends weapon { public pistol() { super(""tabanca"", 12, 99999, 120); } @override public list<bullet> fire(double sx, double sy, double tx, double ty) { if (!canfire()) return new arraylist<>(); if (currentmagazine <= 0) return new arraylist<>(); lastfiretime = system.currenttimemillis(); currentmagazine--; double angle = math.atan2(ty - sy, tx - sx); // duz atis yapar bullet bullet = new bullet(sx, sy, angle, 10, 10, false,false); list<bullet> bullets = new arraylist<>(); bullets.add(bullet); return bullets; } } import javax.swing.jlabel; import javax.swing.joptionpane; import javax.swing.jpanel; import javax.swing.jwindow; import javax.swing.swingconstants; import javax.swing.swingutilities; import javax.swing.timer; import java.awt.*; import java.awt.event.*; import java.io.*; import java.util.arraylist; import java.util.list; import java.util.random; public class gamepanel extends jpanel implements actionlistener, keylistener, mouselistener, mousemotionlistener { // timing private timer timer; private final int delay = 16; // ~60 fps (16 ms per frame) 60 fps saglayacak // game state private boolean ispaused; private player player; private java.util.list<zombie> zombies; private java.util.list<bullet> bullets; private list<spit> spits; private list<ammodrop> ammodrops = new arraylist<>(); private int wavenumber; private int score; private random random; private gamemap gamemap; // nisan almak icin private point mousepos = new point(0, 0); public gamepanel() { setbackground(color.dark_gray); setfocusable(true); // listeners addkeylistener(this); addmouselistener(this); addmousemotionlistener(this); // initialize baslat timer = new timer(delay, this); //her 16 msda actionperformed() methodu cagrilir ispaused = false; random = new random(); } public void startgame() { // yeni oyuncu yarat player = new player(512, 384); // zombi ve mermi listlerini yarat zombies = new arraylist<>(); bullets = new arraylist<>(); spits = new arraylist<>(); // harita gamemap = new gamemap(""map.txt""); wavenumber = 0; // 1 oldugunda piyade tufegi hemen geliyor dikkat et score = 0; spawnwave(wavenumber); // start timer timer.start(); // java tanim : starts the timer, causing it to start sending action events to its listeners. // her 16 msnde bir actionperformed() cagrilir delay = 16 } // oyun yüklendiginde ya da kaydedilginde kisa sureli mesaj gostermek icin private void showtempmsg(string message) { jwindow window = new jwindow(); jlabel label = new jlabel(message); label.setfont(new font(""arial"", font.bold, 22)); jpanel panel = new jpanel(new borderlayout()); panel.add(label, borderlayout.center); window.getcontentpane().add(panel); window.setsize(200, 150); window.setlocationrelativeto(null); window.setvisible(true); new timer(1000, e -> window.dispose()).start(); // 1 saniye sonra kendi kapanir } private void spawnwave(int wave) { // her dalgada daha fazla ve cesitli zombiler gelir int zombiecount = 3 + (wave * 2); int w = math.max(1, getwidth()); // eger component henuz cagrilmadiysa sikinti cikmasin diye max kullandik int h = math.max(1, getheight() / 2); // getler 0 ise 1 degeri alir ve negative bound olmaz // hesapladigimiz width(w) ve height(h) noktalari kullanilarak rastgele bir yerde zombiler olusturulur // dalga arttikca daha zor olmasını ve zombi cesitliligini saglamak icin random.nextint(100) kullandik for (int i = 0; i < zombiecount; i++) { zombie z; if (wave >= 3 && random.nextint(100) < 30) { z = new spitterzombie(random.nextint(w),random.nextint(h)); } else if (wave >= 2 && random.nextint(100) < 20) { z = new tankzombie(random.nextint(w),random.nextint(h)); } else if (wave >= 1 && random.nextint(100) < 30) { z = new crawlerzombie(random.nextint(w),random.nextint(h)); } else { z = new normalzombie(random.nextint(w),random.nextint(h)); } zombies.add(z); } // belirli zombi dalgalari temzilendikten sonra odul olarak yeni silah verir // silahların eklenme sirasi ile sayi tuslarındaki sirasi aynidir // 1-> tabanca 2-> piyade tufegi gibi... if (wave == 1) { // 1. dalgadan sonra piyade tufegi player.addweapon(new assaultrifle()); } else if (wave == 3) { // 3. dalgadan sonra pompali tufek player.addweapon(new shotgun()); } else if (wave == 5) { // 5. dalgadan sonra keskin nisanci player.addweapon(new sniperrifle()); } else if (wave == 10) { // 10. dalgadan sonra roketatar player.addweapon(new rocketlauncher()); } } @override public void actionperformed(actionevent e) { if (!ispaused) { updategame(); repaint(); } } private void updategame() { // player double prevx = player.x; double prevy = player.y; player.update(); rectangle playerbounds = new rectangle((int) player.x, (int) player.y, player.getwidth(), player.getheight()); // tile ile collision var mi if (gamemap.checkcollision(playerbounds)) { player.x = prevx; player.y = prevy; } // bullets for (int i = bullets.size() - 1; i >= 0; i--) { bullet b = bullets.get(i); b.update(); // ekran disina ciktiysa remove if (!isonscreen(b.x, b.y)) { bullets.remove(i); } } // zombies list<zombie> zombieseffected = new arraylist<>(); for (int i = zombies.size() - 1; i >= 0; i--) { zombie z = zombies.get(i); z.update(player.x, player.y); if (z instanceof spitterzombie) { spitterzombie spitter = (spitterzombie) z; spit spit = spitter.mayspit(player); if (spit != null) { spits.add(spit); } } for (int j = bullets.size() - 1; j >= 0; j--) { bullet b = bullets.get(j); if (z.ishitbybullet(b)) { // oncelikle roketatar mi geldi kontrol etmeliyiz if (b.getexplosionradius() > 0) { // eger roketatar ise belli bir mesafe içersinde etkilenecek zombileri kaydetmeliyiz for (int k = zombies.size() - 1; k >= 0; k--) { zombie other = zombies.get(k); double dx = other.x - b.x; double dy = other.y - b.y; double dist = math.sqrt(dx * dx + dy * dy); // burada zombinin mermiden ne kadar uzak oldugunu hesapladık if (dist <= b.getexplosionradius()) { zombieseffected.add(other); score += 10; // eger olduyse arkasinde random sayida mermi bulunduran bir kutu birakmali int ammoamount = 5 + random.nextint(10); // random sayida mermi dusursun olunce ammodrops.add(new ammodrop(z.x, z.y, ammoamount)); } } } // roketatar degilse else { z.takedamage(b.getdamage()); if (!z.isalive()) { zombieseffected.add(z); score += 10; // eger olen zombi asit tukuren ise belli bir cevresindeki zombiler de olmeli // burada roketatar yaparken kullandigin mantiktan ilerle !! if(z instanceof spitterzombie){ list<zombie> zombieseffectedbyspit = new arraylist<>(); for (zombie other : zombies) { if (other != z) { double dx = other.x - z.x; double dy = other.y - z.y; double dist = math.sqrt(dx * dx + dy * dy); if (dist < 100) { zombieseffectedbyspit.add(other); } } } for (zombie victim : zombieseffectedbyspit) { victim.takedamage(101); if (!zombieseffected.contains(victim)) { zombieseffected.add(victim); } } } // eger olduyse arkasinde random sayida mermi bulunduran bir kutu birakmali int ammoamount = 5 + random.nextint(10); ammodrops.add(new ammodrop(z.x, z.y, ammoamount)); } } if (!b.canpassthrough()) bullets.remove(j); break; } } if(i < zombies.size()){ if(z.collideswith(player)){ player.takedamage(z.getdamage()); } } if(!player.isalive()){ gameover(); return; } } // bos list hatasi olmamasi icin en son listeden cikardik zombies.removeall(zombieseffected); // spits for (int i = spits.size() - 1; i >= 0; i--) { spit s = spits.get(i); s.update(); // ekran disina ciktiysa remove if (!isonscreen(s.x, s.y)) { spits.remove(i); continue; } // oyuncu ile collision oldu mu if (s.collideswith(player)) { // oyuncunun canını azalt player.takedamage(s.getdamage()); spits.remove(i); // oyuncu oldu mu if (!player.isalive()) { gameover(); return; } } } // dusen mermileri topla for (int i = ammodrops.size() - 1; i>= 0; i--) { ammodrop drop = ammodrops.get(i); if (!drop.iscollected && drop.collideswith(player)) { drop.iscollected = true; player.getcurrentweapon().addammo(drop.amount); ammodrops.remove(i); } } // dalgadaki zombiler bitti mi if (zombies.isempty()) { wavenumber++; spawnwave(wavenumber); // bittiyse yeni wave spawn } } private boolean isonscreen(double x, double y) { return (x >= 0 && x < getwidth() && y >= 0 && y < getheight()); } private void gameover() { timer.stop(); joptionpane.showmessagedialog(this, ""oyun bitti! toplam skor: "" + score); // oyun bitince tekrar mi baslasin kontrol et !!! startgame(); //system.exit(0); } @override protected void paintcomponent(graphics g) { super.paintcomponent(g); // haritayi ciz if (gamemap != null) { gamemap.draw(g); } // oyuncu ciz if (player != null) { player.draw(g); } // mermileri ciz for (bullet b : bullets) { b.draw(g); } for (spit s : spits) { s.draw(g); } // zombileri ciz for (zombie z : zombies) { z.draw(g); } // zombilerin olunce biraktıkları mermi kutusu for (ammodrop drop : ammodrops) { drop.draw(g); } // sol ust koseye bilgiler yazilir g.setcolor(color.pink); if (player != null && player.getcurrentweapon() != null) { g.drawstring( ""silah: "" + player.getcurrentweapon().getname() + "" | şarjör: "" + player.getcurrentweapon().getcurrentmagazine() + ""/"" + player.getcurrentweapon().getmagazinecapacity() + "" | mermi sayısı: "" + player.getcurrentweapon().gettotalammo() + "" | dalga: "" + (wavenumber + 1), 10, 20 ); } // sag ust koseye can ve skor yazilir g.drawstring(""kalan can: "" + player.health + "" | puan: "" + score, getwidth() - 150, 20); } // fileio ile oyun kaydetme, durdurma ve yükleme public void savegame() { // dokumasyonda istedigi gibi bir fileda kaydedilen oyunun bilgilerini tutacagız load secilince buradan bigileri okuyacagız try (printwriter pw = new printwriter(new filewriter(""saved.txt""))) { pw.println(wavenumber); // hangi dalgadayiz pw.println(score); // skor // oyuncu bilgileri pw.println(player.x + "" "" + player.y + "" "" + player.health); // regex "" "" // silah bilgileri pw.println(player.getweapons().indexof(player.getcurrentweapon())); for (weapon w : player.getweapons()) { pw.print(w.getname() + "" ""); pw.print(w.getcurrentmagazine() + "" ""); pw.print(w.gettotalammo() + ""\n""); } // zombie bilgileri pw.println(zombies.size()); for (zombie z : zombies) { pw.println(z.tosave()); } showtempmsg("" oyun kaydedildi!""); } catch (ioexception ex) { ex.printstacktrace(); } } // yazdigimiz sirayla okuyalim public void loadgame() { try (bufferedreader br = new bufferedreader(new filereader(""saved.txt""))) { wavenumber = integer.parseint(br.readline()); score = integer.parseint(br.readline()); // oyuncu bilgileri string[] playerdata = br.readline().split("" ""); player.x = double.parsedouble(playerdata[0]); player.y = double.parsedouble(playerdata[1]); player.health = integer.parseint(playerdata[2]); int currentweaponindex = integer.parseint(br.readline()); // silahlar player.getweapons().clear(); list<weapon> loadedweapons = new arraylist<>(); string line; while ((line = br.readline()) != null) { string[] weapondata = line.split("" ""); if (weapondata.length == 1) { break; } string wname = weapondata[0]; int currmag = integer.parseint(weapondata[1]); int totalammo = integer.parseint(weapondata[2]); weapon w = createweaponbyname(wname); if (w != null) { w.setcurrentmagazine(currmag); w.settotalammo(totalammo); loadedweapons.add(w); } } player.getweapons().addall(loadedweapons); if (!player.getweapons().isempty() && currentweaponindex >= 0 && currentweaponindex < player.getweapons().size()) { player.setcurrentweapon(player.getweapons().get(currentweaponindex)); } // zombiler zombies.clear(); int zombiecount = integer.parseint(line); for (int i = 0; i < zombiecount; i++) { string zline = br.readline(); zombie z = zombie.fromsave(zline); if (z != null) { zombies.add(z); } } showtempmsg("" oyun yüklendi!""); } catch (ioexception e) { e.printstacktrace(); } } private weapon createweaponbyname(string name) { switch(name) { case ""tabanca"": return new pistol(); case ""piyade tüfeği"": return new assaultrifle(); case ""pompalı tüfek"": return new shotgun(); case ""keskin nişancı tüfeği"": return new sniperrifle(); case ""roketatar"": return new rocketlauncher(); default: return null; } } // pause ve resume public void pausegame() { ispaused = true; } public void resumegame() { ispaused = false; } // klavyeden ve mousedan input @override public void keypressed(keyevent e) { if (player != null) { player.keypresshandler(e.getkeycode()); } } @override public void keyreleased(keyevent e) { if (player != null) { player.keyreleasehandler(e.getkeycode()); // r ye basildiginda silahlarin mermisi reload if (e.getkeycode() == keyevent.vk_r) { player.reload(); } } } @override public void keytyped(keyevent e) {} @override public void mouseclicked(mouseevent e) { // sol veya sag tik ile mermi ateslensin if (swingutilities.isleftmousebutton(e) && !ispaused && player != null || swingutilities.isrightmousebutton(e) && !ispaused && player != null) { java.util.list<bullet> newbullets = player.firetoward(e.getx(), e.gety()); bullets.addall(newbullets); } } @override public void mousepressed(mouseevent e) {} @override public void mousereleased(mouseevent e) {} @override public void mouseentered(mouseevent e) {} @override public void mouseexited(mouseevent e) {} @override public void mousedragged(mouseevent e) { mousepos = e.getpoint(); } @override public void mousemoved(mouseevent e) { mousepos = e.getpoint(); } } import java.util.arraylist; import java.util.collections; import java.util.list; import java.util.random; /** piyade tüfeği * fire rate 600 * 1.dalgadan sonra elde edilir */ public class assaultrifle extends weapon { private random rand; public assaultrifle() { super(""piyade tüfeği"", 30, 600, 600); this.rand = new random(); } @override public list<bullet> fire(double sx, double sy, double tx, double ty) { if (!canfire()) return collections.emptylist(); if (currentmagazine <= 0) return collections.emptylist(); lastfiretime = system.currenttimemillis(); currentmagazine--; double baseangle = math.atan2(ty - sy, tx - sx); // duz ates etme buna -+ 15 eklicez random double spread = math.toradians(15); // aciyi sayiyya cevirdik double offset = (rand.nextdouble() * (spread * 2)) - spread; // -15 derece ve +15 derece arasi bir sayi degeri verecek o yuzden radyan kullandık double angle = baseangle + offset; bullet bullet = new bullet(sx, sy, angle, 10, 20, false, false); // damage=8 olsun mu bak list<bullet> bullets = new arraylist<>(); bullets.add(bullet); return bullets; } } import java.awt.color; /* * asit tüküren zombi * can: düşük- hız: yavaş- hasar: orta (uzaktan asit tükürebilir)- özellik: öldürüldüğünde yanındaki birimlere zarar verir */ public class spitterzombie extends zombie { private long lastspit = 0; private final long spitrepeat = 3000; // 3 saniyede 1 asit firlatsin public spitterzombie(double x, double y) { super(""spitterzombie "", x, y, 35, 0.8, 10, color.yellow); } @override public string tosave() { return ""spitterzombie "" + x + "" "" + y + "" "" + health; } public spit mayspit(player player) { long now = system.currenttimemillis(); if (now - lastspit >= spitrepeat) { lastspit = now; double angle = math.atan2(player.y - y, player.x - x); // oyuncu ile arasindaki mesafe icin return new spit(x, y, angle, 3.0, 7); } return null; } } import java.awt.color; /* * sürünge zombi * can: düşük- hız: hızlı- hasar: orta - özellik: oyuncunun yakınına geldiğinde zıplar. */ public class crawlerzombie extends zombie { public crawlerzombie(double x, double y) { super( ""crawlerzombie "", x, y, 35, 1.6, 10, color.magenta); } @override public string tosave() { return ""crawlerzombie "" + x + "" "" + y + "" "" + health; } } import java.awt.color; /* * tank zombi * can: yüksek- hız: çok yavaş- hasar: yüksek */ public class tankzombie extends zombie { public tankzombie(double x, double y) { super(""tankzombie "", x, y, 100, 0.5, 20, color.red); } @override public string tosave() { return ""tankzombie "" + x + "" "" + y + "" "" + health; } } /* java topdown.game main */ public class game { public static void main(string[] args) { /*swingutilities.invokelater(() -> { // bu thread safemis gamewindow window = new gamewindow(); window.setvisible(true); });*/ gamewindow window = new gamewindow(); window.setvisible(true); } } import java.util.arraylist; import java.util.collections; import java.util.list; /** * roketatar * fire rate 10 */ public class rocketlauncher extends weapon { public rocketlauncher() { super(""roketatar"", 1, 5, 10); } @override public list<bullet> fire(double sx, double sy, double tx, double ty) { if (!canfire()) return collections.emptylist(); if (currentmagazine <= 0) return collections.emptylist(); lastfiretime = system.currenttimemillis(); currentmagazine--; double angle = math.atan2(ty - sy, tx - sx); // yine tek bir mermi gibi gozukur ama etrafindakileri yok eder bullet rocket = new bullet(sx, sy, angle, 8, 100, false,false); // rocket is a bullet o yuzden explosionradius kullandık rocket.setexplosionradius(50); // collision oldugunda 50 derece etrafindaki tum zombiler yok olsun list<bullet> bullets = new arraylist<>(); bullets.add(rocket); return bullets; } } import java.awt.*; import java.awt.event.keyevent; import java.util.arraylist; import java.util.list; public class player { public double x, y; public int health; public final double speed = 4.0; // hareket flags private boolean up, down, left, right; // weapons private list<weapon> weapons; private weapon currentweapon; public player(double x, double y) { this.x = x; this.y = y; this.health = 100; weapons = new arraylist<>(); // default olarak tabancası olacak weapon pistol = new pistol(); weapons.add(pistol); currentweapon = pistol; } public void update() { if (up) y -= speed; if (down) y += speed; if (left) x -= speed; if (right) x += speed; } public void draw(graphics g) { g.setcolor(color.blue); g.fillrect((int)x - 15, (int)y - 15, 30, 30); } public void keypresshandler(int keycode) { if (keycode == keyevent.vk_w || keycode == keyevent.vk_up) up = true; if (keycode == keyevent.vk_s || keycode == keyevent.vk_down) down = true; if (keycode == keyevent.vk_a || keycode == keyevent.vk_left) left = true; if (keycode == keyevent.vk_d || keycode == keyevent.vk_right) right = true; // sayi tuslari ile silahlar degisimi handle edilir if (keycode >= keyevent.vk_1 && keycode <= keyevent.vk_9) { int idx = keycode - keyevent.vk_1; if (idx >= 0 && idx < weapons.size()) { currentweapon = weapons.get(idx); } } } public void keyreleasehandler(int keycode) { if (keycode == keyevent.vk_w || keycode == keyevent.vk_up) up = false; if (keycode == keyevent.vk_s || keycode == keyevent.vk_down) down = false; if (keycode == keyevent.vk_a || keycode == keyevent.vk_left) left = false; if (keycode == keyevent.vk_d || keycode == keyevent.vk_right) right = false; } public void reload() { if (currentweapon != null) { currentweapon.reload(); } } public boolean isalive() { return health > 0; } public void takedamage(int dmg) { health -= dmg; } public weapon getcurrentweapon() { return currentweapon; } public void setcurrentweapon(weapon w) { currentweapon = w; } public void addweapon(weapon w) { for (weapon existing : weapons) { if (existing.getclass() == w.getclass()) { return; } } weapons.add(w); } public list<weapon> getweapons() { return weapons; } /* * mouse yonunda ates edecek bir mermi list dondurur */ public list<bullet> firetoward(int targetx, int targety) { if (currentweapon == null) return new arraylist<>(); return currentweapon.fire(x, y, targetx, targety); } public int getwidth() { return 30; } public int getheight() { return 30; } }"
1280995,1,"recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. package test; public class collatz{ public static void main(string[] args){ system.out.println(collatz(5)); } public static int collatz(int i){ if (i == 1) return 0; else if (i%2==0){ return 1 + collatz(i/2); } else { return 1 + collatz(i*3+1); } } } package test; public class cocktail{ public static void main(string[] args){ int[] arr = {5,4,1,2}; cocktailsort(arr); //printer for (int i = 0; i < arr.length; i++){ system.out.print(arr[i] + "",""); } } public static void cocktailsort(int[] arr){ bubble(arr, 0, arr.length - 1, false); } public static void bubble(int[] arr, int start, int end, boolean rightway){ rightway = true; if (start == end && !isordered(arr) && rightway){ rightway = false; bubble(arr, arr.length - 1, 0, rightway); return; } if (start == end && !isordered(arr) && !rightway){ rightway = true; bubble(arr, 0, arr.length, rightway); return; } else if (start == end && isordered(arr)) { return; } else if (end > start) { if (arr[start] > arr[start + 1]){ int temp = arr[start + 1]; arr[start + 1] = arr[start]; arr[start] = temp; } bubble(arr, start + 1, end, rightway); return; } else if (start > end) { if (arr[start - 1] > arr[start]){ int temp = arr[start - 1]; arr[start - 1] = arr[start]; arr[start] = temp; } bubble(arr, start - 1, end, rightway); return; } } public static boolean isordered(int[] arr){ for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) return false; } return true; } } package test; public class sayac{ string s; public sayac(string s) { this.s = s; } public int say(){ if (s.indexof('1') == -1) return 0; else { s = s.substring(0,s.indexof('1')) + ""0"" + s.substring(s.indexof('1') + 1,s.length()); return 1 + say(); } } } class testing{ public static void main(string[] args){ sayac s1 = new sayac(""1001""); sayac s2 = new sayac(""1111""); system.out.println(s2.say()); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; import java.util.arraylist; import java.util.arrays; import java.util.random; abstract class sarki { sarki(){} string isim; string sanatci; abstract void oynat(); sarki(string isim, string sanatci){ this.isim = isim; this.sanatci = sanatci; } } class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik){ this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void oynat(){ system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } void gostermetalozellikleri(){ system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" [ozellik: "" + metalozellik + ""]""); } } class rocksarki extends sarki { rocksarki(string isim, string sanatci){ this.isim = isim; this.sanatci = sanatci; } //? void oynat(){ system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } class klasiksarki extends sarki { klasiksarki(string isim, string sanatci){ this.isim = isim; this.sanatci = sanatci; } // bi tane daha? void oynat(){ system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } interface calmastratejisi { void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi){ //liste sırasında çal for (sarki sarki : sarkilistesi){ sarki.oynat(); } system.out.println(); } siralicalma(){} } class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi){ //her şarkı bir kere çalınmak üzere karışık çal random random = new random(); list<sarki> karisik = new arraylist<sarki>(sarkilistesi); while (!karisik.isempty()){ int nextint = random.nextint(karisik.size()); karisik.get(nextint).oynat(); karisik.remove(nextint); } system.out.println(); } karisikcalma(){} } class rockcuozelcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi){ //liste sırasında çal rocksarki çalarken sesi yükselt, diğerlerinde normale döndür. //ardışık şarkılarda sadece baştakinde işlemi yap, değilse aynı kalsın. boolean sesnasil = false; for (sarki sarki : sarkilistesi){ if(sarki instanceof rocksarki && sesnasil == false){ sesnasil = true; system.out.println(""[bilgi] ses duzeyi: yuksek""); } else if (!(sarki instanceof rocksarki) && sesnasil == true){ sesnasil = false; system.out.println(""[bilgi] ses duzeyi: normal""); } sarki.oynat(); } system.out.println(); } rockcuozelcalma(){} } class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s){ //değiştiriyor strateji = s; } void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } public class muziklisey { public static void main(string[] args){ // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { metalsarki a = new metalsarki("""", """", """"); a = (metalsarki)sarki; a.gostermetalozellikleri(); } } } } kelime sayıcı bil 211 - lab 3 20 şubat 2025 1 giriş bu laboratuvarda fileioveexceptions kullanarak bir kelime sayıcı geliştireceğiz. kelime sayıcı , verilen birmetindosyasındakibelirlikelimelerinkaçkezgeçtiğinisayarakbirçıktıdosyasınakaydedecekvebelirlenen hata durumlarında uygun çıktılar oluşturacaktır. 2 genel program program, aşağıdaki sabit isimlere sahip iki giriş dosyası ile çalışacaktır: -kelimeler.txt – aranacak kelimeleri içeren dosya. -metin.txt – kelimelerin aranacağı metnin bulunduğu dosya. program, kelimeler.txt dosyasındaki her kelimenin metin.txt içinde kaç kez geçtiğini sayacak ve sonucu bir çıktı dosyasına kaydedecektir: -sonuc.txt – her kelimenin kaç kez geçtiğini içeren çıktı dosyası. dosyalar,programınçalıştırıldığıdizindebulunmalıdır. dosyaisimlerideğiştirilemez,programsadeceyukarıda belirtilen isimlerle çalışacaktır. eğerkelimeler.txt içinde bulunan herhangi bir kelime, metin.txt içinde hiç geçmiyorsa, program bir hata oluşturmalı ve stderr’e uygun bir mesaj yazmalıdır. 3 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları kullanacaktır (örn., bufferredreader, scanner, printwriter). dosyaları okurken ve yazarken kullanacağınız fileio sınıflarının seçimi size bırakılmıştır. i̇şlenmesi gereken dosyalar şunlardır: -kelimeler.txt dosyası okunmalıdır. -metin.txt dosyası okunmalıdır. -sonuc.txt dosyası oluşturulup yazılmalıdır. program,aşağıdakiolasıdosyahatalarınıoluşturmalıvehatalaroluştuğundastderr’ebelirlenenhatamesajlarını yazmalıdır: - dosyabulunamıyorsa: ""hata: kelimeler.txt bulunamadı."" veya""hata: metin.txt bulunamadı."" - dosya boşsa: ""hata: kelimeler.txt boş."" veya""hata: metin.txt boş."" 4 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program hata kodu ile çıkış yapmalıdır (yani mainmetodunuz bu hataları atarak sonlanmalı) ve hatalar stderr’e yazılmalıdır (programınızı hata atarak sonlandırırsanız java bunu kendisi yapacaktır). belirtilen hata mesajları ile birlikte java’nın hata ile sonlanan programlar için oluşturduğu sınıf, metod, ve satır gibi bilgiler bulunabilir. 1 4.1 girdi hataları (inputexception class) bu kategori, programın giriş dosyalarıyla ilgili karşılaşabileceği tüm hataları kapsar. öğrenciler, dosya işlem- leriyle ilgili hata türlerini inputexception sınıfından türetmelidir. aşağıdaki özel hata türleri tanımlanmalıdır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: [dosya adı] bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: [dosya adı] boş."" 4.2 kelime bulunamadı hatası (kelimebulunamadiexception class) eğerkelimeler.txt içinde bulunan en az bir kelime, metin.txt dosyasında hiç geçmiyorsa, program kelimebulunamadiexception hatasını atmalıdır. hata yalnızca kelimeler.txt dosyasında bulunamayan ilk kelime için atılır ve program sonlanır. bu hata oluştuğunda stderr’e şu mesaj yazılmalıdır: -""hata: [kelime] metinde bulunamadı."" bu hata, doğrudan exception sınıfından türetilecek ve inputexception ile bağlantılı olmayacaktır. 5 dosya formatları program üç farklı dosya ile çalışacaktır: kelimeler.txt (girdi),metin.txt (girdi) ve sonuc.txt (çıktı). bu dosyaların formatı aşağıda belirtilmiştir. 5.1 girdi dosyaları girdi dosyaları düz metin ( .txt) formatında olacaktır ve her biri aşağıdaki gibi yapılandırılmış olmalıdır. 5.1.1kelimeler.txt formatı kelimeler.txt dosyası, her satırda bir kelime olacak şekilde düzenlenmelidir. dosyada yalnızca harf karak- terleri bulunur. kelimeler büyük/küçük harf duyarsız olarak aranacaktır. örnek i̇çerik: elma armut üzüm eğer dosya boşsa, program şu hatayı vermelidir: hata: kelimeler.txt boş. 5.1.2metin.txt formatı metin.txt dosyası, içinde aranacak kelimelerin geçebileceği serbest formatlı bir metin içermelidir. dosya içinde noktalama işaretleri ve boşluklar bulunabilir. örnek i̇çerik: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. eğer dosya boşsa, program şu hatayı vermelidir: hata: metin.txt boş. 5.2 çıktı dosyası program, kelimelerin kaç kez geçtiğini gösteren bir çıktı dosyası ( sonuc.txt ) oluşturmalıdır. 2 5.2.1sonuc.txt formatı sonuc.txt dosyası, her satırda kelimenin adı ve kaç kez geçtiği bilgisi olacak şekilde düzenlenmelidir. format şu şekilde olmalıdır: [kelime] [geçme sayısı] kelime ve geçme sayısı arasında tek bir boşluk olmalıdır. örnek çıktı ( sonuc.txt ): elma 2 armut 2 üzüm 1 5.3 özel hata durumları ve çıktıları eğerkelimeler.txt içindekiherhangibirkelime metin.txt içindebulunamazsa, kelimebulunamadiexception hatası atılmalıdır ve stderr’e şu mesaj yazılmalıdır: hata: üzüm metinde bulunamadı. bu hata oluştuğunda, yine de sonuc.txt dosyası oluşturulmalı ve bulunan kelimeler için normal çıktı yazıl- malıdır. ancak bulunamayan kelimeler çıktı dosyasına eklenmemelidir. örnek durum: eğerkelimeler.txt şu şekildeyse: elma armut muz vemetin.txt şu şekildeyse: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. o zaman sonuc.txt şu şekilde olmalıdır: elma 2 armut 2 ve stderr’e şu mesaj yazılmalıdır: hata: muz metinde bulunamadı. 6 gönderim formatı - labı bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara şeklinde isimlendirin (örn., johnnash_181101014.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""lab3 gönderim"" başlıklı bir mail ile gönderin. 3 metot açıklama string(string s) sile aynı değere sahip bir string oluşturur. string(char[] a) a[]dizisindeki karakterlerle bir string oluşturur. int length() string içindeki karakter sayısını döndürür. char charat(int i) belirtilen iindeksindeki karakteri döndürür. string substring(int i, int j) iilej-1arasındaki karakterleri içeren bir alt string döndürür. boolean contains(string substring) string’in substring ’i içerip içermediğini kontrol eder. boolean startswith(string prefix) string’in prefixile başlayıp başlamadığını kontrol eder. boolean endswith(string postfix) string’in postfix ile bitip bitmediğini kontrol eder. int indexof(string pattern) pattern ifadesinin ilk geçtiği indeks değerini döndürür. int indexof(string pattern, int i) iindeksinden sonraki ilk pattern konumunu döndürür. string concat(string t) string’in sonuna teklenmiş halini döndürür. int compareto(string t) i̇ki string’i karşılaştırır (sözlük sırasına göre). string tolowercase() string’in tüm harflerini küçük harfe çevirir. string touppercase() string’in tüm harflerini büyük harfe çevirir. string replace(string a, string b) string içindeki a’larıbile değiştirir. string trim() string’in başındaki ve sonundaki boşlukları kaldırır. boolean matches(string regex) string’in belirtilen regexle eşleşip eşleşmediğini kontrol eder. string[] split(string delimiter) string’idelimiter kullanarak böler ve bir dizi döndürür. boolean equals(object t) string’in değeri tile aynı mı diye kontrol eder. table 1: java string sınıfı metotları 4 package kelimesayici; import java.io.file; import java.io.filenotfoundexception; import java.io.printwriter; import java.util.arraylist; import java.util.scanner; public class main { public static void main(string[] args) throws dosyabulunamadiexception, bosdosyaexception, inputexception, kelimebulunamadiexception{ string metin = """"; arraylist<string> kelimeler = new arraylist<>(); file metinfile = new file(""metin.txt""); file kelifile = new file(""kelimeler.txt""); scanner scan; try { scan = new scanner(metinfile); if (!scan.hasnext()) { scan.close(); throw new bosdosyaexception(""hata: metin.txt bos.""); } while (scan.hasnext()) { metin += scan.nextline(); } scan.close(); } catch (filenotfoundexception e) { throw new dosyabulunamadiexception(""hata: metin.txt bulunamadi.""); } try { scan = new scanner(kelifile); if (!scan.hasnext()) { scan.close(); throw new bosdosyaexception(""hata: kelimeler.txt bos.""); } while (scan.hasnext()){ kelimeler.add(scan.next()); } scan.close(); } catch (filenotfoundexception e) { throw new dosyabulunamadiexception(""hata: kelimeler.txt bulunamadi.""); } int[] amount = new int[kelimeler.size()]; string removed = metin.replaceall(""\\p{punct}"", "" "").trim().tolowercase(); boolean none = false; int nonewhere = 0; for (int i = 0; i < kelimeler.size(); i++){ if (removed.indexof(kelimeler.get(i)) == -1) { none = true; nonewhere = i; break; } } for (int i = 0; i < kelimeler.size(); i++){ while (removed.indexof(kelimeler.get(i)) != -1) { amount[i]++; removed = removed.substring(0, removed.indexof(kelimeler.get(i))) + removed.substring(removed.indexof(kelimeler.get(i)) + kelimeler.get(i).length(), removed.length()); removed = removed.trim(); } } file sonuc = new file(""sonuc.txt""); try { sonuc.createnewfile(); printwriter print = new printwriter(""sonuc.txt""); for (int i = 0; i < amount.length; i++){ print.println(kelimeler.get(i) + "" "" + amount[i]); } print.close(); } catch (exception e) { system.err.println(""hata!""); } if (none) throw new kelimebulunamadiexception(""hata: "" + kelimeler.get(nonewhere) + "" metinde bulunamadi.""); } } package kelimesayici; public class kelimebulunamadiexception extends exception { kelimebulunamadiexception(string message) { super(message); } } package kelimesayici; public class bosdosyaexception extends inputexception { bosdosyaexception(string message){ super(message); } } package kelimesayici; import java.io.ioexception; public class inputexception extends ioexception { inputexception(string message){ super(message); } } package kelimesayici; public class dosyabulunamadiexception extends inputexception { dosyabulunamadiexception(string message){ super(message); } } generic 1) envanter yönetim sistemi bu labda amacımı bir oyun için envanter sistemi eklemektir. item isminde bir arayüz tanımlayın: aşağıdaki metotları içermelidir: string getname() int getvalue() weapon sınıfı tanımlayın. bu sınıf item arayüzünü uygulamalıdır. int damage isimli bir özelliği olmalıdır. armor sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. int defense isimli bir değişkeni olmalıdır. potion sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. string effect isimli bir değişkeni olmalıdır. generic inventory<t> sınıfı bir arraylist kullanarak nesneleri saklamalıdır. void additem(t item): envantere istenilen eşyayı eklemeli void removeitem(t item): envanterden istenilen eşyayı silmeli void printinventory(): envanteri basmalı t mostvaluableitem(): en değerli eşyayı dönmeli t finditembyname(string name): verilen isme karşılık gelen eşyayı dönmeli. i̇simlerin unique olduğunu varsayabilirsiniz. eğer yoksa null dönün. list<t> finditemsbyvalue(int value): verilen değerden daha değerli eşyaarın listesini döndürür. int gettotalvalue(): envanterin toplam değerini döner. list<t> filterbytype(class<?> type): istenilen sınıfa ait ögeleri döner. int gettotalweapondamage(): weapon classına ait olan nesnelerin toplam hasarınıdöner. void sortbyvalue(): değeri azalan şekilde envanteri sıralamalıdır. public static void printmostvaluableitem(inventory<? extends item> inventory): verilen envanterdem en değerli eşayı ekrana basmalıdır. public static void transferarmor(inventory<? super armor> destination, inventory<armor> source): verilen hedef envantere zırhı taşımalıdır. driver class: main metodu burada olmalıdır. sadece weapon’dan oluşan ve itemdan oluşan invertory classı yazıp test ediniz. yardımcı olabilecek metotlar: class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon import java.util.arraylist; import java.util.list; public class inventory<t> { arraylist<t> items; public inventory(){ items = new arraylist<>(); } void additem(t item){ items.add(item); } void removeitem(t item){ items.remove(item); } void printinventory(){ system.out.print(""[""); for (int i = 0; i < items.size(); i++){ if (items.get(i) instanceof item) { item a = (item) items.get(i); if (i != items.size()-1) system.out.print(a.getname() + "", ""); else system.out.println(a.getname() + ""]""); } } } t mostvalueableitem(){ int value = 0; t valueableitem = null; for (t item : items) { if (item instanceof item) { item a = (item) item; if (a.getvalue() > value) { value = a.getvalue(); valueableitem = item; } } } return valueableitem; } t finditembyname(string name) { t neededitem = null; for (t item : items) { if (item instanceof item) { item a = (item) item; if (a.getname().equals(name)) neededitem = item; } } return neededitem; } list<t> finditemsbyvalue(int value) { arraylist<t> valuelist = new arraylist<>(); for (t item : items) { if (item instanceof item) { item a = (item) item; if (a.getvalue() > value) { valuelist.add(item); } } } return valuelist; } int gettotalvalue(){ int value = 0; for (t item : items) { if (item instanceof item) { item a = (item) item; value += a.getvalue(); } } return value; } list<t> filterbytype(class<?> type){ arraylist<t> typelist = new arraylist<>(); for (t item : items) { if (item.getclass().getname().equals(type.getname())){ typelist.add(item); } } return typelist; } int gettotalweapondamage(){ int damage = 0; for (t item : items) { if (item instanceof weapon) { weapon a = (weapon) item; damage += a.getdamage(); } } return damage; } void sortbyvalue(){ arraylist<t> orderedlist = new arraylist<>(items); for (int i = 0; i < orderedlist.size(); i++){ if (orderedlist.get(i) instanceof item) { item a = (item) orderedlist.get(i); for (int j = 0; j < orderedlist.size(); j++){ if (orderedlist.get(j) instanceof item) { item b = (item) orderedlist.get(j); if (b.getvalue() <= a.getvalue()){ t temp = orderedlist.get(i); orderedlist.set(i, orderedlist.get(j)); orderedlist.set(j, temp); } } } } } items = orderedlist; } public static void printmostvaluableitem(inventory<? extends item> inventory){ int value = 0; item valueableitem = null; for (int i = 0; i < inventory.items.size(); i++){ if (inventory.items.get(i) instanceof item) { item a = (item) inventory.items.get(i); if (a.getvalue() > value) { value = a.getvalue(); valueableitem = inventory.items.get(i); } } } system.out.println(valueableitem.getname()); } public static void transferarmor(inventory<? super armor> destination, inventory<armor> source){ for (int i = 0; i< source.items.size(); i++){ destination.additem(source.items.get(i)); } } } public class weapon implements item { private string name; int value; int damage; public weapon(string name, int value, int damage){ this.name = name; this.value = value; this.damage = damage; } @override public string getname() { return name; } @override public int getvalue() { return value; } public int getdamage() { return damage; } } public interface item { public string getname(); public int getvalue(); } public class armor implements item { string name; int value; int defense; public armor(string name, int value, int defense){ this.name = name; this.value = value; this.defense = defense; } public string getname() { return name; } @override public int getvalue() { return value; } } public class potion implements item { string name; int value; string effect; public potion(string name, int value, string effect){ this.name = name; this.value = value; this.effect = effect; } public string getname() { return name; } @override public int getvalue() { return value; } } public class driver { public static void main(string[] args) { inventory<weapon> silahenvanter = new inventory<weapon>(); silahenvanter.additem(new weapon(""excalibur"", 1000, 100)); silahenvanter.additem(new weapon(""caliburn"", 999999, 200)); silahenvanter.additem(new weapon(""some sword"", 80, 10)); inventory<potion> potenvanter = new inventory<potion>(); potenvanter.additem(new potion(""leziz iksir"", 100, ""leziz"")); potenvanter.additem(new potion(""ekşi iksir"", 5, ""çok ekşi"")); inventory<armor> zirhenvanter1 = new inventory<armor>(); inventory<armor> zirhenvanter2 = new inventory<armor>(); zirhenvanter1.additem(new armor(""güçlü zırh"", 100, 100)); zirhenvanter2.additem(new armor(""zayıf zırh"", 10, 10)); inventory.transferarmor(zirhenvanter2, zirhenvanter1); inventory.printmostvaluableitem(silahenvanter); silahenvanter.sortbyvalue(); silahenvanter.printinventory(); zirhenvanter2.printinventory(); } } ""recursion"" kavramı nedir, kısaca açıklayınız. kendini çağıran metod tekniği. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case ve tekrar eden case. jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. normal metod gibi çağırıyor? hangi açıdan anlamadım. int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. i̇teratif yöntemin recursive yöntemden çoğu durumda daha verimli olduğu bilgisinden yola çıkarak iteratif derim. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? ?? stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack jvm hafızasında ayrılan bir bölüm. hafıza aşılırsa overflow olur. bir recursion metodunun base case'inin düzgün çalışmaması sebep olabilir. tail recursion nedir, kısaca açıklayınız. recursive case'in sonda olduğu recursion türü. abstraction kavramını açıklayınız. yazacağımız kod için gerekli olan kavramları, kontekste bağlı değişen kavramlardan ayrıştırmak. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür, eğer hourlyemployee bunun alt sınıfı ise. tersi mümkün değil. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier daha yakın. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? çünkü hepsi constructor ile bir instance üretmek için object sınıfına refer ediyor. biz yazmazsak da jvm otomatik hallediyor. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır. her class sadece bir class'ı extend edebilir. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? instanceof operatörü soldaki ifadenin sağdakinin bir instance'ı (aynı sınıf ve objesi, veya alt sınıflardan biri veya onlardan birinin objesi) mı diye bakar. a b'den derive edilen herhangi bir şey olabilir. metot overriding ve overloading kavramlarını açıklayınız. overriding var olan başka bir metod ile aynı signature ile bir metod yazmaktır, böylece metod alt sınıflarda farklı davranabilir (polymorphism). overloading ise aynı isimde ancak imzaları farklı olan birden fazla metod yazılmasıdır. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? base class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? dynamic binding instance metodları için yapılır, static binding ise diğerleri için. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? objeden bağımsız çalışmaları. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? dynamic binding. dinamik bağlamada jvm'nin görevi nedir? metod call'ının hangi metod bloğunu çağırdığını anlamak. java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? is-a mantığından ötürü. hayvan bir canlıdır ama her canlı hayvan değildir. bundan ötürü implicit şekilde upcast yapmamıza java izin verir. ama tersi söz konusu olmadığı için implicit şekilde yapamayız. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik bağlama. class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik bağlama. java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class'ların metodları tanımlanmak zorunda değil, bu işi onu extend eden class'lara bırakabilir. constructor'ları olur ama bu super'i çağırsın diye, o class'dan obje üretemeyiz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? başına default keyword'ü koyarak default bir mekanizma implement edilebilir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. metodun oluşturulmasını erteleyebilmemizi veya başka birine bırakabilmemizi sağlar. inherit eden class'larda polymorphism olmasını sağlar/gerektirir. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract class'larda her metod abstract olacak diye bir kural yok, ancak interface'lerin içeriği %100 abstract'tir. tip olarak kullanamayız. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface bir sıfat gibi işler, bir class'a o sıfatı atfetmemizi sağlar. i̇çi boş bir interface tanımından ibarettir. functional interface ne bilmiyorum. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? i̇kisi de mümkün. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? shape'den obje üretemeyiz, çünkü abstract class. circle'dan üretirsek alacağımız sonuç: drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? compile edilemez, belirsizlik var. implement ettiğimiz bağımsız iki interface'de aynı signature'e sahip iki metod var. super.show() yerine örneğin eğer a interface'indekini kullanmak istiyorsak a.show() diyebiliriz, bu durumda output a olur. java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. runtime ve java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? override eden metodun override ettiği metod'a göre ya eşit, ya da daha dar bir throwable kapsamına sahip olması, veya direkt throws ifadesinin kaldırılması gerekir. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally bloğu her daim işletilen bir kod bloğudur. catch'e girilirse de girilmezse de çalışır. catch'in içinde return edilir ve bloktan çıkılırsa da çalışır. java'da kendi exceptionunuzu nasıl tanımlarsınız? exception sınıfını extend ederek yeni bir exception sınıfı oluşturarak. bunun içinde exception'un bakacağı kondisyonları ve hangi durumda exception fırlatacağını if case'leri ile kontrol edebiliriz. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caughtfinallyoopsdone41 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? unreachable code mevcut. exception bloklarından biri silinmeli. text file ile binary file arasındaki fark nedir? text dosyaları kullanılan text encoding türüne göre karakterleri depolar, yazılan her şey bir karakterdir. binary file'larda her şey kendi tipinde en primitive şekilde saklanır. bir dosyaya yazarken düzenli olarak flush yapmamak neye yol açabilir? resource'larımızın boşa harcanmasına. binary bir dosyaya bir object yazdırırken bu objenin hangi interfaceyi implement etmesi gerekiyor? bu interfacenin metotlarını sıralayınız. bu interface functional veya marker bir interface midir? bir şey-able. unuttum kelimeyi. marker interface görevi görüyor, yazdırılabilen objelere vermek istediğimiz bir işaretçi,çünkü sadece bu objeler yazdırılabilir. binary bir dosyaya primitive typeler (int, float, char etc.) yazılabilir mi, evet ise nasıl? evet. örneğin randomaccessfile class'ının write metodları ile. buffered reader ve scanner sınıfları ile dosya okurken dosyanın sonuna geldiğini nasıl kontrol edilir? isnext() metoduyla. binary bir dosya okurken dosyanın sonuna gelindiği nasıl test edilir? dosya length'ine ulaşıp ulaşmamamız ile. public class randomaccessdemo { public static void main(string[] args) throws exception { _______ f = new _______(""numbers.bin"", ""____""); f.writeint(10); f.writeint(20); int a = f.readint(); f.seek(_____________); int b = f.readint(); system.out.println(a + b); f.close(); } } boşluklara sırasıyla ne gelmelidir? output? randomaccessfile, randomaccessfile, rw, 5 gelmelidir. output ""30"". public class demo { public static void main(string[] args) throws exception { fileoutputstream fos = new fileoutputstream(""log.txt"", true); ______________ pw = new ______________(fos); pw.println(""new log entry""); pw.close(); } } boşluklara sırasıyla ne gelmelidir? bu kod çalıştırıldığında log.txt dosyası nasıl etkilenir? printwriter gelmelidir. log.txt'nin sonuna ""new long entry"" ve new line eklenir. what grade (a, b, c, d, or f) do you expect to earn by the end of this course? cc java'da generic kavramı nedir, bu kavramın temel amacı nedir? generic'ler bir nevi bir değişkendir, farklı sınıflara göre istediğimiz sınıf veya metoda farklı behaviour'lar tanımlamamızı sağlar. upper bound ve lower bound wildcardları nasıl ifade edersiniz? upper ve lower boundun kullanılacağı durumlara birer tane örnek veriniz. upperbound için extends, lowerbound için super keyword'ü kullanılır. amaç generic olarak alabildiğimiz sınıfları sınırlamak. örneğin animal almak istiyorum ama bird ve alt sınıfları olamaz. generic bir classın constructorunda type parametresi bulunur mu, neden? bulunmaz. type zaten compile sırasında belirlenir. mygenericclass<a> ve mygenericclass<object> classları arasında kalıtım (child-parent) ilişkisi nasıldır, açıklayınız. mygenericclass<object> sınıfı orijinal sınıfın metod ve attribute'larının object için çalışan compile edilmiş hallerini inherit eder. class node<t>{ t[] data = new t[10]; } //psvm node<string> stringnode = new node<>(); bu kodda bir hata var mı? (varsa) bu hata nedir, nedenini açıklayınız. (varsa) bu hata nasıl düzeltilmeli, kodun doğru halini yazınız. herhangi bir hata yok. swapheadandtail metodu aşağıda tanımı verilmiş node classının birbirlerine bağlanmış nodelerinden ilkini alan ve baştaki node ile sondaki node'yi değiştiren metottur. örnek: başlangıçta: a -> b -> c metodu a ile çağırdığıktan sonra: c -> b -> a ayrıca metot en başa gelen nodeyi dönmelidir (bu örnekte c dönmeli). class node{ int data; node next; } static node swapheadandtail(node head) { node a = head; node b = head.next; node c = head; node d = null; while (____ != null) { d = c; c = c.next; } c.next = ____; d.next = ____; a.next = ____; return ____; } buna göre boşluklara neler gelmelidir? c.next, head, gerisini bilmiyorum. public _________ { public void sırala(list<t> liste) { // sıralama algoritmanız } } yaptığınız uzun çalışmalar sonucu yeni bir sıralama algoritması buldunuz. bunu implement etmek için bir class yazmalısınız. bu classın declarationunu nasıl yapardınız neden, boşluğu buna göre doldurun. ""class newalgorithm extends list<t>"" map ve set veri yapılarını kıyaslayınız, aralarındaki farkları açıklayınız. set her elemandan bir tane bulunan, yani unique olduğu bir liste türüdür, map ise anahtar değerler kullanılarak birbirlerine bağlı verilerden birine ulaşmamızı sağlayan bir veri yapısıdır. collections interfacesindeki metotlar temel olarak hangi işlevleri yerine getiriyor? elemanlarla alakalı işlevler, ekleme, çıkarma, yer değiştirme, boyutunu alma, içinde belli bir eleman var mı kontrol etme vb. i̇ki objenin equals metodu true dönüyorsa bu iki objenin hash codeleri aynıdır, bunun nedenini açıklayınız; eğer bu sağlanmazsa hangi veri yapıları istenilen şekilde sağlanır? kendi yazdığınız classlarda bunu sağlamak için hangi metotları override etmelisiniz, neden? bir öğrenci kulübü, yılsonu etkinliği için sınırlı kontenjana sahip bir kayıt sistemi oluşturuyor. sistem, öğrenci kayıtlarını ""ilk gelen ilk hizmet alır"" prensibiyle yönetiyor. ancak, bazı öğrenciler kaydını iptal edebiliyor ve boş kalan yerler otomatik olarak sıradaki öğrenciye veriliyor. bu senaryoda, kayıt sırasını ve iptal durumlarını etkin bir şekilde yönetebilmek için hangi veri yapısını tercih edersiniz? neden? fark etmez. fifo nedir, açıklayınız ve aşağıdakı veri yapılarını fifo/lifo şeklinde sınıflandırınız: stack queue map priorityqueue stack ve map lifo, queue ve priority queue lifo. public class main { public static void main(string[] args) { map<string, integer> scores = new hashmap<>(); scores.put(""alice"", 95); scores.put(""bob"", 80); scores.put(""alice"", 100); set<string> keys = scores.keyset(); int sum = 0; for (string key : keys) { sum += scores.get(key); } system.out.println(""number of entries: "" + scores.size()); system.out.println(""sum of scores: "" + sum); } } output? number of entries: 3 sum of scores: 275 public class main { public static void main(string[] args) { list<string> list = new arraylist<>(); list.add(""apple""); list.add(""banana""); list.add(1, ""cherry""); list.remove(""banana""); list.add(""apple""); system.out.println(list.size()); system.out.println(list.indexof(""apple"") + "" "" + list.lastindexof(""apple"")); } } output? 0 2 ara sınavdan yaklaşık hangi notu bekliyorsun (0-100)? 60 java gui'leri bağlamında olay güdümlü (event driven) programlamayı tanımlayın. olay güdümlü programlama, kullanıcının verdiği input'lara bağlı olarak karşılaşılabilecek farklı durumların programcı tarafından tasarladığı programlama şeklidir. kullanıcıdan alınan inputa göre tetiklenen olaylar ile çalışır. geleneksel sıralı programlama ile olay güdümlü (event driven) programlama arasındaki temel fark nedir? sıralı programlamada aşama aşama ne olacağı bilinirken, olay güdümlü programlamada bilgisayarın gerçekleştireceği işlemler kullanıcının input'una bağlı değişir. borderlayout yöneticisi, bir konteynerdeki bileşenleri nasıl düzenler? konteynerdaki bölümleri farklı yönlere göre ""border""lara (adı üzerinde) böler. java gui uygulamalarında jpanel'in amacı nedir? frame üzerinde bir panel oluşturabilmek, bu panele ne koyacağımız bize kalmış. temelde container ile beraber frame'i parçalara ayırırken kullandığımız bir eleman. java'daki gui programları neden tipik olarak sonsuz bir olay döngüsü çalıştırır ve bu durum sistem veya uygulama tarafından tetiklenen yeniden çizim (repaint) olaylarıyla nasıl ilişkilidir? programların kullanıcıdan kapatılmaya dair bir input alıncaya dek açık kalması ve çalışması gerektiğinden. bunun repaint ile olan ilişkisi, bu loop'da program içerisinde gerçekleşen değişikliklerin program repaint edilmediği sürece kullanıcı tarafından görülememesi. bu yüzden programın düzenli aralıklarla repaint edilmesi gerekir. bir swing uygulamasında repaint() metodunu çağırmanın etkisi nedir? program görüntüsü tekrardan çizilir ve programda yaşanan değişiklikler ekrana yansır. aşağıdaki kodun çalışmasını izleyin ve düğmeye tıklandığında ne olduğunu belirleyin: public class simplegui extends jframe implements actionlistener { public simplegui() { setsize(200, 100); setdefaultcloseoperation(jframe.exit_on_close); jbutton button = new jbutton(""click me""); button.addactionlistener(this); add(button); setvisible(true); } public void actionperformed(actionevent e) { joptionpane.showmessagedialog(this, ""button was clicked!""); system.exit(0); } public static void main(string[] args) { new simplegui(); } } ""button was clicked!"" mesajını gösterir ve sistem kapatılır. aşağıdaki kod parçasını inceleyin: import javax.swing.*; import java.awt.*; public class layoutexample { public static void main(string[] args) { jframe frame = new jframe(""layout test""); frame.setsize(400, 300); frame.setdefaultcloseoperation(jframe.exit_on_close); frame.setlayout(new borderlayout()); frame.add(new jlabel(""n""), borderlayout.north); frame.add(new jbutton(""s""), borderlayout.south); frame.add(new jpanel(), borderlayout.center); frame.setvisible(true); } } bu program çalıştığında bileşenlerin nasıl düzenlendiğini açıklayın. n yazan jlabel ekranın orta üstüne, s yazan jbutton ekranın orta altına, ekranın ortasında ise boş bir jpanel yerleştirilir. thread oluşturmanın 2 temel yöntemi nedir? thread oluştururken lambda notasyonunun kullanılabilmesi ne sağlar? runnable'ı implement etmek veya thread sınıfını extend etmek. thread'in gerçekleştireceği fonksiyonun kolay şekilde ifade edilmesini. data race problemi nedir, neden kaynaklanır? nasıl önüne geçilir? thread'lerden hangisinin bir veriye diğerlerinden önce erişip, okuyup, değiştireceğinin bilinememesi. senkronizasyon ile çözülür. dead lock problemi nedir, neden kaynaklanır; bunun önüne geçebilmek için ne yapılabilir? bir thread'in a kilidini alıp b kilidini beklemesi, diğer thread'in b kilidini alıp a kilidini beklemesi. reentrant lock kullanılabilir. bir threadi başlatmak için neden run metodu çağırılmamalı, açıklayınız. peki hangi metot çağrılmalıdır? run metodu çağrılırsa main thread veya çağrıldığı thread'de, herhangi bir metod gibi execute edilir. start metodu çağrılmalıdır. bir thread başka bir thread tarafından nasıl doğru bir şekilde sonlandırılabilir? diğer thread içinde o thread'in stop metodu çağrılır. java'da kaç çeşit thread vardır, farkları açıklayınız. daemon ve normal thread, daemon thread'leri programın çalışması boyunca açık kalır. public class bankaccount { private double balance; public void deposit(double amount) { balance = balance + amount; ; } public void withdraw(double amount) balance = balance - amount ; } public static void main(string[] args) { bankaccount account = new bankaccount(); thread t1 = new thread(() -> { for (int i = 0; i < 3; i++) { account.deposit(100); } }); thread t2 = new thread(() -> { for (int i = 0; i < 2; i++) { account.withdraw(100); } }); t1.start(); t2.start(); } } bu kodda bir problem var mı? varsa bu problemi nasıl çözersiniz? (varsa) problemi çözdükten sonra program çalıştığında balance'nin son değeri ne olur? thread'ler senkronize değil. race problemi yaşanır. çözmek için withdraw ve deposit metodlarını synchronized yapabiliriz. son değer 100 olur. class threadvisibility { private static boolean flag = false; private static int value = 0; public static void main(string[] args) throws interruptedexception { thread t1 = new thread(() -> { string name = thread.currentthread().getname(); system.out.println(""started""); while (!flag) { try { thread.sleep(100); } catch (interruptedexception e) { e.printstacktrace(); } } system.out.println(name + value); }); t1.setname(""t2""); t1.start(); thread.sleep(1000); // give t1 time to start value = 11; synchronized (threadvisibility.class) { flag = true; } } } output? started t211 bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true import java.util.arraylist; class robot { private string name; private string type; private int batterylevel; // 100 ile 0 arasında bir değer private boolean isoperational; // bataryası varsa true public string getname(){ return new string(name); } public void setname(string s){ name = s; } public string gettype(){ return new string(type); } public void settype(string s){ type = s; } public int getbatterylevel(){ return batterylevel; } public void setbatterylevel(int i){ if (i <= 100 && i >= 0){ batterylevel = i; if (i > 0) isoperational = true; else isoperational = false; } else system.out.println(""that's an invalid amount.""); } public boolean getisoperational(){ return isoperational; } // yazdım ama pek anlamlı bir metod değil, 100'ken niye false'a çekebileyim örneğin // public void setisoperational(boolean bool){ // isoperational = bool; //} public void charge(){ batterylevel = 100; isoperational = true; } public robot(){ name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } public robot(string name, string type, int batterylevel){ this.name = name; this.type = type; if (batterylevel <= 100 && batterylevel >= 0) this.batterylevel = batterylevel; else { system.out.println(""that's an invalid number for the battery level. it will be set to 100%.""); this.batterylevel = 100; } if (batterylevel > 0) isoperational = true; else isoperational = false; } public void printrobot(){ system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + ""%"" + "" is operational: "" + isoperational); } } class factory { private string name; private string location; private arraylist<robot> robots; public string getname(){ return new string(name); } public void setname(string s){ name = s; } public string getlocation(){ return new string(location); } public void setlocation(string s){ location = s; } public void addrobot(robot robot){ robots.add(robot); } public void chargeallrobots(){ for (int i = 0; i < robots.size(); i++) { robots.get(i).charge(); } } public factory(string name, string location){ this.name = name; this.location = location; robots = new arraylist<>(); } public factory(){ name = ""factory1""; location = ""moon""; robots = new arraylist<>(); } public void printfactory(){ for (int i = 0; i < robots.size(); i++) { robots.get(i).printrobot(); } } public void work(){ for (int i = 0; i < robots.size(); i++){ int current = robots.get(i).getbatterylevel(); if (current >= 15) current -= 15; else current = 0; robots.get(i).setbatterylevel(current); } } } public class robottest { public static void main(string[] args){ factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 24); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } public class casecombo { public static void main(string[] args){ string s = ""a1b2c3d4""; casecombo(s, 0); } public static void casecombo(string s, int i){ if (i == 0){ system.out.println(s); } // string'i alalım. index'deki harf mi diye bakalım. harfse bir büyük yapalım bir küçük yapalım ve ekrana yazdıralım. // sonra index'i bir arttırarak metodu tekrar çağıralım. index == length olunca sadece yazdırsın. if (i == s.length() - 1){ if ((int) s.charat(i) >= 65 && s.charat(i) <= 90){ s = s.substring(0, i) + (char)(s.charat(i) + 32) + s.substring(i + 1, s.length()); system.out.println(s); } else if ((int) s.charat(i) >= 97 && s.charat(i) <= 122){ s = s.substring(0, i) + (char)(s.charat(i) - 32) + s.substring(i + 1, s.length()); system.out.println(s); } } else { if ((int) s.charat(i) >= 65 && s.charat(i) <= 90){ casecombo(s, i + 1); s = s.substring(0, i) + (char)(s.charat(i) + 32) + s.substring(i + 1, s.length()); system.out.println(s); casecombo(s, i + 1); } else if ((int) s.charat(i) >= 97 && s.charat(i) <= 122){ casecombo(s, i + 1); s = s.substring(0, i) + (char)(s.charat(i) - 32) + s.substring(i + 1, s.length()); system.out.println(s); casecombo(s, i + 1); } else { casecombo(s, i + 1); } } return; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 package robotfactory; public interface withbattery { int getbatterylife(); void recharge(); } package robotfactory; public abstract class abstractrobot implements withbattery { public abstractrobot(){} protected string modelname; protected int batterylife; protected int maximumbattery; public abstractrobot(string modelname, int batterylife){ this.modelname = modelname; this.batterylife = batterylife; this.maximumbattery = batterylife; } public string getmodelname(){ return new string(modelname); } public abstract void performtask(); public int getbatterylife() { return batterylife; } public void recharge() { batterylife = maximumbattery; } } package robotfactory; public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.totalrobotcount(); } } package robotfactory; public class securityrobot extends abstractrobot { private boolean isarmed; public boolean getisarmed(){ return isarmed; } securityrobot(string modelname, int batterylife, boolean isarmed) { this.modelname = modelname; this.batterylife = batterylife; this.isarmed = isarmed; } public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] "" + ""scanning for threats... armed: "" + isarmed); batterylife-=10; } else { system.out.println(""["" + modelname + ""] "" + ""not enough battery to scan threats...""); } } public void togglearmedmode(){ isarmed = !isarmed; } } package robotfactory; public class cleaningrobot extends abstractrobot { private int cleaningpower; public int getcleaningpower(){ return cleaningpower; } public void performtask(){ if (batterylife >= 10) { system.out.println(""["" + modelname + ""] "" + ""cleaning in progress... cleaning power: "" + cleaningpower); batterylife-=10; } else { system.out.println(""["" + modelname + ""] "" + ""not enough battery to clean...""); } } public void boostcleaningpower(int miktar){ cleaningpower+=miktar; } cleaningrobot(string modelname, int batterylife, int cleaningpower) { this.modelname = modelname; this.batterylife = batterylife; this.cleaningpower = cleaningpower; } } package robotfactory; import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); private static int total; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); total++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ robots.add(new securityrobot(modelname, batterylife, isarmed)); total++; } public void performalltasks() { for (abstractrobot robot : robots){ robot.performtask(); } } public void displayrobots() { for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot){ cleaningrobot temp = (cleaningrobot) robot; system.out.println(""cleaningrobot - model: "" + temp.getmodelname() + "", battery: "" + temp.getbatterylife() + "", cleaning power: "" + temp.getcleaningpower()); } else if (robot instanceof securityrobot){ securityrobot temp = (securityrobot) robot; system.out.println(""cleaningrobot - model: "" + temp.getmodelname() + "", battery: "" + temp.getbatterylife() + "", armed: "" + temp.getisarmed()); } } } public void upgradecleaningrobots(int miktar) { for (abstractrobot robot : robots){ if (robot instanceof cleaningrobot) { cleaningrobot temp = (cleaningrobot) robot; temp.boostcleaningpower(miktar); robot = temp; system.out.println(""cleaningrobot - "" + temp.getmodelname() + "" now has cleaning power: "" + temp.getcleaningpower()); } } } public void togglesecurityrobotsmode() { for (abstractrobot robot : robots){ if (robot instanceof securityrobot) { securityrobot temp = (securityrobot) robot; temp.togglearmedmode(); robot = temp; if (temp.getisarmed()) system.out.println(""securityrobot - "" + temp.getmodelname() + "" is now armed""); else system.out.println(""securityrobot - "" + temp.getmodelname() + "" is now unarmed""); } } } public static void totalrobotcount() { system.out.println(""tum fabrikalar tarafindan toplam "" + total + "" robot uretildi""); } } envanter takip sistemi bil 211 - quiz 3 27 şubat 2025 1 giriş bu quizde, fileioveexceptions kullanarak basit bir envanter takip sistemi uygulaması geliştireceğiz. uygulama, interaktif bir terminal menüsü üzerinden, tek bir eşyanın ve stoğunun tutulduğu kayıtların yönetilmesini (eşya ekleme, çıkarma ve stok güncelleme) sağlayacaktır. ayrıca, envanter verileri sabit isimli bir dosyaya kaydedilebilecek ve bu dosyadan geri yüklenebilecektir. 2 genel program program konsol tabanlı bir kullanıcı arayüzü ile envanter takibi gerçekleştirmelidir. arayüz özellikleri aşağı- daki gibidir. -terminal menüsü: kullanıcıya aşağıdaki seçenekleri sunacaktır: – eşya ekleme: yeni bir eşya kaydı oluşturulur. her kayıt, eşya adı ve başlangıç stoğu bilgilerini içerir. eğer çoktan var olan bir eşya eklenmeye çalışılırsa program otomatik olarak önceki kaydın stoğunu güncellemelidir (yani aynı isimde iki kayıt oluşmamalı). – eşya çıkarma: mevcut envanterden istenilen eşya silinir. – stok güncelleme: kayıtlı bir eşyanın stoğu artırılabilir ya da azaltılabilir. i̇şlem sonucunda stok miktarı negatif olmamalıdır. – envanter listeleme: mevcut envanter kayıtları ekrana listelenir. – dosyaya kaydetme: güncel envanter verileri sabit isimli dosyaya kaydedilir. – dosyadan geri yükleme: daha önce kaydedilmiş envanter verileri dosyadan okunarak geri yüklenir. – çıkış: program sonlandırılır. 3envanterkaydi sınıfı değişkenler: -isim(private string) eşyanın adını tutar. -stok(private int) eşyanın stok miktarını tutar. metotlar: -public envanterkaydi(string isim, int stok) constructor; eşya adı ve stok miktarını başlatır. -public void stokguncelle(int miktar) stok miktarını günceller; negatif sonuç oluşmaması kontrol edilmelidir. - stokguncelle dışında ihtiyacınıza göre private değişkenler için getter ve setter tanımlayabilirsiniz. 4 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları (örn., bufferedreader , scanner,printwriter ) kullanacaktır. dosya işlemleri sırasında aşağıdaki hata durumları için uygun mesajlar verilmelidir: - dosya bulunamazsa: ""hata: envanter dosyası bulunamadı."" - dosya boşsa: ""hata: envanter dosyası boş."" 1 5 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program, hata kodu ile sonlanmalı ve ilgili hata mesajları stderr’e yazdırılmalıdır. 5.1 girdi hataları (inputexception class) dosya işlemleriyle ilgili hatalar için kendi tanımlayacağınız inputexception sınıfından türeyen özel hata sınıfları oluşturulacaktır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: envanter dosyası bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: envanter dosyası boş."" 5.2 envanter i̇şlemleri hataları envanter işlemleri sırasında oluşabilecek hatalar için aşağıdaki özel hata türleri tanımlanacaktır: -stoknegatifexception (extends exception) : stok güncelleme işlemi sonucunda, eşyanın stoğu negatif bir değere düşerse atılacak hata. - hata mesajı: ""hata: stok miktarı negatif olamaz."" -esyayokexception (extends exception) : çıkarma veya güncelleme işlemi yapılmak istenen eşya envanterde bulunmuyorsa atılacak hata. - hata mesajı: ""hata: i̇stenen eşya envanterde mevcut değil."" -ozellikhatasiexception (extends exception) : eşya ekleme sırasında girilen bilgilerde hata veya eksiklik varsa atılacak hata. - hata mesajı: ""hata: eşya bilgileri hatalı veya eksik."" 6 gönderim formatı - quizinizi bitirdiğinizde asistanlarınızdan birisine kodunuzu ve çıktısını gösterip puanlatın. - asistan labınızı puanladığında tüm kaynak dosyalarını ve bu dökümantasyonu bir arşiv dosyası (zip, rar, 7z, tar, tar.gz) halinde sıkıştırın. - arşiv dosyasının isim_numara formatında isimlendirin (örn., sebnemferah_181101014.zip). - i̇simlendirdiğiniz arşiv dosyasını uzak sistemindeki quiz alanına yükleyin. 2 package envanter; import java.util.scanner; import java.util.arraylist; import java.io.objectoutputstream; import java.io.fileinputstream; import java.io.filenotfoundexception; import java.io.fileoutputstream; import java.io.inputstream; import java.io.objectinputstream; public class main { public static void main(string[] args) throws exception { scanner userinput = new scanner(system.in); arraylist<envanterkaydi> esyalar = new arraylist<>(); while(true) { system.out.println(""envanter takip sistemine hoş geldiniz. ne yapmak istersiniz?""); system.out.println(""1-) eşya ekleme 2-) eşya çıkarma 3-) stok güncelleme 4-)envanter listeleme 5-) dosyaya kaydetme 6-) dosyadan geri yükleme 7-) çıkış""); int answer = userinput.nextint(); if (answer == 7){ break; } else if (answer == 1) { system.out.println(""eklemek istediğiniz eşyanın adı nedir?""); string itemname = userinput.next(); system.out.println(""eşyanın stok miktarı?""); int stockamount = 0; try { stockamount = userinput.nextint(); } catch (exception e) { throw new ozellikhatasiexception(""hata: eşya bilgileri hatalı veya eksik.""); } if (doesexist(itemname, esyalar) == -1) { esyalar.add(new envanterkaydi(itemname, stockamount)); system.out.println(""eşyanız envantere eklenmiştir.""); system.out.println(); } else { esyalar.get(doesexist(itemname, esyalar)).stokguncelle(stockamount); system.out.println(""eşyanız zaten var olduğu için stok sayısı güncellenmiştir.""); system.out.println(); } } else if (answer == 2) { system.out.println(""eşyanızın adı nedir?""); string itemname = userinput.next(); if (doesexist(itemname, esyalar) == -1) throw new esyayokexception(""hata: i̇stenen eşya envanterde mevcut değil.""); else { esyalar.remove(doesexist(itemname, esyalar)); system.out.println(""eşya silinmiştir.""); system.out.println(); } } else if (answer == 3) { system.out.println(""stok miktarını güncellemek istediğiniz eşyanın adını girin.""); string itemname = userinput.next(); if (doesexist(itemname, esyalar) == -1) throw new esyayokexception(""hata: i̇stenen eşya envanterde mevcut değil.""); else { system.out.println(""miktarı girin.""); int stockamount = userinput.nextint(); if (stockamount < 0) throw new stoknegatifexception(""hata: stok miktarı negatif olamaz.""); else { esyalar.get(doesexist(itemname, esyalar)).stokguncelle(stockamount); system.out.println(""stok miktarı güncellenmiştir.""); system.out.println(); } } } else if (answer == 4) { for (int i = 0; i < esyalar.size(); i++) { system.out.println(""i̇sim: "" + esyalar.get(i).getisim() + "" stok: "" + esyalar.get(i).getstok()); } system.out.println(); } else if (answer == 5) { objectoutputstream output = new objectoutputstream(new fileoutputstream(""envanter.bin"")); output.writeobject(esyalar); system.out.println(""envanter bilgileri kaydedildi.""); system.out.println(); output.close(); } else if (answer == 6) { boolean isempty = false; try { objectinputstream input = new objectinputstream(new fileinputstream(""envanter.bin"")); object aaa = input.readobject(); esyalar = (arraylist<envanterkaydi>) aaa; system.out.println(); input.close(); } catch (exception e) { throw new dosyabulunamadiexception(""hata: envanter dosyası bulunamadı.""); } if (esyalar.isempty()) isempty = true; else isempty = false; if (isempty) { throw new bosdosyaexception(""hata: envanter dosyası boş.""); } system.out.println(""envanter yüklenildi.""); } } userinput.close(); } public static int doesexist(string itemname, arraylist<envanterkaydi> esyalar) { for (int i = 0; i < esyalar.size(); i++) { if (esyalar.get(i).getisim().equals(itemname)) return i; } return -1; } } package envanter; public class esyayokexception extends exception { string message; esyayokexception(string message){ super(message); } } package envanter; public class ozellikhatasiexception extends exception { string message; ozellikhatasiexception(string message){ super(message); } } package envanter; import java.io.serializable; public class envanterkaydi implements serializable { private string isim; private int stok; public envanterkaydi(string isim, int stok){ this.isim = isim; this.stok = stok; } public void stokguncelle(int miktar){ stok = miktar; } public string getisim() { return new string(isim); } public int getstok() { return stok; } } package envanter; public class bosdosyaexception extends inputexception { string message; bosdosyaexception(string message){ super(message); } } package envanter; public class stoknegatifexception extends exception { string message; stoknegatifexception(string message){ super(message); } } package envanter; public class inputexception extends exception { string message; inputexception(string message) { super(message); } } package envanter; public class dosyabulunamadiexception extends inputexception { string message; dosyabulunamadiexception(string message){ super(message); } } bil211 quiz 4 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: undoablelist<t> adında bir sınıf oluşturun. bu sınıf, bir arraylist'i genişletmeli ve aşağıdaki ek özelliklere sahip olmalıdır: ● undolast() metodu, en son eklenen öğeyi kaldırmalıdır. ● getlastadded() → son eklenen öğeyi listeyi değiştirmeden döndürür. ● eğer liste boşsa, undolast() bir hata vermemeli, sadece hiçbir şey yapmamalıdır. örnek kullanım: undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] q2: aşağıdaki generic metodu tamamlayın. ● verilen bir collection<t> içinde minimum veya maksimum öğeyi bulan bir metod yazın. ● boolean parametresi true ise maksimumu, false ise minimumu döndürmelidir. ● t öğeleri comparable<t> arabirimini uygulamalıdır. public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { // metodu tamamlayın } örnek kullanım: list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) q3: belirli türdeki elemanları filtreleme ● bir collection<?> içindeki belirli bir türdeki öğeleri filtreleyen bir generic metod yazın. ● class<t> tür filtresi olarak kullanılmalıdır. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { // metodu tamamlayın } örnek kullanım: list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] import java.util.arrays; import java.util.collection; import java.util.iterator; import java.util.list; public class q2 { public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { // collection'un elemanları comparable olmalı. iterator<t> iterator = collection.iterator(); t result = iterator.next(); iterator<t> iterator2 = collection.iterator(); while (iterator2.hasnext()) { t next = iterator2.next(); if (next instanceof comparable<?>) { if (findmax) { if (next.compareto(result) > 0) { result = next; } } else { if (next.compareto(result) < 0) { result = next; } } } } return result; } public static void main(string[] args) { list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) } } import java.util.arraylist; import java.util.arrays; import java.util.collection; import java.util.list; import java.util.iterator; public class q3 { public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { iterator<?> iterator = collection.iterator(); list<t> result = new arraylist<>(); while (iterator.hasnext()) { t a = (t) iterator.next(); if (a.getclass().equals(type)) { result.add(a); } } return result; } public static void main(string[] args) { list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] } } import java.util.arraylist; public class undoablelist<t> extends arraylist<t> { private t lastadded; @override public boolean add(t e) { lastadded = e; return super.add(e); } public void undolast() { if (indexof(lastadded)!=-1) remove(lastadded); } public t getlastadded() { return lastadded; } public static void main(string[] args) { undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] } } 1 kuş bakışı atış oyunu (top-down shooter) bil 211 - proje teslim tarihi: 27 mart 2025 23:59 1 amaç bu ödevde amacınız, java swing kullanarak kuş bakışı bir atış oyunu (top-down shooter) tasarlamaktır. oyunda, yönettiğimiz karakterin üzerine dalga dalga gelen çeşitli zombileri fare ile hedef alarak farklı silahlar kullanıp öldürmemiz gerekmektedir. karakterimiz öldüğünde oyun sona erecektir. her dalga başına ve öldürülen zombi başına kazanılan puan artacaktır. dalgalar ilerledikçe gelen zombilerin sayısı ve çeşitleri artarak zorluk seviyesi yükselecektir. 2 gereksinimler oyun derste öğrendiğiniz oop ilkelerine uygun sınıf/arayüz tasarımları ile geliştirilmelidir. - zorluk seviyesi arttıkça zombi sayısı ve çeşitliliği artmalıdır. - oyun duraklatılabilmeli ve kaydedilip tekrar yüklenilebilmelidir (fileio kullanılmalıdır). - sol üst köşede seçili silah ve kalan mermi miktarı gösterilmelidir. - sağ üst köşede oyuncunun canı ve toplam puanı gösterilmelidir. - oyunun duraklatılması, kaydedilmesi ve devam ettirilmesi için bir menü bulunmalıdır. 3 silahlar oyunda farklı silahlar bulunmaktadır. belirli zombi dalgaları temizlendikten sonra oyun ödül olarak yeni bir silahverecektir. hersilahınkendineözgübirçalışmamekanizmasıvardır. silahlarınşarjörkapasitesisınırlıdır ve şarjördeki mermiler bittiğinde tekrar doldurulmadan ateş edilemez. toplam mermi sayısı oyuncunun o silaha ait elinde ne kadar mermi olduğunu gösterir. r tuşuna basarak şarjör yeniden doldurulabilir. 3.1 tabanca - şarjör kapasitesi: 12 mermi - ateş hızı: 120 mermi/dakika - elde etme: oyuncu oyuna bu silahla başlar. - özellik: düz atış yapar, sapma yoktur. sınırsız yedek şarjör (diğer tüm silahlar için yedek şarjör ve mermiler rastgele bir şekilde dalga sırasında ve sonlarında zombilerden düşer). 3.2 piyade tüfeği - şarjör kapasitesi: 30 mermi - ateş hızı: 600 mermi/dakika - elde etme: 1. dalga tamamlandıktan sonra - özellik: düzatışyaparancak30derecesapmasıvardır. sapmaaçısı, karakterinbaktığıyöndemerminin her iki dönme yönüne de saçılabileceği maksimum açıdır. 1 3.3 pompalı tüfek - şarjör kapasitesi: 5 mermi - ateş hızı: 60 mermi/dakika - elde etme: 3. dalga tamamlandıktan sonra - özellik: her atış 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi atar (yani karakter merkezli mermi hız vektörleri arasında 5 derece açı olmalıdır). 3.4 keskin nişancı tüfeği - şarjör kapasitesi: 5 mermi - ateş hızı: 30 mermi/dakika - elde etme: 5. dalga tamamlandıktan sonra - özellik: mermileri zombileri delip arasındaki zombilere de hasar verir. 3.5 roketatar - şarjör kapasitesi: 1 roket - ateş hızı: 10 roket/dakika - elde etme: 10. dalga tamamlandıktan sonra - özellik: patlama etkisiyle birden fazla zombiye zarar verir. 4 zombiler zombiler oyundaki düşman tipleridir. zombiler oyuncuya doğru ilerlerler ve eğer oyuncuya temas ederlerse oyuncuya hasar verirler. zorluk seviyesi arttıkça zombilerin sayısı ve çeşitliliği artmaktadır. zombi tipleri birbirinden renk ya da şekil olarak ayırt edilebilmelidir. 4.1 normal zombi - can: orta - hız: yavaş - hasar: orta 4.2 sürünge zombi - can: düşük - hız: hızlı - hasar: orta - özellik: oyuncunun yakınına geldiğinde zıplar. 4.3 tank zombi - can: yüksek - hız: çok yavaş - hasar: yüksek 2 4.4 asit tüküren zombi - can: düşük - hız: yavaş - hasar: orta (uzaktan asit tükürebilir) - özellik: öldürüldüğünde yanındaki birimlere zarar verir. 5 rapor ve teslim formatı - oyun, oopprensiplerineuygunolaraktasarlanmalıvesınıfdiyagramları, arayüztasarımıfinalraporda sunulmalıdır. - oyun test edilerek ekran görüntüleri rapora eklenmelidir. - rapor pdf formatında olmalı ve ismi proje_rapor.pdf olmalıdır. - oyunun mainfonksiyonu gameisimli bir sınıf içinde bulunmalıdır ( java game komutuyla çalışmalı). - kaynak kodun tamamı source.zip (uzantı 7z, rar, tar.gz de olabilir) şeklinde sıkıştırılmış olmalıdır. - sıkıştırılmış kaynak kod ve rapor uzak sistemine yüklenmelidir. 6 yardımcı kaynaklar dahaöncehiçkuşbakışıatışoyunuoynamadıysanızaşağıdakioyunlarıreferansolarakalabilirsiniz. buradaki oyunlarıngrafikleriilemekaniklerisizdenbeklenendenfarklıolsadaharitatasarımı, karakterhareketi,kamera hareketi, ateş etme mekanikleri ve zombilerin yapay zekası ile ilgili temel fikirler edinebilirsiniz. - little top-down shooter: https://www.youtube.com/watch?v=pj3m3fu3i5a - super c - stage 2: https://www.youtube.com/watch?v=os2t_v5suj4 - neon chrome: https://www.youtube.com/watch?v=puhw1bevtro 3 import gameclasses.gameframe; import gameclasses.gamemanager; import gameclasses.gamethread; import gamedata.scenes.*; public class game { public static void main(string[] args){ gamemanager.frame = new gameframe(); // i tried to reference gamemanager variables in class definitions bu that sometimes resulted in // passing references while they were still null, breaking the whole thing. so it seems that the best // approach is to only reference them only in methods, to have more control over what's going on. gameframe frame = gamemanager.frame; gamethread.setscene(new scenes1()); gamemanager.runthreads(); // this panel is the main game screen. everything is going to be printed on this. frame.add(gamemanager.panel); frame.setvisible(true); } } package gameclasses; import javax.swing.jpanel; import java.awt.color; import java.awt.graphics; import java.util.arraylist; import java.util.collections; import java.util.comparator; public class gamethread extends thread { // this is the screen that the graphics thread paints everything on. public class gamepanel extends jpanel { { setbackground(color.gray); } arraylist<gamenode> copynodes; public void paintcomponent(graphics g) { synchronized (gamemanager.gamenodes) { copynodes = new arraylist<gamenode>(gamemanager.gamenodes); } collections.sort(copynodes, comparator.comparingint(node -> node.drawlayer)); super.paintcomponent(g); if (gamemanager.cameraexists) { for (gamenode node : copynodes) { gamemanager.gamecam.render(g, node); } for (gamenode node : copynodes) { gamemanager.gamecam.guirender(g, node); } } } } // every setting the thread can work in. static public enum threadtype { process, physics, graphics, } // defined in setscene because you can't draw without a scene. threadtype threadtype = threadtype.process; { gamemanager.panel = new gamepanel(); } public gamethread(threadtype threadtype) { this.threadtype = threadtype; } public static void setscene(gamescene scene){ gamemanager.gamenodes = scene.nodelist(); } // updates the arraylist based on new node addition and removal calls during ends of the loops. public static void listupdate() { synchronized (gamemanager.gamenodes) { if (gamemanager.islocked()) { gamemanager.gamenodes.removeall(gamemanager.removenodes); gamemanager.gamenodes.addall(gamemanager.addnodes); gamemanager.gamenodes.trimtosize(); gamemanager.removenodes = new arraylist<gamenode>(); gamemanager.addnodes = new arraylist<gamenode>(); gamemanager.updatecall = false; } } } @override public void run() { long lasttime = system.nanotime(); final long fpsinnano = 16_640_000; while (true) { long currenttime = system.nanotime(); long deltatime = currenttime - lasttime; if (threadtype == threadtype.process) { for (gamenode node : gamemanager.gamenodes) { node.process(); } while (gamemanager.updatecall) { gamemanager.threadlock = true; listupdate(); } gamemanager.threadlock = false; } else if (threadtype == threadtype.physics) { if (deltatime >= fpsinnano) { for (gamenode node : gamemanager.gamenodes) { node.physicsprocess(); } lasttime = currenttime; if (gamemanager.threadlock) { gamemanager.physicslocked = true; while (gamemanager.threadlock); } gamemanager.physicslocked = false; } } else if (threadtype == threadtype.graphics) { if (deltatime >= fpsinnano) { gamemanager.panel.repaint(); if (gamemanager.threadlock) { gamemanager.graphicslocked = true; while (gamemanager.threadlock); } gamemanager.graphicslocked = false; } } else { try { sleep(1); } catch (exception e) { e.printstacktrace(); } } } } } package gameclasses; import java.awt.color; import javax.swing.jframe; public class gameframe extends jframe { public gameframe() { super(""tds game that sucks quite a lot""); setdefaultcloseoperation(jframe.exit_on_close); setsize(gamemanager.framewidth, gamemanager.frameheight); setbackground(color.gray); gameinput inputcontroller = new gameinput(); addkeylistener(inputcontroller); addmousemotionlistener(inputcontroller); addmouselistener(inputcontroller); } } package gameclasses; import java.util.arraylist; public abstract class gamescene { //this'll refer to another ""subscene"" when needed. which will allow you to use scenes as nodes. // you have to define scenenodes and childscenes in the constructor under classes you extend from this. public gamescene(){}; public arraylist<gamenode> childnodes = new arraylist<gamenode>(); // if it's a node, add it and its childnodes. // returns every node in the scene and the subscene in an array. public arraylist<gamenode> nodelist(){ arraylist<gamenode> nodelist = new arraylist<gamenode>(); for (gamenode node : childnodes) { if (node.childnodes.size()!= 0) { for (int i = 0; i < node.nodelist().size(); i++) { node.nodelist().get(i).parentnode = node; nodelist.add(node.nodelist().get(i)); } } node.parentnode = this; nodelist.add(node); } return nodelist; } } package gameclasses; import java.util.arraylist; import gameclasses.gamethread.gamepanel; import gameclasses.gamethread.threadtype; import gameclasses.defaultclass.camera2d; // a class that stores static references to pretty much everything needed. public class gamemanager { public static gameframe frame; // static value so that it can be used by the camera. public static gamepanel panel; // the size of the actual frame. public static int framewidth = 1280; public static int frameheight = 720; // used for camera rendering public static int virtualwidth = 1280; public static int virtualheight = 720; // finds the game camera. public static boolean cameraexists = false; public static camera2d gamecam; // debugging tool. public static boolean showshapes = false; public static boolean ispaused = false; public static int gamescore = 0; // game score. // this is all the nodes the game will work with. public static arraylist<gamenode> gamenodes = new arraylist<gamenode>(); public static arraylist<gamenode> addnodes = new arraylist<gamenode>(); public static arraylist<gamenode> removenodes = new arraylist<gamenode>(); public static boolean updatecall = false; // calls for an update. public static volatile boolean threadlock = false; // tries to lock the threads. // becomes true when the threads are locked. public static volatile boolean physicslocked = false; public static volatile boolean graphicslocked = false; private static boolean cameraexists() { boolean doesit = false; for (gamenode camnode : gamenodes) { if (camnode instanceof camera2d) { gamecam = (camera2d) camnode; doesit = true; } } return doesit; } public static synchronized boolean islocked() { if (physicslocked && graphicslocked) return true; else return false; } public static void updateadd(gamenode node) { addnodes.add(node); updatecall = true; } public static void updateremove(gamenode node) { removenodes.add(node); updatecall = true; } public static gamenode getnode(class<? extends gamenode> nodeclass) { for (gamenode node : gamenodes) { if (node.getclass().equals(nodeclass)) { return node; } } return null; } public static void runthreads() { gamethread processthread = new gamethread(threadtype.process); gamethread physicsthread = new gamethread(threadtype.physics); gamethread graphicsthread = new gamethread(threadtype.graphics); cameraexists = cameraexists(); processthread.start(); physicsthread.start(); graphicsthread.start(); } } package gameclasses; import java.awt.event.keyevent; import java.awt.event.keylistener; import java.awt.event.mousemotionlistener; import java.awt.geom.point2d; import java.awt.event.mouseevent; import java.awt.event.mouselistener; public class gameinput implements keylistener, mouselistener, mousemotionlistener { // basically you have to store the key bind, make a boolean for it and add it to the if cases below. // is it a little bothersome? kind of. do i care? no. i got like less than 2 weeks for this. public static int up = keyevent.vk_up; public static boolean isup = false; public static int down = keyevent.vk_down; public static boolean isdown = false; public static int left = keyevent.vk_left; public static boolean isleft = false; public static int right = keyevent.vk_right; public static boolean isright = false; public static int reload = keyevent.vk_r; public static boolean isreload = false; public static int pause = keyevent.vk_p; public static boolean ispause = false; public static int weaponswitch = keyevent.vk_t; public static boolean isweaponswitch = false; public static int fire = mouseevent.button1; public static boolean isfiring = false; public static int leftclick = mouseevent.button1; public static boolean isleftclick = false; public static boolean ismousemoved = false; public static point2d cursorposition = new point2d.double(0,0); @override public void keypressed(keyevent e) { int pressedkey = e.getkeycode(); if (pressedkey == up) { isup = true; } else if (pressedkey == down) { isdown = true; } else if (pressedkey == left) { isleft = true; } else if (pressedkey == right) { isright = true; } else if (pressedkey == reload) { isreload = true; } else if (pressedkey == pause) { ispause = true; } else if (pressedkey == weaponswitch) { isweaponswitch = true; } } @override public void keyreleased(keyevent e) { int releasedkey = e.getkeycode(); if (releasedkey == up) { isup = false; } else if (releasedkey == down) { isdown = false; } else if (releasedkey == left) { isleft = false; } else if (releasedkey == right) { isright = false; } else if (releasedkey == reload) { isreload = false; } else if (releasedkey == pause) { ispause = false; } else if (releasedkey == weaponswitch) { isweaponswitch = false; } } public static point2d getrelativemouse() { double relativex = getcursor().getx() - gamemanager.frame.getwidth()/2; double relativey = getcursor().gety() - gamemanager.frame.getheight()/2; return new point2d.double(relativex, relativey); } // this is to be able to use input booleans dynamically. currently used for creating direction vectors out // of booleans. public static boolean getbool(boolean gameinbool) { return gameinbool; } // didn't really need this. could be implemented when necessary. @override public void keytyped(keyevent e) {} // for getting mouse input. @override public void mousemoved(mouseevent e) { cursorposition = new point2d.double(e.getx(), e.gety()); } @override public void mousepressed(mouseevent e) { if (e.getbutton() == fire) { isfiring = true; } if (e.getbutton() == leftclick) { isleftclick = true; } } @override public void mousereleased(mouseevent e) { if (e.getbutton() == fire) { isfiring = false; } if (e.getbutton() == leftclick) { isleftclick = false; } } @override public void mouseclicked(mouseevent e) {} @override public void mouseentered(mouseevent e) {} @override public void mouseexited(mouseevent e) {} public static point2d getcursor() { return cursorposition; } @override public void mousedragged(mouseevent e) { cursorposition = new point2d.double(e.getx(), e.gety()); } } package gameclasses; import java.awt.geom.point2d; import java.util.arraylist; import gameclasses.defaultclass.area2d; import gameclasses.defaultclass.nodeanim; import java.lang.math; public abstract class gamenode extends gamescene { public point2d position = new point2d.double(0,0); // position on the game world. protected double scale = 1; // sprite scale. public boolean isvisible = true; public arraylist<nodeanim> anims = new arraylist<nodeanim>(); // if the node needs a visual representation. public int currentanim = 0; protected gamescene parentnode = null; public int drawlayer = 0; protected boolean guielement = false; // if this is set to be true, it'll be rendered on top, and independent from game position. // custom area2d class as collision. to set values, use the setshape method. protected area2d collisionshape = new area2d(this); protected area2d hitboxshape = new area2d(this); public gamenode() {}; // for spawning nodes at (0,0). public gamenode(double x, double y) { position.setlocation(x,y); } public gamenode(gamenode node) { parentnode = node; } // for dynamic access to these attributes. public double spritewidth() { if (anims.size() != 0 && anims.get(0) != null) return anims.get(0).frame(0).getwidth(); else return 0; } public double spriteheight() { if (anims.size() != 0 && anims.get(0) != null) return anims.get(0).frame(0).getheight(); else return 0; } public double getscale() { return scale; } // below here are generic methods that can be used by anything that inherits this class. public double movetoward(double target, double start, double amount) { double delta = target - start; if (math.abs(delta) <= amount || delta == 0) { return target; } double position = start + (math.signum(delta) * math.abs(amount)); return position; } public gamenode collidingwith() { for (gamenode node : gamemanager.gamenodes) { // skip self check if (!node.collexists() || !(node == this)) { if (collisionshape.areaintersecting(node.collisionshape)) { return node; } } } return null; } // this is for checking before spawning objects. it runs through addnodes. public gamenode ghostcollidingwith() { for (gamenode node : gamemanager.addnodes) { // skip self check if (!node.collexists() || !(node == this)) { if (collisionshape.areaintersecting(node.collisionshape)) { return node; } } } return null; } public gamenode collidingwith(class<? extends gamenode> class1) { for (gamenode node : gamemanager.gamenodes) { // skip self check if (!node.collexists() || !(node == this)) { if (node.getclass().equals(class1) && collisionshape.areaintersecting(node.collisionshape)) { return node; } } } return null; } public gamenode ishitting() { for (gamenode node : gamemanager.gamenodes) { if (!node.hitboxexists() || !(node == this)) { if (hitboxshape.areaintersecting(node.hitboxshape)) { return node; } } } return null; } // this is for specifically checking if it's getting hit by a certain class. public gamenode ishitting(class<? extends gamenode> class1) { for (gamenode node : gamemanager.gamenodes) { if (!node.hitboxexists() || !(node == this)) { if (hitboxshape.areaintersecting(node.hitboxshape) && node.getclass().equals(class1) && hitboxshape.areaintersecting(node.hitboxshape)) { return node; } } } return null; } public boolean collexists() { if (collisionshape != null && collisionshape.areashape != null) return true; else return false; } public area2d getcollision() { return collisionshape; } public boolean hitboxexists() { if (hitboxshape != null && hitboxshape.areashape != null) return true; else return false; } public area2d gethitbox() { return hitboxshape; } public synchronized void nodeadd(gamenode node) { gamemanager.updateadd(node); } public synchronized void nodedispose(gamenode node) { gamemanager.updateremove(node); } // this is where calculations unrelated to physics will be made. it runs as fast as possible. public void process() {} // this is where physics calculations that run in ticks will be handled. public void physicsprocess() {} } package gameclasses.defaultclass; import gameclasses.gamethread.gamepanel; import gameclasses.defaultclass.gui.guinode; import gameclasses.defaultclass.gui.textnode; import gameclasses.gamenode; import java.awt.graphics; import gameclasses.gamemanager; import java.lang.math; import java.awt.font; // this is a default node created from gamenode in order to process what's on the screen. // can also be used for process calculations just like the average node. public class camera2d extends gamenode { // position is inherited. // the inherited scale value is used as zoom. public camera2d() { super(); } public camera2d(double x, double y) { super(x, y); } public void render(graphics g, gamenode node) { gamepanel panel = gamemanager.panel; // analytic geometry basically. the gamemanager sizes are static, while // the getwidth/height commands return the dynamic value. // (for panels, the sprite methods always return the dimensions of the image) if (!(node instanceof guinode)) { int x = (int) math.round((-position.getx() + node.position.getx() - (node.spritewidth()*node.getscale())/2 + gamemanager.virtualwidth/2) * panel.getwidth() * scale / gamemanager.virtualwidth); int y = (int) math.round((+position.gety() - node.position.gety() - (node.spriteheight()*node.getscale())/2 + gamemanager.virtualheight/2) * panel.getheight() * scale / gamemanager.virtualheight); int width = (int) math.round(node.spritewidth() * node.getscale() * scale * panel.getwidth() / gamemanager.virtualwidth); int height = (int) math.round(node.spriteheight() * node.getscale() * scale * panel.getheight() / gamemanager.virtualheight); boolean infield = true; if ((x > panel.getwidth() || x + node.spritewidth()*node.getscale() < 0) || (y > panel.getheight() || y + node.spriteheight()*node.getscale() < 0)) infield = false; if (node.anims.size() != 0 && infield && node.isvisible) g.drawimage(node.anims.get(node.currentanim).animatedframe(), x, y, width, height, null); // draws collision shapes if there are any. if (node.collexists() && gamemanager.showshapes) { int collisionx = (int) math.round((-position.getx() + node.position.getx() + node.getcollision().areashape.getx() - (node.getcollision().areashape.getwidth()*node.getscale())/2 + gamemanager.virtualwidth/2) * panel.getwidth() * scale / gamemanager.virtualwidth); int collisiony = (int) math.round((+position.gety() - node.position.gety() - node.getcollision().areashape.gety() - (node.getcollision().areashape.getheight()*node.getscale())/2 + gamemanager.virtualheight/2) * panel.getheight() * scale / gamemanager.virtualheight); int collisionwidth = (int) math.round(node.getcollision().areashape.getwidth() * node.getscale() * scale * panel.getwidth() / gamemanager.virtualwidth); int collisionheight = (int) math.round(node.getcollision().areashape.getheight() * node.getscale() * scale * panel.getheight() / gamemanager.virtualheight); g.drawrect(collisionx, collisiony, collisionwidth, collisionheight); } // draws hitboxes if there are any. if (node.hitboxexists() && gamemanager.showshapes) { int hitboxx = (int) math.round((-position.getx() + node.position.getx() + node.gethitbox().areashape.getx() - (node.gethitbox().areashape.getwidth()*node.getscale())/2 + gamemanager.virtualwidth/2) * panel.getwidth() * scale / gamemanager.virtualwidth); int hitboxy = (int) math.round((+position.gety() - node.position.gety() - node.gethitbox().areashape.gety() - (node.gethitbox().areashape.getheight()*node.getscale())/2 + gamemanager.virtualheight/2) * panel.getheight() * scale / gamemanager.virtualheight); int hitboxwidth = (int) math.round(node.gethitbox().areashape.getwidth() * node.getscale() * scale * panel.getwidth() / gamemanager.virtualwidth); int hitboxheight = (int) math.round(node.gethitbox().areashape.getheight() * node.getscale() * scale * panel.getheight() / gamemanager.virtualheight); g.drawrect(hitboxx, hitboxy, hitboxwidth, hitboxheight); } } } public void guirender(graphics g, gamenode node) { gamepanel panel = gamemanager.panel; if (node instanceof guinode && node.isvisible) { int x = (int) math.round((node.position.getx() - (node.spritewidth()*node.getscale())/2 + gamemanager.virtualwidth/2) * panel.getwidth() / gamemanager.virtualwidth); int y = (int) math.round((-node.position.gety() - (node.spriteheight()*node.getscale())/2 + gamemanager.virtualheight/2) * panel.getheight() / gamemanager.virtualheight); int width = (int) math.round(node.spritewidth() * node.getscale() * panel.getwidth() / gamemanager.virtualwidth); int height = (int) math.round(node.spriteheight() * node.getscale() * panel.getheight() / gamemanager.virtualheight); if (node.anims.size() != 0) g.drawimage(node.anims.get(node.currentanim).animatedframe(), x, y, width, height, null); if (node instanceof textnode) { textnode nodetext = (textnode) node; if (nodetext.getfont() != null) { double framearea = (double) gamemanager.frame.getheight() * gamemanager.frame.getwidth(); double virtualarea = (double) gamemanager.virtualwidth * gamemanager.virtualheight; double scalefactor = framearea / virtualarea; int fontsize = math.max(1, (int) math.round(nodetext.getfont().getsize() * nodetext.getscale() * scalefactor)); g.setfont(new font(nodetext.getfont().getname(), nodetext.getfont().getstyle(), fontsize)); } g.setcolor(nodetext.getcolor()); g.drawstring(nodetext.gettext(), (int) x, (int) y); } } } public void follownode(gamenode node) { vector2d diff = new vector2d(node.position.getx() - position.getx(), node.position.gety() - position.gety()); vector2d move = vector2d.zero; double distance = diff.length(); if (distance >= 50) { move = diff.normalized().dot(8); } else if (distance >= 1) { move = diff.normalized().dot(2); } position.setlocation(position.getx() + move.x, position.gety() + move.y); } } package gameclasses.defaultclass; import java.awt.geom.point2d; import java.awt.geom.rectangle2d; import gameclasses.gamenode; public class area2d { public rectangle2d areashape; public gamenode node; // we calculate it as if it is centered on the position variable. // the margin values shift the position of the shape from the center. public void setshape(double xmargin, double ymargin, double width, double height) { areashape = new rectangle2d.double(xmargin, ymargin, width, height); } public area2d(gamenode node) { this.node = node; } public boolean exists() { if (areashape == null) return false; else return true; } public boolean doescontain(point2d point) { if (exists()) { double x = node.position.getx() + areashape.getx(); double y = node.position.gety() + areashape.gety(); double width = areashape.getwidth() * node.getscale(); double height = areashape.getheight() * node.getscale(); return point.getx() >= x - width/2 && point.getx() <= x + width/2 && point.gety() >= - y - height/2 && point.gety() <= - y + height/2; } else return false; } // does checks to see if the collision/hitboxes are intersecting. aabb collision. public boolean areaintersecting(area2d other) { if (exists() && other.exists()) { double x = math.round(node.position.getx() + areashape.getx()); double y = math.round(node.position.gety() + areashape.gety()); double width = math.round(areashape.getwidth() * node.getscale()); double height = math.round(areashape.getheight() * node.getscale()); double otherx = math.round(other.node.position.getx() + other.areashape.getx()); double othery = math.round(other.node.position.gety() + other.areashape.gety()); double otherwidth = math.round(other.areashape.getwidth() * other.node.getscale()); double otherheight = math.round(other.areashape.getheight() * other.node.getscale()); return x < otherx + otherwidth && x + width > otherx && y < othery + otherheight && y + height > othery; } else return false; } } package gameclasses.defaultclass; import java.awt.image.bufferedimage; import java.io.file; import java.util.iterator; import java.util.timertask; import java.util.timer; import javax.imageio.imageio; import javax.imageio.imagereader; import javax.imageio.metadata.iiometadata; import javax.imageio.metadata.iiometadatanode; import javax.imageio.stream.imageinputstream; import java.awt.geom.affinetransform; import java.awt.image.affinetransformop; import java.lang.math; import org.w3c.dom.nodelist; import java.awt.renderinghints; import java.awt.graphics2d; public class nodeanim { private bufferedimage[] animation; private bufferedimage[] transformedanim; private int currentframe = 0; public int speed = 1; // when set to 1, every frame is visible for 0.1 seconds. when set to 0, it doesn't play. public boolean flipx = false; public boolean flipy = false; private int length; static timer animtimer = new timer(); public void runframes() { if (speed != 0) { animtimer.scheduleatfixedrate(new timertask() { @override public void run() { currentframe = (currentframe + 1) % length; } }, 0, 100/speed); } } public nodeanim(string filepath) { file file = new file(filepath); try (imageinputstream stream = imageio.createimageinputstream(file)) { iterator<imagereader> readers = imageio.getimagereaders(stream); string fileformat = readers.next().getformatname(); if (fileformat.equals(""gif"")) { try { animation = loadframes(file); transformedanim = animation.clone(); } catch (exception e) { e.printstacktrace(); } } else { animation = new bufferedimage[1]; animation[0] = imageio.read(file); length = 1; transformedanim = animation.clone(); } } catch (exception e) { e.printstacktrace(); } runframes(); } public nodeanim(bufferedimage sheet, int tilesize) { this.animation = splitsheet(sheet, tilesize); speed = 0; } public bufferedimage frame(int index) { return transformedanim[index]; } public bufferedimage animatedframe() { return transformedanim[currentframe]; } public void setcurrentframe(int index) { currentframe = index; } public void transformanim(boolean horizontal, boolean vertical, double radians) { bufferedimage[] transformedanimation = new bufferedimage[animation.length]; transformedanimation = animation.clone(); for (int i = 0; i < animation.length; i++) { transformedanimation[i] = flip(transformedanimation[i], horizontal, vertical); } if (radians != 0) { for (int i = 0; i < animation.length; i++) { transformedanimation[i] = rotate(transformedanimation[i], radians); } } transformedanim = transformedanimation; } // uses affinetransform to flip the image if necessary. public static bufferedimage flip(bufferedimage sprite, boolean horizontal, boolean vertical) { affinetransform transform = new affinetransform(); int width = sprite.getwidth(); int height = sprite.getheight(); if (horizontal) transform.scale(-1, 1); // flip horizontally if (vertical) transform.scale(1, -1); // flip vertically transform.translate(horizontal ? -width : 0, vertical ? -height : 0); affinetransformop op = new affinetransformop(transform, affinetransformop.type_nearest_neighbor); return op.filter(sprite, null); } // uses affinetransform to rotate the image. public static bufferedimage rotate(bufferedimage sprite, double radians) { int width = sprite.getwidth(); int height = sprite.getheight(); double sin = math.abs(math.sin(radians)); double cos = math.abs(math.cos(radians)); int newwidth = (int) math.ceil(width * cos + height * sin); int newheight = (int) math.ceil(width * sin + height * cos); bufferedimage rotatedsprite = new bufferedimage(newwidth, newheight, bufferedimage.type_int_argb); graphics2d g2d = rotatedsprite.creategraphics(); g2d.setrenderinghint(renderinghints.key_interpolation, renderinghints.value_interpolation_nearest_neighbor); affinetransform transform = new affinetransform(); transform.translate((newwidth - width) / 2.0, (newheight - height) / 2.0); transform.rotate(radians, width / 2.0, height / 2.0); // rotate around center g2d.drawimage(sprite, transform, null); g2d.dispose(); return rotatedsprite; } //splits a gif file into an array. private bufferedimage[] loadframes(file file) throws exception { imageinputstream stream = imageio.createimageinputstream(file); iterator<imagereader> readers = imageio.getimagereadersbyformatname(""gif""); if (!readers.hasnext()) throw new runtimeexception(); imagereader reader = readers.next(); reader.setinput(stream); int numframes = reader.getnumimages(true); int width = reader.getwidth(0); int height = reader.getheight(0); bufferedimage[] frames = new bufferedimage[numframes]; for (int i = 0; i < numframes; i++) { bufferedimage rawframe = reader.read(i); // reads metadata to get the actual offset of the frame, if it's specified in the gif file. iiometadata metadata = reader.getimagemetadata(i); int xoffset = 0, yoffset = 0; try { string metaformat = metadata.getnativemetadataformatname(); iiometadatanode root = (iiometadatanode) metadata.getastree(metaformat); nodelist imagedescriptor = root.getelementsbytagname(""imagedescriptor""); if (imagedescriptor.getlength() > 0) { iiometadatanode descriptor = (iiometadatanode) imagedescriptor.item(0); xoffset = integer.parseint(descriptor.getattribute(""imageleftposition"")); yoffset = integer.parseint(descriptor.getattribute(""imagetopposition"")); } } catch (exception e) { e.printstacktrace(); } bufferedimage fixedframe = new bufferedimage(width, height, bufferedimage.type_int_argb); graphics2d g2d = fixedframe.creategraphics(); g2d.drawimage(rawframe, xoffset, yoffset, null); g2d.dispose(); frames[i] = fixedframe; } length = numframes; return frames; } // takes subimages of each sprite sheet, and returns them as an array. private static bufferedimage[] splitsheet(bufferedimage spritesheet, int tilesize) { int cols = spritesheet.getwidth() / tilesize; int rows = spritesheet.getheight() / tilesize; bufferedimage[] frames = new bufferedimage[cols * rows]; for (int y = 0; y < rows; y++) { for (int x = 0; x < cols; x++) { frames[y * cols + x] = spritesheet.getsubimage(x * tilesize, y * tilesize, tilesize, tilesize); } } return frames; } } package gameclasses.defaultclass; import java.lang.math; import gameclasses.gameinput; public class vector2d { public double x = 0; // x direction. public double y = 0; // y direction. public static vector2d zero = new vector2d(0,0); public vector2d (double x, double y) { this.x = x; this.y = y; } // typically for control directions. public vector2d (boolean up, boolean down, boolean left, boolean right) { x = - (gameinput.getbool(gameinput.isleft) ? 1 : 0) + (gameinput.getbool(gameinput.isright) ? 1 : 0); y = - (gameinput.getbool(gameinput.isdown) ? 1 : 0) + (gameinput.getbool(gameinput.isup) ? 1 : 0); } public double length() { return math.sqrt(x*x + y*y); } public vector2d normalized() { if (length() > 0) { double newx = x/length(); double newy = y/length(); return new vector2d(newx, newy); } else return vector2d.zero; } public vector2d dot(vector2d vector) { return new vector2d(x * vector.x, y * vector.y); } public vector2d dot(double a) { return new vector2d(x * a, y * a); } // move toward method for the vector class. made just to make it easier to write controls. public vector2d movetoward(vector2d vector, double amount) { double dx = vector.x - x; double dy = vector.y - y; double delta = math.sqrt(dx * dx + dy * dy); if (delta <= amount) { return vector; } double newx = x + dx * (amount / delta); double newy = y + dy * (amount / delta); return new vector2d(newx, newy); } // utilizes the standard rotation formulas to rotate the vector. public vector2d rotate(double radians) { double newx = this.x * math.cos(radians) - this.y * math.sin(radians); double newy = this.x * math.sin(radians) + this.y * math.cos(radians); return new vector2d(newx, newy); } } package gameclasses.defaultclass.gui; import gameclasses.gamenode; public abstract class guinode extends gamenode { public guinode(double x, double y) { super (x, y); guielement = true; } } package gameclasses.defaultclass.gui; import java.awt.font; import java.awt.color; public abstract class textnode extends guinode { // create an anonymous class using this. private string text; private font font; private color color; public textnode(double x, double y) { super(x, y); } public color getcolor() { return color; } public font getfont() { return font; } public string gettext() { return text; } public void setcolor(color color) { this.color = color; } public void setfont(font font) { this.font = font; } public void settext(string text) { this.text = text; } public void setscale(double scale) { if (font != null) { int newsize = (int) (font.getsize() * scale); // scale the font size this.font = new font(font.getname(), font.getstyle(), newsize); } } } package gameclasses.defaultclass.gui; import java.awt.geom.point2d; import gameclasses.gameinput; import gameclasses.gamemanager; import gameclasses.defaultclass.area2d; import gameclasses.defaultclass.nodeanim; public abstract class buttonnode extends guinode { // use this for button hitboxes. we don't want to interact with game world nodes. area2d buttonarea = new area2d(this); public buttonnode(double x, double y, string filepath) { super(x, y); nodeanim button1 = new nodeanim(filepath); anims.add(button1); buttonarea.setshape(0, 0, button1.frame(0).getwidth(), button1.frame(0).getheight()); } public static boolean hasclicked = false; @override public void process() { double mousex = gameinput.getcursor().getx() - gamemanager.frame.getwidth()/2; double mousey = gameinput.getcursor().gety() - gamemanager.frame.getheight()/2; point2d mouserelative = new point2d.double(mousex, mousey); if (buttonarea.doescontain(mouserelative) && gameinput.isleftclick && !hasclicked) { buttonfunc(); hasclicked = true; } if (!gameinput.isleftclick) { hasclicked = false; } } public void buttonfunc() {} } package gamedata.scenes; import gameclasses.gameinput; import gameclasses.gamemanager; import gameclasses.defaultclass.gui.buttonnode; import gameclasses.defaultclass.gui.guinode; import gameclasses.gamescene; import gameclasses.gamethread; import gameclasses.defaultclass.nodeanim; import gameclasses.defaultclass.gui.textnode; import java.awt.font; import java.io.file; import java.io.printwriter; import java.awt.color; import gamedata.nodes.player; import gamedata.nodes.wavemanager; import gamedata.nodes.weapons; import gamedata.nodes.weapons.bullets.bullet; import gamedata.nodes.weapons.gun.pistol; import java.util.scanner; public class gui extends gamescene { static guinode pausemenu = new guinode(0, 0) { buttonnode newgame = new buttonnode(0, 200, ""gamedata/images/menu/new.png"") { { drawlayer = 1; isvisible = false; } public void process() { isvisible = gamemanager.ispaused; super.process(); }; public void buttonfunc() { if (gamemanager.ispaused) { gamethread.setscene(new scenes1()); wavemanager.level = 0; wavemanager.zombieamount = 0; wavemanager.isspawning = true; bullet.totalamount = 0; weapons.rifleunlocked = false; weapons.rifleadded = false; weapons.shotgununlocked = false; weapons.shotgunadded = false; weapons.sniperunlocked = false; weapons.sniperadded = false; weapons.rocketunlocked = false; weapons.rocketadded = false; gamemanager.gamescore = 0; gamemanager.gamecam.position.setlocation(0, 0); gamemanager.ispaused = false; } }; }; buttonnode save = new buttonnode(0, 100, ""gamedata/images/menu/save.png"") { file save = new file(""save.sav""); { drawlayer = 1; isvisible = false; } public void process() { isvisible = gamemanager.ispaused; super.process(); }; public void buttonfunc() { if (gamemanager.ispaused) { try { printwriter writer = new printwriter(save); writer.println(wavemanager.level); writer.println(weapons.rifleunlocked); writer.println(weapons.shotgununlocked); writer.println(weapons.sniperunlocked); writer.println(weapons.rocketunlocked); writer.println(gamemanager.gamescore); writer.println(((player)gamemanager.getnode(player.class)).gethp()); writer.close(); gamemanager.ispaused = false; } catch (exception e) { e.printstacktrace(); // failed to save! } } }; }; buttonnode load = new buttonnode(0, 0, ""gamedata/images/menu/loadnt.png"") { nodeanim loadable = new nodeanim(""gamedata/images/menu/load.png""); { anims.add(loadable); drawlayer = 1; isvisible = false; } file save = new file(""save.sav""); public void process() { isvisible = gamemanager.ispaused; if (save.exists()) { currentanim = 1; super.process(); } else currentanim = 0; }; public void buttonfunc() { if (gamemanager.ispaused) { try { gamethread.setscene(new scenes1()); scanner reader = new scanner(save); wavemanager.level = integer.parseint(reader.nextline()); weapons.rifleunlocked = boolean.parseboolean(reader.nextline()); weapons.shotgununlocked = boolean.parseboolean(reader.nextline()); weapons.sniperunlocked = boolean.parseboolean(reader.nextline()); weapons.rocketunlocked = boolean.parseboolean(reader.nextline()); gamemanager.gamescore = integer.parseint(reader.nextline()); ((player)gamemanager.getnode(player.class)).sethp(integer.parseint(reader.nextline())); reader.close(); wavemanager.zombieamount = 0; wavemanager.isspawning = true; bullet.totalamount = 0; weapons.rifleadded = false; weapons.shotgunadded = false; weapons.sniperadded = false; weapons.rocketadded = false; gamemanager.gamecam.position.setlocation(0, 0); gamemanager.ispaused = false; } catch (exception e) { e.printstacktrace(); // failed to load! } } }; }; buttonnode quit = new buttonnode(0, -100, ""gamedata/images/menu/quit.png"") { { drawlayer = 1; isvisible = false; } public void process() { isvisible = gamemanager.ispaused; super.process(); }; public void buttonfunc() { if (gamemanager.ispaused) { system.exit(0); } }; }; nodeanim tint = new nodeanim(""gamedata/images/menu/paused.png""); { isvisible = false; anims.add(tint); childnodes.add(newgame); childnodes.add(save); childnodes.add(load); childnodes.add(quit); } boolean pausetriggered = false; public void process() { isvisible = gamemanager.ispaused; if (gameinput.ispause && !pausetriggered) { gamemanager.ispaused = !gamemanager.ispaused; pausetriggered = true; } if (!gameinput.ispause) { pausetriggered = false; } } }; textnode health = new textnode(300, 300){ { setfont(new font(font.serif, font.plain, 12)); settext(""health: 0""); setcolor(color.white); scale = 5; } public void physicsprocess() { if (((player) gamemanager.getnode(player.class)).gethp() > 0) settext(""health: "" + ((player) gamemanager.getnode(player.class)).gethp()); else settext(""health: 0""); }; }; textnode score = new textnode(300, 250){ { setfont(new font(font.serif, font.plain, 12)); settext(""score: 0""); setcolor(color.white); scale = 5; } public void physicsprocess() { settext(""score: "" + gamemanager.gamescore); }; }; textnode weapon = new textnode(-600, 300){ { setfont(new font(font.serif, font.plain, 12)); settext(""current weapon: 0""); setcolor(color.white); scale = 5; } public void physicsprocess() { settext(""current weapon: "" + ((player) gamemanager.getnode(player.class)).getweapons().getcurrentgun().name); }; }; textnode bullets = new textnode(-600, 250){ { setfont(new font(font.serif, font.plain, 12)); settext(""bullets: 0""); setcolor(color.white); scale = 5; } public void physicsprocess() { settext(""bullets: "" + ((player) gamemanager.getnode(player.class)).getweapons().getcurrentgun().getbulletsleft()); }; }; textnode ammo = new textnode(-600, 200){ { setfont(new font(font.serif, font.plain, 12)); settext(""ammo: 0""); setcolor(color.white); scale = 5; } public void physicsprocess() { if (((player) gamemanager.getnode(player.class)).getweapons().getcurrentgun() instanceof pistol) { settext(""ammo: ∞""); } else settext(""ammo: "" + ((player) gamemanager.getnode(player.class)).getweapons().getcurrentgun().getmagazinesleft()); }; }; textnode unlocktext = new textnode(0, -200){ { setfont(new font(font.serif, font.plain, 12)); settext(""new weapon unlocked!""); setcolor(color.white); scale = 4; isvisible = false; } int waitcooldown = 0; boolean prevrifle = false, prevshotgun = false, prevsniper = false, prevrocket = false; public void physicsprocess() { boolean newunlock = (!prevrifle && weapons.rifleunlocked) || (!prevshotgun && weapons.shotgununlocked) || (!prevsniper && weapons.sniperunlocked) || (!prevrocket && weapons.rocketunlocked); if (newunlock) { waitcooldown = 180; isvisible = true; } if (waitcooldown > 0) { waitcooldown--; if (waitcooldown == 0) { isvisible = false; } } prevrifle = weapons.rifleunlocked; prevshotgun = weapons.shotgununlocked; prevsniper = weapons.sniperunlocked; prevrocket = weapons.rocketunlocked; } }; { childnodes.add(pausemenu); childnodes.add(health); childnodes.add(score); childnodes.add(weapon); childnodes.add(bullets); childnodes.add(ammo); childnodes.add(unlocktext); } } package gamedata.scenes; import gameclasses.gamenode; import gameclasses.gamescene; import gameclasses.defaultclass.camera2d; import gameclasses.defaultclass.nodeanim; import gamedata.nodes.player; import gamedata.nodes.wavemanager; public class scenes1 extends gamescene { public scenes1() { gamenode map = new gamenode(0,0) { nodeanim map = new nodeanim(""gamedata/images/welp.png""); { drawlayer = -1; anims.add(map); } }; gui gui = new gui(); childnodes.add(map); childnodes.add(new camera2d()); childnodes.add(new player()); childnodes.addall(gui.nodelist()); childnodes.add(new wavemanager()); } } package gamedata.nodes; import gameclasses.gamemanager; import gameclasses.gamenode; import gamedata.nodes.enemies.zombie.acidzombie; import gamedata.nodes.enemies.zombie.crawlingzombie; import gamedata.nodes.enemies.zombie.normalzombie; import gamedata.nodes.enemies.zombie.tankzombie; public class wavemanager extends gamenode { public final int mapx = 1000; public final int mapy = 1000; public final int spawnmargin = 200; public static int level = 0; public static int zombieamount = 0; public static boolean isspawning = true; public wavemanager() { super(); } @override public void process() { if (!gamemanager.ispaused) { spawn(); if (level == 2 && !weapons.rifleadded) { weapons.rifleunlocked = true; } if (level == 4 && !weapons.shotgunadded) { weapons.shotgununlocked = true; } if (level == 6 && !weapons.sniperadded) { weapons.sniperunlocked = true; } if (level == 8 && !weapons.rocketadded) { weapons.rocketunlocked = true; } } } public void spawn() { if (isspawning && zombieamount == 0) { zombieamount = 20 + level*5; int acidamount = 0, tankamount = 0, crawleramount = 0, normalamount = 0; if (level >= 6) { acidamount = level*level/10; } if (level >= 4) { tankamount = level*level/5 - acidamount; } if (level >= 2) { crawleramount = level*level/3 - acidamount - tankamount; } normalamount = zombieamount - acidamount - tankamount - crawleramount; while (normalamount != 0) { normalzombie newnormal = new normalzombie(math.random()*mapx*2-mapx, math.random()*mapy*2-mapy); if (newnormal.ghostcollidingwith() == null && newnormal.collidingwith() == null && (newnormal.position.getx() >= spawnmargin || newnormal.position.getx() <= -spawnmargin) && (newnormal.position.gety() >= spawnmargin || newnormal.position.gety() <= -spawnmargin)) { nodeadd(newnormal); normalamount--; } else newnormal = null; } while (crawleramount != 0) { crawlingzombie newcrawling = new crawlingzombie(math.random()*mapx*2-mapx, math.random()*mapy*2-mapy); if (newcrawling.ghostcollidingwith() == null && newcrawling.collidingwith() == null && (newcrawling.position.getx() >= spawnmargin || newcrawling.position.getx() <= -spawnmargin) && (newcrawling.position.gety() >= spawnmargin || newcrawling.position.gety() <= -spawnmargin)) { nodeadd(newcrawling); crawleramount--; } else newcrawling = null; } while (tankamount != 0) { tankzombie newtank = new tankzombie(math.random()*mapx*2-mapx, math.random()*mapy*2-mapy); if (newtank.ghostcollidingwith() == null && newtank.collidingwith() == null && (newtank.position.getx() >= spawnmargin || newtank.position.getx() <= -spawnmargin) && (newtank.position.gety() >= spawnmargin || newtank.position.gety() <= -spawnmargin)) { nodeadd(newtank); tankamount--; } else newtank = null; } while (acidamount != 0) { acidzombie newacid = new acidzombie(math.random()*mapx*2-mapx, math.random()*mapy*2-mapy); if (newacid.ghostcollidingwith() == null && newacid.collidingwith() == null && (newacid.position.getx() >= spawnmargin || newacid.position.getx() <= -spawnmargin) && (newacid.position.gety() >= spawnmargin || newacid.position.gety() <= -spawnmargin)) { nodeadd(newacid); acidamount--; } else newacid = null; } isspawning = false; } if (!isspawning && zombieamount == 0) { isspawning = true; if (level != 16) level++; } } } package gamedata.nodes; import java.util.arraylist; import gameclasses.gamemanager; import gameclasses.gamenode; import gamedata.nodes.weapons.gun; import gamedata.nodes.weapons.gun.infantryrifle; import gamedata.nodes.weapons.gun.pistol; import gamedata.nodes.weapons.gun.rocketlauncher; import gamedata.nodes.weapons.gun.shotgun; import gamedata.nodes.weapons.gun.sniperrifle; public class weapons extends gun { // inventory class for the players weapons. // will only be iterated through when changing weapons, so not in the game loop generally. public arraylist<gun> weaponlist = new arraylist<gun>(); private int currentindex = 0; gun currentgun; public infantryrifle rifle = new infantryrifle(); public static boolean rifleunlocked = false; public static boolean rifleadded = false; public shotgun shotgun = new shotgun(); public static boolean shotgununlocked = false; public static boolean shotgunadded = false; public sniperrifle sniperrifle = new sniperrifle(); public static boolean sniperunlocked = false; public static boolean sniperadded = false; public rocketlauncher rocketlauncher = new rocketlauncher(); public static boolean rocketunlocked = false; public static boolean rocketadded = false; { pistol pistol = new pistol(); //debugrifle debug = new debugrifle(); weaponlist.add(pistol); currentgun = weaponlist.get(currentindex); } public weapons() { super(); } public void swapweapon(int index) { if (weaponlist.size() > 1) { gun temp = weaponlist.get(index); weaponlist.set(index, currentgun); currentgun = temp; currentindex = index; } } public gun getcurrentgun() { return currentgun; } public int getcurrentindex() { return currentindex; } @override public void process() { if (!gamemanager.ispaused) { currentgun.position.setlocation(((gamenode) parentnode).position); if (!rifleadded && rifleunlocked) { weaponlist.add(rifle); rifleadded = true; } if (!shotgunadded && shotgununlocked) { weaponlist.add(shotgun); shotgunadded = true; } if (!sniperadded && sniperunlocked) { weaponlist.add(sniperrifle); sniperadded = true; } if (!rocketadded && rocketunlocked) { weaponlist.add(rocketlauncher); rocketadded = true; } } currentgun.process(); } @override public void physicsprocess() { currentgun.physicsprocess(); } } package gamedata.nodes; import gameclasses.gameinput; import gameclasses.gamemanager; import gameclasses.gamenode; import gameclasses.defaultclass.nodeanim; import gameclasses.defaultclass.vector2d; import gamedata.nodes.enemies.zombie.acidzombie; import gamedata.nodes.enemies.zombie.crawlingzombie; import gamedata.nodes.enemies.zombie.normalzombie; import gamedata.nodes.enemies.zombie.tankzombie; import gamedata.nodes.weapons.bullets.acid; import gamedata.nodes.weapons.gun.drops.rifledrop; import gamedata.nodes.weapons.gun.drops.rocketdrop; import gamedata.nodes.weapons.gun.drops.sniperdrop; import gamedata.nodes.weapons.gun.drops.shotgundrop; import gamedata.nodes.enemies.zombie; public class player extends gamenode { // character health. int hp = 100; boolean isdead = false; public static nodeanim idle = new nodeanim(""gamedata/images/girl.gif""); weapons weapons = new weapons(); { try { anims.add(idle); } catch (exception e) { e.printstacktrace(); } scale = 3; drawlayer = 1; collisionshape.setshape(0, -10, 20, 35); hitboxshape.setshape(0, -10, 20, 35); childnodes.add(weapons); } public player(){ super(); } public player(int x, int y){ super(x,y); } boolean switchtriggered = false; @override public void process() { if (!isdead && !gamemanager.ispaused) { if (gameinput.isweaponswitch && !switchtriggered) { weapons.swapweapon((weapons.getcurrentindex() + 1) % (weapons.weaponlist.size())); switchtriggered = true; } if (!gameinput.isweaponswitch) { switchtriggered = false; } } } public int gethp() { return hp; } public void sethp(int value) { hp = value; } public weapons getweapons() { return weapons; } protected int damagecooldown = 0; protected int cooldownlength = 60; @override public void physicsprocess() { if (!isdead && !gamemanager.ispaused) { vector2d inputvector = new vector2d(gameinput.isup, gameinput.isdown, gameinput.isleft, gameinput.isright).normalized(); vector2d velocity = vector2d.zero.movetoward(inputvector, 1).dot(8); if (gameinput.getrelativemouse().getx() < 0) { anims.get(currentanim).transformanim(true, false, 0); anims.get(currentanim).speed = 1; } else if (gameinput.getrelativemouse().getx() > 0) { anims.get(currentanim).transformanim(false, false, 0); anims.get(currentanim).speed = 1; } if (velocity.x == 0 && velocity.y == 0) { anims.get(currentanim).setcurrentframe(0); anims.get(currentanim).speed = 0; } position.setlocation(position.getx() + velocity.x, position.gety() + velocity.y); gamemanager.gamecam.follownode(this); if (ishitting(acid.class) != null) { hp-=8; } gamenode normaldmg = ishitting(normalzombie.class); if (normaldmg != null && damagecooldown == 0) { hp-=((zombie) normaldmg).getdamage(); damagecooldown = cooldownlength; } gamenode crawldmg = ishitting(crawlingzombie.class); if (crawldmg != null && damagecooldown == 0) { hp-=((zombie) crawldmg).getdamage(); damagecooldown = cooldownlength; } gamenode tankdmg = ishitting(tankzombie.class); if (tankdmg != null && damagecooldown == 0) { hp-=((zombie) tankdmg).getdamage(); damagecooldown = cooldownlength; } gamenode aciddmg = ishitting(acidzombie.class); if (aciddmg != null && damagecooldown == 0) { hp-=((zombie) aciddmg).getdamage(); damagecooldown = cooldownlength; } if (damagecooldown > 0) { damagecooldown--; } if (collidingwith(rifledrop.class) != null) { weapons.rifle.addmagazine(); } if (collidingwith(shotgundrop.class) != null) { weapons.shotgun.addmagazine(); } if (collidingwith(sniperdrop.class) != null) { weapons.sniperrifle.addmagazine(); } if (collidingwith(rocketdrop.class) != null) { weapons.rocketlauncher.addmagazine(); } if (hp <= 0) { isdead = true; nodedispose(weapons); } } } } package gamedata.nodes.other; import gameclasses.gamenode; import gameclasses.defaultclass.nodeanim; public class acidexplosion extends gamenode { public static nodeanim explode = new nodeanim(""gamedata/images/acidexplosion.gif""); { try { anims.add(explode); } catch (exception e) { e.printstacktrace(); } hitboxshape.setshape(0, 0, explode.frame(0).getwidth(), explode.frame(0).getheight()); scale = 0.5; } public acidexplosion(double x, double y) { super(x, y); } @override public void process() {} int counter = 100; @override public void physicsprocess() { counter--; if(counter == 0) nodedispose(this); } } package gamedata.nodes.other; import gameclasses.gamenode; import gameclasses.defaultclass.nodeanim; public class explosion extends gamenode { public static nodeanim explode = new nodeanim(""gamedata/images/explosion.gif""); { try { anims.add(explode); } catch (exception e) { e.printstacktrace(); } hitboxshape.setshape(0, 0, explode.frame(0).getwidth(), explode.frame(0).getheight()); scale = 1; } public explosion(double x, double y) { super(x, y); } @override public void process() {} int counter = 100; @override public void physicsprocess() { counter--; if(counter == 0) nodedispose(this); } } package gamedata.nodes.enemies; import gameclasses.gamemanager; import gameclasses.gamenode; import gameclasses.defaultclass.vector2d; import gamedata.nodes.player; import gamedata.nodes.wavemanager; import gamedata.nodes.weapons; import gamedata.nodes.other.explosion; import gamedata.nodes.weapons.bullets.bullet; import gamedata.nodes.weapons.bullets.rocket; import gamedata.nodes.weapons.bullets.sniperbullet; import gamedata.nodes.weapons.gun.drops.rifledrop; import gamedata.nodes.weapons.gun.drops.rocketdrop; import gamedata.nodes.weapons.gun.drops.shotgundrop; import gamedata.nodes.weapons.gun.drops.sniperdrop; import java.awt.geom.point2d; public abstract class zombie extends gamenode { public static gamenode playerref; { drawlayer = 1; } protected enum amount { low, medium, high } public enum state { idle, walk, attack, die } protected int health; protected int damage; protected double speed; protected state state = state.idle; protected int zombiescore = 20; public zombie() { super(); } public zombie(double x, double y) { super(x, y); } public zombie(double x, double y, amount healthamount, amount speedamount, amount damageamount) { super(x, y); switch (healthamount) { case low: health = 20; break; case medium: health = 40; break; case high: health = 80; break; } switch (speedamount) { case low: speed = 1.5; break; case medium: speed = 3; break; case high: speed = 4.5; break; } switch (damageamount) { case low: damage = 7; break; case medium: damage = 16; break; case high: damage = 25; break; } } public int getdamage() { return damage; } @override public void physicsprocess() { if (!gamemanager.ispaused) { playerref = gamemanager.getnode(player.class); if (playerref!= null) zombiestate(); } } public void zombiestate() { takedamage(); switch (state) { case idle: idle(); break; case walk: walk(); break; case attack: attack(); break; case die: die(); break; } } protected double playermargin = 0.5; public void idle() { if (position.distance(playerref.position) >= (playerref.spritewidth()*playerref.getscale()/2)*playermargin) { state = state.walk; } else state = state.attack; } public void walk() { if (position.distance(playerref.position) <= (playerref.spritewidth()*playerref.getscale()/2)*playermargin) { state = state.idle; } else { vector2d playervector = new vector2d(playerref.position.getx() - position.getx(), playerref.position.gety() - position.gety()).normalized(); vector2d velocity = vector2d.zero.movetoward(playervector, 1).normalized().dot(speed); point2d previousposition = new point2d.double(position.getx(), position.gety()); position.setlocation(position.getx() + velocity.x, position.gety() + velocity.y); if (collidingwith() instanceof zombie) { position = previousposition; } } } int attackcooldown = 120; public void attack() { if (position.distance(playerref.position) >= (playerref.spritewidth()*playerref.getscale()/2)*playermargin) { state = state.idle; } else { if (attackcooldown == 120) { attackcooldown--; } else if (attackcooldown <= 0) attackcooldown = 120; else attackcooldown--; } } public void die() { nodedispose(this); wavemanager.zombieamount--; gamemanager.gamescore+=zombiescore; double droprate = math.random() * 100; if (weapons.rocketunlocked && droprate >= 90) { nodeadd(new rocketdrop(position.getx(), position.gety())); } else if (weapons.sniperunlocked && droprate >= 75 && droprate <= 95) { nodeadd(new sniperdrop(position.getx(), position.gety())); } else if (weapons.shotgununlocked && droprate >= 60 && droprate <= 75) { nodeadd(new shotgundrop(position.getx(), position.gety())); } else if (weapons.rifleunlocked && droprate >= 45 && droprate <= 60) { nodeadd(new rifledrop(position.getx(), position.gety())); } } public void takedamage() { if (health <= 0) { state = state.die; return; } if ((ishitting(bullet.class)!= null || ishitting(rocket.class) != null || ishitting(sniperbullet.class) != null || ishitting(explosion.class)!= null) && state != state.die) { health = health - 15; } } } package gamedata.nodes.enemies.zombie; import gameclasses.defaultclass.nodeanim; import gameclasses.defaultclass.vector2d; import gamedata.nodes.enemies.zombie; import java.awt.geom.point2d; public class crawlingzombie extends zombie { public static nodeanim idle = new nodeanim(""gamedata/images/crawlingzombie.gif""); { try { anims.add(idle); } catch (exception e) { e.printstacktrace(); } scale = 0.2; hitboxshape.setshape(-10, -5, 300, 500); collisionshape.setshape(-10, -5, 300, 500); zombiescore = 30; } public crawlingzombie(double x, double y) { super(x, y, amount.low, amount.high, amount.medium); } @override public void physicsprocess() {super.physicsprocess();} @override public void zombiestate() { takedamage(); switch (state) { case idle: idle(); break; case walk: walk(); break; case attack: if (islunging) {lunge(); break;} attack(); break; case die: die(); break; } } @override public void idle() { if (position.distance(playerref.position) >= (playerref.spritewidth()*playerref.getscale()/2)*3) { state = state.walk; } else state = state.attack; } @override public void walk() { if (position.distance(playerref.position) <= (playerref.spritewidth()*playerref.getscale()/2)*3) { state = state.idle; } else { vector2d playervector = new vector2d(playerref.position.getx() - position.getx(), playerref.position.gety() - position.gety()).normalized(); vector2d velocity = vector2d.zero.movetoward(playervector, 1).normalized().dot(speed); point2d previousposition = new point2d.double(position.getx(), position.gety()); position.setlocation(position.getx() + velocity.x, position.gety() + velocity.y); if (collidingwith() instanceof zombie) { position = previousposition; } } } int attackcooldown = 120; boolean islunging = false; point2d lastposition = position; @override public void attack() { if (position.distance(playerref.position) >= (playerref.spritewidth()*playerref.getscale()/2)*3) { state = state.idle; } else if (attackcooldown == 120) { if (position.distance(playerref.position) <= (playerref.spritewidth()*playerref.getscale()/2)*3 && position.distance(playerref.position) >= (playerref.spritewidth()*playerref.getscale()/2)*playermargin) { lastposition = new point2d.double(playerref.position.getx(), playerref.position.gety()); attackcooldown--; islunging = true; } else if (position.distance(playerref.position) <= (playerref.spritewidth()*playerref.getscale()/2)*playermargin) { attackcooldown--; } } else if (attackcooldown <= 0) attackcooldown = 120; else attackcooldown--; } public void lunge() { double distance = position.distance(lastposition); if (distance <= 2) { islunging = false; state = state.idle; attackcooldown--; return; } double step = math.min(speed * 3, distance); vector2d jumpvector = new vector2d(lastposition.getx() - position.getx(), lastposition.gety() - position.gety()).normalized().dot(step); point2d previousposition = new point2d.double(position.getx(), position.gety()); position.setlocation(position.getx() + jumpvector.x, position.gety() + jumpvector.y); if (collidingwith() instanceof zombie) { position = previousposition; state = state.idle; islunging = false; attackcooldown--; } } } package gamedata.nodes.enemies.zombie; import gameclasses.gamemanager; import gameclasses.defaultclass.nodeanim; import gameclasses.defaultclass.vector2d; import gamedata.nodes.wavemanager; import gamedata.nodes.weapons; import gamedata.nodes.enemies.zombie; import gamedata.nodes.other.acidexplosion; import gamedata.nodes.weapons.bullets.acid; import gamedata.nodes.weapons.gun.drops.rifledrop; import gamedata.nodes.weapons.gun.drops.rocketdrop; import gamedata.nodes.weapons.gun.drops.shotgundrop; import gamedata.nodes.weapons.gun.drops.sniperdrop; import java.awt.geom.point2d; public class acidzombie extends zombie { public static nodeanim idle = new nodeanim(""gamedata/images/acidzombie.gif""); { try { anims.add(idle); } catch (exception e) { e.printstacktrace(); } scale = 0.2; hitboxshape.setshape(-10, -5, 300, 500); collisionshape.setshape(-10, -5, 300, 500); zombiescore = 50; } public acidzombie(double x, double y) { super(x, y, amount.low, amount.low, amount.medium); } @override public void physicsprocess() {super.physicsprocess();} @override public void idle() { if (position.distance(playerref.position) >= (playerref.spritewidth()*playerref.getscale()/2)*playerdistance) { state = state.walk; } else state = state.attack; } double playerdistance = 6; @override public void walk() { if (position.distance(playerref.position) <= (playerref.spritewidth()*playerref.getscale()/2)*playerdistance) { state = state.idle; } else { vector2d playervector = new vector2d(playerref.position.getx() - position.getx(), playerref.position.gety() - position.gety()).normalized(); vector2d velocity = vector2d.zero.movetoward(playervector, 1).normalized().dot(speed); point2d previousposition = new point2d.double(position.getx(), position.gety()); position.setlocation(position.getx() + velocity.x, position.gety() + velocity.y); if (collidingwith() instanceof zombie) { position = previousposition; } } } int attackcooldown = 120; @override public void attack() { if (position.distance(playerref.position) >= (playerref.spritewidth()*playerref.getscale()/2)*playerdistance) { state = state.idle; } else { if (attackcooldown == 120) { nodeadd(new acid(position.getx(), position.gety(), playerref)); attackcooldown--; } else if (attackcooldown <= 0) attackcooldown = 120; else attackcooldown--; } } @override public void die() { nodeadd(new acidexplosion(position.getx(), position.gety())); nodedispose(this); wavemanager.zombieamount--; gamemanager.gamescore += zombiescore; double droprate = math.random() * 100; if (weapons.rocketunlocked && droprate >= 90) { nodeadd(new rocketdrop(position.getx(), position.gety())); } else if (weapons.sniperunlocked && droprate >= 75 && droprate <= 95) { nodeadd(new sniperdrop(position.getx(), position.gety())); } else if (weapons.shotgununlocked && droprate >= 60 && droprate <= 75) { nodeadd(new shotgundrop(position.getx(), position.gety())); } else if (weapons.rifleunlocked && droprate >= 45 && droprate <= 60) { nodeadd(new rifledrop(position.getx(), position.gety())); } } } package gamedata.nodes.enemies.zombie; import gameclasses.defaultclass.nodeanim; import gamedata.nodes.enemies.zombie; public class normalzombie extends zombie { // if you need to keep the order for which zombie this is, use id logic. // use the static numerator from earlier, but this time equate it to a class variable too, // so that it works as an id. public static nodeanim idle = new nodeanim(""gamedata/images/zombie.gif""); { try { anims.add(idle); } catch (exception e) { e.printstacktrace(); } scale = 0.2; hitboxshape.setshape(-10, -5, 300, 500); collisionshape.setshape(-10, -5, 300, 500); } public normalzombie(double x, double y) { super(x, y, amount.medium, amount.low, amount.medium); } @override public void physicsprocess() {super.physicsprocess();} } package gamedata.nodes.enemies.zombie; import gameclasses.defaultclass.nodeanim; import gamedata.nodes.enemies.zombie; public class tankzombie extends zombie { public static nodeanim idle = new nodeanim(""gamedata/images/tankzombie.gif""); { try { anims.add(idle); } catch (exception e) { e.printstacktrace(); } scale = 0.4; hitboxshape.setshape(-10, -5, 300, 500); collisionshape.setshape(-10, -5, 300, 500); zombiescore = 40; } public tankzombie(double x, double y) { super(x, y, amount.high, amount.low, amount.high); } @override public void physicsprocess() {super.physicsprocess();} } package gamedata.nodes.weapons; import gameclasses.gameinput; import gameclasses.gamemanager; import gameclasses.gamenode; import gamedata.nodes.weapons.bullets.bullet; public abstract class gun extends gamenode { public string name = ""gun""; protected double firespeed; // bullets per sec protected int magazine; protected int bulletsleft; protected int magazinesleft; protected boolean reloadtriggered = false; protected double recoilangle = 0; public double getfirespeed() { return firespeed; } public int getmagazine() { return magazine; } public gun() { super(); } public gun (int magazine, double firespeed) { this.firespeed = firespeed; this.magazine = magazine; bulletsleft = magazine; } @override public void process() { if (!gamemanager.ispaused) { if (gameinput.isreload && !reloadtriggered) { reload(); reloadtriggered = true; } if (!gameinput.isreload) { reloadtriggered = false; } } } protected int bulletcooldown = 0; // counter for bullet cooldown @override public void physicsprocess() { if (!gamemanager.ispaused) { final int cooldownlength = (int) (60/firespeed); if (gameinput.isfiring) { if (bulletcooldown <= 0 && bulletsleft > 0) { nodeadd(new bullet(position.getx(), position.gety(), recoilangle/2, true)); bulletsleft--; bulletcooldown = cooldownlength; } } if (bulletcooldown > 0) { bulletcooldown--; } } } public int getbulletsleft() { return bulletsleft; } public int getmagazinesleft() { return magazinesleft; } public void addmagazine() { magazinesleft++; } protected void reload() { if (magazinesleft > 0) { bulletsleft = magazine; magazinesleft--; } } } package gamedata.nodes.weapons.bullets; import gameclasses.gameinput; import gameclasses.gamemanager; import gameclasses.gamenode; import gameclasses.defaultclass.nodeanim; import gameclasses.defaultclass.vector2d; import gamedata.nodes.enemies.zombie.crawlingzombie; import gamedata.nodes.enemies.zombie.normalzombie; import gamedata.nodes.enemies.zombie.tankzombie; import gamedata.nodes.enemies.zombie.acidzombie; public class bullet extends gamenode { public static int totalamount = 0; protected final int maxbullets = 60; // max amount of projectiles that can be on screen. vector2d direction = vector2d.zero; public static nodeanim idle = new nodeanim(""gamedata/images/bullet.png""); { try { anims.add(idle); } catch (exception e) { e.printstacktrace(); } hitboxshape.setshape(0, 0, idle.animatedframe().getwidth(), idle.animatedframe().getwidth()); scale = 1; } public bullet(){ super(); totalamount++; } public bullet(double x, double y, double recoilradians, boolean random) { super(x,y); double angle1 = recoilradians; if (recoilradians != 0 && random) { int sign = math.random() < 0.5 ? -1 : 1; angle1 = recoilradians * math.random() * sign; } totalamount++; double mousex = gameinput.getcursor().getx() - gamemanager.frame.getwidth()/2; double mousey = gameinput.getcursor().gety() - gamemanager.frame.getheight()/2; direction = new vector2d(mousex, mousey).rotate(angle1).normalized(); } @override public void process() {} final int speed = 24; @override public void physicsprocess() { if (!gamemanager.ispaused) { vector2d velocity = direction.dot(speed); if (totalamount >= maxbullets || ishitting(normalzombie.class) != null || ishitting(crawlingzombie.class) != null || ishitting(tankzombie.class)!= null || ishitting(acidzombie.class) != null) { totalamount--; nodedispose(this); } position.setlocation(position.getx() + velocity.x, position.gety() - velocity.y); } } } package gamedata.nodes.weapons.bullets; import gameclasses.gamemanager; import gameclasses.gamenode; import gameclasses.defaultclass.nodeanim; import gameclasses.defaultclass.vector2d; import gamedata.nodes.player; public class acid extends gamenode { vector2d direction = vector2d.zero; public static nodeanim idle = new nodeanim(""gamedata/images/acid.png""); { try { anims.add(idle); } catch (exception e) { e.printstacktrace(); } hitboxshape.setshape(0, 0, idle.animatedframe().getwidth(), idle.animatedframe().getwidth()); scale = 1; } public acid(){ super(); bullet.totalamount++; } // projectile thrown at node. public acid(double x, double y, gamenode node) { super(x,y); bullet.totalamount++; direction = new vector2d(node.position.getx() - position.getx(), - node.position.gety() + position.gety()).normalized(); } @override public void process() {} final int speed = 24; @override public void physicsprocess() { if (!gamemanager.ispaused) { vector2d velocity = direction.dot(speed); position.setlocation(position.getx() + velocity.x, position.gety() - velocity.y); if (bullet.totalamount >= 60 || ishitting(player.class) != null) { bullet.totalamount--; nodedispose(this); } } } } package gamedata.nodes.weapons.bullets; import gameclasses.gamemanager; import gameclasses.defaultclass.vector2d; public class sniperbullet extends bullet { public sniperbullet() { super(); } public sniperbullet(double x, double y) { super(x, y, 0, false); } @override public void physicsprocess() { if (!gamemanager.ispaused) { vector2d velocity = direction.dot(speed); if (totalamount >= maxbullets) { totalamount--; nodedispose(this); } position.setlocation(position.getx() + velocity.x, position.gety() - velocity.y); } } } package gamedata.nodes.weapons.bullets; import gameclasses.gamemanager; import gameclasses.defaultclass.vector2d; import gamedata.nodes.enemies.zombie.acidzombie; import gamedata.nodes.enemies.zombie.crawlingzombie; import gamedata.nodes.enemies.zombie.normalzombie; import gamedata.nodes.enemies.zombie.tankzombie; import gamedata.nodes.other.explosion; public class rocket extends bullet { public rocket() { super(); } public rocket(double x, double y) { super(x, y, 0, false); } @override public void physicsprocess() { if (!gamemanager.ispaused) { vector2d velocity = direction.dot(speed); if (totalamount >= maxbullets || ishitting(normalzombie.class) != null || ishitting(crawlingzombie.class) != null || ishitting(tankzombie.class)!= null || ishitting(acidzombie.class) != null) { totalamount--; nodeadd(new explosion(position.getx(), position.gety())); nodedispose(this); } position.setlocation(position.getx() + velocity.x, position.gety() - velocity.y); } } } package gamedata.nodes.weapons.gun; import gameclasses.gameinput; import gameclasses.gamemanager; import gamedata.nodes.weapons.gun; import gamedata.nodes.weapons.bullets.bullet; public class shotgun extends gun { // the project manual says that the shotgun shoots 9 bullets in a 45 degrees range, each // bullets velocity vector seperated 5 degrees apart. that isn't mathematically possible. // if you split the 45 degrees range into 5 degree sections, you get 9 sections, but 10 lines. // therefore i'll split the 45 degree range into 8 sections instead. public shotgun() { super(5, 1); name = ""shotgun""; } @override public void physicsprocess() { if (!gamemanager.ispaused) { final int cooldownlength = (int) (60/firespeed); if (gameinput.isfiring) { if (super.bulletcooldown <= 0 && bulletsleft > 0) { nodeadd(new bullet(position.getx(), position.gety(), math.pi/8, false)); nodeadd(new bullet(position.getx(), position.gety(), 3*math.pi/32, false)); nodeadd(new bullet(position.getx(), position.gety(), math.pi/16, false)); nodeadd(new bullet(position.getx(), position.gety(), math.pi/32, false)); nodeadd(new bullet(position.getx(), position.gety(), 0, false)); nodeadd(new bullet(position.getx(), position.gety(), -math.pi/32, false)); nodeadd(new bullet(position.getx(), position.gety(), -math.pi/16, false)); nodeadd(new bullet(position.getx(), position.gety(), -3*math.pi/32, false)); nodeadd(new bullet(position.getx(), position.gety(), -math.pi/8, false)); bulletsleft--; bulletcooldown = cooldownlength; } } if (gameinput.isreload && !reloadtriggered) { reload(); reloadtriggered = true; } if (!gameinput.isreload) { reloadtriggered = false; } if (bulletcooldown > 0) { bulletcooldown--; } } } } package gamedata.nodes.weapons.gun; import gamedata.nodes.weapons.gun; public class infantryrifle extends gun { public infantryrifle() { super(30, 5); super.recoilangle = math.pi/6; name = ""infantry rifle""; } } package gamedata.nodes.weapons.gun; import gameclasses.gameinput; import gameclasses.gamemanager; import gamedata.nodes.weapons.gun; import gamedata.nodes.weapons.bullets.sniperbullet; public class sniperrifle extends gun { public sniperrifle(){ super(5, 0.5); name = ""sniper rifle""; } public void physicsprocess() { if (!gamemanager.ispaused) { final int cooldownlength = (int) (60/firespeed); if (gameinput.isfiring) { if (bulletcooldown <= 0 && bulletsleft > 0) { nodeadd(new sniperbullet(position.getx(), position.gety())); bulletsleft--; bulletcooldown = cooldownlength; } } if (gameinput.isreload && !reloadtriggered) { reload(); reloadtriggered = true; } if (!gameinput.isreload) { reloadtriggered = false; } if (bulletcooldown > 0) { bulletcooldown--; } } } } package gamedata.nodes.weapons.gun; import gamedata.nodes.weapons.gun; public class debugrifle extends gun { public debugrifle(){ super(3000000, 10); name = ""debug rifle""; } } package gamedata.nodes.weapons.gun; import gamedata.nodes.weapons.gun; public class pistol extends gun { public pistol() { super(12, 2); name = ""pistol""; } // makes it infinitely reload. @override protected void reload() { super.magazinesleft++; super.reload(); } } package gamedata.nodes.weapons.gun; import gameclasses.gameinput; import gameclasses.gamemanager; import gamedata.nodes.weapons.gun; import gamedata.nodes.weapons.bullets.rocket; public class rocketlauncher extends gun { public rocketlauncher() { super(1, (1.00/6.00)); name = ""rocket launcher""; } @override public void physicsprocess() { if (!gamemanager.ispaused) { final int cooldownlength = (int) (60/firespeed); if (gameinput.isfiring) { if (bulletcooldown <= 0 && bulletsleft > 0) { nodeadd(new rocket(position.getx(), position.gety())); bulletsleft--; bulletcooldown = cooldownlength; } } if (gameinput.isreload && !reloadtriggered) { reload(); reloadtriggered = true; } if (!gameinput.isreload) { reloadtriggered = false; } if (bulletcooldown > 0) { bulletcooldown--; } } } } package gamedata.nodes.weapons.gun.drops; import gameclasses.defaultclass.nodeanim; public class rocketdrop extends drop { public static nodeanim dropsprite = new nodeanim(""gamedata/images/rocketdrop.png""); { try { anims.add(dropsprite); } catch (exception e) { e.printstacktrace(); } collisionshape.setshape(0, 0, dropsprite.frame(0).getwidth(), dropsprite.frame(0).getheight()); } public rocketdrop(double x, double y) { super(x,y); } } package gamedata.nodes.weapons.gun.drops; import gameclasses.defaultclass.nodeanim; public class sniperdrop extends drop { public static nodeanim dropsprite = new nodeanim(""gamedata/images/sniperdrop.png""); { try { anims.add(dropsprite); } catch (exception e) { e.printstacktrace(); } collisionshape.setshape(0, 0, dropsprite.frame(0).getwidth(), dropsprite.frame(0).getheight()); } public sniperdrop(double x, double y) { super(x,y); } } package gamedata.nodes.weapons.gun.drops; import gameclasses.gamemanager; import gameclasses.gamenode; import gamedata.nodes.player; public class drop extends gamenode { public drop(double x, double y) { super(x,y); } int dropwait = 600; @override public void physicsprocess() { if (!gamemanager.ispaused) { if (dropwait <= 0 || collidingwith(player.class)!= null) nodedispose(this); dropwait--; } } } package gamedata.nodes.weapons.gun.drops; import gameclasses.defaultclass.nodeanim; public class rifledrop extends drop { public static nodeanim dropsprite = new nodeanim(""gamedata/images/rifledrop.png""); { try { anims.add(dropsprite); } catch (exception e) { e.printstacktrace(); } collisionshape.setshape(0, 0, dropsprite.frame(0).getwidth(), dropsprite.frame(0).getheight()); } public rifledrop(double x, double y) { super(x,y); } } package gamedata.nodes.weapons.gun.drops; import gameclasses.defaultclass.nodeanim; public class shotgundrop extends drop { public static nodeanim dropsprite = new nodeanim(""gamedata/images/shotgundrop.png""); { try { anims.add(dropsprite); } catch (exception e) { e.printstacktrace(); } collisionshape.setshape(0, 0, dropsprite.frame(0).getwidth(), dropsprite.frame(0).getheight()); } public shotgundrop(double x, double y) { super(x,y); } }"
2051651,8,"recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q3 { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s2.say()); } } class sayac{ string str; sayac(string str){ this.str = str; } public int say(){ return stringcounter(str, 0); } private int stringcounter(string str, int i){ if(i >= str.length()){ return 0; } else if(str.charat(i) == '1'){ return 1 + stringcounter(str, i + 1); } else return stringcounter(str, i + 1); } } public class lab1q2 { public static void main(string[] args) { int[] arr = {3, 1, 7, 5, 6, 0, 4}; cocktailsort(arr); } public static void cocktailsort(int[] arr){ for(int i = 0; i < arr.length; i++){ sortforward(arr, 0); sortbackward(arr, arr.length-1); } for(int i = 0; i < arr.length; i++){ system.out.println(arr[i]); } } public static int[] swap(int i, int j, int[] arr){ int temp = 0; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; } public static int[] sortforward(int[] arr, int i){ if(i >= arr.length-1){ return arr; } else if(arr[i] > arr[i+1]){ swap(i, i+1, arr); return sortforward(arr, i + 1); } else{ return sortforward(arr, i + 1); } } public static int[] sortbackward(int[] arr, int i){ if(i <= 0){ return arr; } else if(arr[i] < arr[i-1]){ swap(i, i+1, arr); return sortforward(arr, i + 1); } else{ return sortforward(arr, i + 1); } } } class lab1q1{ public static void main(string[] args) { system.out.println(collatz(5)); } public static int collatz(int i){ if(i <= 1){ return 0; } else if(i % 2 == 0){ return 1 + collatz(i / 2); } else{ return 1 + collatz(3*i + 1); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar{ calmastratejisi calmastratejisi; void setstrateji(calmastratejisi s){ this.calmastratejisi = s; } void muzikcal(list<sarki> sarkilistesi){ calmastratejisi.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args){ // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki.gettype().equals(""metal"")){ metalsarki m = (metalsarki) sarki; m.gostermetalozellikleri(); } } } } public class klasiksarki extends sarki { klasiksarki(string sanatçi, string isim){ this.isim = isim; this.sanatçi = sanatçi; } @override void oynat() { system.out.println(""[klasi̇k] "" + sanatçi + "" - "" + isim + ""(hafif ve sakin)""); } @override string gettype(){ return ""klasik""; } } public class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik){ this.isim = isim; this.sanatçi = sanatci; this.metalozellik = metalozellik; } @override void oynat() { system.out.println(""[metal] "" + sanatçi + "" - "" + isim + "" "" + metalozellik); } void gostermetalozellikleri(){ system.out.println(sanatçi + "" - "" + isim + "" - metal özelik: "" + metalozellik); } @override string gettype(){ return ""metal""; } } public class rocksarki extends sarki{ rocksarki(string sanatçi, string isim){ this.isim = isim; this.sanatçi = sanatçi; } @override void oynat() { system.out.println(""[rock] "" + sanatçi + "" - "" + isim + ""(huzurlu ve nostaljik)""); } @override string gettype(){ return ""rock""; } } import java.util.list; public class karisikcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(sarkilistesi.size()-i-1).oynat(); } } } import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } public abstract class sarki { string isim; string sanatçi; abstract void oynat(); abstract string gettype(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi{ int volume = 50; public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { if(sarki.gettype().equals(""rock"")){ if(volume < 100) system.out.println("" (volume is increased.)""); volume = 100; } else{ if(volume == 100){ volume = 50; system.out.println("" (volume is decreased.)""); } } sarki.oynat(); } } } import java.util.list; public interface calmastratejisi{ void cal(list<sarki> sarkilistesi); } metin karşılaştırıcı bil 211 - lab 3 20 şubat 2025 1 giriş bulaboratuvarda fileio ve exceptions kullanarakbir metinkarşılaştırıcı geliştireceğiz. metinkarşılaştırıcı , verilen iki metin dosyasını karşılaştırarak ikinci metnin yalnızca yeni satırlar eklenerek oluşturulup oluştu- rulmadığını kontrol edecek ve gerektiğinde hangi satırdan sonra hangi eklemelerin yapıldığını belirleyecektir. 2 genel program program, çalıştırılırken komut satırından iki dosya adı alacaktır: - orijinal metin dosyası (ilk argüman) - değiştirilmiş metin dosyası (ikinci argüman) program şu şekilde çalıştırmalıdır (burada köşeli parantezler yerine dosyaların asıl adı gelmeli): java metinkarsilastirici [orijinal.txt] [degistirilmis.txt] program, ilk argümanda verilen dosyayı orijinal metin, ikinci argümandaki dosyayı değiştirilmiş metin olarak kabul edecek ve yalnızca yeni satırlar eklenerek oluşturulup oluşturulmadığını kontrol edecektir. eğer mümkünse, hangi satırdan sonra hangi eklemelerin yapıldığını tespit ederek bir çıktı dosyasına yazacaktır: -farklar.txt – yeni satırların hangi satırdan sonra eklendiğini gösteren çıktı dosyası. eğer dosya adları eksikse veya hatalı formatta verilmişse, program özel bir hata oluşturmalı ve stderr’e uygun bir mesaj yazmalıdır. 3 fileio program, dosyaokumaveyazmaişlemleriiçinjava’nın java.io paketindekisınıflarıkullanacaktır(örn., buf- ferredreader, scanner, printwriter). dosyaları okurken ve yazarken kullanacağınız fileio sınıflarının seçimi size bırakılmıştır. program, aşağıdaki olası dosya hatalarını atmalı ve stderr’e belirlenen hata mesajlarını yazmalıdır: - dosya bulunamıyorsa: ""hata: [dosya adı] bulunamadı."" - dosya boşsa: ""hata: [dosya adı] boş."" 4 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program hata kodu ile çıkış yapmalıdır (yani mainmetodunuz bu hataları atarak sonlanmalı) ve hatalar stderr’e yazılmalıdır (programınızı hata atarak sonlandırırsanız java bunu kendisi yapacaktır). belirtilen hata mesajları ile birlikte java’nın hata ile sonlanan programlar için oluşturduğu sınıf, metod, ve satır gibi bilgiler bulunabilir. 4.1 girdi hataları (inputexception class) bu kategori, programın giriş dosyalarıyla ilgili karşılaşabileceği tüm hataları kapsar. öğrenciler, dosya işlem- leriyle ilgili hata türlerini inputexception sınıfından türetmelidir. aşağıdaki özel hata türleri tanımlanmalıdır: 1 - yanlisargumanexception (extends inputexception): argümanlar eksik ya da fazlaysa atılacak hata. burada[argümanlar] yerine programın çalıştırıldığı argüman listesi yazılmalıdır. - hata mesajı: ""hata: hatalı argüman kullanımı: [argümanlar]. program argüman olarak 2 dosya ismi almalı."" - dosyabulunamadiexception (extends inputexception): dosya eksikse atılacak hata. - hata mesajı: ""hata: [dosya adı] bulunamadı."" - bosdosyaexception (extends inputexception): dosya boşsa atılacak hata. - hata mesajı: ""hata: [dosya adı] boş."" 4.2 geçersiz değişiklik hatası (gecersizdegisiklikexception class) eğerdegistirilmis.txt dosyası,orijinal.txt dosyasına yalnızca yeni satırlar eklenerek oluşturulamıy- orsa, program gecersizdegisiklikexception hatasını atmalıdır. bu hata oluştuğunda stderr’e şu mesaj yazılmalıdır: hata: [degistirilmis.txt] dosyası, [orijinal.txt] dosyasına yalnızca yeni satırlar eklenerek oluşturulmamış. 5 dosya formatları 5.1 girdi dosyaları 5.1.1orijinal.txt vedegistirilmis.txt formatı bu dosyalar, her satırın ayrı bir metin satırı olduğu düz metin formatında olmalıdır. örnek i̇çerik ( orijinal.txt ): merhaba dünya. bu bir test dosyasıdır. son satır budur. örnek i̇çerik ( degistirilmis.txt ): merhaba dünya. bu bir test dosyasıdır. eklenen yeni bir satır. son satır budur. yeni bir satır daha eklendi. 5.2 çıktı dosyası 5.2.1farklar.txt formatı farklar.txt dosyası, hangi satırdan sonra hangi yeni satırın eklendiğini gösterecek şekilde yapılandırıl- malıdır: örnek çıktı ( farklar.txt ): 2 -> eklenen yeni bir satır. 4 -> yeni bir satır daha eklendi. burada ‘2 ->‘ ifadesi, ""2. satırdan sonra eklenmiştir"" anlamına gelir. eğer aynı yere birden fazla satır eklenmişse aynı sayıyı tekrar ederek eklenme sırasında yazılmalı. 5.3 özel hata durumları ve çıktıları eğerdegistirilmis.txt ,orijinal.txt üzerine sadece yeni satırlar eklenerek oluşturulmamışsa stderr’e şu mesaj yazılmalıdır: hata: degistirilmis.txt dosyası, orijinal.txt dosyasına yalnızca yeni satırlar eklenerek oluşturulmamış. eğer dosya adları eksikse veya hatalıysa, stderr’e şu mesaj yazılmalıdır: hata: geçersiz dosya adı. 2 6 gönderim formatı - labı bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara şeklinde isimlendirin (örn., johnnash_181101014.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""lab3 gönderim"" başlıklı bir mail ile gönderin. metot açıklama string(string s) sile aynı değere sahip bir string oluşturur. string(char[] a) a[]dizisindeki karakterleri temsil eden bir string oluşturur. int length() string içindeki karakter sayısını döndürür. char charat(int i) belirtilen iindeksindeki karakteri döndürür. string substring(int i, int j) iilej-1arasındaki karakterleri içeren bir alt string döndürür. boolean contains(string substring) string’in substring içerip içermediğini kontrol eder. boolean startswith(string prefix) string’in prefixile başlayıp başlamadığını kontrol eder. boolean endswith(string postfix) string’in postfix ile bitip bitmediğini kontrol eder. int indexof(string pattern) pattern ifadesinin ilk geçtiği indeks değerini döndürür. int indexof(string pattern, int i) iindeksinden sonraki ilk pattern konumunu döndürür. string concat(string t) string’in sonuna teklenmiş halini döndürür. int compareto(string t) i̇ki string’i karşılaştırır (sözlük sırasına göre). string tolowercase() string’in tüm harflerini küçük harfe çevirir. string touppercase() string’in tüm harflerini büyük harfe çevirir. string replace(string a, string b) string içindeki a’larıbile değiştirir. string trim() string’in başındaki ve sonundaki boşlukları kaldırır. boolean matches(string regexp) string’in belirtilen regexle eşleşip eşleşmediğini kontrol eder. string[] split(string delimiter) string’idelimiter kullanarak böler ve bir dizi döndürür. boolean equals(object t) string’in değeri tile aynı mı diye kontrol eder. table 1: java string sınıfı metotları 3 import java.io.fileinputstream; import java.io.filenotfoundexception; import java.io.fileoutputstream; import java.io.printwriter; import java.util.arraylist; import java.util.scanner; public class main { public static void main(string[] args) throws bosdosyaexception, kelimebulunamadiexception, dosyabulunamadiexception{ scanner scanner; scanner textscanner; arraylist<string> words = new arraylist<>(); arraylist<string> text = new arraylist<>(); int index = 0; int count = 0; try{ fileinputstream kelimeler = new fileinputstream(""kelimeler.txt""); scanner = new scanner(kelimeler); if(!scanner.hasnext()){ throw new bosdosyaexception(); } while(scanner.hasnext()){ string removed = scanner.next().replaceall(""\\p{punct}"", """"); words.add(removed); } } catch(filenotfoundexception e){ system.err.println(""kelimeler.txt bulunamadı.""); } int[] wordcount = new int[words.size()]; try{ fileinputstream metin = new fileinputstream(""metin.txt""); textscanner = new scanner(metin); if(!textscanner.hasnext()){ throw new bosdosyaexception(); } while(textscanner.hasnext()){ string removed2 = textscanner.next().replaceall(""\\p{punct}"", """"); text.add(removed2); } } catch(filenotfoundexception e){ system.err.println(""metin.txt bulunamadı.""); } try{ fileoutputstream sonuc = new fileoutputstream(""sounc.txt""); printwriter writer = new printwriter(sonuc); for (string word : words) { for (string txt : text) { if(word.equals(txt)){ count++; wordcount[index]++; } } if(count > 0){ writer.write(word + "": "" + count + ""\n""); } index++; count = 0; } writer.close(); for(int i = 0; i < wordcount.length; i++){ if(wordcount[i] == 0){ system.err.println(words.get(i) + "" metinde bulunamadı.""); throw new kelimebulunamadiexception(); } } } catch(filenotfoundexception g){ system.err.println(""sounc.txt bulunamadı""); throw new dosyabulunamadiexception(); } } } public class kelimebulunamadiexception extends exception{ } public class bosdosyaexception extends inputexception { } public class inputexception extends exception { } public class dosyabulunamadiexception extends inputexception { dosyabulunamadiexception(){ super(); } } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. methodun kendi içinde kendisini çağırmasıdır. recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. base case recursive methodun her çağrıldığında kontrol ettigi bir şarttır. i̇stenilen sonuca ulaşıp ulaşılmadıgını kontrol eder ve ulaşılmışsa çıkar bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? method her çağrıldığında artan bir sayaç koyardım, her seferinde stringin son harfini alıp return'e eklerdim. sayaç string uzunluğuna eşit oldugunda çıkardım. recursive bir metotta base case olmazsa ne olur? metod surekli kendini çağırarak belleği doldurur. stack overflow recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. çağırılan metod diğer metotların ust katmanına ksydedilir ve bu şekilde ilerler fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. fibonacci dizisinde sadece son 2 sayıyı kullanırız, recursive metot surekli tamamını tekrar eder tail recursion nedir, kısaca açıklayınız. bilmiyorum java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? ? hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? ? dinamik bağlamada jvm'nin görevi nedir? ? java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? ? java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? ? java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. ? class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? bark, meow. dinamik class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? yanlış yok. dinamik binding. output: child display /n child special java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class olarak kullanılabilen fakat concrete classın aksine tip obje oluşturulamayan ve içinde implement edilmemiş metodlar bulunan bir tur class dır. constructorları olabiliri. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? hayır abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. -i̇mplement edilmemişlerdir -tip olarak kullanılabilir -uzerinden obje oluşturalamaz -altındaki classlarda olmasını istedigimiz ama nasıl yapılacağı serbest bıraktıgımız durumlarda kullanılır. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? i̇nterface metodlarının tamamı abstract'dır, bir class birden fazla interface implement edebilir ama birden fazla abstract class extend edemez. i̇kisi de tip olarak kullanılabilir. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface içinde metod olmayan interface'dir. functional interface içinde tek bir metod olan interfacelerdir bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet, evet. abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? animal abstract class olduğu için uzerinden obje oluşurulamaz. animal a = new dog(""buddy""); olmalıydı. output : animal: buddy, woof. interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? default metod override edilemez. duck classında move metodu olmamalıydı. output: flying. yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. 3 çeşit hata vardır: compile error, örnek: syntax hataları. runtine exception örnek: 0 a bölme. logical error: algoritmada yapılan hatalar exception handlingin amacı nedir? program akışında beklenmedik durumlarla karşılaşıldıgında bunları düzeltmek ya da bunlara özel işlemler yapmak exception handlingde finally bloğunun amacı nedir? ondan önceki bloklardan hangisine girdiginden bağımsız olarak her zaman çalışmasını istedigimiz kod için vardır. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? handle edilmiş exceptionlar checked, handle edilmemiş olanlar unchecked java'da kendi exceptionunuzu nasıl tanımlarsınız? exception classını inherit eden yeni bir class yazarak java'da error ve exception arasındaki fark nedir, açıklayınız error kod yaxarkwn veya kodun mantıgında yapılan bir hatadır. exception program akışında karşılaşılan beklenmeyen durumlardır java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? exceptiona özel işlemleri yapmak ama yine de programı durdurup kullanıcıya bildirmek için 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? bilmiyorum static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenmez. hatanın kaynağı e referansının hem exception hem de arrayindexoutofboundsexception objesi icin kullanılması. duzeltmek için e'lerden birinin ismi değiştirilebilir static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught. finally oops done 41 text file ile binary file arasındaki fark nedir? text file'da karakterler kaydedilir. binary file da byte degerleri kaydedilir bir dosyaya yazarken düzenli olarak flush yapmamak neye yol açabilir? program beklenmedik bir şekilde kapatılırsa son bufferda kalan verilerin kaybedilmesine neden olabilir. binary bir dosyaya bir object yazdırırken bu objenin hangi interfaceyi implement etmesi gerekiyor? bu interfacenin metotlarını sıralayınız. bu interface functional veya marker bir interface midir? serializable interface. bu interface'in metodu yoktur, marker interface'dir binary bir dosyaya primitive typeler (int, float, char etc.) yazılabilir mi, evet ise nasıl? yazılır, bunların byte degerleri yazılır ama okunurken anlaşılması icin ek bilgi gerekebilir buffered reader ve scanner sınıfları ile dosya okurken dosyanın sonuna geldiğini nasıl kontrol edilir? scanner için hasnext() metodu. buffered reader icin has() metodu. binary bir dosya okurken dosyanın sonuna gelindiği nasıl test edilir? length-1 degerine ulaşıldıgında anlaşılır public class randomaccessdemo { public static void main(string[] args) throws exception { randomaccessfile raf = new randomaccessfile(""numbers.bin"", ""rw""); raf.writeint(10); raf.writeint(20); raf.seek(0); int a = raf.readint(); raf.seek(7); byte b = raf.readbyte(); system.out.println(a + "" "" + b); raf.close(); } } output? 10 0 public class demo { public static void main(string[] args) throws exception { try{ fileoutputstream fos = new fileoutputstream(""log.txt"", true); printwriter pw = new printwriter(fos); pw.println(""new log entry""); throw new exception(); } catch(exception e){ system.err(""oopps!""); } } } bu kod çalıştırıldığında log.txt dosyası nasıl etkilenir, açıklayınız. log.txt dosyasının sonuna new log entry yazısı eklenir. what grade (a, b, c, d, or f) do you expect to earn by the end of this course? cb java'da generic kavramı nedir, bu kavramın temel amacı nedir? kullanılacak değişken turkerinin compile zamanında belirmenmesini sağlayan java kavramıdır. amacı esnek kod yazabilmektir upper bound ve lower bound wildcardları nasıl ifade edersiniz? upper ve lower boundun kullanılacağı durumlara birer tane örnek veriniz. upper bound - ? extends t lower bound - ? super t generic bir classın constructorunda type parametresi bulunur mu, neden? bulunmaz, type parametresi class yazılırken verilmistir mygenericclass<a> ve mygenericclass<object> classları arasında kalıtım (child-parent) ilişkisi nasıldır, açıklayınız. yoktur, farklı sınıflar class node<t>{ t[] data = new t[10]; } //psvm node<string> stringnode = new node<>(); bu kodda bir hata var mı? (varsa) bu hata nedir, nedenini açıklayınız. (varsa) bu hata nasıl düzeltilmeli, kodun doğru halini yazınız. geberic tip t ile obje oluşturulamaz swapheadandtail metodu aşağıda tanımı verilmiş node classının birbirlerine bağlanmış nodelerinden ilkini alan ve baştaki node ile sondaki node'yi değiştiren metottur. örnek: başlangıçta: a -> b -> c metodu a ile çağırdığıktan sonra: c -> b -> a ayrıca metot en başa gelen nodeyi dönmelidir (bu örnekte c dönmeli). class node{ int data; node next; } static node swapheadandtail(node head) { node a = head; node b = head.next; node c = head; node d = null; while (____ != null) { d = c; c = c.next; } c.next = ____; d.next = ____; a.next = ____; return ____; } buna göre boşluklara neler gelmelidir? bilmiyorum public _________ { public void sırala(list<t> liste) { // sıralama algoritmanız } } yaptığınız uzun çalışmalar sonucu yeni bir sıralama algoritması buldunuz. bunu implement etmek için bir class yazmalısınız. bu classın declarationunu nasıl yapardınız neden, boşluğu buna göre doldurun. <t> sırala(list<t> liste) ara sınavdan yaklaşık hangi notu bekliyorsun (0-100)? 20-50 4. sütun option 1 java gui uygulamalarında olayları yönetmek için bir programcının yapması gereken iki temel görev nedir? bilmiyorum neden gui uygulamalarında system.exit(0) sıklıkla gerekli olurken, konsol uygulamalarında bu durum geçerli değildir? gui uygulamalarında sürekli bir loop vardır ve kod normaldeki gibi sırayla işlenip sona gelince bitirilmez bu yuzden çıkmak için manuel olarak programı kapatmak gerekir gui tasarımında düzen yöneticilerinin (layout managers) amacı nedir ve bu yöneticiler geliştiricilere nasıl yardımcı olur? frame'e ya da panel'e eklenen componentlerin nasıl yerleştirileceğini yonetir ve bunalrı otomatik olarak yaparak zamandan ve efordam tasaruf saglar jframe'de setdefaultcloseoperation metodunun işlevini açıklayın. sağ ustteki çarpı tuşuna basıldıgında yapılacak işlemi ayarlamak icin kullanılır flowlayout ve gridlayout, bileşenleri düzenlemede nasıl farklılık gösterirler? flowlayout için componentler sırayla(frame'e eklenme sırası) dizilir, alan dolduysa alta geçilir. aşağıdaki kodun çalışmasını izleyin ve jframe'de neyin görüntüleneceğini belirleyin: jframe frame = new jframe(""test""); frame.setsize(300, 200); frame.setlayout(new borderlayout()); jbutton northbutton = new jbutton(""north""); jbutton centerbutton = new jbutton(""center""); frame.add(northbutton, borderlayout.north); frame.add(centerbutton, borderlayout.center); northbutton.setvisible(false); frame.setvisible(true); ekran ortadan ikiye bölünür, yukarda north button olur ama visible olmadığı için onun yerine beyaz bir boşluk olur. altta uzerinde center yazan bur buton olur aşağıdaki kod parçasını göz önünde bulundurun: import javax.swing.*; import java.awt.event.*; public class testframe extends jframe { public testframe() { settitle(""test""); setsize(300, 200); jbutton btn = new jbutton(""exit""); btn.addactionlistener(new actionlistener() { public void actionperformed(actionevent e) { system.out.println(""button clicked""); system.exit(0); } }); add(btn); setdefaultcloseoperation(jframe.exit_on_close); setvisible(true); } public static void main(string[] args) { new testframe(); } } kullanıcı ""exit"" düğmesine tıkladığında olaylar sırası nasıldır? bir frame açılır uzerinde tıklandıgında programı kapatan bir buton olur kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; string type; public abstractrobot(string modelname, int batterylife, string type){ this.modelname = modelname; this.batterylife = batterylife; this.type = type; } public string getmodelname(){ return modelname; } public abstract void performtask(); } public class main { public static void main(string[] args){ robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(); system.out.println(""tüm fabrikalar tarafından toplam "" + robotfactory.totalrobots + "" robot üretildi.""); } } public class securityrobot extends abstractrobot { private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife, ""security robot""); this.isarmed = isarmed; } @override public int getbatterylife() { return batterylife; } @override public void recharge() { batterylife = 100; } @override public void performtask() { if(batterylife >= 10){ system.out.println(modelname + "" scanning for threats... armed "" + isarmed); batterylife -= 10; } else{ system.out.println(modelname + "" not enough battery to scan threats.""); } } public void togglearmedmode(){ if(isarmed == true){ isarmed = false; } else{ isarmed = true; } } public boolean getisarmed(){ return isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower){ super(modelname, batterylife, ""cleaning robot""); this.cleaningpower = cleaningpower; } @override public int getbatterylife() { return batterylife; } @override public void recharge() { batterylife = 100; } @override public void performtask() { if(batterylife >= 10){ system.out.println(modelname + "" cleaning in progress... "" + ""cleaning power: "" + cleaningpower); batterylife -= 10; } else{ system.out.println(modelname + "" not enough battery to clean""); } } public int getcleaningpower(){ return cleaningpower; } public void setcleaningpower(int x){ cleaningpower += x; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); private arraylist<securityrobot> securityrobots = new arraylist<>(); private arraylist<cleaningrobot> cleaningrobots = new arraylist<>(); static int totalrobots; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); cleaningrobots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); totalrobots += 1; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ robots.add(new securityrobot(modelname, batterylife, isarmed)); securityrobots.add(new securityrobot(modelname, batterylife, isarmed)); totalrobots += 1; } public void performalltasks(){ for (abstractrobot abstractrobot : robots) { abstractrobot.performtask(); } } public void displayrobots(){ for (cleaningrobot c : cleaningrobots) { system.out.println(""cleaning robot - model: "" + c.getmodelname() + "", battery: "" + c.getbatterylife() + "", cleaning power: "" + c.getcleaningpower()); } for (securityrobot s : securityrobots) { system.out.println(""security robot - model: "" + s.getmodelname() + "", battery: "" + s.getbatterylife() + "", armed: "" + s.getisarmed()); } } public void upgradecleaningrobots(int miktar){ for (cleaningrobot c : cleaningrobots){ c.setcleaningpower(miktar); system.out.println(""cleaning robot - "" + c.getmodelname() + "" now has cleaning power "" + c.getcleaningpower()); } } public void togglesecurityrobotsmode(){ for (securityrobot s : securityrobots) { s.togglearmedmode(); if(s.getisarmed() == true){ system.out.println(""security robot - "" + s.getmodelname() + "" is now armed.""); } else{ system.out.println(""security robot - "" + s.getmodelname() + "" is now unarmed.""); } } } } 8"
4779274,2,"recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab221301009 { // test için main public static void main(string[] args) { system.out.println(""\n"" + collatz(5)); int[] arr = {5,4,1,2,6,7,1,3,9,11,2,1,-3}; //kontrol etmek için karışık yaptım for(int i=0; i<arr.length; i++) system.out.print(arr[i] + "" ""); cocktailsort(arr); // fonk call system.out.print(""\n yeni hali :""); for(int i=0; i<arr.length; i++) system.out.print(arr[i] + "" ""); sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(""\n"" + s1.say() +"" ve ""+ s2.say()); } // soru 1 collatz public static int collatz(int i) { int mod = i % 2; system.out.print(i + "" -> ""); // adımları yazmak için if (i == 1) return 0; else{ if(mod == 1) return 1 + collatz((i*3)+1); else return 1 + collatz(i / 2); } } // soru 2 cocktail shaker sort public static void cocktailsort(int[] arr) { if (arr.length != 0) karsilastir(arr,0, 1, 1); else system.out.println(""olmaz""); } static void karsilastir (int[] arr, int index, int yon, int iteras) { boolean kucukmu = arr [index] <= arr [index + yon]; //iterasyon bittiyse boş dön bitir if (iteras == arr.length) return; // yöne göre küçük mü büyük mü olması değişmesini etkiliyordu o yüzden böyle if (kucukmu == false && yon == 1 || kucukmu == true && yon == -1) { int temp = arr [index]; arr [index] = arr [index + yon]; arr [index + yon] = temp; } // burada tamamen sınırlara gelince yön değişmesi ve iterasyon artması için falan // ayrı ayrı çağırdım daha kısa yapılabilirdi if (index == arr.length - 2 && yon == 1) karsilastir(arr, arr.length - 2, -1, iteras + 1); else if (index == 1 && yon == -1) karsilastir(arr, 1, 1, iteras + 1); else karsilastir(arr, index + yon , yon, iteras); } } //soru 3 class sayac { string str; sayac(string str) { this.str = str; } //stringi alan bi helper lazımdı her şeyi onda yaptım aslında public int sayhelp(string str) { if (str.length() == 0) return 0; else if (str.charat(0) == '1') return 1 + sayhelp(str.substring(1)); else return 0 + sayhelp(str.substring(1)); } public int say() { return(sayhelp(str)); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.sql.time; import java.util.arrays; import java.util.collections; import java.util.list; public class lab2_221301009 { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki) { ((metalsarki)sarki).gostermetalozellikleri(); } } } } abstract class sarki { string isim, sanatci; abstract void oynat(); } class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void oynat() { system.out.println(""[metal] ""+this.sanatci+"" - ""+this.isim+"" (""+this.metalozellik+"")""); } void gostermetalozellikleri() { system.out.println(this.sanatci+"" - ""+this.isim+"" [ozellik: ""+this.metalozellik+""]""); } } class rocksarki extends sarki { string rockozellik = ""huzurlu ve nostaljik""; rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[rock] ""+this.sanatci+"" - ""+this.isim+"" (""+this.rockozellik+"")""); } } class klasiksarki extends sarki { string klasikozellik = ""hafif ve sakin""; klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[klasik] ""+this.sanatci+"" - ""+this.isim+"" (""+this.klasikozellik+"")""); } } interface calmastratejisi{ void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } system.out.println(); } } class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { collections.shuffle(sarkilistesi); for (sarki sarki : sarkilistesi) { sarki.oynat(); } system.out.println(); } } class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean yuksekmi = false; for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki && yuksekmi == false) { system.out.println(""[bilgi] ses duzeyi: yuksek""); yuksekmi = true; } else if (!(sarki instanceof rocksarki) && yuksekmi == true) { system.out.println(""[bilgi] ses duzeyi: normal""); yuksekmi = false; } sarki.oynat(); } } } class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { strateji = s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } kelime sayıcı bil 211 - lab 3 20 şubat 2025 1 giriş bu laboratuvarda fileioveexceptions kullanarak bir kelime sayıcı geliştireceğiz. kelime sayıcı , verilen birmetindosyasındakibelirlikelimelerinkaçkezgeçtiğinisayarakbirçıktıdosyasınakaydedecekvebelirlenen hata durumlarında uygun çıktılar oluşturacaktır. 2 genel program program, aşağıdaki sabit isimlere sahip iki giriş dosyası ile çalışacaktır: -kelimeler.txt – aranacak kelimeleri içeren dosya. -metin.txt – kelimelerin aranacağı metnin bulunduğu dosya. program, kelimeler.txt dosyasındaki her kelimenin metin.txt içinde kaç kez geçtiğini sayacak ve sonucu bir çıktı dosyasına kaydedecektir: -sonuc.txt – her kelimenin kaç kez geçtiğini içeren çıktı dosyası. dosyalar,programınçalıştırıldığıdizindebulunmalıdır. dosyaisimlerideğiştirilemez,programsadeceyukarıda belirtilen isimlerle çalışacaktır. eğerkelimeler.txt içinde bulunan herhangi bir kelime, metin.txt içinde hiç geçmiyorsa, program bir hata oluşturmalı ve stderr’e uygun bir mesaj yazmalıdır. 3 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları kullanacaktır (örn., bufferredreader, scanner, printwriter). dosyaları okurken ve yazarken kullanacağınız fileio sınıflarının seçimi size bırakılmıştır. i̇şlenmesi gereken dosyalar şunlardır: -kelimeler.txt dosyası okunmalıdır. -metin.txt dosyası okunmalıdır. -sonuc.txt dosyası oluşturulup yazılmalıdır. program,aşağıdakiolasıdosyahatalarınıoluşturmalıvehatalaroluştuğundastderr’ebelirlenenhatamesajlarını yazmalıdır: - dosyabulunamıyorsa: ""hata: kelimeler.txt bulunamadı."" veya""hata: metin.txt bulunamadı."" - dosya boşsa: ""hata: kelimeler.txt boş."" veya""hata: metin.txt boş."" 4 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program hata kodu ile çıkış yapmalıdır (yani mainmetodunuz bu hataları atarak sonlanmalı) ve hatalar stderr’e yazılmalıdır (programınızı hata atarak sonlandırırsanız java bunu kendisi yapacaktır). belirtilen hata mesajları ile birlikte java’nın hata ile sonlanan programlar için oluşturduğu sınıf, metod, ve satır gibi bilgiler bulunabilir. 1 4.1 girdi hataları (inputexception class) bu kategori, programın giriş dosyalarıyla ilgili karşılaşabileceği tüm hataları kapsar. öğrenciler, dosya işlem- leriyle ilgili hata türlerini inputexception sınıfından türetmelidir. aşağıdaki özel hata türleri tanımlanmalıdır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: [dosya adı] bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: [dosya adı] boş."" 4.2 kelime bulunamadı hatası (kelimebulunamadiexception class) eğerkelimeler.txt içinde bulunan en az bir kelime, metin.txt dosyasında hiç geçmiyorsa, program kelimebulunamadiexception hatasını atmalıdır. hata yalnızca kelimeler.txt dosyasında bulunamayan ilk kelime için atılır ve program sonlanır. bu hata oluştuğunda stderr’e şu mesaj yazılmalıdır: -""hata: [kelime] metinde bulunamadı."" bu hata, doğrudan exception sınıfından türetilecek ve inputexception ile bağlantılı olmayacaktır. 5 dosya formatları program üç farklı dosya ile çalışacaktır: kelimeler.txt (girdi),metin.txt (girdi) ve sonuc.txt (çıktı). bu dosyaların formatı aşağıda belirtilmiştir. 5.1 girdi dosyaları girdi dosyaları düz metin ( .txt) formatında olacaktır ve her biri aşağıdaki gibi yapılandırılmış olmalıdır. 5.1.1kelimeler.txt formatı kelimeler.txt dosyası, her satırda bir kelime olacak şekilde düzenlenmelidir. dosyada yalnızca harf karak- terleri bulunur. kelimeler büyük/küçük harf duyarsız olarak aranacaktır. örnek i̇çerik: elma armut üzüm eğer dosya boşsa, program şu hatayı vermelidir: hata: kelimeler.txt boş. 5.1.2metin.txt formatı metin.txt dosyası, içinde aranacak kelimelerin geçebileceği serbest formatlı bir metin içermelidir. dosya içinde noktalama işaretleri ve boşluklar bulunabilir. örnek i̇çerik: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. eğer dosya boşsa, program şu hatayı vermelidir: hata: metin.txt boş. 5.2 çıktı dosyası program, kelimelerin kaç kez geçtiğini gösteren bir çıktı dosyası ( sonuc.txt ) oluşturmalıdır. 2 5.2.1sonuc.txt formatı sonuc.txt dosyası, her satırda kelimenin adı ve kaç kez geçtiği bilgisi olacak şekilde düzenlenmelidir. format şu şekilde olmalıdır: [kelime] [geçme sayısı] kelime ve geçme sayısı arasında tek bir boşluk olmalıdır. örnek çıktı ( sonuc.txt ): elma 2 armut 2 üzüm 1 5.3 özel hata durumları ve çıktıları eğerkelimeler.txt içindekiherhangibirkelime metin.txt içindebulunamazsa, kelimebulunamadiexception hatası atılmalıdır ve stderr’e şu mesaj yazılmalıdır: hata: üzüm metinde bulunamadı. bu hata oluştuğunda, yine de sonuc.txt dosyası oluşturulmalı ve bulunan kelimeler için normal çıktı yazıl- malıdır. ancak bulunamayan kelimeler çıktı dosyasına eklenmemelidir. örnek durum: eğerkelimeler.txt şu şekildeyse: elma armut muz vemetin.txt şu şekildeyse: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. o zaman sonuc.txt şu şekilde olmalıdır: elma 2 armut 2 ve stderr’e şu mesaj yazılmalıdır: hata: muz metinde bulunamadı. 6 gönderim formatı - labı bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara şeklinde isimlendirin (örn., johnnash_181101014.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""lab3 gönderim"" başlıklı bir mail ile gönderin. 3 metot açıklama string(string s) sile aynı değere sahip bir string oluşturur. string(char[] a) a[]dizisindeki karakterlerle bir string oluşturur. int length() string içindeki karakter sayısını döndürür. char charat(int i) belirtilen iindeksindeki karakteri döndürür. string substring(int i, int j) iilej-1arasındaki karakterleri içeren bir alt string döndürür. boolean contains(string substring) string’in substring ’i içerip içermediğini kontrol eder. boolean startswith(string prefix) string’in prefixile başlayıp başlamadığını kontrol eder. boolean endswith(string postfix) string’in postfix ile bitip bitmediğini kontrol eder. int indexof(string pattern) pattern ifadesinin ilk geçtiği indeks değerini döndürür. int indexof(string pattern, int i) iindeksinden sonraki ilk pattern konumunu döndürür. string concat(string t) string’in sonuna teklenmiş halini döndürür. int compareto(string t) i̇ki string’i karşılaştırır (sözlük sırasına göre). string tolowercase() string’in tüm harflerini küçük harfe çevirir. string touppercase() string’in tüm harflerini büyük harfe çevirir. string replace(string a, string b) string içindeki a’larıbile değiştirir. string trim() string’in başındaki ve sonundaki boşlukları kaldırır. boolean matches(string regex) string’in belirtilen regexle eşleşip eşleşmediğini kontrol eder. string[] split(string delimiter) string’idelimiter kullanarak böler ve bir dizi döndürür. boolean equals(object t) string’in değeri tile aynı mı diye kontrol eder. table 1: java string sınıfı metotları 4 // vaktim yetmediğinden classları ayrı dosyaya alamadım kusura bakmayın. import java.io.bufferedreader; import java.io.file; import java.io.fileinputstream; import java.io.filenotfoundexception; import java.io.fileoutputstream; import java.io.filereader; import java.io.ioexception; import java.io.printwriter; import java.util.arraylist; import java.util.scanner; public class lab3 { //stderrora yazdiran tüm exceptionları mainden de throw ettim alt satırda. public static void main(string[] args) throws ioexception, dosyabulunamadiexception, bosdosyaexception{ arraylist<string> kelimelerdizisi = new arraylist<string>(); try { bufferedreader in = new bufferedreader(new filereader(""c:\\users\\meren\\desktop\\muhammederenöner_221301009\\kelimeler.txt"")); string word; int i; for(i=0;(word = in.readline()) != null;i++) { kelimelerdizisi.add(word); } in.close(); if (i==0) { //direkt ilk iterasyonda null çıktıysa boş dosya hatası fırlat throw new bosdosyaexception(""hata: kelimeler.txt boş""); } //üst noktada kelimeler okundu ve arraylistine alındı. bufferedreader metin = new bufferedreader(new filereader(""c:\\users\\meren\\desktop\\muhammederenöner_221301009\\metin.txt"")); arraylist<string> linedizi = new arraylist<>(); int j; for(j=0;(word = metin.readline()) != null;j++) { kelimelerdizisi.add(word); } if (j==0) { //direkt ilk iterasyonda null çıktıysa boş dosya hatası fırlat throw new bosdosyaexception(""hata: metin.txt boş""); } metin.close(); //burada da cümleler metinden alındı arraylistlere. arraylist<integer> tekrarsayilari = new arraylist<>(); //alttaki nested forları açıklıyorum: //her bi kelime için alınan her satırı tarar, contains ise arttırıp kalan kısımda contains mi diye bakar, tekrar artar. for (string kelime : kelimelerdizisi) { int tekrar=0; for (string dizin : linedizi) { if(dizin.contains(kelime)) { int index = 0; while(index < dizin.length()) { index = dizin.indexof(kelime, index+kelime.length()); tekrar++; } } } tekrarsayilari.add(tekrar); } //üst kısım sanırım eksik, doğru hesapladiğini varsayarak yazdırma aşamasına geçiyorum fileoutputstream sonuc = new fileoutputstream(""c:\\users\\meren\\desktop\\muhammederenöner_221301009\\sonuc.txt"", true); printwriter yaz = new printwriter(sonuc); //i kelime sayısını tutuyordu, o yüzden üst sınır. for(int kelimeno=0; kelimeno<i; kelimeno++) { //eğer total 0 ise hata fırlat if(tekrarsayilari.get(kelimeno) == 0) { throw new kelimebulunamadiexception(""hata: ""+ kelimelerdizisi.get(kelimeno) + "" metinde bulunamadı."") } yaz.println(kelimelerdizisi.get(kelimeno) + "" "" + tekrarsayilari.get(kelimeno)); // her bir kelime ve karşılık geldiği tekrar sayısını dosyaya yazdır. } } catch(kelimebulunamadiexception k) { system.out.println(k.getmessage()); } catch(filenotfoundexception e) { //dosya bulunmadıysa zaten zorunlu olarak filenotfound fırlatıldı, ben de onu tutup bunu attım throw new dosyabulunamadiexception(""hata: kelimeler.txt//metin.txt bulunamadı.""); //zamanım kalmadığı için aynı try bloğunda ikisini de çektim ondan hata mesajı birlesik oldu :( } } } //exception classlarımda extra tanımlanacak bir şey yoktu sanırsam class inputexception extends exception { public inputexception(string mesaj) { super(mesaj); } } class dosyabulunamadiexception extends inputexception { public dosyabulunamadiexception(string mesaj) { super(mesaj); } } class bosdosyaexception extends inputexception { public bosdosyaexception(string mesaj) { super(mesaj); } } class kelimebulunamadiexception extends exception { public kelimebulunamadiexception(string mesaj) { super(mesaj); } } generic 1) envanter yönetim sistemi bu labda amacımı bir oyun için envanter sistemi eklemektir. item isminde bir arayüz tanımlayın: aşağıdaki metotları içermelidir: string getname() int getvalue() weapon sınıfı tanımlayın. bu sınıf item arayüzünü uygulamalıdır. int damage isimli bir özelliği olmalıdır. armor sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. int defense isimli bir değişkeni olmalıdır. potion sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. string effect isimli bir değişkeni olmalıdır. generic inventory<t> sınıfı bir arraylist kullanarak nesneleri saklamalıdır. void additem(t item): envantere istenilen eşyayı eklemeli void removeitem(t item): envanterden istenilen eşyayı silmeli void printinventory(): envanteri basmalı t mostvaluableitem(): en değerli eşyayı dönmeli t finditembyname(string name): verilen isme karşılık gelen eşyayı dönmeli. i̇simlerin unique olduğunu varsayabilirsiniz. eğer yoksa null dönün. list<t> finditemsbyvalue(int value): verilen değerden daha değerli eşyaarın listesini döndürür. int gettotalvalue(): envanterin toplam değerini döner. list<t> filterbytype(class<?> type): istenilen sınıfa ait ögeleri döner. int gettotalweapondamage(): weapon classına ait olan nesnelerin toplam hasarınıdöner. void sortbyvalue(): değeri azalan şekilde envanteri sıralamalıdır. public static void printmostvaluableitem(inventory<? extends item> inventory): verilen envanterdem en değerli eşayı ekrana basmalıdır. public static void transferarmor(inventory<? super armor> destination, inventory<armor> source): verilen hedef envantere zırhı taşımalıdır. driver class: main metodu burada olmalıdır. sadece weapon’dan oluşan ve itemdan oluşan invertory classı yazıp test ediniz. yardımcı olabilecek metotlar: class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon import java.util.arraylist; import java.util.list; public class inventory <t extends item> { private arraylist<t> itemlist = new arraylist<>(); void additem(t item) { itemlist.add(item); } void removeitem(t item) { itemlist.remove(item); } void printinventory() { for (t env : itemlist) { system.out.println(env.tostring()); } } t mostvaluableitem() { int valuetemp = 0; t ttemp = null; for (t env : itemlist) { if (env.getvalue() >= valuetemp) { ttemp = env; valuetemp = env.getvalue(); } } return ttemp; } t finditembyname(string name) { t ttemp = null; for (t env : itemlist) { if(env.getname().equals(name)) ttemp = env; } return ttemp; } list<t> finditemsbyvalue(int value) { list<t> thatlist = new arraylist<>(); for(t env : itemlist) { if(env.getvalue() > value) thatlist.add(env); } return thatlist; } int gettotalvalue() { int total = 0; for(t env : itemlist) total += env.getvalue(); return total; } list<t> filterbytype(class<?> type) { list<t> thatlist = new arraylist<>(); for (t env : itemlist) { //isinstance kullanmayı tercih ettim class getname falan da olur if (type.isinstance(env)) { thatlist.add(env); } } return thatlist; } int gettotalweapondamage() { int damage = 0; for (t env : itemlist) { if (env instanceof weapon) damage += env.getdamage(); } return damage; } void sortbyvalue() { for(int i=0; i<itemlist.size()-1; i++) { int index=i; t temp= null; int maxvalue = 0; for(int j=i; j<itemlist.size(); j++) { if(itemlist.get(j).getvalue() >= maxvalue) { maxvalue = itemlist.get(j).getvalue(); index = j; } } temp = itemlist.get(index); itemlist.set(index, itemlist.get(i)); itemlist.set(i, temp); } } public static void printmostvaluableitem(inventory<? extends item> inventory) { system.out.println(""envanterdeki en degerli item:"" + (inventory.mostvaluableitem().getname())); } public static void transferarmor(inventory<? super armor> destionation, inventory<armor> source) { list<armor> totransfer = source.filterbytype(armor.class); for (armor armor : totransfer) { destionation.additem(armor); source.removeitem(armor); } } } public class weapon implements item { private int damage; private string name; private int value; @override public string tostring() { return name + "" "" + value + "" damage:"" + damage; } public weapon(string string, int value, int damage) { this.name = string; this.damage = damage; this.value = value; } @override public string getname() { return this.name; } @override public int getvalue() { return this.value; } @override public int getdamage() { return this.damage; } } public interface item { string getname(); int getvalue(); default int getdamage() { system.out.println(""inventory'de t type'ında bulunabilmesi icin""); //zaten buraya girmez ama inventory classı item extendli olduğu için bu gerekiyodu return 0; } } public class armor implements item { private string name; private int value; private int defense; @override public string tostring() { return name + "" "" + value + "" defense:"" + defense; } public armor(string name, int value, int defense) { this.name = name; this.value = value; this.defense = defense; } @override public string getname() { return this.name; } @override public int getvalue() { return this.value; } } public class potion implements item{ private string effect; @override public string tostring() { return name + "" "" + value + "" effect:"" + effect; } public potion(string name, int value, string effect) { this.effect = effect; this.value = value; this.name = name; } private int value; private string name; @override public string getname() { return this.name; } @override public int getvalue() { return this.value; } } public class driver { public static void main(string[] args) { inventory<item> iteminventory = new inventory<>(); iteminventory.additem(new weapon(""biweapon"", 150, 30)); iteminventory.additem(new armor(""zirh"", 350, 500)); iteminventory.additem(new armor(""zirh ikinci"", 400, 600)); iteminventory.additem(new potion(""ilac"", 310, ""healing"")); iteminventory.sortbyvalue(); iteminventory.printinventory(); system.out.println(""""); inventory<weapon> envanter = new inventory<>(); envanter.additem(new weapon(""kilic"", 1560, 90)); envanter.additem(new weapon(""bicak"", 1500, 70)); envanter.additem(new weapon(""silah"",2500 , 150)); inventory.printmostvaluableitem(envanter); inventory<armor> arminventory = new inventory<>(); arminventory.additem(new armor(""öz-zirh"", 290, 500)); arminventory.additem(new armor(""öz-zirh ikinci"", 900, 600)); envanter.sortbyvalue(); envanter.printinventory(); system.out.println(""total value: "" + envanter.gettotalvalue()); inventory.transferarmor(iteminventory, arminventory); system.out.println(""\narmordan aktarma yapildi, item inventory son hali:""); iteminventory.printinventory(); iteminventory.sortbyvalue(); system.out.println(""\n\nitem inventory tekrar sort edildi son hali:""); iteminventory.printinventory(); } } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. recursive (özyineleme) bir metodun kendini tekrar çağırması - tetiklemesi diyebiliriz, base kısmı vardı recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. en küçük durum için gerekliydi, bu fonksiyonun yani metodun kendini sürekli çağırarak çalışmasının bi noktada durmasını sağlayan kısım. yani baz kısmında tekrar çağırmayız bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? her bi iterasyonda bir önceki elemana giden yani sondan başlayarak yazdıran bi fonksiyonumuz olurdu, base case ise ilk eleman (fonksiyonun eleman girdisi n ise base n ==0 koşulu olabilir) recursive bir metotta base case olmazsa ne olur? sonsuza kadar gidebilir bence anlamli sonuç olmaz, baz ile en son durumda recursiveı durdurmayı amaçlıyoruz çünkü while yazıp koşul yazmamak gibi bi şey olur recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. stackte tüm çağrılan fonksiyonların girdileri birikir üst üste. aynı fonk ne kadar çağrıldıysa fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. recursive genel verimsiz ve fibonacci de çok fazla stack depolaması gerektirir bence tail recursion nedir, kısaca açıklayınız. unuttum abstraction kavramını açıklayınız. soyutlama, ""is a"" ilişkilerinde temel olan özellikleri bir kenarda soyut bi biçimde tutma diyebiliriz bence dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? evet mümkün, zaten hourlyemployee is an employee mantığıyla bakınca dönüş tipi değişmio protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier dediğimiz default mu eğer öyleyde no modifier daha yakın. protected subclas falan da alıo java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? e çünkü alt sınıftan bi nesne tanımladığımızda bunun atasındaki instance variablelerinr de atama yapmamız gerekecek. atasının atası bu zincir ne kdr var, ne kadar instamce var değer atamak için bunları bilmediğimizden her cınstructor atasına referans verirse zincirleme her şey atanabilir java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır olmaz aynı isimli metotlar falan sıkıntı java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a b nin subclassı demek oluo, ata oğul ilişkisinin kontrolü metot overriding ve overloading kavramlarını açıklayınız. overriding: aynı imza (isim ve değişkrbler) ; overloading: aynı metot ismi ama variablrlrr farklı yani aslında bambaşka bi fonksiyon compiler için bence class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? hocam derived objesi açmışız hani derivedin consrructorunda super varsa o base() çalıştırır o da print(); çağırır. o da base nin kendi printine gider o da ""base"" çıktısı verir cevap base bence class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? bence 10. bence zaten c.getvalue direkt parentteki getvalue gider gibi hissettim java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? comp sırasında kodun gidişine göre anlamı değişmeyen bindingler en başta static olarak yapılır, override falan varsa dynamic çünkü hangisine bind etmeli falan java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? üçünü de artık override edemezsin, bu yüzden static bindingle direkt net olarak o bağlanır overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overriding varsa dynamic, overloading zaten bambaşka bi methot tanımı anlamına geldiğinden static bindingi bozmaz dinamik bağlamada jvm'nin görevi nedir? runtime sırasında bağlamı belirlemek ?? yani override var ve en yakın overrideya bağlıyor kısaca açıklamaya çalıştım java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? biri diğerini kapsıyo olduğundan upcasting implicit halde olabilir ama downcasting için aynısını diyemeyiz yapılamaz java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? e hepsini runtime da belirlemesi bence zaman karmaşıklığını arttırırdı, jvm nin o anda bununla upraşmasına gerek yok bazı bindingler net şekilde başta yapılabilecekken class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child yazar, override olduğundan comp başında binding olmaz yani dinamik bağlama class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? productbook çıktısı verir , iki bağlama tipi de var arryin ilk itemi direkt product diğeri ise book olduğu içib ama belki java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract classlar soyuttur, metotu yaratır tanım içermez alt classlar için yapı sağlar; constructor olabilir abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? implement dediğimiz interface ile alakalı değil mi abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. sıfatlardan bahsedebilir hale geliriz, soyutlama işte yani nesnesel programlama yapabilmek için nesneyi koda soyut aktardığımız hal abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract classın abstract olmayan metotları olabilir interface tamamen soyut, tip olabilirler aynı zamanda marker interface ve functional interface kavramları nedir, nasıl kullanılır? ilk kez duyuyırum bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet birden çok eder; ama bir interface diğerini extend eder abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? hata animal a variablesinin yine animal tipinde bir objeyi tutuyo olması. bu durumda a.sound abstract kalmış bi function olarak kalır, dogtaki sounda zaten inemez ama bence hata da verir. onu dğzeltirsek de çıktı animal:buddy /n woof olr. interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? bence interfacenin içinde de metot içi tanım yapamıyoz zaten ikisi ayrı ayrı yapabilseydi aynı anda implement edemezdik bence, o iç tanım duck classı içinde yapılmalı ve yazdırılmalı. bu haliyle output doğrudan swimming ya da flying biz ne dersek artık sonuçta ikisini de yapabilir, ne durumda olduğuna bağlı bi metot yazılır yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. error ve exception olarak ayrılır, compile error ve runtime error olaeak ayrılır exception handlingin amacı nedir? oluşacak muhtemel hatalara doğru müdahele etmek, hatalardaki kontrolle kodu tam anlamıyla yönetebilmiş olmak exception handlingde finally bloğunun amacı nedir? eğer hata alındıktan (ya da almadıktan) sonra kesiblikle yapılması gereken bir şey varsa bu blokta bunlar gerçekleşir mesela bi dosyayı bi scanneri kapatmak. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? checked, compile esnasında kontrol edilmesi gereken exceptionlarken unchecked ler runtime esnasında oluşabilme ihtimali serbest olan exceptionlardır java'da kendi exceptionunuzu nasıl tanımlarsınız? exception classına bi oğul class tanımlayarak (exceptiın ile extend ederek) sonra constructoru, gerekiyorsa hata mrsajını vs tanımlarım java'da error ve exception arasındaki fark nedir, açıklayınız errorlar geri dönülemez sistem hataları olarak nitelendirilir, exception ise coder tarafından handle edilebilecek kusurlardır java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? metod, bu hatayla ilgili kendi düzeltmelerini yaptıktan sonra bir öncesinde çağrıldığı metodda da düzeltmeler gerekiyorsa üst metodun da catch edebilmesi için tekrar fırlatılır 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? override ederken ana metodda fırlatılan hata türü veya o türün oğul hataları fırkatılabilir, ata exceptionlar override metodda throw edemez static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenir ama hata var. catchlerin sırası yanlış. bu durumda exception caught çalışır. ama daha özelinde çalışması gereken alttaki catchtir. derlenir ama mantığı yanlış static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally done -1 text file ile binary file arasındaki fark nedir? text file dönüştürülmüş insanın açıp okuyabildiği iken binary file tüm verileri olduğu gibi bitler halinde yazar okunamaz göz ile bir dosyaya yazarken düzenli olarak flush yapmamak neye yol açabilir? veri kaybına sebep olabilir, vatelite özelliğini tetikler binary bir dosyaya bir object yazdırırken bu objenin hangi interfaceyi implement etmesi gerekiyor? bu interfacenin metotlarını sıralayınız. bu interface functional veya marker bir interface midir? serializable interfacesini implement etmeli, functionaldı binary bir dosyaya primitive typeler (int, float, char etc.) yazılabilir mi, evet ise nasıl? yazılsa da hepsi binary şekilde yazılır, objectinputstream ile yazdırırız buffered reader ve scanner sınıfları ile dosya okurken dosyanın sonuna geldiğini nasıl kontrol edilir? eof vardı bitane, buffered olanda eksi 1 alıyor değer scannerde de has next line vs. var boolean binary bir dosya okurken dosyanın sonuna gelindiği nasıl test edilir? eof 😜 public class randomaccessdemo { public static void main(string[] args) throws exception { _______ f = new _______(""numbers.bin"", ""____""); f.writeint(10); f.writeint(20); int a = f.readint(); f.seek(_____________); int b = f.readint(); system.out.println(a + b); f.close(); } } boşluklara sırasıyla ne gelmelidir? output? objectinputstream f = new objectinputstream .... true gelmeli f.seek de 8 falan olmalı heehalde output 30 public class demo { public static void main(string[] args) throws exception { fileoutputstream fos = new fileoutputstream(""log.txt"", true); ______________ pw = new ______________(fos); pw.println(""new log entry""); pw.close(); } } boşluklara sırasıyla ne gelmelidir? bu kod çalıştırıldığında log.txt dosyası nasıl etkilenir? printwriter gelmesi gerekmio mu ikisine ya what grade (a, b, c, d, or f) do you expect to earn by the end of this course? bb java'da generic kavramı nedir, bu kavramın temel amacı nedir? class ve metotların typee göre esnetilebilmesini sağlayan yapıdır, amaç classın belirli birden faza obje türüne uyumlu hale getirilmesi bir wildcard'ı ne zaman sınırlamaya ihtiyaç duyarsınız, sınırlandığı ve sınırlanmadığı durumlar için birer örnek veriniz. boundları hangi keywordlerle ifade edersiniz? eğer o classta her objede olmayan belirli objelerin sahip olduğu metotlar varsa. boundlar ? * fasa fiso jenerik olmayan bir class jenerik bir metot içerebilir mi? açıklayınız. evet içerebilir metotun jeneriği kendisiyle alakalıdır mygenericclass<integer> ve mygenericclass<number> classları arasında kalıtım(child-parent) ilişkisi nasıldır, açıklayınız. child parent ilişkisi yoktur biri diğerini tam olrk kapsamıyor çünki class node<t>{ t[] data = new t[10]; } //psvm node<string> stringnode = new node<>(); bu kodda bir hata var mı? (varsa) bu hata nedir, nedenini açıklayınız. (varsa) bu hata nasıl düzeltilmeli, kodun doğru halini yazınız. bence hata yok public _____________ { double sum = 0.0; for (t item : list) { sum += item.doublevalue(); } return sum / list.size(); } public static void main(string[] args) { list<integer> integers = arrays.aslist(1, 2, 3, 4); list<double> doubles = arrays.aslist(1.5, 2.5, 3.5); main m = new main(); system.out.println(average(integers)); system.out.println(average(doubles)); } yukarıda boşluk bırakılan yeri doldurun. not: metodun jenerik olduğuna, çağırılma biçimine ve jenerik tipine dikkat edin! boşluğu doldurduktan sonra programın çıktısı ne olur? <t extends number> average(list<t> list) (üstteki boşluk) çıktı: 2.5 2.5 aşağıda tanımı verilmiş node classının birbirlerine bağlanmış nodelerinden ilkini alan ve hepsini 1 defa sağa kaydıran metodu nasıl yazardınız, stratejiniz ne olurdu? peki ya n defa sağa kaydırma işlemini nasıl yapardınız? n defa kaydırma çözümünüz sizce optimal olan çözüm mü, neden? örnek: başlangıçta: a -> b -> c metodu a ile çağırdığıktan sonra: c -> a -> b ayrıca metot en başa gelen nodeyi dönmelidir (bu örnekte c dönmeli). class node{ int data; node next; } static node rotate(node head){...} son nodea giderdim forla onu tutardım, sonra onun nextini heade bağlarım, ondan bir öncekinin nextini null yaparım. n kadar kaydırma,(n mod total node sayısı) kadar kaydırmakla aynıdır. onu bulup o kadar kaydırılırdı arraylist ve linkedlist veri yapılarını kıyaslayınız, aralarındaki farkları açıklayınız. arraylist direkt array oluşturur genişletir linked list birbirine bağlı esnek collections interfacesindeki metotlar temel olarak hangi işlevleri yerine getiriyor? herangi bi collectionun yapması gerekenler işte eleman ekleme silme vs vs kendi yazdığınız bir classta veri yapilarını istenilen şekilde (mesela hashset'te duplicate objelerin olmamasi) kullanabilmek için object classının hangi metotlarını override etmek gerekir, neden? equals, tostring belki ne bilm bir dijital kütüphane uygulaması geliştiriyorsunuz. bu uygulamada, öğrenciler araştırma projeleri için kaynak ekliyor ve sistem, en son eklenen kaynağı ilk olarak görüntülemek üzere tasarlanıyor. öğrenciler, ekledikleri kaynakların boyut sırasına göre tekrar gözden geçebilmek istiyorlar. bu durumda, hangi veri yapısını tercih edersiniz? neden? stack veri yapısını twrcih ederdim çünkü lifo. fifo nedir, açıklayınız ve aşağıdakı veri yapılarını fifo/lifo şeklinde sınıflandırınız: stack queue map priorityqueue fifo firs in first out ilk giren ilk çıkar. stack lifo queue fifo map lifo priorityqueue ikisi de deil. public class demo { public static void main(string[] args) { stack<integer> stack = new stack<>(); stack.push(10); stack.push(20); stack.push(30); system.out.println(stack.pop()); system.out.println(stack.peek()); system.out.println(stack.pop()); } } output? 30 10 public class test { public static void main(string[] args) { map<string, integer> scores = new hashmap<>(); scores.put(""alice"", 95); scores.put(""bob"", 85); scores.put(""charlie"", 90); scores.put(""alice"", 100); system.out.println(scores.get(""alice"")); system.out.println(scores.size()); } } output? 95 4 ara sınavdan yaklaşık hangi notu bekliyorsun (0-100)? 60🥀 4. sütun option 1 java gui uygulamalarında olayları yönetmek için bir programcının yapması gereken iki temel görev nedir? listener eklemek neden gui uygulamalarında system.exit(0) sıklıkla gerekli olurken, konsol uygulamalarında bu durum geçerli değildir? guide pencere açık kalabilio kapansa da gui tasarımında düzen yöneticilerinin (layout managers) amacı nedir ve bu yöneticiler geliştiricilere nasıl yardımcı olur? e o sayede design yapılır jframe'de setdefaultcloseoperation metodunun işlevini açıklayın. metotla close tuşuna basınca nolması gerektiği ayarlanır flowlayout ve gridlayout, bileşenleri düzenlemede nasıl farklılık gösterirler? bilmiyom aşağıdaki kodun çalışmasını izleyin ve jframe'de neyin görüntüleneceğini belirleyin: jframe frame = new jframe(""test""); frame.setsize(300, 200); frame.setlayout(new borderlayout()); jbutton northbutton = new jbutton(""north""); jbutton centerbutton = new jbutton(""center""); frame.add(northbutton, borderlayout.north); frame.add(centerbutton, borderlayout.center); northbutton.setvisible(false); frame.setvisible(true); centerbutton görülebilir bilmiom. aşağıdaki kod parçasını göz önünde bulundurun: import javax.swing.*; import java.awt.event.*; public class testframe extends jframe { public testframe() { settitle(""test""); setsize(300, 200); jbutton btn = new jbutton(""exit""); btn.addactionlistener(new actionlistener() { public void actionperformed(actionevent e) { system.out.println(""button clicked""); system.exit(0); } }); add(btn); setdefaultcloseoperation(jframe.exit_on_close); setvisible(true); } public static void main(string[] args) { new testframe(); } } kullanıcı ""exit"" düğmesine tıkladığında olaylar sırası nasıldır? çıkar bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class quiz1q1_221301009 { public static void main(string [] args) { string hey = ""a1b2""; combination(hey); } // a: 65 a: 97 static void combination(string str) { int numofletters=0; int[] indexes = new int[10]; int y=0; for(int i=0; i<str.length(); i++) { if(str.charat(i) >= 65 && str.charat(i) <= 97) { numofletters++; indexes[y] = i; y++; } } //amacım letter olan kaç tane char olduğunu ve bu charların indexlerini bulup recrsn fonksiyona götürmek system.out.print(""["" + combination_rec(str, 2^numofletters - 1, indexes) + ""]""); } //bu fonksiyonda da amacım harf sayısının 2 üzerili hali yani //toplam kombinasoyn sayısını buraya aktardıktan sonra //her bi kombinasyonu booleanlı bi hale dönüşütürerek //büyütüp küçülmeyi ayarlamayı sağlamaktı //mesela 2 karakter varsa numofletters=3 ile başlayacak //3 : 11 ile ikisini de değişicek sonra 2 : 10 sonra 1: 01 sonra 0: 00 ile //tüm olası büyütme küçültmeleri yapmaktı ama olmadı //bi de 3 harf ile sınırlandırdım malsef döngü ile total harf sayısı //yapılabilirdi ama sürem yetmedi static string combination_rec(string str, int numofletters, int[] index) { if(numofletters == 0) return """"; else return ""c""; string word = """"; boolean [] comb = new boolean[3]; comb[0] = (numofletters%2 == 1)? true:false; comb[1] = ((numofletters/2)%2 == 1)? true:false; comb[2] = ((numofletters/4)%2 == 1)? true:false; // bu comb değerleri bu iterasyonda hangi harfin değişmesi hangisinin // aynı kalması gerektiğini belirler int y=0; char c; for(int ind=0; ind<str.length(); ind++){ if(ind == index[0] || ind == index[1] || ind == index[2]){ if(comb[y] == true) { if(str.charat(ind) < 97) c=str.charat(ind) + 32; else c=str.charat(ind) - 32; // true ise değiş. } else c = str.charat(ind); //false ise aynı kal } else c = str.charat(ind); //harf değilse değişme ve word değişkenine bu charı al word = word + c; } // wordu ekrana yazdır diğer word için iterasyonu 1 azalt. return ""\"""" + word + ""\"""" + combination_rec(str, numofletters-1, index); } } import java.util.arraylist; public class quiz1q2_221301009 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public string getname() { return name; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int newbat) { this.batterylevel = newbat; } public boolean getoperational() { return isoperational; } public void setoperational(boolean newboolean) { this.isoperational = newboolean; } public void charge() { batterylevel = 100; isoperational = true; } robot() { name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } robot(string name, string type, int batterylevel) { this.name = name; this.type = type; this.batterylevel = batterylevel; isoperational = (batterylevel>0) ? true:false; } public void printrobot() { system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: %"" + batterylevel + "" is operational: "" + isoperational); } } class factory { private string name; private string location; private arraylist<robot> robots = new arraylist<robot>(); public factory(string name, string location) { this.name = name; this.location = location; } public factory() { name = ""factory1""; location = ""moon""; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getloc() { return location; } public void setloc(string loc) { this.location = loc; } public arraylist<robot> getrobots() { return robots; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for(i=0; i<robots.size(); i++) { robots.get(i).charge(); } } public void printfactory() { system.out.println(""factory name: "" + this.name + "" location: "" + this.location + ""\nrobots operating here:""); for(int i=0; i<robots.size(); i++) { robots.get(i).printrobot(); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public int getbatterylife() { return batterylife; } public void recharge() { batterylife=100; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.print(""\n""); //static method yazdım ??? sorusu için robotfactory.toplamroboturetimi(); } } public class securityrobot extends abstractrobot{ private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } public void performtask() { if(batterylife < 10) { system.out.println(""[""+modelname+ ""] not enough battery to scan threats...""); } else{ system.out.println(""[""+modelname+ ""] scanning for threats... armed: ""+ isarmed); batterylife -= 10; } } public void togglearmedmode() { isarmed = !isarmed; } // gerekiyordu public boolean getarmed() { return isarmed; } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; //gerekiyodu:) public int getcleaning() { return cleaningpower; } public void setcleaning(int miktar) { cleaningpower += miktar; } cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } public void performtask() { if(batterylife < 10) { system.out.println(""[""+modelname+ ""] not enough battery to clean...""); } else{ system.out.println(""[""+modelname+ ""] cleaning in progress... cleaning power: ""+ cleaningpower); batterylife -= 10; } } public void boostcleaningpower() { cleaningpower++; //?? arttırır yazmış anlamadım 1 tane artsın } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); static int toplam = 0; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { abstractrobot newrob = new cleaningrobot(modelname, batterylife, cleaningpower); robots.add(newrob); toplam++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { abstractrobot newrob = new securityrobot(modelname, batterylife, isarmed); robots.add(newrob); toplam++; } public void performalltasks() { for(abstractrobot robot: robots) { robot.performtask(); } } public void displayrobots() { for(abstractrobot robot: robots) { string type = (robot instanceof cleaningrobot) ? ""cleaningrobot"" : ""securityrobot""; string info = (robot instanceof cleaningrobot) ? ""cleaning power: "" + ((cleaningrobot)robot).getcleaning() : ""armed: "" + ((securityrobot)robot).getarmed(); system.out.println(type+ "" - model: ""+ robot.getmodelname()+ "", battery: ""+ robot.getbatterylife()+"", ""+info); } } //bunun için de ister istemez setter gerekiyor, ilgili yerde oluşturdum. public void upgradecleaningrobots(int miktar) { for(abstractrobot robot: robots) { if(robot instanceof cleaningrobot) { ((cleaningrobot)robot).setcleaning(miktar); system.out.println(""cleaningrobot - "" + robot.getmodelname() + "" now has cleaning power: "" + ((cleaningrobot)robot).getcleaning()); } } } public void togglesecurityrobotsmode() { for(abstractrobot robot: robots) { if(robot instanceof securityrobot) { ((securityrobot)robot).togglearmedmode(); string type = ((securityrobot)robot).getarmed() == true ? ""armed"": ""unarmed""; system.out.println(""securityrobot - "" + robot.getmodelname() + "" is now "" + type); } } } //??? sorusu //static int toplam ile class içinde herhangi bi objede herhangi bi robot oluşumunda saymayı sağladım public static int toplamroboturetimi() { system.out.println(""tum fabrikalar tarafindan toplam ""+ toplam + "" robot uretildi""); return toplam; } } envanter takip sistemi bil 211 - quiz 3 27 şubat 2025 1 giriş bu quizde, fileioveexceptions kullanarak basit bir envanter takip sistemi uygulaması geliştireceğiz. uygulama, interaktif bir terminal menüsü üzerinden, tek bir eşyanın ve stoğunun tutulduğu kayıtların yönetilmesini (eşya ekleme, çıkarma ve stok güncelleme) sağlayacaktır. ayrıca, envanter verileri sabit isimli bir dosyaya kaydedilebilecek ve bu dosyadan geri yüklenebilecektir. 2 genel program program konsol tabanlı bir kullanıcı arayüzü ile envanter takibi gerçekleştirmelidir. arayüz özellikleri aşağı- daki gibidir. -terminal menüsü: kullanıcıya aşağıdaki seçenekleri sunacaktır: – eşya ekleme: yeni bir eşya kaydı oluşturulur. her kayıt, eşya adı ve başlangıç stoğu bilgilerini içerir. eğer çoktan var olan bir eşya eklenmeye çalışılırsa program otomatik olarak önceki kaydın stoğunu güncellemelidir (yani aynı isimde iki kayıt oluşmamalı). – eşya çıkarma: mevcut envanterden istenilen eşya silinir. – stok güncelleme: kayıtlı bir eşyanın stoğu artırılabilir ya da azaltılabilir. i̇şlem sonucunda stok miktarı negatif olmamalıdır. – envanter listeleme: mevcut envanter kayıtları ekrana listelenir. – dosyaya kaydetme: güncel envanter verileri sabit isimli dosyaya kaydedilir. – dosyadan geri yükleme: daha önce kaydedilmiş envanter verileri dosyadan okunarak geri yüklenir. – çıkış: program sonlandırılır. 3envanterkaydi sınıfı değişkenler: -isim(private string) eşyanın adını tutar. -stok(private int) eşyanın stok miktarını tutar. metotlar: -public envanterkaydi(string isim, int stok) constructor; eşya adı ve stok miktarını başlatır. -public void stokguncelle(int miktar) stok miktarını günceller; negatif sonuç oluşmaması kontrol edilmelidir. - stokguncelle dışında ihtiyacınıza göre private değişkenler için getter ve setter tanımlayabilirsiniz. 4 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları (örn., bufferedreader , scanner,printwriter ) kullanacaktır. dosya işlemleri sırasında aşağıdaki hata durumları için uygun mesajlar verilmelidir: - dosya bulunamazsa: ""hata: envanter dosyası bulunamadı."" - dosya boşsa: ""hata: envanter dosyası boş."" 1 5 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program, hata kodu ile sonlanmalı ve ilgili hata mesajları stderr’e yazdırılmalıdır. 5.1 girdi hataları (inputexception class) dosya işlemleriyle ilgili hatalar için kendi tanımlayacağınız inputexception sınıfından türeyen özel hata sınıfları oluşturulacaktır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: envanter dosyası bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: envanter dosyası boş."" 5.2 envanter i̇şlemleri hataları envanter işlemleri sırasında oluşabilecek hatalar için aşağıdaki özel hata türleri tanımlanacaktır: -stoknegatifexception (extends exception) : stok güncelleme işlemi sonucunda, eşyanın stoğu negatif bir değere düşerse atılacak hata. - hata mesajı: ""hata: stok miktarı negatif olamaz."" -esyayokexception (extends exception) : çıkarma veya güncelleme işlemi yapılmak istenen eşya envanterde bulunmuyorsa atılacak hata. - hata mesajı: ""hata: i̇stenen eşya envanterde mevcut değil."" -ozellikhatasiexception (extends exception) : eşya ekleme sırasında girilen bilgilerde hata veya eksiklik varsa atılacak hata. - hata mesajı: ""hata: eşya bilgileri hatalı veya eksik."" 6 gönderim formatı - quizinizi bitirdiğinizde asistanlarınızdan birisine kodunuzu ve çıktısını gösterip puanlatın. - asistan labınızı puanladığında tüm kaynak dosyalarını ve bu dökümantasyonu bir arşiv dosyası (zip, rar, 7z, tar, tar.gz) halinde sıkıştırın. - arşiv dosyasının isim_numara formatında isimlendirin (örn., sebnemferah_181101014.zip). - i̇simlendirdiğiniz arşiv dosyasını uzak sistemindeki quiz alanına yükleyin. 2 import java.io.bufferedreader; import java.io.file; import java.io.filenotfoundexception; import java.io.fileoutputstream; import java.io.filereader; import java.io.printwriter; import java.util.arraylist; import java.util.scanner; //exception classları class stoknegatifexception extends exception { public stoknegatifexception() { super(""hata: stok miktarı negatif olamaz.""); } } class esyayokexception extends exception { public esyayokexception() { super(""hata: i̇stenen eşya envanterde mevcut değil.""); } } class ozellikhatasiexception extends exception { public ozellikhatasiexception() { super(""hata: eşya bilgileri hatalı veya eksik.""); } } class dosyabulunamadiexception extends exception { public dosyabulunamadiexception() { super(""hata: envanter dosyası bulunamadı.""); } } class bosdosyaexception extends exception { public bosdosyaexception() { super(""hata: envanter dosyası boş.""); } } public class quiz3_221301009 { public static void main (string[] args) throws dosyabulunamadiexception { arraylist<envanterkaydi> envanter = new arraylist<>(); boolean bitti_mi = false; scanner secimal = new scanner(system.in); while(!bitti_mi) { system.out.println(""termi̇nal\n""+ ""1-eşya ekle\n""+ ""2-eşya çıkar\n""+ ""3-stok güncelle\n""+ ""4-envanter listele\n""+ ""5-dosyaya kaydet\n""+ ""6-dosyadan geri yükle\n""+ ""7-çıkış\n""+ ""seçiminiz:"" ); int sec = secimal.nextint(); secimal.nextline(); string hedefesya; boolean var_mi = false; int index = -1; switch(sec) { case 1: string esyaname; int stok; system.out.print(""eşya adı giriniz:""); esyaname = secimal.nextline(); system.out.print(esyaname + "" başlangıç stoğu""); stok = secimal.nextint(); try { if (stok < 0) throw new ozellikhatasiexception(); boolean mevcut_kayit = false; for(envanterkaydi env : envanter) { if(env.getisim().equals(esyaname)) { env.stokguncelle(stok); mevcut_kayit = true; } } if(mevcut_kayit == false) { envanterkaydi yeni = new envanterkaydi(esyaname, stok); envanter.add(yeni); } } catch (ozellikhatasiexception | stoknegatifexception e) { system.err.println(e.getmessage()); } break; case 2: system.out.print(""silinecek eşya ismi:""); hedefesya = secimal.nextline(); var_mi = false; for (envanterkaydi env : envanter) { system.out.println(env.getisim() + ""?""); if(hedefesya.equals(env.getisim())) { var_mi = true; index = envanter.indexof(env); } } try { if (var_mi == false) throw new esyayokexception(); envanter.remove(index); } catch (esyayokexception e) { system.err.println(e.getmessage()); } break; case 3: system.out.print(""güncellenecek eşya:""); hedefesya = secimal.nextline(); system.out.print(""yeni stok:""); stok = secimal.nextint(); var_mi = false; for (envanterkaydi env : envanter) { if(hedefesya.equals(env.getisim())) { var_mi = true; index = envanter.indexof(env); } } try { if (index == -1) throw new esyayokexception(); else envanter.get(index).stokguncelle(stok); } catch (esyayokexception | stoknegatifexception e) { system.err.println(e.getmessage()); } break; case 4: for (envanterkaydi env : envanter) { system.out.println(env.getisim() + "" isimli eşya stoğu: "" + env.getstok()); } break; case 5: try (printwriter yazici = new printwriter(new fileoutputstream(""envanterlist.txt""))) { for (envanterkaydi env : envanter) { yazici.println(env.getisim() + "","" + env.getstok()); } system.out.println(""dosyaya kaydedildi""); } catch (filenotfoundexception e) { throw new dosyabulunamadiexception(); } break; case 6: try { file dosya = new file (""envanterlist.txt""); if (!dosya.exists()) throw new dosyabulunamadiexception(); string dizi; scanner oku = new scanner(dosya); if (!oku.hasnextline()) throw new bosdosyaexception(); while (oku.hasnextline()) { dizi = oku.nextline(); system.out.println(dizi); } } catch (filenotfoundexception e) { throw new dosyabulunamadiexception(); } catch (bosdosyaexception e) { system.err.println(e.getmessage()); } case 7: bitti_mi = true; break; } } } } class envanterkaydi { private string isim; private int stok; public envanterkaydi(string isim, int stok) throws ozellikhatasiexception{ this.isim = isim; if(stok<0) throw new ozellikhatasiexception(); this.stok = stok; } public void stokguncelle(int miktar) throws stoknegatifexception { if (miktar>=0) this.stok = miktar; else throw new stoknegatifexception(); } public string getisim() { return this.isim; } public int getstok() { return stok; } } bil211 quiz 4 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: undoablelist<t> adında bir sınıf oluşturun. bu sınıf, bir arraylist'i genişletmeli ve aşağıdaki ek özelliklere sahip olmalıdır: ● undolast() metodu, en son eklenen öğeyi kaldırmalıdır. ● getlastadded() → son eklenen öğeyi listeyi değiştirmeden döndürür. ● eğer liste boşsa, undolast() bir hata vermemeli, sadece hiçbir şey yapmamalıdır. örnek kullanım: undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] q2: aşağıdaki generic metodu tamamlayın. ● verilen bir collection<t> içinde minimum veya maksimum öğeyi bulan bir metod yazın. ● boolean parametresi true ise maksimumu, false ise minimumu döndürmelidir. ● t öğeleri comparable<t> arabirimini uygulamalıdır. public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { // metodu tamamlayın } örnek kullanım: list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) q3: belirli türdeki elemanları filtreleme ● bir collection<?> içindeki belirli bir türdeki öğeleri filtreleyen bir generic metod yazın. ● class<t> tür filtresi olarak kullanılmalıdır. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { // metodu tamamlayın } örnek kullanım: list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] import java.util.arrays; import java.util.collection; import java.util.list; public class question2 { public static void main(string[] args) { list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) //ben ekledim. list<string> isimler = arrays.aslist(""eren"",""semra"",""bülent"",""nebi"",""ico"",""resat""); system.out.println(""\nkendi deneme listem\nisimler listesinde minimum: ""+findextreme(isimler, false)); system.out.println(""isimler listesinde maximum: ""+findextreme(isimler, true)); } public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { t answer = null; for(t any:collection) { if(answer==null) answer = any; if (any.compareto(answer) < 0 && !findmax || any.compareto(answer) > 0 && findmax) { answer = any; } } return answer; } } import java.util.arraylist; public class question1 { public static void main(string[] args) { undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); system.out.println(""son eklenen: ""+list.getlastadded()); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] } } class undoablelist<t> extends arraylist<t>{ public void undolast() { try{ this.remove(this.size()-1); } catch (exception e) { } } public t getlastadded() { return this.get(this.size()-1); } } import java.util.arraylist; import java.util.arrays; import java.util.collection; import java.util.list; public class question3 { public static void main(string[] args) { list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(""qui̇z dosyasindaki̇ çikti\n""+filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] list<number> karisik = arrays.aslist(1,(2.3),(3.8),5,-1,(0.6)); system.out.println(""\nbeni̇m yazdığım deneme çıktısı\nonly integers: ""+ filterbytype(karisik, integer.class)); system.out.println(""only doubles: ""+ filterbytype(karisik, double.class)); } public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { list<t> newlist = new arraylist<>(); //""?"""" yerine ne kullandığımızı unuttuğum için collectionu direkt //object üzerinden döndürdüm sanki başka bişi yapıyoduk da //bu haliyle doğru çalışıyo ama type safety uyarısı veriyor sadece for(object any : collection) { if(any.getclass() == type) { newlist.add((t)any); } } return newlist; } } 2 kuş bakışı atış oyunu (top-down shooter) bil 211 - proje teslim tarihi: 27 mart 2025 23:59 1 amaç bu ödevde amacınız, java swing kullanarak kuş bakışı bir atış oyunu (top-down shooter) tasarlamaktır. oyunda, yönettiğimiz karakterin üzerine dalga dalga gelen çeşitli zombileri fare ile hedef alarak farklı silahlar kullanıp öldürmemiz gerekmektedir. karakterimiz öldüğünde oyun sona erecektir. her dalga başına ve öldürülen zombi başına kazanılan puan artacaktır. dalgalar ilerledikçe gelen zombilerin sayısı ve çeşitleri artarak zorluk seviyesi yükselecektir. 2 gereksinimler oyun derste öğrendiğiniz oop ilkelerine uygun sınıf/arayüz tasarımları ile geliştirilmelidir. - zorluk seviyesi arttıkça zombi sayısı ve çeşitliliği artmalıdır. - oyun duraklatılabilmeli ve kaydedilip tekrar yüklenilebilmelidir (fileio kullanılmalıdır). - sol üst köşede seçili silah ve kalan mermi miktarı gösterilmelidir. - sağ üst köşede oyuncunun canı ve toplam puanı gösterilmelidir. - oyunun duraklatılması, kaydedilmesi ve devam ettirilmesi için bir menü bulunmalıdır. 3 silahlar oyunda farklı silahlar bulunmaktadır. belirli zombi dalgaları temizlendikten sonra oyun ödül olarak yeni bir silahverecektir. hersilahınkendineözgübirçalışmamekanizmasıvardır. silahlarınşarjörkapasitesisınırlıdır ve şarjördeki mermiler bittiğinde tekrar doldurulmadan ateş edilemez. toplam mermi sayısı oyuncunun o silaha ait elinde ne kadar mermi olduğunu gösterir. r tuşuna basarak şarjör yeniden doldurulabilir. 3.1 tabanca - şarjör kapasitesi: 12 mermi - ateş hızı: 120 mermi/dakika - elde etme: oyuncu oyuna bu silahla başlar. - özellik: düz atış yapar, sapma yoktur. sınırsız yedek şarjör (diğer tüm silahlar için yedek şarjör ve mermiler rastgele bir şekilde dalga sırasında ve sonlarında zombilerden düşer). 3.2 piyade tüfeği - şarjör kapasitesi: 30 mermi - ateş hızı: 600 mermi/dakika - elde etme: 1. dalga tamamlandıktan sonra - özellik: düzatışyaparancak30derecesapmasıvardır. sapmaaçısı, karakterinbaktığıyöndemerminin her iki dönme yönüne de saçılabileceği maksimum açıdır. 1 3.3 pompalı tüfek - şarjör kapasitesi: 5 mermi - ateş hızı: 60 mermi/dakika - elde etme: 3. dalga tamamlandıktan sonra - özellik: her atış 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi atar (yani karakter merkezli mermi hız vektörleri arasında 5 derece açı olmalıdır). 3.4 keskin nişancı tüfeği - şarjör kapasitesi: 5 mermi - ateş hızı: 30 mermi/dakika - elde etme: 5. dalga tamamlandıktan sonra - özellik: mermileri zombileri delip arasındaki zombilere de hasar verir. 3.5 roketatar - şarjör kapasitesi: 1 roket - ateş hızı: 10 roket/dakika - elde etme: 10. dalga tamamlandıktan sonra - özellik: patlama etkisiyle birden fazla zombiye zarar verir. 4 zombiler zombiler oyundaki düşman tipleridir. zombiler oyuncuya doğru ilerlerler ve eğer oyuncuya temas ederlerse oyuncuya hasar verirler. zorluk seviyesi arttıkça zombilerin sayısı ve çeşitliliği artmaktadır. zombi tipleri birbirinden renk ya da şekil olarak ayırt edilebilmelidir. 4.1 normal zombi - can: orta - hız: yavaş - hasar: orta 4.2 sürünge zombi - can: düşük - hız: hızlı - hasar: orta - özellik: oyuncunun yakınına geldiğinde zıplar. 4.3 tank zombi - can: yüksek - hız: çok yavaş - hasar: yüksek 2 4.4 asit tüküren zombi - can: düşük - hız: yavaş - hasar: orta (uzaktan asit tükürebilir) - özellik: öldürüldüğünde yanındaki birimlere zarar verir. 5 rapor ve teslim formatı - oyun, oopprensiplerineuygunolaraktasarlanmalıvesınıfdiyagramları, arayüztasarımıfinalraporda sunulmalıdır. - oyun test edilerek ekran görüntüleri rapora eklenmelidir. - rapor pdf formatında olmalı ve ismi proje_rapor.pdf olmalıdır. - oyunun mainfonksiyonu gameisimli bir sınıf içinde bulunmalıdır ( java game komutuyla çalışmalı). - kaynak kodun tamamı source.zip (uzantı 7z, rar, tar.gz de olabilir) şeklinde sıkıştırılmış olmalıdır. - sıkıştırılmış kaynak kod ve rapor uzak sistemine yüklenmelidir. 6 yardımcı kaynaklar dahaöncehiçkuşbakışıatışoyunuoynamadıysanızaşağıdakioyunlarıreferansolarakalabilirsiniz. buradaki oyunlarıngrafikleriilemekaniklerisizdenbeklenendenfarklıolsadaharitatasarımı, karakterhareketi,kamera hareketi, ateş etme mekanikleri ve zombilerin yapay zekası ile ilgili temel fikirler edinebilirsiniz. - little top-down shooter: https://www.youtube.com/watch?v=pj3m3fu3i5a - super c - stage 2: https://www.youtube.com/watch?v=os2t_v5suj4 - neon chrome: https://www.youtube.com/watch?v=puhw1bevtro 3 import java.io.serializable; public class gamesave implements serializable{ //bu classtan açılacak obje ile oyunda kaydedilmesi gereken her şey alıncak //sonra dosyaya yazdırılcak //kameranın konumu public camera camera; public player player; //main-static player (entities içinde var ama tek başına da çok kullandım kolaylık sağladığından) public double playerhealth; public int playerscore; //dalga boolean değerleri public boolean[] dalga; //handler public handler handler; //hangi turda, turun hangi spawner indisinde kaldık public int tour, zombieindex; //silahla alakalı bilgiler public guntype guntype; //dosyadan okurken type'a göre hızlıca silahı modifiye edeceğiz } import java.awt.rectangle; import java.util.arraylist; import java.util.list; public abstract class zombie extends gameobject { protected handler handler; protected gameobject player; protected int health; protected int attack; protected long shoottime=0; protected long jumptime=0; protected boolean isjumping = false; public zombie(int x, int y, entitytype type, handler handler) { super(x, y, type); this.handler = handler; this.player = getplayer(); } private gameobject getplayer() { for (int i=0; i < handler.entities.size(); i++) { gameobject tempgameobject = handler.entities.get(i); if (tempgameobject.gettype() == entitytype.player) { return tempgameobject; } } return null; } @override public void tick() { if (player != null) { if (health <= 0) { //asit tüküren zombi ölünce etraftaki zombilerin //canını 2 azaltır - duvarları siler //oyuncu canını da 50 azaltır eğer o alandaysa if(this instanceof zombieasitli){ rectangle etkialani = new rectangle( this.getx()-60, this.gety()-60, 120, 120 ); double random = math.random(); if(random < 0.25 && player.gun.type != guntype.tabanca) { handler.addentity(new yedeksarjor(this.getx(), this.gety(), entitytype.yedeksarjor)); } list<gameobject> silinecekler = new arraylist<>(); silinecekler.add(this); for(int j=0; j<handler.entities.size(); j++) { gameobject temp = handler.entities.get(j); if(temp instanceof zombie && temp.getbounds().intersects(etkialani)) { ((zombie)temp).sethealth(((zombie)temp).gethealth() - 3); } else if(temp instanceof player && temp.getbounds().intersects(etkialani)) { player.sethealth(player.gethealth() - 30); } else if(temp.gettype() == entitytype.block && temp.getbounds().intersects(etkialani)) { silinecekler.add(temp); } } for(gameobject sil : silinecekler) { handler.removeentity(sil); if(sil instanceof zombie) player.setscore(player.getscore() + 5); } handler.addentity(new bombeffect(this.getx() - 60, this.gety() - 60, entitytype.asitlizombiefekt , 120, 120, 60, handler)); } else { double random = math.random(); if(random < 0.25 && player.gun.type != guntype.tabanca) { handler.addentity(new yedeksarjor(this.x, this.y, entitytype.yedeksarjor)); } handler.removeentity(this); player.setscore(player.getscore() + 5); } } int playerx = player.getx(); int playery = player.gety(); collision.checksomecollision(this, handler); double diffx = playerx - x; double diffy = playery - y; double distance = math.sqrt(diffx * diffx + diffy * diffy); //asit tüküren zombinin asit tükürmesi if(this instanceof zombieasitli) { long currenttime = system.currenttimemillis(); if(currenttime - shoottime > 1000) { shoottime = system.currenttimemillis(); handler.addentity(new acyd(this.getx(), this.gety(), entitytype.asit, handler, ((player)player))); } } //sürünge zombiler 230 mesafeden sonra oyuncunun sırtına atlar //sonra kaçabiliriz, bir süre sonra tekrar atlar long currenttime = system.currenttimemillis(); if (this instanceof zombiesurunge && distance <= 230 && distance >= 30) { if (!isjumping && currenttime - jumptime > 3500) { //3,5 saniye yeniden atlamak için güç toplar jumptime = currenttime; isjumping = true; } if (isjumping && currenttime - jumptime < 400) { speed_x = (int) ((diffx / distance) * getspeed() * 3.75); speed_y = (int) ((diffy / distance) * getspeed() * 3.75); } else if (isjumping) { isjumping = false; jumptime = currenttime; } } else { speed_x = (int) ((diffx / distance) * getspeed()); speed_y = (int) ((diffy / distance) * getspeed()); } x += speed_x; y += speed_y; } } protected abstract double getspeed(); public int gethealth() { return health; } public void sethealth(int health) { this.health = health; } public int getattack() { return attack; } public void setattack(int attack) { this.attack = attack; } } import java.awt.graphics; import java.awt.rectangle; import java.awt.color; public class zombietank extends zombie{ public zombietank(int x, int y, entitytype type, handler handler) { super(x, y, type, handler); health = 5; attack = 4; } @override protected double getspeed() { return 2.0; } @override public void render(graphics g) { g.setcolor(new color(70,70,40,230)); g.fillrect(x, y, 40, 40); } @override public rectangle getbounds() { return new rectangle(x,y,40,40); } } import java.awt.graphics; import java.awt.rectangle; import java.awt.color; public class zombiesurunge extends zombie{ public zombiesurunge(int x, int y, entitytype type, handler handler) { super(x, y, type, handler); health = 2; attack = 2; } @override protected double getspeed() { return 4.0; } @override public void render(graphics g) { g.setcolor(new color(158,0,3,230)); g.filloval(x, y, 32, 32); } @override public rectangle getbounds() { return new rectangle(x,y,32,32); } } import java.awt.color; import java.awt.graphics; import java.awt.rectangle; public class bombeffect extends gameobject { private int duration; private handler handler; public bombeffect(int x, int y, entitytype type, int width, int height, int duration, handler handler) { super(x, y, type); this.width = width; this.height = height; this.duration = duration; this.handler = handler; } @override public void tick() { duration--; if (duration <= 0) { handler.removeentity(this); } } @override public void render(graphics g) { if(type == entitytype.asitlizombiefekt) g.setcolor(new color(0, 255, 0, 80)); else if(type == entitytype.roketatarefekt) g.setcolor(new color(255, 80, 30, 80)); g.fillrect(x, y, width, height); } @override public rectangle getbounds() { return new rectangle(x, y, width, height); } } import java.awt.color; import java.awt.graphics; import java.awt.rectangle; public class bullet extends gameobject { private handler handler; private double bulletspeed; private double angle; public bullet(int x, int y, entitytype type, handler handler, double angle) { super(x, y, type); this.handler = handler; this.angle = angle; this.bulletspeed = player.gun.speed; } @override public void tick() { x += bulletspeed * math.cos(angle); y += bulletspeed * math.sin(angle); for(int i = 0; i<handler.entities.size(); i++) { gameobject anyobject = handler.entities.get(i); if(anyobject instanceof block) { if(getbounds().intersects(anyobject.getbounds())){ handler.removeentity(this); if(player.gun.type == guntype.roketatar) { rectangle etkialani = new rectangle( anyobject.getx()-75, anyobject.gety()-75, 150, 150 ); for(int j=0; j<handler.entities.size(); j++) { gameobject temp = handler.entities.get(j); if(temp instanceof zombie && temp.getbounds().intersects(etkialani)) { ((zombie)temp).sethealth(((zombie)temp).gethealth() - 3); } else if(temp.gettype() == entitytype.block && temp.getbounds().intersects(etkialani)) { handler.removeentity(temp); } } handler.addentity(new bombeffect(anyobject.getx()-75, anyobject.gety()-75, entitytype.roketatarefekt, 150, 150, 60, handler)); } } } } } @override public void render(graphics g) { g.setcolor(color.black); g.filloval(x, y, 8, 8); } @override public rectangle getbounds() { return new rectangle(x, y, 8,8); } } import java.awt.graphics; import java.awt.rectangle; import java.awt.color; public class yedeksarjor extends gameobject{ public yedeksarjor(int x, int y, entitytype type) { super(x, y, type); } @override public void render(graphics g) { g.setcolor(new color(79,158,138,200)); g.fillrect(x, y, 20, 30); } @override public rectangle getbounds() { return new rectangle(x,y,20,30); } @override public void tick() { //boş hareketsiz çünkü } } import java.awt.color; import java.awt.graphics; import java.awt.rectangle; public class zombieasitli extends zombie { public zombieasitli(int x, int y, entitytype type, handler handler) { super(x, y, type, handler); health = 2; attack = 2; } @override protected double getspeed() { return 3.0; } @override public void render(graphics g) { g.setcolor(new color(39,100,42,230)); g.filloval(x, y, 32, 32); } @override public rectangle getbounds() { return new rectangle(x,y,32,32); } } public enum guntype{ tabanca, piyade, pompali, keskinnisanci, roketatar } import java.awt.color; import java.awt.graphics; import java.awt.rectangle; public class block extends gameobject{ int width = 32; int height = 32; public block(int x, int y, entitytype type) { super(x, y, type); } @override public void tick() { //boş } @override public void render(graphics g) { g.setcolor(new color(123, 98, 145,205)); g.fillrect(x, y, 32, 32); } @override public rectangle getbounds() { return new rectangle(x, y, 32,32); } } import java.awt.rectangle; public class collision { public static void checksomecollision(gameobject entity, handler handler) { if(!(entity instanceof player || entity instanceof zombie)) return; for (int i = 0; i < handler.entities.size(); i++) { gameobject anyobject = handler.entities.get(i); if (anyobject.gettype() == entitytype.block || anyobject.gettype() == entitytype.kirilmazblock) { rectangle blockbounds = anyobject.getbounds(); rectangle entitybounds = entity.getbounds(); boolean yataycollision = false; rectangle nextybounds = new rectangle( entitybounds.x, entitybounds.y + (int)entity.getspeed_y(), entitybounds.width, entitybounds.height ); rectangle nextxbounds = new rectangle( entitybounds.x + (int)entity.getspeed_x(), entitybounds.y, entitybounds.width, entitybounds.height ); if (nextybounds.intersects(blockbounds)) { yataycollision = true; //çarpışmaların karışmaması için if (entity.getspeed_y() > 0) { entity.sety(blockbounds.y - entitybounds.height - 5); } else if (entity.getspeed_y() < 0) { entity.sety(blockbounds.y + blockbounds.height + 5); } entity.setspeed_y(0); } if (!yataycollision) { if (nextxbounds.intersects(blockbounds)) { if (entity.getspeed_x() > 0) { entity.setx(blockbounds.x - entitybounds.width - 5); } else if (entity.getspeed_x() < 0) { entity.setx(blockbounds.x + blockbounds.width + 5); } entity.setspeed_x(0); } } } if (anyobject.gettype() == entitytype.bullet && entity instanceof zombie) { zombie tempzombie = (zombie)entity; if(entity.getbounds().intersects(anyobject.getbounds())) { //keskin nişancı için mermi yok edilmez, //merminin değdiği zombiler büyük hasar alır hepsi direkt ölür //mermi aynı güçte ilerler varsayımı if(player.gun.type != guntype.keskinnisanci) { handler.removeentity(anyobject); player.setscore(player.getscore() + 5); } else{ ((zombie)entity).sethealth(((zombie)entity).gethealth() - 5); player.setscore(player.getscore() + 5); } if(player.gun.type == guntype.roketatar) { tempzombie.sethealth(tempzombie.gethealth() -3); player.setscore(player.getscore() + 3); //mermi kimin kafasına geldiyse ona 3 hasar //patlamanın etki edeceği alan rectangle etkialani = new rectangle( anyobject.getx()-100, anyobject.gety()-100, 200, 200 ); for(int j=0; j<handler.entities.size(); j++) { gameobject temp = handler.entities.get(j); if(temp instanceof zombie && temp.getbounds().intersects(etkialani)) { ((zombie)temp).sethealth(((zombie)temp).gethealth() - 2); //alandaki her zombiye ikişer hasar player.setscore(player.getscore() + 2); } else if(temp.gettype() == entitytype.block && temp.getbounds().intersects(etkialani)) { handler.removeentity(temp); } } handler.addentity(new bombeffect(anyobject.getx()-100, anyobject.gety()-100, entitytype.roketatarefekt, 200, 200, 60, handler)); } else { tempzombie.sethealth(tempzombie.gethealth() - 1); player.setscore(player.getscore() + 1); } } } if (anyobject.gettype() == entitytype.asit && entity instanceof player) { if(entity.getbounds().intersects(anyobject.getbounds())) { handler.removeentity(anyobject); player.sethealth(player.gethealth() - 8); } } if (entity instanceof player && anyobject instanceof zombie) { if(entity.getbounds().intersects(anyobject.getbounds())) { player.sethealth(player.gethealth() - 0.01 * ((zombie)anyobject).getattack()); } } if (anyobject.gettype() == entitytype.yedeksarjor && entity instanceof player) { if(entity.getbounds().intersects(anyobject.getbounds())) { player.gun.yedeksarjor++; handler.removeentity(anyobject); } } } } } import java.awt.event.keyadapter; import java.awt.event.keyevent; public class keyboardinput extends keyadapter{ handler handler; static long reloadcurrenttime; public keyboardinput(handler handler) { this.handler = handler; } public void keypressed(keyevent e) { int key = e.getkeycode(); if(key == keyevent.vk_r) { reloadcurrenttime = system.currenttimemillis(); handler.fillthemagazine(); } if(key == keyevent.vk_w) handler.setup(true); if(key == keyevent.vk_a) handler.setleft(true); if(key == keyevent.vk_d) handler.setright(true); if(key == keyevent.vk_s) handler.setdown(true); } public void keyreleased(keyevent e) { int key = e.getkeycode(); for(int i=0; i < handler.entities.size() ; i++) { gameobject temp = handler.entities.get(i); if (temp.gettype() == entitytype.player) { if(key == keyevent.vk_w) handler.setup(false); if(key == keyevent.vk_a) handler.setleft(false); if(key == keyevent.vk_d) handler.setright(false); if(key == keyevent.vk_s) handler.setdown(false); } } } } import java.util.linkedlist; import java.awt.graphics; import java.io.serializable; public class handler implements serializable{ linkedlist<gameobject> entities = new linkedlist<gameobject>(); private boolean up = false, down = false, right = false, left = false; public void fillthemagazine() { if(player.gun.yedeksarjor <= 0 && player.gun.type != guntype.tabanca) { mouseinput.isreloading = false; return; } mouseinput.isreloading = true; player.setmagazine(player.getmax_magazine()); player.gun.yedeksarjor--; } public void tick() { for(int i=0; i<entities.size(); i++) { entities.get(i).tick(); } } public void render(graphics g) { for(int i=0; i<entities.size(); i++) { entities.get(i).render(g); } } public void addentity(gameobject newobj) { entities.add(newobj); } public void removeentity(gameobject entity) { entities.remove(entity); } public boolean isup() { return up; } public void setup(boolean set) { this.up = set; } public boolean isdown() { return down; } public void setdown(boolean set) { this.down = set; } public boolean isright() { return right; } public void setright(boolean set) { this.right = set; } public boolean isleft() { return left; } public void setleft(boolean set) { this.left = set; } } import java.awt.color; import java.awt.graphics; import java.awt.rectangle; public class zombienormal extends zombie{ public zombienormal(int x, int y, entitytype type, handler handler) { super(x, y, type, handler); health = 3; attack = 2; //orta sağlık orta hasar } @override protected double getspeed() { return 3.0; } @override public void render(graphics g) { g.setcolor(new color(76,92,75,230)); g.filloval(x, y, 32, 32); } @override public rectangle getbounds() { return new rectangle(x,y,32,32); } } import java.awt.image.bufferedimage; import java.io.ioexception; import javax.imageio.imageio; public class bufferedimageloader { private bufferedimage image; public bufferedimage loadimage(string path) { try { image = imageio.read(getclass().getresource(path)); } catch (ioexception e) { e.printstacktrace(); } return image; } } import javax.sound.sampled.*; import java.io.bufferedinputstream; import java.io.ioexception; import java.io.inputstream; //sesi çekebilmek için internetten fazlasıyla yararlandım. public class soundplayer { private clip clip; public soundplayer(string filepath) { try { inputstream audiosrc = getclass().getresourceasstream(filepath); if (audiosrc == null) { throw new illegalargumentexception(""ses dosyası bulunamadı!""); } audioinputstream audiostream = audiosystem.getaudioinputstream(new bufferedinputstream(audiosrc)); clip = audiosystem.getclip(); clip.open(audiostream); } catch (unsupportedaudiofileexception | ioexception | lineunavailableexception e) { e.printstacktrace(); } } public void play() { if (clip != null) { clip.setframeposition(0); clip.start(); } } public void loop() { if (clip != null) { clip.loop(clip.loop_continuously); } } public void stop() { if (clip != null) { clip.stop(); } } } import java.awt.color; import java.awt.graphics; import java.awt.graphics2d; import java.awt.image.bufferstrategy; import java.awt.image.bufferedimage; import java.io.fileinputstream; import java.io.ioexception; import java.io.objectinputstream; import javax.swing.joptionpane; import java.awt.font; import java.awt.canvas; public class game extends canvas implements runnable{ public boolean isrunning = false; public thread thread; private handler handler; private camera camera; private bufferedimage map = null; public static player player; public keyboardinput ki; public mouseinput mi; public boolean issong = false; private boolean [] dalga = new boolean[12]; public static boolean dalgabittiyazisi; public static int tour = 0; public static int zombieindex = 0; public player.gun silah; public game() { soundplayer thedinermusic = new soundplayer(""/res/thedinermusic.wav""); thedinermusic.loop(); issong = true; handler = new handler(); camera = new camera(0, 0); new window(1000, 563, ""thediner"", this, thread, thedinermusic); bufferedimageloader loader = new bufferedimageloader(); map = loader.loadimage(""/res/thediner_map.png""); loadmap(map); start(); player = new player(100, 100, entitytype.player, handler); handler.addentity(player); silah = new player.gun(); ki = new keyboardinput(handler); mi = new mouseinput(handler, camera, this, player); //load esnasında bunların silinebilmesi için ki mi olarak tuttum this.addkeylistener(ki); this.addmouselistener(mi); this.addmousemotionlistener(mi); for (; tour < 12; tour++) { dalga[tour] = true; if (tour == 0) player.gun.setgun(guntype.tabanca); else if (tour == 1) { //nedenini bilmediğim bi şekilde silahı piyade olarak set etmeme rağmen //ilk mermi atışlarında hız güncellenmiyodu //senkronize etmeyle alakalı bir şeydi ama bulamadım problemimi //bu yüzden bu kısımda manuel olarak atış hızını da güncelledim ve düzeldi //diğer silah geçişlerde hiçbir sıkıntı yok bu geçişte neden oldu bilmiyorum.. mouseinput.magazine_period = 60*1000/600; player.gun.setgun(guntype.piyade); } else if (tour == 3) player.gun.setgun(guntype.pompali); else if (tour == 5) player.gun.setgun(guntype.keskinnisanci); else if (tour == 10) player.gun.setgun(guntype.roketatar); int zombiecount = 8 + (int) (tour * 1.1); //zombi sayısı artsın int sleeptime = math.max(600, 1200 - (tour * 60)); //sleeping düşsün for (; zombieindex< zombiecount; zombieindex++) { try { thread.sleep(sleeptime); } catch (interruptedexception e) { e.printstacktrace(); } if (zombieindex%4 == 3) { handler.addentity(new zombiesurunge(1080, 300, entitytype.surungezombi, handler)); } else if (zombieindex%4 == 1) { handler.addentity(new zombieasitli(600, 550, entitytype.asittukurenzombi, handler)); if (tour >= 3) handler.addentity(new zombietank(600, 350, entitytype.tankzombi, handler)); } else if (zombieindex%4 == 0){ handler.addentity(new zombienormal(530, 548, entitytype.normalzombi, handler)); } else { if(tour>4 && tour%16 == 1) handler.addentity(new zombieasitli(1200, 850, entitytype.asittukurenzombi, handler)); else if(tour>4 && tour%16 == 3) handler.addentity(new zombiesurunge(1200, 850, entitytype.surungezombi, handler)); } if (tour >= 3 && zombieindex%16 == 4) { //tank zombiler daha da gelmeye başlasın handler.addentity(new zombietank(650, 360-(tour*6), entitytype.tankzombi, handler)); } } while (dalga[tour]) { try { thread.sleep(1000); } catch (interruptedexception e) { e.printstacktrace(); } boolean zombivarmi = false; for (int i = 0; i<handler.entities.size();i++) { gameobject e = handler.entities.get(i); if (e instanceof zombie) { zombivarmi = true; break; } } if (!zombivarmi) { if (dalga[11] == true){ joptionpane.showmessagedialog(null, ""12 turu da başarıyla tamamladın! toplam skor: "" + player.getscore(), ""you ate"", joptionpane.plain_message); system.exit(0); } break; } } zombieindex = 0; dalgabittiyazisi = true; try { thread.sleep(3000); //3 sn ara } catch (interruptedexception e) { e.printstacktrace(); } dalga[tour] = false; dalgabittiyazisi = false; } } public void resumegame() { isrunning = true; } void start() { isrunning = true; thread = new thread(this); thread.start(); } private void stop() { isrunning = false; try { thread.join(); } catch (interruptedexception e) { e.printstacktrace(); } } @override public void run() { handler.setdown(false); handler.setleft(false); handler.setright(false); handler.setup(false); this.requestfocus(); long lasttime = system.nanotime(); int fps = 60; double ns = 1000000000 / (double)fps; double delta = 0; long timer = system.currenttimemillis(); @suppresswarnings(""unused"") int frames = 0; while(isrunning) { long now = system.nanotime(); delta += (now - lasttime) / ns; lasttime = now; while(delta >= 1) { tick(); delta--; } render(); frames++; if(system.currenttimemillis() - timer > 1000) { timer += 1000; frames = 0; } } stop(); } public void tick() { camera.tick(player); //kamera kayması handler.tick(); //tüm varlıklar için tick } public void render() { bufferstrategy bs = this.getbufferstrategy(); if (bs == null) { this.createbufferstrategy(3); return; } graphics g = bs.getdrawgraphics(); graphics2d g2d = (graphics2d) g; //draw draaw draaw g.setcolor(new color(225, 225, 235, 240)); g.fillrect(0, 0, 1000, 563); g2d.translate(-camera.getx(), -camera.gety()); handler.render(g); g2d.translate(camera.getx(), camera.gety()); string healthtext = ""toplam kalan can: "" + string.format(""%.1f"", player.gethealth()); string scoretext = ""toplam skor: "" + player.getscore(); string yedektext = ""yedek şarjörün: ""; string reloadingwarntext = ""şarjör deği̇şti̇ri̇li̇yor...""; string dalgawarn = ""zombi dalga""; string dalgabittiwarn = ""tebrikler, sonraki dalga için hazırlan!""; g.setcolor(color.black); g.setfont(new font(""arial"", font.bold, 18)); int padding = 10; g.drawstring(healthtext, getwidth() - g.getfontmetrics().stringwidth(healthtext) - padding, 20); g.drawstring(scoretext, getwidth() - g.getfontmetrics().stringwidth(scoretext) - padding, 50); g.drawstring(""elindeki silah: "" + player.gun.type.tostring() + "" /// şarjör: "" + player.getmagazine(), padding, 20); if(player.gun.type == guntype.tabanca) { g.drawstring(yedektext + ""sınırsız!"", padding, 50); } else { g.drawstring(yedektext + + player.gun.yedeksarjor + "" adet"", padding, 50); } //şarjör değiştirme yazısı ayarları long currenttime = system.currenttimemillis(); if (currenttime - keyboardinput.reloadcurrenttime < 1000) mouseinput.isreloading = true; else mouseinput.isreloading = false; if(mouseinput.isreloading && (player.gun.yedeksarjor > 0 || player.gun.type == guntype.tabanca)) g.drawstring(reloadingwarntext, padding, 80); else if(player.gun.yedeksarjor <= 0 && player.gun.type != guntype.tabanca) g.drawstring(""reload yapılamaz..."", padding, 80); //ateş için hazırlanma süresi uyarısı //piyade ve tabanca için yazmasını istemedim, hızlılar zaten if (currenttime - mouseinput.lastshottime < mouseinput.magazine_period) mouseinput.istime = true; else mouseinput.istime = false; if (mouseinput.istime /*&& player.gun.type != guntype.piyade && player.gun.type != guntype.tabanca*/) g.drawstring(""ateş etmek için "" + (mouseinput.magazine_period - (double)(currenttime - mouseinput.lastshottime))/1000+ "" saniye daha bekle. "", padding, 100); g.setfont(new font(""arial"", font.bold | font.italic, 21)); padding = 450; for(int i=0;i<dalga.length;i++) { if(dalgabittiyazisi) { g.drawstring(dalgabittiwarn, getwidth() - g.getfontmetrics().stringwidth(scoretext) - padding + 20, 30); if(dalga[0] || dalga[2] || dalga[4] || dalga[9]) { g.drawstring(""kullandığın silah güncellendi."", getwidth() - g.getfontmetrics().stringwidth(scoretext) - padding + 20, 60); } } else if(dalga[i]) { g.drawstring(dalgawarn+"" ""+(i+1), getwidth() - g.getfontmetrics().stringwidth(scoretext) - padding + 60, 30); } } //draw drawwwwwwwwww biti g.dispose(); bs.show(); } private void loadmap(bufferedimage image) { int weight = image.getwidth(); int height = image.getheight(); for(int w=0; w<weight; w++) { for(int h=0; h<height; h++) { int pixel = image.getrgb(w, h); int red = (pixel >> 16) & 0xff; int green = (pixel >> 8) & 0xff; int blue = (pixel) & 0xff; if(red == 255 && green == 0 && blue == 0) handler.addentity(new block(w*32, h*32, entitytype.block)); if(red == 255 && green == 100 && blue == 0) { handler.addentity(new block(w*32, h*32, entitytype.kirilmazblock)); } } } } public static void main(string[] args) { new game(); } void readdatastosave(gamesave newsave) { newsave.player = game.player; newsave.camera = camera; newsave.playerhealth = player.gethealth(); newsave.playerscore = player.getscore(); newsave.dalga = dalga; newsave.handler = handler; newsave.tour = game.tour; newsave.zombieindex = game.zombieindex; newsave.guntype = player.gun.type; } gamesave saveddatastoimply() { try (objectinputstream ois = new objectinputstream(new fileinputstream(""oyunkaydi.ser""))) { return (gamesave) ois.readobject(); } catch (classnotfoundexception e) { system.out.println(""kaydedilmis dosya yok.""); return null; } catch (ioexception e) { e.getmessage(); return null; } } void updatedatas(gamesave kayitli) { game.player = kayitli.player; try{ player.loadplayericon(); } catch (exception e) { system.out.println(""player görüntüsü yüklenemedi, kırmızı kutu olarak devam et""); } camera = kayitli.camera; player.sethealth(kayitli.playerhealth); player.setscore(kayitli.playerscore); dalga = kayitli.dalga; handler = kayitli.handler; handler.setdown(false); handler.setleft(false); handler.setright(false); handler.setup(false); //gereksiz hareketleri önlemesi için handlerdaki değerleri false ladık. this.removekeylistener(ki); this.removemouselistener(mi); this.removemousemotionlistener(mi); //tüm listenerleri silip yeni handler ve player için tekrardan ekliyorum ki = new keyboardinput(handler); mi = new mouseinput(handler, camera, this, player); this.addkeylistener(ki); this.addmouselistener(mi); this.addmousemotionlistener(mi); game.tour = kayitli.tour; game.zombieindex = kayitli.zombieindex; player.gun.setgun(kayitli.guntype); } } //açiklama //bullet atma kontrolü üzerinde gerçekten çok uzun zaman uğraştım //basılı tutarak atmayı düzeltsem başka bir şey bozuluyordu vs.. //o yüzden mouseinput dosyasında çok fazla dışarıdan kaynak kullandım, timer component vs şahsen doğrudan yaptığım şeyler değil. import java.awt.*; import java.awt.event.mouseadapter; import java.awt.event.mouseevent; import java.io.serializable; import java.util.random; import java.util.timer; import java.util.timertask; public class mouseinput extends mouseadapter implements serializable{ private handler handler; private boolean ispressed = false; private timer timer; private camera camera; private timertask shoottask; public static long lastshottime = 0; private component gamecomponent; private player player; public static long magazine_period; public static boolean isreloading; public static boolean istime; //bunlar ekrana yazdırılması gerekecek şeyler için statikler public mouseinput(handler handler, camera camera, component gamecomponent, player player) { this.handler = handler; this.gamecomponent = gamecomponent; this.player = player; this.camera = camera; timer = null; } public void mousepressed(mouseevent e) { ispressed = true; startshooting(); } public void mousereleased(mouseevent e) { ispressed = false; stopshooting(); } private void shoot() { mouseinput.magazine_period = 60 * 1000 / player.getfire(); long currenttime = system.currenttimemillis(); long seconds = currenttime - lastshottime; mouseinput.istime = seconds < magazine_period; if (!ispressed || mouseinput.istime|| isreloading || player.getmagazine() <= 0) { return; } lastshottime = currenttime; //mouse konumunu net alabilmek için point p = gamecomponent.getmouseposition(); if (p == null) return; int mouse_x = (int) (p.x + camera.getx()); int mouse_y = (int) (p.y + camera.gety()); double angle = math.atan2(mouse_y - player.gety(), mouse_x - player.getx()); //tabanca keskin nişancı ve roketatar için yalnızca mermi atımı/güncellemesi //delme olayını colissionda bullet yok etmede halledicem keskin nişanc için //patlama olayı da aynı şekilde. //piyade için sapmaya göre angle güncellenir if(player.gun.type == guntype.piyade) { random random = new random(); double max = 30.0; double sapma = math.toradians((random.nextdouble()* 2 * max)-max); angle += sapma; handler.addentity(new bullet(player.getx() + 16, player.gety() + 24, entitytype.bullet, handler, angle)); player.setmagazine(player.getmagazine()-1); } else if(player.gun.type == guntype.tabanca || player.gun.type == guntype.keskinnisanci || player.gun.type == guntype.roketatar) { handler.addentity(new bullet(player.getx() + 16, player.gety() + 24, entitytype.bullet, handler, angle)); player.setmagazine(player.getmagazine()-1); } //pompalı için 9 tane aralıklı atar else if(player.gun.type == guntype.pompali) { double anglefark = math.toradians(45) / 8; //5 derece for (int i = 0; i < 9; i++) { double bulletangle = angle - math.toradians(22.5) + (i * anglefark); handler.addentity(new bullet(player.getx() + 16, player.gety() + 24, entitytype.bullet, handler, bulletangle)); } player.setmagazine(player.getmagazine()-1); } } //herhangi bi press durumunda timer başlatılır, bu sayede tek tık ve basılı tutma için de mermi atımı //optimize edilmiş olur private void startshooting() { if (timer == null) { timer = new timer(); shoottask = new timertask() { @override public void run() { shoot(); } }; timer.scheduleatfixedrate(shoottask, 0, magazine_period+15); } } private void stopshooting() { if (timer != null) { timer.cancel(); timer = null; shoottask = null; } } } public enum entitytype { player(), block(), kirilmazblock(), bullet(), normalzombi(), surungezombi(), tankzombi(), asittukurenzombi(), asit(), asitlizombiefekt(), roketatarefekt(), yedeksarjor(); //iki efekt tipine göre renkleri farklı olcak } import java.awt.graphics; import java.awt.rectangle; import java.awt.color; public class acyd extends gameobject{ private handler handler; private double acydspeed; private double angle; public acyd(int x, int y, entitytype type, handler handler,player player) { super(x, y, type); this.handler = handler; acydspeed = 6; angle = math.atan2(player.gety() - y, player.getx() - x); } @override public void tick() { x += acydspeed * math.cos(angle); y += acydspeed * math.sin(angle); for(int i = 0; i<handler.entities.size(); i++) { gameobject anyobject = handler.entities.get(i); if(anyobject.gettype() == entitytype.block) { if(getbounds().intersects(anyobject.getbounds())){ handler.removeentity(this); } } } } @override public void render(graphics g) { g.setcolor(new color(0,100,0,240)); g.filloval(x, y, 8, 8); } @override public rectangle getbounds() { return new rectangle(x, y, 8,8); } } import java.io.serializable; public class camera implements serializable{ private float x; private float y; public camera(float x, float y) { this.x = x; this.y = y; } public void tick(gameobject anyobject) { x += ((anyobject.getx() - x) - 1000/2) * 0.05f; y += ((anyobject.gety() - y) - 563/2) * 0.05f; //internetten alındı, smooth olarak geçmesi için if( x<=0 ) x=-4; if( x>=1032 ) x = 1032; if( y<=0 ) y=0; if( y>=579 ) y=579; } public float getx() { return x; } public void setx(float x) { this.x = x; } public float gety() { return y; } public void sety(float y) { this.y = y; } } import javax.swing.jbutton; import javax.swing.jframe; import javax.swing.jlabel; import javax.swing.jpanel; import java.awt.borderlayout; import java.awt.dimension; import java.awt.flowlayout; import java.io.fileoutputstream; import java.io.ioexception; import java.io.objectoutputstream; public class window{ public window(int width, int height, string title, game game, thread thread, soundplayer sp) { jframe frame = new jframe(title); frame.setpreferredsize(new dimension(width, height)); frame.setmaximumsize(new dimension(width, height)); frame.setminimumsize(new dimension(width, height)); frame.setresizable(false); frame.setdefaultcloseoperation(jframe.exit_on_close); frame.setlocationrelativeto(null); jpanel buttonpanel = new jpanel(new flowlayout(flowlayout.center)); // ortaya hizala jlabel infolabel = new jlabel(""oyun kontrolleri: ""); jbutton pausebutton = new jbutton(""duraklat""); jbutton resumebutton = new jbutton(""devam et""); jbutton savebutton = new jbutton(""kaydet""); jbutton loadbutton = new jbutton(""yükle(kaydedilen varsa)""); jbutton musicbutton = new jbutton(""müziği kapat/aç""); buttonpanel.add(infolabel); buttonpanel.add(pausebutton); buttonpanel.add(resumebutton); buttonpanel.add(savebutton); buttonpanel.add(loadbutton); buttonpanel.add(musicbutton); pausebutton.addactionlistener(e -> { game.isrunning = false; if (thread != null) { try { thread.join(); } catch (interruptedexception k) { k.printstacktrace(); } } } ); resumebutton.addactionlistener(e -> { if (!game.isrunning) { game.isrunning = true; game.thread = new thread(game); game.thread.start(); } }); savebutton.addactionlistener(e -> { gamesave newsave = new gamesave(); //yazılacak save dosyasına verileri girmek için game.readdatastosave(newsave); //dosyaya yazz try (objectoutputstream oos = new objectoutputstream(new fileoutputstream(""oyunkaydi.ser""))) { oos.writeobject(newsave); system.out.println(""oyun başarıyla kaydedildi""); } catch (ioexception io) { io.printstacktrace(); } }); loadbutton.addactionlistener(e -> { //dosyayı gamesave objesine oku gamesave kayitli = game.saveddatastoimply(); //oyunda güncellenmesi gereken her şeyi güncelle game.updatedatas(kayitli); }); musicbutton.addactionlistener(e -> { if(game.issong) { sp.stop(); game.issong = false; } else { sp.play(); game.issong = true; } }); frame.add(buttonpanel, borderlayout.south); // butonları aşağıya ekle frame.add(game, borderlayout.center); // oyun alanını ortada tut frame.setvisible(true); } } import java.awt.color; import java.awt.graphics; import java.awt.rectangle; import java.awt.image.bufferedimage; import javax.swing.joptionpane; public class player extends gameobject{ handler handler; int width = 64; int height = 64; private static double health = 1000; private static int score = 0; public transient bufferedimage ikon; public player(int x, int y, entitytype type, handler handler) { super(x, y, type); this.handler = handler; loadplayericon(); } public void loadplayericon() { bufferedimageloader loader = new bufferedimageloader(); ikon = loader.loadimage(""/res/ikon.png""); } public static class gun { protected static int max_magazine; protected static int magazine; protected static int fire; protected static guntype type; protected static int yedeksarjor; protected static double speed; public gun() { //obje oluşturulurken tabanca ile başlanır max_magazine = 12; magazine = 12; fire = 120; type = guntype.tabanca; speed = 7; } public static void setgun(guntype type) { gun.type = type; if(type == guntype.tabanca) { max_magazine = 12; magazine = 12; fire = 120; speed = 7; //kontrol edilmeyecek - sonsuz } else if(type == guntype.piyade) { max_magazine = 30; magazine = 30; fire = 600; speed = 8; yedeksarjor = 2; } else if(type == guntype.pompali) { max_magazine = 5; magazine = 5; fire = 60; speed = 10; yedeksarjor = 3; } else if(type == guntype.keskinnisanci) { max_magazine = 5; magazine = 5; fire = 30; speed = 13; yedeksarjor = 4; } else if(type == guntype.roketatar) { max_magazine = 1; magazine = 1; fire = 10; speed = 10; yedeksarjor = 5; } } } public static int getmax_magazine() { return gun.max_magazine; } public static int getmagazine() { return gun.magazine; } public static void setmagazine(int magazine) { gun.magazine = magazine; } public static int getfire() { return gun.fire; } public static void setfire(int fire) { gun.fire = fire; } @override public void tick() { if(player.health <= 0) { joptionpane.showmessagedialog(null, ""öldün malesef :)) gbye"", ""goodbye"", joptionpane.error_message); system.exit(0); } x += speed_x; y += speed_y; collision.checksomecollision(this,handler); if(handler.isup()) speed_y = -4; else if(!handler.isdown()) speed_y = 0; if(handler.isdown()) speed_y = 4; else if(!handler.isup()) speed_y = 0; if(handler.isright()) speed_x = 4; else if(!handler.isleft()) speed_x = 0; if(handler.isleft()) speed_x = -4; else if(!handler.isright()) speed_x = 0; } @override public void render(graphics g) { if (ikon != null) { g.drawimage(ikon, x, y, width, height, null); } else { //resim herhangi bişey yüzünden yüklenmezse g.setcolor(color.red); g.fillrect(x, y, width, height); } } @override public rectangle getbounds() { return new rectangle(x, y, width, height); } public static double gethealth() { return health; } public static void sethealth(double newhealth) { health = newhealth; } public static int getscore() { return score; } public static void setscore(int newscore) { score = newscore; } } import java.awt.graphics; import java.awt.rectangle; import java.io.serializable; public abstract class gameobject implements serializable{ int x, y; float speed_x = 0, speed_y = 0; int height, width; entitytype type; public gameobject (int x, int y, entitytype type) { this.x = x; this.y = y; this.type = type; } public abstract void tick(); public abstract void render(graphics g); public abstract rectangle getbounds(); public entitytype gettype() { return type; } public void settype(entitytype e) { this.type = e; } public int getx() { return x; } public void setx(int x) { this.x = x; } public int gety() { return y; } public void sety(int y) { this.y = y; } public float getspeed_x() { return speed_x; } public void setspeed_x(float speed_x) { this.speed_x = speed_x; } public float getspeed_y() { return speed_y; } public void setspeed_y(float speed_y) { this.speed_y = speed_y; } public int getheight() { return height; } public int getwidth() { return width; } }"
5187413,2,"recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab211q2 { public static void main(string[] args) { int[] arr = { 5, 4, 1, 2 }; coctailsort(arr); } public static void coctailsort(int[] arr) { int high = arr.length - 1; int low = 0; int[] temparr = arr; for (int i = 0; i < arr.length; i++) { for (int j = 0; j < arr.length - 1; j++) { if (temparr[j] > temparr[j + 1]) { int temp = temparr[j]; temparr[j] = temparr[j + 1]; temparr[j + 1] = temp; } } } int count = 0; for (int i = 0; i < arr.length - 1; i++) { if (arr[i] == temparr[i]) { count++; } } if (count == arr.length) { system.out.println(arr); } else { listingup(arr, temparr, low, high); } } public static int listingup(int[] arr, int[] temparr, int low, int high) { int count = 0; for (int i = 0; i < arr.length - 1; i++) { if (arr[i] == temparr[i]) { count++; } } if (count == arr.length) { coctailsort(arr); } if (low == high) { listingdown(arr, temparr, 0, high); } if (arr[low] > arr[low + 1]) { int temp = arr[low]; arr[low] = arr[low + 1]; arr[low + 1] = temp; } return listingup(arr, temparr, low + 1, high); } public static int listingdown(int[] arr, int[] temparr, int low, int high) { int count = 0; for (int i = 0; i < arr.length - 1; i++) { if (arr[i] == temparr[i]) { count++; } } if (count == arr.length) { coctailsort(arr); } if (low == high) { listingup(arr, temparr, low, arr.length - 1); } if (arr[high] < arr[high - 1]) { int temp = arr[high]; arr[high] = arr[high - 1]; arr[high - 1] = temp; } return listingdown(arr, temparr, low, high - 1); } } public class q3sayac { private string str; public q3sayac(string str) { this.str = str; } public int say() { int count = 0; if (str.length() <= 0) { return count; } if (str.charat(0) - '0' == 1) { count++; str = str.substring(1); return count + say(); } str = str.substring(1); return count + say(); } } public class lab211q1 { public static void main(string[] args) { int number = 5; system.out.println(collatz(number)); } public static int collatz(int i) { int count = 0; if (i == 1) { return count; } if (i % 2 == 0) { count++; return count + collatz(i / 2); } count++; return count + collatz(i * 3 + 1); } } public class lab211q3 { public static void main(string[] args) { q3sayac s1 = new q3sayac(""10001""); q3sayac s2 = new q3sayac(""1111""); system.out.println(""s1 sonuç: "" + s1.say() + ""\ns2 sonuc: "" + s2.say()); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { calmastratejisi strateji; public muzikcalar() { } void setstrateji(calmastratejisi s) { strateji = s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { sarki s1 = new klasiksarki(""prelude in c minor"", ""bach""); sarki s2 = new rocksarki(""immigrant song"", ""led zeppelin""); sarki s3 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s4 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s5 = new rocksarki(""welcome to the jungle"", ""guns & roses""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karisik calma: ""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu ozel calma listesi: ""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri: ""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) system.out.println( sarki.sanatci + "" - "" + sarki.isim + ""[ozellik: "" + ((metalsarki) sarki).metalozellik + ""]""); } } } public class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { } } public class metalsarki extends sarki { string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void oynat() { } void gostermetalozellikler() { system.out.println(metalozellik); } } public class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { } } import java.util.list; import java.util.random; import java.util.random.randomgenerator; public class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { randomgenerator gen = new random(); sarki[] liste = new sarki[sarkilistesi.size()]; int index = 0; for (int i = 0; i < sarkilistesi.size(); i++) { liste[index++] = sarkilistesi.get(i); } for (int i = 0; i < liste.length; i++) { sarki temp = liste[i]; liste[i] = liste[gen.nextint(5)]; liste[gen.nextint(5)] = temp; } for (sarki sarki : liste) { if (sarki instanceof metalsarki) { system.out.println(""[metal] "" + sarki.sanatci + "" - "" + sarki.isim + ""( "" + ((metalsarki) sarki).metalozellik + "")""); } else if (sarki instanceof klasiksarki) { system.out.println(""[klasi̇k] "" + sarki.sanatci + "" -"" + sarki.isim); } else { system.out.println(""[rock] "" + sarki.sanatci + "" - "" + sarki.isim); } } } } import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { system.out.println(""[metal] "" + sarki.sanatci + "" - "" + sarki.isim + ""( "" + ((metalsarki) sarki).metalozellik + "")""); } else if (sarki instanceof klasiksarki) { system.out.println(""[klasi̇k] "" + sarki.sanatci + "" -"" + sarki.isim); } else { system.out.println(""[rock] "" + sarki.sanatci + "" - "" + sarki.isim); } } } } public abstract class sarki { string isim; string sanatci; abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof metalsarki) { system.out.println(""[metal] "" + sarkilistesi.get(i).sanatci + "" - "" + sarkilistesi.get(i).isim + ""( "" + ((metalsarki) sarkilistesi.get(i)).metalozellik + "")""); } else if (sarkilistesi.get(i) instanceof klasiksarki) { system.out.println(""[klasi̇k] "" + sarkilistesi.get(i).sanatci + "" -"" + sarkilistesi.get(i).isim); } else { if (!(sarkilistesi.get(i - 1) instanceof rocksarki)) system.out.println(""[bi̇lgi̇] yüksek ses düzeyi""); system.out.println(""[rock] "" + sarkilistesi.get(i).sanatci + "" - "" + sarkilistesi.get(i).isim); if (i != sarkilistesi.size() - 1) { if (!(sarkilistesi.get(i + 1) instanceof rocksarki)) system.out.println(""[bi̇lgi̇] normal ses düzeyi""); } } } } } import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } kelime sayıcı bil 211 - lab 3 20 şubat 2025 1 giriş bu laboratuvarda fileioveexceptions kullanarak bir kelime sayıcı geliştireceğiz. kelime sayıcı , verilen birmetindosyasındakibelirlikelimelerinkaçkezgeçtiğinisayarakbirçıktıdosyasınakaydedecekvebelirlenen hata durumlarında uygun çıktılar oluşturacaktır. 2 genel program program, aşağıdaki sabit isimlere sahip iki giriş dosyası ile çalışacaktır: -kelimeler.txt – aranacak kelimeleri içeren dosya. -metin.txt – kelimelerin aranacağı metnin bulunduğu dosya. program, kelimeler.txt dosyasındaki her kelimenin metin.txt içinde kaç kez geçtiğini sayacak ve sonucu bir çıktı dosyasına kaydedecektir: -sonuc.txt – her kelimenin kaç kez geçtiğini içeren çıktı dosyası. dosyalar,programınçalıştırıldığıdizindebulunmalıdır. dosyaisimlerideğiştirilemez,programsadeceyukarıda belirtilen isimlerle çalışacaktır. eğerkelimeler.txt içinde bulunan herhangi bir kelime, metin.txt içinde hiç geçmiyorsa, program bir hata oluşturmalı ve stderr’e uygun bir mesaj yazmalıdır. 3 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları kullanacaktır (örn., bufferredreader, scanner, printwriter). dosyaları okurken ve yazarken kullanacağınız fileio sınıflarının seçimi size bırakılmıştır. i̇şlenmesi gereken dosyalar şunlardır: -kelimeler.txt dosyası okunmalıdır. -metin.txt dosyası okunmalıdır. -sonuc.txt dosyası oluşturulup yazılmalıdır. program,aşağıdakiolasıdosyahatalarınıoluşturmalıvehatalaroluştuğundastderr’ebelirlenenhatamesajlarını yazmalıdır: - dosyabulunamıyorsa: ""hata: kelimeler.txt bulunamadı."" veya""hata: metin.txt bulunamadı."" - dosya boşsa: ""hata: kelimeler.txt boş."" veya""hata: metin.txt boş."" 4 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program hata kodu ile çıkış yapmalıdır (yani mainmetodunuz bu hataları atarak sonlanmalı) ve hatalar stderr’e yazılmalıdır (programınızı hata atarak sonlandırırsanız java bunu kendisi yapacaktır). belirtilen hata mesajları ile birlikte java’nın hata ile sonlanan programlar için oluşturduğu sınıf, metod, ve satır gibi bilgiler bulunabilir. 1 4.1 girdi hataları (inputexception class) bu kategori, programın giriş dosyalarıyla ilgili karşılaşabileceği tüm hataları kapsar. öğrenciler, dosya işlem- leriyle ilgili hata türlerini inputexception sınıfından türetmelidir. aşağıdaki özel hata türleri tanımlanmalıdır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: [dosya adı] bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: [dosya adı] boş."" 4.2 kelime bulunamadı hatası (kelimebulunamadiexception class) eğerkelimeler.txt içinde bulunan en az bir kelime, metin.txt dosyasında hiç geçmiyorsa, program kelimebulunamadiexception hatasını atmalıdır. hata yalnızca kelimeler.txt dosyasında bulunamayan ilk kelime için atılır ve program sonlanır. bu hata oluştuğunda stderr’e şu mesaj yazılmalıdır: -""hata: [kelime] metinde bulunamadı."" bu hata, doğrudan exception sınıfından türetilecek ve inputexception ile bağlantılı olmayacaktır. 5 dosya formatları program üç farklı dosya ile çalışacaktır: kelimeler.txt (girdi),metin.txt (girdi) ve sonuc.txt (çıktı). bu dosyaların formatı aşağıda belirtilmiştir. 5.1 girdi dosyaları girdi dosyaları düz metin ( .txt) formatında olacaktır ve her biri aşağıdaki gibi yapılandırılmış olmalıdır. 5.1.1kelimeler.txt formatı kelimeler.txt dosyası, her satırda bir kelime olacak şekilde düzenlenmelidir. dosyada yalnızca harf karak- terleri bulunur. kelimeler büyük/küçük harf duyarsız olarak aranacaktır. örnek i̇çerik: elma armut üzüm eğer dosya boşsa, program şu hatayı vermelidir: hata: kelimeler.txt boş. 5.1.2metin.txt formatı metin.txt dosyası, içinde aranacak kelimelerin geçebileceği serbest formatlı bir metin içermelidir. dosya içinde noktalama işaretleri ve boşluklar bulunabilir. örnek i̇çerik: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. eğer dosya boşsa, program şu hatayı vermelidir: hata: metin.txt boş. 5.2 çıktı dosyası program, kelimelerin kaç kez geçtiğini gösteren bir çıktı dosyası ( sonuc.txt ) oluşturmalıdır. 2 5.2.1sonuc.txt formatı sonuc.txt dosyası, her satırda kelimenin adı ve kaç kez geçtiği bilgisi olacak şekilde düzenlenmelidir. format şu şekilde olmalıdır: [kelime] [geçme sayısı] kelime ve geçme sayısı arasında tek bir boşluk olmalıdır. örnek çıktı ( sonuc.txt ): elma 2 armut 2 üzüm 1 5.3 özel hata durumları ve çıktıları eğerkelimeler.txt içindekiherhangibirkelime metin.txt içindebulunamazsa, kelimebulunamadiexception hatası atılmalıdır ve stderr’e şu mesaj yazılmalıdır: hata: üzüm metinde bulunamadı. bu hata oluştuğunda, yine de sonuc.txt dosyası oluşturulmalı ve bulunan kelimeler için normal çıktı yazıl- malıdır. ancak bulunamayan kelimeler çıktı dosyasına eklenmemelidir. örnek durum: eğerkelimeler.txt şu şekildeyse: elma armut muz vemetin.txt şu şekildeyse: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. o zaman sonuc.txt şu şekilde olmalıdır: elma 2 armut 2 ve stderr’e şu mesaj yazılmalıdır: hata: muz metinde bulunamadı. 6 gönderim formatı - labı bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara şeklinde isimlendirin (örn., johnnash_181101014.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""lab3 gönderim"" başlıklı bir mail ile gönderin. 3 metot açıklama string(string s) sile aynı değere sahip bir string oluşturur. string(char[] a) a[]dizisindeki karakterlerle bir string oluşturur. int length() string içindeki karakter sayısını döndürür. char charat(int i) belirtilen iindeksindeki karakteri döndürür. string substring(int i, int j) iilej-1arasındaki karakterleri içeren bir alt string döndürür. boolean contains(string substring) string’in substring ’i içerip içermediğini kontrol eder. boolean startswith(string prefix) string’in prefixile başlayıp başlamadığını kontrol eder. boolean endswith(string postfix) string’in postfix ile bitip bitmediğini kontrol eder. int indexof(string pattern) pattern ifadesinin ilk geçtiği indeks değerini döndürür. int indexof(string pattern, int i) iindeksinden sonraki ilk pattern konumunu döndürür. string concat(string t) string’in sonuna teklenmiş halini döndürür. int compareto(string t) i̇ki string’i karşılaştırır (sözlük sırasına göre). string tolowercase() string’in tüm harflerini küçük harfe çevirir. string touppercase() string’in tüm harflerini büyük harfe çevirir. string replace(string a, string b) string içindeki a’larıbile değiştirir. string trim() string’in başındaki ve sonundaki boşlukları kaldırır. boolean matches(string regex) string’in belirtilen regexle eşleşip eşleşmediğini kontrol eder. string[] split(string delimiter) string’idelimiter kullanarak böler ve bir dizi döndürür. boolean equals(object t) string’in değeri tile aynı mı diye kontrol eder. table 1: java string sınıfı metotları 4 import java.io.fileinputstream; import java.io.filenotfoundexception; import java.io.fileoutputstream; import java.io.printwriter; import java.util.arraylist; import java.util.scanner; public class kelimesayaci { public static void main(string[] args) { okuyucu(""metin.txt""); kelimesayac(""metin.txt"", ""kelimeler.txt""); } public static string okuyucu(string filename) { string str = """"; scanner scan = null; string removed = """"; try { scan = new scanner(new fileinputstream(filename)); if (!scan.hasnextline()) { throw new bosdosyaexception(); } while (scan.hasnextline()) { str = scan.nextline(); } scan.close(); removed = str.replaceall(""\\p{punct}"", """"); return removed; } catch (filenotfoundexception e) { try { throw new dosyabulunamadiexception(); } catch (dosyabulunamadiexception ex) { ex.getmessage(); } } catch (bosdosyaexception e) { e.getmessage(); } return null; } public static arraylist<string> okuyucu2(string filename) { arraylist<string> removed = new arraylist<>(); scanner scan = null; try { scan = new scanner(new fileinputstream(filename)); if (!scan.hasnextline()) { throw new bosdosyaexception(); } while (scan.hasnextline()) { removed.add(scan.nextline()); } scan.close(); return removed; } catch (filenotfoundexception e) { try { throw new dosyabulunamadiexception(); } catch (dosyabulunamadiexception ex) { ex.getmessage(); } } catch (bosdosyaexception e) { e.getmessage(); } return null; } public void kelimeler() { printwriter kelime = null; try { kelime = new printwriter(new fileoutputstream(""sonuc.txt"")); } catch (filenotfoundexception e) { try { throw new dosyabulunamadiexception(); } catch (dosyabulunamadiexception ex) { ex.getmessage(); } } } public static void kelimesayac(string file1, string file2) { if (file1 == null || file2 == null) { return; } string str1 = okuyucu(file1); arraylist<string> str2 = okuyucu2(file2); int counts[] = new int[str2.size()]; int counter = 0; for (int i = 0; i < str2.size(); i++) { int l = str2.get(i).length(); counts[i] = counter; counter = 0; for (int j = 0; j < str1.length(); j++) { if (str2.get(i).equals(str1.substring(j, l))) { counter++; } } } int total = 0; for (int i = 0; i < counts.length; i++) { total += counts[i]; } try { if (total == 0) throw new kelimebulunamadiexception(); } catch (kelimebulunamadiexception e) { e.getmessage(); } } } public class kelimebulunamadiexception extends exception { public kelimebulunamadiexception() { super(); } public kelimebulunamadiexception(string e) { system.out.println(""hata: "" + e + "" metinde bulunamadi""); } } public class bosdosyaexception extends inputexception { public bosdosyaexception() { super(); } public bosdosyaexception(string e) { super(e + "" bos""); } } public class inputexception extends exception { public inputexception() { super(); } public inputexception(string e) { system.out.println(""hata: "" + e); } } public class dosyabulunamadiexception extends inputexception { public dosyabulunamadiexception() { super(); } public dosyabulunamadiexception(string e) { super(e + "" bulunamadi""); } } generic 1) envanter yönetim sistemi bu labda amacımı bir oyun için envanter sistemi eklemektir. item isminde bir arayüz tanımlayın: aşağıdaki metotları içermelidir: string getname() int getvalue() weapon sınıfı tanımlayın. bu sınıf item arayüzünü uygulamalıdır. int damage isimli bir özelliği olmalıdır. armor sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. int defense isimli bir değişkeni olmalıdır. potion sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. string effect isimli bir değişkeni olmalıdır. generic inventory<t> sınıfı bir arraylist kullanarak nesneleri saklamalıdır. void additem(t item): envantere istenilen eşyayı eklemeli void removeitem(t item): envanterden istenilen eşyayı silmeli void printinventory(): envanteri basmalı t mostvaluableitem(): en değerli eşyayı dönmeli t finditembyname(string name): verilen isme karşılık gelen eşyayı dönmeli. i̇simlerin unique olduğunu varsayabilirsiniz. eğer yoksa null dönün. list<t> finditemsbyvalue(int value): verilen değerden daha değerli eşyaarın listesini döndürür. int gettotalvalue(): envanterin toplam değerini döner. list<t> filterbytype(class<?> type): istenilen sınıfa ait ögeleri döner. int gettotalweapondamage(): weapon classına ait olan nesnelerin toplam hasarınıdöner. void sortbyvalue(): değeri azalan şekilde envanteri sıralamalıdır. public static void printmostvaluableitem(inventory<? extends item> inventory): verilen envanterdem en değerli eşayı ekrana basmalıdır. public static void transferarmor(inventory<? super armor> destination, inventory<armor> source): verilen hedef envantere zırhı taşımalıdır. driver class: main metodu burada olmalıdır. sadece weapon’dan oluşan ve itemdan oluşan invertory classı yazıp test ediniz. yardımcı olabilecek metotlar: class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon import java.util.arraylist; import java.util.list; public class inventory<t extends item> { arraylist<t> objects = new arraylist<>(); void additem(t item) { objects.add(item); } void removeitem(t item) { objects.remove(item); } void printinventory() { for (t object : objects) { system.out.println(object); } } t mostvaluableitem() { t temp = null; for (int i = 0; i < objects.size() - 1; i++) { if (objects.get(i).getvalue() < objects.get(i + 1).getvalue()) { temp = objects.get(i + 1); } } return temp; } t finditembyname(string name) { for (t items : objects) { if (items.getname().equals(name)) { return items; } } return null; } list<t> finditemsbyvalue(int value) { list<t> greater = new arraylist<>(); for (t items : objects) { if (items.getvalue() > value) { greater.add(items); } } return greater; } int gettotalvalue() { int total = 0; for (t items : objects) { total += items.getvalue(); } return total; } list<t> filterbytype(class<?> type) { list<t> clas = new arraylist<>(); for (t items : objects) { if (items.getclass().equals(type)) { clas.add(items); } } return clas; } int gettotalweapondamage() { int total = 0; for (t item : objects) { if (item.getclass() == weapon.class) { total += ((weapon) item).getdamage(); } } return total; } void sortbyvalue() { t temp; for (int i = 0; i < objects.size(); i++) { if (objects.get(i).getvalue() < objects.get(i).getvalue()) { temp = objects.get(i); objects.set(i, objects.get(i + 1)); objects.set(i + 1, temp); } } } public static void printmostvaluableitem(inventory<? extends item> inventory) { system.out.println(inventory.mostvaluableitem()); } public static void transferarmor(inventory<? super armor> destination, inventory<armor> source) { for (int i = 0; i < source.objects.size(); i++) { if (source.objects.get(i).getclass() == armor.class) { destination.objects.add(source.objects.get(i)); } } } } public class weapon implements item { private int damage; private string name; private int value; public weapon(string name, int value, int damage) { this.name = name; this.damage = damage; this.value = value; } public int getdamage() { return damage; } @override public string getname() { return name; } @override public int getvalue() { return value; } public string tostring() { return (""name: "" + getname() + ""value: "" + getvalue() + ""damage: "" + getdamage()); } } public class armor implements item { private int defense; private string name; private int value; public armor(string name, int value, int defense) { this.defense = defense; this.name = name; this.value = value; } public int getdefense() { return defense; } @override public string getname() { return name; } @override public int getvalue() { return value; } public string tostring() { return (""name: "" + getname() + ""value: "" + getvalue() + ""defense: "" + getdefense()); } } public class potion implements item { private string effect; private string name; private int value; public potion(string name, int value, string effect) { this.effect = effect; this.name = name; this.value = value; } public string geteffect() { return effect; } @override public string getname() { return name; } @override public int getvalue() { return value; } public string tostring() { return (""name: "" + getname() + ""value: "" + getvalue() + ""effect: "" + geteffect()); } } public class driver { public static void main(string[] args) { weapon sword = new weapon(""excalibur"", 1000, 100); weapon wea = new weapon(""wea"", 50, 40); weapon wep = new weapon(""wep"", 30, 10); armor armor = new armor(""armor"", 90, 100); armor arm = new armor(""arm"", 5, 10); armor mo = new armor(""mo"", 60, 70); potion pot = new potion(""pot"", 13, ""light""); inventory<item> items = new inventory<>(); items.additem(mo); items.additem(wep); items.additem(pot); inventory<weapon> wp = new inventory<>(); wp.additem(sword); wp.additem(wep); wp.additem(wea); inventory<armor> ar = new inventory<>(); ar.additem(armor); ar.additem(arm); inventory<armor> mor = new inventory<>(); mor.additem(mo); system.out.println(wp.gettotalweapondamage()); inventory.transferarmor(mor, ar); mor.printinventory(); system.out.println(""----------------""); system.out.println(items.filterbytype(weapon.class)); } } ""recursion"" kavramı nedir, kısaca açıklayınız. özyinelemeli metot, kendi içinde tekrar kendi çağırarak işler. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case, metotun stack overflow olmasını engelleyen istenilen durum. büyük problem, çözmek istediğimiz ana problem(n). küçük problem, büyük problemi ayırarak çözümüne odaklandığımız parça (n-1). jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. stack'de en alttan başlayarak elde tutması gerekenleri biriktirir. en tepeye ulaştıktan sonra yukarıdan aşağı olacak şekilde kodu işler. int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. tek bir for döngüsüyle halledebileceğimiz için iteratif olarak. çünkü recursion daha yavaş işler. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? base case stringin uzunluğu 1e eşitse 1 döndür olur. her seferinde int count değişkenimi 1 arttırıp stringi substring(1)'den başlatarak tekrar çağırırım. stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. bilgisayar kaynaklarını tükettiyse olur. base case tanımlanmadığı zaman recursion metotlarında olur. tail recursion nedir, kısaca açıklayınız. metotun içinde iflere girmediği durumda tekrar metotun çağrılmasıyla olur. abstraction kavramını açıklayınız. soyutlama, black box. çalışırken metotun işleyişini detaylı olarak bilmediğimiz ama çıktısını bildiğimiz metotları örnek verebiliriz örneğin system.out.println dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? override ettiğimiz metot diğer sınıfın subclassında yer aldığı için mümkündür. tersi değil. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? protected private a daha yakın çünkü aynı package ve subclassların erişimine izin veriyor. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? kendinden hemen önceki türetildiği classın contructorını almak için. bu listenin en tepesinde object classı yer alır. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır extend ettiğimiz classların metotları birbiriyle aynı olabilir sorun çıkarabilir. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a b'nin içinde tanımlı bir variabledir. metot overriding ve overloading kavramlarını açıklayınız. overriding base classta bulunan bir metotun türettiğimiz classa özel halini yazmaktır isimleri aynıdır. overloading yine aynı isimli metotların farklı imzalara sahip tanımlanmasıdır aynı classın içinde olur. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? base 1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? parent+"" \n"" + 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? direkt aktarmak istiyorsak static yoksa dinamik java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? override edilemezler değiştirilemezler yani overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? dinamik çünkü değiştirilebilirler dinamik bağlamada jvm'nin görevi nedir? ---- java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? ----- java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? staticler olmadığı için öncelikli aktarım sırasında sorun yasanırdı class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? parent dinamik class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book statik java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 2 çeşittir . unchecked ve checked exceptions. unchecked exceptionlara runtime exceptionlar örnek verilebilir örneğin nullpointerexceptin. ioexception checked exceptionlara örnek verilebilir. java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? throws keywordu kullanarak attığımız exceptionlardır. eğer override edilmiş bir metotta bunu yapıyorsak throws yaptığımız exceptionun classı override ettiģimiz metotta throws yaptığımız exceptionun classından daha üst seviyede olamaz . finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally bloğu exception atılsa da atılmasa da her zaman çalıştırılır. java'da kendi exceptionunuzu nasıl tanımlarsınız? exception sınıfından bir class türeterek bu classta bir boş bir de string ifade alan olacak şekilde 2 contructor tanımlarım. constructorların içinde super metodunu çağırırım. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? handle edilmesi gerekilen exceptionu daha basitleştirmek. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenmez io exception exceptionun subclassıdır bu yüzden sıralamada önce o yazılmalıdır. trying m1 caught2 finally text file ile binary file arasındaki fark nedir? text file editor tarafından okunurken binary file bilgisayar tarafından okunur ve 1 ve 0lardan oluşur bir dosyaya yazarken düzenli olarak flush yapmamak neye yol açabilir? data kaybına yol açabilir binary bir dosyaya bir object yazdırırken bu objenin hangi interfaceyi implement etmesi gerekiyor? bu interfacenin metotlarını sıralayınız. bu interface functional veya marker bir interface midir? functional bir interfacedir binary bir dosyaya primitive typeler (int, float, char etc.) yazılabilir mi, evet ise nasıl? evet yazılabilir dosya bunları 1 ve 0lara çevirir buffered reader ve scanner sınıfları ile dosya okurken dosyanın sonuna geldiğini nasıl kontrol edilir? buffered reader readline metotu null döndürür read metotu ise -1 döndürür. sacnner sınıfında ise hasnext metotu ile sona gelip gelinmedigi anlaşılabilir binary bir dosya okurken dosyanın sonuna gelindiği nasıl test edilir? -- public class randomaccessdemo { public static void main(string[] args) throws exception { _______ f = new _______(""numbers.bin"", ""____""); f.writeint(10); f.writeint(20); int a = f.readint(); f.seek(_____________); int b = f.readint(); system.out.println(a + b); f.close(); } } boşluklara sırasıyla ne gelmelidir? output? -- public class demo { public static void main(string[] args) throws exception { fileoutputstream fos = new fileoutputstream(""log.txt"", true); ______________ pw = new ______________(fos); pw.println(""new log entry""); pw.close(); } } boşluklara sırasıyla ne gelmelidir? bu kod çalıştırıldığında log.txt dosyası nasıl etkilenir? printwriter printwriter log.txt dosyasına new log entry yazılır what grade (a, b, c, d, or f) do you expect to earn by the end of this course? cc java'da generic kavramı nedir, bu kavramın temel amacı nedir? classı instantinate etmeden önce belli bir tiple yazmaya gerek kalmamasıdır upper bound ve lower bound wildcardları nasıl ifade edersiniz? upper ve lower boundun kullanılacağı durumlara birer tane örnek veriniz. lower bound yazabilceģimiz minumum class tipini belirler upper bound da ulaşabileceģimiz maksimum class tipini belirtir örneğin t extends comperable demek class tiplerimizi t yi extend edenler olarak sınırlandırır generic bir classın constructorunda type parametresi bulunur mu, neden? hayır bulunmaz mygenericclass<a> ve mygenericclass<object> classları arasında kalıtım (child-parent) ilişkisi nasıldır, açıklayınız. normal kalıtım ilişkisi yoktur birinin obnesi diğerinin de objesi sayılmaz class node<t>{ t[] data = new t[10]; } //psvm node<string> stringnode = new node<>(); bu kodda bir hata var mı? (varsa) bu hata nedir, nedenini açıklayınız. (varsa) bu hata nasıl düzeltilmeli, kodun doğru halini yazınız. generic type array yazamayız. arraylost kullanabiliriz swapheadandtail metodu aşağıda tanımı verilmiş node classının birbirlerine bağlanmış nodelerinden ilkini alan ve baştaki node ile sondaki node'yi değiştiren metottur. örnek: başlangıçta: a -> b -> c metodu a ile çağırdığıktan sonra: c -> b -> a ayrıca metot en başa gelen nodeyi dönmelidir (bu örnekte c dönmeli). class node{ int data; node next; } static node swapheadandtail(node head) { node a = head; node b = head.next; node c = head; node d = null; while (____ != null) { d = c; c = c.next; } c.next = ____; d.next = ____; a.next = ____; return ____; } buna göre boşluklara neler gelmelidir? --- public _________ { public void sırala(list<t> liste) { // sıralama algoritmanız } } yaptığınız uzun çalışmalar sonucu yeni bir sıralama algoritması buldunuz. bunu implement etmek için bir class yazmalısınız. bu classın declarationunu nasıl yapardınız neden, boşluğu buna göre doldurun. <t> map ve set veri yapılarını kıyaslayınız, aralarındaki farkları açıklayınız. -- collections interfacesindeki metotlar temel olarak hangi işlevleri yerine getiriyor? listelere ekleme eksiltme boyunu döndürme ve iterasyona aktarma i̇ki objenin equals metodu true dönüyorsa bu iki objenin hash codeleri aynıdır, bunun nedenini açıklayınız; eğer bu sağlanmazsa hangi veri yapıları istenilen şekilde sağlanır? kendi yazdığınız classlarda bunu sağlamak için hangi metotları override etmelisiniz, neden? hashcode objeleri tutan referanstir aynı referans iki objeyi tutabilir. equals metodu override edilmelidir. bir öğrenci kulübü, yılsonu etkinliği için sınırlı kontenjana sahip bir kayıt sistemi oluşturuyor. sistem, öğrenci kayıtlarını ""ilk gelen ilk hizmet alır"" prensibiyle yönetiyor. ancak, bazı öğrenciler kaydını iptal edebiliyor ve boş kalan yerler otomatik olarak sıradaki öğrenciye veriliyor. bu senaryoda, kayıt sırasını ve iptal durumlarını etkin bir şekilde yönetebilmek için hangi veri yapısını tercih edersiniz? neden? bu örnek bankada sıra bekleyen insanlara benziyor bu yuzden setler bu durumda kullanilabilir fifo nedir, açıklayınız ve aşağıdakı veri yapılarını fifo/lifo şeklinde sınıflandırınız: stack queue map priorityqueue -- public class main { public static void main(string[] args) { map<string, integer> scores = new hashmap<>(); scores.put(""alice"", 95); scores.put(""bob"", 80); scores.put(""alice"", 100); set<string> keys = scores.keyset(); int sum = 0; for (string key : keys) { sum += scores.get(key); } system.out.println(""number of entries: "" + scores.size()); system.out.println(""sum of scores: "" + sum); } } output? 3 275 public class main { public static void main(string[] args) { list<string> list = new arraylist<>(); list.add(""apple""); list.add(""banana""); list.add(1, ""cherry""); list.remove(""banana""); list.add(""apple""); system.out.println(list.size()); system.out.println(list.indexof(""apple"") + "" "" + list.lastindexof(""apple"")); } } output? 0 0 ara sınavdan yaklaşık hangi notu bekliyorsun (0-100)? 30 java gui'leri bağlamında olay güdümlü (event driven) programlamayı tanımlayın. atılan event objesini yakalayan listenerların olduğu programlama turudur geleneksel sıralı programlama ile olay güdümlü (event driven) programlama arasındaki temel fark nedir? evetler gidişata karar verir bazı metotlar hiç kullanılmayabilir borderlayout yöneticisi, bir konteynerdeki bileşenleri nasıl düzenler? konteyner üzerindeki konumlarını ayarlamaya yardımcı olur. java gui uygulamalarında jpanel'in amacı nedir? -- java'daki gui programları neden tipik olarak sonsuz bir olay döngüsü çalıştırır ve bu durum sistem veya uygulama tarafından tetiklenen yeniden çizim (repaint) olaylarıyla nasıl ilişkilidir? her seferinde ekrandaki şeklin güncellenmesi gerekir bir swing uygulamasında repaint() metodunu çağırmanın etkisi nedir? ekrana yeni eklenen şeyleri yansıtmak aşağıdaki kodun çalışmasını izleyin ve düğmeye tıklandığında ne olduğunu belirleyin: public class simplegui extends jframe implements actionlistener { public simplegui() { setsize(200, 100); setdefaultcloseoperation(jframe.exit_on_close); jbutton button = new jbutton(""click me""); button.addactionlistener(this); add(button); setvisible(true); } public void actionperformed(actionevent e) { joptionpane.showmessagedialog(this, ""button was clicked!""); system.exit(0); } public static void main(string[] args) { new simplegui(); } } this button was clicked. program sonlanır. aşağıdaki kod parçasını inceleyin: import javax.swing.*; import java.awt.*; public class layoutexample { public static void main(string[] args) { jframe frame = new jframe(""layout test""); frame.setsize(400, 300); frame.setdefaultcloseoperation(jframe.exit_on_close); frame.setlayout(new borderlayout()); frame.add(new jlabel(""n""), borderlayout.north); frame.add(new jbutton(""s""), borderlayout.south); frame.add(new jpanel(), borderlayout.center); frame.setvisible(true); } } bu program çalıştığında bileşenlerin nasıl düzenlendiğini açıklayın. frame in başlığı layout test olur. frame in üstünde kuzeyde n güneyde s yazar . thread oluşturmanın 2 temel yöntemi nedir? thread oluştururken lambda notasyonunun kullanılabilmesi ne sağlar? lambda notasyonu kullanabilmesi block seklinde kullanimi saglar data race problemi nedir, neden kaynaklanır? nasıl önüne geçilir? -- dead lock problemi nedir, neden kaynaklanır; bunun önüne geçebilmek için ne yapılabilir? eğer 2 tread arasında biri karşıdan almayı beklerken veriyor diğeri de diğer treadten almayı bekliyor ve veriyor ise aralarinda dead lock problemi olur bir threadi başlatmak için neden run metodu çağırılmamalı, açıklayınız. peki hangi metot çağrılmalıdır? thread kendi içinde run metotudunu cagiracagi icin basladiğında bizim ayrıca çağırmamıza gerek yok bir thread başka bir thread tarafından nasıl doğru bir şekilde sonlandırılabilir? -- java'da kaç çeşit thread vardır, farkları açıklayınız. -- public class bankaccount { private double balance; public void deposit(double amount) { balance = balance + amount; ; } public void withdraw(double amount) balance = balance - amount ; } public static void main(string[] args) { bankaccount account = new bankaccount(); thread t1 = new thread(() -> { for (int i = 0; i < 3; i++) { account.deposit(100); } }); thread t2 = new thread(() -> { for (int i = 0; i < 2; i++) { account.withdraw(100); } }); t1.start(); t2.start(); } } bu kodda bir problem var mı? varsa bu problemi nasıl çözersiniz? (varsa) problemi çözdükten sonra program çalıştığında balance'nin son değeri ne olur? dead lock problemi var bunu cozmek icin senkronize block kullanabiliriz.0. class threadvisibility { private static boolean flag = false; private static int value = 0; public static void main(string[] args) throws interruptedexception { thread t1 = new thread(() -> { string name = thread.currentthread().getname(); system.out.println(""started""); while (!flag) { try { thread.sleep(100); } catch (interruptedexception e) { e.printstacktrace(); } } system.out.println(name + value); }); t1.setname(""t2""); t1.start(); thread.sleep(1000); // give t1 time to start value = 11; synchronized (threadvisibility.class) { flag = true; } } } output? started t2 0 bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot { private string name; private string type; private int batterylevel;// 100 ile 0 arasında bir değer private boolean isoperational;// bataryası varsa true public robot() { name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } public robot(string name, string type, int batterylevel) { this.name = name; this.type = type; this.batterylevel = batterylevel; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public boolean getisoperational() { return isoperational; } public void setisoperational(boolean isoperational) { this.isoperational = isoperational; } public void charge() { batterylevel = 100; } public void printrobot() { system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + ""%"" + "" is operational: "" + isoperational); } } public class factorybase { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } import java.util.arraylist; public class quizq1 { public static void main(string[] args) { string str = ""a1b2""; system.out.println(); } public static void makearray(string str) { arraylist<string> strs = new arraylist<>(); string str1 = """"; for (int i = 0; i < str.length(); i++) { if (str.charat(0) - 'a' < 0 && str.charat(0) - 'a' >= 0) { str1 += str.charat(0); } if (str.charat(0) - 'a' >= 0) { str1 += (char) ((str.charat(0) - 'a') + 'a'); } if (str.charat(0) - 'a' >= 0) { str1 += (char) ((str.charat(0) - 'a') + 'a'); } } strs.add(str1); } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots = new arraylist<>(); public factory(string name, string location) { this.name = name; this.location = location; } public factory() { name = ""factory1""; location = ""moon""; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getlocatiion() { return location; } public void setlocation(string location) { this.location = location; } public arraylist<robot> getrobots() { return robots; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for (int i = 0; i < robots.size(); i++) { robots.get(i).setbatterylevel(100); } } public void printfactory() { system.out.println(""factory name: "" + name + "" location: "" + location + ""\nrobots operating here:""); for (int i = 0; i < robots.size(); i++) { robots.get(i).printrobot(); } } public void work() { for (int i = 0; i < robots.size(); i++) { robots.get(i).setbatterylevel(robots.get(i).getbatterylevel() * (75 / 100)); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public abstract void performtask(); } public class securityrobot extends abstractrobot { private boolean isarmed; public boolean getisarmed() { return isarmed; } @override public int getbatterylife() { return batterylife; } @override public void recharge() { batterylife = super.batterylife; } @override public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] scanning for threats... armed: "" + isarmed); batterylife -= 10; } else { system.out.println(""["" + modelname + ""] not enough battery to scan threats...""); } } securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } public void togglearmedmode() { isarmed = !isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; public int getcleaningpower() { return cleaningpower; } @override public int getbatterylife() { return batterylife; } @override public void recharge() { batterylife = super.batterylife; } cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } @override public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] cleaning in progress... cleaning power: "" + cleaningpower); batterylife -= 10; } else { system.out.println(""["" + modelname + ""] not enough battery to clean...""); } } public void boostcleaningpower(int cleaningpower, int miktar) { cleaningpower += miktar; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { cleaningrobot cleaningrobot = new cleaningrobot(modelname, batterylife, cleaningpower); robots.add(cleaningrobot); counter++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { securityrobot securityrobot = new securityrobot(modelname, batterylife, isarmed); robots.add(securityrobot); counter++; } public void performalltasks() { for (int i = 0; i < robots.size(); i++) { robots.get(i).performtask(); } } public void displayrobots() { for (int i = 0; i < robots.size(); i++) { if (robots.get(i).getclass() == cleaningrobot.class) { cleaningrobot r1 = (cleaningrobot) robots.get(i); system.out.println(""cleaning robot - model: "" + robots.get(i).getmodelname() + "", battery: "" + robots.get(i).getbatterylife() + "", cleaning power: "" + r1.getcleaningpower()); } else { securityrobot r2 = (securityrobot) robots.get(i); system.out.println(""security robot - model: "" + robots.get(i).getmodelname() + "", battery: "" + robots.get(i).getbatterylife() + "", armed: "" + r2.getisarmed()); } } } public void upgradecleaningrobots(int miktar) { for (int i = 0; i < robots.size(); i++) { if (robots.get(i).getclass() == cleaningrobot.class) { cleaningrobot r3 = (cleaningrobot) robots.get(i); r3.boostcleaningpower(r3.getcleaningpower(), miktar); system.out.println(""cleaningrobot - "" + robots.get(i).modelname + ""now has cleaning power:"" + r3.getcleaningpower()); } } } public void togglesecurityrobotsmode() { for (int i = 0; i < robots.size(); i++) { if (robots.get(i).getclass() == securityrobot.class) { securityrobot r4 = (securityrobot) robots.get(i); r4.togglearmedmode(); system.out.println(""securityrobot - "" + robots.get(i).modelname + ""is now "" + r4.getisarmed()); } } } public static int counter; public void allrobots() { system.out.println(""tum fabrikalar tarafindan toplam "" + counter + "" üretildi.""); } } public class main1 { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); anotherfactory.allrobots(); } } envanter takip sistemi bil 211 - quiz 3 27 şubat 2025 1 giriş bu quizde, fileioveexceptions kullanarak basit bir envanter takip sistemi uygulaması geliştireceğiz. uygulama, interaktif bir terminal menüsü üzerinden, tek bir eşyanın ve stoğunun tutulduğu kayıtların yönetilmesini (eşya ekleme, çıkarma ve stok güncelleme) sağlayacaktır. ayrıca, envanter verileri sabit isimli bir dosyaya kaydedilebilecek ve bu dosyadan geri yüklenebilecektir. 2 genel program program konsol tabanlı bir kullanıcı arayüzü ile envanter takibi gerçekleştirmelidir. arayüz özellikleri aşağı- daki gibidir. -terminal menüsü: kullanıcıya aşağıdaki seçenekleri sunacaktır: – eşya ekleme: yeni bir eşya kaydı oluşturulur. her kayıt, eşya adı ve başlangıç stoğu bilgilerini içerir. eğer çoktan var olan bir eşya eklenmeye çalışılırsa program otomatik olarak önceki kaydın stoğunu güncellemelidir (yani aynı isimde iki kayıt oluşmamalı). – eşya çıkarma: mevcut envanterden istenilen eşya silinir. – stok güncelleme: kayıtlı bir eşyanın stoğu artırılabilir ya da azaltılabilir. i̇şlem sonucunda stok miktarı negatif olmamalıdır. – envanter listeleme: mevcut envanter kayıtları ekrana listelenir. – dosyaya kaydetme: güncel envanter verileri sabit isimli dosyaya kaydedilir. – dosyadan geri yükleme: daha önce kaydedilmiş envanter verileri dosyadan okunarak geri yüklenir. – çıkış: program sonlandırılır. 3envanterkaydi sınıfı değişkenler: -isim(private string) eşyanın adını tutar. -stok(private int) eşyanın stok miktarını tutar. metotlar: -public envanterkaydi(string isim, int stok) constructor; eşya adı ve stok miktarını başlatır. -public void stokguncelle(int miktar) stok miktarını günceller; negatif sonuç oluşmaması kontrol edilmelidir. - stokguncelle dışında ihtiyacınıza göre private değişkenler için getter ve setter tanımlayabilirsiniz. 4 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları (örn., bufferedreader , scanner,printwriter ) kullanacaktır. dosya işlemleri sırasında aşağıdaki hata durumları için uygun mesajlar verilmelidir: - dosya bulunamazsa: ""hata: envanter dosyası bulunamadı."" - dosya boşsa: ""hata: envanter dosyası boş."" 1 5 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program, hata kodu ile sonlanmalı ve ilgili hata mesajları stderr’e yazdırılmalıdır. 5.1 girdi hataları (inputexception class) dosya işlemleriyle ilgili hatalar için kendi tanımlayacağınız inputexception sınıfından türeyen özel hata sınıfları oluşturulacaktır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: envanter dosyası bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: envanter dosyası boş."" 5.2 envanter i̇şlemleri hataları envanter işlemleri sırasında oluşabilecek hatalar için aşağıdaki özel hata türleri tanımlanacaktır: -stoknegatifexception (extends exception) : stok güncelleme işlemi sonucunda, eşyanın stoğu negatif bir değere düşerse atılacak hata. - hata mesajı: ""hata: stok miktarı negatif olamaz."" -esyayokexception (extends exception) : çıkarma veya güncelleme işlemi yapılmak istenen eşya envanterde bulunmuyorsa atılacak hata. - hata mesajı: ""hata: i̇stenen eşya envanterde mevcut değil."" -ozellikhatasiexception (extends exception) : eşya ekleme sırasında girilen bilgilerde hata veya eksiklik varsa atılacak hata. - hata mesajı: ""hata: eşya bilgileri hatalı veya eksik."" 6 gönderim formatı - quizinizi bitirdiğinizde asistanlarınızdan birisine kodunuzu ve çıktısını gösterip puanlatın. - asistan labınızı puanladığında tüm kaynak dosyalarını ve bu dökümantasyonu bir arşiv dosyası (zip, rar, 7z, tar, tar.gz) halinde sıkıştırın. - arşiv dosyasının isim_numara formatında isimlendirin (örn., sebnemferah_181101014.zip). - i̇simlendirdiğiniz arşiv dosyasını uzak sistemindeki quiz alanına yükleyin. 2 public class bosdosyaaexception extends inputtexception { public bosdosyaaexception() { super(""hata: envanter dosyasi bos.""); } public bosdosyaaexception(string message) { super(message); } } public class esyayokexception extends exception { public esyayokexception() { super(""hata: i̇stenen eşya envanterde mevcut değil.""); } public esyayokexception(string message) { super(message); } } public class dosyabulunamadiiexception extends inputtexception { public dosyabulunamadiiexception() { super(""hata: envanter dosyasi bulunamadi.""); } public dosyabulunamadiiexception(string message) { super(message); } } import java.io.fileinputstream; import java.io.filenotfoundexception; import java.io.fileoutputstream; import java.io.printwriter; import java.util.arraylist; import java.util.scanner; public class kelimesayaci { public static void main(string[] args) { okuyucu(""metin.txt""); kelimesayac(""metin.txt"", ""kelimeler.txt""); } public static string okuyucu(string filename) { string str = """"; scanner scan = null; string removed = """"; try { scan = new scanner(new fileinputstream(filename)); if (!scan.hasnextline()) { throw new bosdosyaexception(); } while (scan.hasnextline()) { str = scan.nextline(); } scan.close(); removed = str.replaceall(""\\p{punct}"", """"); return removed; } catch (filenotfoundexception e) { try { throw new dosyabulunamadiexception(); } catch (dosyabulunamadiexception ex) { ex.getmessage(); } } catch (bosdosyaexception e) { e.getmessage(); } return null; } public static arraylist<string> okuyucu2(string filename) { arraylist<string> removed = new arraylist<>(); scanner scan = null; removed. try { scan = new scanner(new fileinputstream(filename)); if (!scan.hasnextline()) { throw new bosdosyaexception(); } while (scan.hasnextline()) { removed.add(scan.nextline()); } scan.close(); return removed; } catch (filenotfoundexception e) { try { throw new dosyabulunamadiexception(); } catch (dosyabulunamadiexception ex) { ex.getmessage(); } } catch (bosdosyaexception e) { e.getmessage(); } return null; } public void kelimeler() { printwriter kelime = null; try { kelime = new printwriter(new fileoutputstream(""sonuc.txt"")); } catch (filenotfoundexception e) { try { throw new dosyabulunamadiexception(); } catch (dosyabulunamadiexception ex) { ex.getmessage(); } } } public static void kelimesayac(string file1, string file2) { if (file1 == null || file2 == null) { return; } string str1 = okuyucu(file1); arraylist<string> str2 = okuyucu2(file2); int counts[] = new int[str2.size()]; int counter = 0; for (int i = 0; i < str2.size(); i++) { int l = str2.get(i).length(); counts[i] = counter; counter = 0; for (int j = 0; j < str1.length(); j++) { if (str2.get(i).equals(str1.substring(j, l))) { counter++; } } } int total = 0; for (int i = 0; i < counts.length; i++) { total += counts[i]; } try { if (total == 0) throw new kelimebulunamadiexception(); } catch (kelimebulunamadiexception e) { e.getmessage(); } } } public class ozellikhatasiexception extends exception { public ozellikhatasiexception() { super(""hata: eşya bilgileri hatali veya eksik.""); } public ozellikhatasiexception(string message) { super(message); } } import java.io.serializable; public class envanterkaydi implements serializable { private string isim; private int stok; public string getisim() { return isim; } public int getstok() { return stok; } public void setstok(int stok) { this.stok = stok; } public void setisim(string isim) { this.isim = isim; } public envanterkaydi(string isim, int stok) { this.isim = isim; this.stok = stok; } public void stokguncelle(int miktar) { try { stok += miktar; if (stok < 0) { throw new stoknegatifexception(); } } catch (stoknegatifexception e) { system.err.println(e.getmessage()); system.exit(0); } } public void tostring(envanterkaydi esya) { system.out.println(""i̇sim: "" + esya.getisim() + "" stok: "" + esya.getstok()); } } import java.io.*; import java.util.scanner; import java.util.arraylist; public class terminalmenu { public static void main(string[] args) { arraylist<envanterkaydi> envanter = new arraylist<>(); scanner scan = new scanner(system.in); system.out.println( ""1)esya ekleme \n2)esya cikarma \n3)stok guncelleme \n4)envanter listeleme \n5)dosyaya kaydetme \n6)dosyadan geri yukleme \n7)cikis""); system.out.println(""i̇stediginiz islemi seciniz.""); int pick = scan.nextint(); system.out.println(""bitirmek için -1 tuslayin.""); while (pick != -1) { if (pick == 1) { try { string eisim; system.out.println(""envanter ismi:""); scan.nextline(); eisim = scan.nextline(); system.out.println(""envanter stogu:""); int estok = scan.nextint(); scan.nextline(); if (eisim == null || estok < 0) { throw new ozellikhatasiexception(); } envanterkaydi esya1 = new envanterkaydi(eisim, estok); envanter.add(esya1); } catch (ozellikhatasiexception e) { system.err.println(e.getmessage()); system.exit(0); } } if (pick == 2) { system.out.println(""cikarmak istediginiz esya ismi:""); string esyaout1 = scan.nextline(); scan.nextline(); system.out.println(""cikarmak istediginiz esya stogu:""); int esyaout2 = scan.nextint(); scan.nextline(); try { envanterkaydi esyaout = new envanterkaydi(esyaout1, esyaout2); for (int i = 0; i < envanter.size(); i++) { if (envanter.get(i).getisim().equals(esyaout1) && envanter.get(i).getstok() == esyaout2) { envanter.remove(esyaout); } else if (!envanter.contains(esyaout)) { throw new esyayokexception(); } } } catch (esyayokexception e) { system.err.println(e.getmessage()); system.exit(0); } } if (pick == 3) { system.out.println(""aradiginiz istediginiz esya ismi:""); string esyas = scan.nextline(); scan.nextline(); system.out.println(""aradiginiz istediginiz esya stogu:""); int esyas1 = scan.nextint(); scan.nextline(); try { envanterkaydi esyas2 = new envanterkaydi(esyas, esyas1); system.out.println(""guncellemek istediginiz miktar:""); int guncel = scan.nextint(); for (int i = 0; i < envanter.size(); i++) { if (envanter.get(i).getisim().equals(esyas) && envanter.get(i).getstok() == esyas1) { esyas2.stokguncelle(guncel); } else { throw new esyayokexception(); } } } catch (esyayokexception e) { system.err.println(e.getmessage()); system.exit(0); } } if (pick == 4) { for (int i = 0; i < envanter.size(); i++) { system.out.println(envanter.get(i).tostring()); } } if (pick == 5) { try { printwriter l = new printwriter(new fileoutputstream(""sabit.txt"")); for (int i = 0; i < envanter.size(); i++) { l.println(envanter.get(i).tostring()); } l.close(); } catch (filenotfoundexception e) { try { throw new dosyabulunamadiexception(); } catch (dosyabulunamadiexception ex) { system.err.println(ex.getmessage()); system.exit(0); } } } if (pick == 6) { scanner read = null; try { read = new scanner(new fileinputstream(""sabit.txt"")); if (!read.hasnext()) { throw new bosdosyaexception(); } read.close(); } catch (filenotfoundexception e) { try { throw new dosyabulunamadiexception(); } catch (dosyabulunamadiexception ex) { system.err.println(ex.getmessage()); system.exit(0); } } catch (bosdosyaexception ep) { system.err.println(ep.getmessage()); system.exit(0); } } if (pick == 7) { system.exit(0); } system.out.println(""i̇stediginiz islemi seciniz.""); int continue = scan.nextint(); pick = continue; } scan.close(); } } public class inputtexception extends exception { public inputtexception() { super(); } public inputtexception(string message) { super(message); } } bil211 quiz 4 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: undoablelist<t> adında bir sınıf oluşturun. bu sınıf, bir arraylist'i genişletmeli ve aşağıdaki ek özelliklere sahip olmalıdır: ● undolast() metodu, en son eklenen öğeyi kaldırmalıdır. ● getlastadded() → son eklenen öğeyi listeyi değiştirmeden döndürür. ● eğer liste boşsa, undolast() bir hata vermemeli, sadece hiçbir şey yapmamalıdır. örnek kullanım: undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] q2: aşağıdaki generic metodu tamamlayın. ● verilen bir collection<t> içinde minimum veya maksimum öğeyi bulan bir metod yazın. ● boolean parametresi true ise maksimumu, false ise minimumu döndürmelidir. ● t öğeleri comparable<t> arabirimini uygulamalıdır. public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { // metodu tamamlayın } örnek kullanım: list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) q3: belirli türdeki elemanları filtreleme ● bir collection<?> içindeki belirli bir türdeki öğeleri filtreleyen bir generic metod yazın. ● class<t> tür filtresi olarak kullanılmalıdır. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { // metodu tamamlayın } örnek kullanım: list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] import java.util.arraylist; import java.util.collection; import java.util.iterator; import java.util.list; public class generic { @suppresswarnings(""unchecked"") public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { iterator<t> i = collection.iterator(); if (findmax) { t max = i.next(); while (i.hasnext()) { if (i.next().compareto(max) > 0) { max = i.next(); } } return max; } else { t min = i.next(); while (i.hasnext()) { if (i.next().compareto(min) > 0) { min = i.next(); } } return min; } } public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { list<t> newlist = new arraylist<t>(); iterator<?> i = collection.iterator(); while (i.hasnext()) { if (i.next().getclass().equals(type)) { newlist.add((t) i.next()); } } return newlist; } } import java.util.arrays; import java.util.list; public class test { public static void main(string[] args) { undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); system.out.println(list.getlastadded()); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(generic.findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(generic.findextreme(numbers, false)); // çıktı: 1 (minimum) list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(generic.filterbytype(mixed, string.class)); // çıktı: [""hello"",""world""] system.out.println(generic.filterbytype(mixed, integer.class)); // çıktı: [1, 3] } } import java.util.arraylist; public class undoablelist<t> extends arraylist { public undoablelist() { } public void undolast() { if (!this.isempty()) { this.remove(this.getlastadded()); } } @suppresswarnings(""unchecked"") public t getlastadded() { object e = this.get(this.size() - 1); t item = (t) e; return item; } } 2 kuş bakışı atış oyunu (top-down shooter) bil 211 - proje teslim tarihi: 27 mart 2025 23:59 1 amaç bu ödevde amacınız, java swing kullanarak kuş bakışı bir atış oyunu (top-down shooter) tasarlamaktır. oyunda, yönettiğimiz karakterin üzerine dalga dalga gelen çeşitli zombileri fare ile hedef alarak farklı silahlar kullanıp öldürmemiz gerekmektedir. karakterimiz öldüğünde oyun sona erecektir. her dalga başına ve öldürülen zombi başına kazanılan puan artacaktır. dalgalar ilerledikçe gelen zombilerin sayısı ve çeşitleri artarak zorluk seviyesi yükselecektir. 2 gereksinimler oyun derste öğrendiğiniz oop ilkelerine uygun sınıf/arayüz tasarımları ile geliştirilmelidir. - zorluk seviyesi arttıkça zombi sayısı ve çeşitliliği artmalıdır. - oyun duraklatılabilmeli ve kaydedilip tekrar yüklenilebilmelidir (fileio kullanılmalıdır). - sol üst köşede seçili silah ve kalan mermi miktarı gösterilmelidir. - sağ üst köşede oyuncunun canı ve toplam puanı gösterilmelidir. - oyunun duraklatılması, kaydedilmesi ve devam ettirilmesi için bir menü bulunmalıdır. 3 silahlar oyunda farklı silahlar bulunmaktadır. belirli zombi dalgaları temizlendikten sonra oyun ödül olarak yeni bir silahverecektir. hersilahınkendineözgübirçalışmamekanizmasıvardır. silahlarınşarjörkapasitesisınırlıdır ve şarjördeki mermiler bittiğinde tekrar doldurulmadan ateş edilemez. toplam mermi sayısı oyuncunun o silaha ait elinde ne kadar mermi olduğunu gösterir. r tuşuna basarak şarjör yeniden doldurulabilir. 3.1 tabanca - şarjör kapasitesi: 12 mermi - ateş hızı: 120 mermi/dakika - elde etme: oyuncu oyuna bu silahla başlar. - özellik: düz atış yapar, sapma yoktur. sınırsız yedek şarjör (diğer tüm silahlar için yedek şarjör ve mermiler rastgele bir şekilde dalga sırasında ve sonlarında zombilerden düşer). 3.2 piyade tüfeği - şarjör kapasitesi: 30 mermi - ateş hızı: 600 mermi/dakika - elde etme: 1. dalga tamamlandıktan sonra - özellik: düzatışyaparancak30derecesapmasıvardır. sapmaaçısı, karakterinbaktığıyöndemerminin her iki dönme yönüne de saçılabileceği maksimum açıdır. 1 3.3 pompalı tüfek - şarjör kapasitesi: 5 mermi - ateş hızı: 60 mermi/dakika - elde etme: 3. dalga tamamlandıktan sonra - özellik: her atış 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi atar (yani karakter merkezli mermi hız vektörleri arasında 5 derece açı olmalıdır). 3.4 keskin nişancı tüfeği - şarjör kapasitesi: 5 mermi - ateş hızı: 30 mermi/dakika - elde etme: 5. dalga tamamlandıktan sonra - özellik: mermileri zombileri delip arasındaki zombilere de hasar verir. 3.5 roketatar - şarjör kapasitesi: 1 roket - ateş hızı: 10 roket/dakika - elde etme: 10. dalga tamamlandıktan sonra - özellik: patlama etkisiyle birden fazla zombiye zarar verir. 4 zombiler zombiler oyundaki düşman tipleridir. zombiler oyuncuya doğru ilerlerler ve eğer oyuncuya temas ederlerse oyuncuya hasar verirler. zorluk seviyesi arttıkça zombilerin sayısı ve çeşitliliği artmaktadır. zombi tipleri birbirinden renk ya da şekil olarak ayırt edilebilmelidir. 4.1 normal zombi - can: orta - hız: yavaş - hasar: orta 4.2 sürünge zombi - can: düşük - hız: hızlı - hasar: orta - özellik: oyuncunun yakınına geldiğinde zıplar. 4.3 tank zombi - can: yüksek - hız: çok yavaş - hasar: yüksek 2 4.4 asit tüküren zombi - can: düşük - hız: yavaş - hasar: orta (uzaktan asit tükürebilir) - özellik: öldürüldüğünde yanındaki birimlere zarar verir. 5 rapor ve teslim formatı - oyun, oopprensiplerineuygunolaraktasarlanmalıvesınıfdiyagramları, arayüztasarımıfinalraporda sunulmalıdır. - oyun test edilerek ekran görüntüleri rapora eklenmelidir. - rapor pdf formatında olmalı ve ismi proje_rapor.pdf olmalıdır. - oyunun mainfonksiyonu gameisimli bir sınıf içinde bulunmalıdır ( java game komutuyla çalışmalı). - kaynak kodun tamamı source.zip (uzantı 7z, rar, tar.gz de olabilir) şeklinde sıkıştırılmış olmalıdır. - sıkıştırılmış kaynak kod ve rapor uzak sistemine yüklenmelidir. 6 yardımcı kaynaklar dahaöncehiçkuşbakışıatışoyunuoynamadıysanızaşağıdakioyunlarıreferansolarakalabilirsiniz. buradaki oyunlarıngrafikleriilemekaniklerisizdenbeklenendenfarklıolsadaharitatasarımı, karakterhareketi,kamera hareketi, ateş etme mekanikleri ve zombilerin yapay zekası ile ilgili temel fikirler edinebilirsiniz. - little top-down shooter: https://www.youtube.com/watch?v=pj3m3fu3i5a - super c - stage 2: https://www.youtube.com/watch?v=os2t_v5suj4 - neon chrome: https://www.youtube.com/watch?v=puhw1bevtro 3 public class sniper extends weapon { public static final int ammo = 5; public static final double speedrate = 30; public static final int wavenumber = 6; private double lastfiredtime = 0; handler handler; public sniper() { super(sniper.class, ammo, speedrate, wavenumber); } public void reload() { if (handler.snipercharger > 0) { if (currentammo != ammo) { currentammo = ammo; } } else { system.out.println(""no charger left!!!""); } } public void fire(int mousex, int mousey, int playerx, int playery, handler handler, spritesheet ss, long currenttime) { if (currenttime - lastfiredtime >= 1000 / speedrate) { double angletoplayer = math.atan2(mousey - playery, mousex - playerx); // create the sniper bullet (penetrating bullet) bullet sniperbullet = new bullet(playerx + 16, playery + 16, handler, mousex, mousey, ss); sniperbullet.setspeedx((float) (angletoplayer)); sniperbullet.setspeedy((float) (angletoplayer)); sniperbullet.setpasser(true); handler.addchar(sniperbullet); lastfiredtime = currenttime; } } } import java.awt.color; import java.awt.font; import java.awt.graphics; import java.awt.event.mouseadapter; import java.awt.event.mouseevent; public class menu extends mouseadapter { private game game; private handler handler; private zombiewave zombiewave; public menu(game game, handler handler) { this.game = game; this.handler = handler; } public void mousepressed(mouseevent e) { int mx = e.getx(); int my = e.gety(); if (game.gamestate == game.state.menu) { if (mouseover(mx, my, 430, 150, 160, 63)) { game.gamestate = game.state.game; zombiewave = new zombiewave(handler); } } } public void mousereleased(mouseevent e) { } private boolean mouseover(int mx, int my, int x, int y, int width, int height) { if (mx > x && mx < x + width) { if (my > y && my < y + height) { return true; } else { return false; } } else { return false; } } public void tick() { } public void render(graphics g) { font f = new font(""arial"", 1, 45); g.setfont(f); g.setcolor(color.red); g.drawstring(""start"", 434, 200); g.drawrect(430, 150, 160, 63); font ft = new font(""arial"", 1, 12); g.setfont(ft); g.setcolor(color.dark_gray); g.drawstring(""press \""p\"" to pause"", 449, 310); g.drawstring(""press \""r\"" to reload the ammo"", 428, 250); g.drawstring(""use w a s d for movement"", 437, 280); } } import java.awt.color; import java.awt.font; import java.awt.graphics; import java.awt.event.mouseadapter; import java.awt.event.mouseevent; public class pausemenu extends mouseadapter { private game game; private handler handler; public pausemenu(game game, handler handler) { this.game = game; this.handler = handler; } public void mousepressed(mouseevent e) { int mx = e.getx(); int my = e.gety(); if (game.gamestate == game.state.pausemenu) { if (mouseover(mx, my, 400, 150, 200, 63)) { savemanager.savegame(game, ""savegame.dat""); system.out.println(""game has been saved""); } else if (mouseover(mx, my, 450, 250, 100, 63)) { loadmanager.loadgame(""savegame.dat""); system.out.println(""game has been loaded""); } } } public void mousereleased(mouseevent e) { } private boolean mouseover(int mx, int my, int x, int y, int width, int height) { if (mx > x && mx < x + width) { if (my > y && my < y + height) { return true; } else { return false; } } else { return false; } } public void tick() { } public void render(graphics g) { font f = new font(""arial"", 1, 45); g.setfont(f); g.setcolor(color.red); g.drawstring(""save"", 445, 200); g.drawrect(400, 150, 200, 63); g.drawstring(""load"", 445, 300); g.drawrect(400, 250, 200, 63); font ft = new font(""arial"", 1, 15); g.setfont(ft); g.setcolor(color.dark_gray); g.drawstring(""press \""p\"" to continue"", 410, 350); } } public class weapon { class<?> currentweapon; int ammo; int currentammo; int wavenumber; double speedrate; int leftcharger; public weapon(class<?> currentweapon, int ammo, double speedrate, int wavenumber) { this.currentweapon = currentweapon; this.ammo = ammo; this.speedrate = speedrate; this.wavenumber = wavenumber; this.currentammo = ammo; } public void fire(int mousex, int mousey, int playerx, int playery, handler handler, spritesheet ss, long currenttime) { } public int getleftcharger() { return leftcharger; } public void setleftcharger(int leftcharger) { this.leftcharger = leftcharger; } public int getammo() { return ammo; } public int getwavenumber() { return wavenumber; } public double getspeedrate() { return speedrate; } public class<?> getcurrentweapon() { return currentweapon; } public weapon getcurrweapon() { return this; } public void setcurrentweapon(class<?> currentweapon) { this.currentweapon = currentweapon; } public void setcurrentweapon(weapon weapon) { this.ammo = weapon.ammo; this.currentweapon = weapon.currentweapon; this.speedrate = weapon.speedrate; this.wavenumber = weapon.wavenumber; } public int getcurrentammo() { return currentammo; } public void setcurrentammo(int consumed) { currentammo = currentammo - consumed; } public void reload() { if (currentammo != ammo) currentammo = ammo; } } import java.awt.color; import java.awt.graphics; import java.awt.rectangle; public class bullet extends gameobject { private handler handler; private game game; private double angle; private boolean ispasser = false;; public void setpasser(boolean ispasser) { this.ispasser = ispasser; } public boolean ispasser() { return ispasser; } private double speed; private double angleadj; public bullet(int x, int y, handler handler, int mx, int my, spritesheet ss) { super(x, y, ss); this.handler = handler; double disx = mx - x; double disy = my - y; double distance = math.sqrt(disx * disx + disy * disy); double baseangle = math.pi + math.atan2(disy, disx); this.angle = baseangle + angleadj; if (distance != 0) { velx += (float) ((disx / distance) * 10.0); vely += (float) ((disy / distance) * 10.0); } else { velx += 0; vely += 0; } } @override public void tick() { x += velx; y += vely; for (int i = 0; i < handler.gamec.size(); i++) { gameobject tempobject = handler.gamec.get(i); if (tempobject.getclass() == block.class) { if (getbounds().intersects(tempobject.getbounds())) { handler.removechar(this); } } } } @override public void render(graphics graphic) { graphic.setcolor(color.black); graphic.filloval(x, y, 5, 5); } @override public rectangle getbounds() { return new rectangle(x, y, 4, 4); } } public class shotgun extends weapon { public static final int ammo = 5; public static final double speedrate = 60; public static final int wavenumber = 4; private static final int bulletspershot = 9; // shotgun fires 9 bullets per shot private static final double angleadj = math.toradians(45); private static final double bulletsep = math.toradians(5); // 5-degree separation between each bullet handler handler; private double lastfiredtime = 0; public shotgun() { super(shotgun.class, ammo, speedrate, wavenumber); } public void reload() { if (handler.shotguncharger > 0) { if (currentammo != ammo) { currentammo = ammo; } } else { system.out.println(""no charger left!!!""); } } public void shoot(int mousex, int mousey, int playerx, int playery, handler handler, spritesheet ss, long currenttime) { if (currenttime - lastfiredtime >= 1000 / speedrate) { double angletoplayer = math.atan2(mousey - playery, mousex - playerx); for (int i = 0; i < bulletspershot; i++) { double angleoffset = -(angleadj / 2) + (i * bulletsep); // calculate angle offset for each bullet bullet bullet = new bullet(playerx + 16, playery + 16, handler, mousex, mousey, ss); bullet.setspeedx((float) (angletoplayer + angleoffset)); bullet.setspeedy((float) (angletoplayer + angleoffset)); handler.addchar(bullet); } lastfiredtime = currenttime; } } } public class reptilezombie extends enemies { public reptilezombie(int x, int y, handler handler, spritesheet ss, class<?> type, zombiewave zombiewave) { super(x, y, handler, ss, type, zombiewave); sethealth(); setdamage(); setspeed(); } public void tick() { super.tick(); } public void setspeed() { this.speed = 3.0; } public void setdamage() { this.damage = 0.25; } public double getdamage() { return damage; } public void sethealth() { this.health = 25; } public int gethealth() { return health; } public void sethealth(double damage) { health -= damage; } } public class normalzombie extends enemies { public normalzombie(int x, int y, handler handler, spritesheet ss, class<?> type, zombiewave zombiewave) { super(x, y, handler, ss, type, zombiewave); sethealth(); setdamage(); setspeed(); } public void tick() { super.tick(); } public void setspeed() { this.speed = 2.5; } public void setdamage() { this.damage = 0.25; } public double getdamage() { return damage; } public void sethealth() { this.health = 50; } public int gethealth() { return health; } public void sethealth(double damage) { health -= damage; } } import java.io.serializable; import java.util.arraylist; import java.util.random; public class zombiewave implements serializable { private int wavenumber = 0; handler handler; arraylist<enemies> zombies = new arraylist<>(); private int waveinterval = 6000; // time between waves (in milliseconds) private int spawninterval = 5000; // time between enemy spawns in the wave (in milliseconds) private long lastwavetime = 0; private long lastspawntime = 0; private int enemiestospawn = 5; private int enemiesspawned = 0; private long currenttime; bufferedimageloader loader = new bufferedimageloader(); public zombiewave(handler handler) { this.handler = handler; } public long getcurrenttime() { return currenttime; } public void tick() { currenttime = system.currenttimemillis(); if (currenttime - lastwavetime >= waveinterval) { lastwavetime = currenttime; spawnwave(); handler.score += 5; } if (currenttime - lastspawntime >= spawninterval && enemiesspawned < enemiestospawn) { lastspawntime = currenttime; spawnenemy(); } } private void spawnwave() { enemiesspawned = 0; wavenumber++; enemiestospawn = wavenumber * 5; system.out.println(""new wave spawned: wave "" + wavenumber + "" with "" + enemiestospawn + "" enemies!""); spawninterval = math.max(1500, 2000 - (wavenumber * 100)); // decrease spawn interval as waves progress } private void spawnenemy() { class<?> enemytype = selectrandomzombietype(); class<?> enemytype1 = selectrandomzombietype1(); class<?> enemytype2 = selectrandomzombietype2(); int spawnx, spawny; int coin = new random().nextint(2); if (coin == 0) { spawnx = 8; spawny = 8; } else { spawnx = 32; spawny = 32; } enemies newenemy = null; if (wavenumber <= 2) { newenemy = new normalzombie(spawnx * 32, spawny * 32, handler, new spritesheet(loader.loadimage(""image\\zombie movement.png"")), enemytype, this); } else if (wavenumber > 2 && wavenumber <= 6) { switch (enemytype1.getsimplename()) { case ""normalzombie"": newenemy = new normalzombie(spawnx * 32, spawny * 32, handler, new spritesheet(loader.loadimage(""image\\zombie movement.png"")), enemytype, this); break; case ""acidiczombie"": newenemy = new acidiczombie(spawnx * 32, spawny * 32, handler, new spritesheet(loader.loadimage(""image\\zombie.png"")), enemytype, this); break; } } else if (wavenumber > 6 && wavenumber <= 9) { switch (enemytype2.getsimplename()) { case ""normalzombie"": newenemy = new normalzombie(spawnx * 32, spawny * 32, handler, new spritesheet(loader.loadimage(""image\\zombie movement.png"")), enemytype, this); break; case ""acidiczombie"": newenemy = new acidiczombie(spawnx * 32, spawny * 32, handler, new spritesheet(loader.loadimage(""image\\zombie.png"")), enemytype, this); break; case ""reptilezombie"": newenemy = new reptilezombie(spawnx * 32, spawny * 32, handler, new spritesheet(loader.loadimage(""image\\reptilezombie.png"")), enemytype, this); break; } } else if (wavenumber >= 10) { switch (enemytype.getsimplename()) { case ""normalzombie"": newenemy = new normalzombie(spawnx * 32, spawny * 32, handler, new spritesheet(loader.loadimage(""image\\zombie movement.png"")), enemytype, this); break; case ""acidiczombie"": newenemy = new acidiczombie(spawnx * 32, spawny * 32, handler, new spritesheet(loader.loadimage(""image\\zombie.png"")), enemytype, this); break; case ""reptilezombie"": newenemy = new reptilezombie(spawnx * 32, spawny * 32, handler, new spritesheet(loader.loadimage(""image\\reptilezombie.png"")), enemytype, this); break; case ""tankzombie"": newenemy = new tankzombie(spawnx * 32, spawny * 32, handler, new spritesheet(loader.loadimage(""image\\tankzombie.png"")), enemytype, this); break; } } handler.addchar(newenemy); enemiesspawned++; } private class<?> selectrandomzombietype() { random random = new random(); int randomchoice = random.nextint(4); switch (randomchoice) { case 0: return normalzombie.class; case 1: return acidiczombie.class; case 2: return reptilezombie.class; case 3: return tankzombie.class; default: return normalzombie.class; } } private class<?> selectrandomzombietype2() { random random = new random(); int randomchoice = random.nextint(3); switch (randomchoice) { case 0: return normalzombie.class; case 1: return acidiczombie.class; case 2: return reptilezombie.class; default: return normalzombie.class; } } private class<?> selectrandomzombietype1() { random random = new random(); int randomchoice = random.nextint(2); switch (randomchoice) { case 0: return normalzombie.class; case 1: return acidiczombie.class; default: return normalzombie.class; } } public int getwavenumber() { return wavenumber; } public int getwaveinterval() { return waveinterval; } public int getspawninterval() { return spawninterval; } public long getlastwavetime() { return lastwavetime; } public long getlastspawntime() { return lastspawntime; } public int getenemiestospawn() { return enemiestospawn; } public int getenemiesspawned() { return enemiesspawned; } } import java.awt.event.*; public class keyinput extends keyadapter { handler handler; // yeni instance oluşturmayıp aynı handleri kullanıyoruz eğer yeni handler // oluşturursak yeni liste oluşturur. private game game; private weapon weapon; public keyinput(handler handler, game game, weapon weapon) { this.handler = handler; this.game = game; this.weapon = weapon; } public void keypressed(keyevent e) { int key = e.getkeycode(); for (int i = 0; i < handler.gamec.size(); i++) { gameobject gamechar = handler.gamec.get(i); if (gamechar.getclass() == player.class) { if (key == keyevent.vk_w) { handler.setup(true); } if (key == keyevent.vk_s) { handler.setdown(true); } if (key == keyevent.vk_a) { handler.setleft(true); } if (key == keyevent.vk_d) { handler.setright(true); } } } if (e.getkeycode() == keyevent.vk_p) { handler.togglepause(); if (handler.ispaused()) { game.gamestate = game.state.pausemenu; } else if (!handler.ispaused()) { game.gamestate = game.state.game; } } else if (e.getkeycode() == keyevent.vk_r) { weapon.reload(); } if (e.getkeycode() == keyevent.vk_1) { for (int i = 0; i < handler.weapons.size(); i++) { if (handler.weapons.get(i).getcurrentweapon().equals(handgun.class)) { weapon.setcurrentweapon(handler.weapons.get(i)); } } } else if (e.getkeycode() == keyevent.vk_2) { for (int i = 0; i < handler.weapons.size(); i++) { if (handler.weapons.get(i).getcurrentweapon().equals(rifle.class)) { weapon.setcurrentweapon(handler.weapons.get(i)); } } } else if (e.getkeycode() == keyevent.vk_3) { for (int i = 0; i < handler.weapons.size(); i++) { if (handler.weapons.get(i).getcurrentweapon().equals(shotgun.class)) { weapon.setcurrentweapon(handler.weapons.get(i)); } } } else if (e.getkeycode() == keyevent.vk_4) { for (int i = 0; i < handler.weapons.size(); i++) { if (handler.weapons.get(i).getcurrentweapon().equals(sniper.class)) { weapon.setcurrentweapon(handler.weapons.get(i)); } } } else if (e.getkeycode() == keyevent.vk_5) { for (int i = 0; i < handler.weapons.size(); i++) { if (handler.weapons.get(i).getcurrentweapon().equals(rocketlauncher.class)) { weapon.setcurrentweapon(handler.weapons.get(i)); } } } } public void keyreleased(keyevent e) { int key = e.getkeycode(); for (int i = 0; i < handler.gamec.size(); i++) { gameobject gamechar = handler.gamec.get(i); if (gamechar.getclass() == player.class) { if (key == keyevent.vk_w) { handler.setup(false); } if (key == keyevent.vk_s) { handler.setdown(false); } if (key == keyevent.vk_a) { handler.setleft(false); } if (key == keyevent.vk_d) { handler.setright(false); } } } } } import java.awt.graphics; import java.awt.rectangle; import java.awt.image.bufferedimage; public class block extends gameobject { private bufferedimage block1 = null; public block(int x, int y, spritesheet ss) { super(x, y, ss); block1 = ss.grabimage16(32, 5, 32, 32);// 13 20 32 32 } @override public void tick() { } @override public void render(graphics graphic) { graphic.drawimage(block1, x, y, null); } @override public rectangle getbounds() { return new rectangle(x, y, 32, 32); } } import java.awt.graphics; import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; public class enemies extends gameobject { protected bufferedimage enemyimg = null; private double rotationspeed = 2.0; private double direction; zombiewave zombiewave; private game game; handler handler; private class<?> type; protected int health; protected double damage; protected int playerx, playery; protected double speed; public double getdamage() { return damage; } public int gethealth() { return health; } public void sethealth(double damage) { health -= damage; } public class<?> gettype() { return type; } public enemies(int x, int y, handler handler, spritesheet ss, class<?> type, zombiewave zombiewave) { super(x, y, ss); this.handler = handler; this.zombiewave = zombiewave; this.type = type; enemyimg = ss.grabimage32(1, 1, 32, 32); } @override public void tick() { x += velx; y += vely; for (int i = 0; i < handler.gamec.size(); i++) { gameobject tempobject = handler.gamec.get(i); if (tempobject.getclass() == block.class) { if (getbounds2().intersects(tempobject.getbounds())) { x += velx * -1; y += vely * -1; } } if (tempobject.getclass() == bullet.class) { bullet bullet = (bullet) tempobject; if (getbounds().intersects(tempobject.getbounds())) { health -= 25; if (health <= 0) { handler.removechar(this); handler.zombiecounter++; if (this.getclass() == normalzombie.class) { if (zombiewave.getwavenumber() >= 1 && !handler.weapons.contains(handler.handgun)) { handler.weapons.add(handler.handgun); } if (zombiewave.getwavenumber() >= 2 && !handler.weapons.contains(handler.rifle)) { handler.weapons.add(handler.rifle); system.out.println(""rifle added to inventory!""); } if (handler.zombiecounter % 5 == 0) handler.riflecharger += 2; handler.score += 10; } else if (this.getclass() == acidiczombie.class || this.getclass() == reptilezombie.class) { if (zombiewave.getwavenumber() >= 4 && !handler.weapons.contains(handler.shotgun)) { handler.weapons.add(handler.shotgun); system.out.println(""shotgun added to inventory!""); } if (handler.zombiecounter % 5 == 0) handler.riflecharger += 2; if (zombiewave.getwavenumber() >= 6 && !handler.weapons.contains(handler.sniper)) { handler.weapons.add(handler.sniper); system.out.println(""sniper added to inventory!""); } if (handler.zombiecounter % 9 == 0) handler.snipercharger += 2; handler.score += 5; } else if (this.getclass() == tankzombie.class) { if (zombiewave.getwavenumber() >= 11 && !handler.weapons.contains(handler.rocketlauncher)) { handler.weapons.add(handler.rocketlauncher); system.out.println(""rocketlauncher added to inventory!""); } if (handler.zombiecounter % 11 == 0) handler.rocketcharger += 2; handler.score += 15; } } if (!bullet.ispasser()) { handler.removechar(bullet); } } } if (tempobject instanceof enemies) { if (getbounds2().intersects(tempobject.getbounds())) { velx += (velx * 2) * -1; vely += (vely * 2) * -1; } } if (tempobject.getclass() == player.class) { if (getbounds2().intersects(tempobject.getbounds())) { if (this.getclass() == acidiczombie.class) { acidiczombie ac = (acidiczombie) this; damage = ac.getdamage(); } } else if (getbounds().intersects(tempobject.getbounds())) { switch (this.gettype().getsimplename()) { case ""normalzombie"": normalzombie normzomb = (normalzombie) this; damage = normzomb.getdamage(); break; case ""acidiczombie"": acidiczombie acidzomb = (acidiczombie) this; damage = acidzomb.getdamage(); break; case ""reptilezombie"": reptilezombie repzomb = (reptilezombie) this; damage = repzomb.getdamage(); break; case ""tankzombie"": tankzombie tankzomb = (tankzombie) this; damage = tankzomb.getdamage(); break; default: damage = 0.25; break; } } } } for ( int i = 0; i < handler.gamec.size(); i++) { if (handler.gamec.get(i).getclass() == player.class) { playerx = handler.gamec.get(i).getx(); playery = handler.gamec.get(i).gety(); } } for (int i = 0; i < handler.gamec.size(); i++) { gameobject temp = handler.gamec.get(i); if (temp.getclass() == player.class) { player player = (player) temp; if (this.getclass() == reptilezombie.class) { if (getbounds().intersects(player.getbounds2())) { this.x = playerx; this.y = playery; } } } } int dx = playerx - x; int dy = playery - y; double angle = math.atan2(dy, dx); velx = (int) (speed * math.cos(angle)); vely = (int) (speed * math.sin(angle)); x += velx; y += vely; double targetdirection = math.atan2(playery - (y + 24), playerx - (x + 24)); double angledifference = targetdirection - direction; if (angledifference > math.pi) angledifference -= 2 * math.pi; if (angledifference < -math.pi) angledifference += 2 * math.pi; if (math.abs(angledifference) > rotationspeed) { direction += rotationspeed * math.signum(angledifference); } else { direction = targetdirection; } } @override public void render(graphics graphic) { graphics2d g2d = (graphics2d) graphic; g2d.rotate(direction, x + 24, y + 24); g2d.drawimage(enemyimg, x, y, null); g2d.rotate(-direction, x + 24, y + 24); } @override public rectangle getbounds() { return new rectangle(x, y, 32, 32); } public rectangle getbounds2() { return new rectangle(x - 16, y - 16, 64, 64); } } import java.awt.color; import java.awt.graphics; import java.awt.rectangle; public class rocket extends gameobject { private double angle; private boolean isexploded = false; private int explosionradius = 50; handler handler; public rocket(int x, int y, handler handler, int targetx, int targety, spritesheet ss) { super(x, y, ss); this.handler = handler; double disx = targetx - x; double disy = targety - y; double distance = math.sqrt(disx * disx + disy * disy); this.angle = math.atan2(disy, disx); // velocity of the rocket velx = (float) ((disx / distance) * 5.0); // adjust velocity as needed vely = (float) ((disy / distance) * 5.0); } @override public void tick() { if (!isexploded) { x += velx; y += vely; // check for collision with blocks or other objects for (int i = 0; i < handler.gamec.size(); i++) { gameobject tempobject = handler.gamec.get(i); if (tempobject.getclass() == block.class || tempobject.getclass() == enemies.class) { // if the rocket hits a block or an enemy, trigger the explosion if (getbounds().intersects(tempobject.getbounds())) { triggerexplosion(); handler.removechar(this); // remove rocket after explosion break; } } } } } private void triggerexplosion() { // explosion effect: damage enemies in the explosion radius for (int i = 0; i < handler.gamec.size(); i++) { gameobject tempobject = handler.gamec.get(i); if (tempobject instanceof enemies) { enemies enemy = (enemies) tempobject; // calculate the distance between the explosion and the enemy double distance = math.sqrt(math.pow(enemy.getx() - x, 2) + math.pow(enemy.gety() - y, 2)); // if the enemy is within the explosion radius, apply damage if (distance <= explosionradius) { enemy.sethealth(100); // adjust damage as needed } } } // mark the rocket as exploded isexploded = true; } @override public void render(graphics graphic) { graphic.setcolor(color.red); graphic.filloval(x, y, 10, 10); } @override public rectangle getbounds() { return new rectangle(x, y, 10, 10); } } public class handgun extends weapon { public static final int ammo = 12; public static final double speedrate = 120; public static final int wavenumber = 1; private double lastfiredtime = 0; handler handler; public handgun() { super(handgun.class, ammo, speedrate, wavenumber); } public void fire(int mousex, int mousey, int playerx, int playery, handler handler, spritesheet ss, long currenttime) { if (currenttime - lastfiredtime >= 1000 / speedrate) { bullet bullet = new bullet(playerx + 16, playery + 16, handler, mousex, mousey, ss); handler.addchar(bullet); lastfiredtime = currenttime; } } } public class acidiczombie extends enemies { public acidiczombie(int x, int y, handler handler, spritesheet ss, class<?> type, zombiewave zombiewave) { super(x, y, handler, ss, type, zombiewave); sethealth(); setdamage(); setspeed(); } public void tick() { super.tick(); } public void setspeed() { this.speed = 2.5; } public void setdamage() { this.damage = 0.5; } public double getdamage() { return damage; } public void sethealth() { this.health = 25; } public int gethealth() { return health; } public void sethealth(double damage) { health -= damage; } } import java.util.arraylist; import java.util.linkedlist; import java.awt.*; import java.io.serializable; public class handler implements serializable { private boolean up = false, down = false, left = false, right = false, ispaused = false; int score; linkedlist<gameobject> gamec = new linkedlist<gameobject>(); arraylist<weapon> weapons = new arraylist<>(); weapon handgun = new handgun(); weapon rifle = new rifle(); weapon shotgun = new shotgun(); weapon sniper = new sniper(); weapon rocketlauncher = new rocketlauncher(); int zombiecounter; int riflecharger = 1; int shotguncharger = 1; int snipercharger = 1; int rocketcharger = 1; public void tick() { for (int i = 0; i < gamec.size(); i++) { gameobject tempchar = gamec.get(i); tempchar.tick(); } } public boolean ispaused() { return ispaused; } public void togglepause() { ispaused = !ispaused; } public boolean isup() { return up; } public void setup(boolean up) { this.up = up; } public boolean isdown() { return down; } public void setdown(boolean down) { this.down = down; } public boolean isleft() { return left; } public void setleft(boolean left) { this.left = left; } public boolean isright() { return right; } public void setright(boolean right) { this.right = right; } public void render(graphics graphic) { for (int i = 0; i < gamec.size(); i++) { gameobject tempchar = gamec.get(i); tempchar.render(graphic); } } public void addchar(gameobject gamechar) { gamec.add(gamechar); } public void removechar(gameobject gamechar) { gamec.remove(gamechar); } public boolean contains(weapon weapon) { for (int i = 0; i < weapons.size(); i++) { weapon temp = weapons.get(i); if (temp.getclass() == weapon.getclass()) { return true; } } return false; } } import java.util.random; public class rifle extends weapon { public static final int ammo = 30; public static final double speedrate = 600; public static final int wavenumber = 2; private static final double angleadj = math.toradians(30); private double lastfiredtime = 0; handler handler; public rifle() { super(rifle.class, ammo, speedrate, wavenumber); } public void reload() { if (handler.riflecharger > 0) { if (currentammo != ammo) { currentammo = ammo; } } else { system.out.println(""no charger left!!!""); } } public void fire(int mousex, int mousey, int playerx, int playery, handler handler, spritesheet ss, long currenttime) { if (currenttime - lastfiredtime >= 1000 / speedrate) { bullet bullet1 = new bullet(playerx + 16, playery + 16, handler, mousex, mousey, ss); bullet bullet2 = new bullet(playerx + 16, playery + 16, handler, mousex, mousey, ss); bullet1.setspeedx((float) (+getrandomdeviation())); bullet1.setspeedy((float) (+getrandomdeviation())); bullet2.setspeedx((float) (-getrandomdeviation())); bullet2.setspeedy((float) (-getrandomdeviation())); handler.addchar(bullet1); handler.addchar(bullet2); lastfiredtime = currenttime; } } private double getrandomdeviation() { random rand = new random(); return rand.nextdouble() * angleadj * 2 - angleadj; // random value between -angleadj and +angleadj } } public class tankzombie extends enemies { public tankzombie(int x, int y, handler handler, spritesheet ss, class<?> type, zombiewave zombiewave) { super(x, y, handler, ss, type, zombiewave); sethealth(); setdamage(); setspeed(); } public void tick() { super.tick(); } public void setspeed() { this.speed = 2.0; } public void setdamage() { this.damage = 0.5; } public double getdamage() { return damage; } public void sethealth() { this.health = 85; } public int gethealth() { return health; } public void sethealth(double damage) { health -= damage; } } import java.io.fileoutputstream; import java.io.objectoutputstream; public class savemanager { public static void savegame(game game, string filename) { objectoutputstream outst; try { outst = new objectoutputstream(new fileoutputstream(filename)); outst.writeobject(game); outst.close(); } catch (exception e) { system.err.println(e.getmessage()); } } } import java.awt.image.*; import java.io.ioexception; import javax.imageio.imageio; public class bufferedimageloader { private bufferedimage image; public bufferedimage loadimage(string path) { try { image = imageio.read(getclass().getresource(path)); } catch (ioexception e) { e.printstacktrace(); } return image; } } import java.awt.color; import java.awt.font; import java.awt.graphics; import java.awt.event.mouseadapter; import java.awt.event.mouseevent; public class gameover extends mouseadapter { private game game; private handler handler; public gameover(game game, handler handler) { this.game = game; this.handler = handler; } public void mousepressed(mouseevent e) { int mx = e.getx(); int my = e.gety(); if (mouseover(mx, my, 375, 200, 255, 63)) { if (game.gamestate == game.state.gameover) system.exit(0); } } public void mousereleased(mouseevent e) { } private boolean mouseover(int mx, int my, int x, int y, int width, int height) { if (mx > x && mx < x + width) { if (my > y && my < y + height) { return true; } else { return false; } } else { return false; } } public void tick() { } public void render(graphics g) { font f = new font(""arial"", 1, 40); g.setfont(f); g.setcolor(color.red); g.drawstring(""game over"", 380, 250); g.drawrect(375, 200, 255, 63); font ft = new font(""arial"", 1, 12); g.setfont(ft); g.setcolor(color.dark_gray); g.drawstring(""enter to exit"", 465, 290); g.drawstring(""score : "" + handler.score, 470, 180); } } import java.awt.canvas; import java.awt.color; import java.awt.*; import java.awt.font; import java.awt.graphics; import java.awt.graphics2d; import java.awt.graphics2d.*; import java.awt.geom.affinetransform; import java.awt.image.bufferstrategy; import java.awt.image.bufferedimage; public class game extends canvas implements runnable { private boolean isrunning = false; private thread thread; private handler handler; private zombiewave zombiewave; private weapon weapon; affinetransform transform; private bufferedimage spritesheet = null; private bufferedimage spritesheet2 = null; private bufferedimage spritesheet3 = null; private bufferedimage spritesheet4 = null; private bufferedimage img = null; private bufferedimage background = null; private camera camera; private spritesheet ss; private spritesheet ss2; private spritesheet ss3; private spritesheet ss4; private player player; private menu menu; private gameover gameover; private pausemenu pausemenu; public enum state { menu, game, gameover, pausemenu }; public state gamestate = state.menu; public spritesheet getss3() { return ss3; } public game() { new window(1000, 563, ""top down shooter"", this); start(); synchronized (this) { handler = new handler(); zombiewave = new zombiewave(handler); camera = new camera(0, 0); menu = new menu(this, handler); gameover = new gameover(this, handler); pausemenu = new pausemenu(this, handler); weapon = new handgun(); } this.addkeylistener(new keyinput(handler, this, weapon)); bufferedimageloader loader = new bufferedimageloader(); img = loader.loadimage(""image\\pixil-frame-0.png""); spritesheet = loader.loadimage(""image\\apocalypse.png""); ss = new spritesheet(spritesheet); spritesheet2 = loader.loadimage(""image\\tileset-grassland-grass.png""); ss2 = new spritesheet(spritesheet2); spritesheet3 = loader.loadimage(""image\\zombie movement.png""); ss3 = new spritesheet(spritesheet3); spritesheet4 = loader.loadimage(""image\\ekran görüntüsü (4).png""); ss4 = new spritesheet(spritesheet4); background = ss2.grabimage160(1, 1, 160, 160); this.addmouselistener(menu); this.addmouselistener(gameover); this.addmouselistener(pausemenu); this.addmouselistener(new mouseinput(handler, camera, weapon, zombiewave, ss)); this.addmousemotionlistener(new mouseinput(handler, camera, weapon, zombiewave, ss)); loading(img); if (gamestate == state.game) { zombiewave = new zombiewave(handler); } } private void start() { isrunning = true; thread = new thread(this);// by mean this, it is this classes run method thread.start(); } private void stop() { isrunning = false; try { thread.join(); } catch (interruptedexception e) { e.printstacktrace(); } } public void savegame() { savemanager.savegame(this, ""savegame.dat""); } public void loadgame() { game loadedgame = loadmanager.loadgame(""savegame.dat""); if (loadedgame != null) { this.player = loadedgame.player; this.handler = loadedgame.handler; this.gamestate = loadedgame.gamestate; this.weapon = loadedgame.weapon; this.zombiewave = loadedgame.zombiewave; } } public synchronized void tick() { if (!handler.ispaused()) { for (int i = 0; i < handler.gamec.size(); i++) { if (handler.gamec.get(i).getclass() == player.class) { camera.tick(handler.gamec.get(i)); } } handler.tick(); if (gamestate == state.game) { zombiewave.tick(); } else if (gamestate == state.menu) { if (menu != null) { menu.tick(); } else { system.out.println(""menu is null in tick()""); } } else if (gamestate == state.gameover) { gameover.tick(); } } else { pausemenu.tick(); } } public void render() { bufferstrategy buffers = this.getbufferstrategy();// when it created it becames null if (buffers == null) { this.createbufferstrategy(3);// its creates buffers with 3 arguments, number of frames that loaded if we // make it 30 it will slows our game return; } graphics graphic = buffers.getdrawgraphics(); graphics2d g2d = (graphics2d) graphic; if (!handler.ispaused()) { ////////////////////////////////////////////////// g2d.translate(-camera.getx(), -camera.gety()); for (int xx = 0; xx < 30 * 72; xx += 160) { for (int yy = 0; yy < 30 * 72; yy += 160) { graphic.drawimage(background, xx, yy, null); } } handler.render(graphic); g2d.translate(camera.getx(), camera.gety()); if (gamestate == state.game) { font f = new font(""arial"", 1, 9); graphic.setfont(f); graphic.drawstring(""ammo : "" + weapon.getcurrentammo(), 10, 30); graphic.drawstring(""current weapon : "" + weapon.getcurrentweapon().getsimplename(), 10, 50); graphic.drawstring(""score : "" + handler.score, 905, 30); graphic.drawstring(""health : "" + player.gethealth(), 905, 50); } else if (gamestate == state.menu) { menu.render(graphic); } else if (gamestate == state.gameover) { gameover.render(graphic); } //////////////////////////////////////////////// } else { pausemenu.render(graphic); } graphic.dispose(); buffers.show(); } private void loading(bufferedimage image) { int w = image.getwidth(); int h = image.getheight(); for (int xx = 0; xx < w; xx++) { for (int yy = 0; yy < h; yy++) { int pixel = image.getrgb(xx, yy); int red = (pixel >> 16) & 0xff; int green = (pixel >> 8) & 0xff; int blue = (pixel) & 0xff; if (red == 255 && blue == 0 && green == 0) { handler.addchar(new block(xx * 32, yy * 32, ss)); } if (blue == 255 && red == 0 && green == 0) { player = new player(xx * 32, yy * 32, handler, ss4, this); handler.addchar(player); } } } } @override public void run() { this.requestfocus(); long lasttime = system.nanotime(); double amountofticks = 60.0; double ns = 1000000000 / amountofticks; double delta = 0; long timer = system.currenttimemillis(); int frames = 0; while (isrunning) { long now = system.nanotime(); delta += (now - lasttime) / ns; lasttime = now; while (delta >= 1) { tick(); delta--; } render(); frames++; if (system.currenttimemillis() - timer > 1000) { timer += 1000; frames = 0; } } stop(); } public static void main(string[] args) { new game(); } } import java.awt.event.mouseadapter; import java.awt.event.mouseevent; public class mouseinput extends mouseadapter { private handler handler; private camera camera; private weapon weapon; private spritesheet ss; public static float x, y; private zombiewave zombiewave; public mouseinput(handler handler, camera camera, weapon weapon, zombiewave zombiewave, spritesheet ss) { this.handler = handler; this.camera = camera; this.weapon = weapon; this.ss = ss; this.zombiewave = zombiewave; } public void mousemoved(mouseevent e) { // update mouse position when moved x = e.getx() + camera.getx(); y = e.gety() + camera.gety(); } public void mousepressed(mouseevent e) { int mx = (int) (e.getx() + camera.getx()); int my = (int) (e.gety() + camera.gety()); for (int i = 0; i < handler.gamec.size(); i++) { gameobject tempobject = handler.gamec.get(i); if (tempobject.getclass() == player.class) { // handler.addchar(new bullet(tempobject.getx() + 16, tempobject.gety() + 24, // handler, mx, my, ss)); weapon.getcurrweapon().fire(mx, my, tempobject.getx(), tempobject.gety(), handler, ss, zombiewave.getcurrenttime()); weapon.setcurrentammo(1); } if (weapon.getcurrentammo() <= 0) break; } } } public class camera { private float x, y; public camera(float x, float y) { this.x = x; this.y = y; } public void tick(gameobject gameobject) { x += ((gameobject.getx() - x) - 1000 / 2) * 0.05f; y += ((gameobject.gety() - y) - 563 / 2) * 0.05f; if (x <= 0) x = 0; if (x >= 1032) x = 1032; if (y <= 0) y = 0; if (y >= 611) y = 611; } public float getx() { return x; } public void setx(float x) { this.x = x; } public float gety() { return y; } public void sety(float y) { this.y = y; } } import java.awt.image.*; public class spritesheet { private bufferedimage img; public spritesheet(bufferedimage img) { this.img = img; } public bufferedimage grabimage16(int col, int row, int width, int height) { return img.getsubimage((col * 16) - 16, (row * 16) - 16, width, height); } public bufferedimage grabimage32(int col, int row, int width, int height) { return img.getsubimage((col * 32) - 32, (row * 32) - 32, width, height); } public bufferedimage grabimage48(int col, int row, int width, int height) { return img.getsubimage((col * 48) - 48, (row * 48) - 48, width, height); } public bufferedimage grabimage160(int col, int row, int width, int height) { return img.getsubimage((col * 160) - 160, (row * 160) - 160, width, height); } } public class rocketlauncher extends weapon { public static final int ammo = 1; public static final double speedrate = 10; public static final int wavenumber = 11; handler handler; public rocketlauncher() { super(rocketlauncher.class, ammo, speedrate, wavenumber); } public void reload() { if (handler.rocketcharger > 0) { if (currentammo != ammo) { currentammo = ammo; } } else { system.out.println(""no charger left!!!""); } } public void fire(int x, int y, int targetx, int targety, spritesheet ss) { rocket rocket = new rocket(x, y, handler, targetx, targety, ss); handler.addchar(rocket); } } import java.io.fileinputstream; import java.io.objectinputstream; public class loadmanager { public static game loadgame(string filename) { game game = null; objectinputstream inst; try { inst = new objectinputstream(new fileinputstream(filename)); game = (game) inst.readobject(); inst.close(); } catch (exception e) { system.err.println(e.getmessage()); } return game; } } import javax.swing.*; import java.awt.*; public class window { public window(int width, int height, string title, game game) { jframe window = new jframe(title); window.setpreferredsize(new dimension(width, height)); window.setmaximumsize(new dimension(width, height)); window.setminimumsize(new dimension(width, height)); window.add(game); window.setresizable(false); window.setlocationrelativeto(null); window.setdefaultcloseoperation(jframe.exit_on_close); window.setvisible(true); } } import java.awt.graphics; import java.awt.graphics2d; import java.awt.rectangle; import java.awt.image.bufferedimage; public class player extends gameobject { handler handler; private game game; private bufferedimage playerimg = null; private int health; private double direction; private double rotationspeed = 0.2; private double targetdirection; public player(int x, int y, handler handler, spritesheet ss, game game) { super(x, y, ss); this.handler = handler; sethealth(); playerimg = ss.grabimage48(1, 1, 48, 48); this.game = game; } public int gethealth() { return health; } public void sethealth() { this.health = 200; } public void sethealth(double damage) { health -= damage; } @override public void tick() { x += velx; y += vely; collision(); if (handler.isup()) { vely = -5; } else if (!handler.isdown()) { vely = 0; } if (handler.isdown()) { vely = 5; } else if (!handler.isup()) { vely = 0; } if (handler.isright()) { velx = 5; } else if (!handler.isleft()) { velx = 0; } if (handler.isleft()) { velx = -5; } else if (!handler.isright()) { velx = 0; } double mousex = mouseinput.x; double mousey = mouseinput.y; targetdirection = math.atan2(mousey - (y + 24), mousex - (x + 24)); double angledifference = targetdirection - direction; if (angledifference > math.pi) angledifference -= 2 * math.pi; if (angledifference < -math.pi) angledifference += 2 * math.pi; if (math.abs(angledifference) > rotationspeed) { direction += rotationspeed * math.signum(angledifference); } else { direction = targetdirection; } } private void collision() { for (int i = 0; i < handler.gamec.size(); i++) { gameobject tempobject = handler.gamec.get(i); if (tempobject.getclass() == block.class) { if (getbounds().intersects(tempobject.getbounds())) { x += velx * -1; y += vely * -1; } } else if (tempobject instanceof enemies) { if (getbounds().intersects(tempobject.getbounds())) { velx += (velx * 2) * -1; vely += (vely * 2) * -1; enemies enemy = (enemies) tempobject; double damage = enemy.getdamage(); system.out.println( ""player collided with "" + enemy.getclass().getsimplename() + "" - damage: "" + damage); health -= damage; if (health <= 0) { handler.removechar(this); game.gamestate = game.state.gameover; } } } } } @override public void render(graphics graphic) { graphics2d g2d = (graphics2d) graphic; g2d.rotate(direction, x + 24, y + 24); g2d.drawimage(playerimg, x, y, null); g2d.rotate(-direction, x + 24, y + 24); } @override public rectangle getbounds() { return new rectangle(x, y, 48, 48); } public rectangle getbounds2() { return new rectangle(x - 16, y - 16, 96, 96); } } import java.awt.graphics; import java.awt.rectangle; import java.awt.geom.affinetransform; import java.io.serializable; public abstract class gameobject implements serializable { protected int x; protected int y; protected float velx = 0; protected float vely = 0; protected spritesheet ss; protected affinetransform transform; public gameobject(int x, int y, spritesheet ss) { this.x = x; this.y = y; this.ss = ss; } public int getx() { return x; } public void setx(int x) { this.x = x; } public int gety() { return y; } public void sety(int y) { this.y = y; } public float getspeedx() { return velx; } public void setspeedx(float speedx) { this.velx += speedx; } public float getspeedy() { return vely; } public void setspeedy(float speedy) { this.vely += speedy; } public abstract void tick(); public abstract void render(graphics graphic); public abstract rectangle getbounds(); }"
6914659,3,"recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class cocktailshaker{ public static void cocktailsort(int[] array2){ csrec(array2, 0, array2.length - 1); } public static void csrec(int[] array1, int ilk, int son){ if (ilk >= son) //base case return; boolean degistir = false; for (int i=ilk ; i<son ; i++){//soldan sağa doğru kontrol ediyorum if (array1[i] > array1[i+1]){ //buradaki durum 5,4 durumu. bunu 4,5 yapmaya çalışıyorum yer_degistirme(array1, i, i+1); //soldaki ile sağdakinin yerini değiştirdim degistir = true; //değiştirme işleminin yapıldığını göstermek için } } if (!degistir){ //değiştirme işleminin yani yer_degistirme metodunun kullanılıp kullanılmadığını kontrol ediyorum /* eğer değiştirme işlemi yapılsaydı ""degistir"" değeri true olacaktı ve bu blok false olacağı için çalışmazdı değiştirme işlemi yapılmazsa ""degistir"" değeri false olarak kalacağı için blok true olur ve çalışır. */ return; } degistir = false; for (int i = son-1 ; i>ilk ; i--){//sağdan sola doğru kontrol ediyorum if (array1[i-1] > array1[i]){ yer_degistirme(array1, i-1, i);//sağdaki ile soldakinin yerini değiştirdim degistir = true; //değiştirme işleminin yapıldığını göstermek için } } csrec(array1, ilk+1, son-1);//arrayın ilk elemanı ile son elemanını attım } public static void yer_degistirme(int[] arr, int a, int b){ int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; } public static void main(string[] args){ int[] array3 = {5, 4, 1, 2}; cocktailsort(array3); for (int a: array3){ system.out.print(a + "" ""); } } } public class collatz{ public static int collatz(int i){ int sum = i; if(i == 1) //base case return 0; if(i % 2 == 0){ //çiftse ikiye böl sum /= 2; return 1 + collatz(sum); } else{ //tekse 3 ile çarp 1 ekle sum = (sum*3)+1; return 1 + collatz(sum); } } public static void main(string[] args) { system.out.println(collatz(5)); } } public class sayacwithhelpermethod { string str; public sayacwithhelpermethod(string str){ this.str = str; } public int helper(string str) { int currentcount = 0; if(str.length() == 0) //base case return 0; if(str.charat(0)=='1') return 1+helper(str.substring(1)); return currentcount + helper(str.substring(1)); } public int say(){ if(str.length() == 0) return 0; if(str.charat(0)=='1'){ str = str.substring(1); return 1 + say(); } else{ str = str.substring(1); return say(); } } public static void main(string[] args) { sayacwithhelpermethod s1 = new sayacwithhelpermethod(""10001""); sayacwithhelpermethod s2 = new sayacwithhelpermethod(""1111""); sayacwithhelpermethod s3 = new sayacwithhelpermethod(""11190002""); system.out.println(""sayac with helper method""); system.out.println(s1.say()); // 2 basacak. system.out.println(s2.say()); //4 system.out.println(s3.say()); //3 } } public class sayac { string str; public sayac(string str){ this.str = str; } public int say(){ if(str.length() == 0)//base case return 0; if(str.charat(0)=='1'){ //eleman 1 ise sayacı 1 artır str = str.substring(1); return 1 + say(); } else{ //eleman 1 dışında herhangi bir rakam ise sayacın degerini degistirme str = str.substring(1); return say(); } } public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); sayac s3 = new sayac(""11190002""); system.out.println(s1.say()); // 2 basacak. system.out.println(s2.say()); //4 system.out.println(s3.say()); //3 } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar{ private calmastratejisi strateji; public void setstrateji(calmastratejisi s){ this.strateji = s; } public void muzikcal(list<sarki> sarkilistesi){ if (strateji != null){ //strateji objesi bos degilse strateji.cal(sarkilistesi); } } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki: sarkilistesi) { if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } } } } public class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci){ super(isim, sanatci); } @override public void oynat(){ system.out.println(""[klasik] "" + getsanatci() + "" - "" + getisim() + "" (hafif ve sakin)""); } } import java.util.list; public class metalsarki extends sarki implements calmastratejisi{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik){ super(isim, sanatci); this.metalozellik = metalozellik; } public string getmetalozellik(){ return metalozellik; } public void setmetalozellik(string metalozellik){ this.metalozellik = metalozellik; } @override public void oynat(){ system.out.println(""[metal] "" + getsanatci() + "" - "" + getisim() + "" ("" + getmetalozellik() + "")""); } public void gostermetalozellikleri(){ system.out.println(getsanatci() + "" - "" + getisim() + "" [ozellik: "" + getmetalozellik() + ""]""); } @override public void cal(list<sarki> sarkilistesi){ // todo auto-generated method stub throw new unsupportedoperationexception(""unimplemented method 'cal'""); } } public class rocksarki extends sarki{ public rocksarki(string isim, string sanatci){ super(isim,sanatci); } @override public void oynat(){ system.out.println(""[rock] "" + getsanatci() + "" - "" + getisim() + "" (huzurlu ve nostaljik)""); } } import java.util.list; public class karisikcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi){ int n = sarkilistesi.size(); for (int i=n-1; i>0; i--){ int rnd = (int)(math.random()*(i+1)); //indeksi rastgele seçiyor sarki temp = sarkilistesi.get(i); sarkilistesi.set(i, sarkilistesi.get(rnd)); //random gelen elemani koydum sarkilistesi.set(rnd, temp); } for (sarki sarki: sarkilistesi){ //sarkilistesinin yeni hali sarki.oynat(); } } } import java.util.list; class siralicalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi){ for (sarki sarki: sarkilistesi){ sarki.oynat(); } } } public abstract class sarki{ private string isim; //sarki adi private string sanatci; //sanatci adi public sarki(string isim, string sanatci){ this.isim = isim; this.sanatci = sanatci; } public string getisim(){ return isim; } public void setisim(string isim){ this.isim = isim; } public string getsanatci(){ return sanatci; } public void setsanatci(string sanatci){ this.sanatci = sanatci; } public abstract void oynat(); //soyut metod oldugu icin govdesi yok. } import java.util.list; public class rockcuozelcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi){ boolean sesyuksekmi = false; for (int i=0; i<sarkilistesi.size(); i++){ sarki sarki = sarkilistesi.get(i); if (sarki instanceof rocksarki && !sesyuksekmi){ //eger sarki objesi rocksarki objesi ise ve ses yuksekse system.out.println(""[bilgi] ses duzeyi: yuksek""); sesyuksekmi = true; //ses artık yuksek } sarki.oynat(); //sanatciyi, sarki ismini ve sarki ozelliklerini bastirdi if (sesyuksekmi && (i == sarkilistesi.size()-1 || !(sarkilistesi.get(i+1) instanceof rocksarki))){ //ses yuksekligi dusukse ve sarkilistesindeki elemanlar rocksarki objesi degilse veya index sondaysa system.out.println(""[bilgi] ses duzeyi: normal""); sesyuksekmi = false; } } } } import java.util.list; public interface calmastratejisi{ void cal(list<sarki> sarkilistesi); } kelime sayıcı bil 211 - lab 3 20 şubat 2025 1 giriş bu laboratuvarda fileioveexceptions kullanarak bir kelime sayıcı geliştireceğiz. kelime sayıcı , verilen birmetindosyasındakibelirlikelimelerinkaçkezgeçtiğinisayarakbirçıktıdosyasınakaydedecekvebelirlenen hata durumlarında uygun çıktılar oluşturacaktır. 2 genel program program, aşağıdaki sabit isimlere sahip iki giriş dosyası ile çalışacaktır: -kelimeler.txt – aranacak kelimeleri içeren dosya. -metin.txt – kelimelerin aranacağı metnin bulunduğu dosya. program, kelimeler.txt dosyasındaki her kelimenin metin.txt içinde kaç kez geçtiğini sayacak ve sonucu bir çıktı dosyasına kaydedecektir: -sonuc.txt – her kelimenin kaç kez geçtiğini içeren çıktı dosyası. dosyalar,programınçalıştırıldığıdizindebulunmalıdır. dosyaisimlerideğiştirilemez,programsadeceyukarıda belirtilen isimlerle çalışacaktır. eğerkelimeler.txt içinde bulunan herhangi bir kelime, metin.txt içinde hiç geçmiyorsa, program bir hata oluşturmalı ve stderr’e uygun bir mesaj yazmalıdır. 3 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları kullanacaktır (örn., bufferredreader, scanner, printwriter). dosyaları okurken ve yazarken kullanacağınız fileio sınıflarının seçimi size bırakılmıştır. i̇şlenmesi gereken dosyalar şunlardır: -kelimeler.txt dosyası okunmalıdır. -metin.txt dosyası okunmalıdır. -sonuc.txt dosyası oluşturulup yazılmalıdır. program,aşağıdakiolasıdosyahatalarınıoluşturmalıvehatalaroluştuğundastderr’ebelirlenenhatamesajlarını yazmalıdır: - dosyabulunamıyorsa: ""hata: kelimeler.txt bulunamadı."" veya""hata: metin.txt bulunamadı."" - dosya boşsa: ""hata: kelimeler.txt boş."" veya""hata: metin.txt boş."" 4 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program hata kodu ile çıkış yapmalıdır (yani mainmetodunuz bu hataları atarak sonlanmalı) ve hatalar stderr’e yazılmalıdır (programınızı hata atarak sonlandırırsanız java bunu kendisi yapacaktır). belirtilen hata mesajları ile birlikte java’nın hata ile sonlanan programlar için oluşturduğu sınıf, metod, ve satır gibi bilgiler bulunabilir. 1 4.1 girdi hataları (inputexception class) bu kategori, programın giriş dosyalarıyla ilgili karşılaşabileceği tüm hataları kapsar. öğrenciler, dosya işlem- leriyle ilgili hata türlerini inputexception sınıfından türetmelidir. aşağıdaki özel hata türleri tanımlanmalıdır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: [dosya adı] bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: [dosya adı] boş."" 4.2 kelime bulunamadı hatası (kelimebulunamadiexception class) eğerkelimeler.txt içinde bulunan en az bir kelime, metin.txt dosyasında hiç geçmiyorsa, program kelimebulunamadiexception hatasını atmalıdır. hata yalnızca kelimeler.txt dosyasında bulunamayan ilk kelime için atılır ve program sonlanır. bu hata oluştuğunda stderr’e şu mesaj yazılmalıdır: -""hata: [kelime] metinde bulunamadı."" bu hata, doğrudan exception sınıfından türetilecek ve inputexception ile bağlantılı olmayacaktır. 5 dosya formatları program üç farklı dosya ile çalışacaktır: kelimeler.txt (girdi),metin.txt (girdi) ve sonuc.txt (çıktı). bu dosyaların formatı aşağıda belirtilmiştir. 5.1 girdi dosyaları girdi dosyaları düz metin ( .txt) formatında olacaktır ve her biri aşağıdaki gibi yapılandırılmış olmalıdır. 5.1.1kelimeler.txt formatı kelimeler.txt dosyası, her satırda bir kelime olacak şekilde düzenlenmelidir. dosyada yalnızca harf karak- terleri bulunur. kelimeler büyük/küçük harf duyarsız olarak aranacaktır. örnek i̇çerik: elma armut üzüm eğer dosya boşsa, program şu hatayı vermelidir: hata: kelimeler.txt boş. 5.1.2metin.txt formatı metin.txt dosyası, içinde aranacak kelimelerin geçebileceği serbest formatlı bir metin içermelidir. dosya içinde noktalama işaretleri ve boşluklar bulunabilir. örnek i̇çerik: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. eğer dosya boşsa, program şu hatayı vermelidir: hata: metin.txt boş. 5.2 çıktı dosyası program, kelimelerin kaç kez geçtiğini gösteren bir çıktı dosyası ( sonuc.txt ) oluşturmalıdır. 2 5.2.1sonuc.txt formatı sonuc.txt dosyası, her satırda kelimenin adı ve kaç kez geçtiği bilgisi olacak şekilde düzenlenmelidir. format şu şekilde olmalıdır: [kelime] [geçme sayısı] kelime ve geçme sayısı arasında tek bir boşluk olmalıdır. örnek çıktı ( sonuc.txt ): elma 2 armut 2 üzüm 1 5.3 özel hata durumları ve çıktıları eğerkelimeler.txt içindekiherhangibirkelime metin.txt içindebulunamazsa, kelimebulunamadiexception hatası atılmalıdır ve stderr’e şu mesaj yazılmalıdır: hata: üzüm metinde bulunamadı. bu hata oluştuğunda, yine de sonuc.txt dosyası oluşturulmalı ve bulunan kelimeler için normal çıktı yazıl- malıdır. ancak bulunamayan kelimeler çıktı dosyasına eklenmemelidir. örnek durum: eğerkelimeler.txt şu şekildeyse: elma armut muz vemetin.txt şu şekildeyse: elma ve armut çok lezzetlidir. elma suyu da çok faydalıdır. armut yemek sağlığa iyi gelir. üzüm de sağlıklı bir meyvedir. o zaman sonuc.txt şu şekilde olmalıdır: elma 2 armut 2 ve stderr’e şu mesaj yazılmalıdır: hata: muz metinde bulunamadı. 6 gönderim formatı - labı bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara şeklinde isimlendirin (örn., johnnash_181101014.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""lab3 gönderim"" başlıklı bir mail ile gönderin. 3 metot açıklama string(string s) sile aynı değere sahip bir string oluşturur. string(char[] a) a[]dizisindeki karakterlerle bir string oluşturur. int length() string içindeki karakter sayısını döndürür. char charat(int i) belirtilen iindeksindeki karakteri döndürür. string substring(int i, int j) iilej-1arasındaki karakterleri içeren bir alt string döndürür. boolean contains(string substring) string’in substring ’i içerip içermediğini kontrol eder. boolean startswith(string prefix) string’in prefixile başlayıp başlamadığını kontrol eder. boolean endswith(string postfix) string’in postfix ile bitip bitmediğini kontrol eder. int indexof(string pattern) pattern ifadesinin ilk geçtiği indeks değerini döndürür. int indexof(string pattern, int i) iindeksinden sonraki ilk pattern konumunu döndürür. string concat(string t) string’in sonuna teklenmiş halini döndürür. int compareto(string t) i̇ki string’i karşılaştırır (sözlük sırasına göre). string tolowercase() string’in tüm harflerini küçük harfe çevirir. string touppercase() string’in tüm harflerini büyük harfe çevirir. string replace(string a, string b) string içindeki a’larıbile değiştirir. string trim() string’in başındaki ve sonundaki boşlukları kaldırır. boolean matches(string regex) string’in belirtilen regexle eşleşip eşleşmediğini kontrol eder. string[] split(string delimiter) string’idelimiter kullanarak böler ve bir dizi döndürür. boolean equals(object t) string’in değeri tile aynı mı diye kontrol eder. table 1: java string sınıfı metotları 4 import java.io.*; import java.util.*; public class kelimesayaci{ public static void main(string[] args){ try{ list<string>kelimeler = dosyayioku(""kelimeler.txt""); list<string>metin = dosyayioku(""metin.txt""); list<string>kelimelistesi = new arraylist<>(); list<integer>kelimesayilari = new arraylist<>(); boolean kelimebulunamadi = false; //yani kelime bulunmus kabul et. string ilkbulunamayankelime = null; for(string k: kelimeler){ int sayac = kelimesay(metin, k); if((sayac == 0) && (!kelimebulunamadi)){ kelimebulunamadi = true; //kelimenin bulunamadigini dogrular. ilkbulunamayankelime = k; } if(sayac > 0){ kelimelistesi.add(k); kelimesayilari.add(sayac); } } sonucdosyasiniyaz(""sonuc.txt"", kelimelistesi, kelimesayilari); //sonuc.txt'ye yazacak. if(kelimebulunamadi){ //kelimebulunamadi == true oldugunda exception firlat. throw new kelimebulunamadiexception(ilkbulunamayankelime); } }catch(inputexception e){ system.err.println(e.getmessage()); }catch(kelimebulunamadiexception e){ system.err.println(e.getmessage()); }catch(ioexception e){ system.err.println(""hata: dosya okuma/yazma hatası oluştu.""); } } public static list<string>dosyayioku(string dosyaadi) throws inputexception, ioexception{ //checked exceptionlar file f = new file(dosyaadi); if (!f.exists()){ //dosya bulunamazsa exception firlat. throw new dosyabulunamadiexception(dosyaadi); } list<string>satir = new arraylist<>(); try(bufferedreader br = new bufferedreader(new filereader(f))){ string str; while((str = br.readline()) != null){ if(!str.trim().isempty()) { satir.add(str.trim().tolowercase()); } } } if(satir.isempty()){ throw new bosdosyaexception(dosyaadi); } return satir; } public static int kelimesay(list<string>metin, string kelime){ int sayac = 0; for(string str: metin){ string[]kelimeler = str.tolowercase().split(""\\w+""); for(string k: kelimeler){ if (k.equals(kelime)){ sayac++; } } } return sayac; } public static void sonucdosyasiniyaz(string dosyaadi, list<string>kelimelistesi, list<integer>kelimesayilari) throws ioexception{ try(printwriter wrt = new printwriter(new filewriter(dosyaadi))){ for(int i=0; i<kelimelistesi.size(); i++){ if(kelimesayilari.get(i) > 0){ //eger kelime metinde gectiyse yazdirir wrt.println(kelimelistesi.get(i) + "" "" + kelimesayilari.get(i)); } } wrt.flush(); } } } public class kelimebulunamadiexception extends exception{ public kelimebulunamadiexception(string kelime){ super(""hata: "" + kelime + "" metinde bulunamadı.""); } } public class bosdosyaexception extends inputexception{ public bosdosyaexception(string filename){ super(""hata: "" + filename + "" boş.""); } } public class inputexception extends exception{ public inputexception(string message){ super(message); } } public class dosyabulunamadiexception extends inputexception{ public dosyabulunamadiexception(string filename){ super(""hata: "" + filename + "" bulunamadı.""); } } generic 1) envanter yönetim sistemi bu labda amacımı bir oyun için envanter sistemi eklemektir. item isminde bir arayüz tanımlayın: aşağıdaki metotları içermelidir: string getname() int getvalue() weapon sınıfı tanımlayın. bu sınıf item arayüzünü uygulamalıdır. int damage isimli bir özelliği olmalıdır. armor sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. int defense isimli bir değişkeni olmalıdır. potion sınıfı tanımlayın. bu sınıf da item arayüzünü uygulamalıdır. string effect isimli bir değişkeni olmalıdır. generic inventory<t> sınıfı bir arraylist kullanarak nesneleri saklamalıdır. void additem(t item): envantere istenilen eşyayı eklemeli void removeitem(t item): envanterden istenilen eşyayı silmeli void printinventory(): envanteri basmalı t mostvaluableitem(): en değerli eşyayı dönmeli t finditembyname(string name): verilen isme karşılık gelen eşyayı dönmeli. i̇simlerin unique olduğunu varsayabilirsiniz. eğer yoksa null dönün. list<t> finditemsbyvalue(int value): verilen değerden daha değerli eşyaarın listesini döndürür. int gettotalvalue(): envanterin toplam değerini döner. list<t> filterbytype(class<?> type): istenilen sınıfa ait ögeleri döner. int gettotalweapondamage(): weapon classına ait olan nesnelerin toplam hasarınıdöner. void sortbyvalue(): değeri azalan şekilde envanteri sıralamalıdır. public static void printmostvaluableitem(inventory<? extends item> inventory): verilen envanterdem en değerli eşayı ekrana basmalıdır. public static void transferarmor(inventory<? super armor> destination, inventory<armor> source): verilen hedef envantere zırhı taşımalıdır. driver class: main metodu burada olmalıdır. sadece weapon’dan oluşan ve itemdan oluşan invertory classı yazıp test ediniz. yardımcı olabilecek metotlar: class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon import java.util.arraylist; import java.util.list; public class inventory<t extends item>{ public list<t> items = new arraylist<>(); public void additem(t i){ //envntere istenilen esyayi eklemeli items.add(i); } public void removeitem(t i){ //envanterden istenilen esyayi silmeli items.remove(i); } public void printinventory(){ //envanteri basmali for (t i: items){ system.out.println(i); } } public t mostvaluableitem(){ //en degerli esyayi donmeli if(items.isempty()){ return null; } t mostvalit = items.get(0); for(t i: items){ if(i.getvalue() > mostvalit.getvalue()){ mostvalit = i; } } return mostvalit; } public t finditembyname(string name){ //verilen isme karsilik gelen esyayi doner, eger yoksa null don for(t i: items){ if(i.getname().equals(name)){ return i; } } return null; } public list<t> finditemsbyvalue(int value){ //verilen degerden daha degerli esyalarin listesi list<t> itms = new arraylist<>(); for(t i: items){ if(i.getvalue() > value){ itms.add(i); } } return itms; } public int gettotalvalue(){ //weapon classinin toplam hasari int total_damage = 0; for (t i: items){ total_damage += i.getvalue(); } return total_damage; } public list<t> filterbytype(class<?> type){ //istenilen sinifa ait ogeler, sinifin ne oldugunu bilmedigimiz icin ? wildcard kullandim list<t> ogeler = new arraylist<>(); for (t i: items){ if(i.getclass().equals(type)){ ogeler.add(i); } } return ogeler; } public int gettotalweapondamage(){ //weapon classina ait olan nesnelerin toplam hasarini don int total_damage = 0; for(t i: items){ if (i instanceof weapon) { total_damage += ((weapon)i).getdamage(); } } return total_damage; } public void sortbyvalue(){ //degeri azalan seklinde envanteri sirala for(int i=0 ; i<items.size()-1 ; i++){ for(int j=i+1 ; j<items.size() ; j++){ if(items.get(i).getvalue() < items.get(j).getvalue()){ t temp = items.get(i); items.set(i, items.get(j)); items.set(j, temp); } } } } public static void printmostvaluableitem(inventory<? extends item> inventory){ //verilen envanterdem en degerli esyayi ekrana bas item i = inventory.mostvaluableitem(); if(i != null){ system.out.println(""most valuable item: "" + i); } } public static void transferarmor(inventory<? super armor> destination, inventory<armor> source){ //verilen hedef envantere zirhi tasi list<armor> move = new arraylist<>(); for(item i: source.items){ if(i instanceof armor){ //ekle move.add((armor)i); } } for(armor a: move){ //tasi destination.additem(a); source.removeitem(a); } } } public class weapon implements item{ private string name; private int value; private int damage; public weapon(string name, int value, int damage){ this.name = name; this.value = value; this.damage = damage; } @override public string getname(){ return name; } @override public int getvalue(){ return value; } public int getdamage(){ return damage; } @override public string tostring(){ return ""weapon{"" + ""name='"" + name + '\'' + "", value="" + value + "", damage="" + damage + '}'; } } public interface item{ string getname(); int getvalue(); } public class armor implements item{ private string name; private int value; private int defense; public armor(string name, int value, int defense){ this.name = name; this.value = value; this.defense = defense; } @override public string getname(){ return name; } @override public int getvalue(){ return value; } public int getdefense(){ return defense; } @override public string tostring(){ return ""armor{"" + ""name='"" + name + '\'' + "", value="" + value + "", defense="" + defense + '}'; } } public class potion implements item{ private string name; private int value; private string effect; public potion(string name, int value, string effect){ this.name = name; this.value = value; this.effect = effect; } @override public string getname(){ return name; } @override public int getvalue(){ return value; } public string geteffect(){ return effect; } @override public string tostring(){ return ""potion{"" + ""name='"" + name + '\'' + "", value="" + value + "", effect='"" + effect + '\'' + '}'; } } public class driver{ /*public static void main(string[] args){ class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon }*/ public static void main(string[] args){ inventory<weapon>weaponinventory = new inventory<>(); weaponinventory.additem(new weapon(""excalibur"", 1000, 100)); weaponinventory.additem(new weapon(""excalibur2"", 300, 50)); inventory<item>generalinventory = new inventory<>(); generalinventory.additem(new weapon(""weapon1"", 400, 85)); generalinventory.additem(new weapon(""weapon2"", 500, 80)); system.out.println(""weapon inventory:""); weaponinventory.printinventory(); system.out.println(""total weapon damage: "" + weaponinventory.gettotalweapondamage()); system.out.println(""most valuable weapon: "" + weaponinventory.mostvaluableitem()); system.out.println(""verilen isme karsilik gelip gelmedigini kontrol et: "" + weaponinventory.finditembyname(""excalibur"")); system.out.println(""verilen degerden daha degerli esyalar: "" + weaponinventory.finditemsbyvalue(30)); system.out.println(""toplam deger: "" + weaponinventory.gettotalvalue()); system.out.println(""toplam weapon hasari: "" + weaponinventory.gettotalweapondamage()); system.out.println(); system.out.println(""general inventory:""); generalinventory.printinventory(); system.out.println(); class<weapon> weaponclass = weapon.class; system.out.println(""sınıf adı: "" + weaponclass.getname()); // çıktı: weapon weapon sword = new weapon(""excalibur"", 1000, 100); class<?> clazz = sword.getclass(); system.out.println(clazz.getname()); // çıktı: weapon } } ""recursion"" kavramı nedir, kısaca açıklayınız. bir metodun kendi kendisini çağırmasıdır. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case: temel olan kısımdır. burasi recursive kolun kilitlendiği yerdir. call case: burasi ise recursive kismin devamli olarak büyüyüp kuculerek kendisini çağırmaya devam ettigi yerdir. jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. stack denilen bir yapıda bu call'ları tutuyor, son giren veri ilk çıkıyor. int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. i̇teratif yöntem yani for veya while döngüsü daha hızlıdır ve bellekte daha az yer kaplar, fakat bu verilen metodu recursive yazmak yazılımcı acisindan daha kolaydir ve kod daha clean gozukur. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? public int length(string s) { if(s.length() == 1) //base case return 1; calling case: else return length(s.substring(1))+1; stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack: recursive metotlarda metod kendisini her çağırdığında gelecek veriler burada toplanir, son giren veri ilk cikar. stackoverflow ise cok fazla veri geldiğinde olusur, stack taşar. tail recursion nedir, kısaca açıklayınız. metodun sadece kendisini çağırmasıdır yani yaninda toplama veya carpma gibi bir işlem bulunmaz abstraction kavramını açıklayınız. soyutlama anlamina gelir. java dilinde classlar objeler encapsulation ve polymorphism abstarction kavramina örnektir. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? evet mumkundur. çünkü hourlyemployee employee sınırının alt classıdır. fakat tersi mümkün değildir. çünkü her hourlyemployee bir employee'dir, fakat her employee hourlyemployee değildir. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? default daha yakindir, çünkü protected ile alt sinif oldugu surece farkli paketlerden erisim saglanir ama default'tan saglanmaz. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? alt sinif oldugu icin. ust sinifin ozelliklerini de icermesi gerektiğinden daima alt sinifin constructorının ilk satirinda ust sinifi temsil eden super satırı olmak zorundadır. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? edemez. bir class her zaman yalnizca tek 1 class'ı extend edebilir. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a objesi b classının bir objeyi mi diye bakar. metot overriding ve overloading kavramlarını açıklayınız. overriding: ust sinifta tanımlanmış bir metodun alt sınıflarda yeniden tanimlanmasidir, metodun imzasi ve return type'ı degismez. ust sinifta metod tanimlanirken final keywordü kullanilirsa o metod override edilemez. overloading: bir metodun ayni isimle ama farkli parametrelerle yeniden tanimlanmasidir, parametreler degisecegi icin imza degisebilir fakar return type degisemez. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? base1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? hata verir. çünkü görünürlüğü azaltamayız. fakat burada ust sınıfta x değişkeni protected olarak tanimlanirken alt sinifta private olarak tanımlayarak bu hatayı yapmış java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? metotlar ve variablelar siniflara özgü ise static, objelere ozgu ise dynamic java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? override edilemezler yani degistirilemezler overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? early binding, çünkü compiler hangi metodu calistiracagina karar verir dinamik bağlamada jvm'nin görevi nedir? kodu javanin anlayacagi bytecode a cevirir java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? çünkü üst sınıf referanslı alt sınıf objesi oluşturulur, fakat down casting implicit yapilamaz java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? late binding yapılamazdi ve çoğu kod hatalı olurdu class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? static class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 2 çeşittir checked ve unchecked. checked exception örneği io, unchecked exception örneği runtime. java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? checked exceptionlar için throws kullanılır. override edilen metodlarda throw yazılarak exception fırlatılır. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? ne olursa olsun çalıştır demektir. finally blogu exception atılmayan yerde çalışmaz. java'da kendi exceptionunuzu nasıl tanımlarsınız? class yazıp extends throwable ya da extends exception yazarak. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? checked exception olduğu için. veya birden fazla exception olabileceği için. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally done static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenmesi. hata ise ilk catch blogunda exception yazıp altındaki catch blogunda exception classinin alt sınıfı olan ioexception yapmasıdır. hatayı düzeltmek için ioexception ı yukarı, exception ı aşağı almalıyız. hata duzeltildikten sonra: trying m1 caught2 finally what grade (a, b, c, d, or f) do you expect to earn by the end of this course? dd java'da generic kavramı nedir, bu kavramın temel amacı nedir? her türü destekleyen genel bir yapı upper bound ve lower bound wildcardları nasıl ifade edersiniz? upper ve lower boundun kullanılacağı durumlara birer tane örnek veriniz. upper bound okuma, lower bound yazma amacıyla kullanılır. upperbound(? extends t) ve lowerbound(? extends t) generic bir classın constructorunda type parametresi bulunur mu, neden? bir generic sınıfın constructor'ı generic type parametresini alabilir ancak constructor'ın kendisi generic olamaz.cunku runtimeda tür bilgisi silinir mygenericclass<a> ve mygenericclass<object> classları arasında kalıtım (child-parent) ilişkisi nasıldır, açıklayınız. mygenericclass<a> ve mygenericclass<object> arasında kalıtım ilişkisi yoktur. eğer mygenericclass<t> içindeki t, object'in bir alt sınıfıysa, ? extends object kullanarak ilişkili hale getirebiliriz. generics kullanırken kalıtım ilişkisi oluşturmak için wildcard (? extends) kullanılmalı. class node<t>{ t[] data = new t[10]; } //psvm node<string> stringnode = new node<>(); bu kodda bir hata var mı? (varsa) bu hata nedir, nedenini açıklayınız. (varsa) bu hata nasıl düzeltilmeli, kodun doğru halini yazınız. t[10] hatalıdır cünkü generics runtimeda tür bilgisine sahip değildir. diziyi object[] olarak oluşturup (t[]) ile cast edebiliriz swapheadandtail metodu aşağıda tanımı verilmiş node classının birbirlerine bağlanmış nodelerinden ilkini alan ve baştaki node ile sondaki node'yi değiştiren metottur. örnek: başlangıçta: a -> b -> c metodu a ile çağırdığıktan sonra: c -> b -> a ayrıca metot en başa gelen nodeyi dönmelidir (bu örnekte c dönmeli). class node{ int data; node next; } static node swapheadandtail(node head) { node a = head; node b = head.next; node c = head; node d = null; while (____ != null) { d = c; c = c.next; } c.next = ____; d.next = ____; a.next = ____; return ____; } buna göre boşluklara neler gelmelidir? (c.next != null) c.next = null d.next = a a.next = b return c public _________ { public void sırala(list<t> liste) { // sıralama algoritmanız } } yaptığınız uzun çalışmalar sonucu yeni bir sıralama algoritması buldunuz. bunu implement etmek için bir class yazmalısınız. bu classın declarationunu nasıl yapardınız neden, boşluğu buna göre doldurun. public class mysorter<t> türü belli olmadığı için declarationı t ile yaparız. map ve set veri yapılarını kıyaslayınız, aralarındaki farkları açıklayınız. set, elemanlarının sırasını saklamaz veya belirli bir düzene göre sıralayabilir (treeset). map ise anahtarların sırasını değiştirebilir veya belirli bir düzene sokabilir (treemap). collections interfacesindeki metotlar temel olarak hangi işlevleri yerine getiriyor? ekle sil ara dönüştür manipülasyon i̇ki objenin equals metodu true dönüyorsa bu iki objenin hash codeleri aynıdır, bunun nedenini açıklayınız; eğer bu sağlanmazsa hangi veri yapıları istenilen şekilde sağlanır? kendi yazdığınız classlarda bunu sağlamak için hangi metotları override etmelisiniz, neden? hashmap veya hashset içinde aynı nesneler farklı hash kodlarına sahip olursa, veri yapısı gereksiz yere daha fazla alan kullanır ve arama ekleme performansı düşebilir. override edilmesi gerek metodlar: equals(): iki nesnenin eşit olup olmadığını anlamak için. hashcode(): eşit nesnelerin aynı hash koduna sahip olmasını sağlamak için. bir öğrenci kulübü, yılsonu etkinliği için sınırlı kontenjana sahip bir kayıt sistemi oluşturuyor. sistem, öğrenci kayıtlarını ""ilk gelen ilk hizmet alır"" prensibiyle yönetiyor. ancak, bazı öğrenciler kaydını iptal edebiliyor ve boş kalan yerler otomatik olarak sıradaki öğrenciye veriliyor. bu senaryoda, kayıt sırasını ve iptal durumlarını etkin bir şekilde yönetebilmek için hangi veri yapısını tercih edersiniz? neden? ""ilk gelen ilk hizmet alır"" yani fifo prensibi uygulandığı için queue (kuyruk) veri yapısı en uygun seçimdir. fifo nedir, açıklayınız ve aşağıdakı veri yapılarını fifo/lifo şeklinde sınıflandırınız: stack queue map priorityqueue fifo: first on first out demektir yani ilk giren ilk çıkar. stack: lifo queue: fifo map: ikisi de değil priorityqueue: fifo public class main { public static void main(string[] args) { map<string, integer> scores = new hashmap<>(); scores.put(""alice"", 95); scores.put(""bob"", 80); scores.put(""alice"", 100); set<string> keys = scores.keyset(); int sum = 0; for (string key : keys) { sum += scores.get(key); } system.out.println(""number of entries: "" + scores.size()); system.out.println(""sum of scores: "" + sum); } } output? number of entries: 2 sum of scores: 180 public class main { public static void main(string[] args) { list<string> list = new arraylist<>(); list.add(""apple""); list.add(""banana""); list.add(1, ""cherry""); list.remove(""banana""); list.add(""apple""); system.out.println(list.size()); system.out.println(list.indexof(""apple"") + "" "" + list.lastindexof(""apple"")); } } output? 3 0 2 ara sınavdan yaklaşık hangi notu bekliyorsun (0-100)? 30 java gui'leri bağlamında olay güdümlü (event driven) programlamayı tanımlayın. event, kullanıcının yaptığı eylemler. event source, olayın gerçekleştiği bileşen. event listener, olayı yakalayan ve ilgili kodu çalıştıran arayüz veya sınıf. geleneksel sıralı programlama ile olay güdümlü (event driven) programlama arasındaki temel fark nedir? programin akışının kontrolü borderlayout yöneticisi, bir konteynerdeki bileşenleri nasıl düzenler? .north kuzey, .south güney, .east doğu, .west batı, .center tam orta java gui uygulamalarında jpanel'in amacı nedir? yeni bir panel açmayı sağlar. java'daki gui programları neden tipik olarak sonsuz bir olay döngüsü çalıştırır ve bu durum sistem veya uygulama tarafından tetiklenen yeniden çizim (repaint) olaylarıyla nasıl ilişkilidir? kullanıcının veya sistemin tetiklediği olayları devamlı dinler ve işleyerek uygulamanın dinamik ve etkileşimli olmasını sağlar. bir swing uygulamasında repaint() metodunu çağırmanın etkisi nedir? bilesenleri yeniden çizer. aşağıdaki kodun çalışmasını izleyin ve düğmeye tıklandığında ne olduğunu belirleyin: public class simplegui extends jframe implements actionlistener { public simplegui() { setsize(200, 100); setdefaultcloseoperation(jframe.exit_on_close); jbutton button = new jbutton(""click me""); button.addactionlistener(this); add(button); setvisible(true); } public void actionperformed(actionevent e) { joptionpane.showmessagedialog(this, ""button was clicked!""); system.exit(0); } public static void main(string[] args) { new simplegui(); } } button was clicked! yazar ve kapanir aşağıdaki kod parçasını inceleyin: import javax.swing.*; import java.awt.*; public class layoutexample { public static void main(string[] args) { jframe frame = new jframe(""layout test""); frame.setsize(400, 300); frame.setdefaultcloseoperation(jframe.exit_on_close); frame.setlayout(new borderlayout()); frame.add(new jlabel(""n""), borderlayout.north); frame.add(new jbutton(""s""), borderlayout.south); frame.add(new jpanel(), borderlayout.center); frame.setvisible(true); } } bu program çalıştığında bileşenlerin nasıl düzenlendiğini açıklayın. t thread oluşturmanın 2 temel yöntemi nedir? thread oluştururken lambda notasyonunun kullanılabilmesi ne sağlar? extends thread ya da implements runnable data race problemi nedir, neden kaynaklanır? nasıl önüne geçilir? aynı paylaşılan kaynağa (örneğin bir değişken) iki veya daha fazla thread'in aynı anda erişmesi sonucu tutarsız verilere yol açmasıdır. synchronized kullanarak geçilir. dead lock problemi nedir, neden kaynaklanır; bunun önüne geçebilmek için ne yapılabilir? dead lock problemi threadlerin birbirini bekleyip kilitlenerek sonsuza kadar durmasıdır. trylock() wait() ve notify() kullanarak bunun önüne geçilebilir. bir threadi başlatmak için neden run metodu çağırılmamalı, açıklayınız. peki hangi metot çağrılmalıdır? run() metodu threadi thread gibi değil, normal.bir metod gibi çağırır. bu yüzden start() metodu çağırmalıyız. bir thread başka bir thread tarafından nasıl doğru bir şekilde sonlandırılabilir? interrput() veya isinterrupted() java'da kaç çeşit thread vardır, farkları açıklayınız. user ve daemon threads. user kullanıcının gördüğü, daemon ise arka planda çalışan ve garbage işlerini yapan threaddir. public class bankaccount { private double balance; public void deposit(double amount) { balance = balance + amount; ; } public void withdraw(double amount) balance = balance - amount ; } public static void main(string[] args) { bankaccount account = new bankaccount(); thread t1 = new thread(() -> { for (int i = 0; i < 3; i++) { account.deposit(100); } }); thread t2 = new thread(() -> { for (int i = 0; i < 2; i++) { account.withdraw(100); } }); t1.start(); t2.start(); } } bu kodda bir problem var mı? varsa bu problemi nasıl çözersiniz? (varsa) problemi çözdükten sonra program çalıştığında balance'nin son değeri ne olur? deposit() ve withdraw() metotları senkronize değil. birden fazla thread aynı anda eriştiğinde data race oluşabilir. synchronized ekleyerek duzeltebiliriz. sonuç ise 100 olur. class threadvisibility { private static boolean flag = false; private static int value = 0; public static void main(string[] args) throws interruptedexception { thread t1 = new thread(() -> { string name = thread.currentthread().getname(); system.out.println(""started""); while (!flag) { try { thread.sleep(100); } catch (interruptedexception e) { e.printstacktrace(); } } system.out.println(name + value); }); t1.setname(""t2""); t1.start(); thread.sleep(1000); // give t1 time to start value = 11; synchronized (threadvisibility.class) { flag = true; } } } output? started t2 11 bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot{ private string name; private string type; private int batterylevel; // 100 ile 0 arasında bir değer private boolean isoperational; // bataryası varsa true public robot(){ name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } public robot(string name, string type, int batterylevel){ this.name = name; this.type = type; this.batterylevel = batterylevel; } public string getname(){ return name; } public void setname(string name){ this.name = name; } public string gettype(){ return type; } public void settype(string type){ this.type = type; } public int getbatterylevel(){ return batterylevel; } public void setbatterylevel(int batterylevel){ this.batterylevel = batterylevel; } public boolean getisoperational(){ return isoperational; } public void setisoperational(boolean isoperational){ //this.isoperational = isoperational; if(batterylevel > 0) isoperational = true; else isoperational = false; this.isoperational = isoperational; } public void charge(){ batterylevel = 100; } public void printrobot(){ //robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + ""%"" + "" is operational: "" + isoperational); } } public class main { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } public class q1{ public static void combinations(string str, int index, string guncelstr){ if(index == str.length()){ // stringin verilen ilk halini yazdıracak system.out.println(guncelstr); return; } char c = str.charat(index); int ascii_degeri = (int)c; if ((ascii_degeri>=65 && ascii_degeri<=90) || (ascii_degeri>=97 && ascii_degeri<=122)) { //küçük harf mi veya büyük harf mi diye bakacak, rakam ise lower veya upper işlemi uygulamayacak. combinations(str, index+1, guncelstr+character.tolowercase(c)); combinations(str, index+1, guncelstr+character.touppercase(c)); } else combinations(str, index+1, guncelstr+c); } public static void main(string[] args) { string str = ""a1b2""; combinations(str, 0, """"); } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name, string location){ this.name = name; this.location = location; this.robots = new arraylist<>(); } public factory(){ name = ""factory1""; location = ""moon""; this.robots = new arraylist<>(); } public string getname(){ return name; } public void setname(string name){ this.name = name; } public string getlocation(){ return location; } public void setlocation(string location){ this.location = location; } public arraylist<robot> getrobots(){ return robots; } public void setrobots(arraylist<robot> robots){ this.robots = robots; } public void addrobot(robot robot){ robots.add(robot); } public void chargeallrobots() { for (robot robot: robots) { robot.charge(); } } public void printfactory() { system.out.print(""factory name: "" + name); system.out.println("" location: "" + location); system.out.println(""robots operating here:""); for (robot robot : robots) { robot.printrobot(); } } public void work() { robot rbt = new robot(); if(rbt.getbatterylevel() >= 15) rbt.setbatterylevel(rbt.getbatterylevel()-15); else rbt.setbatterylevel(0); rbt.setisoperational(rbt.getbatterylevel() > 0); } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery{ int getbatterylife(); //batarya omrunu doner void recharge(); //bataryayi yeniler } public abstract class abstractrobot implements withbattery{ protected string modelname; //robotun modeli protected int batterylife; //robotun batarya omru public abstractrobot(string modelname, int batterylife){ this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname(){ return modelname; } public abstract void performtask(); //abstract metod oldugu icin govdesiz public int getbatterylife(){ return batterylife; } public void recharge(){ this.batterylife = 100; } } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); //?? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz robotfactory.toplamroboturetimi(); } } public class securityrobot extends abstractrobot{ private boolean isarmed; //robotun silahli olup olmadigini gosterir securityrobot(string modelname, int batterylife, boolean isarmed){ super(modelname, batterylife); this.isarmed = isarmed; } /* eğer batarya ömrü 10 ya da daha fazla ise ""[modelname] scanning for threats... armed: isarmed"" mesajını yazdırır (modelname ve isarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname] not enough battery to scan threats..."" mesajı gösterilmeli. */ public void performtask(){ if(batterylife >= 10){ system.out.println(""["" + modelname + ""]"" + "" scanning for threats... armed: "" + isarmed); batterylife -= 10; } else{ system.out.println(""["" + modelname + ""]"" + "" not enough battery to scan threats...""); } } public void togglearmedmode(){ //silah modunu degistirir //securityrobot - guardbot x is now unarmed this.isarmed = !this.isarmed; if(isarmed == true) system.out.println(""securityrobot - "" + modelname + "" is now armed""); else system.out.println(""securityrobot - "" + modelname + "" is now unarmed""); } public boolean getisarmed(){ return isarmed; } public void setisarmed(boolean isarmed){ this.isarmed = isarmed; } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower){ super(modelname, batterylife); this.cleaningpower = cleaningpower; } /* eğer batarya ömrü 10 ya da daha fazla ise ""[modelname] cleaning in progress... cleaning power: cleaningpower"" mesajını yazdırır (modelname ve cleaningpower yerine değişken değerleri gösterilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname] not enough battery to clean..."" mesajı gösterilmeli. */ public void performtask(){ if(batterylife >= 10){ system.out.println(""["" + modelname + ""]"" + "" cleaning in progress... cleaning power: "" + cleaningpower); batterylife -= 10; } else{ system.out.println(""["" + modelname + ""]"" + "" not enough battery to clean...""); } } public void boostcleaningpower(){ //temizlik gucunu artirir this.cleaningpower += 10; system.out.println(""cleaningrobot - "" + modelname + "" now has cleaning power: "" + cleaningpower); } public int getcleaningpower(){ return cleaningpower; } public void setcleaningpower(int cleaningpower){ this.cleaningpower = cleaningpower; } } import java.util.arraylist; class robotfactory{ private arraylist<abstractrobot> robots; private static int totalrobotproduction = 0; // main metodunda obje olusturmadan cagirmak icin static public robotfactory(){ robots = new arraylist<>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); totalrobotproduction++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ robots.add(new securityrobot(modelname, batterylife, isarmed)); totalrobotproduction++; } public void performalltasks(){ for (abstractrobot robot: robots){ robot.performtask(); } } public void displayrobots(){ for (abstractrobot r: robots){ if (r instanceof cleaningrobot){ cleaningrobot cr = (cleaningrobot)r; system.out.println(""cleaningrobot - model: "" + cr.getmodelname() + "", battery: "" + cr.getbatterylife() + "", cleaning power: "" + cr.getcleaningpower()); } else if (r instanceof securityrobot){ securityrobot sr = (securityrobot)r; system.out.println(""securityrobot - model: "" + sr.getmodelname() + "", battery: "" + sr.getbatterylife() + "", armed: "" + sr.getisarmed()); } } } public void upgradecleaningrobots(int miktar){ //cleaning robot sinifindayken for (abstractrobot r: robots){ if (r instanceof cleaningrobot){ ((cleaningrobot)r).boostcleaningpower(); } } } public void togglesecurityrobotsmode(){ //security robot sinifindayken for (abstractrobot r: robots){ if (r instanceof securityrobot){ ((securityrobot)r).togglearmedmode(); } } } public static void toplamroboturetimi(){ system.out.println(""tum fabrikalar tarafindan toplam "" + totalrobotproduction + "" robot uretildi""); } } envanter takip sistemi bil 211 - quiz 3 27 şubat 2025 1 giriş bu quizde, fileioveexceptions kullanarak basit bir envanter takip sistemi uygulaması geliştireceğiz. uygulama, interaktif bir terminal menüsü üzerinden, tek bir eşyanın ve stoğunun tutulduğu kayıtların yönetilmesini (eşya ekleme, çıkarma ve stok güncelleme) sağlayacaktır. ayrıca, envanter verileri sabit isimli bir dosyaya kaydedilebilecek ve bu dosyadan geri yüklenebilecektir. 2 genel program program konsol tabanlı bir kullanıcı arayüzü ile envanter takibi gerçekleştirmelidir. arayüz özellikleri aşağı- daki gibidir. -terminal menüsü: kullanıcıya aşağıdaki seçenekleri sunacaktır: – eşya ekleme: yeni bir eşya kaydı oluşturulur. her kayıt, eşya adı ve başlangıç stoğu bilgilerini içerir. eğer çoktan var olan bir eşya eklenmeye çalışılırsa program otomatik olarak önceki kaydın stoğunu güncellemelidir (yani aynı isimde iki kayıt oluşmamalı). – eşya çıkarma: mevcut envanterden istenilen eşya silinir. – stok güncelleme: kayıtlı bir eşyanın stoğu artırılabilir ya da azaltılabilir. i̇şlem sonucunda stok miktarı negatif olmamalıdır. – envanter listeleme: mevcut envanter kayıtları ekrana listelenir. – dosyaya kaydetme: güncel envanter verileri sabit isimli dosyaya kaydedilir. – dosyadan geri yükleme: daha önce kaydedilmiş envanter verileri dosyadan okunarak geri yüklenir. – çıkış: program sonlandırılır. 3envanterkaydi sınıfı değişkenler: -isim(private string) eşyanın adını tutar. -stok(private int) eşyanın stok miktarını tutar. metotlar: -public envanterkaydi(string isim, int stok) constructor; eşya adı ve stok miktarını başlatır. -public void stokguncelle(int miktar) stok miktarını günceller; negatif sonuç oluşmaması kontrol edilmelidir. - stokguncelle dışında ihtiyacınıza göre private değişkenler için getter ve setter tanımlayabilirsiniz. 4 fileio program, dosya okuma ve yazma işlemleri için java’nın java.io paketindeki sınıfları (örn., bufferedreader , scanner,printwriter ) kullanacaktır. dosya işlemleri sırasında aşağıdaki hata durumları için uygun mesajlar verilmelidir: - dosya bulunamazsa: ""hata: envanter dosyası bulunamadı."" - dosya boşsa: ""hata: envanter dosyası boş."" 1 5 hata yönetimi programda hata yönetimini düzenlemek için aşağıdaki özel hata türleri tanımlanacaktır. bu hatalar tespit edildiğinde program, hata kodu ile sonlanmalı ve ilgili hata mesajları stderr’e yazdırılmalıdır. 5.1 girdi hataları (inputexception class) dosya işlemleriyle ilgili hatalar için kendi tanımlayacağınız inputexception sınıfından türeyen özel hata sınıfları oluşturulacaktır: -dosyabulunamadiexception (extends inputexception) : dosya eksikse atılacak hata. - hata mesajı: ""hata: envanter dosyası bulunamadı."" -bosdosyaexception (extends inputexception) : dosya boşsa atılacak hata. - hata mesajı: ""hata: envanter dosyası boş."" 5.2 envanter i̇şlemleri hataları envanter işlemleri sırasında oluşabilecek hatalar için aşağıdaki özel hata türleri tanımlanacaktır: -stoknegatifexception (extends exception) : stok güncelleme işlemi sonucunda, eşyanın stoğu negatif bir değere düşerse atılacak hata. - hata mesajı: ""hata: stok miktarı negatif olamaz."" -esyayokexception (extends exception) : çıkarma veya güncelleme işlemi yapılmak istenen eşya envanterde bulunmuyorsa atılacak hata. - hata mesajı: ""hata: i̇stenen eşya envanterde mevcut değil."" -ozellikhatasiexception (extends exception) : eşya ekleme sırasında girilen bilgilerde hata veya eksiklik varsa atılacak hata. - hata mesajı: ""hata: eşya bilgileri hatalı veya eksik."" 6 gönderim formatı - quizinizi bitirdiğinizde asistanlarınızdan birisine kodunuzu ve çıktısını gösterip puanlatın. - asistan labınızı puanladığında tüm kaynak dosyalarını ve bu dökümantasyonu bir arşiv dosyası (zip, rar, 7z, tar, tar.gz) halinde sıkıştırın. - arşiv dosyasının isim_numara formatında isimlendirin (örn., sebnemferah_181101014.zip). - i̇simlendirdiğiniz arşiv dosyasını uzak sistemindeki quiz alanına yükleyin. 2 import java.io.*; import java.util.arraylist; import java.util.list; import java.util.scanner; public class envantersistemi{ public static final string dosyaadi = ""envanter.txt""; public static list<envanterkaydi> env = new arraylist<>(); public static void main(string[] args){ scanner keyboard = new scanner(system.in); boolean cont = true; while(cont){ system.out.println(""\n1. eşya ekle\n2. eşya çıkar\n3. stok güncelle\n4. envanteri listele\n5. dosyaya kaydet\n6. dosyadan yükle\n7. çıkış""); system.out.print(""seçim: ""); int sec = keyboard.nextint(); keyboard.nextline(); try{ switch(sec){ case 1: esyaekle(); break; case 2: esyacikar(); break; case 3: stokguncelle(); break; case 4: envanterilistele(); break; case 5: dosyayakaydet(); break; case 6: dosyadanyukle(); break; case 7: cont = false; break; default: system.out.println(""geçersiz seçim!""); } } catch(exception e){ system.err.println(e.getmessage()); } } } public static void esyaekle(){ scanner keyboard = new scanner(system.in); system.out.print(""eşya adı: ""); string isim = keyboard.nextline(); system.out.print(""stok miktarı: ""); int stok = keyboard.nextint(); keyboard.nextline(); for (envanterkaydi k: env){ if (k.getisim().equals(isim)){ try{ k.stokguncelle(stok); } catch(stoknegatifexception e){ system.err.println(e.getmessage()); } return; } } env.add(new envanterkaydi(isim, stok)); } public static void esyacikar() throws esyayokexception{ scanner keyboard = new scanner(system.in); system.out.print(""silinecek eşya adı: ""); string isim = keyboard.nextline(); for(int i = 0; i< env.size() ; i++){ if (env.get(i).getisim().equals(isim)){ env.remove(i); return; } } throw new esyayokexception(); } public static void stokguncelle() throws esyayokexception{ scanner keyboard = new scanner(system.in); system.out.print(""eşya adı: ""); string isim = keyboard.nextline(); for(envanterkaydi kayit : env){ if(kayit.getisim().equals(isim)){ system.out.print(""stok değişim miktarı (+/-): ""); int miktar = keyboard.nextint(); keyboard.nextline(); try{ kayit.stokguncelle(miktar); }catch(stoknegatifexception e){ system.err.println(e.getmessage()); } return; } } throw new esyayokexception(); } public static void envanterilistele(){ if(env.isempty()){ system.out.println(""envanter boş.""); return; } for(envanterkaydi k: env){ system.out.println(k.getisim() + "" - stok: "" + k.getstok()); } } public static void dosyayakaydet(){ try (printwriter writer = new printwriter(new filewriter(dosyaadi))){ for (envanterkaydi k: env){ writer.println(k.getisim() + "","" + k.getstok()); } } catch(ioexception e){ system.err.println(""dosya yazma hatası!""); } } public static void dosyadanyukle(){ try (bufferedreader rd = new bufferedreader(new filereader(dosyaadi))){ string cols; env.clear(); while((cols = rd.readline()) != null){ string[] elemanlar = cols.split("",""); if (elemanlar.length != 2) continue; env.add(new envanterkaydi(elemanlar[0], integer.parseint(elemanlar[1]))); } if(env.isempty()){ throw new bosdosyaexception(); } } catch(filenotfoundexception e){ system.err.println(new dosyabulunamadiexception().getmessage()); } catch(ioexception | bosdosyaexception e){ system.err.println(e.getmessage()); } } } public class esyayokexception extends exception{ public esyayokexception(){ super(""hata: i̇stenen eşya envanterde mevcut değil.""); } } public class ozellikhatasiexception extends runtimeexception{ public ozellikhatasiexception(string mesaj){ super(mesaj); } } public class envanterkaydi{ private string isim; private int stok; public envanterkaydi(string isim, int stok){ if ((isim == null) || (isim.isempty()) || (stok < 0)){ throw new ozellikhatasiexception(""hata: eşya bilgileri hatalı veya eksik.""); } this.isim = isim; this.stok = stok; } public string getisim(){ return isim; } public void setisim(string isim){ this.isim = isim; } public int getstok(){ return stok; } public void setstok(int stok){ this.stok = stok; } public void stokguncelle(int miktar) throws stoknegatifexception{ if ((this.stok + miktar < 0)){ throw new stoknegatifexception(""hata: stok miktarı negatif olamaz.""); } this.stok += miktar; } } public class bosdosyaexception extends inputexception{ public bosdosyaexception(){ super(""hata: envanter dosyası boş""); } } public class stoknegatifexception extends exception{ public stoknegatifexception(string mesaj){ super(mesaj); } } public class inputexception extends exception { public inputexception(string mesaj) { super(mesaj); } } public class dosyabulunamadiexception extends inputexception{ public dosyabulunamadiexception(){ super(""hata: envanter dosyası bulunamadı.""); } } bil211 quiz 4 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: undoablelist<t> adında bir sınıf oluşturun. bu sınıf, bir arraylist'i genişletmeli ve aşağıdaki ek özelliklere sahip olmalıdır: ● undolast() metodu, en son eklenen öğeyi kaldırmalıdır. ● getlastadded() → son eklenen öğeyi listeyi değiştirmeden döndürür. ● eğer liste boşsa, undolast() bir hata vermemeli, sadece hiçbir şey yapmamalıdır. örnek kullanım: undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] q2: aşağıdaki generic metodu tamamlayın. ● verilen bir collection<t> içinde minimum veya maksimum öğeyi bulan bir metod yazın. ● boolean parametresi true ise maksimumu, false ise minimumu döndürmelidir. ● t öğeleri comparable<t> arabirimini uygulamalıdır. public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax) { // metodu tamamlayın } örnek kullanım: list<integer> numbers = arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) q3: belirli türdeki elemanları filtreleme ● bir collection<?> içindeki belirli bir türdeki öğeleri filtreleyen bir generic metod yazın. ● class<t> tür filtresi olarak kullanılmalıdır. ● sonucu yeni bir list<t> olarak döndürmelidir. public static <t> list<t> filterbytype(collection<?> collection, class<t> type) { // metodu tamamlayın } örnek kullanım: list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] import java.util.collection; import java.util.arraylist; import java.util.arrays; import java.util.list; public class utils{ public static <t> list<t> filterbytype(collection<?> collection, class<t> type){ list<t> f_l = new arraylist<>(); for(object eleman: collection){ if (type.isinstance(eleman)){ f_l.add(type.cast(eleman)); } } return f_l; } public static void main(string[] args){ list<object> mixed = arrays.aslist(1, ""hello"", 2.5, ""world"", 3, true); system.out.println(filterbytype(mixed, string.class)); // çıktı: [""hello"", ""world""] system.out.println(filterbytype(mixed, integer.class)); // çıktı: [1, 3] } } import java.util.collection; public class extremefinder{ public static <t extends comparable<t>> t findextreme(collection<t> collection, boolean findmax){ if(collection == null || collection.isempty()){ //bossa null don return null; } t a = null; for(t eleman: collection){ if(a == null){ // a bossa elemani a'ya ata a = eleman; } else{ // a bos degilse b ile a'yi karsilastir int b = eleman.compareto(a); if((findmax) && (b>0)){ // findmax true ise maksimumu doner a = eleman; } else if((!findmax) && (b<0)){ // findmax false ise minimumu doner a = eleman; } } } return a; } public static void main(string[] args) { java.util.list<integer> numbers = java.util.arrays.aslist(3, 9, 1, 6); system.out.println(findextreme(numbers, true)); // çıktı: 9 (maksimum) system.out.println(findextreme(numbers, false)); // çıktı: 1 (minimum) } } import java.util.arraylist; public class undoablelist<t> extends arraylist<t>{ public void undolast(){ // en son eklenen ogeyi kaldir if(this.isempty()){ // liste bossa bir sey yapma return; } else if(!this.isempty()){ //liste doluysa son ogeyi cikar this.remove(this.size()-1); } } public t getlastadded(){ // son eklenen ogeyi listeyi degistirmeden dondur if(!this.isempty()){ return this.get(this.size()-1); } return null; } public static void main(string[] args){ undoablelist<string> list = new undoablelist<>(); list.add(""a""); list.add(""b""); list.add(""c""); list.undolast(); // ""c"" kaldırılmalı system.out.println(list); // çıktı: [""a"", ""b""] } } 3 kuş bakışı atış oyunu (top-down shooter) bil 211 - proje teslim tarihi: 27 mart 2025 23:59 1 amaç bu ödevde amacınız, java swing kullanarak kuş bakışı bir atış oyunu (top-down shooter) tasarlamaktır. oyunda, yönettiğimiz karakterin üzerine dalga dalga gelen çeşitli zombileri fare ile hedef alarak farklı silahlar kullanıp öldürmemiz gerekmektedir. karakterimiz öldüğünde oyun sona erecektir. her dalga başına ve öldürülen zombi başına kazanılan puan artacaktır. dalgalar ilerledikçe gelen zombilerin sayısı ve çeşitleri artarak zorluk seviyesi yükselecektir. 2 gereksinimler oyun derste öğrendiğiniz oop ilkelerine uygun sınıf/arayüz tasarımları ile geliştirilmelidir. - zorluk seviyesi arttıkça zombi sayısı ve çeşitliliği artmalıdır. - oyun duraklatılabilmeli ve kaydedilip tekrar yüklenilebilmelidir (fileio kullanılmalıdır). - sol üst köşede seçili silah ve kalan mermi miktarı gösterilmelidir. - sağ üst köşede oyuncunun canı ve toplam puanı gösterilmelidir. - oyunun duraklatılması, kaydedilmesi ve devam ettirilmesi için bir menü bulunmalıdır. 3 silahlar oyunda farklı silahlar bulunmaktadır. belirli zombi dalgaları temizlendikten sonra oyun ödül olarak yeni bir silahverecektir. hersilahınkendineözgübirçalışmamekanizmasıvardır. silahlarınşarjörkapasitesisınırlıdır ve şarjördeki mermiler bittiğinde tekrar doldurulmadan ateş edilemez. toplam mermi sayısı oyuncunun o silaha ait elinde ne kadar mermi olduğunu gösterir. r tuşuna basarak şarjör yeniden doldurulabilir. 3.1 tabanca - şarjör kapasitesi: 12 mermi - ateş hızı: 120 mermi/dakika - elde etme: oyuncu oyuna bu silahla başlar. - özellik: düz atış yapar, sapma yoktur. sınırsız yedek şarjör (diğer tüm silahlar için yedek şarjör ve mermiler rastgele bir şekilde dalga sırasında ve sonlarında zombilerden düşer). 3.2 piyade tüfeği - şarjör kapasitesi: 30 mermi - ateş hızı: 600 mermi/dakika - elde etme: 1. dalga tamamlandıktan sonra - özellik: düzatışyaparancak30derecesapmasıvardır. sapmaaçısı, karakterinbaktığıyöndemerminin her iki dönme yönüne de saçılabileceği maksimum açıdır. 1 3.3 pompalı tüfek - şarjör kapasitesi: 5 mermi - ateş hızı: 60 mermi/dakika - elde etme: 3. dalga tamamlandıktan sonra - özellik: her atış 45 derecelik bir yay üzerinde eşit aralıklı 9 mermi atar (yani karakter merkezli mermi hız vektörleri arasında 5 derece açı olmalıdır). 3.4 keskin nişancı tüfeği - şarjör kapasitesi: 5 mermi - ateş hızı: 30 mermi/dakika - elde etme: 5. dalga tamamlandıktan sonra - özellik: mermileri zombileri delip arasındaki zombilere de hasar verir. 3.5 roketatar - şarjör kapasitesi: 1 roket - ateş hızı: 10 roket/dakika - elde etme: 10. dalga tamamlandıktan sonra - özellik: patlama etkisiyle birden fazla zombiye zarar verir. 4 zombiler zombiler oyundaki düşman tipleridir. zombiler oyuncuya doğru ilerlerler ve eğer oyuncuya temas ederlerse oyuncuya hasar verirler. zorluk seviyesi arttıkça zombilerin sayısı ve çeşitliliği artmaktadır. zombi tipleri birbirinden renk ya da şekil olarak ayırt edilebilmelidir. 4.1 normal zombi - can: orta - hız: yavaş - hasar: orta 4.2 sürünge zombi - can: düşük - hız: hızlı - hasar: orta - özellik: oyuncunun yakınına geldiğinde zıplar. 4.3 tank zombi - can: yüksek - hız: çok yavaş - hasar: yüksek 2 4.4 asit tüküren zombi - can: düşük - hız: yavaş - hasar: orta (uzaktan asit tükürebilir) - özellik: öldürüldüğünde yanındaki birimlere zarar verir. 5 rapor ve teslim formatı - oyun, oopprensiplerineuygunolaraktasarlanmalıvesınıfdiyagramları, arayüztasarımıfinalraporda sunulmalıdır. - oyun test edilerek ekran görüntüleri rapora eklenmelidir. - rapor pdf formatında olmalı ve ismi proje_rapor.pdf olmalıdır. - oyunun mainfonksiyonu gameisimli bir sınıf içinde bulunmalıdır ( java game komutuyla çalışmalı). - kaynak kodun tamamı source.zip (uzantı 7z, rar, tar.gz de olabilir) şeklinde sıkıştırılmış olmalıdır. - sıkıştırılmış kaynak kod ve rapor uzak sistemine yüklenmelidir. 6 yardımcı kaynaklar dahaöncehiçkuşbakışıatışoyunuoynamadıysanızaşağıdakioyunlarıreferansolarakalabilirsiniz. buradaki oyunlarıngrafikleriilemekaniklerisizdenbeklenendenfarklıolsadaharitatasarımı, karakterhareketi,kamera hareketi, ateş etme mekanikleri ve zombilerin yapay zekası ile ilgili temel fikirler edinebilirsiniz. - little top-down shooter: https://www.youtube.com/watch?v=pj3m3fu3i5a - super c - stage 2: https://www.youtube.com/watch?v=os2t_v5suj4 - neon chrome: https://www.youtube.com/watch?v=puhw1bevtro 3 public class weapon { } public class pistol { } import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.awt.geom.point2d; import java.awt.image.bufferedimage; import java.io.*; import java.util.*; import java.util.list; import java.util.timer; import javax.imageio.imageio; import java.awt.image.*; public class game extends jframe implements keylistener, mouselistener, mousemotionlistener{ private static final long serialversionuid = 1l; // game constants private static final int window_width = 1000; private static final int window_height = 600; private static final int player_size = 30; private static final int zombie_size = 25; private static final int projectile_size = 5; private static final int player_speed = 5; // game state private boolean running = false; private boolean paused = false; private int score = 0; private int currentwave = 0; private long lastwavetime = 0; private long wavedelay = 5000; // wave'ler arası 5 saniye // game entities private player player; private list<zombie> zombies = new arraylist<>(); private list<projectile> projectiles = new arraylist<>(); private list<pickup> pickups = new arraylist<>(); private list<wall> walls = new arraylist<>(); // ui elements //private bufferedimage background; private jpanel gamepanel; private jmenubar menubar; private jmenuitem pauseitem, saveitem, loaditem, exititem; private transient bufferedimage background; // input tracking private boolean up, down, left, right; private point mouseposition = new point(0, 0); // game timer private transient timer gametimer; private int fps = 60; //backgorund private transient bufferedimage coverimage; public static void main(string[] args){ new game(); } public game(){ settitle(""zombie shooter""); setdefaultcloseoperation(jframe.exit_on_close); setresizable(false); try{ coverimage = imageio.read(getclass().getclassloader().getresourceasstream(""background.png"")); }catch(ioexception e){ system.out.println(""gorsel yuklenemedi: "" + e.getmessage()); e.printstacktrace(); } // arayuz initialize ediyorum createmenubar(); creategamepanel(); addwindowfocuslistener(new windowadapter(){ @override public void windowgainedfocus(windowevent e){ gamepanel.requestfocusinwindow(); } }); // oyunu initialize ediyorum initializegame(); pack(); setlocationrelativeto(null); setvisible(true); // oyun loopunu baslatiyorum startgameloop(); } private void createmenubar(){ menubar = new jmenubar(); jmenu gamemenu = new jmenu(""game""); pauseitem = new jmenuitem(""pause""); pauseitem.addactionlistener(e -> togglepause()); saveitem = new jmenuitem(""save game""); saveitem.addactionlistener(e -> savegame()); loaditem = new jmenuitem(""load game""); loaditem.addactionlistener(e -> loadgame()); exititem = new jmenuitem(""exit""); exititem.addactionlistener(e -> system.exit(0)); gamemenu.add(pauseitem); gamemenu.add(saveitem); gamemenu.add(loaditem); gamemenu.addseparator(); gamemenu.add(exititem); menubar.add(gamemenu); setjmenubar(menubar); } private void creategamepanel(){ gamepanel = new jpanel(){ @override protected void paintcomponent(graphics g){ super.paintcomponent(g); graphics2d g2d = (graphics2d) g; // oyun calismiyorsa kapak ekrani if (!running){ bufferedimage coverimage = null; try{ coverimage = imageio.read(getclass().getclassloader().getresourceasstream(""background.png"")); }catch(ioexception e){ system.out.println(""kapak resmi yüklenemedi: "" + e.getmessage()); e.printstacktrace(); } // kapak resmi if (coverimage != null){ g2d.drawimage(coverimage, 0, 0, getwidth(), getheight(), null); } else{ // eğer fotograf yuklenmezse siyah background ve ustune hata mesaji yazacak g2d.setcolor(color.black); g2d.fillrect(0, 0, getwidth(), getheight()); g2d.setcolor(color.white); g2d.setfont(new font(""arial"", font.bold, 36)); g2d.drawstring(""kapak resmi yüklenemedi!"", getwidth() / 2 - 150, getheight() / 2 - 20); } // baslik ve buyruklar g2d.setcolor(color.white); g2d.setfont(new font(""arial"", font.bold, 36)); //g2d.drawstring(""zombie shooter"", getwidth() / 2 - 150, getheight() / 2 - 50); g2d.setfont(new font(""arial"", font.plain, 20)); //g2d.drawstring(""press enter to start"", getwidth() / 2 - 100, getheight() / 2); } else{ // oyun calisiyorsa background siyah g2d.setcolor(color.black); g2d.fillrect(0, 0, getwidth(), getheight()); // duvarlar for (wall wall: walls){ wall.render(g2d); } // projeler for (projectile p: projectiles){ p.render(g2d); } // zombiler for (zombie z: zombies){ z.render(g2d); } // pickuplar for (pickup pickup: pickups){ pickup.render(g2d); } // oyuncu (biz) player.render(g2d); // arayuz elemanlari drawui(g2d); } } }; gamepanel.setpreferredsize(new dimension(window_width, window_height)); gamepanel.setfocusable(true); gamepanel.addkeylistener(this); gamepanel.addmouselistener(this); gamepanel.addmousemotionlistener(this); add(gamepanel); } private void drawui(graphics2d g2d){ // silah bilgisi (solda) g2d.setcolor(color.white); g2d.setfont(new font(""arial"", font.bold, 14)); weapon currentweapon = player.getcurrentweapon(); g2d.drawstring(""weapon: "" + currentweapon.getname(), 20, 30); g2d.drawstring(""ammo: "" + currentweapon.getammo() + ""/"" + currentweapon.gettotalammo(), 20, 50); // saglik durumu ve score g2d.drawstring(""health: "" + player.health, 800, 30); // sag ust g2d.drawstring(""score: "" + score, 780, 60); // sag ustun alti // hangi level'da (wave) oldugumuzun bilgisi (orta ust) g2d.drawstring(""wave: "" + currentwave, window_width / 2 - 30, 30); // saglik durumu guncellemesi gorsel gorunum g2d.setcolor(color.red); g2d.fillrect(window_width - 150, 40, 100, 10); g2d.setcolor(color.green); g2d.fillrect(window_width - 150, 40, player.health, 10); // zombi turlerinin bilgisi drawzombiekey(g2d); } // ustte zombilerin ikon ve isimlerini gösteren panel private void drawzombiekey(graphics2d g2d){ int iconsize = 20; int margin = 10; int startx = window_width/2 - 200; // baslangic noktasi int y = 60; // normal zombie: yesil daire g2d.setcolor(color.green); g2d.filloval(startx, y, iconsize, iconsize); g2d.setcolor(color.white); g2d.drawstring(""normal zombie"", startx + iconsize + margin, y + iconsize - 3); // crawler (surungen) zombie: sari kare startx += 180; g2d.setcolor(color.yellow); g2d.fillrect(startx, y, iconsize, iconsize); g2d.setcolor(color.white); g2d.drawstring(""crawler zombie"", startx + iconsize + margin, y + iconsize - 3); // tank zombie: kirmizi dortgen startx += 180; int centerx = startx + iconsize / 2; int centery = y + iconsize / 2; polygon diamond = new polygon(); diamond.addpoint(centerx, centery - iconsize / 2); // ust nokta diamond.addpoint(centerx + iconsize / 2, centery); // sag nokta diamond.addpoint(centerx, centery + iconsize / 2); // alt nokta diamond.addpoint(centerx - iconsize / 2, centery); // sol nokta g2d.setcolor(color.red); g2d.fillpolygon(diamond); g2d.setcolor(color.black); g2d.setstroke(new basicstroke(2)); g2d.drawpolygon(diamond); g2d.setcolor(color.white); g2d.setstroke(new basicstroke(1)); g2d.drawstring(""tank zombie"", startx + iconsize + margin, y + iconsize - 3); // acid (asit tukuren) zombie: mor ucgen startx += 180; g2d.setcolor(color.magenta); int[] xpoints = {startx + iconsize/2, startx, startx + iconsize}; int[] ypoints = {y, y + iconsize, y + iconsize}; g2d.fillpolygon(xpoints, ypoints, 3); g2d.setcolor(color.white); g2d.drawstring(""acid zombie"", startx + iconsize + margin, y + iconsize - 3); } // duvarlarin cakismasini istemedigim icin bunun kontrolunu burada yapiyorum private boolean canplacewall(int x, int y, int width, int height){ rectangle newwallrect = new rectangle(x, y, width, height); for (wall wall: walls){ rectangle existingwallrect = new rectangle(wall.x, wall.y, wall.width, wall.height); if(newwallrect.intersects(existingwallrect)){ return false; } } return true; } private void initializegame(){ // oyuncu (ben) oyun ekraninin merkezinde oyuna basliyorum player = new player(window_width / 2, window_height / 2); player.addweapon(new pistol()); // resetleme zombies.clear(); projectiles.clear(); pickups.clear(); walls.clear(); score = 0; currentwave = 0; if(canplacewall(150, 50, 20, 200)){ walls.add(new wall(350, 90, 20, 200)); } if(canplacewall(550, 300, 20, 200)){ walls.add(new wall(550, 300, 20, 200)); } if(canplacewall(700, 100, 20, 200)){ walls.add(new wall(700, 150, 20, 200)); } if(canplacewall(200, 350, 200, 20)){ walls.add(new wall(200, 350, 200, 20)); } if(canplacewall(400, 500, 200, 20)){ walls.add(new wall(700, 500, 200, 20)); } if(canplacewall(50, 300, 100, 20)){ walls.add(new wall(50, 200, 100, 20)); } if(canplacewall(850, 50, 100, 20)){ walls.add(new wall(850, 250, 100, 20)); } if(canplacewall(300, 450, 20, 100)){ walls.add(new wall(300, 450, 20, 100)); } // baslangicta oyun calismasin running = false; paused = false; } private void startgameloop(){ gametimer = new timer(); gametimer.scheduleatfixedrate(new timertask(){ @override public void run(){ if(running && !paused){ update(); } gamepanel.repaint(); } }, 0, 1000 / fps); } private void update(){ // oyuncu guncellemesi player.update(); // mermi guncellemesi ve carpisma kontrolu for(int i = projectiles.size() - 1; i >= 0; i--){ projectile p = projectiles.get(i); p.update(); // sinir disinda kalan mermileri yok ediyorum if (p.x < 0 || p.x > window_width || p.y < 0 || p.y > window_height){ projectiles.remove(i); continue; } // duvarlarla carpisma olup olmadığını kontrol ediyorum, carpisma varsa mermiyi cikariyorum for(wall wall: walls){ if(circlerectcollision(p, wall)){ projectiles.remove(i); break; } } // zombilerle carpismayi kontrol ediyorum for(int j = zombies.size() - 1; j >= 0; j--){ zombie z = zombies.get(j); if(checkcollision(p, z)){ z.takedamage(p.damage); // roketatar icin special case: patlama etkisiyle birden fazla zombiye zarar verir if(p instanceof rocketprojectile){ ((rocketprojectile) p).explode(zombies); projectiles.remove(i); break; } // keskin nisanci tufegi icin special case: mermileri zombileri delip arasındaki zombilere de hasar verir if(!(p instanceof sniperprojectile)){ projectiles.remove(i); break; } } } } // zombileri guncelliyorum ve oyuncu carpismasini kontrol ediyorum for(int i = zombies.size() - 1; i >= 0; i--){ zombie z = zombies.get(i); z.update(); // zombinin olup olmedigini kontrol et if(z.health <= 0){ // asit tukuren zombinin ozel efekti if(z instanceof acidzombie){ ((acidzombie) z).splashacid(zombies); } // cephane dusurme if(math.random() < 0.15){ pickups.add(new ammopickup(z.x, z.y)); } zombies.remove(i); score += 10 * currentwave; continue; } // oyuncuyla carpisma olup olmadigini kontrol ediyorum if(checkcollision(player, z)){ player.takedamage(z.damage); // oyuncuyu zombiden uzaklastiriyorum double angle = math.atan2(player.y - z.y, player.x - z.x); player.x += math.cos(angle) * 10; player.y += math.sin(angle) * 10; // oyuncu olunce oyun bitiyor if(player.health <= 0){ running = false; } } } // pickuplari guncelliyorum ve collectionlari kontrol ediyorum for(int i = pickups.size() - 1; i >= 0; i--){ pickup pickup = pickups.get(i); if(checkcollision(player, pickup)){ pickup.collect(player); pickups.remove(i); } } // level'in (wave) bitip bitmedigini kontrol ediyorum if(zombies.isempty()){ if (system.currenttimemillis() - lastwavetime > wavedelay){ startnextwave(); } } } private void startnextwave() { currentwave++; lastwavetime = system.currenttimemillis(); // silah ekleme kontrolleri if(currentwave == 2){ player.addweapon(new assaultrifle()); } else if(currentwave == 4){ player.addweapon(new shotgun()); } else if(currentwave == 6){ player.addweapon(new sniperrifle()); } else if(currentwave == 11){ player.addweapon(new rocketlauncher()); } // level'lara gore zombiler if(currentwave == 1){ // sadece normal zombi int normalcount = 3; // temel sayı for(int i = 0; i < normalcount; i++){ spawnzombieatedge(new normalzombie(0, 0)); } } else if(currentwave == 2){ // normal ve surungen zombi int normalcount = 3; int crawlercount = 2; for(int i = 0; i < normalcount; i++){ spawnzombieatedge(new normalzombie(0, 0)); } for(int i = 0; i < crawlercount; i++){ spawnzombieatedge(new crawlerzombie(0, 0)); } } else if(currentwave == 3){ // normal, surungen ve tank zombie int normalcount = 3; int crawlercount = 2; int tankcount = 3; for(int i = 0; i < normalcount; i++){ spawnzombieatedge(new normalzombie(0, 0)); } for(int i = 0; i < crawlercount; i++){ spawnzombieatedge(new crawlerzombie(0, 0)); } for(int i = 0; i < tankcount; i++){ spawnzombieatedge(new tankzombie(0, 0)); } } else if(currentwave >= 4){ // 4. wave ve sonrasında: normal, surungen, tank ve asit tukuren zombi spawn ediyorum // surungen haricinde tum zombi türlerine her wavede 1'er adet ekliyorum int increase = currentwave - 3; // 4. dalgada artis=1, 5. dalgada artis=2 int normalcount = 3 + increase; int tankcount = 3 + increase; int acidcount = 3 + increase; int crawlercount = 1; // sabit for(int i = 0; i < normalcount; i++){ spawnzombieatedge(new normalzombie(0, 0)); } for(int i = 0; i < crawlercount; i++){ spawnzombieatedge(new crawlerzombie(0, 0)); } for(int i = 0; i < tankcount; i++){ spawnzombieatedge(new tankzombie(0, 0)); } for(int i = 0; i < acidcount; i++){ spawnzombieatedge(new acidzombie(0, 0)); } } } /* private void startnextwave(){ /* * oyunun bu kismini sadece kontrol etme amacli yazdim ve waveler arasi geci̇s kontrolu icin * oyundaki zombi sayilarini 1'e indirerek oyunu kodun bu kisminda kolaylastirdim. * bundan dolayi bu kismi comment satirina aldim. * /* // normal zombi for(int i = 0; i < 1; i++){ spawnzombieatedge(new normalzombie(0, 0)); } // surungen zombi if(currentwave >= 2){ for(int i = 0; i < 1; i++){ spawnzombieatedge(new crawlerzombie(0, 0)); } } // tank zombi if(currentwave >= 3){ for(int i = 0; i < 1; i++){ spawnzombieatedge(new tankzombie(0, 0)); } } // asit zombi if(currentwave >= 4){ for(int i = 0; i < 1; i++){ spawnzombieatedge(new acidzombie(0, 0)); } } }*/ private void spawnzombieatedge(zombie zombie){ int side = (int) (math.random() * 4); // 0:ust, 1:sag, 2:alt, 3:sol switch(side){ case 0: // ust zombie.x = math.random() * window_width; zombie.y = -zombie_size; break; case 1: // sag zombie.x = window_width + zombie_size; zombie.y = math.random() * window_height; break; case 2: // alt zombie.x = math.random() * window_width; zombie.y = window_height + zombie_size; break; case 3: // sol zombie.x = -zombie_size; zombie.y = math.random() * window_height; break; } zombies.add(zombie); } private boolean checkcollision(gameobject a, gameobject b){ double distance = math.sqrt(math.pow(a.x - b.x, 2) + math.pow(a.y - b.y, 2)); return distance < (a.size + b.size) / 2; } // daire ile dikdortgen carpismasini tespit ediyorum private boolean circlerectcollision(gameobject circle, wall wall){ double radius = circle.size / 2.0; double cx = circle.x; double cy = circle.y; double closestx = math.max(wall.x, math.min(cx, wall.x + wall.width)); double closesty = math.max(wall.y, math.min(cy, wall.y + wall.height)); double dx = cx - closestx; double dy = cy - closesty; return (dx * dx + dy * dy) < (radius * radius); } // carpisma olunca nesneyi duvardan itiyorum private void resolvecollision(gameobject circle, wall wall){ double radius = circle.size / 2.0; double cx = circle.x; double cy = circle.y; double closestx = math.max(wall.x, math.min(cx, wall.x + wall.width)); double closesty = math.max(wall.y, math.min(cy, wall.y + wall.height)); double dx = cx - closestx; double dy = cy - closesty; double distance = math.sqrt(dx * dx + dy * dy); if(distance < radius && distance != 0){ double penetration = radius - distance; circle.x += (dx / distance) * penetration; circle.y += (dy / distance) * penetration; } else if(distance == 0){ circle.x += radius; } } private void togglepause(){ paused = !paused; pauseitem.settext(paused ? ""resume"" : ""pause""); } private void savegame(){ if(!running){ return; } try(objectoutputstream oos = new objectoutputstream(new fileoutputstream(""savegame.dat""))){ gamestate state = new gamestate(); state.player = player; state.zombies = zombies; state.projectiles = projectiles; state.pickups = pickups; state.score = score; state.currentwave = currentwave; oos.writeobject(state); joptionpane.showmessagedialog(this, ""game saved successfully!""); } catch(exception e){ joptionpane.showmessagedialog(this, ""failed to save game: "" + e.getmessage(), ""error"", joptionpane.error_message); e.printstacktrace(); } } private void loadgame(){ try(objectinputstream ois = new objectinputstream(new fileinputstream(""savegame.dat""))){ gamestate state = (gamestate) ois.readobject(); player = state.player; zombies = state.zombies; projectiles = state.projectiles; pickups = state.pickups; score = state.score; currentwave = state.currentwave; gametimer = new timer(); startgameloop(); reloadassets(); running = true; paused = false; pauseitem.settext(""pause""); joptionpane.showmessagedialog(this, ""game loaded successfully!""); } catch(exception e){ joptionpane.showmessagedialog(this, ""failed to load game: "" + e.getmessage(), ""error"", joptionpane.error_message); e.printstacktrace(); } } private void reloadassets() { try { background = imageio.read(new file(""background.png"")); // diğer grafik nesneleri burada tekrar yüklenir } catch (ioexception e) { joptionpane.showmessagedialog(this, ""failed to load assets: "" + e.getmessage(), ""error"", joptionpane.error_message); e.printstacktrace(); } } // kaydetme ve yukleme islerini yapiyorum private static class gamestate implements serializable{ private static final long serialversionuid = 1l; player player; list<zombie> zombies; list<projectile> projectiles; list<pickup> pickups; int score; int currentwave; } // game objelerinin base class'i private abstract class gameobject implements serializable{ private static final long serialversionuid = 1l; double x, y; int size; color color; public gameobject(double x, double y, int size, color color){ this.x = x; this.y = y; this.size = size; this.color = color; } public abstract void update(); public void render(graphics2d g){ g.setcolor(color); g.filloval((int)(x - size/2), (int)(y - size/2), size, size); } } // duvar private class wall implements serializable{ private static final long serialversionuid = 1l; int x, y, width, height; public wall(int x, int y, int width, int height){ this.x = x; this.y = y; this.width = width; this.height = height; } public void render(graphics2d g){ g.setcolor(color.light_gray); g.fillrect(x, y, width, height); } } private class player extends gameobject{ private static final long serialversionuid = 1l; private int health = 100; private list<weapon> weapons = new arraylist<>(); private int currentweaponindex = 0; private double angle = 0; public player(double x, double y){ super(x, y, player_size, color.blue); } public void addweapon(weapon weapon){ weapons.add(weapon); } public weapon getcurrentweapon(){ return weapons.get(currentweaponindex); } public void switchweapon(int index){ if(index >= 0 && index < weapons.size()){ currentweaponindex = index; } } public void nextweapon(){ currentweaponindex = (currentweaponindex + 1) % weapons.size(); } public void previousweapon(){ currentweaponindex = (currentweaponindex - 1 + weapons.size()) % weapons.size(); } public void shoot(){ getcurrentweapon().shoot(x, y, angle); } public void reload(){ getcurrentweapon().reload(); } public void takedamage(int amount){ health -= amount; if (health < 0) health = 0; } @override public void update(){ double oldx = x, oldy = y; double dx = 0, dy = 0; if (up) dy -= player_speed; if (down) dy += player_speed; if (left) dx -= player_speed; if (right) dx += player_speed; // capraz hareket if(dx != 0 && dy != 0){ double factor = player_speed / math.sqrt(dx * dx + dy * dy); dx *= factor; dy *= factor; } x += dx; y += dy; // oyuncuyu sinirlar icinde tutuyorum if(x < size/2){ x = size/2; } if(x > window_width - size/2){ x = window_width - size/2; } if(y < size/2){ y = size/2; } if(y > window_height - size/2){ y = window_height - size/2; } // duvara carpinca geri don for (wall wall: walls){ if (circlerectcollision(this, wall)){ x = oldx; y = oldy; break; } } // aciyi mouse'un konumuna gore guncelliyorum double dx2 = mouseposition.x - x; double dy2 = mouseposition.y - y; angle = math.atan2(dy2, dx2); } @override public void render(graphics2d g){ // oyuncuyu ciziyorum g.setcolor(color); g.filloval((int)(x - size/2), (int)(y - size/2), size, size); // silahin yonu int gunlength = size/2 + 10; int endx = (int)(x + math.cos(angle) * gunlength); int endy = (int)(y + math.sin(angle) * gunlength); g.setcolor(color.dark_gray); g.setstroke(new basicstroke(3)); g.drawline((int)x, (int)y, endx, endy); } } private abstract class zombie extends gameobject{ private static final long serialversionuid = 1l; protected int health; protected int damage; protected double speed; protected long lastattacktime = 0; protected int attackcooldown = 1000; // 1 saniye public zombie(double x, double y, int size, color color, int health, int damage, double speed){ super(x, y, size, color); this.health = health; this.damage = damage; this.speed = speed; } public void takedamage(int amount){ health -= amount; } @override public void update(){ double dx = player.x - x; double dy = player.y - y; double distance = math.sqrt(dx * dx + dy * dy); if(distance > 0){ dx = dx / distance * speed; dy = dy / distance * speed; x += dx; y += dy; } // carpisma durumu for(wall wall: walls){ if(circlerectcollision(this, wall)){ resolvecollision(this, wall); } } } // varsayılan render() => yuvarlak (normalzombie) } // normal zombie: yesil daire (default durum) private class normalzombie extends zombie{ private static final long serialversionuid = 1l; public normalzombie(double x, double y){ super(x, y, zombie_size, color.green, 30, 10, 1.0); } } // crawler (surungen) zombie: sari kare private class crawlerzombie extends zombie { private static final long serialversionuid = 1l; private boolean isjumping = false; private double jumptime = 0; public crawlerzombie(double x, double y){ super(x, y, zombie_size - 5, color.yellow, 15, 8, 2.0); } @override public void update(){ double dx = player.x - x; double dy = player.y - y; double distance = math.sqrt(dx * dx + dy * dy); if(distance < 150 && !isjumping){ isjumping = true; jumptime = 0; } if(isjumping){ jumptime += 0.05; if(jumptime < 1.0){ dx = dx / distance * (speed * 2); dy = dy / distance * (speed * 2); x += dx; y += dy; } else{ isjumping = false; } } else{ double ddx = player.x - x; double ddy = player.y - y; double ddistance = math.sqrt(ddx * ddx + ddy * ddy); if(ddistance > 0){ ddx = ddx / ddistance * speed; ddy = ddy / ddistance * speed; x += ddx; y += ddy; } } for(wall wall: walls){ if(circlerectcollision(this, wall)){ resolvecollision(this, wall); } } } // kare @override public void render(graphics2d g){ g.setcolor(color); int drawx = (int)(x - size/2); int drawy = (int)(y - size/2); g.fillrect(drawx, drawy, size, size); } } // tank zombie: kirmizi dortgen private class tankzombie extends zombie{ private static final long serialversionuid = 1l; public tankzombie(double x, double y){ super(x, y, zombie_size + 10, color.red, 100, 20, 0.5); } @override public void render(graphics2d g){ // icini dolduruyorum g.setcolor(color); g.filloval((int)(x - size/2), (int)(y - size/2), size, size); // kalin siyah border g.setcolor(color.black); g.setstroke(new basicstroke(3)); g.drawoval((int)(x - size/2), (int)(y - size/2), size, size); g.setstroke(new basicstroke(1)); } } // acid (asit tukuren) zombie: mor ucgen private class acidzombie extends zombie{ private static final long serialversionuid = 1l; private long lastspittime = 0; private int spitcooldown = 3000; // 3 seconds public acidzombie(double x, double y){ super(x, y, zombie_size, color.magenta, 20, 8, 0.7); } @override public void update(){ super.update(); double distance = math.sqrt(math.pow(player.x - x, 2) + math.pow(player.y - y, 2)); if(distance < 200 && system.currenttimemillis() - lastspittime > spitcooldown){ double angle = math.atan2(player.y - y, player.x - x); projectiles.add(new acidprojectile(x, y, angle)); lastspittime = system.currenttimemillis(); } } // ucgen @override public void render(graphics2d g){ g.setcolor(color); int halfsize = size / 2; int[] xpoints = {(int)x, (int)(x - halfsize), (int)(x + halfsize)}; int[] ypoints = {(int)(y - halfsize), (int)(y + halfsize), (int)(y + halfsize)}; g.fillpolygon(xpoints, ypoints, 3); } public void splashacid(list<zombie> zombies){ for(zombie z : zombies){ if(z != this){ double distance = math.sqrt(math.pow(z.x - x, 2) + math.pow(z.y - y, 2)); if(distance < 100){ z.takedamage(15); } } } } } private abstract class projectile extends gameobject{ private static final long serialversionuid = 1l; protected double vx, vy; protected int damage; public projectile(double x, double y, double angle, double speed, int damage, int size, color color){ super(x, y, size, color); this.vx = math.cos(angle) * speed; this.vy = math.sin(angle) * speed; this.damage = damage; } @override public void update(){ x += vx; y += vy; } } private class bulletprojectile extends projectile{ private static final long serialversionuid = 1l; public bulletprojectile(double x, double y, double angle, int damage){ super(x, y, angle, 10.0, damage, projectile_size, color.yellow); } } private class shotgunprojectile extends projectile{ private static final long serialversionuid = 1l; public shotgunprojectile(double x, double y, double angle, int damage){ super(x, y, angle, 8.0, damage, projectile_size, color.orange); } } private class sniperprojectile extends projectile{ private static final long serialversionuid = 1l; public sniperprojectile(double x, double y, double angle, int damage){ super(x, y, angle, 15.0, damage, projectile_size, color.red); } } private class rocketprojectile extends projectile{ private static final long serialversionuid = 1l; public rocketprojectile(double x, double y, double angle, int damage){ super(x, y, angle, 5.0, damage, projectile_size * 2, color.gray); } public void explode(list<zombie> zombies){ for(zombie z : zombies){ double distance = math.sqrt(math.pow(z.x - x, 2) + math.pow(z.y - y, 2)); if(distance < 100){ int explosiondamage = (int)(damage * (1 - distance / 100)); z.takedamage(explosiondamage); } } } @override public void render(graphics2d g){ g.setcolor(color); g.filloval((int)(x - size/2), (int)(y - size/2), size, size); g.setcolor(color.orange); g.filloval((int)(x - vx - size/4), (int)(y - vy - size/4), size/2, size/2); } } private class acidprojectile extends projectile{ private static final long serialversionuid = 1l; public acidprojectile(double x, double y, double angle){ super(x, y, angle, 3.0, 5, projectile_size, color.green); } } private interface weapon extends serializable{ void shoot(double x, double y, double angle); void reload(); int getammo(); int getmaxammo(); int gettotalammo(); string getname(); } private abstract class abstractweapon implements weapon{ private static final long serialversionuid = 1l; protected int ammo; protected int maxammo; protected int totalammo; protected int damage; protected long lastshottime = 0; protected int firerate; public abstractweapon(int maxammo, int totalammo, int damage, int firerate){ this.maxammo = maxammo; this.ammo = maxammo; this.totalammo = totalammo; this.damage = damage; this.firerate = firerate; } @override public void reload(){ if (totalammo > 0){ int ammoneeded = maxammo - ammo; int ammotoadd = math.min(ammoneeded, totalammo); ammo += ammotoadd; totalammo -= ammotoadd; } } @override public int getammo(){ return ammo; } @override public int getmaxammo(){ return maxammo; } @override public int gettotalammo(){ return totalammo; } protected boolean canshoot(){ return ammo > 0 && system.currenttimemillis() - lastshottime > firerate; } } private class pistol extends abstractweapon{ private static final long serialversionuid = 1l; public pistol(){ super(12, 60, 15, 400); } @override public void shoot(double x, double y, double angle){ if(canshoot()){ projectiles.add(new bulletprojectile(x, y, angle, damage)); ammo--; lastshottime = system.currenttimemillis(); } } @override public string getname(){ return ""pistol""; } } private class assaultrifle extends abstractweapon{ private static final long serialversionuid = 1l; public assaultrifle(){ super(30, 120, 10, 100); } @override public void shoot(double x, double y, double angle){ if(canshoot()){ double spread = math.toradians((math.random() - 0.5) * 30); // -15° ile +15° arası sapma projectiles.add(new bulletprojectile(x, y, angle + spread, damage)); ammo--; lastshottime = system.currenttimemillis(); } } @override public string getname(){ return ""assault rifle""; } } private class shotgun extends abstractweapon{ private static final long serialversionuid = 1l; public shotgun(){ super(8, 32, 8, 700); } @override public void shoot(double x, double y, double mainangle){ if(canshoot()){ int pelletcount = 9; double totalspread = math.toradians(45); // 45 derece aci // ilk aci: yay araliginin yarisini sola cekiyorum double startangle = mainangle - totalspread / 2; double angleincrement = totalspread / (pelletcount - 1); for(int i = 0; i < pelletcount; i++){ double pelletangle = startangle + i * angleincrement; projectiles.add(new shotgunprojectile(x, y, pelletangle, damage)); } ammo--; lastshottime = system.currenttimemillis(); } } @override public string getname(){ return ""shotgun""; } } private class sniperrifle extends abstractweapon{ private static final long serialversionuid = 1l; public sniperrifle(){ super(5, 20, 50, 1200); } @override public void shoot(double x, double y, double angle){ if(canshoot()){ projectiles.add(new sniperprojectile(x, y, angle, damage)); ammo--; lastshottime = system.currenttimemillis(); } } @override public string getname(){ return ""sniper rifle""; } } private class rocketlauncher extends abstractweapon{ private static final long serialversionuid = 1l; public rocketlauncher(){ super(1, 5, 100, 2000); } @override public void shoot(double x, double y, double angle) { if(canshoot()){ projectiles.add(new rocketprojectile(x, y, angle, damage)); ammo--; lastshottime = system.currenttimemillis(); } } @override public string getname(){ return ""rocket launcher""; } } private abstract class pickup extends gameobject{ private static final long serialversionuid = 1l; public pickup(double x, double y, int size, color color){ super(x, y, size, color); } public abstract void collect(player player); @override public void update(){ // pickuplar hareket etmeyecek } } private class ammopickup extends pickup{ private static final long serialversionuid = 1l; public ammopickup(double x, double y){ super(x, y, 15, color.orange); } @override public void collect(player player){ weapon weapon = player.getcurrentweapon(); ((abstractweapon)weapon).totalammo += weapon.getmaxammo(); } @override public void render(graphics2d g){ g.setcolor(color); g.fillrect((int)(x - size/2), (int)(y - size/2), size, size); g.setcolor(color.black); g.drawstring(""a"", (int)x - 3, (int)y + 3); } } @override public void keypressed(keyevent e){ switch(e.getkeycode()){ case keyevent.vk_w: up = true; break; case keyevent.vk_s: down = true; break; case keyevent.vk_a: left = true; break; case keyevent.vk_d: right = true; break; case keyevent.vk_r: if(running && !paused){ player.reload(); } break; case keyevent.vk_1: case keyevent.vk_2: case keyevent.vk_3: case keyevent.vk_4: case keyevent.vk_5: if(running && !paused){ int index = e.getkeycode() - keyevent.vk_1; player.switchweapon(index); } break; case keyevent.vk_escape: if(running){ togglepause(); } break; case keyevent.vk_enter: if(!running){ initializegame(); running = true; startnextwave(); } break; case keyevent.vk_k: if(running && !paused){ savegame(); } break; } } @override public void keyreleased(keyevent e){ switch(e.getkeycode()){ case keyevent.vk_w: up = false; break; case keyevent.vk_s: down = false; break; case keyevent.vk_a: left = false; break; case keyevent.vk_d: right = false; break; } } @override public void keytyped(keyevent e){ // kullanmiyorum } @override public void mousepressed(mouseevent e){ if(running && !paused && e.getbutton() == mouseevent.button1){ player.shoot(); } } @override public void mousereleased(mouseevent e){ // kullanmiyorum } @override public void mouseclicked(mouseevent e){ // kullanmiyorum } @override public void mouseentered(mouseevent e){ // kullanmiyorum } @override public void mouseexited(mouseevent e){ // kullanmiyorum } @override public void mousemoved(mouseevent e){ mouseposition.x = e.getx(); mouseposition.y = e.gety(); } @override public void mousedragged(mouseevent e){ mouseposition.x = e.getx(); mouseposition.y = e.gety(); // surukleme if (running && !paused && swingutilities.isleftmousebutton(e)) { player.shoot(); } } }"
