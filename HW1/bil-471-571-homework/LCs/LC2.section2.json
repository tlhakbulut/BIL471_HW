{
  "questions": [
    "Öğrenci No.",
    "Abstraction kavramını açıklayınız.",
    "Dönüş tipi Employee olan bir metodu dönüş tipi HourlyEmployee olan bir metot olarak override etmek mümkün müdür? Peki ya bunun tersi?",
    "Protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır?",
    "Java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır?",
    "Java'da bir class birden çok classı extend edebilir mi, \"A extends B, C\" gibi bir şey mümkün müdür?",
    "Java'da \"instanceof\" operatörü hangi ilişkiyi kontrol eder? \"A instanceof B\" ise A ve B arasındaki ilişki nedir?",
    "Metot overriding ve overloading kavramlarını açıklayınız.",
    "class Base {\n    int x = 10;\n    Base() { print(); }\n    void print() { System.out.print(\"Base\"); }\n}\nclass Derived extends Base {\n    int x = 1;\n    void print() { System.out.print(x); }\n}\n\n// Test sınıfı, main metodu içinde \nnew Derived();\n\n\nOutput?",
    "class Parent {\n    protected int x = 10;\n    { System.out.println(\"Parent\");}\n    public int getValue() { return x; }\n}\nclass Child extends Parent {\n    private int x = 20;\n    public int getValue() { return super.x + x; }\n}\n\n// Test sınıfı, main metodu içinde \nParent c = new Child();\nSystem.out.println(c.getValue());\n\nOutput?"
  ],
  "answers": [
    {
      "id": "6094496",
      "cevap1": "javada tanımladığımız nesnelerin bazı özelliklerini gözardı etmemize abstraction denir. Soyutlama da denir",
      "cevap2": "-",
      "cevap3": "protected",
      "cevap4": "-",
      "cevap5": "olabilir. Bir classın iki tane parent classı olabilir",
      "cevap6": "B A'nın parent classıdır veya base classıdır",
      "cevap7": "-",
      "cevap8": 1,
      "cevap9": 30
    },
    {
      "id": "5628146",
      "cevap1": "Soyutlama, karmaşıok bir sistemi kolay ve anlaşılır hale getirir",
      "cevap2": "evet mümkündür java covraiant return typesı destekler tersi mümkün değil çünkü subclass olmalı",
      "cevap3": "no modifier(default) class ve package içerirken protected için bunun üstüne subclass eklenir yani no modifier daha yakın",
      "cevap4": "üst sınıfta kullandığımız constructuru subclasslarda kullanabilmek için",
      "cevap5": "mümkün değil sadece birini yapabilir",
      "cevap6": "bir nesnenin belirli bir sınıfın veya arayüzün örneği olup olmadığını kontrol eder A,B'nin subclasıysa true döner",
      "cevap7": "overloading : aynı isimdeki metotların farklı parametre listeleriyle tanımlanması overriding : subclasın  üst sınıfta tanımlı bir metodu yeniden tanımlaması",
      "cevap8": 0,
      "cevap9": 30
    },
    {
      "id": "7732416",
      "cevap1": "Abstraction gerçek hayat problemlerinin soyutlanması. Yani dijitalde temsil etmemiz. Sınıfları ise contexte göre bilgileri gösterecek şekilde tasarlamamız",
      "cevap2": "Mümkündür çünkü Hourly employee İS A employee. Fakat tam tersi olamaz çünkü employee bir hourly employee değildir",
      "cevap3": "Default daha yakındır çünkü erişebilen sınıf sayısı protected a göre daha sınırlı (subclasslar erişemiyor)",
      "cevap4": "Çünkü üst sınıfın özellikleri doldurulmalıdır. En önce üst sınıf şeklinde yaratılıp sonra özellikler eklenir",
      "cevap5": "Edemez çünkü başka sınıflarda metot veya variable isimleri aynıysa bu karışıklığa sebebiyet verir",
      "cevap6": "Subclass olup olmamasını kontrol eder. A, B nin subclassı dır",
      "cevap7": "Overriding alt sınıfta üst sınıfın metodunu tekrar tanımlamaya denir ve signature aynıdır. Overloading ise aynı isimli metotların farklı parametrelere sahip olmasıdır.",
      "cevap8": "Base 1",
      "cevap9": "Parent 30 "
    },
    {
      "id": "4856424",
      "cevap1": "gerekli bilgileri alıp kalanıyla ilgilenmeme",
      "cevap2": "ikiside olmaz",
      "cevap3": "no modifier",
      "cevap4": "inheritance dan dolayı parent class daki degiskenleri almak için ",
      "cevap5": "hayır",
      "cevap6": "bilmiyorum",
      "cevap7": "override: parent classtaki bir metodun uzantisindaki baska bir sinifta yine olmasi ama farkli bir ifadeyle mesela kedi köpek ve balık üçününde parent classi hayvanlardir ama kuş koşamaz uçabilir overloading ise bir metodun ismi ayni ama parametrelerinin farkli olarak kullanilmasidir",
      "cevap8": 1,
      "cevap9": "bilmiyorum"
    },
    {
      "id": "6343320",
      "cevap1": ".",
      "cevap2": "Hayır çünkü override etmek için metodların signature ve isim kısmı aynı olmalı",
      "cevap3": "No modifier",
      "cevap4": "Çünkü eğer super olursa erişimi kısıtlamış oluruz",
      "cevap5": "Hayır ama eğer b c yi extend etmişse ve a da b yi extend ediyorsa a otomatikmen c yi de extend etmiş olur",
      "cevap6": "A b midir yani extend edilmiş mi diye bakar",
      "cevap7": "Override bir metodu farklı bir classın içinde aynı signature ve isimle tekrardan yazmaktır, overload ise metodu fazladan yüklemektir",
      "cevap8": 101,
      "cevap9": 30
    },
    {
      "id": "2103960",
      "cevap1": "Soyutlama gerekli bilgi açık gereksiz bilgi kapalı",
      "cevap2": "Evet mümkün tersi olmaz",
      "cevap3": "default daha yakın",
      "cevap4": "Her classın parent classına kolayca sürekli Super yazmadan ulaşmayı sağlar parentn constructerını çağırır",
      "cevap5": "Hayır",
      "cevap6": "A Bnin objesi",
      "cevap7": "Override aynı signatureın subclasslarda yeniden tanınlanması overload ise aynı isim farklı signature",
      "cevap8": " ",
      "cevap9": "Parent 10"
    },
    {
      "id": "4114373",
      "cevap1": "Abstraction bir işlevin nasıl çalıştığına değil ne yaptığına bakan, gereksiz detaylara boğulmadan istenileni vermesine denilen kavramdır.",
      "cevap2": "Employee, HourlyEmployee'nin parenti oldugu için HourlyEmployee is A Employee deriz yani mümkün olur ama Employee is HourlyEmployee olmadığı için mümkün olmaz.",
      "cevap3": "Protected: Class, Package ve subclass Default: Class ve Package olduğundan dolayı Default Private'e daha yakındır.",
      "cevap4": "Çünkü parentta bulunan her şey child'da da vardır ve bu yüzden objeyi oluştururken tüm değişkenleri ayarlamak istiyorsak bi üstteki parent'in constructerini çağırmak zorundayız.",
      "cevap5": "Hayır mümkün değildir çünkü B'de ve C'de aynı metotlar veya değişkenler olabilir.",
      "cevap6": "getClass() gibi class'ın kendisine de bakıp aynı zamanda parent'larının da eşit olmasını döndürür",
      "cevap7": "Metot override: tamamen aynı olan metotlar, metot overloading: dönüş tipi hariç her şeyi aynı olan metotlar",
      "cevap8": "Output: ",
      "cevap9": 30
    },
    {
      "id": "1889298",
      "cevap1": "Kodun sadece belirli bir kısmını kullanıcının değiştirmesine açık kılmak",
      "cevap2": "HourlyEmployee tipi bir objeden Employee döndürürsek eksikler kalır ama tersi bir durum geçerli olabilir (hourlyEmployee Employeeyi kapsıyor çünkü)",
      "cevap3": "No modifier yani default modifier daha yakındir",
      "cevap4": "Base class ve kullandığımız classın atası olan subclasslardaki metod ve parametreleri korumak için",
      "cevap5": "C B'nin subclassıysa A extends C şeklinde edebilir ama üstteki gibi bir kullanım olamaz",
      "cevap6": "A'nın B'nin subclassı olup olmadığını kontrol eder",
      "cevap7": "Overriding signiture kısmı aynı overloading ise signiture kısmı farklı olan metodları tekrar subclassda kullanmaktır",
      "cevap8": 1,
      "cevap9": 30
    },
    {
      "id": "5187413",
      "cevap1": "Soyutlama, black box. Çalışırken metotun işleyişini detaylı olarak bilmediğimiz ama çıktısını bildiğimiz metotları örnek verebiliriz örneğin system.out.println",
      "cevap2": "Override ettiğimiz metot diğer sınıfın subclassında yer aldığı için mümkündür. Tersi değil.",
      "cevap3": "Protected private a daha yakın çünkü aynı package ve subclassların erişimine izin veriyor.",
      "cevap4": "Kendinden hemen önceki türetildiği classın contructorını almak için. Bu listenin en tepesinde object classı yer alır.",
      "cevap5": "Hayır extend ettiğimiz classların metotları birbiriyle aynı olabilir sorun çıkarabilir.",
      "cevap6": "A B'nin içinde tanımlı bir variabledir.",
      "cevap7": "Overriding base classta bulunan bir metotun türettiğimiz classa özel halini yazmaktır isimleri aynıdır. Overloading yine aynı isimli metotların farklı imzalara sahip tanımlanmasıdır aynı classın içinde olur.",
      "cevap8": "Base 1",
      "cevap9": "Parent+\" \\n\" + 30"
    },
    {
      "id": "6418019",
      "cevap1": "gerekli bilgileri alıp geri kalan bilgileri gizlemek, blackbox a almak",
      "cevap2": "mümkündür cünkü Employee HourlyEmployee nin  atasıdır. Tersi mümkün degildir",
      "cevap3": "protected",
      "cevap4": "ata class ın constructorını çağırmak ve bilgilerli almak için",
      "cevap5": "mümkün değildir, her class bir üstündeki classı extend etmeli",
      "cevap6": "verilen değişkenlerin typelarının aynı olup olmadıgına ve aralarında kalıtım ilişkisi var mı ona bakar. Aralarındaki ilişki: typeları aynıdır ve B, A nın atasıdır",
      "cevap7": "overriding: metotların signatureları aynıdır, metodu child classın özelliklerine göre tekrar düzenleriz. overloading: metotların isimleri aynıdır ama parametreler farklıdır.",
      "cevap8": "-",
      "cevap9": 30
    },
    {
      "id": "4779274",
      "cevap1": "soyutlama, \"is a\" ilişkilerinde temel olan özellikleri bir kenarda soyut bi biçimde tutma diyebiliriz bence",
      "cevap2": "evet mümkün, zaten hourlyemployee is an employee mantığıyla bakınca dönüş tipi değişmio",
      "cevap3": "no modifier dediğimiz default mu eğer öyleyde no modifier daha yakın. protected subclas falan da alıo",
      "cevap4": "e çünkü alt sınıftan bi nesne tanımladığımızda bunun atasındaki instance variablelerinr de atama yapmamız gerekecek. atasının atası bu zincir ne kdr var, ne kadar instamce var değer atamak için bunları bilmediğimizden her cınstructor atasına referans verirse zincirleme her şey atanabilir",
      "cevap5": "hayır olmaz aynı isimli metotlar falan sıkıntı",
      "cevap6": "A B nin subclassı demek oluo, ata oğul ilişkisinin kontrolü",
      "cevap7": "overriding: aynı imza (isim ve değişkrbler) ; overloading: aynı metot ismi ama variablrlrr farklı yani aslında bambaşka bi fonksiyon compiler için bence",
      "cevap8": "hocam derived objesi açmışız hani derivedin consrructorunda super varsa o Base() çalıştırır o da print(); çağırır. o da Base nin kendi printine gider o da \"Base\" çıktısı verir cevap Base bence",
      "cevap9": "bence 10. bence zaten c.getValue direkt parentteki getvalue gider gibi hissettim "
    },
    {
      "id": "6157698",
      "cevap1": "Amacımıza ulaşmak için gerekli olmayan bilgileri atmak ve sadece ilgili olanları bırakmak.",
      "cevap2": "Eğer hourlyemployee employee nin subclassı ise mümkündür.",
      "cevap3": "protected",
      "cevap4": "Subclasslardan hemen üstünde olmayan parent classın değerlerine erişebilmek için",
      "cevap5": "Hayır bu durum olası karışıklıkları engellemek için mümkün değildir ve diamond problem olarak adlandırılır",
      "cevap6": "A B'nin subclasslarından birisi demektir",
      "cevap7": "Overriding aynı sinature'a sahip bir methodun tekrar yazılması ve parent classtaki halinin yerine kullanılmasıdır. Ovrloading aynı isimli bir methodun parametrelerinin değiştirilmesi sonucu genelde aynı işlemi daha fazla ya da az parametreyle yapacak bir methodun oluşturulmasıdır ",
      "cevap8": "Yazdırmaz",
      "cevap9": 30
    },
    {
      "id": "7374887",
      "cevap1": "Abstraction sadece bizim için önemli olan kısımları kullanıp diğer kısımların nasıl çalıştığına bakmadan kullanmak",
      "cevap2": "Mümkün değildir ancak tersi mümkündür",
      "cevap3": "Protected",
      "cevap4": "Üst classının constructorını öncrlikli olarak çalıştırıp düzgün bir şekilde initialze olabilmesi için",
      "cevap5": "Mümkün değildir her bir class tek bir classı extend edebilir",
      "cevap6": "A ve b nin aynı tipte olup olmadığına bakar ve bunu yaparken sub-super class ilişkisinide kontrol eder birbirinin sub super classı olan classlarda true sonucu verir",
      "cevap7": "Overriding super classtan bir methodu ad veya signature ı değiştirmeden sub classta içeriğini değiştirmek .overloading ise aynı classta aynı isim farklı signature ile methotlar yapmaktır.",
      "cevap8": "Base",
      "cevap9": "Parent 30"
    },
    {
      "id": "8059049",
      "cevap1": "Black boxing dir,kodun gerekli kısımlarını tutar gereksiz kısımlarını gizleriz",
      "cevap2": "Hourly Employee için evet(subclass ise )tersi için hayır",
      "cevap3": "no modifier subclass a erişemediğinden no modifier daha yakındır",
      "cevap4": "Üst sınıfın constructorına erişmek ve initialize edebilmek için",
      "cevap5": "Hayır",
      "cevap6": "is A ilişkisidir",
      "cevap7": "Overriding de aynı isim ve signature ile yeni bir metod tanımlarız.Overloading de ise isim aynı ama parametreler farklıdır",
      "cevap8": "Base /n(alt satır) 1",
      "cevap9": "Parent /n 30"
    },
    {
      "id": "3688139",
      "cevap1": "Soyutlama. Kullanıcıya sadece kendisi için gerekli bilgileri verme. Altta ne yapıldığını gizlemek.",
      "cevap2": "Employee returnlu metodu hourlyemployee olarak override etmek mumkundur. Tersi ise mumkun degildir cunku atadan alta override edilir.",
      "cevap3": "protected",
      "cevap4": "Ata classin constructoruna da ulasmamiz icin.",
      "cevap5": "Hayır. Bir atadan birden fazla subclass cikabilir ama her subclass bir ataya baglidir",
      "cevap6": "A ve B arasında kalitim iliskisi vardir.",
      "cevap7": "Metot overriding subclassların ata classlardan gelen aynı imzalı metotları kendi returnu ile kullanması. Metot overloading aynı isimli metotlara farklı parametre verilmesiyle farklı imzalı metotlar olmasıdir.",
      "cevap8": 1,
      "cevap9": 30
    },
    {
      "id": "9905145",
      "cevap1": "bize gerektigi kadariyla görmek geri kalanini önemsememek (blackbox)",
      "cevap2": "evet mumkundur employee, hourlyemp in ata classidir o yuzden hourlyemp de bir employedir ancak tam tersi mumkun degil",
      "cevap3": "no modifier daha yakindir(default) çünkü package ve classtan erisimi var",
      "cevap4": "ata class daki verileri kullanmak icin super olmasi gerekiyor ve her class en sonunda objecte baglandigi icin super olmasi gerek",
      "cevap5": "edemez çünkü b ve c nin ortak ozellikleri var ise b c yi extend ederdi veya c b yi ederdi",
      "cevap6": "a ve b nin birbirinin alt classi olup olmadigini kontrol eder",
      "cevap7": "metot overriding ayni ismi ve parametreleri kullanan 2 metotu kasteder, overloading ise ayni ismi kullanan ancak farkli parametreleri olan metotlari kasteder",
      "cevap8": "Base1",
      "cevap9": "Parent30"
    },
    {
      "id": "3963286",
      "cevap1": "Projelerimizde,sadece kullanıcıya ihtiyacı oldugu kadarıyla sisteme erisim vermektir.",
      "cevap2": "Mümkündür,sadece super classın metodu cocugunuda override edildiginde return type değisebilir.tersi mümkün değildir",
      "cevap3": "No modifier",
      "cevap4": "...",
      "cevap5": "Mümkün değildir,sadece bir class ,baska bir classı extend edebilir",
      "cevap6": "Seçilen atadan itibaren classların aynı olup olmadıgını kontrol eder,yani A dan itibaren Bnin A nın subclassı olup olmadigini kontrol eder.",
      "cevap7": "Overloading:metodların signaturelerı farklı,yaptıkları farklı.Overridingde tek farkı metodun üste extra işlevler yüklenmesidir.",
      "cevap8": "Base1",
      "cevap9": "Parent30"
    },
    {
      "id": "1280995",
      "cevap1": "Yazacağımız kod için gerekli olan kavramları, kontekste bağlı değişen kavramlardan ayrıştırmak.",
      "cevap2": "Mümkündür, eğer HourlyEmployee bunun alt sınıfı ise. Tersi mümkün değil. ",
      "cevap3": "No modifier daha yakın. ",
      "cevap4": "Çünkü hepsi constructor ile bir instance üretmek için Object sınıfına refer ediyor. Biz yazmazsak da JVM otomatik hallediyor. ",
      "cevap5": "Hayır. Her class sadece bir class'ı extend edebilir. ",
      "cevap6": "instanceof operatörü soldaki ifadenin sağdakinin bir instance'ı (aynı sınıf ve objesi, veya alt sınıflardan biri veya onlardan birinin objesi) mı diye bakar. A B'den derive edilen herhangi bir şey olabilir. ",
      "cevap7": "Overriding var olan başka bir metod ile aynı signature ile bir metod yazmaktır, böylece metod alt sınıflarda farklı davranabilir (polymorphism). Overloading ise aynı isimde ancak imzaları farklı olan birden fazla metod yazılmasıdır. ",
      "cevap8": "Base",
      "cevap9": 30
    },
    {
      "id": "2384475",
      "cevap1": "İhtiyacımız olan şeylerin dışındakileri yok saymaktır.",
      "cevap2": "Mümkündür cünkü HourlyE is a E ama tam tersi degil cunku E is not a HourlyE.",
      "cevap3": "Package access daha yakındır.",
      "cevap4": "Üst classların instance variablelarını parametre olarak gecirmek icin.",
      "cevap5": "Hayır,mümkün değil.",
      "cevap6": "Verilen objenin bizim istedigimiz türden bir obje olup olmadigini kontrol eder. B objesi A objesiyle ayni class a aittir.",
      "cevap7": "Overriding signature ı aynı olan metotlar icin kullanılır. Overlode ismi aynı ama parametreleri farkli metotlar icin kullanilir.",
      "cevap8": 10,
      "cevap9": 30
    },
    {
      "id": "4275079",
      "cevap1": "ihtiyac duyulmayan methodların soyutlanarak kullanici tarafindan gorulmesini engeller.",
      "cevap2": "Mümkündür ama tersi mümkün değildir.",
      "cevap3": "Default daha yakindir. ",
      "cevap4": "Java da bir class sadece bir üst classına erisebildigi icin 2 üst class erismek recursive bir durum alır bunun uygulanabilmesi icin de her classin ilk satiri super olmalidir",
      "cevap5": "hayir.",
      "cevap6": "A, B nin  upper classidir.",
      "cevap7": "Overriding ayni signatura sahip metotlarin farkli classlar icin farkli gorevler icin kullanilmasidir ancak overloading ayni classta farkli parametreler alarak farkli gorevlerde kullanilmasi icindir",
      "cevap8": "Output yok.",
      "cevap9": 10
    },
    {
      "id": "6914659",
      "cevap1": "Soyutlama anlamina gelir. Java dilinde classlar objeler encapsulation ve polymorphism abstarction kavramina örnektir.",
      "cevap2": "Evet mumkundur. Çünkü hourlyemployee employee sınırının alt classıdır. Fakat tersi mümkün değildir. Çünkü her hourlyemployee bir employee'dir, fakat her employee hourlyemployee değildir.",
      "cevap3": "Default daha yakindir, çünkü protected ile alt sinif oldugu surece farkli paketlerden erisim saglanir ama default'tan saglanmaz.",
      "cevap4": "Alt sinif oldugu icin. Ust sinifin ozelliklerini de icermesi gerektiğinden daima alt sinifin constructorının ilk satirinda ust sinifi temsil eden super satırı olmak zorundadır.",
      "cevap5": "Edemez. Bir class her zaman yalnizca tek 1 class'ı extend edebilir.",
      "cevap6": "A objesi B classının bir objeyi mi diye bakar.",
      "cevap7": "Overriding: ust sinifta tanımlanmış bir metodun alt sınıflarda yeniden tanimlanmasidir, metodun imzasi ve return type'ı degismez. Ust sinifta metod tanimlanirken final keywordü kullanilirsa o metod override edilemez. Overloading: bir metodun ayni isimle ama farkli parametrelerle yeniden tanimlanmasidir, parametreler degisecegi icin imza degisebilir fakar return type degisemez.",
      "cevap8": "Base1",
      "cevap9": "Hata verir. Çünkü görünürlüğü azaltamayız. Fakat burada ust sınıfta x değişkeni protected olarak tanimlanirken alt sinifta private olarak tanımlayarak bu hatayı yapmış "
    },
    {
      "id": "5902250",
      "cevap1": "Hide states, reveal behaviour. Gerekli olan bilgileri paylaşırken diğer bilgileri saklamak.",
      "cevap2": "Mümkündür fakat tersi mümkün değildir.",
      "cevap3": "Default, no modifier",
      "cevap4": "Nasıl her aslan bir hayvansa, her child class kendi super classına üyedir. Super class nesnesi oluşturmak zorundadır.",
      "cevap5": "Hayır",
      "cevap6": "A, B classı veya B’den türetilmiş bir class demektir.",
      "cevap7": "Override, metodun yaptığı işi, ismini, return type’ını, signature’ını tamamiyle yeni yazacağımız kodla değiştirmek demek. Overload ise, metodun sadece signature’ını değiştirebildiğimiz ve içine yeni kod yazabildiğimiz bir yöntem.",
      "cevap8": "Base",
      "cevap9": "Parent 1020"
    },
    {
      "id": "6429016",
      "cevap1": "Soyutluk veriye nesneye erişilmesi için gereklilikleri azaltma işi ",
      "cevap2": "Mümkündür çünkü horuly employee employeenin alt kumesidir. Tersi mümkün değildir kümedeb çıkamayız. ",
      "cevap3": "No modifier daha yakındır. ",
      "cevap4": "Çünkü atasının constructorunu taşımalı ve nesiller arası bir zincir olusturmalidir. Bu bir kuraldır. ",
      "cevap5": "Hayır java'da tek ata olabilir. Ancak bunu sağlamak için b extends c, a extends B yaparsak a ikisinin de override edilmeyen özelliklerini taşır.",
      "cevap6": "A Byi extend ediyor mu. B A'nın atası ya da A'nın kendisi mıdır. A objesi b classın in objesinin bir örneği mıdır? ",
      "cevap7": "Metot overriding bir subclassın üst classın aynı adda metodunu ezmesidir. Subclassın metodu calisir. Method overloading farklı parametrelere sahip aynı isimli farklı metodlar taninlamaktır. Aynı method ismi ile farklı parametrelere işlem yapmaya metodun daha esnek olmasına olanak tanır. ",
      "cevap8": 1,
      "cevap9": "Parent 30"
    },
    {
      "id": "8857652",
      "cevap1": "Ne yaptığımız sorusuna yanıt buluruz, nasıl yaptığımızla ilgilenmeyiz. Örneğin bir arabada gaza basınca arabanın ileri hareket etmesi ama bunun arkasındaki mekanizmayla ilgilenmeyiz.",
      "cevap2": "Evet mümkündür. Covariant return type olmuş olur çünkü HourlyEmployee de aynı zamanda bir Employee'dir( is a relation). Tam olarak bundan dolayı bunun tersi mümkün olmayacaktır çünkü hourly employee daha restricteddir.",
      "cevap3": "Private > default > protected > public (en restrictedden en aza) en yakin olan bir sonrakidir yani mantiken",
      "cevap4": "Genel özellikleri sistemli ve en hatasız şekilde inherit edebilmek için",
      "cevap5": "Hayır sadece 1 tane için mümkündür. Bir çocuğun 2 annesi olamaması ile bağdaşım yapılabilir.",
      "cevap6": "A classı Bnin child classıdır. Bunun sayesinde pek çok işlemin hatasıx yapilmasi saglanabilir. ",
      "cevap7": "Overload metodun signatureünün farklı olması olayı (isim ya da parametre) bu durumda gelen veriye (compatibility) göre o işleve özel metoda implement saglanir. Override ise birbiriyle iliskili (child parent) sınıflardaki metodların işleviyle alakalıdır örnegın animal classındaki ses çıkar metodu dog  classında overeide edilerek spesifik olarak objenin havlayarak ses çıkarmasını sağlayacaktır",
      "cevap8": 1,
      "cevap9": "Parent /n  10 30"
    },
    {
      "id": "6539697",
      "cevap1": "gerekli verileri kullanıp önemli olmayanları göz ardı etmek",
      "cevap2": "mümkündür ancak tersi mümkün değildir çünkü her hourlyemployee aynı zamanda bir employee'dir ancak her employee bir hourlyemployee değildir.",
      "cevap3": "no modifier",
      "cevap4": "her class parent classının özelliklerini taşımak durumundadır",
      "cevap5": "mümkün değildir",
      "cevap6": "a'nın b'nin subclassı olup olmadığını kontrol eder, eğer true dönüyor ise a classı b'nin bir subclassıdır",
      "cevap7": "override= parent classtaki bir metot ile aynı signature'a sahip ancak farklı işlemler yapacak bir metot yazmak, overloading=parent class'taki bir metot ile aynı isme sahip fakat farklı parametreleri alan bir metot yazmak",
      "cevap8": 1,
      "cevap9": "Parent 30 "
    },
    {
      "id": "2179244",
      "cevap1": "Gereksiz değerlerin çıkarılmasıyla kullanıcıya yalın bir kod sunmaktır.",
      "cevap2": "Mümkündür",
      "cevap3": "No modifier",
      "cevap4": "Java kendisi Object sınıfı oluşturur ve kendisi super oluşturur. Bir üst sınıfın class ın çağrılması için",
      "cevap5": "Mümkün değildir",
      "cevap6": "A nesnesinin B türünden olması ",
      "cevap7": "Overloading: aynı class içerisinde metodun farklı parametre isimleri veya sayılarıyla çağrılması demektir. Overriding ise inheritance gerektirir ve bir üst classtaki metodun subclassta çağrılmasıdır.",
      "cevap8": ".",
      "cevap9": "."
    },
    {
      "id": "9245287",
      "cevap1": "Kullaniciya sadece ise yarar kadar bilgi veriyoruz. Kullanicinin isine yaramayan arka planda bilgisayar tarafindan calistirilan bazi kodlar soyutlanir",
      "cevap2": "Mumkundur cunku hourlyemployee bir employeedir ama tersi mumkun degil",
      "cevap3": "No modifier(default) private daha yakindir",
      "cevap4": "Cunku classin metodlarin ve degiskenlerin duzgun calisabilmesi icin oncelikle parent classtaki degiskenler initialize edilmelidir. Aksi halde parent classindan inherit ettigi bir degiskeni duzgun kullanamaz",
      "cevap5": "Mumkun degil. Her classin bir tane parenti vardir ancak bir parentin birden fazla cocugu(child) olabilir",
      "cevap6": "A, B objenin turu veya subclassi mi diye bakar. Yani kalitim agacinda a, b ye esit veya asagi bir classta mi. Ornegin Animal mammal dog diye olsa Dog instance of animal true doner.",
      "cevap7": "Overriding: parentindan aldigi bir metodu ayni signatureda kalmak sartiyla yeniden yazilmasidir, polymorphisim ile iliskilidir. Overload: ayni metod ismini parametrelerini degistirerek tekrar yazmaktir ornegin num(int a) ve num(int a, int b) bir overloadingtir",
      "cevap8": "Base",
      "cevap9": 30
    },
    {
      "id": "4810237",
      "cevap1": "Abstraction kavramı Java gibi nesne tabanlı olan dillerde kullanıcılara ihtiyaçları olan kadar bilgi vermeyi sağlar. Kullanıcılar sadece onlarla alakalı olan bilgilere erişebilir ve bu da karmaşıklığı önler. Black box bunun en önemli örneklerinden biridir.",
      "cevap2": "Bilmiyorum",
      "cevap3": "Package access private modifierına daha yakındır. Erişimin en az sıralandığından en çok sıralandığına göre sıra public protected package ve private şeklindedir.",
      "cevap4": "Çünkü classın constructor'unun classın ",
      "cevap5": "Bilmiyorum",
      "cevap6": "A B'nin bir örneğiyse B bir nesnedir(object) ve A da B nesnesinin bir örneğidir.",
      "cevap7": "Method overloading parametreleri farklı olan metodların isimleri aynı olarak yazılabilmesidir. Bu da signature'ları farklı isimleri aynı olan metotların tanımlanmasını sağlar. Metot overriding ise signature'ları aynı olan metotların isimleri farklı olarak tanımlanabilmesidir. ",
      "cevap8": "Bilmiyorum ",
      "cevap9": "Bilmiyorum"
    }
  ]
}