id,NaN_count,answers
4380745,1,"4380745 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q3{ public static void main(string[] args){ sayac sayac = new sayac(""100101111101010""); sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s2.say()); system.out.println(sayac.say()); } } public class lab1q2{ public static void main(string[] args){ int[] arr1 = {1,8,9,12,7,3,45,10}; int[] arr2 = {5,4,1,2}; cocktailsort(arr2); for(int i = 0; i < arr2.length; i++){ system.out.println(arr2[i]); } } public static void cocktailsort(int[] arr){ cocktailsort(arr, 0, arr.length-1); } public static void cocktailsort(int[] arr, int i, int j){ boolean fsflag = forwardsort(arr, i, j, false); if(!fsflag){ return; } boolean bsflag = backsort(arr, i, j, false); if(!bsflag){ return; } cocktailsort(arr, i+1, j-1); } public static void swap(int[] arr, int i, int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return; } public static boolean forwardsort(int[] arr, int i, int j, boolean flag){ if(i == j){ return flag; } if(arr[i] >= arr[i+1]){ swap(arr, i, i+1); flag = true; } return forwardsort(arr, i+1, j, flag); } public static boolean backsort(int[] arr, int i, int j, boolean flag){ if(j == i){ return flag; } if(arr[j - 1] >= arr[j]){ swap(arr, j, j-1); flag = true; } return backsort(arr, i, j-1, flag); } } public class sayac{ public string input; public sayac(string input){ this.input = input; } public int say(){ return sayrecursive(0); } public int sayrecursive(int index){ if(index >= input.length()){ return 0; } if(input.charat(index) == '1'){ return 1 + sayrecursive(index + 1); } else{ return sayrecursive(index + 1); } } } public class lab1q1{ public static void main(string[] args){ system.out.println(collatz(2)); } public static int collatz(int i){ if(i == 1){ return 0; } else if(i%2 == 0){ return 1 + collatz(i/2); } else{ return 1 + collatz(3*i + 1); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arraylist; import java.util.arrays; import java.util.list; import java.util.random;; public class bil211l2 { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki == null){ continue; } if(sarki instanceof metalsarki){ ((metalsarki)sarki).gostermetalozellikler(); } } } } abstract class sarki { protected string isim; protected string sanatci; abstract void oynat(); } interface calmastratejisi{ abstract void cal(list<sarki> sarkilistesi); } class metalsarki extends sarki{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik){ this.isim = new string(isim); this.sanatci = new string(sanatci); this.metalozellik = new string(metalozellik); } @override public void oynat(){ system.out.println(sanatci + "" - "" + isim + "" ("" + metalozellik +"")""); } public void gostermetalozellikler(){ system.out.println(sanatci + "" - "" + isim + "" [ozellik: "" + metalozellik +""]""); } } class rocksarki extends sarki{ public rocksarki(string isim, string sanatci){ this.isim = new string(isim); this.sanatci = new string(sanatci); } @override public void oynat(){ system.out.println(sanatci + "" - "" + isim + "" ("" + ""huzurlu ve nostaljik"" +"")""); } } class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci){ this.isim = new string(isim); this.sanatci = new string(sanatci); } @override public void oynat(){ system.out.println(sanatci + "" - "" + isim + "" ("" + ""hafif ve sakin"" +"")""); } } class siralicalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { string etiket; for(sarki sarki: sarkilistesi){ if(sarki == null){ continue; } if(sarki instanceof metalsarki){ etiket = ""[metal]""; } else if(sarki instanceof rocksarki){ etiket = ""[rock]""; } else{ etiket = ""[klasik]""; } system.out.print(etiket + "" ""); sarki.oynat(); } } } class karisikcalma implements calmastratejisi{ random random = new random(666); @override public void cal(list<sarki> sarkilistesi) { string etiket; list<sarki> sarkilistesi_ = new arraylist<>(); for(sarki sarki: sarkilistesi){ if(sarki == null){ continue; } sarkilistesi_.add(sarki); } while(sarkilistesi_.size() > 0){ int index = random.nextint(sarkilistesi_.size()); if(sarkilistesi_.get(index) == null){ sarkilistesi_.remove(index); continue; } if(sarkilistesi_.get(index) instanceof metalsarki){ etiket = ""[metal]""; } else if(sarkilistesi_.get(index) instanceof rocksarki){ etiket = ""[rock]""; } else{ etiket = ""[klasik]""; } system.out.print(etiket + "" ""); sarkilistesi_.get(index).oynat(); sarkilistesi_.remove(index); } } } class rockcuozelcalma implements calmastratejisi{ random random = new random(666); @override public void cal(list<sarki> sarkilistesi) { string etiket; string mode = ""metal""; for(sarki sarki: sarkilistesi){ if(sarki == null){ continue; } if(sarki instanceof metalsarki){ etiket = ""[metal]""; if(mode.equals(""rock"")){ system.out.println(""[bilgi] ses duzeyi: normal""); } mode = ""metal""; } else if(sarki instanceof rocksarki){ etiket = ""[rock]""; //degisti = mode.equals(""normal"") ? false : true; if(!mode.equals(""rock"")){ system.out.println(""[bilgi] ses duzeyi: yuksek""); } mode = ""rock""; } else{ etiket = ""[klasik]""; //degisti = mode.equals(""normal"") ? false : true; if(mode.equals(""rock"")){ system.out.println(""[bilgi] ses duzeyi: normal""); } mode = ""klasik""; } system.out.print(etiket + "" ""); sarki.oynat(); } } } class muzikcalar{ calmastratejisi strateji; public void setstrateji(calmastratejisi s){ strateji = s; } public void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. matematikteki induction’ın proglama dünyasındaki hali recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. recursion’dan çıkış koşuludur. olmazsa sonsuz recursion’a girilir bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? index’i 0 olqcak şekilde ve başlatmayı string uzunluğunun bir eksiğinden itibaren olacak şekilde stringi gezen bir recursive metot yazılır recursive bir metotta base case olmazsa ne olur? sonsuz döngüye girer recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. stackde önceki bulununan durumun üstüne doğru yeni parametrelerle yeni durum yazılır ve hali hazırda üzerinde bulunulan fonksiyonlar bittikçe eki değerlere dönülerek veriler işlenerek önceki metotda döndürülmüş olur fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. çünkü aynı değerler tekrar ve tekrar hesaplanır tail recursion nedir, kısaca açıklayınız. ? abstraction kavramını açıklayınız. soyutlama, kodun birbirleriyle etkileşime girmesi gereken kısımları birbirinden ayırarak aralarındaki etkileşimi daha iyi yönetmemizi sağlayan kavram ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? extend yapılarak kalıtım ile oluşan ilişki türi bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? default ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? a veya c olabilir java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? evet çünkü hiçbir kalıtım yapılmamış sınıfları java object classı ile extend eder. zaten inheritance yapılmışlar için super çağrılır java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? mümkün değildir metot overriding ve overloading kavramlarını açıklayınız. overriding inheritance yapıldığında kalıtım ile gelen sınıfın metot signature’ı korunurken içeriğinin değiştirilmesidir. overloading aynı isme sahip fonksiyonların farklı signature a sahip olması sağlanarak o fonksiyonun gerekli olan çeşitli versiyonlarının yaratılmasıdır class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dog bark! class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? circle 8.0 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? hangi metodun hangi versiyonunun kullanılacağının belirlenmesidir. i̇ki tipi bardır: statik ve dinamik hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? overload edilen metotlarda statik, override edilenlerde dinamik binding kullanılır dinamik bağlamada jvm'nin görevi nedir? runtime esnasında metodun hangi versiyonunun kullanılacağına karar vermek java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? başlangıçta metotları yükleme aşaması olmaz ve bir statik metoda ihtiyaç duyulduğu zaman kullanılamazdı java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? ? java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. edilemez çünkü kalıtımda üstteki class’ın hakları kadar alt class’lara kadar aktarılabilir class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? bark meow dinamik class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? parent p = new child() kısmında parent olduğunu söylüyoruz javaya p’nin ama parent’da olmayan bir metot çağrılıyor mnce child’a cast edilmeli dinamik binding child display child special java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? i̇mplementasyon aşamasında eksik olan sınıftır abstract metotlar tanımlayabilir abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? edilemez abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. temel sağlanması gereken bir şablon sunar, bu da bize abstract metotları, implemente edilmeye zorunlu bırakılan class ve metotlar abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract class’lar concrete metotlar içerebilir marker interface ve functional interface kavramları nedir, nasıl kullanılır? bir şeyin bir şey yapıp yapamayacağını belirten interfsce’ler vardır runnable gibi bir de belirli görevlerin nasıl gerçekleştirileceğinin ayarlanması gereken interface’ler olur bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? bir class birden çok interface’i implemente edebilir. bir interface diğer interface’leri extend eder. abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? a içindeki sound metodu implemente edilmemiş versiyonudur onun yerine dog nesnesi oluşturulup dog referanxı tutan bir variable’a verilmelidir output: buddy woof interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? i̇nterface içinde concrete metot oluşturulmuş swimmiable abstract class yapılıp flyable implemente edilmelidir output: swimming java'da inner class nedir, avantajları nelerdir? sınıf içindeki sınıflardır. bazı sistem tasarım mimarilerinde kullanılır. statik ve statik olmayan (member) inner class arasındaki temel fark nedir? statik olanlar ana class olmadan da yaşayabilirler diğerlerinin yaşamı dışarıdaki class’a bağlıdır anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? bir sınıf üzerinden yeni bir class yartmadan doğrudan kullanacağımız şekilde hangi class üzerinden yaratacaksak köşeli parantezler açılarak tanımlanır. concrete class inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? erişebiliyor, bu sayede o ana nesneyi oluşturan builder tipi inner class’lar yaratılıp constructor tasarım aşamasındaki karmaşanın önüne geçilebilir statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? tanımlanabilir, nesnenin yaratılmasına ihtiyaç duymaz statik tanımlamalar anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? olabilir bu sayede anlık constructor override esilecekse yeni bir metot yazmadan anında anonim classlar ile kullanılabilir hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? static inner class’lar class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? outer.inner diye bir erişim olmaz doğrudan inner diye çağırması gerekir value: 10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? derlenir, count: 5 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.arraylist; public class bil211q1q2 { public static void main(string[] args) { penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(""antarctica"", -15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); p1.hunt(); habitat.printhabitat(); } } class penguin{ private string name; private string species; private int age; private double weight; public penguin(){ this(""willy"", ""emperor"", 1, 5.0); } public penguin(string name, string species, int age, double weight){ this.name = new string(name); this.species = new string(species); this.age = age; this.weight = weight; } public string getname(){ return new string(name); } public void setname(string name){ this.name = new string(name); } public string getspecies(){ return new string(species); } public void setspecies(string species){ this.species = new string(species); } public int getage(){ return age; } public void setage(int age){ this.age = age; } public double getweight(){ return weight; } public void setweight(double weight){ this.weight = weight; } public void hunt(){ setweight(getweight() + 1); } public void printpenguin(){ system.out.println(""penguin name: "" + getname() + ""\n"" + ""penguin species: "" + getspecies() + ""\n"" + ""penguin age: "" + getage() + ""\n""+ ""penguin weight: "" + getweight() + ""\n"" + ""----------------------""); } } class habitat{ private string location; private double temperature; private arraylist<penguin> penguins; public habitat(string location, double temperature){ this.location = new string(location); this.temperature = temperature; penguins = new arraylist<penguin>(); } public string getlocation(){ return new string(location); } public void setlocation(string location){ this.location = new string(location); } public double gettemperature(){ return temperature; } public void settemperature(double temperature){ this.temperature = temperature; } public arraylist<penguin> getpenguins(){ return penguins; } public void setpenguins(arraylist<penguin> list){ penguins = list; } public void addpenguin(penguin penguin){ penguins.add(penguin); } public void printhabitat(){ system.out.println(""habitat location: "" + getlocation() + ""\n"" + ""average temperature: "" + gettemperature() + "" c\n"" +""penguins living here:""); for(int i = 0; i < penguins.size(); i++){ penguins.get(i).printpenguin(); } } } import java.util.arraylist; public class bil211q1q1 { static arraylist<string> arr = new arraylist<string>(); public static void main(string[] args) { parantezbas(3); parantezbas(2); } public static void parantezbas(int n){ parantezbas(n, """"); } public static void parantezbas(int n, string output){ if(n <= 0){ boolean flag = false; for(int i = 0; i < arr.size(); i++){ if(output.equals(arr.get(i))){ flag = true; } } if(flag){ return; } system.out.println(output); arr.add(output); return; } parantezbas(n-1,""("" + output + "")""); parantezbas(n-1,""("" + "")"" + output); parantezbas(n-1, output + ""("" + "")""); } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public class latte extends basecoffee{ @override public double calculateprice() { int price = 50; string message = ""sipariş: latte""; for(coffeeaddon addon : addons){ price += addon.getcost(); message += "" + "" + addon.getname(); } system.out.println(message); system.out.println(""toplam fiyat: "" + price + ""tl""); system.out.println(); return price; } @override public string gettype() { return ""latte""; } } public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); anothermachine.displaysumofcoffenumber();// burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } public class espresso extends basecoffee{ private boolean isheated = false; public espresso(){ } @override public double calculateprice() { int price = 40; string message = ""sipariş: espresso""; if(isheated) message += "" (sıcak fincan)""; for(coffeeaddon addon : addons){ price += addon.getcost(); message += "" + "" + addon.getname(); } system.out.println(message); system.out.println(""toplam fiyat: "" + price + ""tl""); system.out.println(); return price; } public void heatcup(){ isheated = true; } @override public string gettype() { return ""espresso""; } } public class vanillasyrup implements coffeeaddon{ @override public double getcost() { return 6; } @override public string getname() { return ""vanilla syrup""; } } public interface coffeeaddon { double getcost(); string getname(); } import java.util.arraylist; public abstract class basecoffee { protected arraylist<coffeeaddon> addons; public basecoffee(){ addons = new arraylist<coffeeaddon>(); } public void addaddon(coffeeaddon addon){ addons.add(addon); } public abstract double calculateprice(); public abstract string gettype(); } public class americano extends basecoffee{ @override public double calculateprice() { int price = 45; string message = ""sipariş: americano""; for(coffeeaddon addon : addons){ price += addon.getcost(); message += "" + "" + addon.getname(); } system.out.println(message); system.out.println(""toplam fiyat: "" + price + ""tl""); system.out.println(); return price; } @override public string gettype() { return ""americano""; } } public class coffeemachine { static int sumofcoffenumber = 0; public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon){ if(coffee instanceof espresso && (adddon instanceof doubleshot || adddon instanceof chocolate)){ coffee.addaddon(adddon); } else if(coffee instanceof latte && (adddon instanceof milk || adddon instanceof vanillasyrup || adddon instanceof chocolate)){ coffee.addaddon(adddon); } else if(coffee instanceof americano && (adddon instanceof milk || adddon instanceof vanillasyrup)){ coffee.addaddon(adddon); } else{ system.out.println(""[uyari] "" + coffee.gettype() + "" tipi kahveye "" + adddon.getname() + "" eklenemez""); } } public void makecoffee(basecoffee coffee){ coffee.calculateprice(); sumofcoffenumber++; } public void heatespressocup(basecoffee coffee){ if(coffee instanceof espresso){ ((espresso)coffee).heatcup(); system.out.println(""espresso kahve fincanı ısıtıldı""); } else{ system.out.println(""[uyari] yalnızca espresso kahve fincanları ısıtılabilir""); } } public void displaysumofcoffenumber(){ system.out.println(""tum kahve makineleri tarafindan toplam "" + sumofcoffenumber + "" kahve uretildi""); } } public class milk implements coffeeaddon{ @override public double getcost() { return 5; } @override public string getname() { return ""milk""; } } public class doubleshot implements coffeeaddon{ @override public double getcost() { return 10; } @override public string getname() { return ""double shot""; } } public class chocolate implements coffeeaddon{ @override public double getcost() { return 7; } @override public string getname() { return ""chocolate""; } } 1"
8190737,1,"8190737 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. import java.util.*; public class lab21q1 { public static int collatz(int i){ if(i == 1) return 0; if(i % 2 == 0) return 1 + collatz(i / 2); return 1 + collatz(3 * i + 1); } public static void main(string[] args) { scanner sc = new scanner(system.in); int i = sc.nextint(); system.out.println(collatz(i)); sc.close(); } } import java.util.*; public class lab21q2 { static boolean issorted(int[] arr){ int n = arr.length; for(int i = 1;i < n;i++){ if(arr[i-1] > arr[i]) return false; } return true; } static int[] coctailsort(int[] arr, boolean bubblebiggest){ if(issorted(arr)) return arr; int n = arr.length; for(int i = 1;i < n;i++){ if(bubblebiggest){ if(arr[i-1] > arr[i]){ int a1 = arr[i-1]; int a2 = arr[i]; arr[i-1] = a2; arr[i] = a1; } } else{ if(arr[i-1] < arr[i]){ int a1 = arr[i-1]; int a2 = arr[i]; arr[i-1] = a2; arr[i] = a1; } } } int[] rev = new int[n]; for(int i = 0;i < n;i++) rev[i] = arr[(n-1) - i]; return coctailsort(rev, !bubblebiggest); } public static void main(string[] args) { scanner sc = new scanner(system.in); int n = sc.nextint(); int[] arr = new int[n]; for(int i = 0;i < n;i++) arr[i] = sc.nextint(); arr = coctailsort(arr, true); for(int i = 0;i < n;i++) system.out.print("""" + arr[i] + "" ""); system.out.print(""\n""); sc.close(); } } import java.util.*; class sayac{ string str; sayac(string str){ this.str = str; } public int say(int idx){ if(idx == str.length()) return 0; if(str.charat(idx) == '1') return 1 + say(idx + 1); else return say(idx + 1); } public int say(){ return say(0); } } public class lab21q3 { public static void main(string[] args) { scanner sc = new scanner(system.in); string str1 = sc.next(); sayac say1 = new sayac(str1); system.out.println(say1.say()); string str2 = sc.next(); sayac say2 = new sayac(str2); system.out.println(say2.say()); sc.close(); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.*; public class musicplayer{ playingstrategy strategy; void setstrategy(playingstrategy strategy){ this.strategy = strategy; } void play(list<song> playlist){ strategy.play(playlist); } } import java.util.*; public class main { public static void main(string[] args) { scanner sc = new scanner(system.in); song s1 = new metal(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); song s2 = new metal(""voice of the soul"", ""death"", ""enstrumantal""); song s3 = new rock(""small mountain"", ""midlake""); song s4 = new rock(""ankara"", ""vega""); song s5 = new classic(""una mattina"", ""ludovico einaudi""); // songlari iceren calma listesi list<song> playlist = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi musicplayer musicplayer = new musicplayer(); // sirali calma stratejisi system.out.println(""sirali calma:""); musicplayer.setstrategy(new ordered()); musicplayer.play(playlist); // karisik calma stratejisi system.out.println(""karisik calma:""); musicplayer.setstrategy(new shuffled()); musicplayer.play(playlist); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); musicplayer.setstrategy(new rockspecial()); musicplayer.play(playlist); system.out.println(""metal ozellikleri:""); for (song song:playlist){ if(song instanceof metal){ metal metal = (metal)song; system.out.println(metal.singer + "" - "" + metal.name + "" [ozellik: "" + metal.metalproperties + ""]""); } } sc.close(); } } abstract class song{ string name; string singer; abstract void play(); } class metal extends song{ string name; string singer; string metalproperties; metal(string name, string singer, string metalproperties){ this.name = name; this.singer = singer; this.metalproperties = metalproperties; } void play(){ system.out.println(""[metal] "" + singer + "" - "" + name + "" ("" + metalproperties + "")""); } void showmetalproperties(){ system.out.println(metalproperties); } } class rock extends song{ string name; string singer; rock(string name, string singer){ this.name = name; this.singer = singer; } void play(){ system.out.println(""[rock] "" + singer + "" - "" + name + "" (huzurlu ve nostaljik)""); } } class classic extends song{ string name; string singer; classic(string name, string singer){ this.name = name; this.singer = singer; } void play(){ system.out.println(""[klasik] "" + singer + "" - "" + name + "" (hafif ve sakin)""); } } import java.util.*; interface playingstrategy{ public void play(list<song> playlist); } class ordered implements playingstrategy{ public void play(list<song> playlist){ for(song song:playlist){ song.play(); } system.out.println(""\n""); } } class shuffled implements playingstrategy{ public void play(list<song> playlist){ int length = playlist.size(); for(int i = length-1;i >= 0;i--){ int idx = (int)math.round(math.random() * i); song tempsong1 = playlist.get(idx); song tempsong2 = playlist.get(i); playlist.set(idx, tempsong2); playlist.set(i , tempsong1); } for(song song:playlist){ song.play(); } system.out.println(""\n""); } } class rockspecial implements playingstrategy{ public void play(list<song> playlist){ boolean playingrock = false; for(song song:playlist){ if(song instanceof rock && !playingrock){ system.out.println(""[bilgi] ses duzeyi: yuksek""); playingrock = true; } else if(!(song instanceof rock) && playingrock){ system.out.println(""[bilgi] ses duzeyi: normal""); playingrock = false; } song.play(); } system.out.println(""\n""); } } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. özyinelemedir. bir fonksiyon kendisini çağırıyorsa recursive olur recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. recursion'un bitirildiği case'dir. base case'e girince fonksiyon bir kez daha kendisini çağırmaz bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? sondaki harf + f(str.substring(0, uzunluk-1)). base case, stringing 0 uzunluğunda olduğu case olur recursive bir metotta base case olmazsa ne olur? sonsuza kadar kendini çağırmaya devam eder, stackoverflow olur recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. her bir çağırma, stack'e bir katman daha ekler. recursion bittiğinde ise katmanlar birer birer işlenir fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. n'inci fibonacci sayısı için 2^n kez fonksiyon çağırılır tail recursion nedir, kısaca açıklayınız. fonksiyonun en sonunda return ifadesi ile beraber recursionun çağırılmasıdır abstraction kavramını açıklayınız. bir nesnenin özelliklerini çıkartarak değişkenlerden ve metotlardan oluşan bir class/blueprint yaratmaktır ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? inheritance ilişkisi olduğunda ""is a"" olur. ""class a extends b"" ifadesiyle belirtilir bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? protected ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? a veya b java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? o class initialize edilmeden önce tüm ata class değişkenlerinin ve metotlarının setlenmesi gerekmektedir java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? hayır metot overriding ve overloading kavramlarını açıklayınız. override, ata classta tanımlı bir metot ile aynı signature'e sahip bir metodu child classta tanımlamaktır. overload ise aynı isme sahip ama farklı signature'u bulunan metotlar tanımlamaktır class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dog \n bark! class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? circle \n 8.0 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? kullanılacak metodun hangi tanıma göre kullanılacağını belirlemektir. statik ve dinamik olabilir hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? overriding olmayan veya override edilemeyen metodlarda static, overriding olan metodlarda dinamik binding yapılır. static binding için final keywordu kullanılır dinamik bağlamada jvm'nin görevi nedir? metodun tanımını runtime'da bulmaktır java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? kod daha yavaş çalışırdı java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? compiler error alırız java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. bir canlı yemek yiyebiliyorsa bir köpek de yemek yiyebilmelidir. protected bir metod public olarak override edilebilir class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? p.special() komutu çalışmayacaktır ve compiler error alınacaktır. bu satır silindikten sonra output ""child special"" olacaktır. dinamik binding bulunuyor java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? i̇çinde abstract metodların bulunduğu classlara abstract class denir. ikisinin de constructurları olamaz abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? evet. abstarct keywordu kullanılarak. fonksiyonun tanımı yapılmaz abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract metodları tanımı yapılmaz. concrete hale getirilmek istendiğinde yapılır. abstract classlar, atası olduğu classlara ""şunu şunu implement etmek zorundasın"" der. abstract classları polymorphism için kullanabiliriz abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract classlar bir classtır, extend edilirler. interfaceler class değildir. implement edilirler. evet type olarak kullanılabilir marker interface ve functional interface kavramları nedir, nasıl kullanılır? ( ´_ゝ`) marker interface bi blueprint görevi görür. i̇çindeki metodlar tanımsızdır. functional interface'in içinde tanımı olan metodlar bulunur bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? edebilir. edebilir abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? new animal() yerine new dog() yazarız. output: animal: buddy woof interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? etmez. birden fazla move() tanımı var. i̇kisinden birini silmemiz lazım. sonrasında hangisini sildiysek diğerini outputlar. java'da inner class nedir, avantajları nelerdir? class içindeki class'tır. class içinde tekrar tekrar kullanılan yapıları bir çatı altında toplamaya yarar statik ve statik olmayan (member) inner class arasındaki temel fark nedir? statik inner class objesini, class dışında, class objecti oluşturmadan oluşturabiliyoruz. statik değil ise inner class objesi oluşturmak için outet class objesi oluşturmamız gerekiyor anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? ismi olmayan ve tek bir obje özelinde oluşturulan classlardır. her türlü classtan ve interface'den oluşturulabilir. yeter ki gerekli metodlar tanımlansın inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? evet. evet. daha fazla fonksiyonalite sağlar statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? hayır. çünkü inner class static değil ise inner classın outer classından bir obje oluşturulmadığı sürece inner classın içindeki herhangi bir şey var olmayacağından dolayı static keywordunun bir anlamı kalmıyor anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? olamaz çünkü tek seferliktirler. inner class, outer class içinde başka bir classtır. anonymous class ise bir classın veya interface'in kullanılarsk tek bir seferlik bir obje üretilmesidir. hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? private olmayanlar class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? (new outer()).new inner() olması gerekiyor. output: value: 10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? hata yok gibi. output: count: 5 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.*; public class lab2q1 { public static boolean check(string str){ int cnt = 0; for(int i = 0;i < str.length();i++){ if(str.charat(i) == ')'){ if(cnt == 0) return false; cnt--; } else{ cnt++; } } if(cnt == 0) return true; return false; } public static void parantezbasiterative(int n){ int val = (int)math.pow(2, 2*n); for(int i = 0;i < val;i++){ string str = """"; for(int j = 0;j < 2*n;j++){ if(((int)math.pow(2, j) & i) == 0) str = str + '('; else str = str + ')'; } if(check(str)) system.out.println(str); } } public static void parantezbasrecursive(int n, string str){ if(str.length() == 2*n){ if(check(str)) system.out.println(str); return; } parantezbasrecursive(n, str + '('); parantezbasrecursive(n, str + ')'); } public static void main(string[] args) { scanner sc = new scanner(system.in); int n = sc.nextint(); parantezbasrecursive(n, """"); sc.close(); } } import java.util.*; class penguin{ private string name; private string species; private int age; private double weight; public penguin(){ this(""willy"", ""emperor"", 1, 5.0); } public penguin(string name, string species, int age, double weight){ setname(name); setspecies(species); setage(age); setweight(weight); } public void setname(string name){ this.name = name; } public void setspecies(string species){ this.species = species; } public void setage(int age){ this.age = age; } public void setweight(double weight){ this.weight = weight; } public string getname(){ return name; } public string getspecies(){ return species; } public int getage(){ return age; } public double getweight(){ return weight; } public void hunt(){ age++; } public void printpenguin(){ system.out.println(""penguin name: "" + name + ""\tspecies:"" + species + ""\tage:"" + age + ""years "" + ""\t weight:"" + weight + "" kg""); } } class habitat{ private string location; private double temperature; private arraylist<penguin> penguins; public habitat(string location, double temperature){ setlocation(location); settemperature(temperature); penguins = new arraylist<penguin>(); } public void setlocation(string location){ this.location = location; } public void settemperature(double temperature){ this.temperature = temperature; } public string getlocation(){ return location; } public double gettemperature(){ return temperature; } public void addpenguin(penguin penguin){ penguins.add(penguin); } public void printhabitat(){ system.out.println(""habitat location: "" + location); system.out.println(""average temperature: "" + temperature + ""°c""); system.out.println(""penguins living in here:""); for(penguin penguin:penguins){ penguin.printpenguin(); } } } public class lab2q2 { public static void main(string[] args) { scanner sc = new scanner(system.in); penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); habitat habitat = new habitat(""antarctica"", -15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); sc.close(); } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 import java.util.*; public class main { public static void main(string[] args) { scanner sc = new scanner(system.in); coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); machine.printcoffeecounter(); sc.close(); } } public interface coffeeaddon{ double getcost(); string getname(); } class milk implements coffeeaddon{ final double cost = 5; final string name = ""milk""; public double getcost(){ return cost; } public string getname(){ return name; } } class chocolate implements coffeeaddon{ final double cost = 7; final string name = ""chocolate""; public double getcost(){ return cost; } public string getname(){ return name; } } class vanillasyrup implements coffeeaddon{ final double cost = 6; final string name = ""vanillasyrup""; public double getcost(){ return cost; } public string getname(){ return name; } } class doubleshot implements coffeeaddon{ final double cost = 10; final string name = ""doubleshot""; public double getcost(){ return cost; } public string getname(){ return name; } } import java.util.*; public abstract class basecoffee{ protected arraylist<coffeeaddon> addons; basecoffee(){ addons = new arraylist<coffeeaddon>(); } public void addaddon(coffeeaddon addon){ addons.add(addon); }; public abstract double calculateprice(); public abstract string gettype(); } class espresso extends basecoffee{ private string type = ""espresso""; private boolean isheated = false; public string gettype(){ if(isheated) return type + "" (sicak fincan)""; else return type; } public void heatcup(){ isheated = true; } public double calculateprice(){ double price = 40; for(coffeeaddon addon:addons){ price += addon.getcost(); } return price; } } class latte extends basecoffee{ private string type = ""latte""; public string gettype(){ return type; } public double calculateprice(){ double price = 50; for(coffeeaddon addon:addons){ price += addon.getcost(); } return price; } } class americano extends basecoffee{ private string type = ""americano""; public string gettype(){ return type; } public double calculateprice(){ double price = 45; for(coffeeaddon addon:addons){ price += addon.getcost(); } return price; } } public class coffeemachine{ static int counter = 0; private boolean isaddoncompatible(basecoffee coffee, coffeeaddon addon){ if(coffee instanceof espresso){ return addon.getname().equals(""doubleshot"") || addon.getname().equals(""chocolate""); } if(coffee instanceof latte){ return addon.getname().equals(""milk"") || addon.getname().equals(""vanillasyrup"") || addon.getname().equals(""chocolate""); } if(coffee instanceof americano){ return addon.getname().equals(""milk"") || addon.getname().equals(""vanillasyrup""); } return false; } public void addaddontocoffee(basecoffee coffee, coffeeaddon addon){ if(!isaddoncompatible(coffee, addon)){ system.out.println(""[uyari]"" + coffee.gettype() + "" tipi kahveye "" + addon.getname() + "" eklenemez\n""); return; } coffee.addaddon(addon); } public void makecoffee(basecoffee coffee){ counter = counter + 1; system.out.print(""siparis: "" + coffee.gettype()); for(coffeeaddon addon:coffee.addons){ system.out.print("" + "" + addon.getname()); } system.out.println(""\ntoplam fiyat: "" + coffee.calculateprice() + ""\n""); } public void heatespressocup(basecoffee coffee){ if(coffee instanceof espresso){ ((espresso)coffee).heatcup(); system.out.println(""espresso kahve fincani isitildi \n""); return; } system.out.println(""[uyari] yalnizca espresso kahve fincanlari isitilabilir""); } public void printcoffeecounter(){ system.out.println(""tum kahve makineleri tarafindan toplam "" + counter + "" kahve uretildi""); } } 1"
2051651,3,"2051651 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q3 { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s2.say()); } } class sayac{ string str; sayac(string str){ this.str = str; } public int say(){ return stringcounter(str, 0); } private int stringcounter(string str, int i){ if(i >= str.length()){ return 0; } else if(str.charat(i) == '1'){ return 1 + stringcounter(str, i + 1); } else return stringcounter(str, i + 1); } } public class lab1q2 { public static void main(string[] args) { int[] arr = {3, 1, 7, 5, 6, 0, 4}; cocktailsort(arr); } public static void cocktailsort(int[] arr){ for(int i = 0; i < arr.length; i++){ sortforward(arr, 0); sortbackward(arr, arr.length-1); } for(int i = 0; i < arr.length; i++){ system.out.println(arr[i]); } } public static int[] swap(int i, int j, int[] arr){ int temp = 0; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; } public static int[] sortforward(int[] arr, int i){ if(i >= arr.length-1){ return arr; } else if(arr[i] > arr[i+1]){ swap(i, i+1, arr); return sortforward(arr, i + 1); } else{ return sortforward(arr, i + 1); } } public static int[] sortbackward(int[] arr, int i){ if(i <= 0){ return arr; } else if(arr[i] < arr[i-1]){ swap(i, i+1, arr); return sortforward(arr, i + 1); } else{ return sortforward(arr, i + 1); } } } class lab1q1{ public static void main(string[] args) { system.out.println(collatz(5)); } public static int collatz(int i){ if(i <= 1){ return 0; } else if(i % 2 == 0){ return 1 + collatz(i / 2); } else{ return 1 + collatz(3*i + 1); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar{ calmastratejisi calmastratejisi; void setstrateji(calmastratejisi s){ this.calmastratejisi = s; } void muzikcal(list<sarki> sarkilistesi){ calmastratejisi.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args){ // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki.gettype().equals(""metal"")){ metalsarki m = (metalsarki) sarki; m.gostermetalozellikleri(); } } } } public class klasiksarki extends sarki { klasiksarki(string sanatçi, string isim){ this.isim = isim; this.sanatçi = sanatçi; } @override void oynat() { system.out.println(""[klasi̇k] "" + sanatçi + "" - "" + isim + ""(hafif ve sakin)""); } @override string gettype(){ return ""klasik""; } } public class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik){ this.isim = isim; this.sanatçi = sanatci; this.metalozellik = metalozellik; } @override void oynat() { system.out.println(""[metal] "" + sanatçi + "" - "" + isim + "" "" + metalozellik); } void gostermetalozellikleri(){ system.out.println(sanatçi + "" - "" + isim + "" - metal özelik: "" + metalozellik); } @override string gettype(){ return ""metal""; } } public class rocksarki extends sarki{ rocksarki(string sanatçi, string isim){ this.isim = isim; this.sanatçi = sanatçi; } @override void oynat() { system.out.println(""[rock] "" + sanatçi + "" - "" + isim + ""(huzurlu ve nostaljik)""); } @override string gettype(){ return ""rock""; } } import java.util.list; public class karisikcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(sarkilistesi.size()-i-1).oynat(); } } } import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } public abstract class sarki { string isim; string sanatçi; abstract void oynat(); abstract string gettype(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi{ int volume = 50; public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { if(sarki.gettype().equals(""rock"")){ if(volume < 100) system.out.println("" (volume is increased.)""); volume = 100; } else{ if(volume == 100){ volume = 50; system.out.println("" (volume is decreased.)""); } } sarki.oynat(); } } } import java.util.list; public interface calmastratejisi{ void cal(list<sarki> sarkilistesi); } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. methodun kendi içinde kendisini çağırmasıdır. recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. base case recursive methodun her çağrıldığında kontrol ettigi bir şarttır. i̇stenilen sonuca ulaşıp ulaşılmadıgını kontrol eder ve ulaşılmışsa çıkar bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? method her çağrıldığında artan bir sayaç koyardım, her seferinde stringin son harfini alıp return'e eklerdim. sayaç string uzunluğuna eşit oldugunda çıkardım. recursive bir metotta base case olmazsa ne olur? metod surekli kendini çağırarak belleği doldurur. stack overflow recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. çağırılan metod diğer metotların ust katmanına ksydedilir ve bu şekilde ilerler fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. fibonacci dizisinde sadece son 2 sayıyı kullanırız, recursive metot surekli tamamını tekrar eder tail recursion nedir, kısaca açıklayınız. bilmiyorum java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? ? hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? ? dinamik bağlamada jvm'nin görevi nedir? ? java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? ? java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? ? java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. ? class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? bark, meow. dinamik class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? yanlış yok. dinamik binding. output: child display /n child special java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class olarak kullanılabilen fakat concrete classın aksine tip obje oluşturulamayan ve içinde implement edilmemiş metodlar bulunan bir tur class dır. constructorları olabiliri. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? hayır abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. -i̇mplement edilmemişlerdir -tip olarak kullanılabilir -uzerinden obje oluşturalamaz -altındaki classlarda olmasını istedigimiz ama nasıl yapılacağı serbest bıraktıgımız durumlarda kullanılır. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? i̇nterface metodlarının tamamı abstract'dır, bir class birden fazla interface implement edebilir ama birden fazla abstract class extend edemez. i̇kisi de tip olarak kullanılabilir. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface içinde metod olmayan interface'dir. functional interface içinde tek bir metod olan interfacelerdir bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet, evet. abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? animal abstract class olduğu için uzerinden obje oluşurulamaz. animal a = new dog(""buddy""); olmalıydı. output : animal: buddy, woof. interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? default metod override edilemez. duck classında move metodu olmamalıydı. output: flying. yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. 3 çeşit hata vardır: compile error, örnek: syntax hataları. runtine exception örnek: 0 a bölme. logical error: algoritmada yapılan hatalar exception handlingin amacı nedir? program akışında beklenmedik durumlarla karşılaşıldıgında bunları düzeltmek ya da bunlara özel işlemler yapmak exception handlingde finally bloğunun amacı nedir? ondan önceki bloklardan hangisine girdiginden bağımsız olarak her zaman çalışmasını istedigimiz kod için vardır. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? handle edilmiş exceptionlar checked, handle edilmemiş olanlar unchecked java'da kendi exceptionunuzu nasıl tanımlarsınız? exception classını inherit eden yeni bir class yazarak java'da error ve exception arasındaki fark nedir, açıklayınız error kod yaxarkwn veya kodun mantıgında yapılan bir hatadır. exception program akışında karşılaşılan beklenmeyen durumlardır java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? exceptiona özel işlemleri yapmak ama yine de programı durdurup kullanıcıya bildirmek için 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? bilmiyorum static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenmez. hatanın kaynağı e referansının hem exception hem de arrayindexoutofboundsexception objesi icin kullanılması. duzeltmek için e'lerden birinin ismi değiştirilebilir static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught. finally oops done 41 kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; string type; public abstractrobot(string modelname, int batterylife, string type){ this.modelname = modelname; this.batterylife = batterylife; this.type = type; } public string getmodelname(){ return modelname; } public abstract void performtask(); } public class main { public static void main(string[] args){ robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(); system.out.println(""tüm fabrikalar tarafından toplam "" + robotfactory.totalrobots + "" robot üretildi.""); } } public class securityrobot extends abstractrobot { private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife, ""security robot""); this.isarmed = isarmed; } @override public int getbatterylife() { return batterylife; } @override public void recharge() { batterylife = 100; } @override public void performtask() { if(batterylife >= 10){ system.out.println(modelname + "" scanning for threats... armed "" + isarmed); batterylife -= 10; } else{ system.out.println(modelname + "" not enough battery to scan threats.""); } } public void togglearmedmode(){ if(isarmed == true){ isarmed = false; } else{ isarmed = true; } } public boolean getisarmed(){ return isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower){ super(modelname, batterylife, ""cleaning robot""); this.cleaningpower = cleaningpower; } @override public int getbatterylife() { return batterylife; } @override public void recharge() { batterylife = 100; } @override public void performtask() { if(batterylife >= 10){ system.out.println(modelname + "" cleaning in progress... "" + ""cleaning power: "" + cleaningpower); batterylife -= 10; } else{ system.out.println(modelname + "" not enough battery to clean""); } } public int getcleaningpower(){ return cleaningpower; } public void setcleaningpower(int x){ cleaningpower += x; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); private arraylist<securityrobot> securityrobots = new arraylist<>(); private arraylist<cleaningrobot> cleaningrobots = new arraylist<>(); static int totalrobots; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); cleaningrobots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); totalrobots += 1; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ robots.add(new securityrobot(modelname, batterylife, isarmed)); securityrobots.add(new securityrobot(modelname, batterylife, isarmed)); totalrobots += 1; } public void performalltasks(){ for (abstractrobot abstractrobot : robots) { abstractrobot.performtask(); } } public void displayrobots(){ for (cleaningrobot c : cleaningrobots) { system.out.println(""cleaning robot - model: "" + c.getmodelname() + "", battery: "" + c.getbatterylife() + "", cleaning power: "" + c.getcleaningpower()); } for (securityrobot s : securityrobots) { system.out.println(""security robot - model: "" + s.getmodelname() + "", battery: "" + s.getbatterylife() + "", armed: "" + s.getisarmed()); } } public void upgradecleaningrobots(int miktar){ for (cleaningrobot c : cleaningrobots){ c.setcleaningpower(miktar); system.out.println(""cleaning robot - "" + c.getmodelname() + "" now has cleaning power "" + c.getcleaningpower()); } } public void togglesecurityrobotsmode(){ for (securityrobot s : securityrobots) { s.togglearmedmode(); if(s.getisarmed() == true){ system.out.println(""security robot - "" + s.getmodelname() + "" is now armed.""); } else{ system.out.println(""security robot - "" + s.getmodelname() + "" is now unarmed.""); } } } } 3"
8964453,4,"8964453 müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.*; public class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { strateji =s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } import java.util.*; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki){ metalsarki metal = (metalsarki) sarki; metal.gostermetalozellikleri(); } } } } public class klasiksarki extends sarki{ public klasiksarki(string isim,string sanatci ) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (hafif ve sakin""); } } public class metalsarki extends sarki{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void gostermetalozellikleri() { system.out.println(sanatci + "" - "" + isim + "" [ozellik: "" + metalozellik + ""]""); } void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } } public class rocksarki extends sarki{ public rocksarki(string isim,string sanatci ) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[rock] "" +sanatci + "" - "" + isim + "" (huzurlu ve nostaljik""); } } import java.util.*; public class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { list<sarki> sarkilistcpy = new arraylist<>(sarkilistesi); collections.shuffle(sarkilistcpy); for(sarki x : sarkilistcpy) { x.oynat(); } } } import java.util.*; public class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for(sarki x : sarkilistesi) { x.oynat(); } } } public abstract class sarki{ string isim; string sanatci; void oynat(){} } import java.util.*; public class rockcuozelcalma implements calmastratejisi{ private boolean sesseviyesi = false; //false:normal true:yuksek public void cal(list<sarki> sarkilistesi) { for(sarki x : sarkilistesi) { if(x instanceof rocksarki) { if(sesseviyesi == false) { sesseviyesi = true; system.out.println(""[bilgi] ses duzeyi: yuksek""); } } else { if(sesseviyesi == true) { system.out.println(""[bilgi] ses duzeyi: normal""); sesseviyesi =false; } } x.oynat(); } } } import java.util.*; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. yineleyen methodlardir. recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. base case dongunun duracagi yeri anladigi yerdir. sonsuz donguyu engeller bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? string uzunlugunun 0 veya 1 olmasi recursive bir metotta base case olmazsa ne olur? sonsuz dongu recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. her bir cagri stack frame olusturur, bunlar ust uste yazilmaya devam eder her iterasyonda fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. her bir iterasyonda alt sayilar tekrar tekrar hesaplanir anlamsizdir tail recursion nedir, kısaca açıklayınız. ciktinin tekrar girise girdigi base case e kadar ne olusuyorsa devam eden iterasyon method turudur abstraction kavramını açıklayınız. nesnenin istedigimiz ozelliklerini alip gerekmeyenleri veya gizlenmek istenenleri kullaniciya gostermemek ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? fox is a animal ifadesi dogrudur burdan fox classinin aninal classinin child classi oldugunu soyleyebiliriz bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? protected ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? a veya c java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? her classin parent classi object classidir, duzgun calisabilmesi icin object classinin constructoru da cagirilmalidir java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? hayir interface birden fazla extend edilebilir metot overriding ve overloading kavramlarını açıklayınız. override icin methodun signature i aynidir, ust classdan alt classa override edilebilir, overload ise ayni isimde bir methodu farkli parametrelerle yani farkli signature ile yeniden yazmak class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? animal bark! class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? generic circle 8.0 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? kodun ne zaman derlenecegini anlatir, early binding ile static binding cesitleridir hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? private metodlar, static methodlar, final methodlar early binding classa bagli nesne olusturulmadan calisirlar kalani static calisirlar dinamik bağlamada jvm'nin görevi nedir? polimorfizm kullanilan methodlarda overridelari takip edip istenilen methoda gitmesi. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? performans kaybi ve guven acikligi olusturur ongorulebilirligi azaltir java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? tip kontrolu yapmak icindir, implicit yaparsak class cast exception hatalari cikabilir java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. override edecegemiz methodu daha az gorunur yapamayiz fakat ust sinifa giderken access modifieri genisletilebilinir class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? bark meov dynamic binding gorulmektedir class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? p.special() da hata vardir parent classda bu method yoktur, dynamic binding gorulmektedir yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. 3 tip hata vardir, 1) syntax soz dizimi hatasi 2) logic hatasi mantiksal yaptigimiz hata 3) run time error program compile ettikden sonra cesitli sebeplerle 1/0 gibi sebeplerle ortaya cikar exception handlingin amacı nedir? programin calisma sirasinda cikabilecek hatalari ongorerek crashi engellemek ve olusabilecek hatalari onceden ayarlayarak cozmek. exception handlingde finally bloğunun amacı nedir? exception yakalandiktan sonra try catch icinde ne yapildigindan bagimsiz her turlu calisacak bir methoddur. yani her kosulda calismasini istedigimiz seyleri buraya yazariz. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? checked exceptions compile time sirasinda ortaya cikar ve crash yememek icin direk ele alinmalidir. unchecked exceptions run time sirasinda dizilerde vs ortaya cikar yani girilen inputlara gore cikabilir veya cikmayabilir. bunu da onceden ongorup halledilmelidir. java'da kendi exceptionunuzu nasıl tanımlarsınız? kendi exceptionumuzu sinifini yaratarak ve exception classindan miras alarak exceptionumuzu olustururuz. main metodu icinde veya farkli bir yerde try catch ile yakalariz ve cozeriz. java'da error ve exception arasındaki fark nedir, açıklayınız error jvm ile alakalidir, exception kodun icinde yaptigimiz seylerle alakalidir. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? hata bilgisini alt katmanlarda kaydetmek ve ust katmanlara iletmek, kullanici dostlugunu arttirmak. 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? alt siniftan daha genis bir exception firlatilamaz. static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? kod derlenmez, ozel exception once genel exception sonra kodda yer almalidir. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public class latte extends basecoffee{ public string getname() { return ""latte""; } @override public double calculateprice() { double totalprice = 0; totalprice +=50; for(coffeeaddon x : addons) { totalprice += x.getcost(); } return totalprice; } } public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(""\n""); coffeemachine.totalcoffeemade(); } } import java.util.arraylist; public class espresso extends basecoffee{ private boolean isheated = false; public string getname() { if(isheated) { return ""espresso (sicak fincan)""; } else { return ""espresso""; } } @override public double calculateprice() { double totalprice = 0; totalprice +=40; for(coffeeaddon x : addons) { totalprice += x.getcost(); } return totalprice; } public void heatcup() { isheated = true; } } public class vanillasyrup implements coffeeaddon { @override public double getcost() { return 6; } public string getname() {return ""vanilla syrup"";} } public abstract interface coffeeaddon { double getcost(); string getname(); } import java.util.arraylist; public abstract class basecoffee { public abstract string getname(); protected arraylist<coffeeaddon> addons; basecoffee() { addons = new arraylist<coffeeaddon>(); } public void addaddon(coffeeaddon x){ addons.add(x); } public abstract double calculateprice(); } public class americano extends basecoffee{ public string getname() { return ""americano""; } public double calculateprice() { double totalprice = 0; totalprice +=45; for(coffeeaddon x : addons) { totalprice += x.getcost(); } return totalprice; } } public class coffeemachine { static int toplamkahveuretimi; public void addaddontocoffee(basecoffee coffee, coffeeaddon addon) { if(coffee instanceof espresso) { if(addon instanceof doubleshot || addon instanceof chocolate) { coffee.addaddon(addon); } else { system.out.println(""[uyari] "" + coffee.getname() + "" tipi kahveye "" + addon.getname() + "" eklenmez""); } } else if(coffee instanceof latte) { if(addon instanceof milk || addon instanceof chocolate || addon instanceof vanillasyrup) { coffee.addaddon(addon); } else { system.out.println(""[uyari] "" + coffee.getname() + "" tipi kahveye "" + addon.getname() + "" eklenmez""); } } else if(coffee instanceof americano) { if(addon instanceof milk || addon instanceof vanillasyrup) { coffee.addaddon(addon); } else { system.out.println(""[uyari] "" + coffee.getname() + "" tipi kahveye "" + addon.getname() + "" eklenmez""); } } } public void makecoffee(basecoffee coffee) { toplamkahveuretimi +=1; system.out.print(""siprais: "" + coffee.getname()); for(coffeeaddon x : coffee.addons) { system.out.print("" + ""); system.out.print(x.getname()); } system.out.println(); system.out.println(""toplam fiyat:"" + (int) coffee.calculateprice() + ""tl""); system.out.println(); } public void heatespressocup(basecoffee coffee) { if(coffee instanceof espresso) { system.out.println(""espresso kahve fincanı ısıtıldı""); ((espresso) coffee).heatcup(); } else { system.out.println(""[uyari] yalnızca espresso kahve fincanları ısıtılabilir""); } } public static void totalcoffeemade() { system.out.println(""tum fabrikalar kahve makineleri toplam ""+ toplamkahveuretimi + "" kahve uretildi""); } } public class milk implements coffeeaddon { public double getcost() { return 5; } public string getname() { return ""milk""; } } public class doubleshot implements coffeeaddon{ @override public double getcost() { return 10; } public string getname() { return ""double shot""; } } public class chocolate implements coffeeaddon { @override public double getcost() { return 7; } public string getname() { return ""chocolate""; } } 4"
2384475,1,"2384475 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q2 { public static void main(string[] args) { int arr[] = { 5, 4, 1, 2 }; cocktailsort(arr, true); for (int i = 0; i < arr.length; i++) { system.out.println(arr[i]); } } public static void cocktailsort(int[] arr, boolean x) { for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } if (arr.length < 2) return; { if (x) { arr = bubble1(arr); x = false; } else { arr = bubble2(arr); x = true; } cocktailsort(arr, x); } } public static int[] bubble1(int[] arr) { int newarr[] = new int[arr.length - 1]; for (int i = 0; i < arr.length - 1; i++) { newarr[i] = arr[i]; } for (int i = 0; i < newarr.length - 1; i++) { if (newarr[i] > newarr[i + 1]) { int temp = newarr[i]; newarr[i] = newarr[i + 1]; newarr[i + 1] = temp; } } return newarr; } public static int[] bubble2(int[] arr) { int newarr[] = new int[arr.length - 1]; for (int i = 0; i < arr.length - 1; i++) { newarr[i] = arr[i]; } for (int i = newarr.length - 1; i > 0; i--) { if (newarr[i] < newarr[i - 1]) { int temp = newarr[i]; newarr[i] = newarr[i - 1]; newarr[i - 1] = temp; } } return newarr; } } public class lab1q1 { public static void main(string[] args) { system.out.println(collatz(2)); } public static int collatz(int i) { int count = 0; if (i == 1) return count; if (i % 2 == 0) count = 1 + collatz(i / 2); else if (i % 2 == 1) count = 1 + collatz(i * 3 + 1); return count; } } class sayac { public string x; public sayac(string x) { this.x = x; } public int say() { int res = say2(x); return res; } public int say2(string x) { int res = 0; if (x.length() < 1) return res; if (x.charat(0) != '1') { res = res + say2(x.substring(1)); } else if (x.charat(0) == '1') res = res + 1 + say2(x.substring(1)); return res; } public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; import java.util.*; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { metalsarki met = (metalsarki) sarki; system.out.println(sarki.sanatci + ""-"" + sarki.isim + "" [ozellik: "" + met.metalozellik + ""]""); } // bu kismi cikti ornegini saglayacak sekilde doldurun } } } abstract class sarki { string isim; string sanatci; sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } abstract void oynat(); } class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { super(isim, sanatci); this.metalozellik = metalozellik; } @override void oynat() { } void gostermetalozellikleri() { system.out.println(metalozellik); } } class rocksarki extends sarki { string rocko; rocksarki(string isim, string sanatci) { super(isim, sanatci); this.rocko = ""huzurlu ve nostaljik""; } @override void oynat() { } } class klasiksarki extends sarki { string klasiko; klasiksarki(string isim, string sanatci) { super(isim, sanatci); this.klasiko = ""hafif ve sakin""; } @override void oynat() { } } interface calmastratejisi { void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki) { rocksarki r = (rocksarki) sarki; system.out.println( ""[rock] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + r.rocko + "")""); } else if (sarki instanceof metalsarki) { metalsarki met = (metalsarki) sarki; system.out.println(""[metal] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + met.metalozellik + "")""); } else if (sarki instanceof klasiksarki) { klasiksarki k = (klasiksarki) sarki; system.out.println( ""[klasik] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + k.klasiko + "")""); } } } } class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { // karısık calma yapamadım :( tersten caldırdım. sarkilistesi = sarkilistesi.reversed(); for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki) { rocksarki r = (rocksarki) sarki; system.out.println( ""[rock] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + r.rocko + "")""); } else if (sarki instanceof metalsarki) { metalsarki met = (metalsarki) sarki; system.out.println(""[metal] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + met.metalozellik + "")""); } else if (sarki instanceof klasiksarki) { klasiksarki k = (klasiksarki) sarki; system.out.println( ""[klasik] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + k.klasiko + "")""); } } } } class rockcuozelcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki) { rocksarki r = (rocksarki) sarki; system.out.println(""[bilgi] ses duzeyi : yuksek""); system.out.println( ""[rock] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + r.rocko + "")""); system.out.println(""[bilgi] ses duzeyi : normal""); } else if (sarki instanceof metalsarki) { metalsarki met = (metalsarki) sarki; system.out.println(""[metal] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + met.metalozellik + "")""); } else if (sarki instanceof klasiksarki) { klasiksarki k = (klasiksarki) sarki; system.out.println( ""[klasik] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + k.klasiko + "")""); } } } } class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { this.strateji = s; } void muzikcal(list<sarki> sarkilistesi) { if (strateji instanceof siralicalma) { strateji.cal(sarkilistesi); } else if (strateji instanceof karisikcalma) { strateji.cal(sarkilistesi); } else if (strateji instanceof rockcuozelcalma) { strateji.cal(sarkilistesi); } } } abstraction kavramını açıklayınız. i̇htiyacımız olan şeylerin dışındakileri yok saymaktır. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür cünkü hourlye is a e ama tam tersi degil cunku e is not a hourlye. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? package access daha yakındır. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? üst classların instance variablelarını parametre olarak gecirmek icin. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır,mümkün değil. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? verilen objenin bizim istedigimiz türden bir obje olup olmadigini kontrol eder. b objesi a objesiyle ayni class a aittir. metot overriding ve overloading kavramlarını açıklayınız. overriding signature ı aynı olan metotlar icin kullanılır. overlode ismi aynı ama parametreleri farkli metotlar icin kullanilir. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? 10 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? signatureları farklı olan methodlarda static binding aynı olanlarda dynamic binding kullanılır. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? bu metotlar değiştirilemez ve override edilemez. bu yüzden static bindingle bağlanır. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloadingde static binding overridingde dynamic binding gerçekleşir. dinamik bağlamada jvm'nin görevi nedir? run time sırasında karar verir. java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? ana classın referans variable ı alt classın objesini refer ettiği için. downcast implicit yapılamaz. typecating ile yapılır. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? run time sırasında vakit kaybederdik. class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child dinamik bağlama class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book dinamik bağlama java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? i̇çinde abstract method(implement edilmemis) bulunduran ya da bulundarmayan classlardır. abstract classlarda constructur olabilir.interfacde olamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? bir abstract classın methodu başka bir abstract classda implement edilebilir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. daha sonra kesin olarak implement edileceğini bildiğimiz bir methodu tanımlamamızı sağlar. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interfaceler class değil bir tiptir. abstract classlardan obje üretilmez. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interfacelerin içi boştur. functionallarda implement edilmeyi bekleyen methodlar vardır. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? classlar birden fazla interface implement edebilir. i̇nterface başka bir interfacei extend edebilir. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abstract classtan obje üretilmez. shape c = new circle(); olmalı drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? edilemez çünkü hangisini çalıştiracagıni bilemez. super olmamalıydı. new b().show; yapabiliriz. output: b java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 2 çeşittir. io ve runtime exception java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? trowable olmak zorundadır ve override edildiğinde kendisi ve subclassları throws edilebilir. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? her koşulda kod bloğunu çalıştırır. exception atılıp atılmaması önemli değildir. java'da kendi exceptionunuzu nasıl tanımlarsınız? i̇stediğimiz türdeki exception classını extend ederiz ve şu koşul gerçekleşirse exception fırlat deriz. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? . static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done -1 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? normalde specific olandan olmayana doğru catch ederiz ama böylede çalışır trying m1 caught2 finally bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class quiz1q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55, true); robot r3 = new robot(""r2-d2"", ""astromech"", 80, true); int i = 0; factory.addrobot(r1, i++); factory.addrobot(r2, i++); factory.addrobot(r3, i++); factory.printfactory(); } } class factory { private string name; private string location; private robot[] robots = new robot[100]; public factory(string name, string location) { this.name = name; this.location = location; } public factory() { this.name = ""factory1""; this.location = ""moon""; } public void addrobot(robot robot, int index) { robots[index] = robot; } public void chargeallrobots() { for (int i = 0; i < robots.length; i++) { robots[i].charge(); } } public void printfactory() { system.out.println(""factory name: "" + getname1() + "" location: "" + getlocation1()); for (int i = 0; i < robots.length; i++) { if (robots[i] != null) system.out.println("" robot name: "" + robots[i].getname() + "" robot type: "" + robots[i].gettype() + "" battery level: "" + robots[i].getbattery() + "" is operational: "" + robots[i].getopera()); } } public void work() { for (int i = 0; i < robots.length; i++) { int x = robots[i].getbattery() - 15; system.out.println(x); } } public string getname1() { return name; } public string getlocation1() { return location; } } class robot { private string name; private string type; private int batterylevel; // 100 ile 0 arasında bir değer private boolean isoperational;// bataryası varsa true robot() { this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } robot(string name, string type, int batterylevel, boolean isoperational) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = isoperational; } public void charge() { batterylevel = 100; } public void printrobot() { system.out.println(); } public string getname() { return name; } public string gettype() { return type; } public int getbattery() { return batterylevel; } public boolean getopera() { return isoperational; } } public class quiz1q1 { public static void main(string[] args) { string x = ""a1b2""; string[] ar = method(x); for (int i = 0; i < ar.length; i++) { system.out.println(ar[i]); } } public static string[] method(string x) { x = x.touppercase(); string[] arr = new string[2 ^ (x.length() / 2)]; for (int i = 0; i < arr.length; i++) { arr[i] = x.substring(0, i) + x.substring(i).tolowercase(); } return arr; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 package robot; public interface withbattery { int getbatterylife(); void recharge(); } package robot; public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public abstract void performtask(); public int getbatterylife() { return batterylife; } public void recharge() { final int temp = batterylife; this.batterylife = temp; system.out.println(batterylife); } } package robot; public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.robotnumber(); // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } package robot; public class securityrobot extends abstractrobot { private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } @override public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] scanning for threats... armed:"" + isarmed); batterylife = batterylife - 10; } else { system.out.println(""["" + modelname + ""] not enough battery to scan threats...""); } } public void togglearmedmode() { isarmed = !isarmed; } public boolean getisarmed() { return isarmed; } } package robot; public class cleaningrobot extends abstractrobot { private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } @override public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] cleaning in progress... cleaning power:"" + cleaningpower); batterylife = batterylife - 10; } else { system.out.println(""["" + modelname + ""] not enough battery to clean...""); } } public void boostcleaningpower() { cleaningpower = cleaningpower + 10; } public int getcleaningpower() { return cleaningpower; } } package robot; import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; static int number; robotfactory() { robots = new arraylist<abstractrobot>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { cleaningrobot x = new cleaningrobot(modelname, batterylife, cleaningpower); number++; robots.add(x); } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { securityrobot x = new securityrobot(modelname, batterylife, isarmed); number++; robots.add(x); } public void performalltasks() { for (abstractrobot r : robots) { r.performtask(); } } public void displayrobots() { for (abstractrobot r : robots) { if (r instanceof cleaningrobot) { cleaningrobot x = (cleaningrobot) r; system.out.println(""- model: "" + x.modelname + "", battery: "" + x.batterylife + "", cleaning power: "" + x.getcleaningpower()); } else if (r instanceof securityrobot) { securityrobot x = (securityrobot) r; system.out.println( ""- model: "" + x.modelname + "", battery: "" + x.batterylife + "", armed: "" + x.getisarmed()); } } } public void upgradecleaningrobots(int miktar) { for (abstractrobot r : robots) { if (r instanceof cleaningrobot) { cleaningrobot x = (cleaningrobot) r; x.boostcleaningpower(); system.out .println(""cleaningrobot - "" + x.modelname + "" now has cleaning power: "" + x.getcleaningpower()); } } } public void togglesecurityrobotsmode() { for (abstractrobot r : robots) { if (r instanceof securityrobot) { securityrobot x = (securityrobot) r; x.togglearmedmode(); system.out.print(""securityrobot - "" + x.modelname + "" is now ""); if (x.getisarmed()) { system.out.println(""armed""); } else { system.out.println(""unarmed""); } } } } public static void robotnumber() { system.out.println(""tum fabrikalar tarafindan toplam "" + number + "" robot uretildi""); } } 1"
6914659,1,"6914659 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class cocktailshaker{ public static void cocktailsort(int[] array2){ csrec(array2, 0, array2.length - 1); } public static void csrec(int[] array1, int ilk, int son){ if (ilk >= son) //base case return; boolean degistir = false; for (int i=ilk ; i<son ; i++){//soldan sağa doğru kontrol ediyorum if (array1[i] > array1[i+1]){ //buradaki durum 5,4 durumu. bunu 4,5 yapmaya çalışıyorum yer_degistirme(array1, i, i+1); //soldaki ile sağdakinin yerini değiştirdim degistir = true; //değiştirme işleminin yapıldığını göstermek için } } if (!degistir){ //değiştirme işleminin yani yer_degistirme metodunun kullanılıp kullanılmadığını kontrol ediyorum /* eğer değiştirme işlemi yapılsaydı ""degistir"" değeri true olacaktı ve bu blok false olacağı için çalışmazdı değiştirme işlemi yapılmazsa ""degistir"" değeri false olarak kalacağı için blok true olur ve çalışır. */ return; } degistir = false; for (int i = son-1 ; i>ilk ; i--){//sağdan sola doğru kontrol ediyorum if (array1[i-1] > array1[i]){ yer_degistirme(array1, i-1, i);//sağdaki ile soldakinin yerini değiştirdim degistir = true; //değiştirme işleminin yapıldığını göstermek için } } csrec(array1, ilk+1, son-1);//arrayın ilk elemanı ile son elemanını attım } public static void yer_degistirme(int[] arr, int a, int b){ int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; } public static void main(string[] args){ int[] array3 = {5, 4, 1, 2}; cocktailsort(array3); for (int a: array3){ system.out.print(a + "" ""); } } } public class collatz{ public static int collatz(int i){ int sum = i; if(i == 1) //base case return 0; if(i % 2 == 0){ //çiftse ikiye böl sum /= 2; return 1 + collatz(sum); } else{ //tekse 3 ile çarp 1 ekle sum = (sum*3)+1; return 1 + collatz(sum); } } public static void main(string[] args) { system.out.println(collatz(5)); } } public class sayacwithhelpermethod { string str; public sayacwithhelpermethod(string str){ this.str = str; } public int helper(string str) { int currentcount = 0; if(str.length() == 0) //base case return 0; if(str.charat(0)=='1') return 1+helper(str.substring(1)); return currentcount + helper(str.substring(1)); } public int say(){ if(str.length() == 0) return 0; if(str.charat(0)=='1'){ str = str.substring(1); return 1 + say(); } else{ str = str.substring(1); return say(); } } public static void main(string[] args) { sayacwithhelpermethod s1 = new sayacwithhelpermethod(""10001""); sayacwithhelpermethod s2 = new sayacwithhelpermethod(""1111""); sayacwithhelpermethod s3 = new sayacwithhelpermethod(""11190002""); system.out.println(""sayac with helper method""); system.out.println(s1.say()); // 2 basacak. system.out.println(s2.say()); //4 system.out.println(s3.say()); //3 } } public class sayac { string str; public sayac(string str){ this.str = str; } public int say(){ if(str.length() == 0)//base case return 0; if(str.charat(0)=='1'){ //eleman 1 ise sayacı 1 artır str = str.substring(1); return 1 + say(); } else{ //eleman 1 dışında herhangi bir rakam ise sayacın degerini degistirme str = str.substring(1); return say(); } } public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); sayac s3 = new sayac(""11190002""); system.out.println(s1.say()); // 2 basacak. system.out.println(s2.say()); //4 system.out.println(s3.say()); //3 } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar{ private calmastratejisi strateji; public void setstrateji(calmastratejisi s){ this.strateji = s; } public void muzikcal(list<sarki> sarkilistesi){ if (strateji != null){ //strateji objesi bos degilse strateji.cal(sarkilistesi); } } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki: sarkilistesi) { if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } } } } public class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci){ super(isim, sanatci); } @override public void oynat(){ system.out.println(""[klasik] "" + getsanatci() + "" - "" + getisim() + "" (hafif ve sakin)""); } } import java.util.list; public class metalsarki extends sarki implements calmastratejisi{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik){ super(isim, sanatci); this.metalozellik = metalozellik; } public string getmetalozellik(){ return metalozellik; } public void setmetalozellik(string metalozellik){ this.metalozellik = metalozellik; } @override public void oynat(){ system.out.println(""[metal] "" + getsanatci() + "" - "" + getisim() + "" ("" + getmetalozellik() + "")""); } public void gostermetalozellikleri(){ system.out.println(getsanatci() + "" - "" + getisim() + "" [ozellik: "" + getmetalozellik() + ""]""); } @override public void cal(list<sarki> sarkilistesi){ // todo auto-generated method stub throw new unsupportedoperationexception(""unimplemented method 'cal'""); } } public class rocksarki extends sarki{ public rocksarki(string isim, string sanatci){ super(isim,sanatci); } @override public void oynat(){ system.out.println(""[rock] "" + getsanatci() + "" - "" + getisim() + "" (huzurlu ve nostaljik)""); } } import java.util.list; public class karisikcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi){ int n = sarkilistesi.size(); for (int i=n-1; i>0; i--){ int rnd = (int)(math.random()*(i+1)); //indeksi rastgele seçiyor sarki temp = sarkilistesi.get(i); sarkilistesi.set(i, sarkilistesi.get(rnd)); //random gelen elemani koydum sarkilistesi.set(rnd, temp); } for (sarki sarki: sarkilistesi){ //sarkilistesinin yeni hali sarki.oynat(); } } } import java.util.list; class siralicalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi){ for (sarki sarki: sarkilistesi){ sarki.oynat(); } } } public abstract class sarki{ private string isim; //sarki adi private string sanatci; //sanatci adi public sarki(string isim, string sanatci){ this.isim = isim; this.sanatci = sanatci; } public string getisim(){ return isim; } public void setisim(string isim){ this.isim = isim; } public string getsanatci(){ return sanatci; } public void setsanatci(string sanatci){ this.sanatci = sanatci; } public abstract void oynat(); //soyut metod oldugu icin govdesi yok. } import java.util.list; public class rockcuozelcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi){ boolean sesyuksekmi = false; for (int i=0; i<sarkilistesi.size(); i++){ sarki sarki = sarkilistesi.get(i); if (sarki instanceof rocksarki && !sesyuksekmi){ //eger sarki objesi rocksarki objesi ise ve ses yuksekse system.out.println(""[bilgi] ses duzeyi: yuksek""); sesyuksekmi = true; //ses artık yuksek } sarki.oynat(); //sanatciyi, sarki ismini ve sarki ozelliklerini bastirdi if (sesyuksekmi && (i == sarkilistesi.size()-1 || !(sarkilistesi.get(i+1) instanceof rocksarki))){ //ses yuksekligi dusukse ve sarkilistesindeki elemanlar rocksarki objesi degilse veya index sondaysa system.out.println(""[bilgi] ses duzeyi: normal""); sesyuksekmi = false; } } } } import java.util.list; public interface calmastratejisi{ void cal(list<sarki> sarkilistesi); } ""recursion"" kavramı nedir, kısaca açıklayınız. bir metodun kendi kendisini çağırmasıdır. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case: temel olan kısımdır. burasi recursive kolun kilitlendiği yerdir. call case: burasi ise recursive kismin devamli olarak büyüyüp kuculerek kendisini çağırmaya devam ettigi yerdir. jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. stack denilen bir yapıda bu call'ları tutuyor, son giren veri ilk çıkıyor. int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. i̇teratif yöntem yani for veya while döngüsü daha hızlıdır ve bellekte daha az yer kaplar, fakat bu verilen metodu recursive yazmak yazılımcı acisindan daha kolaydir ve kod daha clean gozukur. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? public int length(string s) { if(s.length() == 1) //base case return 1; calling case: else return length(s.substring(1))+1; stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack: recursive metotlarda metod kendisini her çağırdığında gelecek veriler burada toplanir, son giren veri ilk cikar. stackoverflow ise cok fazla veri geldiğinde olusur, stack taşar. tail recursion nedir, kısaca açıklayınız. metodun sadece kendisini çağırmasıdır yani yaninda toplama veya carpma gibi bir işlem bulunmaz abstraction kavramını açıklayınız. soyutlama anlamina gelir. java dilinde classlar objeler encapsulation ve polymorphism abstarction kavramina örnektir. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? evet mumkundur. çünkü hourlyemployee employee sınırının alt classıdır. fakat tersi mümkün değildir. çünkü her hourlyemployee bir employee'dir, fakat her employee hourlyemployee değildir. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? default daha yakindir, çünkü protected ile alt sinif oldugu surece farkli paketlerden erisim saglanir ama default'tan saglanmaz. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? alt sinif oldugu icin. ust sinifin ozelliklerini de icermesi gerektiğinden daima alt sinifin constructorının ilk satirinda ust sinifi temsil eden super satırı olmak zorundadır. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? edemez. bir class her zaman yalnizca tek 1 class'ı extend edebilir. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a objesi b classının bir objeyi mi diye bakar. metot overriding ve overloading kavramlarını açıklayınız. overriding: ust sinifta tanımlanmış bir metodun alt sınıflarda yeniden tanimlanmasidir, metodun imzasi ve return type'ı degismez. ust sinifta metod tanimlanirken final keywordü kullanilirsa o metod override edilemez. overloading: bir metodun ayni isimle ama farkli parametrelerle yeniden tanimlanmasidir, parametreler degisecegi icin imza degisebilir fakar return type degisemez. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? base1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? hata verir. çünkü görünürlüğü azaltamayız. fakat burada ust sınıfta x değişkeni protected olarak tanimlanirken alt sinifta private olarak tanımlayarak bu hatayı yapmış java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? metotlar ve variablelar siniflara özgü ise static, objelere ozgu ise dynamic java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? override edilemezler yani degistirilemezler overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? early binding, çünkü compiler hangi metodu calistiracagina karar verir dinamik bağlamada jvm'nin görevi nedir? kodu javanin anlayacagi bytecode a cevirir java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? çünkü üst sınıf referanslı alt sınıf objesi oluşturulur, fakat down casting implicit yapilamaz java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? late binding yapılamazdi ve çoğu kod hatalı olurdu class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? static class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 2 çeşittir checked ve unchecked. checked exception örneği io, unchecked exception örneği runtime. java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? checked exceptionlar için throws kullanılır. override edilen metodlarda throw yazılarak exception fırlatılır. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? ne olursa olsun çalıştır demektir. finally blogu exception atılmayan yerde çalışmaz. java'da kendi exceptionunuzu nasıl tanımlarsınız? class yazıp extends throwable ya da extends exception yazarak. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? checked exception olduğu için. veya birden fazla exception olabileceği için. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally done static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenmesi. hata ise ilk catch blogunda exception yazıp altındaki catch blogunda exception classinin alt sınıfı olan ioexception yapmasıdır. hatayı düzeltmek için ioexception ı yukarı, exception ı aşağı almalıyız. hata duzeltildikten sonra: trying m1 caught2 finally bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot{ private string name; private string type; private int batterylevel; // 100 ile 0 arasında bir değer private boolean isoperational; // bataryası varsa true public robot(){ name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } public robot(string name, string type, int batterylevel){ this.name = name; this.type = type; this.batterylevel = batterylevel; } public string getname(){ return name; } public void setname(string name){ this.name = name; } public string gettype(){ return type; } public void settype(string type){ this.type = type; } public int getbatterylevel(){ return batterylevel; } public void setbatterylevel(int batterylevel){ this.batterylevel = batterylevel; } public boolean getisoperational(){ return isoperational; } public void setisoperational(boolean isoperational){ //this.isoperational = isoperational; if(batterylevel > 0) isoperational = true; else isoperational = false; this.isoperational = isoperational; } public void charge(){ batterylevel = 100; } public void printrobot(){ //robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + ""%"" + "" is operational: "" + isoperational); } } public class main { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } public class q1{ public static void combinations(string str, int index, string guncelstr){ if(index == str.length()){ // stringin verilen ilk halini yazdıracak system.out.println(guncelstr); return; } char c = str.charat(index); int ascii_degeri = (int)c; if ((ascii_degeri>=65 && ascii_degeri<=90) || (ascii_degeri>=97 && ascii_degeri<=122)) { //küçük harf mi veya büyük harf mi diye bakacak, rakam ise lower veya upper işlemi uygulamayacak. combinations(str, index+1, guncelstr+character.tolowercase(c)); combinations(str, index+1, guncelstr+character.touppercase(c)); } else combinations(str, index+1, guncelstr+c); } public static void main(string[] args) { string str = ""a1b2""; combinations(str, 0, """"); } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name, string location){ this.name = name; this.location = location; this.robots = new arraylist<>(); } public factory(){ name = ""factory1""; location = ""moon""; this.robots = new arraylist<>(); } public string getname(){ return name; } public void setname(string name){ this.name = name; } public string getlocation(){ return location; } public void setlocation(string location){ this.location = location; } public arraylist<robot> getrobots(){ return robots; } public void setrobots(arraylist<robot> robots){ this.robots = robots; } public void addrobot(robot robot){ robots.add(robot); } public void chargeallrobots() { for (robot robot: robots) { robot.charge(); } } public void printfactory() { system.out.print(""factory name: "" + name); system.out.println("" location: "" + location); system.out.println(""robots operating here:""); for (robot robot : robots) { robot.printrobot(); } } public void work() { robot rbt = new robot(); if(rbt.getbatterylevel() >= 15) rbt.setbatterylevel(rbt.getbatterylevel()-15); else rbt.setbatterylevel(0); rbt.setisoperational(rbt.getbatterylevel() > 0); } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery{ int getbatterylife(); //batarya omrunu doner void recharge(); //bataryayi yeniler } public abstract class abstractrobot implements withbattery{ protected string modelname; //robotun modeli protected int batterylife; //robotun batarya omru public abstractrobot(string modelname, int batterylife){ this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname(){ return modelname; } public abstract void performtask(); //abstract metod oldugu icin govdesiz public int getbatterylife(){ return batterylife; } public void recharge(){ this.batterylife = 100; } } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); //?? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz robotfactory.toplamroboturetimi(); } } public class securityrobot extends abstractrobot{ private boolean isarmed; //robotun silahli olup olmadigini gosterir securityrobot(string modelname, int batterylife, boolean isarmed){ super(modelname, batterylife); this.isarmed = isarmed; } /* eğer batarya ömrü 10 ya da daha fazla ise ""[modelname] scanning for threats... armed: isarmed"" mesajını yazdırır (modelname ve isarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname] not enough battery to scan threats..."" mesajı gösterilmeli. */ public void performtask(){ if(batterylife >= 10){ system.out.println(""["" + modelname + ""]"" + "" scanning for threats... armed: "" + isarmed); batterylife -= 10; } else{ system.out.println(""["" + modelname + ""]"" + "" not enough battery to scan threats...""); } } public void togglearmedmode(){ //silah modunu degistirir //securityrobot - guardbot x is now unarmed this.isarmed = !this.isarmed; if(isarmed == true) system.out.println(""securityrobot - "" + modelname + "" is now armed""); else system.out.println(""securityrobot - "" + modelname + "" is now unarmed""); } public boolean getisarmed(){ return isarmed; } public void setisarmed(boolean isarmed){ this.isarmed = isarmed; } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower){ super(modelname, batterylife); this.cleaningpower = cleaningpower; } /* eğer batarya ömrü 10 ya da daha fazla ise ""[modelname] cleaning in progress... cleaning power: cleaningpower"" mesajını yazdırır (modelname ve cleaningpower yerine değişken değerleri gösterilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname] not enough battery to clean..."" mesajı gösterilmeli. */ public void performtask(){ if(batterylife >= 10){ system.out.println(""["" + modelname + ""]"" + "" cleaning in progress... cleaning power: "" + cleaningpower); batterylife -= 10; } else{ system.out.println(""["" + modelname + ""]"" + "" not enough battery to clean...""); } } public void boostcleaningpower(){ //temizlik gucunu artirir this.cleaningpower += 10; system.out.println(""cleaningrobot - "" + modelname + "" now has cleaning power: "" + cleaningpower); } public int getcleaningpower(){ return cleaningpower; } public void setcleaningpower(int cleaningpower){ this.cleaningpower = cleaningpower; } } import java.util.arraylist; class robotfactory{ private arraylist<abstractrobot> robots; private static int totalrobotproduction = 0; // main metodunda obje olusturmadan cagirmak icin static public robotfactory(){ robots = new arraylist<>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); totalrobotproduction++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ robots.add(new securityrobot(modelname, batterylife, isarmed)); totalrobotproduction++; } public void performalltasks(){ for (abstractrobot robot: robots){ robot.performtask(); } } public void displayrobots(){ for (abstractrobot r: robots){ if (r instanceof cleaningrobot){ cleaningrobot cr = (cleaningrobot)r; system.out.println(""cleaningrobot - model: "" + cr.getmodelname() + "", battery: "" + cr.getbatterylife() + "", cleaning power: "" + cr.getcleaningpower()); } else if (r instanceof securityrobot){ securityrobot sr = (securityrobot)r; system.out.println(""securityrobot - model: "" + sr.getmodelname() + "", battery: "" + sr.getbatterylife() + "", armed: "" + sr.getisarmed()); } } } public void upgradecleaningrobots(int miktar){ //cleaning robot sinifindayken for (abstractrobot r: robots){ if (r instanceof cleaningrobot){ ((cleaningrobot)r).boostcleaningpower(); } } } public void togglesecurityrobotsmode(){ //security robot sinifindayken for (abstractrobot r: robots){ if (r instanceof securityrobot){ ((securityrobot)r).togglearmedmode(); } } } public static void toplamroboturetimi(){ system.out.println(""tum fabrikalar tarafindan toplam "" + totalrobotproduction + "" robot uretildi""); } } 1"
5187413,1,"5187413 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab211q2 { public static void main(string[] args) { int[] arr = { 5, 4, 1, 2 }; coctailsort(arr); } public static void coctailsort(int[] arr) { int high = arr.length - 1; int low = 0; int[] temparr = arr; for (int i = 0; i < arr.length; i++) { for (int j = 0; j < arr.length - 1; j++) { if (temparr[j] > temparr[j + 1]) { int temp = temparr[j]; temparr[j] = temparr[j + 1]; temparr[j + 1] = temp; } } } int count = 0; for (int i = 0; i < arr.length - 1; i++) { if (arr[i] == temparr[i]) { count++; } } if (count == arr.length) { system.out.println(arr); } else { listingup(arr, temparr, low, high); } } public static int listingup(int[] arr, int[] temparr, int low, int high) { int count = 0; for (int i = 0; i < arr.length - 1; i++) { if (arr[i] == temparr[i]) { count++; } } if (count == arr.length) { coctailsort(arr); } if (low == high) { listingdown(arr, temparr, 0, high); } if (arr[low] > arr[low + 1]) { int temp = arr[low]; arr[low] = arr[low + 1]; arr[low + 1] = temp; } return listingup(arr, temparr, low + 1, high); } public static int listingdown(int[] arr, int[] temparr, int low, int high) { int count = 0; for (int i = 0; i < arr.length - 1; i++) { if (arr[i] == temparr[i]) { count++; } } if (count == arr.length) { coctailsort(arr); } if (low == high) { listingup(arr, temparr, low, arr.length - 1); } if (arr[high] < arr[high - 1]) { int temp = arr[high]; arr[high] = arr[high - 1]; arr[high - 1] = temp; } return listingdown(arr, temparr, low, high - 1); } } public class q3sayac { private string str; public q3sayac(string str) { this.str = str; } public int say() { int count = 0; if (str.length() <= 0) { return count; } if (str.charat(0) - '0' == 1) { count++; str = str.substring(1); return count + say(); } str = str.substring(1); return count + say(); } } public class lab211q1 { public static void main(string[] args) { int number = 5; system.out.println(collatz(number)); } public static int collatz(int i) { int count = 0; if (i == 1) { return count; } if (i % 2 == 0) { count++; return count + collatz(i / 2); } count++; return count + collatz(i * 3 + 1); } } public class lab211q3 { public static void main(string[] args) { q3sayac s1 = new q3sayac(""10001""); q3sayac s2 = new q3sayac(""1111""); system.out.println(""s1 sonuç: "" + s1.say() + ""\ns2 sonuc: "" + s2.say()); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { calmastratejisi strateji; public muzikcalar() { } void setstrateji(calmastratejisi s) { strateji = s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { sarki s1 = new klasiksarki(""prelude in c minor"", ""bach""); sarki s2 = new rocksarki(""immigrant song"", ""led zeppelin""); sarki s3 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s4 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s5 = new rocksarki(""welcome to the jungle"", ""guns & roses""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karisik calma: ""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu ozel calma listesi: ""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri: ""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) system.out.println( sarki.sanatci + "" - "" + sarki.isim + ""[ozellik: "" + ((metalsarki) sarki).metalozellik + ""]""); } } } public class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { } } public class metalsarki extends sarki { string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void oynat() { } void gostermetalozellikler() { system.out.println(metalozellik); } } public class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { } } import java.util.list; import java.util.random; import java.util.random.randomgenerator; public class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { randomgenerator gen = new random(); sarki[] liste = new sarki[sarkilistesi.size()]; int index = 0; for (int i = 0; i < sarkilistesi.size(); i++) { liste[index++] = sarkilistesi.get(i); } for (int i = 0; i < liste.length; i++) { sarki temp = liste[i]; liste[i] = liste[gen.nextint(5)]; liste[gen.nextint(5)] = temp; } for (sarki sarki : liste) { if (sarki instanceof metalsarki) { system.out.println(""[metal] "" + sarki.sanatci + "" - "" + sarki.isim + ""( "" + ((metalsarki) sarki).metalozellik + "")""); } else if (sarki instanceof klasiksarki) { system.out.println(""[klasi̇k] "" + sarki.sanatci + "" -"" + sarki.isim); } else { system.out.println(""[rock] "" + sarki.sanatci + "" - "" + sarki.isim); } } } } import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { system.out.println(""[metal] "" + sarki.sanatci + "" - "" + sarki.isim + ""( "" + ((metalsarki) sarki).metalozellik + "")""); } else if (sarki instanceof klasiksarki) { system.out.println(""[klasi̇k] "" + sarki.sanatci + "" -"" + sarki.isim); } else { system.out.println(""[rock] "" + sarki.sanatci + "" - "" + sarki.isim); } } } } public abstract class sarki { string isim; string sanatci; abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof metalsarki) { system.out.println(""[metal] "" + sarkilistesi.get(i).sanatci + "" - "" + sarkilistesi.get(i).isim + ""( "" + ((metalsarki) sarkilistesi.get(i)).metalozellik + "")""); } else if (sarkilistesi.get(i) instanceof klasiksarki) { system.out.println(""[klasi̇k] "" + sarkilistesi.get(i).sanatci + "" -"" + sarkilistesi.get(i).isim); } else { if (!(sarkilistesi.get(i - 1) instanceof rocksarki)) system.out.println(""[bi̇lgi̇] yüksek ses düzeyi""); system.out.println(""[rock] "" + sarkilistesi.get(i).sanatci + "" - "" + sarkilistesi.get(i).isim); if (i != sarkilistesi.size() - 1) { if (!(sarkilistesi.get(i + 1) instanceof rocksarki)) system.out.println(""[bi̇lgi̇] normal ses düzeyi""); } } } } } import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } ""recursion"" kavramı nedir, kısaca açıklayınız. özyinelemeli metot, kendi içinde tekrar kendi çağırarak işler. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case, metotun stack overflow olmasını engelleyen istenilen durum. büyük problem, çözmek istediğimiz ana problem(n). küçük problem, büyük problemi ayırarak çözümüne odaklandığımız parça (n-1). jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. stack'de en alttan başlayarak elde tutması gerekenleri biriktirir. en tepeye ulaştıktan sonra yukarıdan aşağı olacak şekilde kodu işler. int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. tek bir for döngüsüyle halledebileceğimiz için iteratif olarak. çünkü recursion daha yavaş işler. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? base case stringin uzunluğu 1e eşitse 1 döndür olur. her seferinde int count değişkenimi 1 arttırıp stringi substring(1)'den başlatarak tekrar çağırırım. stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. bilgisayar kaynaklarını tükettiyse olur. base case tanımlanmadığı zaman recursion metotlarında olur. tail recursion nedir, kısaca açıklayınız. metotun içinde iflere girmediği durumda tekrar metotun çağrılmasıyla olur. abstraction kavramını açıklayınız. soyutlama, black box. çalışırken metotun işleyişini detaylı olarak bilmediğimiz ama çıktısını bildiğimiz metotları örnek verebiliriz örneğin system.out.println dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? override ettiğimiz metot diğer sınıfın subclassında yer aldığı için mümkündür. tersi değil. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? protected private a daha yakın çünkü aynı package ve subclassların erişimine izin veriyor. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? kendinden hemen önceki türetildiği classın contructorını almak için. bu listenin en tepesinde object classı yer alır. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır extend ettiğimiz classların metotları birbiriyle aynı olabilir sorun çıkarabilir. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a b'nin içinde tanımlı bir variabledir. metot overriding ve overloading kavramlarını açıklayınız. overriding base classta bulunan bir metotun türettiğimiz classa özel halini yazmaktır isimleri aynıdır. overloading yine aynı isimli metotların farklı imzalara sahip tanımlanmasıdır aynı classın içinde olur. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? base 1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? parent+"" \n"" + 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? direkt aktarmak istiyorsak static yoksa dinamik java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? override edilemezler değiştirilemezler yani overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? dinamik çünkü değiştirilebilirler dinamik bağlamada jvm'nin görevi nedir? ---- java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? ----- java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? staticler olmadığı için öncelikli aktarım sırasında sorun yasanırdı class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? parent dinamik class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book statik java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 2 çeşittir . unchecked ve checked exceptions. unchecked exceptionlara runtime exceptionlar örnek verilebilir örneğin nullpointerexceptin. ioexception checked exceptionlara örnek verilebilir. java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? throws keywordu kullanarak attığımız exceptionlardır. eğer override edilmiş bir metotta bunu yapıyorsak throws yaptığımız exceptionun classı override ettiģimiz metotta throws yaptığımız exceptionun classından daha üst seviyede olamaz . finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally bloğu exception atılsa da atılmasa da her zaman çalıştırılır. java'da kendi exceptionunuzu nasıl tanımlarsınız? exception sınıfından bir class türeterek bu classta bir boş bir de string ifade alan olacak şekilde 2 contructor tanımlarım. constructorların içinde super metodunu çağırırım. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? handle edilmesi gerekilen exceptionu daha basitleştirmek. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenmez io exception exceptionun subclassıdır bu yüzden sıralamada önce o yazılmalıdır. trying m1 caught2 finally bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot { private string name; private string type; private int batterylevel;// 100 ile 0 arasında bir değer private boolean isoperational;// bataryası varsa true public robot() { name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } public robot(string name, string type, int batterylevel) { this.name = name; this.type = type; this.batterylevel = batterylevel; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public boolean getisoperational() { return isoperational; } public void setisoperational(boolean isoperational) { this.isoperational = isoperational; } public void charge() { batterylevel = 100; } public void printrobot() { system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + ""%"" + "" is operational: "" + isoperational); } } public class factorybase { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } import java.util.arraylist; public class quizq1 { public static void main(string[] args) { string str = ""a1b2""; system.out.println(); } public static void makearray(string str) { arraylist<string> strs = new arraylist<>(); string str1 = """"; for (int i = 0; i < str.length(); i++) { if (str.charat(0) - 'a' < 0 && str.charat(0) - 'a' >= 0) { str1 += str.charat(0); } if (str.charat(0) - 'a' >= 0) { str1 += (char) ((str.charat(0) - 'a') + 'a'); } if (str.charat(0) - 'a' >= 0) { str1 += (char) ((str.charat(0) - 'a') + 'a'); } } strs.add(str1); } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots = new arraylist<>(); public factory(string name, string location) { this.name = name; this.location = location; } public factory() { name = ""factory1""; location = ""moon""; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getlocatiion() { return location; } public void setlocation(string location) { this.location = location; } public arraylist<robot> getrobots() { return robots; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for (int i = 0; i < robots.size(); i++) { robots.get(i).setbatterylevel(100); } } public void printfactory() { system.out.println(""factory name: "" + name + "" location: "" + location + ""\nrobots operating here:""); for (int i = 0; i < robots.size(); i++) { robots.get(i).printrobot(); } } public void work() { for (int i = 0; i < robots.size(); i++) { robots.get(i).setbatterylevel(robots.get(i).getbatterylevel() * (75 / 100)); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public abstract void performtask(); } public class securityrobot extends abstractrobot { private boolean isarmed; public boolean getisarmed() { return isarmed; } @override public int getbatterylife() { return batterylife; } @override public void recharge() { batterylife = super.batterylife; } @override public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] scanning for threats... armed: "" + isarmed); batterylife -= 10; } else { system.out.println(""["" + modelname + ""] not enough battery to scan threats...""); } } securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } public void togglearmedmode() { isarmed = !isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; public int getcleaningpower() { return cleaningpower; } @override public int getbatterylife() { return batterylife; } @override public void recharge() { batterylife = super.batterylife; } cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } @override public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] cleaning in progress... cleaning power: "" + cleaningpower); batterylife -= 10; } else { system.out.println(""["" + modelname + ""] not enough battery to clean...""); } } public void boostcleaningpower(int cleaningpower, int miktar) { cleaningpower += miktar; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { cleaningrobot cleaningrobot = new cleaningrobot(modelname, batterylife, cleaningpower); robots.add(cleaningrobot); counter++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { securityrobot securityrobot = new securityrobot(modelname, batterylife, isarmed); robots.add(securityrobot); counter++; } public void performalltasks() { for (int i = 0; i < robots.size(); i++) { robots.get(i).performtask(); } } public void displayrobots() { for (int i = 0; i < robots.size(); i++) { if (robots.get(i).getclass() == cleaningrobot.class) { cleaningrobot r1 = (cleaningrobot) robots.get(i); system.out.println(""cleaning robot - model: "" + robots.get(i).getmodelname() + "", battery: "" + robots.get(i).getbatterylife() + "", cleaning power: "" + r1.getcleaningpower()); } else { securityrobot r2 = (securityrobot) robots.get(i); system.out.println(""security robot - model: "" + robots.get(i).getmodelname() + "", battery: "" + robots.get(i).getbatterylife() + "", armed: "" + r2.getisarmed()); } } } public void upgradecleaningrobots(int miktar) { for (int i = 0; i < robots.size(); i++) { if (robots.get(i).getclass() == cleaningrobot.class) { cleaningrobot r3 = (cleaningrobot) robots.get(i); r3.boostcleaningpower(r3.getcleaningpower(), miktar); system.out.println(""cleaningrobot - "" + robots.get(i).modelname + ""now has cleaning power:"" + r3.getcleaningpower()); } } } public void togglesecurityrobotsmode() { for (int i = 0; i < robots.size(); i++) { if (robots.get(i).getclass() == securityrobot.class) { securityrobot r4 = (securityrobot) robots.get(i); r4.togglearmedmode(); system.out.println(""securityrobot - "" + robots.get(i).modelname + ""is now "" + r4.getisarmed()); } } } public static int counter; public void allrobots() { system.out.println(""tum fabrikalar tarafindan toplam "" + counter + "" üretildi.""); } } public class main1 { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); anotherfactory.allrobots(); } } 1"
4540765,5,"4540765 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. package quiz1bil211nebiyanar; public class main { public static int collatz(int i,int count) { if(i==1) { return count ; } else if(i%2==0) { return collatz(i/2,count+1); } else { return collatz(3*i+1,count+1); } } public static void cocktailsort(int[] arr,int iteration) { //iteration 0 başlatılacak if(iteration==arr.length-1) { } else { if(iteration%2==0) { for(int i=0;i<arr.length-1;i++) { if(arr[i]>arr[i+1]) { int temp=arr[i]; arr[i]=arr[i+1]; arr[i+1]=temp; } } cocktailsort(arr, iteration+1); } else { for(int i=arr.length-1;i>0;i--) { if(arr[i-1]>arr[i]) { int temp=arr[i-1]; arr[i-1]=arr[i]; arr[i]=temp; } } cocktailsort(arr, iteration+1); } } } public static void main(string[] args) { //system.out.println(collatz(5,0)); sayac sayac=new sayac(""10001""); //system.out.println(sayac.say()); int[] arr1= {1,4,5,7,3,2}; cocktailsort(arr1, 0); for(int i=0;i<arr1.length;i++) { system.out.println(arr1[i]); } } } package quiz1bil211nebiyanar; public class sayac { static string str1; public sayac(string str) { str1=str; } public static int say() { return say(str1); } public static int say(string str1) { if(str1.length()==0) return 0; else { if(str1.charat(0)=='1') return 1+ say(str1.substring(1)); else { return say(str1.substring(1)); } } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 package lab2bil211nebiyanar; import java.util.list; public class muzikcalar { private calmastratejisi strateji; public void setstrateji(calmastratejisi strateji) { this.strateji = strateji; } public void muzikcal(list<sarki> sarkilistesi) { if (strateji != null) { strateji.cal(sarkilistesi); } } } package lab2bil211nebiyanar; import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki) ((metalsarki) sarki).gostermetalozellikleri(); } } } package lab2bil211nebiyanar; public class klasiksarki extends sarki { public klasiksarki(string isim,string sanatci) { this.isim=isim; this.sanatci=sanatci; // todo auto-generated constructor stub } void oynat() { system.out.println(""[klasi̇k] -""+sanatci+"" -""+isim+"" - (hafif ve sakin)""); } } package lab2bil211nebiyanar; public class metalsarki extends sarki { string metalozellik; public metalsarki(string isim,string sanatci,string metalozellik) { this.isim=isim; this.sanatci=sanatci; this.metalozellik=metalozellik; // todo auto-generated constructor stub } void gostermetalozellikleri() { system.out.println(""[metal] -""+sanatci+"" -""+isim+"" ""+""[ozellik: ""+metalozellik+""]""); } void oynat() { system.out.println(""[metal] -""+sanatci+"" -""+isim+"" -""+""(""+metalozellik+"")""); } } package lab2bil211nebiyanar; public class rocksarki extends sarki { public rocksarki(string isim,string sanatci) { this.isim=isim; this.sanatci=sanatci; // todo auto-generated constructor stub } void oynat() { system.out.println(""[rock] -""+sanatci+"" -""+isim+"" -(huzurlu ve nostaljik)""); } } package lab2bil211nebiyanar; import java.util.arraylist; import java.util.collections; import java.util.list; public class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { list<sarki> karisikliste = new arraylist<>(sarkilistesi); collections.shuffle(karisikliste); for (int i=0;i<karisikliste.size();i++) { karisikliste.get(i).oynat(); } } } package lab2bil211nebiyanar; import java.util.list; public class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (int i=0;i<sarkilistesi.size();i++) { sarkilistesi.get(i).oynat(); } } } package lab2bil211nebiyanar; public abstract class sarki { string isim; string sanatci; abstract void oynat(); } package lab2bil211nebiyanar; import java.util.list; public class rockcuozelcalma implements calmastratejisi { public void cal(list <sarki> sarkilistesi) { boolean isrock=false; for(int i=0;i<sarkilistesi.size();i++) { if(sarkilistesi.get(i) instanceof rocksarki && !isrock) { system.out.println(""[bilgi] ses duzeyi̇ yuksek""); isrock=true; } else if(!(sarkilistesi.get(i) instanceof rocksarki && isrock)) { system.out.println(""[bilgi] ses duzeyi̇ normal""); isrock=false; } sarkilistesi.get(i).oynat(); } } } package lab2bil211nebiyanar; import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true package q1bil211nebiyanar; public class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public robot() { this.name=""wall-e""; this.type=""trash""; this.batterylevel=100; this.isoperational=true; } public robot(string name,string type,int batterylevel) { this.name=name; this.type=type; this.batterylevel=batterylevel; if(this.batterylevel>0) { this.isoperational=true; } else { this.isoperational=false; } } public string getname() { return name; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public boolean isoperational() { return isoperational; } public void setoperational(boolean isoperational) { this.isoperational = isoperational; } public void charge() { this.batterylevel=100; } public void printrobot() { system.out.println(string.format(""robot name:%s robot type:%s trash battery level:"" + ""%d isoperational:%b"",name,type,batterylevel,isoperational)); } } package q1bil211nebiyanar; public class main { public static void main(string[] args) { factory factory=new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } package q1bil211nebiyanar; import java.security.permission; public class soru1 { public static void perm(string str,int index) { system.out.println(str); if(str.length()-1==index) { } else { if((str.charat(index)>=65&&str.charat(index)<=90)) { index++; perm(str.substring(0, index+1).tolowercase()+str.substring(index+1),index); } else if(str.charat(index)>=48 && str.charat(index)<=57) { index++; perm(str.substring(0, index+1).touppercase()+str.substring(index+1),index); } } } public static void main(string[] args) { perm(""a1b"", 0); } } package q1bil211nebiyanar; import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory() { this.name=""factory1""; this.location=""moon""; this.robots=arraylist <robot>(); } public factory(string name,string location) { this.name=name; this.location=location; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getlocation() { return location; } public void setlocation(string location) { this.location = location; } public arraylist<robot> getrobots() { return robots; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public void addrobot(robot robots1) { robots.addlast(robots1); } public void chargeallrobots() { for(int i=0;i<robots.size();i++) { robots.get(i).setbatterylevel(100); } } public void printfactory() { system.out.println(""factory name:""+name+"" location:""+location); for(int i=0;i<robots.size();i++) { robots.get(i).printrobot(); } } public void works() { for(int i=0;i<robots.size();i++) { robots.get(i).setbatterylevel(robots.get(i).getbatterylevel()-15); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 package q2bil211nebiyanar; public interface withbattery { int getbatterylife(); void recharge(); } package q2bil211nebiyanar; public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; int maxbattery; public abstractrobot(string modelname,int batterylife) { this.modelname=modelname; this.batterylife=batterylife; this.maxbattery=batterylife; } public string getmodelname() { return modelname; } public void recharge() { if(maxbattery<100) { this.batterylife=100; } else { this.batterylife=maxbattery; } } public int getbatterylife() { return batterylife; } public abstract void performtask(); } package q2bil211nebiyanar; public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.totalrobotproduced(); } } package q2bil211nebiyanar; public class securityrobot extends abstractrobot { private boolean isarmed; public securityrobot(string modelname,int batterylife,boolean isarmed) { super(modelname, batterylife); this.isarmed=isarmed; } public void performtask() { if(batterylife<10) { system.out.println(""[""+modelname+""] not enough battery to scan threads""); } else { system.out.println(""[""+modelname+""]"" + ""scanning for threads... armed:""+isarmed); batterylife-=10; } } public void tooglearmedmode() { if(isarmed) { isarmed=false; system.out.println(""securityrobot - ""+this.modelname+ "" is now unarmed""); } else { isarmed=true; system.out.println(""securityrobot - ""+this.modelname+ "" is now unarmed""); } } public boolean isarmed() { return isarmed; } public void setarmed(boolean isarmed) { this.isarmed = isarmed; } } package q2bil211nebiyanar; public class cleaningrobot extends abstractrobot { private int cleaningpower; public cleaningrobot(string modelname,int batterylife,int cleaningpower) { super(modelname, batterylife); this.cleaningpower=cleaningpower; } public int getcleaningpower() { return cleaningpower; } public void setcleaningpower(int cleaningpower) { this.cleaningpower = cleaningpower; } public void performtask() { if(batterylife<10) { system.out.println(""[""+modelname+""] not enough battery to clean""); } else { system.out.println(""[""+modelname+""] cleaning in progress .. cleaning power:""+cleaningpower); batterylife-=10; } } public void boostcleaningpower(int miktar) { this.cleaningpower+=miktar; system.out.println(""cleaningrobot - ""+this.modelname+"" now has cleaning power:""+this.cleaningpower); } } package q2bil211nebiyanar; import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots=new arraylist<abstractrobot>(); static int n=0; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); n++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); n++; } public void performalltasks() { for(int i=0;i<robots.size();i++) { robots.get(i).performtask(); } } public void displayrobots() { for(int i=0;i<robots.size();i++) { if(robots.get(i) instanceof cleaningrobot) { cleaningrobot r1=(cleaningrobot) robots.get(i); system.out.println(""cleaningrobot - model: ""+r1.getmodelname() +"", battery:""+r1.getbatterylife()+"", cleaning power:""+r1.getcleaningpower()); } else if(robots.get(i) instanceof securityrobot) { securityrobot r1=(securityrobot) robots.get(i); system.out.println(""securityrobot - model: ""+r1.getmodelname() +"", battery:""+r1.getbatterylife()+"", armed:""+r1.isarmed()); } } } public void upgradecleaningrobots(int miktar) { for(int i=0;i<robots.size();i++) { if(robots.get(i) instanceof cleaningrobot) { cleaningrobot r1=(cleaningrobot) robots.get(i); r1.boostcleaningpower( miktar); } } } public void togglesecurityrobotsmode() { for(int i=0;i<robots.size();i++) { if(robots.get(i) instanceof securityrobot) { securityrobot r1=(securityrobot) robots.get(i); r1.tooglearmedmode(); } } } public static void totalrobotproduced() { system.out.println(""tum fabrikalar tarafından ""+n+"" robot uretildi""); } } 5"
6418019,1,"6418019 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. package bil211_lab; public class sayac { string str; public sayac(string str){ this.str = str; } public int say1(string input){ if(input.length() == 0){ return 0; } if(input.charat(0) == '1'){ return 1 + say1(input.substring(1)); } else{ return say1(input.substring(1)); } } public int say(){ return say1(str); } } package bil211_lab; public class lab1 { public static void main(string[] args) { system.out.println(collatz(5)); int[] ar = {5, 4, 1, 2}; cocktailsort(ar); for(int i = 0; i<ar.length; i++){ system.out.println(ar[i]); } sayac s1 = new sayac(""10001""); system.out.println(s1.say()); } public static int collatz(int i){ if(i == 1){ return 0; } if(i%2 == 0){ return 1 + collatz(i/2); } else{ return 1 + collatz(i*3 + 1); } } public static void cocktailsort(int[] arr){ sort2(arr, 0, arr.length - 1, false); } public static void sort2(int[] array, int start, int end, boolean direction){ if(start >= end){ return; } if(direction == false){ for(int i = start; i < end; i++){ if(array[i] > array[i+1]){ int buyuk = array[i]; array[i] = array[i+1]; array[i+1] = buyuk; } } end--; } else{ for(int i = end; i>0; i-- ){ if(array[i] < array[i-1]){ int kucuk = array[i]; array[i] = array[i-1]; array[i-1] = kucuk; } } start++; } sort2( array,start, end, !direction); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arraylist; import java.util.arrays; import java.util.collections; import java.util.list; import javax.sound.sampled.sourcedataline; public class lab2 { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); arraylist<sarki> sarkilistesi = (arraylist)arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri:""); for(int i = 0; i < sarkilistesi.size(); i++){ sarki s = sarkilistesi.get(i); if(s instanceof metalsarki){ system.out.println( ((metalsarki)s).getisim + "" - "" + ((metalsarki)s).getsanatci ; } } } } abstract class sarki{ protected string isim; protected string sanatci; public string getisim() { return isim; } public string getsanatci() { return sanatci; } public void setisim(string isim) { this.isim = isim; } public void setsanatci(string sanatci) { this.sanatci = sanatci; } public abstract void oynat(); } class metalsarki extends sarki{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik){ setisim(isim); setsanatci(sanatci); this.metalozellik = metalozellik; } public void gostermetalozellikler(){ system.out.println(metalozellik); } public void oynat(){ system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" "" + ""("" + metalozellik + "")""); } } class rocksarki extends sarki{ public rocksarki(string isim, string sanatci){ setisim(isim); setsanatci(sanatci); } public void oynat(){ system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci){ setisim(isim); setsanatci(sanatci); } public void oynat(){ system.out.println(""[klasi̇k] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } interface calmastratejisi{ void cal(arraylist<sarki> sarkilistesi); } class siralicalma implements calmastratejisi{ public void cal(arraylist<sarki> sarkilistesi){ system.out.println(""sirali calma""); for(int i = 0; i<sarkilistesi.size(); i++){ sarki s = sarkilistesi.get(i); if(s instanceof metalsarki){ ((metalsarki)s).oynat(); } else if(s instanceof rocksarki){ ((rocksarki)s).oynat(); } else if(s instanceof klasiksarki){ ((klasiksarki)s).oynat(); } } } } class karisikcalma implements calmastratejisi{ public void cal(arraylist<sarki> sarkilistesi){ collections.shuffle(sarkilistesi); system.out.println(""karisik calma""); for(int i = 0; i<sarkilistesi.size(); i++){ sarki s = sarkilistesi.get(i); if(s instanceof metalsarki){ ((metalsarki)s).oynat(); } else if(s instanceof rocksarki){ ((rocksarki)s).oynat(); } else if(s instanceof klasiksarki){ ((klasiksarki)s).oynat(); } } } } class rockcuozelcalma implements calmastratejisi{ public void cal(arraylist<sarki> sarkilistesi){ boolean sesduzeyi = false; system.out.println(""rockcuozelcalma calma""); for(int i = 0; i<sarkilistesi.size(); i++){ sarki s = sarkilistesi.get(i); if(s instanceof metalsarki){ ((metalsarki)s).oynat(); } else if(s instanceof rocksarki && sesduzeyi == false){ sesduzeyi = true; system.out.println(""[bi̇lgi̇] ses duzeyi: yuksek""); ((rocksarki)s).oynat(); } else if(s instanceof rocksarki && sesduzeyi == true){ ((rocksarki)s).oynat(); system.out.println(""[bi̇lgi̇] ses duzeyi: normal""); } else if(s instanceof klasiksarki){ ((klasiksarki)s).oynat(); } } } } class muzikcalar{ calmastratejisi strateji; public void setstrateji(calmastratejisi strateji){ this.strateji = strateji; } public void muzikcal(arraylist<sarki> sarkilistesi){ if(strateji instanceof siralicalma){ siralicalma sira = (siralicalma) strateji; sira.cal(sarkilistesi); } else if(strateji instanceof karisikcalma){ karisikcalma karisik = (karisikcalma) strateji; karisik.cal(sarkilistesi); } } } ""recursion"" kavramı nedir, kısaca açıklayınız. bir methodunun kendi kendini çağırması recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base durum: recursion a girmeden en basit case, decomposition: problemi daha küçük problemlere ayrıdığımız kısım, composition: jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. - int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. iteratif olarak for döngüsü yerine recursive yapmak daha verimlidir bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? - stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. recursionun sonsuz bir döngüye girmesi tail recursion nedir, kısaca açıklayınız. - abstraction kavramını açıklayınız. gerekli bilgileri alıp geri kalan bilgileri gizlemek, blackbox a almak dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür cünkü employee hourlyemployee nin atasıdır. tersi mümkün degildir protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? protected java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? ata class ın constructorını çağırmak ve bilgilerli almak için java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? mümkün değildir, her class bir üstündeki classı extend etmeli java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? verilen değişkenlerin typelarının aynı olup olmadıgına ve aralarında kalıtım ilişkisi var mı ona bakar. aralarındaki ilişki: typeları aynıdır ve b, a nın atasıdır metot overriding ve overloading kavramlarını açıklayınız. overriding: metotların signatureları aynıdır, metodu child classın özelliklerine göre tekrar düzenleriz. overloading: metotların isimleri aynıdır ama parametreler farklıdır. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? - class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class içinde normal metod ya da abstract metod olabilir. abstract metodun gövdesi olmaz ve bu bu classı extend eden classta abstract metodlar override edilmelidir. abstract classtan bir obje yaratamayız. abstract classların constructoru olabilir ama interfacelerin olmaz abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? abstarct classi extend eden baska bir abstarct classta implement edilebilir abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract metodun body si olmaz abstract class icinde abstract olmayan metod ya yazabiliriz abstract classlar sayesinde subclasslara abstarct metodlari zorunlu kılmış oluruz abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract classlar tip olarak kullanılamaz ama interfaceler kullanılabilir. interfacelerde metodlar otomatik public abstract olarak tanımlanır marker interface ve functional interface kavramları nedir, nasıl kullanılır? - bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? bir class birden çok interface implement edebilir. bir interface baska bir interfacei implement edebilir. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abstarct classtan obje yaratamayiz, circle c = new circle(); yaparız output: drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? - java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 3 çeşittir: compile time error: syntax hataları örneğin parantezin unutulması, runtime error: sıfıra bölme , logical error: programın çalışıp istenilen sonucu vermemesi. java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? checked türündeki hatalar icin kullanılır. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? - java'da kendi exceptionunuzu nasıl tanımlarsınız? o exception adı ile bir class oluştururum. bu class exception classını override etmelidir. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? - static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught -1 finally oops done static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? - bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public robot(string name,string type, int batterylevel, boolean isoperational ){ this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = isoperational; } public robot(){ this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public string getname(){ return name; } public void setname(string name){ this.name = name; } public string gettype(){ return type; } public void settype(string type){ this.type = type; } public int getbatterylevel(){ return batterylevel; } public void setbatterylevel(int batterylevel){ this.batterylevel = batterylevel; } public boolean getisoperational(){ return isoperational; } public void setisoperational(boolean isoperational){ this.isoperational = isoperational; } public void charge(){ batterylevel = 100; } public void printrobot(){ system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + "" isoperational: "" + isoperational); } } public class q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55, true); robot r3 = new robot(""r2-d2"", ""astromech"", 80, true); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name, string location){ this.name = name; this.location = location; } public factory(){ this.name = ""factory1""; this.location = ""moon""; } public string getname(){ return name; } public void setname(string name){ this.name = name; } public string getlocation(){ return location; } public void setlocation(string location){ this.location = location; } public void addrobot(robot robot){ robots.addlast(robot); } public void chargeallrobots(){ for(int i=0; i<robots.size(); i++){ robots.get(i).setbatterylevel(100); } } public void printfactory(){ for(int i=0; i<robots.size(); i++){ robots.get(i).printrobot();; } } public void work(){ for(int i=0; i<robots.size(); i++){ int a = robots.get(i).getbatterylevel(); robots.get(i).setbatterylevel((a*75)/100); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife){ this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname(){ return modelname; } public int getbatterylife() { return batterylife; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); int sayi = robotfactory.sayi; system.out.println(""tüm fabrikalar tarafindan toplam "" + sayi + "" robot üretildi""); } } public class securityrobot extends abstractrobot { private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed){ super(modelname, batterylife); this.isarmed = isarmed; } public boolean isarmed() { return isarmed; } public void recharge(){ batterylife = 100; } public void performtask(){ if(batterylife >= 10){ system.out.println(""["" + modelname + ""]"" + "" scanning for threats... "" + "" armed:"" + isarmed); batterylife = batterylife - 10; } else{ system.out.println(""["" + modelname + ""]"" + "" not enough battery to scan threats...""); } } public void togglearmedmode(){ isarmed = !isarmed; } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; public cleaningrobot(string modelname, int batterylife, int cleaningpower){ super(modelname, batterylife); this.cleaningpower = cleaningpower; } public int getcleaningpower() { return cleaningpower; } public void setcleaningpower(int cleaningpower) { this.cleaningpower = cleaningpower; } public void recharge(){ batterylife = 100; } public void performtask(){ if(batterylife >= 10){ system.out.println(""["" + modelname + ""]"" + "" cleaning in progress..."" + "" cleaning power:"" + cleaningpower); batterylife = batterylife - 10; } else{ system.out.println(""["" + modelname + ""]"" + "" not enough battery to clean...""); } } public void boostcleaningpower(){ cleaningpower = cleaningpower + 20; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; static int sayi; public robotfactory(){ robots = new arraylist<>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ cleaningrobot newcleaningrobot = new cleaningrobot(modelname, batterylife, cleaningpower); robots.add(newcleaningrobot); sayi++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ securityrobot newsecurityrobot = new securityrobot(modelname, batterylife, isarmed); robots.add(newsecurityrobot); sayi++; } public void performalltasks(){ for(int i=0; i<robots.size(); i++){ robots.get(i).performtask(); } } public void displayrobots(){ for(int i = 0; i<robots.size(); i++){ if(robots.get(i) instanceof cleaningrobot){ cleaningrobot c = (cleaningrobot) robots.get(i); system.out.println(""cleaningrobot - model: "" + c.getmodelname()+ "", battery: "" + c.getbatterylife() + "", cleaning power: "" + c.getcleaningpower()); } else if(robots.get(i) instanceof securityrobot){ securityrobot s = (securityrobot) robots.get(i); system.out.println(""securityrobot - model: "" + s.getmodelname()+ "", battery: "" + s.getbatterylife() + "", armed: "" + s.isarmed()); } } } public void upgradecleaningrobots(int miktar){ for(int i = 0; i<robots.size(); i++){ if(robots.get(i) instanceof cleaningrobot){ cleaningrobot c = (cleaningrobot) robots.get(i); int power = c.getcleaningpower() + miktar; c.setcleaningpower(power); system.out.println(""cleaningrobot - "" + c.getmodelname() + "" now has cleaning power: "" + c.getcleaningpower() ); } } } public void togglesecurityrobotsmode(){ for(int i = 0; i<robots.size(); i++){ if(robots.get(i) instanceof securityrobot){ securityrobot s = (securityrobot) robots.get(i); s.togglearmedmode(); if(s.isarmed() == false){ system.out.println(""securityrobot - "" + s.getmodelname() + "" is now unarmed "" ); } else{ system.out.println(""securityrobot - "" + s.getmodelname() + "" is now armed "" ); } } } } } 1"
4114373,1,"4114373 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q3 { public static void main(string[] args){ sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); } } class sayac{ string str; public sayac(string str){ this.str = str; } public int say(){ if(str.indexof('1')==-1){ return 0; } else{ str = str.substring(str.indexof('1')+1, str.length()); return say() + 1; } } } public class lab1q2 { public static void main(string[] args){ int[] a = {5,4,1,2}; cocktailsort(a); } public static void cocktailsort(int[] arr){ boolean flag = false; for(int i = 1; i < arr.length; i++){ if(arr[i-1]>arr[i]){ int temp = arr[i]; arr[i] = arr[i-1]; arr[i-1] = temp; flag = true; } } if(!flag){ for(int i = 0; i < arr.length; i++){ system.out.print(arr[i] + "" ""); } } else{ cocktailsort(arr); } } } public class lab1q1 { public static void main(string[] args){ system.out.println(collatz(5)); } public static int collatz(int i){ if(i == 1){ return 0; } if(i%2==0){ return collatz(i/2) + 1; } else{ return collatz(3*i + 1) + 1; } } } ""recursion"" kavramı nedir, kısaca açıklayınız. recursion, aynı fonksiyonun kendi içerisinde base condition sağlanana kadar çağırılmasıdır. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. recursive metod, fonksiyonun halletmesi gereken ana problem, diğer fonksiyona(aynı fonksiyon) yollayacağı problem ve en son da çözecek bir şey kalmayınca çıkması gereken kısım olan base conditiondan oluşur. jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. . bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? string'in ölçecek elemanının kalmaması (0'a eşit olması) stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack kod içerisinde çağırdığımız fonksiyonun içindeki verileri ilk çağırılandan son çağırılana kadar çağırması, ve eğer recursion yaparken base condition hiçbir zaman sağlanmazsa stack sonsuza kadar dolmaya devam eder ve stack overflow olmuş olur. tail recursion nedir, kısaca açıklayınız. tail recursion, recursion'un her defasında return olması yerine en son çağırdığımız fonksiyonda return edip en başa dönmesidir. abstraction kavramını açıklayınız. abstraction bir işlevin nasıl çalıştığına değil ne yaptığına bakan, gereksiz detaylara boğulmadan istenileni vermesine denilen kavramdır. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? employee, hourlyemployee'nin parenti oldugu için hourlyemployee is a employee deriz yani mümkün olur ama employee is hourlyemployee olmadığı için mümkün olmaz. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? protected: class, package ve subclass default: class ve package olduğundan dolayı default private'e daha yakındır. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? çünkü parentta bulunan her şey child'da da vardır ve bu yüzden objeyi oluştururken tüm değişkenleri ayarlamak istiyorsak bi üstteki parent'in constructerini çağırmak zorundayız. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır mümkün değildir çünkü b'de ve c'de aynı metotlar veya değişkenler olabilir. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? getclass() gibi class'ın kendisine de bakıp aynı zamanda parent'larının da eşit olmasını döndürür metot overriding ve overloading kavramlarını açıklayınız. metot override: tamamen aynı olan metotlar, metot overloading: dönüş tipi hariç her şeyi aynı olan metotlar class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? output: class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? eğer metot override edilmişse dynamic binding, edilmemişse static binding yapilir. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? çünkü static, private ve final metotlara override yapılmaz bu yüzden de dynamic binding'e gerek olmaz. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? dynamic binding gerçekleşir çünkü aynı adda olan iki ayrı metotu çağırırken java'nın hangi metodu çağırmasını hesaplaması gerekiyor. dinamik bağlamada jvm'nin görevi nedir? jvm'nin görevi referans edilen en parent class'tan başlayarak oluşturulan child objesine doğru gelerek her class'ta metodun override edilmiş olup olmadığını hesaplayıp bularak, doğru metodu çağırmasıdır. java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? parent objenin içerdiği her şeyi child obje içerir fakat child objenin içerdiği her şeyi (metod, değişken vs.) parent obje içermez. bu yüzden parent p = new child(); yapılabilirken child c = new parent(); yapılamaz. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? tüm bindingler dinamik olsaydı child classta çağırdığımız ve child class'a özgü olan bir override metodu çağıramazdık. class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? parent referansıyla bir child object oluşturulduğu için o referanstan çağırdığımız child objesinin parenttaki metod yerine child'daki override edilmiş metodu çağırmasını istediğimiz için dinamik bağlama. class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? i̇lk objede statik bağlama, ikinci objede dinamik bağlama java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class o class içerisine daha sonra implement etmek istediğimiz özellikleri önceden yazabilmemizi sağlayan class türüdür. constructor'u olamaz çünkü abstract class'tan obje oluşturulamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? eğer parent class içerisinde tanimladigimiz abstract metodlarin hepsini child classin içinde implement etmek istemiyorsak child class olrak abstract metodlar harici olusturdugumuz bir abstract class var olabilir. bu class'ta parent class içinde yaptığımız abstract metotlari implement edebiliriz. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract metotlar programın daha iyi okunmasını sağlar. aynı zamanda program için bir şema görevi görür. abstract class ile farklı insanlar aynı proje içinde daha kolay çalışabilirler çünkü abstract class'larin içindeki her metodu bilmek zorunda kalmazlar, herkes kendi bildiği/yapması gereken yeri yaparak işbirliği içinde çalışabilir. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract class veya interface'lerden obje oluşturulamaz. i̇nterface'in abstract class'tan farkı ise içerisindeki tüm metotların/degiskenlerin tanimlanmayacak oluşudur. yani bir abstract class tamamen abstract metotlar içermek zorunda değildir ama interface tamamen bir kara kutu gibi çalışır, yani içerisinde hiçbir şey yoktur, isimlerden başka. marker interface ve functional interface kavramları nedir, nasıl kullanılır? - bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? bir class birden fazla interface'i implement edemez. bir interface başka bir interface'i implement edebilir. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abstract olan bir class'tan obje oluşturulamaz. eğer abstract classi aktardığımız class'tan bir obje oluşturmak istiyorsak ""circle c = new circle();"" kullanabiliriz. hata duzeldikten sonra da, ""drawing circle \n displaying"" yazılır. interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? interface'lerin içindeki metotların ne yaptığı interface içinde tanımlanamaz. ayrıca class c'deki public void show() metodu implement ettiği iki interface'in hangisinin çağırılacağını bilemez. bu yüzden class c'deki metotta direkt olarak ""a"" veya ""b"" yazdıran bir metot yazılabilir. java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. - java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? throws kullanırken child classi yazarsak catch içinde parent class'i cagiramayiz. bu yüzden eğer birden fazla hata catch etmek istiyorsak tüm hataların ortak atasını(parentini) throws ile almalıyız finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally bloğundaki kodlar, try'da throw edilen hata catch'de yakalansa da yakalanmasa da çağrılır java'da kendi exceptionunuzu nasıl tanımlarsınız? bir class oluşturarak, ismine oluşturmak istedigimiz hata adını yazarak throwable classini extend edip, olusturmak istediğimiz durumu if'le yazdıktan sonra o durumun içinde hatamızı tanımlıyoruz, daha sonra o hatanin olup olmadığı yerde kontrol için yazdigimiz classta olusturdugumuz hata classini 'throws' ile alıp, catch içinde o hatayı tanimlayarak yazıyoruz. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? o class tam olarak o sorunu çözememiş ise bir sonraki parent'a fırlatır ve hata orda çözülür static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught -1 finally oops done static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? burada m1()deki ioexception m2() içerisine gittiğinde catch'de ilk olarak exception olarak yakalanır bu yüzden de caught1 yazar yani caught2 yazmamış olur, çünkü try catch okunurken yukardan başlanarak aşağı inilir bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true import java.util.arraylist; public class quiz1q2 { public static void main(string[] args){ factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } class robot{ private string name; private string type; private int batterylevel; private boolean isoperational; public robot(){ this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public robot(string name, string type, int batterylevel){ this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = true; } public void printrobot(){ system.out.print(""robot name: "" + name); system.out.print("" robot type: "" + type); system.out.print("" battery level: "" + batterylevel + ""%""); system.out.print("" is operational: "" + isoperational); } public string getname(){ return name; } public string gettype(){ return type; } public int getbatterylevel(){ return batterylevel; } public boolean getisoperational(){ return isoperational; } public void setname(string name){ this.name = name; } public void settype(string type){ this.type = type; } public void setbatterylevel(int batterylevel){ this.batterylevel = batterylevel; } public void setisoperational(boolean isoperational){ this.isoperational = isoperational; } public void charge(){ batterylevel = 100; } } class factory{ private string name; private string location; private arraylist<robot> robots = new arraylist<robot>(); public factory(){ this.name = ""factory1""; this.location = ""moon""; } public factory(string name, string location){ this.name = name; this.location = location; } public string getname(){ return name; } public string getlocation(){ return location; } public arraylist getrobots(){ return robots; } public void setname(string name){ this.name = name; } public void setlocation(string location){ this.location = location; } public void addrobot(robot robot){ robots.add(robot); } public void chargeallrobots(){ for(int i = 0; i < robots.size(); i++){ robots.get(i).setbatterylevel(100); } } public void printfactory(){ system.out.println(""factory name: "" + name + "" location: "" + location); system.out.println(""robots operating here:""); for(int i = 0; i < robots.size(); i++){ robots.get(i).printrobot(); system.out.println(); } } public void work(){ for(int i = 0; i < robots.size(); i++){ robots.get(i).setbatterylevel(robots.get(i).getbatterylevel()-15); } } } import java.util.arraylist; public class quiz1q1 { public static void main(string[] args){ system.out.println(combination(""a1b2"").tostring()); } public static arraylist combination(string s){ int c = 0; for(int i = 0; i < s.length(); i++){ if((s.charat(i)>=65 && s.charat(i)<91) || (s.charat(i)>=97 && s.charat(i)<123)){ c += 1; } } arraylist<string> a = new arraylist<string>(); boolean flag = true; while(flag){ for(int i = 0; i < s.length(); i++){ if(s.charat(i)>=65 && s.charat(i)<91){ if(!a.contains(s)){ a.add(s); } else{ s = s.substring(0, i+1) + s.substring(i+1,s.length()).tolowercase(); } s = s.substring(0, i) + (char)(s.charat(i)+32) + s.substring(i+1, s.length()); } else if(s.charat(i)>=97 && s.charat(i)<123){ if(!a.contains(s)){ a.add(s); } else{ s = s.substring(0, i+1) + s.substring(i+1,s.length()).touppercase(); } s = s.substring(0, i) + (char)(s.charat(i)-32) + s.substring(i+1, s.length()); } } if(a.size()==math.pow(2, c)){ flag = false; } } return a; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery{ protected string modelname; protected int defaultbattery; protected int batterylife; public abstractrobot(string modelname, int batterylife){ this.modelname = modelname; this.batterylife = batterylife; this.defaultbattery = batterylife; } public string getmodelname(){ return modelname; } public int getbatterylife(){ return batterylife; } public void recharge(){ this.batterylife = defaultbattery; } public abstract void performtask(); public abstract void boostcleaningpower(int miktar); public abstract void togglearmedmode(); public abstract string tostring(); public abstract int getcleaningpower(); public abstract boolean getarmedmode(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.printnumberofrobots(); } } public class securityrobot extends abstractrobot{ private boolean isarmed; public boolean getarmedmode(){ return isarmed; } public securityrobot(string modelname, int batterylife, boolean isarmed){ super(modelname, batterylife); this.isarmed = isarmed; } public void performtask(){ if(batterylife>=10){ system.out.println(""["" + modelname + ""] "" + ""scanning for threats... armed: "" + isarmed); batterylife -= 10; } else{ system.out.println(""["" + modelname + ""] not enough battery to scan threats...""); } } public void togglearmedmode(){ if(isarmed){ isarmed = false; } else{ isarmed = true; } } public string tostring(){ return ""security robot - model: "" + modelname + "", battery: "" + batterylife + "", armed: "" + isarmed + ""\n""; } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; public int getcleaningpower(){ return cleaningpower; } cleaningrobot(string modelname, int batterylife, int cleaningpower){ super(modelname, batterylife); this.cleaningpower = cleaningpower; } public void performtask(){ if(batterylife>=10){ system.out.println(""["" + modelname + ""] "" + ""cleaning in progress... cleaning power: "" + cleaningpower); batterylife -= 10; } else{ system.out.println(""["" + modelname + ""] not enough battery to clean...""); } } public void boostcleaningpower(int power){ this.cleaningpower += power; } public string tostring(){ return ""cleaning robot - model: "" + modelname + "", battery: "" + batterylife + "", cleaning power: "" + cleaningpower + ""\n""; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); public static int robotsayisi = 0; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); robotsayisi += 1; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ robots.add(new securityrobot(modelname, batterylife, isarmed)); robotsayisi += 1; } public void performalltasks(){ for(int i = 0; i < robots.size(); i++){ robots.get(i).performtask(); } } public void displayrobots(){ for(int i = 0; i < robots.size(); i++){ system.out.print(robots.get(i).tostring()); } } public void upgradecleaningrobots(int miktar){ for(int i = 0; i < robots.size(); i++){ if(robots.get(i) instanceof cleaningrobot){ robots.get(i).boostcleaningpower(miktar); system.out.println(""cleaning robot - "" + robots.get(i).modelname + "" now has cleaning power: "" + robots.get(i).getcleaningpower()); } } } public void togglesecurityrobotsmode(){ for(int i = 0; i < robots.size(); i++){ if(robots.get(i) instanceof securityrobot){ robots.get(i).togglearmedmode(); if(robots.get(i).getarmedmode()){ system.out.println(""security robot - "" + robots.get(i).modelname + "" is now armed""); } else{ system.out.println(""security robot - "" + robots.get(i).modelname + "" is now unarmed""); } } } } public static void printnumberofrobots(){ system.out.println(""tüm fabrikalar tarafından toplam "" + robotsayisi + "" robot üretildi.""); } } 1"
1280995,0,"1280995 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. package test; public class collatz{ public static void main(string[] args){ system.out.println(collatz(5)); } public static int collatz(int i){ if (i == 1) return 0; else if (i%2==0){ return 1 + collatz(i/2); } else { return 1 + collatz(i*3+1); } } } package test; public class cocktail{ public static void main(string[] args){ int[] arr = {5,4,1,2}; cocktailsort(arr); //printer for (int i = 0; i < arr.length; i++){ system.out.print(arr[i] + "",""); } } public static void cocktailsort(int[] arr){ bubble(arr, 0, arr.length - 1, false); } public static void bubble(int[] arr, int start, int end, boolean rightway){ rightway = true; if (start == end && !isordered(arr) && rightway){ rightway = false; bubble(arr, arr.length - 1, 0, rightway); return; } if (start == end && !isordered(arr) && !rightway){ rightway = true; bubble(arr, 0, arr.length, rightway); return; } else if (start == end && isordered(arr)) { return; } else if (end > start) { if (arr[start] > arr[start + 1]){ int temp = arr[start + 1]; arr[start + 1] = arr[start]; arr[start] = temp; } bubble(arr, start + 1, end, rightway); return; } else if (start > end) { if (arr[start - 1] > arr[start]){ int temp = arr[start - 1]; arr[start - 1] = arr[start]; arr[start] = temp; } bubble(arr, start - 1, end, rightway); return; } } public static boolean isordered(int[] arr){ for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) return false; } return true; } } package test; public class sayac{ string s; public sayac(string s) { this.s = s; } public int say(){ if (s.indexof('1') == -1) return 0; else { s = s.substring(0,s.indexof('1')) + ""0"" + s.substring(s.indexof('1') + 1,s.length()); return 1 + say(); } } } class testing{ public static void main(string[] args){ sayac s1 = new sayac(""1001""); sayac s2 = new sayac(""1111""); system.out.println(s2.say()); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; import java.util.arraylist; import java.util.arrays; import java.util.random; abstract class sarki { sarki(){} string isim; string sanatci; abstract void oynat(); sarki(string isim, string sanatci){ this.isim = isim; this.sanatci = sanatci; } } class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik){ this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void oynat(){ system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } void gostermetalozellikleri(){ system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" [ozellik: "" + metalozellik + ""]""); } } class rocksarki extends sarki { rocksarki(string isim, string sanatci){ this.isim = isim; this.sanatci = sanatci; } //? void oynat(){ system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } class klasiksarki extends sarki { klasiksarki(string isim, string sanatci){ this.isim = isim; this.sanatci = sanatci; } // bi tane daha? void oynat(){ system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } interface calmastratejisi { void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi){ //liste sırasında çal for (sarki sarki : sarkilistesi){ sarki.oynat(); } system.out.println(); } siralicalma(){} } class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi){ //her şarkı bir kere çalınmak üzere karışık çal random random = new random(); list<sarki> karisik = new arraylist<sarki>(sarkilistesi); while (!karisik.isempty()){ int nextint = random.nextint(karisik.size()); karisik.get(nextint).oynat(); karisik.remove(nextint); } system.out.println(); } karisikcalma(){} } class rockcuozelcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi){ //liste sırasında çal rocksarki çalarken sesi yükselt, diğerlerinde normale döndür. //ardışık şarkılarda sadece baştakinde işlemi yap, değilse aynı kalsın. boolean sesnasil = false; for (sarki sarki : sarkilistesi){ if(sarki instanceof rocksarki && sesnasil == false){ sesnasil = true; system.out.println(""[bilgi] ses duzeyi: yuksek""); } else if (!(sarki instanceof rocksarki) && sesnasil == true){ sesnasil = false; system.out.println(""[bilgi] ses duzeyi: normal""); } sarki.oynat(); } system.out.println(); } rockcuozelcalma(){} } class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s){ //değiştiriyor strateji = s; } void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } public class muziklisey { public static void main(string[] args){ // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { metalsarki a = new metalsarki("""", """", """"); a = (metalsarki)sarki; a.gostermetalozellikleri(); } } } } ""recursion"" kavramı nedir, kısaca açıklayınız. kendini çağıran metod tekniği. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case ve tekrar eden case. jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. normal metod gibi çağırıyor? hangi açıdan anlamadım. int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. i̇teratif yöntemin recursive yöntemden çoğu durumda daha verimli olduğu bilgisinden yola çıkarak iteratif derim. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? ?? stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack jvm hafızasında ayrılan bir bölüm. hafıza aşılırsa overflow olur. bir recursion metodunun base case'inin düzgün çalışmaması sebep olabilir. tail recursion nedir, kısaca açıklayınız. recursive case'in sonda olduğu recursion türü. abstraction kavramını açıklayınız. yazacağımız kod için gerekli olan kavramları, kontekste bağlı değişen kavramlardan ayrıştırmak. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür, eğer hourlyemployee bunun alt sınıfı ise. tersi mümkün değil. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier daha yakın. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? çünkü hepsi constructor ile bir instance üretmek için object sınıfına refer ediyor. biz yazmazsak da jvm otomatik hallediyor. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır. her class sadece bir class'ı extend edebilir. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? instanceof operatörü soldaki ifadenin sağdakinin bir instance'ı (aynı sınıf ve objesi, veya alt sınıflardan biri veya onlardan birinin objesi) mı diye bakar. a b'den derive edilen herhangi bir şey olabilir. metot overriding ve overloading kavramlarını açıklayınız. overriding var olan başka bir metod ile aynı signature ile bir metod yazmaktır, böylece metod alt sınıflarda farklı davranabilir (polymorphism). overloading ise aynı isimde ancak imzaları farklı olan birden fazla metod yazılmasıdır. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? base class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? dynamic binding instance metodları için yapılır, static binding ise diğerleri için. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? objeden bağımsız çalışmaları. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? dynamic binding. dinamik bağlamada jvm'nin görevi nedir? metod call'ının hangi metod bloğunu çağırdığını anlamak. java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? is-a mantığından ötürü. hayvan bir canlıdır ama her canlı hayvan değildir. bundan ötürü implicit şekilde upcast yapmamıza java izin verir. ama tersi söz konusu olmadığı için implicit şekilde yapamayız. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik bağlama. class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik bağlama. java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class'ların metodları tanımlanmak zorunda değil, bu işi onu extend eden class'lara bırakabilir. constructor'ları olur ama bu super'i çağırsın diye, o class'dan obje üretemeyiz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? başına default keyword'ü koyarak default bir mekanizma implement edilebilir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. metodun oluşturulmasını erteleyebilmemizi veya başka birine bırakabilmemizi sağlar. inherit eden class'larda polymorphism olmasını sağlar/gerektirir. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract class'larda her metod abstract olacak diye bir kural yok, ancak interface'lerin içeriği %100 abstract'tir. tip olarak kullanamayız. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface bir sıfat gibi işler, bir class'a o sıfatı atfetmemizi sağlar. i̇çi boş bir interface tanımından ibarettir. functional interface ne bilmiyorum. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? i̇kisi de mümkün. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? shape'den obje üretemeyiz, çünkü abstract class. circle'dan üretirsek alacağımız sonuç: drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? compile edilemez, belirsizlik var. implement ettiğimiz bağımsız iki interface'de aynı signature'e sahip iki metod var. super.show() yerine örneğin eğer a interface'indekini kullanmak istiyorsak a.show() diyebiliriz, bu durumda output a olur. java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. runtime ve java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? override eden metodun override ettiği metod'a göre ya eşit, ya da daha dar bir throwable kapsamına sahip olması, veya direkt throws ifadesinin kaldırılması gerekir. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally bloğu her daim işletilen bir kod bloğudur. catch'e girilirse de girilmezse de çalışır. catch'in içinde return edilir ve bloktan çıkılırsa da çalışır. java'da kendi exceptionunuzu nasıl tanımlarsınız? exception sınıfını extend ederek yeni bir exception sınıfı oluşturarak. bunun içinde exception'un bakacağı kondisyonları ve hangi durumda exception fırlatacağını if case'leri ile kontrol edebiliriz. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caughtfinallyoopsdone41 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? unreachable code mevcut. exception bloklarından biri silinmeli. bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true import java.util.arraylist; class robot { private string name; private string type; private int batterylevel; // 100 ile 0 arasında bir değer private boolean isoperational; // bataryası varsa true public string getname(){ return new string(name); } public void setname(string s){ name = s; } public string gettype(){ return new string(type); } public void settype(string s){ type = s; } public int getbatterylevel(){ return batterylevel; } public void setbatterylevel(int i){ if (i <= 100 && i >= 0){ batterylevel = i; if (i > 0) isoperational = true; else isoperational = false; } else system.out.println(""that's an invalid amount.""); } public boolean getisoperational(){ return isoperational; } // yazdım ama pek anlamlı bir metod değil, 100'ken niye false'a çekebileyim örneğin // public void setisoperational(boolean bool){ // isoperational = bool; //} public void charge(){ batterylevel = 100; isoperational = true; } public robot(){ name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } public robot(string name, string type, int batterylevel){ this.name = name; this.type = type; if (batterylevel <= 100 && batterylevel >= 0) this.batterylevel = batterylevel; else { system.out.println(""that's an invalid number for the battery level. it will be set to 100%.""); this.batterylevel = 100; } if (batterylevel > 0) isoperational = true; else isoperational = false; } public void printrobot(){ system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + ""%"" + "" is operational: "" + isoperational); } } class factory { private string name; private string location; private arraylist<robot> robots; public string getname(){ return new string(name); } public void setname(string s){ name = s; } public string getlocation(){ return new string(location); } public void setlocation(string s){ location = s; } public void addrobot(robot robot){ robots.add(robot); } public void chargeallrobots(){ for (int i = 0; i < robots.size(); i++) { robots.get(i).charge(); } } public factory(string name, string location){ this.name = name; this.location = location; robots = new arraylist<>(); } public factory(){ name = ""factory1""; location = ""moon""; robots = new arraylist<>(); } public void printfactory(){ for (int i = 0; i < robots.size(); i++) { robots.get(i).printrobot(); } } public void work(){ for (int i = 0; i < robots.size(); i++){ int current = robots.get(i).getbatterylevel(); if (current >= 15) current -= 15; else current = 0; robots.get(i).setbatterylevel(current); } } } public class robottest { public static void main(string[] args){ factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 24); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } public class casecombo { public static void main(string[] args){ string s = ""a1b2c3d4""; casecombo(s, 0); } public static void casecombo(string s, int i){ if (i == 0){ system.out.println(s); } // string'i alalım. index'deki harf mi diye bakalım. harfse bir büyük yapalım bir küçük yapalım ve ekrana yazdıralım. // sonra index'i bir arttırarak metodu tekrar çağıralım. index == length olunca sadece yazdırsın. if (i == s.length() - 1){ if ((int) s.charat(i) >= 65 && s.charat(i) <= 90){ s = s.substring(0, i) + (char)(s.charat(i) + 32) + s.substring(i + 1, s.length()); system.out.println(s); } else if ((int) s.charat(i) >= 97 && s.charat(i) <= 122){ s = s.substring(0, i) + (char)(s.charat(i) - 32) + s.substring(i + 1, s.length()); system.out.println(s); } } else { if ((int) s.charat(i) >= 65 && s.charat(i) <= 90){ casecombo(s, i + 1); s = s.substring(0, i) + (char)(s.charat(i) + 32) + s.substring(i + 1, s.length()); system.out.println(s); casecombo(s, i + 1); } else if ((int) s.charat(i) >= 97 && s.charat(i) <= 122){ casecombo(s, i + 1); s = s.substring(0, i) + (char)(s.charat(i) - 32) + s.substring(i + 1, s.length()); system.out.println(s); casecombo(s, i + 1); } else { casecombo(s, i + 1); } } return; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 package robotfactory; public interface withbattery { int getbatterylife(); void recharge(); } package robotfactory; public abstract class abstractrobot implements withbattery { public abstractrobot(){} protected string modelname; protected int batterylife; protected int maximumbattery; public abstractrobot(string modelname, int batterylife){ this.modelname = modelname; this.batterylife = batterylife; this.maximumbattery = batterylife; } public string getmodelname(){ return new string(modelname); } public abstract void performtask(); public int getbatterylife() { return batterylife; } public void recharge() { batterylife = maximumbattery; } } package robotfactory; public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.totalrobotcount(); } } package robotfactory; public class securityrobot extends abstractrobot { private boolean isarmed; public boolean getisarmed(){ return isarmed; } securityrobot(string modelname, int batterylife, boolean isarmed) { this.modelname = modelname; this.batterylife = batterylife; this.isarmed = isarmed; } public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] "" + ""scanning for threats... armed: "" + isarmed); batterylife-=10; } else { system.out.println(""["" + modelname + ""] "" + ""not enough battery to scan threats...""); } } public void togglearmedmode(){ isarmed = !isarmed; } } package robotfactory; public class cleaningrobot extends abstractrobot { private int cleaningpower; public int getcleaningpower(){ return cleaningpower; } public void performtask(){ if (batterylife >= 10) { system.out.println(""["" + modelname + ""] "" + ""cleaning in progress... cleaning power: "" + cleaningpower); batterylife-=10; } else { system.out.println(""["" + modelname + ""] "" + ""not enough battery to clean...""); } } public void boostcleaningpower(int miktar){ cleaningpower+=miktar; } cleaningrobot(string modelname, int batterylife, int cleaningpower) { this.modelname = modelname; this.batterylife = batterylife; this.cleaningpower = cleaningpower; } } package robotfactory; import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); private static int total; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); total++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ robots.add(new securityrobot(modelname, batterylife, isarmed)); total++; } public void performalltasks() { for (abstractrobot robot : robots){ robot.performtask(); } } public void displayrobots() { for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot){ cleaningrobot temp = (cleaningrobot) robot; system.out.println(""cleaningrobot - model: "" + temp.getmodelname() + "", battery: "" + temp.getbatterylife() + "", cleaning power: "" + temp.getcleaningpower()); } else if (robot instanceof securityrobot){ securityrobot temp = (securityrobot) robot; system.out.println(""cleaningrobot - model: "" + temp.getmodelname() + "", battery: "" + temp.getbatterylife() + "", armed: "" + temp.getisarmed()); } } } public void upgradecleaningrobots(int miktar) { for (abstractrobot robot : robots){ if (robot instanceof cleaningrobot) { cleaningrobot temp = (cleaningrobot) robot; temp.boostcleaningpower(miktar); robot = temp; system.out.println(""cleaningrobot - "" + temp.getmodelname() + "" now has cleaning power: "" + temp.getcleaningpower()); } } } public void togglesecurityrobotsmode() { for (abstractrobot robot : robots){ if (robot instanceof securityrobot) { securityrobot temp = (securityrobot) robot; temp.togglearmedmode(); robot = temp; if (temp.getisarmed()) system.out.println(""securityrobot - "" + temp.getmodelname() + "" is now armed""); else system.out.println(""securityrobot - "" + temp.getmodelname() + "" is now unarmed""); } } } public static void totalrobotcount() { system.out.println(""tum fabrikalar tarafindan toplam "" + total + "" robot uretildi""); } } 0"
5281670,3,"5281670 müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar{ calmastratejisi strateji ; void setstrateji(calmastratejisi s){ strateji = s; } void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki){ metalsarki castedotherobj = (metalsarki) sarki; castedotherobj.gostermetalozellikleri(); } } } } public class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci) { super(isim, sanatci); } @override void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } public class metalsarki extends sarki{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(isim,sanatci); this.metalozellik = metalozellik; } @override void oynat(){ system.out.println(""[metal] "" + sanatci + "" - "" + isim +"" (enstrumantal)""); } void gostermetalozellikleri(){ system.out.println(sanatci + "" - "" + isim + "" [ozellik: ]"" + metalozellik); } } public class rocksarki extends sarki{ public rocksarki(string isim, string sanatci) { super(isim, sanatci); } @override void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } import java.util.arraylist; import java.util.collection; import java.util.collections; import java.util.list; import java.util.random; public class karisikcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { list<integer> numbers = new arraylist<>(); for (int i = 0; i < sarkilistesi.size(); i++) { numbers.add(i); } collections.shuffle(numbers); for (int index : numbers) { sarkilistesi.get(index).oynat(); } } } import java.util.list; public class siralicalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { for(int i = 0; i < sarkilistesi.size() ; i++){ sarkilistesi.get(i).oynat(); } } } abstract public class sarki { string isim; string sanatci; public sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { for(int i = 1; i < sarkilistesi.size() ; ++i){ if(sarkilistesi.get(i) instanceof rocksarki ){ system.out.println(""[bilgi] ses duzeyi : yuksek""); sarkilistesi.get(i).oynat(); if(sarkilistesi.get(i + 1) instanceof rocksarki){ sarkilistesi.get(i).oynat(); system.out.println(""[bilgi] ses duzeyi : normal""); ++i; } } sarkilistesi.get(i).oynat(); } } } import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } ""recursion"" kavramı nedir, kısaca açıklayınız. recursion bir methodun kendini çağırması kavramıdır recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case recursive call jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. her bir call yapıldığında stacke o methodun variableları ve kendisi çağrılır ve en baştan başlayarak methodlar çalıştırılır int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. iteratif olarak yapmak daha az yer ve zaman kullanımına sebep olacaktır bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? stringin uzunluğunun sıfıra eşit olup olmadığına bakmak stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack metod çağrıldığında variablelarının saklandığı ve kullanımı bitince çıktığı yerdir eşer method çok kez çağrılırsa stack overflow olur tail recursion nedir, kısaca açıklayınız. - java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? static binding compiler time dynamic run time java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? çünkü override edilemezler dolayısı ile derleme zamanında sınıf üzerinden çözülür overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overriding run time overloading compile time dinamik bağlamada jvm'nin görevi nedir? hangi metotun çağrılacağını nesnenin gerçek türüne göre belirlemek java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? upcasting bir child class nesnesinin üst sınıfın referansında saklanmasıdır downcastibg bir üst sınıf referansının alt sonıf türüne çevirmektir java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? override edilme özelliği kaybolurdu , gereksiz bellek kullanımı olurdu class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child // dynamic class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book // dynamic java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract classlardan nesne oluşturulamaz , evet olabilir abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? hayır yapılamaz abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. genellikle bi şablon görevi görürler , tamamen veya kısmen tamamlanmış metotlar içerebilirler, abstract classlardan nesne oluşturulamaz abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interfacelerde değişkenler final değerlerini alırlar abstract classlar isle sonradan implement edilebilecek şablonlar gibi düşünülebilir o yüzden böyle bi zorunluluk yoktur , abstract classlar kullanılabilir interfaceler kullanılamaz marker interface ve functional interface kavramları nedir, nasıl kullanılır? - bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet ikisi de mümkündür abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? c is a shape ama shape in draw metodu implement edilmemiş bunun yerine circle c = new circle() denilirse drawing circle displaying çıktısı verir interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? - bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot { //a=65 a=97 private string name; private string type; private int batterylevel; // 100 ile 0 arasında bir değer private boolean isoperational; // bataryası varsa true public robot(){ this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public robot(string name, string type, int batterylevel){ this.name = name; this.type = type; this.batterylevel = batterylevel; if(batterylevel > 0){ isoperational = true; } else{ isoperational = false; } } public string getname() { return name ; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbattery() { return batterylevel ; } public void setbattery(int batterylevel) { this.batterylevel = batterylevel ; } public boolean getisop() { return isoperational; } public void setisop(boolean isoperational ) { this.isoperational = isoperational; } public void charge(){ this.batterylevel = 100; } public void printrobot(){ system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + ""% "" + "" is\r\n"" + // ""operational:"" + isoperational); } } public class main { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } public class question1 { //q1 dedigimde compiler sorun cikardi caner hoca sebebnini bilmiyorum dedigi icin question1 seklinde adlandirdim public static void main(string[] args) { string s = findperm(""abc"" , 0); system.out.println(s); string s1 = findperm(""ab"" , 0); system.out.println(s1); string s2 = findperm(""a12b"" , 0); system.out.println(s2); } public static string findperm(string s , int i){ char c = 'x'; if(i >= s.length()) return """"; if(s.charat(i) != '0' && s.charat(i) != '1' && s.charat(i) != '2' && s.charat(i) != '3' && s.charat(i) != '4' && s.charat(i) != '5' && s.charat(i) != '6' && s.charat(i) != '7' && s.charat(i) != '8' && s.charat(i) != '9' ){ if(s.charat(i) <= 'z' && s.charat(i) >= 'a'){ c = (char) (s.charat(i) - 'a'); return c + findperm(s.substring(i+1) , i+1) ; } if(s.charat(i) <= 'z' && s.charat(i) >= 'a'){ c = (char) (s.charat(i) + 32); return c + findperm(s.substring(i+1) , i+1); } } else{ return s.charat(i) + findperm(s.substring(i+1) , i+2) ; } return """"; } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name, string location){ this.name = name; this.location = location; this.robots = new arraylist<>(); } public factory(){ this.name = ""factory1""; this.location = ""moon""; this.robots = new arraylist<>(); } public string getname() { return name ; } public void setname(string name) { this.name = name; } public string getloc() { return location ; } public void setloc(string location) { this.location = location; } public void addrobot(robot robot){ this.robots.add(robot); } public void chargeallrobots(){ for(int i = 0 ; i < robots.size(); i++){ robots.get(i).charge(); } } public void printfactory(){ system.out.println(""factory name: "" + name + "" location: "" + location); system.out.println(""robots operating here:""); for(int i = 0 ; i < robots.size(); i++){ robots.get(i).printrobot(); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery{ int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); //??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz factory.allrobots(); } } public class securityrobot extends abstractrobot{ private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } @override public int getbatterylife() { return this.batterylife; } int keeper = getbatterylife(); @override public void recharge() { this.batterylife = keeper; } @override public void performtask() { if(this.batterylife >= 10){ system.out.println(""["" + modelname + ""]"" + "" scanning for threats... armed: "" + isarmed); this.batterylife-=10; } else if(this.batterylife < 10){ system.out.println(""["" + modelname + ""]"" + "" not enough battery to scan threats...""); } } public void togglearmedmode(){ if(this.isarmed){ this.isarmed = false; } else{ this.isarmed = true; } } public boolean isarmed() { return isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; int keeper = getbatterylife(); public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } public int getbatterylife() { return this.batterylife; } @override public void recharge() { this.batterylife = keeper; } @override public void performtask() { if(this.batterylife >= 10){ system.out.println(""["" + modelname + ""]"" + "" cleaning in progress... cleaning power: "" + cleaningpower); this.batterylife-=10; } else if(this.batterylife < 10){ system.out.println(""["" + modelname + ""]"" + "" not enough battery to clean..."" ); } } public void boostcleaningpower(){ this.cleaningpower += 50; } public int getcleaningpower() { return cleaningpower; } public void setcleaningpower(int cleaningpower) { this.cleaningpower = cleaningpower; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; static int totalproduced = 0; public robotfactory() { robots = new arraylist<>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ totalproduced++; robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ totalproduced++; robots.add(new securityrobot(modelname, batterylife, isarmed)); } public void performalltasks(){ for(int i= 0; i < robots.size(); i++){ robots.get(i).performtask(); } } public void displayrobots(){ for(int i= 0; i < robots.size(); i++){ if(robots.get(i) instanceof securityrobot){ system.out.println(""securityrobot - model: "" + robots.get(i).getmodelname() + "", battery: "" + robots.get(i).getbatterylife() + "", armed: "" + ((securityrobot) robots.get(i)).isarmed()); } if(robots.get(i) instanceof cleaningrobot){ system.out.println(""cleaningrobot - model: "" + robots.get(i).getmodelname() + "", battery: "" + robots.get(i).getbatterylife() + "", cleaning power: "" + ((cleaningrobot) robots.get(i)).getcleaningpower()); } } } public void upgradecleaningrobots(int miktar){ for(int i= 0; i < robots.size(); i++){ if(robots.get(i) instanceof cleaningrobot){ ((cleaningrobot) robots.get(i)).setcleaningpower(((cleaningrobot) robots.get(i)).getcleaningpower() + miktar); system.err.println(""cleaningrobot - "" + robots.get(i).getmodelname() +"" now has cleaning power: "" + ((cleaningrobot) robots.get(i)).getcleaningpower()); } } } public void togglesecurityrobotsmode(){ for(int i= 0; i < robots.size(); i++){ if(robots.get(i) instanceof securityrobot){ securityrobot s = (securityrobot)robots.get(i); s.togglearmedmode(); if(s.isarmed()){ system.out.println(""securityrobot - "" + s.getmodelname() + "" is now armed""); } else{ system.out.println(""securityrobot - "" + s.getmodelname() + "" is now unarmed""); } } } } public void allrobots(){ system.out.println(""tum fabrikalar tarafindan toplam "" + totalproduced + "" robot uretildi\r""); } } 3"
4779274,1,"4779274 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab221301009 { // test için main public static void main(string[] args) { system.out.println(""\n"" + collatz(5)); int[] arr = {5,4,1,2,6,7,1,3,9,11,2,1,-3}; //kontrol etmek için karışık yaptım for(int i=0; i<arr.length; i++) system.out.print(arr[i] + "" ""); cocktailsort(arr); // fonk call system.out.print(""\n yeni hali :""); for(int i=0; i<arr.length; i++) system.out.print(arr[i] + "" ""); sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(""\n"" + s1.say() +"" ve ""+ s2.say()); } // soru 1 collatz public static int collatz(int i) { int mod = i % 2; system.out.print(i + "" -> ""); // adımları yazmak için if (i == 1) return 0; else{ if(mod == 1) return 1 + collatz((i*3)+1); else return 1 + collatz(i / 2); } } // soru 2 cocktail shaker sort public static void cocktailsort(int[] arr) { if (arr.length != 0) karsilastir(arr,0, 1, 1); else system.out.println(""olmaz""); } static void karsilastir (int[] arr, int index, int yon, int iteras) { boolean kucukmu = arr [index] <= arr [index + yon]; //iterasyon bittiyse boş dön bitir if (iteras == arr.length) return; // yöne göre küçük mü büyük mü olması değişmesini etkiliyordu o yüzden böyle if (kucukmu == false && yon == 1 || kucukmu == true && yon == -1) { int temp = arr [index]; arr [index] = arr [index + yon]; arr [index + yon] = temp; } // burada tamamen sınırlara gelince yön değişmesi ve iterasyon artması için falan // ayrı ayrı çağırdım daha kısa yapılabilirdi if (index == arr.length - 2 && yon == 1) karsilastir(arr, arr.length - 2, -1, iteras + 1); else if (index == 1 && yon == -1) karsilastir(arr, 1, 1, iteras + 1); else karsilastir(arr, index + yon , yon, iteras); } } //soru 3 class sayac { string str; sayac(string str) { this.str = str; } //stringi alan bi helper lazımdı her şeyi onda yaptım aslında public int sayhelp(string str) { if (str.length() == 0) return 0; else if (str.charat(0) == '1') return 1 + sayhelp(str.substring(1)); else return 0 + sayhelp(str.substring(1)); } public int say() { return(sayhelp(str)); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.sql.time; import java.util.arrays; import java.util.collections; import java.util.list; public class lab2_221301009 { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki) { ((metalsarki)sarki).gostermetalozellikleri(); } } } } abstract class sarki { string isim, sanatci; abstract void oynat(); } class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void oynat() { system.out.println(""[metal] ""+this.sanatci+"" - ""+this.isim+"" (""+this.metalozellik+"")""); } void gostermetalozellikleri() { system.out.println(this.sanatci+"" - ""+this.isim+"" [ozellik: ""+this.metalozellik+""]""); } } class rocksarki extends sarki { string rockozellik = ""huzurlu ve nostaljik""; rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[rock] ""+this.sanatci+"" - ""+this.isim+"" (""+this.rockozellik+"")""); } } class klasiksarki extends sarki { string klasikozellik = ""hafif ve sakin""; klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[klasik] ""+this.sanatci+"" - ""+this.isim+"" (""+this.klasikozellik+"")""); } } interface calmastratejisi{ void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } system.out.println(); } } class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { collections.shuffle(sarkilistesi); for (sarki sarki : sarkilistesi) { sarki.oynat(); } system.out.println(); } } class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean yuksekmi = false; for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki && yuksekmi == false) { system.out.println(""[bilgi] ses duzeyi: yuksek""); yuksekmi = true; } else if (!(sarki instanceof rocksarki) && yuksekmi == true) { system.out.println(""[bilgi] ses duzeyi: normal""); yuksekmi = false; } sarki.oynat(); } } } class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { strateji = s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. recursive (özyineleme) bir metodun kendini tekrar çağırması - tetiklemesi diyebiliriz, base kısmı vardı recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. en küçük durum için gerekliydi, bu fonksiyonun yani metodun kendini sürekli çağırarak çalışmasının bi noktada durmasını sağlayan kısım. yani baz kısmında tekrar çağırmayız bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? her bi iterasyonda bir önceki elemana giden yani sondan başlayarak yazdıran bi fonksiyonumuz olurdu, base case ise ilk eleman (fonksiyonun eleman girdisi n ise base n ==0 koşulu olabilir) recursive bir metotta base case olmazsa ne olur? sonsuza kadar gidebilir bence anlamli sonuç olmaz, baz ile en son durumda recursiveı durdurmayı amaçlıyoruz çünkü while yazıp koşul yazmamak gibi bi şey olur recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. stackte tüm çağrılan fonksiyonların girdileri birikir üst üste. aynı fonk ne kadar çağrıldıysa fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. recursive genel verimsiz ve fibonacci de çok fazla stack depolaması gerektirir bence tail recursion nedir, kısaca açıklayınız. unuttum abstraction kavramını açıklayınız. soyutlama, ""is a"" ilişkilerinde temel olan özellikleri bir kenarda soyut bi biçimde tutma diyebiliriz bence dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? evet mümkün, zaten hourlyemployee is an employee mantığıyla bakınca dönüş tipi değişmio protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier dediğimiz default mu eğer öyleyde no modifier daha yakın. protected subclas falan da alıo java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? e çünkü alt sınıftan bi nesne tanımladığımızda bunun atasındaki instance variablelerinr de atama yapmamız gerekecek. atasının atası bu zincir ne kdr var, ne kadar instamce var değer atamak için bunları bilmediğimizden her cınstructor atasına referans verirse zincirleme her şey atanabilir java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır olmaz aynı isimli metotlar falan sıkıntı java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a b nin subclassı demek oluo, ata oğul ilişkisinin kontrolü metot overriding ve overloading kavramlarını açıklayınız. overriding: aynı imza (isim ve değişkrbler) ; overloading: aynı metot ismi ama variablrlrr farklı yani aslında bambaşka bi fonksiyon compiler için bence class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? hocam derived objesi açmışız hani derivedin consrructorunda super varsa o base() çalıştırır o da print(); çağırır. o da base nin kendi printine gider o da ""base"" çıktısı verir cevap base bence class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? bence 10. bence zaten c.getvalue direkt parentteki getvalue gider gibi hissettim java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? comp sırasında kodun gidişine göre anlamı değişmeyen bindingler en başta static olarak yapılır, override falan varsa dynamic çünkü hangisine bind etmeli falan java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? üçünü de artık override edemezsin, bu yüzden static bindingle direkt net olarak o bağlanır overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overriding varsa dynamic, overloading zaten bambaşka bi methot tanımı anlamına geldiğinden static bindingi bozmaz dinamik bağlamada jvm'nin görevi nedir? runtime sırasında bağlamı belirlemek ?? yani override var ve en yakın overrideya bağlıyor kısaca açıklamaya çalıştım java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? biri diğerini kapsıyo olduğundan upcasting implicit halde olabilir ama downcasting için aynısını diyemeyiz yapılamaz java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? e hepsini runtime da belirlemesi bence zaman karmaşıklığını arttırırdı, jvm nin o anda bununla upraşmasına gerek yok bazı bindingler net şekilde başta yapılabilecekken class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child yazar, override olduğundan comp başında binding olmaz yani dinamik bağlama class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? productbook çıktısı verir , iki bağlama tipi de var arryin ilk itemi direkt product diğeri ise book olduğu içib ama belki java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract classlar soyuttur, metotu yaratır tanım içermez alt classlar için yapı sağlar; constructor olabilir abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? implement dediğimiz interface ile alakalı değil mi abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. sıfatlardan bahsedebilir hale geliriz, soyutlama işte yani nesnesel programlama yapabilmek için nesneyi koda soyut aktardığımız hal abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract classın abstract olmayan metotları olabilir interface tamamen soyut, tip olabilirler aynı zamanda marker interface ve functional interface kavramları nedir, nasıl kullanılır? ilk kez duyuyırum bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet birden çok eder; ama bir interface diğerini extend eder abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? hata animal a variablesinin yine animal tipinde bir objeyi tutuyo olması. bu durumda a.sound abstract kalmış bi function olarak kalır, dogtaki sounda zaten inemez ama bence hata da verir. onu dğzeltirsek de çıktı animal:buddy /n woof olr. interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? bence interfacenin içinde de metot içi tanım yapamıyoz zaten ikisi ayrı ayrı yapabilseydi aynı anda implement edemezdik bence, o iç tanım duck classı içinde yapılmalı ve yazdırılmalı. bu haliyle output doğrudan swimming ya da flying biz ne dersek artık sonuçta ikisini de yapabilir, ne durumda olduğuna bağlı bi metot yazılır yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. error ve exception olarak ayrılır, compile error ve runtime error olaeak ayrılır exception handlingin amacı nedir? oluşacak muhtemel hatalara doğru müdahele etmek, hatalardaki kontrolle kodu tam anlamıyla yönetebilmiş olmak exception handlingde finally bloğunun amacı nedir? eğer hata alındıktan (ya da almadıktan) sonra kesiblikle yapılması gereken bir şey varsa bu blokta bunlar gerçekleşir mesela bi dosyayı bi scanneri kapatmak. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? checked, compile esnasında kontrol edilmesi gereken exceptionlarken unchecked ler runtime esnasında oluşabilme ihtimali serbest olan exceptionlardır java'da kendi exceptionunuzu nasıl tanımlarsınız? exception classına bi oğul class tanımlayarak (exceptiın ile extend ederek) sonra constructoru, gerekiyorsa hata mrsajını vs tanımlarım java'da error ve exception arasındaki fark nedir, açıklayınız errorlar geri dönülemez sistem hataları olarak nitelendirilir, exception ise coder tarafından handle edilebilecek kusurlardır java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? metod, bu hatayla ilgili kendi düzeltmelerini yaptıktan sonra bir öncesinde çağrıldığı metodda da düzeltmeler gerekiyorsa üst metodun da catch edebilmesi için tekrar fırlatılır 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? override ederken ana metodda fırlatılan hata türü veya o türün oğul hataları fırkatılabilir, ata exceptionlar override metodda throw edemez static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenir ama hata var. catchlerin sırası yanlış. bu durumda exception caught çalışır. ama daha özelinde çalışması gereken alttaki catchtir. derlenir ama mantığı yanlış static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally done -1 bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class quiz1q1_221301009 { public static void main(string [] args) { string hey = ""a1b2""; combination(hey); } // a: 65 a: 97 static void combination(string str) { int numofletters=0; int[] indexes = new int[10]; int y=0; for(int i=0; i<str.length(); i++) { if(str.charat(i) >= 65 && str.charat(i) <= 97) { numofletters++; indexes[y] = i; y++; } } //amacım letter olan kaç tane char olduğunu ve bu charların indexlerini bulup recrsn fonksiyona götürmek system.out.print(""["" + combination_rec(str, 2^numofletters - 1, indexes) + ""]""); } //bu fonksiyonda da amacım harf sayısının 2 üzerili hali yani //toplam kombinasoyn sayısını buraya aktardıktan sonra //her bi kombinasyonu booleanlı bi hale dönüşütürerek //büyütüp küçülmeyi ayarlamayı sağlamaktı //mesela 2 karakter varsa numofletters=3 ile başlayacak //3 : 11 ile ikisini de değişicek sonra 2 : 10 sonra 1: 01 sonra 0: 00 ile //tüm olası büyütme küçültmeleri yapmaktı ama olmadı //bi de 3 harf ile sınırlandırdım malsef döngü ile total harf sayısı //yapılabilirdi ama sürem yetmedi static string combination_rec(string str, int numofletters, int[] index) { if(numofletters == 0) return """"; else return ""c""; string word = """"; boolean [] comb = new boolean[3]; comb[0] = (numofletters%2 == 1)? true:false; comb[1] = ((numofletters/2)%2 == 1)? true:false; comb[2] = ((numofletters/4)%2 == 1)? true:false; // bu comb değerleri bu iterasyonda hangi harfin değişmesi hangisinin // aynı kalması gerektiğini belirler int y=0; char c; for(int ind=0; ind<str.length(); ind++){ if(ind == index[0] || ind == index[1] || ind == index[2]){ if(comb[y] == true) { if(str.charat(ind) < 97) c=str.charat(ind) + 32; else c=str.charat(ind) - 32; // true ise değiş. } else c = str.charat(ind); //false ise aynı kal } else c = str.charat(ind); //harf değilse değişme ve word değişkenine bu charı al word = word + c; } // wordu ekrana yazdır diğer word için iterasyonu 1 azalt. return ""\"""" + word + ""\"""" + combination_rec(str, numofletters-1, index); } } import java.util.arraylist; public class quiz1q2_221301009 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public string getname() { return name; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int newbat) { this.batterylevel = newbat; } public boolean getoperational() { return isoperational; } public void setoperational(boolean newboolean) { this.isoperational = newboolean; } public void charge() { batterylevel = 100; isoperational = true; } robot() { name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } robot(string name, string type, int batterylevel) { this.name = name; this.type = type; this.batterylevel = batterylevel; isoperational = (batterylevel>0) ? true:false; } public void printrobot() { system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: %"" + batterylevel + "" is operational: "" + isoperational); } } class factory { private string name; private string location; private arraylist<robot> robots = new arraylist<robot>(); public factory(string name, string location) { this.name = name; this.location = location; } public factory() { name = ""factory1""; location = ""moon""; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getloc() { return location; } public void setloc(string loc) { this.location = loc; } public arraylist<robot> getrobots() { return robots; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for(i=0; i<robots.size(); i++) { robots.get(i).charge(); } } public void printfactory() { system.out.println(""factory name: "" + this.name + "" location: "" + this.location + ""\nrobots operating here:""); for(int i=0; i<robots.size(); i++) { robots.get(i).printrobot(); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public int getbatterylife() { return batterylife; } public void recharge() { batterylife=100; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.print(""\n""); //static method yazdım ??? sorusu için robotfactory.toplamroboturetimi(); } } public class securityrobot extends abstractrobot{ private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } public void performtask() { if(batterylife < 10) { system.out.println(""[""+modelname+ ""] not enough battery to scan threats...""); } else{ system.out.println(""[""+modelname+ ""] scanning for threats... armed: ""+ isarmed); batterylife -= 10; } } public void togglearmedmode() { isarmed = !isarmed; } // gerekiyordu public boolean getarmed() { return isarmed; } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; //gerekiyodu:) public int getcleaning() { return cleaningpower; } public void setcleaning(int miktar) { cleaningpower += miktar; } cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } public void performtask() { if(batterylife < 10) { system.out.println(""[""+modelname+ ""] not enough battery to clean...""); } else{ system.out.println(""[""+modelname+ ""] cleaning in progress... cleaning power: ""+ cleaningpower); batterylife -= 10; } } public void boostcleaningpower() { cleaningpower++; //?? arttırır yazmış anlamadım 1 tane artsın } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); static int toplam = 0; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { abstractrobot newrob = new cleaningrobot(modelname, batterylife, cleaningpower); robots.add(newrob); toplam++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { abstractrobot newrob = new securityrobot(modelname, batterylife, isarmed); robots.add(newrob); toplam++; } public void performalltasks() { for(abstractrobot robot: robots) { robot.performtask(); } } public void displayrobots() { for(abstractrobot robot: robots) { string type = (robot instanceof cleaningrobot) ? ""cleaningrobot"" : ""securityrobot""; string info = (robot instanceof cleaningrobot) ? ""cleaning power: "" + ((cleaningrobot)robot).getcleaning() : ""armed: "" + ((securityrobot)robot).getarmed(); system.out.println(type+ "" - model: ""+ robot.getmodelname()+ "", battery: ""+ robot.getbatterylife()+"", ""+info); } } //bunun için de ister istemez setter gerekiyor, ilgili yerde oluşturdum. public void upgradecleaningrobots(int miktar) { for(abstractrobot robot: robots) { if(robot instanceof cleaningrobot) { ((cleaningrobot)robot).setcleaning(miktar); system.out.println(""cleaningrobot - "" + robot.getmodelname() + "" now has cleaning power: "" + ((cleaningrobot)robot).getcleaning()); } } } public void togglesecurityrobotsmode() { for(abstractrobot robot: robots) { if(robot instanceof securityrobot) { ((securityrobot)robot).togglearmedmode(); string type = ((securityrobot)robot).getarmed() == true ? ""armed"": ""unarmed""; system.out.println(""securityrobot - "" + robot.getmodelname() + "" is now "" + type); } } } //??? sorusu //static int toplam ile class içinde herhangi bi objede herhangi bi robot oluşumunda saymayı sağladım public static int toplamroboturetimi() { system.out.println(""tum fabrikalar tarafindan toplam ""+ toplam + "" robot uretildi""); return toplam; } } 1"
