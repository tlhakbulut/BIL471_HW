id,NaN_count,answers,char_count,word_count,java_keyword_count,method_count,class_count,comment_count
7214465,2,"7214465 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class q3 { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } class sayac{ public string str; public int index; public int count; public int say(){ return metod(str,0); } public sayac (string str){ this.str = str; } public int metod(string str,int index){ if(index == str.length()){ return count; } else if(str.charat(index) == '1'){ return 1 + metod(str,index+1); } else if(str.charat(index) == '0'){ return 0 + metod(str,index+1); } return 0; } } import java.util.scanner; public class q2 { public static void main(string[] args) { scanner scan = new scanner(system.in); int a = scan.nextint(); int[] arr = new int[a]; for (int i = 0; i < a; i++) { arr[i] = scan.nextint(); } cocktailsort(arr); for (int i = 0; i < a; i++) { system.out.print(arr[i] + "" ""); } } public static void cocktailsort(int[] array){ boolean bl = true; for (int i = 0; i < array.length - 1; i++) { if(array[i] > array[i+1]){ bl = false; } } bubblesort(array,0,array.length-1); } public static void bubblesort(int[] arr, int left, int right){ if( left >= right){ return ; } for (int d = 0; d < arr.length - 1 ; d++) { if(arr[d] > arr[d+1]){ int temp = arr[d]; arr[d] = arr[d+1]; arr[d+1] = temp; } } left++; for (int d = arr.length - 1; d > 0 ; d--) { if(arr[d] < arr[d-1]){ int temp = arr[d]; arr[d] = arr[d-1]; arr[d-1] = temp; } } right--; bubblesort(arr, left, right); } } import java.util.scanner; public class q1 { static int count = 0; public static void main(string[] args) { scanner scan = new scanner(system.in); int sayi = scan.nextint(); int cevap = collatz(sayi); system.out.println(cevap); } public static int collatz(int i){ if(i==1){ return count; } else if(i % 2 == 0){ collatz(i/2); count++; } else if(i % 2 == 1){ collatz(3*i + 1); count++; } return count; } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.collections; import java.util.list; interface calmastratejisi { void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { collections.shuffle(sarkilistesi); for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean bl = true; for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki && bl == false) { system.out.println("" [bi̇lgi̇] ses düzeyi: yüksek""); bl = true; } else if (!(sarki instanceof rocksarki) && bl == true) { system.out.println("" [bi̇lgi̇] ses düzeyi: normal""); bl = false; } sarki.oynat(); } if (bl) { system.out.println("" [bi̇lgi̇] ses düzeyi: normal""); } } } import java.util.list; class muzikcalar { private calmastratejisi strateji; public void setstrateji(calmastratejisi s) { this.strateji = s; } public void muzikcal(list<sarki> sarkilistesi) { if (strateji != null) { strateji.cal(sarkilistesi); } } } import java.util.arrays; import java.util.list; public class soru1 { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki){ ((metalsarki) sarki).gostermetalozellikleri(); } } } } abstract class sarki { public string isim; public string sanatci; public sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } public abstract void oynat(); } class metalsarki extends sarki { private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(isim, sanatci); this.metalozellik = metalozellik; } @override public void oynat() { system.out.println("" [metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } public void gostermetalozellikleri() { system.out.println("" "" + sanatci + "" - "" + isim + "" [özellik: "" + metalozellik + ""]""); } } class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { super(isim, sanatci); } @override public void oynat() { system.out.println("" [rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { super(isim, sanatci); } @override public void oynat() { system.out.println("" [klasi̇k] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. özyineleme yani bir problemin çözümünün diğer küçük parçalarla çözülmesidir. temekl kısımları temel basamak ve özyinelemeli basamaktır. recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. algoritmanın durması gereken durumudur. gerekli olma sebebi algoritmanın daha fazla dönmesi yerine sonucu çıktı olarak vermesi. bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? boş olurdu recursive bir metotta base case olmazsa ne olur? sonsuz döngü recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. . fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. aynı hesaplama çok kez yapılmasından tail recursion nedir, kısaca açıklayınız. bir algoritmanın kendisini son defa çağırdığı bir yöntemdir java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? metodun hangi metoda bağlanacağının sürecidir static ve dynamic çeşitleridir hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? static : static metod, final metod, private metod / dynamic : override metodlar dinamik bağlamada jvm'nin görevi nedir? görevi metodun hangi classa ait olduğunu belirlemektir java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? performans sorunu oluşur veya hata tespiti zorlaşırdı java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? nedeni down casting time complexityde hataya yol açabilir. implict şekilde yapsak time complexity ve kod karmaşıklığı artar java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. evet , polimorfizmle ilişkisi dinamik bağlama ile ilgilidir. class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? p.special() satırı hatalıdır / child display / dinamik binding java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class soyut sınıf demektir farkı abstractta gövdesiz metod olabilir diğerinde olamaz . abstract sınıfların constructoru olabilir ama doğrudan çağrılamaz. interfscelerin olamaz ama abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? evet , abstract sınıf önceki abstract metodu tanımlayıp gövdesini ekleyebilir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. nesne oluşturmaz implement sağlar ortak özellik tanımlar abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? kalıtım mirası, constructor, değişkenler farklarıdır. evet tip olarak kullanılabilir marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker : içinde metod bulunmayan interfacedir, etiket ile kullanılır functional : bir tane abstract metod bulunan interfacedir. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet class birden çok arayüzü implement edebilri. hayır, bir interface başka bir indterfacei implement edemez ama extend edebilir. abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? animal abstarcttır bu yüzden nesne oluşturalmaz. düzelltikten sonra output: animal: buddy wolf interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? hayır hata 2 farklı arayüzden aynı isimden metod alıyor. output: flying yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. syntax , logic ve runtime hataları exception handlingin amacı nedir? hataları daha kolay bulur ve programın çökmesini önler exception handlingde finally bloğunun amacı nedir? excepsion handling bölümünde hata olsa da olmasa da her durumda çalışır amacı kaynak yönetimi yapmak ve kesinlikle çalışmasını istediğimiz kodları koymaktır java'da 'checked' ve 'unchecked' exceptionların farkı nedir? chevked programın dış etken etkileşimiyle oluşur unchacked ise programcı hatalarından kaynaklanır java'da kendi exceptionunuzu nasıl tanımlarsınız? exception veya runtimeexception sınıfından oluşan bir sınıf ile yazabiliriz java'da error ve exception arasındaki fark nedir, açıklayınız error sistemsel hatayı fark eder execption yazılımsal hataları tespit eder java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? işlem devamı için başka hata yönetimi 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? alt sınıf üst sınıftan daha genis throws yapamaz static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenmez önce exception sonra arrayindexoutofboundsexception yakalanmıs düzeltmek için tam tersi yapılmalı çıktısı ise array exception caught static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.arraylist; public class q2 { public static void main(string[] args) { habitat habitat = new habitat(""antarctica "",-15.0); penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); //habitat.addpenguin(p1); //habitat.addpenguin(p2); //habitat.addpenguin(p3); p3.hunt(); // 5, 6 oldu habitat.printhabitat(); p1.printpenguin(); p2.printpenguin(); p3.printpenguin(); } } class penguin{ private string name; private string species; private int age; private double weight; public penguin(string string, string string2, int i, double d) { this.name = string; this.species = string2; this.age = i; this.weight = d; } public penguin() { this.name = ""willy""; this.species =""emperor""; this.age = 1; this.weight = 5.0; } public void setname(string asd){ name = asd; } public string getname(){ return name; } public void setspecies(string species){ this.species = species; } public string getspecies(){ return species; } public void setage(int age){ this.age = age; } public int getage(){ return age; } public void setweight(double weight){ this.weight = weight; } public double getweight(){ return weight; } public void hunt(){ this.weight = weight + 1.0; } public void printpenguin(){ system.out.println(""penguin name: "" + name + "" species: "" + species + "" age: "" + age + "" years weight: "" + weight + "" kg""); } } class habitat{ private string location; private double temperature; private arraylist<penguin> penguins; public habitat(string location, double temperature){ this.location = location; this.temperature = temperature; } public void addpenguin(penguin penguin){ penguins.add(penguin); } public void printhabitat(){ system.out.println(""habitat location: "" + location); system.out.println(""average temperature: "" + temperature + "" °c""); } public void setlocation(string location){ this.location = location; } public string getlocation(){ return location; } public void settemperature(double temperature){ this.temperature = temperature; } public double gettemperature(){ return temperature; } public arraylist<penguin> getpenguins() { return penguins; } } import java.util.scanner; public class q1 { public void parantezbas(int n){ scanner scan = new scanner(system.in); n = scan.nextint(); if(n == 1){ system.out.println(""()""); } char sol = '('; char sag = ')'; scan.close(); } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public class latte extends basecoffee { @override public double calculateprice() { double baseprice = 50; double totalprice = baseprice; for (coffeeaddon addon : addons) { totalprice += addon.getcost(); } return totalprice; } @override public string tostring() { stringbuilder order = new stringbuilder(""latte""); for (coffeeaddon addon : addons) { order.append("" + "").append(addon.getname()); } return ""sipariş: "" + order.tostring() + "" toplam fiyat: "" + calculateprice() + "" tl""; } } public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffeemachine machine2 = new coffeemachine(); machine2.addaddontocoffee(espresso, new doubleshot()); machine2.addaddontocoffee(espresso, new milk()); machine2.heatespressocup(espresso); machine2.makecoffee(espresso); machine2.gettotalcoffeesmade(); //... coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(""\n""); // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz anothermachine.gettotalcoffeesmade(); } } public class espresso extends basecoffee { private boolean isheated = false; public void heatcup() { isheated = true; } @override public double calculateprice() { double baseprice = 40; double totalprice = baseprice; for (coffeeaddon addon : addons) { totalprice += addon.getcost(); } return totalprice; } @override public string tostring() { string coffeename = isheated ? ""espresso (sıcak fincan)"" : ""espresso""; stringbuilder order = new stringbuilder(coffeename); for (coffeeaddon addon : addons) { order.append("" + "").append(addon.getname()); } return ""sipariş: "" + order.tostring() + "" toplam fiyat: "" + calculateprice() + "" tl""; } } public class vanillasyrup implements coffeeaddon { @override public double getcost() { return 6; } @override public string getname() { return ""vanilla syrup""; } } public interface coffeeaddon{ public double getcost(); public string getname(); } import java.util.arraylist; public abstract class basecoffee { protected arraylist<coffeeaddon> addons = new arraylist<>(); public void addaddon(coffeeaddon addon) { addons.add(addon); } public abstract double calculateprice(); } public class americano extends basecoffee { @override public double calculateprice() { double baseprice = 45; double totalprice = baseprice; for (coffeeaddon addon : addons) { totalprice += addon.getcost(); } return totalprice; } @override public string tostring() { stringbuilder order = new stringbuilder(""americano""); for (coffeeaddon addon : addons) { order.append("" + "").append(addon.getname()); } return ""sipariş: "" + order.tostring() + "" toplam fiyat: "" + calculateprice() + "" tl""; } } public class coffeemachine { private static int totalcoffeesmade = 0; public void addaddontocoffee(basecoffee coffee, coffeeaddon addon) { coffee.addaddon(addon); } public void makecoffee(basecoffee coffee) { totalcoffeesmade++; system.out.println(""hazırlanıyor.."" + coffee.getclass().getsimplename()); system.out.println(""toplam fiyat: "" + coffee.calculateprice()); } public void heatespressocup(basecoffee coffee) { if (coffee instanceof espresso) { ((espresso) coffee).heatcup(); system.out.println(""espresso kahve fincanı ısıtıldı""); } else { system.out.println(""[uyari] yalnızca espresso kahve fincanları ısıtılabilir.""); } } public static int gettotalcoffeesmade() { return totalcoffeesmade; } } public class milk implements coffeeaddon { @override public double getcost() { return 5; } @override public string getname() { return ""milk""; } } public class doubleshot implements coffeeaddon { @override public double getcost() { return 10; } @override public string getname() { return ""double shot""; } } public class chocolate implements coffeeaddon { @override public double getcost() { return 7; } @override public string getname() { return ""chocolate""; } } 2",33721,4434,622,229,47,21
9830856,2,"9830856 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab11q1 { public static void main(string[] args) { system.out.println(collatz(3)); } static int count=0; public static int collatz(int i) { if(i!=1) { count++; if(i%2!=0) { i=i*3+1; return collatz(i); } else { i=i/2; return collatz(i); } } else return count; } } public class lab1q2 { public static void main(string[] args) { int [] arr={5,4,1,2,3}; cocktailsort(arr); } static int index=0; static boolean soldan=true; public static void cocktailsort(int[] arr) { if(issorted(arr)) { for(int a=0; a<arr.length; a++) { system.out.print(arr[a]); } } else { if(soldan) { if(index+1!=arr.length) { if(arr[index]>arr[index+1]) { int h=arr[index]; arr[index]=arr[index+1]; arr[index+1]=h; } index++; } else { index=arr.length-1; soldan=false; } } else { if(index!=0) { if(arr[index]<arr[index-1]) { int h=arr[index]; arr[index]=arr[index-1]; arr[index-1]=h; } index--; } else { index=0; soldan=true; } } cocktailsort(arr); } } public static boolean issorted(int[]arrayy) { boolean flag=true; for(int i=0; i<arrayy.length-1; i++) { if(arrayy[i]>arrayy[i+1]) flag=false; } return flag; } } public class lab1q3 { public static void main(string[] args) { sayac s1=new sayac(""10001""); sayac s2=new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } class sayac { string str; int count=0; int index=0; public sayac(string str) { this.str=str; } public int say() { return result(str); } public int result(string str) { if(index==str.length()) return count; else { if(str.charat(index)== '1') { count++; } index++; return result(str); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.*; public class muzikcalar { public calmastratejisi strateji; public void setstrateji(calmastratejisi s) { this.strateji = s; } public void muzikcal(list<sarki> sarkilistesi) { if (strateji != null) { strateji.cal(sarkilistesi); } else { system.out.println(""invalid""); } } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { sarki s1=new metalsarki(""years of silence"", ""thurisaz"", ""aykırı ve atmosferik""); sarki s2= new metalsarki(""voice of the soul"", ""death"", ""enstrümantal""); sarki s3=new rocksarki(""small mountain"", ""midlake""); sarki s4=new rocksarki(""ankara"", ""vega""); sarki s5=new klasiksarki(""una mattina"", ""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1, s2,s3,s4,s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sıralı çalma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""\n karışık çalma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""\n rockçu özel çalma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""\n metal özellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { ( (metalsarki) sarki).gostermetalozellikleri(); } } } } public class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { super(isim,sanatci); } @override void oynat() { system.out.println(""klasik""+ "" sanatçı adı: "" + sanatci + "" şarkı adı: "" + isim + "" hafif ve sakin"" ); } } public class metalsarki extends sarki { private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(isim,sanatci); this.metalozellik=metalozellik; } void gostermetalozellikleri() { system.out.println(metalozellik); } @override void oynat() { system.out.println(""metal"" + "" sanatçı adı: "" + sanatci + "" şarkı adı: "" + isim + "" özellik: "" + metalozellik); } } public class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { super(isim,sanatci); } @override void oynat() { system.out.println(""rock""+ "" sanatçı adı: "" + sanatci + "" şarkı adı: "" + isim + "" huzurlu ve nostaljik""); } } import java.util.*; /* class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean [] issinged= new boolean[sarkilistesi.size()]; while(varmi( issinged)) { double a=math.random(); int i= (int) a * 100; if(issinged[i]==false) { } } } public boolean varmi(boolean[] issinged) { boolean flag=true; for(int i=0; i<issinged.length; i++) { if(!issinged[i]) flag=false; } return flag; } } */ public class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { list<sarki> karisikliste = new arraylist<>(sarkilistesi); collections.shuffle(karisikliste); for (sarki sarki : karisikliste) { sarki.oynat(); } } } import java.util.*; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } public abstract class sarki { string isim, sanatci; public sarki(string isim, string sanatci) { this.isim=isim; this.sanatci=sanatci; } abstract void oynat(); } import java.util.*; public class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean sesyuksek = false; for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof rocksarki && !sesyuksek) { system.out.println(""alert!! ses düzeyi: yüksek""); sesyuksek = true; } sarkilistesi.get(i).oynat(); if (sesyuksek && (i == sarkilistesi.size() - 1 || !(sarkilistesi.get(i + 1) instanceof rocksarki))) { system.out.println(""alert!! ses düzeyi: düşük""); sesyuksek = false; } } } } import java.util.*; interface calmastratejisi { void cal(list<sarki> sarkilistesi); } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. bir metodun içerisinde metodun kendisinin tekrar tekrar çağırılmasıdır. uygun koşul sağlandığında metoda tekrar girmez ve metod burada sonlanır. recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. base case, metodun kendisinin içine tekrardan girmemesini sağlayan koşulu arayan adımdır. bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? metoda parametre olarak stringi ve count++ değerini gönderirim, 0la başlayan count lengthe eşit olduğunda tekrar metoda girmez bu da base caseimiz olur recursive bir metotta base case olmazsa ne olur? stack overflowla karşılaşırız recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. değişen değerler için stackte her bir veri tipi için teker teker yer açılır. fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. tutulması gereken fazla sayıda değer olduğu için her birisini değiştirmek çok zor olur tail recursion nedir, kısaca açıklayınız. metodun kendisinin tekrar return edilmesidir java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? bir metodun hangi türünün çağrılacağına karar vermesidir, static ve dynamic olarak iki çeşidi vardır hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? constructor, final ve private metotlarda static binding yapılır; override edilmiş metotlarda dynamic binding yapılır dinamik bağlamada jvm'nin görevi nedir? hangi sınıfa ait olduğunu belirler ve ona göre metodu çağırır java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? jvm ayırt edemezdi ve compilor hata verirdi java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? cevap veremedim java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. üst sınıfın access modifierı, alt sınıfın access modifierından geniş olamaz, kısıtlaması budur. polimorfizm ise doğru metodun çağrılmasını sağlar, protected bir metod override edilebilir(public olarak) private veya default metodlarda edilmez class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik bağlama class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? dinamik bağlama child display child special java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract classlar doğrudan nesne oluşturamaz ancak alt sınıflar tarafından miras alınarak kullanılabilir(concrete classtan farklı) abstract class ve interfacelerin constructoru yoktur abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? evet edilebilir ancak gövdesi abstract class içinde verilmek zorundadır, ve sadece imza olarak bulunur abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract class içinde ortak özelliğe sahip metodlar ve özellikler tanımlanabilir ve böylece alt sınıflar bu metodları tekrar etmezler başka yazmaya vaktin kalmadı abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract class tek classı miras alabilir, interface birden fazla sınıfı implement edebilir interfaceler yalnızca abstract metodlar içerir, abstract classlar ise hem gövdeli hem gövdesiz metodlara sahiptir evet böyle bir tanımlama mümkündür marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface hiçbir metod içermez sadece bir sınıfın bir özelliğe sahip olduğunu belirtmek için kullanılır functional ise sadece bir abstract metodundan oluşan interfacedir, lambda ifadelerinden çok bahsetmiştiniz bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet bir class birden çok interfacei implement edebilir ancak bir interface başka bir interfacei implement edemez ancak extend edebilir abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abstract class olan animal doğrudan nesne oluşturulmaya çalışılıyor animal a satırı hatalı çıktı animal :buddy wolf interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? bulamadım yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. syntax hatası örnek: i̇nt sayi=5 compile time hatası örnek: i̇nt sayi=""merhaba""; run time hatası örnek: int sayi=10/0; exception handlingin amacı nedir? program sırasında oluşabilecek hataları kontrol altına alarak uygun şekilde çalışmasını sağlamaktır exception handlingde finally bloğunun amacı nedir? hata olsa da olmasa da her türlü çalışmasını istediğimiz parçanın çalışmasını sağlar java'da 'checked' ve 'unchecked' exceptionların farkı nedir? checked exceptionlar derleme zamanında kontrol edilir, unchecked ise runtime da kontrol edilir checked exceptionlarda try catch blokları kullanılır java'da kendi exceptionunuzu nasıl tanımlarsınız? exception veya runtime exception classlarından derived class oluşturarak java'da error ve exception arasındaki fark nedir, açıklayınız exceptionlar bloklarla düzeltilebilecek sorunlardır genellikle ufak tefek yanlışlarla olur( örneğin syntax) errorlar ise genelde kullanıcı tarafından yakalanamaz yazılan algoritmada bir sıkıntı oluşması örnek olabilir java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? hatayı daha detaylı loglamak ve daha anlamlı bşr exception ile değiştirmek 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? daha geniş kapsamlı exception fırlatılamaz static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenmez, main method yazımı hatalı catch bloklarının yazım sırası yanlış static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.arraylist; public class quiz1q2 { public static void main(string[] args) { penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); habitat habitat = new habitat(""antarctica"",-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); } } class habitat { private string location; private double temperature; private arraylist<penguin> penguins; public habitat(string location, double temperature) { this.location=location; this.temperature=temperature; } public void printhabitat() { system.out.println("" habitat location: "" + location); system.out.println(""average temperature: ""+ temperature); system.out.println(""penguins living here: ""); system.out.println(penguins); } public string getlocation() { return location; } public void setlocation() { system.out.println(location); } public double gettemp() { return temperature; } public void settemp() { system.out.println(temperature); } public arraylist<penguin> getarrayyylist() { return penguins; } public void setarraylist() { system.out.println(penguins); } public void addpenguin(penguin p) { penguins.add(p); } } class penguin { private string name; private string species; private int age; private double weight; public penguin(string name, string species, int age, double weight) { this.name=name; this.age=age; this.weight=weight; this.species=species; } public penguin() { this.name=""willy""; this.species=""emperor""; this.age=1; this.weight=5.0; } public void printpenguin() { system.out.print(""penguin name: "") ; system.out.print(name); system.out.println(""years weight:""+ weight + ""kg""); system.out.print(""species: ""); system.out.print(""age: "" + age); } public string getname() { return name; } public void setname() { system.out.println(name); } public string getspecies() { return species; } public void setspecies() { system.out.println(species); } public int getage() { return age; } public void setage() { system.out.println(age); } public double getweight() { return weight; } public void setweight() { system.out.println(weight); } public void hunt() { weight+=1.0; } } import java.util.random; public class quiz1q1 { public static void main(string[] args) { parantezbas(3); } static string[] dizi= new string[99]; static int index=0; public static void helper(string str, int n) { boolean flag1=parantezaçsayısı(str, n); boolean flag2=parantezsayısı(str); boolean flag3=eşitmi(str); if(index==2*n-1) for(int i=0; i<dizi.length; i++) system.out.print(dizi[i] + "" ""); if(str.length()==n*2) { dizi[index]=str; str=""""; index++; helper(str,n); } random generator= new random(1); if(generator.nextint()==0) { if(flag1) { if(flag2) { str+=""(""; helper(str, n); } else helper(str, n); } else { str=str.substring(0,str.length()-1); if(flag2) { if(!flag3) str+="")""; else { dizi[index]=str; str=""""; index++; helper(str,n); } } } } if(generator.nextint()==1) { if(flag3) helper(str, n); else { if(flag1&&flag2) str+="")""; else helper(str, n); } } } public static void parantezbas(int n) { helper("""", n); } public static boolean parantezsayısı(string kelime) { int a=0; int b=0; for(int i=0; i<kelime.length()-1; i++) { if(kelime.charat(i)=='(') { a++; } else b++; } if(a>b) return true; else return false; } public static boolean parantezaçsayısı(string s, int n) { int a=0; for(int i=0; i<s.length()-1; i++) { if(s.charat(i)=='(') { a++; } } if(a>n) return false; else return true; } public static boolean eşitmi(string kelime) { int a=0; int b=0; for(int i=0; i<kelime.length()-1; i++) { if(kelime.charat(i)=='(') { a++; } else b++; } if(a==b) return true; else return false; } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public class latte extends basecoffee { public latte() { basecoffee.count++; } @override public double calculateprice() { return 50.0; } public boolean lattekontrol(coffeeaddon addons) { if(addons instanceof doubleshot) return false; else return true; } } public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(""\n""); anothermachine.toplamkahve(americano); } } public class espresso extends basecoffee { private boolean isheated= false; public espresso() { basecoffee.count++; } @override public double calculateprice() { if(isheated) { heatprint(); } return 40.0; } public void heatcup() { this.isheated=true; } public void heatprint() { system.out.println("" espresso (sıcak fincan)""); } public boolean espressokontrol(coffeeaddon addons) { if(addons instanceof milk) return false; else if(addons instanceof vanillasyrup) return false; else return true; } } public class vanillasyrup implements coffeeaddon { @override public double getcost() { return 6.0; } @override public string getname() { return ""vanilla syrup ""; } } public interface coffeeaddon { double getcost(); string getname(); } import java.util.arraylist; public abstract class basecoffee { public static int count=0; public abstract double calculateprice(); protected arraylist<coffeeaddon> addons; public arraylist<basecoffee> coffees; public void addaddon(coffeeaddon addon) { addons.add(addon); } public boolean eklentikontrol(basecoffee coffee, coffeeaddon adddon) { boolean flag; if(coffee instanceof espresso) flag= ((espresso) coffee).espressokontrol(adddon); else if(coffee instanceof americano) flag= ((americano) coffee).americanokontrol(adddon); else flag= ((latte)coffee).lattekontrol(adddon); return flag; } public void eklenemezprint(basecoffee coffeee, coffeeaddon adddonn ) { if(!eklentikontrol(coffeee, adddonn)) { system.out.println( "" [uyari]!!!! "" + coffeee + "" tipi kahveye "" + adddonn + "" eklenemez.""); } else system.out.println(); } } public class americano extends basecoffee { public americano() { basecoffee.count++; } @override public double calculateprice() { return 45.0; } public boolean americanokontrol(coffeeaddon addons) { if(addons instanceof doubleshot) return false; else if(addons instanceof chocolate) return false; else return true; } } public class coffeemachine { double price=0; public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) { if(coffee.eklentikontrol(coffee,adddon)) { price+=adddon.getcost(); coffee.addaddon(adddon); } else coffee.eklenemezprint(coffee, adddon); } public void makecoffee(basecoffee coffee) { price+= coffee.calculateprice(); if(coffee instanceof espresso) { system.out.println("" espresso kahve fincanı ısıtıldı""); ((espresso) coffee).heatcup(); } else system.out.println(""[uyari]!!! sadece espresso kahve fincanları ısıtılabilir""); price=0; } public void heatespressocup(basecoffee coffee) { if(coffee instanceof espresso) { system.out.println(""espresso kahve fincanı ısıtıldı""); ((espresso) coffee).heatcup(); } } public void toplamkahve(basecoffee coffee) { system.out.println(""tum fabrikalar kahve makineleri "" + basecoffee.count + ""toplam kahve uretildi""); } } public class milk implements coffeeaddon { @override public double getcost() { return 5.0; } @override public string getname() { return ""milk ""; } } public class doubleshot implements coffeeaddon { @override public double getcost() { return 10.0; } @override public string getname() { return ""double shot ""; } } public class chocolate implements coffeeaddon { @override public double getcost() { return 7.0; } @override public string getname() { return ""chocolate ""; } } 2",36012,4558,738,241,53,16
8435496,0,"8435496 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. package lab.lab1; public class lab1q3 { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s2.say()); } } class sayac { private string string; private int length; public sayac(string string) { this.string = string; this.length = string.length(); } public int say() { return birsay(0); } private int birsay(int start) { if (start == length) return 0; if (string.charat(start) == '1') { return 1 + birsay(start + 1); } return birsay(start + 1); } } package lab.lab1; public class lab1q2 { public static void main(string[] args) { int[] arr = {5, 4, 1, 2, 7, 3, 15, -1}; cocktailsort(arr); for (int i = 0; i < arr.length; i++) { system.out.print(arr[i] + "" ""); } } public static void cocktailsort(int[] arr) { bubbletoright(arr); } public static void bubbletoright(int[] arr) { int changes = 0; for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; changes++; } } if (changes == 0) return; bubbletoleft(arr); } public static void bubbletoleft(int[] arr) { int changes = 0; for (int i = arr.length - 1; i > 0; i--) { if (arr[i - 1] > arr[i]) { int temp = arr[i - 1]; arr[i - 1] = arr[i]; arr[i] = temp; changes++; } } if (changes == 0) return; bubbletoright(arr); } } package lab.lab1; public class lab1q1 { public static void main(string[] args) { system.out.println(collatz(3)); } public static int collatz(int i) { if (i == 1) return 0; if (i % 2 == 0) { return 1 + collatz(i / 2); } return 1 + collatz(3 * i + 1); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 package lab.lab2; import java.util.list; public class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { this.strateji = s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } package lab.lab2; import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } } } } package lab.lab2; public class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { super(); super.isim = isim; super.sanatci = sanatci; } @override void oynat() { system.out.println(""[klasik] "" + super.sanatci + "" - "" + super.isim + "" (hafif ve sakin)""); } } package lab.lab2; public class metalsarki extends sarki { private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(); super.isim = isim; super.sanatci = sanatci; this.metalozellik = metalozellik; } void gostermetalozellikleri() { system.out.println(super.sanatci + "" - "" + super.isim +"" [ozellik: "" + this.metalozellik + ""]""); } @override void oynat() { system.out.println(""[metal] "" + super.sanatci + "" - "" + super.isim + "" ("" + this.metalozellik + "")""); } } package lab.lab2; public class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { super(); super.isim = isim; super.sanatci = sanatci; } @override void oynat() { system.out.println(""[rock] "" + super.sanatci + "" - "" + super.isim + "" (huzurlu ve nostaljik)""); } } package lab.lab2; import java.util.arraylist; import java.util.collections; import java.util.list; public class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { list<sarki> sarkilar = new arraylist<>(); for(sarki sarki : sarkilistesi) { sarkilar.add(sarki); } collections.shuffle(sarkilar); for (sarki sarki : sarkilar) { sarki.oynat(); } } } package lab.lab2; import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } package lab.lab2; public abstract class sarki { string isim; string sanatci; abstract void oynat(); } package lab.lab2; import java.util.list; public class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean rockmode = false; for (sarki sarki : sarkilistesi) { if (!rockmode && sarki instanceof rocksarki) { rockmode = true; system.out.println(""[bilgi] ses duzeyi: yuksek""); } if (rockmode && !(sarki instanceof rocksarki)) { rockmode = false; system.out.println(""[bilgi] ses duzeyi: normal""); } sarki.oynat(); } if (rockmode) { system.out.println(""[bilgi] ses duzeyi: normal""); } } } package lab.lab2; import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. kendini çağıran metot. base case: kendini çağırmayı sonlandırdığı durum. i̇şlemi yaptığı yer ve birleştirdiği yer. recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. sonsuz kere kendisini çağırmasını önlemek için. bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? stringin 1 karakter olması base case. subtring(1) + baştaki karakteri recursive bir metotta base case olmazsa ne olur? stack overflow recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. yeni metotun kwndi değişkenleri ve parametreleri stacke ekleneir fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. n-1 ve n-2 yi ayrı ayrı hesaplarkan aynı değeri birden fazla kez hesapladığından tail recursion nedir, kısaca açıklayınız. recursive call un fonksiyonun yağtığı en son işlem olması. loop a kolayca çevrilebilir abstraction kavramını açıklayınız. kodun nasıl çalıştığını bilmemize gerek olmadan bir parçayı kendi başına kullanılabilecek şekilde programın parçalara ayrılması.. ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? i̇nheritance dır.extends gerekir. bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? default ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? c ve a java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? önce parent class ı initialize edip sonra kendisini eder. yazmazsak parent classın parametresiz olan constructor ı çağırılır. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? hayır metot overriding ve overloading kavramlarını açıklayınız. overriding alt classlarda o class için metodun implementationın değiştirilmesi. overloading metotun imzasını değiştirerek aynı isimle metodun yazılması. class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dog /n bark class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? circle /n 8.0 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? çağırılan metodun implement edildiği yer ile bağlanmasıdır. hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? override edilen metotlar dynamic bind olur. final static ve private olan metotlar kesinlikle static bind olur. dinamik bağlamada jvm'nin görevi nedir? class larda yukarı giderek metodun ilk karşılaştığı implementation ını metodun çsğırıldığı yere bağlamak. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? gereksiz bir şekilde yavaş olurdu. java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? o class ın ne olduğunu bizim bilip ona göre cast etmemz gerekir çünkü cast edeceğim class ta o classa özgü olan özellikler olabilir. java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. hayır çünkü o classın belirli yetkilere sahip olan yerlerden erişilebilen özelliği olmaktan çıkrsa override olmaz. class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? animal sound /n bark /n animal sound /n meov /n bark /n meov (dynamic) class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? p.special(); hata verir output: child display (static) java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class içinde implementasyonu yapılmamış metot veya metotlar bulunan class tır. constructor ları olamaz çünkü implementasyonu yapılmayan bir özellik kullanılamayacağından objeleri oluşturulmaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? extend edilfiğinde bazı abstract metotlar implement edilebilir. eğer abstarct metot hala varsa extend edilmiş olan class da abstract kalmak zorunda. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. belli bir grup objenin bir metodunu bir yerde tanımplayıp her obje için farklı implent etme. birden fazla exrend yapamadığımızdan ortak özellikleri olan ama birbirlerini extend etöeyen classlarda ortak özelliklerin bulunmasını sağlama. bir yerde ihyiyacımız olan metodu tanımlayıp sonra implement etme. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? i̇nterfaceler implement edilebilir classlar edilemez. evet o özelliklere sahip objeleri tutabilirler. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker içinde metot olmayan interface, tag gibi kullanılır. functional da içinde bir metot olan lambda olarak oluşturulabilirler. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet .i̇mplement edemez çünkü class değil ama extend edwbiliriz. abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? animal abstract olduğundan objesi oluşturulamaz new dog yazarsak düzelir. animal: buddy /n woof interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? evet. swimming java'da inner class nedir, avantajları nelerdir? classın içinde class. dış class olmadan anlamı olmayan classlar için kullanılabilir. dış class oluşturmadan inner oluşturulmamasını sağlar. statik ve statik olmayan (member) inner class arasındaki temel fark nedir? staticten obje üretilimez ve içine inner eklenemez. anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? bir kerelik kullanalıcak olan class. başka class veya interface ten extend edilebilir. inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? evet. değiştirebilir. statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? evet static final değişken (constant yani). anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? hayır. anonim sadece bir kere kullanılır. hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? private olmayan class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? mainde ilk outer objesi oluşturulup o obje.new yapılmalı value: 10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? static classtan obje üretilmez. mainde sadece staticinner.showvount(); count: 5 yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. 2 compile time, örnek: syntax hatası. runtime: array index out of bounds hatası. exception handlingin amacı nedir? hata olduğunda program tamamen durmaz. o hata handle edilir ve devam edilebilir. exception handlingde finally bloğunun amacı nedir? her zaman çalışır. hata olsa da olmasa da try catch ten sonra çaışır. (system.exit() yapmazsak) java'da 'checked' ve 'unchecked' exceptionların farkı nedir? checked in kodda handle edilmesi compiler tarafıdan zorunlu tutulur. unchecked in tutulmaz. java'da kendi exceptionunuzu nasıl tanımlarsınız? yeni class açıp exception veya onun child classlarından bitini extend ederim. java'da error ve exception arasındaki fark nedir, açıklayınız error throwable değil java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? çağırılan metotlar stack inde her yerde handle etmek. 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? extend edilen throwable orijinal metotta edilen den dar (edilenin child ı) olamaz. static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? hata yok exception caught static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg package quiz.quiz1; import java.util.arraylist; public class quiz1q2 { public static void main(string[] args) { penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(""antarctica"", -15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); } } class habitat { private string location; private double temperature; private arraylist<penguin> penguins; public habitat(string location, double temperature) { this.location = location; this.temperature = temperature; penguins = new arraylist<penguin>(); } public void addpenguin(penguin penguin) { penguins.add(penguin); } public void printhabitat() { system.out.println(""habitat location: "" + this.location + ""\naverage temperature: "" + this.temperature + ""°c""); system.out.println(""penguins living here:""); for (penguin p : penguins) { p.printpenguin(); system.out.println(); } } public string getlocation() { return location; } public void setlocation(string location) { this.location = location; } public double gettemperature() { return temperature; } public void settemperature(double temperature) { this.temperature = temperature; } public arraylist<penguin> getpenguins() { return penguins; } public void setpenguins(arraylist<penguin> penguins) { this.penguins = penguins; } } class penguin { private string name; private string species; private int age; private double weight; public penguin() { this.name = ""willy""; this.species = ""emperor""; this.age = 1; this.weight = 5.0; } public penguin(string name, string species, int age, double weight) { this.name = name; this.species = species; this.age = age; this.weight = weight; } public void hunt() { weight += 1; } public void printpenguin() { system.out.print(""penguin name: "" + this.name + "" species: ""+ this.species + "" age: "" + this.age + "" years weight: "" + this.weight +"" kg""); } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getspecies() { return species; } public void setspecies(string species) { this.species = species; } public int getage() { return age; } public void setage(int age) { this.age = age; } public double getweight() { return weight; } public void setweight(double weight) { this.weight = weight; } } package quiz.quiz1; import java.util.arraylist; public class quiz1q1 { public static void main(string[] args) { parantezbas(3); // n:13 olduğunda çok vakit harcamaya başlıyor. } public static void parantezbas(int n) { if (n < 0) { system.out.println(""??? parantezbas("" + n + "") ???""); return; } arraylist<string> parantezler = parantezbul(n); int length = parantezler.size(); for (int i = 0; i < length - 1; i++) { system.out.print(parantezler.get(i) + "", ""); } if (length > 0) system.out.print(parantezler.get(length - 1)); } private static arraylist<string> parantezbul(int n) { arraylist<string> p = new arraylist<>(); if (n == 0) return p; if (n == 1) { p.add(""()""); return p; } for (string s : parantezbul(n - 1)) { if (!p.contains(""("" + s + "")"")) p.add(""("" + s + "")""); if (!p.contains(s + ""()"")) p.add(s + ""()""); if (!p.contains(""()"" + s)) p.add(""()"" + s); } return p; } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 package quiz.quiz2; public class latte extends basecoffee { @override public double calculateprice() { double price = 50; system.out.print(""sipariş: latte""); for (coffeeaddon addon : addons) { price += addon.getcost(); system.out.print("" + "" + addon.getname()); } system.out.println(); return price; } @override public string getname() { return ""latte""; } } package quiz.quiz2; public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(""\n""); coffeemachine.printtimes(); } } package quiz.quiz2; public class espresso extends basecoffee { private boolean isheated = false; @override public double calculateprice() { double price = 40; system.out.print(""sipariş: ""); if (isheated) { system.out.print(""espresso (sıcak fincan)""); } else { system.out.print(""espresso""); } for (coffeeaddon addon : addons) { price += addon.getcost(); system.out.print("" + "" + addon.getname()); } system.out.println(); return price; } @override public string getname() { return ""espresso""; } public void heatcup() { isheated = true; system.out.println(""espresso kahve fincanı ısıtıldı""); } } package quiz.quiz2; public class vanillasyrup implements coffeeaddon { @override public double getcost() { return 6; } @override public string getname() { return ""vanilla syrup""; } } package quiz.quiz2; public interface coffeeaddon { double getcost(); string getname(); // todo: } package quiz.quiz2; import java.util.arraylist; public abstract class basecoffee { protected arraylist<coffeeaddon> addons; public basecoffee() { addons = new arraylist<>(); } public void addaddon(coffeeaddon addon) { addons.add(addon); } public abstract double calculateprice(); public abstract string getname(); } package quiz.quiz2; public class americano extends basecoffee { @override public double calculateprice() { double price = 45; system.out.print(""sipariş: americano""); for (coffeeaddon addon : addons) { price += addon.getcost(); system.out.print("" + "" + addon.getname()); } system.out.println(); return price; } @override public string getname() { return ""americano""; } } package quiz.quiz2; public class coffeemachine { private static int times = 0; public void addaddontocoffee(basecoffee coffee, coffeeaddon addon) { if (coffee instanceof espresso && addon instanceof milk) { system.out.println(""[uyari] "" + coffee.getname() + "" tipi kahveye "" + addon.getname() + "" eklenemez""); return; } coffee.addaddon(addon); } public void makecoffee(basecoffee coffee) { double price = coffee.calculateprice(); system.out.println(""toplam fiyat: "" + price + ""tl\n""); times++; } public void heatespressocup(basecoffee coffee) { if (coffee instanceof espresso) { ((espresso) coffee).heatcup();; } else { system.out.println(""[uyari] yalnızca espresso kahve fincanları ısıtılabilir""); } } public static void printtimes() { system.out.println(""tum kahve makineleri tarafindan toplam "" + times + "" kahve uretildi""); } } package quiz.quiz2; public class milk implements coffeeaddon { @override public double getcost() { return 5; } @override public string getname() { return ""milk""; } } package quiz.quiz2; public class doubleshot implements coffeeaddon { @override public double getcost() { return 10; } @override public string getname() { return ""double shot""; } } package quiz.quiz2; public class chocolate implements coffeeaddon { @override public double getcost() { return 7; } @override public string getname() { return ""chocolate""; } } 0",38923,5188,757,243,73,27
8783086,0,"8783086 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class q2 { public static void main(string[] args) { int[] arr = { 5, 4, 1, 2, }; coctailsort(arr); for (int i = 0; i < arr.length; i++) { system.out.println(arr[i]); } } public static void coctailsort(int[] arr) { boolean issorted = bubble(arr); if (issorted == true) { for (int i = arr.length - 1; i > 0; i--) { if (arr[i] < arr[i - 1]) { int x = arr[i]; arr[i] = arr[i - 1]; arr[i - 1] = x; } } coctailsort(arr); } } public static boolean bubble(int[] arr) { boolean flag = false; for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { int x = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = x; flag = true; } } return flag; } } public class q1 { public static void main(string[] args) { system.out.println(collatz(5)); } public static int collatz(int i) { int count = 0; if (i != 1) { if ((i % 2) == 0) { count += 1; return count + collatz(i / 2); } else { count += 1; return count + collatz((3 * i) + 1); } } return count; } } public class q3 { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } class sayac { string x; sayac(string x) { this.x = x; } public int say() { int count = 0; if (x.length() >= 1) { if (x.charat(0) == '1') { count += 1; } x = subof(x); return count + say(); } return 0; } public string subof(string x) { return x.substring(1); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { calmastratejisi s; void setstrateji(calmastratejisi s) { this.s = s; } void muzikcal(list<sarki> sarkilistesi) { s.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellik(); } } } } public class klasiksarki extends sarki { klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + ""( hafif ve sakin)""); } } public class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void gostermetalozellik() { system.out.println(sanatci + "" - "" + isim + "" [ozellik: "" + metalozellik + ""]""); } void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } } public class rocksarki extends sarki { rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + isim + ""( huzurlu ve nostaljik)""); } } import java.util.list; import java.util.arraylist; public class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { list<sarki> sarkilistesi1 = new arraylist<sarki>(); for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi1.add(sarkilistesi.get(i)); } for (sarki sarki : sarkilistesi1) { sarki.oynat(); } } } import java.util.list; public class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } abstract class sarki { string isim; string sanatci; abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { boolean flag = false; for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof rocksarki && flag == false) { system.out.println(""[bilgi] ses duzeyi: yuksek""); flag = true; } if (i != 0 && sarkilistesi.get(i - 1) instanceof rocksarki && !(sarkilistesi.get(i) instanceof rocksarki)) { flag = false; system.out.println(""[bilgi] ses duzeyi: normal""); } sarkilistesi.get(i).oynat(); } } } import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. problemi parçalayarak daha küçük problemler üzerinden büyük problemi çözmek recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. döngüden çıkabilmesi için gereken şart bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? base case string ==“” olurdu indexi birer birer arttırarak substringle methodu yeniden çağırıp 0. elemanı print ettirirdim recursive bir metotta base case olmazsa ne olur? stack overflow recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. üst üste katman halinde veriler stackte birikir fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. çok fazla katman oluşur tail recursion nedir, kısaca açıklayınız. . abstraction kavramını açıklayınız. detayları göstermeyip sadece işlevleri göstermek ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? bir classın diğer classın subclassı olması lazım bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? protected ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? a, b java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? çünkü subclassın çalışabilmesi için önce base classının constructorunun çalışması lazım java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? mümkün değil çünkü her classın sadece 1 atası olabilir metot overriding ve overloading kavramlarını açıklayınız. overloading methodun signiture kısmını değiştirip bambaşka bir method gibi yazılması override ise birebir aynı methodun farklı işlem yapmasını sağlamak class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dog bark! class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? circle 8 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? methodların bağlanması static dynamic hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? overload static, override dynamic dinamik bağlamada jvm'nin görevi nedir? method override edilmiş mi diye kontrol etmek java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? program daha yavaş çalışırdı java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? classlar bağlı olmayabilir java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. var edilemez class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? bark meov dinamik bağlama class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? göremedim child display child special dinamik java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract classlar inherit edilemez constructorları olamaz abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? edilemez abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract classlar inherit edilemez abstract metotlar var olması istenen ama sonradan görevi belli olacak methodlarda kullanılabilir abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? kullanılabilir mümkün marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface içinde method bulunmaz functionalda ise 1 method bulunur bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? ikiside edilebilir abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? obje animal olduğu için sound methodu çalışmaz objeyi dog a çevirerek düzeltilebilir interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? compile edilemez move methodu hem swimmable hem flyable içinde var java'da inner class nedir, avantajları nelerdir? class içinde class kodu düzenlemeye yarar statik ve statik olmayan (member) inner class arasındaki temel fark nedir? statik olan inner classı oluşturmak için outer objecte gerek yok anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? anlık olarak method implement etmek için oluşturulan class interface ve abstract classlar ile oluşturulabilir inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? erişebilir çünkü zaten o classın içinde statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? tanımlanamaz çünkü inner class için obje gerekir anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? olamaz hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? public inner classlar ile yaratılabilir class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? başta outer objesi oluşturulması lazım output = value: 10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? statik inner class için objeye gerek yok count static olduğu için ordada sıkıntı yok output = count: 5 yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. 2 çeşit error exception file io exception handlingin amacı nedir? hatayı bulup düzeltmek için exception handlingde finally bloğunun amacı nedir? try catchten sonra her türlü çalıştırmak istenilen kod için kullanılır java'da 'checked' ve 'unchecked' exceptionların farkı nedir? cheked exceptionlar runtime a geçmeden zaten kontrol edilmiş olur java'da kendi exceptionunuzu nasıl tanımlarsınız? exception klasını extend ederek tanımlanabilir java'da error ve exception arasındaki fark nedir, açıklayınız . java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? catch edile bloğun dışında başka bir catch bloğu olabilir 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? return type ın throwable olması lazım static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenir exception caught static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.arraylist; public class q2 { public static void main(string[] args) { penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); habitat habitat = new habitat(""antarctica "", -15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); } } class penguin { private string name; private string species; private int age; private double weight; public penguin() { this.name = ""willy""; this.species = ""emperor""; this.age = 1; this.weight = 5.0; } public penguin(string name, string species, int age, double weight) { this.name = name; this.species = species; this.age = age; this.weight = weight; } public string getname() { string namecopy = name; return namecopy; } public string getspecies() { string speciescopy = species; return speciescopy; } public int getage() { int agecopy = age; return agecopy; } public double getweight() { double weightcopy = weight; return weightcopy; } public void setname(string newname) { name = newname; } public void setspecies(string newspecies) { species = newspecies; } public void setage(int newage) { age = newage; } public void setweight(double newweight) { weight = newweight; } public void hunt() { weight += 1; } } class habitat { private string location; private double temperature; private arraylist<penguin> penguins = new arraylist<>(); public habitat(string location, double temperature) { this.location = location; this.temperature = temperature; system.out.println(""habitat location: "" + location); system.out.println(""average temperature: "" + temperature); } public string getlocation() { string locationcopy = location; return locationcopy; } public double gettemperature() { double temperaturecopy = temperature; return temperaturecopy; } public void addpenguin(penguin penguin) { penguins.add(penguin); } public void printhabitat() { system.out.println(""penguins living here: ""); for (int i = 0; i < penguins.size(); i++) { system.out .println(""penguin name: "" + penguins.get(i).getname() + "" species: "" + penguins.get(i).getspecies() + "" age: "" + penguins.get(i).getage() + "" weight: "" + penguins.get(i).getweight()); } } } public class q1 { public static void main(string[] args) { parantezbas(3); } public static void parantezbas(int n) { if (n > 0) { system.out.print(""(""); parantezbas(n - 1); system.out.print("")""); } } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public class latte extends basecoffee { public double calculateprice() { double price = 50.0; for (int i = 0; i < addons.size(); i++) { price += addons.get(i).getcost(); } return price; } } public class main { public static void main(string[] args) { basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); } } import java.util.arraylist; public class espresso extends basecoffee { private boolean isheated = false; public double calculateprice() { double price = 40.0; for (int i = 0; i < addons.size(); i++) { price += addons.get(i).getcost(); } return price; } public setheat(boolean heat) { isheated = heat; } } public class vanillasyrup implements coffeeaddon { public double getcost() { return 6.0; } public string getname() { return ""vanillasyrup""; } } public interface coffeeaddon { double getcost(); string getname(); } import java.util.arraylist; public abstract class basecoffee { protected arraylist<coffeeaddon> addons = new arraylist<>(); public void addaddon(coffeeaddon addon) { addons.add(addon); } public abstract double calculateprice(); } public class americano extends basecoffee { public double calculateprice() { double price = 45.0; for (int i = 0; i < addons.size(); i++) { price += addons.get(i).getcost(); } return price; } } public class coffeemachine { boolean heat = false; public void addaddontocoffee(basecoffee coffee, coffeeaddon addon) { if (coffee instanceof espresso && (addon instanceof milk || addon instanceof vanillasyrup)) { system.out.println(""[uyari] espresso tipi kahveye "" + addon.getname() + "" eklenemez""); } else if (coffee instanceof latte && addon instanceof doubleshot) { system.out.println(""[uyari] latte tipi kahveye "" + addon.getname() + "" eklenemez""); } else if (coffee instanceof americano && (addon instanceof doubleshot || addon instanceof chocolate)) { system.out.println(""[uyari] americano tipi kahveye "" + addon.getname() + "" eklenemez""); } else { coffee.addaddon(addon); } } public void heatespressocup(basecoffee coffee) { if (coffee instanceof espresso) { system.out.println(""espresso kahve fincanı ısıtıldı""); heat = true; } else { system.out.println(""[uyari] sadece espresso fincanları ısıtılabilir""); } } public void makecoffee(basecoffee coffee) { if (coffee instanceof espresso && heat == true) { system.out.print(""sipariş: espresso (sıcak fincan) ""); for (int i = 0; i < coffee.addons.size(); i++) { system.out.print("" + "" + coffee.addons.get(i).getname()); } } else if (coffee instanceof espresso) { system.out.print(""sipariş: espresso ""); for (int i = 0; i < coffee.addons.size(); i++) { system.out.print("" + "" + coffee.addons.get(i).getname()); system.out.println(); system.out.println(""toplam fiyat:"" + coffee.calculateprice()); } } else if (coffee instanceof americano) { system.out.print(""sipariş: americano ""); for (int i = 0; i < coffee.addons.size(); i++) { system.out.print("" + "" + coffee.addons.get(i).getname()); system.out.println(); system.out.println(""toplam fiyat:"" + coffee.calculateprice()); } } else if (coffee instanceof latte) { system.out.print(""sipariş: latte ""); for (int i = 0; i < coffee.addons.size(); i++) { system.out.print("" + "" + coffee.addons.get(i).getname()); system.out.println(); system.out.println(""toplam fiyat:"" + coffee.calculateprice()); } } } } public class milk implements coffeeaddon { public double getcost() { return 5.0; } public string getname() { return ""milk""; } } public class doubleshot implements coffeeaddon { public double getcost() { return 10.0; } public string getname() { return ""doubleshot""; } } public class chocolate implements coffeeaddon { public double getcost() { return 7.0; } public string getname() { return ""chocolate""; } } 0",35562,4803,658,224,63,16
4731282,0,"4731282 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q3 { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s2.say()); } } class sayac { string sayilacak; int count = 0; sayac(string s) { sayilacak = s; } public int say() { return say(0, this.sayilacak); } public int say(int count, string s) { if (s.length() == 1) { if (s.charat(0) == '1') { return count + 1; } else return count; } if ((s.charat(0)) + 0 == '1') { return say(count + 1, s.substring(1)); } else { return say(count, s.substring(1)); } } } public class lab1q2 { public static void main(string[] args) { int[] array = { 1, 5, 4, 2 }; cocktailsort(array); for (int k = 0; k < array.length; k++) { system.out.print(array[k] + "" ""); } } public static void cocktailsort(int[] arr) { cocktailsort(arr, true); } public static int[] cocktailsort(int[] arr, boolean flag) { int temp = 0; boolean arrflag = true; if (flag == true) { for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { temp = arr[i + 1]; arr[i + 1] = arr[i]; arr[i] = temp; arrflag = false; } } } if (flag == false) { for (int j = arr.length - 1; j > 0; j--) { if (arr[j] < arr[j - 1]) { temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; arrflag = false; } } } if (flag == false) flag = true; if (flag == true) flag = false; if (arrflag == true) { return arr; } else { return cocktailsort(arr, flag); } } } public class lab1q1 { public static void main(string[] args) { int num = 9455; system.out.println(collatz(num)); } public static int collatz(int i) { return counter(0, i); } public static int counter(int count, int x) { if (x == 1) { return count; } if (x % 2 == 0) {// çiftse return counter(count + 1, x / 2); } else { // tekse return counter(count + 1, 3 * x + 1); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arraylist; import java.util.arrays; import java.util.list; public class lab2q1 { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumental""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } } system.out.println(); } } abstract class sarki { string isim; string sanatci; abstract void oynat(); } class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { super.isim = isim; super.sanatci = sanatci; this.metalozellik = metalozellik; } void oynat() { system.out.println(""[metal] "" + isim + "" - "" + sanatci + "" ("" + metalozellik + "")""); } void gostermetalozellikleri() { system.out.println(isim + "" - "" + sanatci + "" ("" + this.metalozellik + "")""); } } class rocksarki extends sarki { string rockozellik = ""huzurlu ve nostaljik""; rocksarki(string isim, string sanatci) { super.isim = isim; super.sanatci = sanatci; } void oynat() { system.out.println(""[rock] "" + isim + "" - "" + sanatci + "" ("" + rockozellik + "")""); } } class klasiksarki extends sarki { string klasikozellik = ""hafif ve sakin""; klasiksarki(string isim, string sanatci) { super.isim = isim; super.sanatci = sanatci; } void oynat() { system.out.println(""[klasik] "" + isim + "" - "" + sanatci + "" ("" + klasikozellik + "")""); } } interface calmastratejisi { void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); } } } class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { list<sarki> locallist = new arraylist<sarki>(sarkilistesi) ; for (int i = 0; i < sarkilistesi.size(); i++) { int rand = (int) math.random() * sarkilistesi.size(); sarki temp = locallist.get(rand); locallist.set(rand, locallist.get(i)); locallist.set(i, temp); } for (int i = 0; i < locallist.size(); i++) { locallist.get(i).oynat(); } } } class rockcuozelcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { boolean yukseldi = false; for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof rocksarki) { if (sarkilistesi.get(i + 1) instanceof rocksarki && yukseldi == false) { system.out.println(""[bilgi] ses duzeyi : yuksek""); yukseldi = true; } } else if (yukseldi == true) { system.out.println(""[bilgi] ses duzeyi : normal""); yukseldi = false; } sarkilistesi.get(i).oynat(); } } } class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi c) { this.strateji = c; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. recursionun temeli bir metodun tekrar kendini çağırmasıdır. recursion kodlarında bir base case (kodun sonsuz döngüye girmemesi için) olmalıdır, recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. base case, metoda girilen parametrenin her iterasyonda yaklaştığı bir durum olmalıdır ki kod sonsuz döngüye girmesin. bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? if string length < 1 recursive bir metotta base case olmazsa ne olur? kod sonsuz döngüye girer ve stack overflow gerçekleşir recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. yeni çağırılan metotlar üst üste biner, en son base case'e ulaşılınca sırayla operasyonlar gerçekleştirilir. fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. büyük sayılarla uğraşırken bilgisayar ne kadar hesaplama yapacağını bilmediği için for döngüsü ile yapılan hesaplamalar daha büyük sayılara ulaşabilir tail recursion nedir, kısaca açıklayınız. tek tek printlemek yerine tüm operasyonları return statementte yapan recursion abstraction kavramını açıklayınız. belli bir konudaki önemli detayları soyutlayarak kullanıcının algıladığı karmaşıklığı azaltmak ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? is a ilişkisi java'da extends ile sağlanır. is-a ilişkisi ata class ve subclass arasında olur bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? protected ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? b veya a java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? ata classın constructoru çalışmadan ata classın instance variable'ları initialize edilemez, bulunulan classta kullanılamaz java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? hayır, sadece bir kez extendlenebilir metot overriding ve overloading kavramlarını açıklayınız. overloading'de signature'ın parametreleri farklı, metod adı aynıdır; overriding'de farklı bir metod adı aynıdır, kullanılan class farklıdır class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dog bark! class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? circle 8 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? metodun hangi parametrelere ve classa göre çalışacağının belirlenmesidir. çeşitler dynamic binding ve static binding'dir. hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? static binding olması için static, final veya private keywordleri kullanılır. metod override'lanmadıysa static binding gerçekleşir, compile edilirken bindlanır. metod başka bir classta da var ise dynamic binding gerçekleşir. dinamik bağlamada jvm'nin görevi nedir? jvm dinamik bağlamada metodun hangi classtan çağırılacağını runtime'da belirler. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? metodlardan önce final veya static yazmamızın bir anlamı kalmazdı, bütün yük runtime'a yüklenirdi. java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? . java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. private bir metod override edilemez. protected metodların içine subclasslar da dahil olduğu için override edilebilir. alt classların üst classlara ait metodları inherit etmesi polimorfizmin özelliğidir. class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? bark meov dinamik class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? p.special() çalışmaz' çünkü parent classında special metodu yoktur. silmeliyiz. output: ""child display"" dynamic binding gözlemlenir java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract classtan veya interfaceden obje üretilemeyeceği için constructor bulunmaz. abstract classlarda metodlar, metodu başka bir classta implement edilmek üzere yazılır. concrete classtan farkı metodların implement edilmemesi ve obje üretilememesidir abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? abstract metodların implement edilmesi concrete classlarda gerçekleşir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. 1) abstract classtan obje üretilmez 2) abstract metodlar genel bir metodun yazılması ve farklı classlarda farklı şekilde implement edilmesine yarar. 3) abstract metod bulunan bir class otomatik olarak abstracttır. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interface reference data type olarak kullanılabilir, abstract class objesi yazılamaz. abstract class ile interface arasında implementation farkları bulunur. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface bir interface taslağıdır, functional interface'in kullanılabilir metodları bulunur. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? bir class birden çok interface'i implement edebilir ve bir interface başka bir interface'i implement edebilir. abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? a.printname() çalışmaz, animal dog = new animal(""buddy"") yazarsak çalışır. output: buddy woof interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? super.move() compile edilemez, çünkü iki interfacede de bulunduğu için hangisiyle bindlanacağına karar verilemez. instanceof ile ayrı ayrı neyi implement ettiğine bakılarak flying swimming benzeri bir output alınabilir. java'da inner class nedir, avantajları nelerdir? başka bir classın içinde declare edilen classlara inner class denir. kodun daha düzenli olmasını ve birbiriyle bağlantılı classların grup halinde yazılmasını sağlar statik ve statik olmayan (member) inner class arasındaki temel fark nedir? member inner classların kullanılması için outer class objesine ihtiyaç vardır, statik inner classlarda ihtiyaç yoktur. anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? anonymous classlar tek seferlik oluşturulan classlardır. objesinde referans bulunumaz. new yazıldıktan sonra kodun alt satırlarında metodlar ve değişkenleri tanımlanır. inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? ulaşabilir ve değiştirebilir. bu, iki classın yakın ilişkide olmasını sağlar statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? hayır, çünkü statik olmayan inner classların yaşaması için outer class objesine ihtiyaç vardır. statik keywordu ise obje olmadan kullanılacak variable/method tanımlar anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? olamaz, çünkü başka bir yerde objesi oluşturulamaz. inner classlardan obje oluşturulabileceği için constructor bulunabilir. hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? public, static class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? private olduğu için dışarıdan ulaşılamaz, getvalue() yazmalıyız veya private'ı silmeliyiz. output: value: 10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? showcount metodunu variable adıyla değil class adıyla çağırmalıyız. compile edilmez. private variable'ı public veya getcount ile almalıyız. output: count: 5 yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. 3 çeşit hata vardır, error(), exception(null pointer exception), exception handlingin amacı nedir? kod hata verdiğinde debuglamanın kolay olması ve şık bir şekilde kullanıcıya anlatılmasıdır. exception handlingde finally bloğunun amacı nedir? exception verse de vermese de en son runlanan kod, finally bloğunun içindeki koddur. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? checked exceptionların throwlanacağı biliniyorsa try-catch bloğu veya throws keywordu ile handlelanmalıdır. unchecked exceptionlar handlelanmasa bile kod çalışır. java'da kendi exceptionunuzu nasıl tanımlarsınız? class olarak tanımlanır ve extends exception keywordleri yazılır. java'da error ve exception arasındaki fark nedir, açıklayınız . java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? bir exception varsa ve bu exception varken belli kod bloklarının çalışması istenmiyorsa try-catchten sonra tekrar catch görene kadar kodun çalışmaması için tekrar fırlatılabilir. 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? . static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? kodda yazılan ikinci catch bloğuna kod hiçbir zaman girmez, çünkü throwlanabilecek her exception üstteki blokta yakalanır. output: exception caught static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally -1 oops 41 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.arraylist; public class quiz1q2 { public static void main(string[] args) { penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); habitat habitat = new habitat(""antarctica "", -15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); } } class penguin { private string name; private string species; private int age; private double weight; public penguin(string name, string species, int age, double weight) { this.name = name; this.species = species; this.age = age; this.weight = weight; } public penguin() { this.name = ""willy""; this.species = ""emperor""; this.age = 1; this.weight = 5.0; } public string getname(penguin p) { return p.name; } public string getspecies(penguin p) { return p.species; } public int getage(penguin p) { return p.age; } public double getweight(penguin p) { return p.weight; } public void setname(penguin p, string s) { p.name = s; } public void setspecies(penguin p, string s) { p.species = s; } public void setage(penguin p, int a) { p.age = a; } public void setweight(penguin p, double w) { p.weight = w; } public void hunt() { this.weight += 1; } public void printpenguin() { system.out.println(""penguin name : "" + this.name); system.out.println(""penguin species : "" + this.species); system.out.println(""penguin age : "" + this.age + "" year(s)""); system.out.println(""penguin weight : "" + this.weight + "" kg""); } } class habitat { private string location; private double temperature; private arraylist<penguin> penguins = new arraylist<penguin>(); private int length = 0; public habitat(string location, double temperature) { this.location = location; this.temperature = temperature; } public string getlocation(habitat h) { return h.location; } public double gettemperature(habitat h) { return h.temperature; } public arraylist<penguin> getpenguins(habitat h) { return h.penguins; } public void setlocation(habitat h, string l) { h.location = l; } public void settemperature(habitat h, double t) { h.temperature = t; } public void setpenguins(habitat h, arraylist<penguin> p) { h.penguins = p; } public void addpenguin(penguin penguin) { (this.penguins).add(penguin); length++; } public void printhabitat() { system.out.println(""habitat location: "" + this.location); system.out.println(""average temperature: "" + this.temperature); system.out.println(""penguins living here: ""); system.out.println(); for (int i = 0; i < length; i++) { (this.penguins.get(i)).printpenguin(); system.out.println(); } } } import java.util.scanner; public class quiz1q1 { public static void main(string[] args) { scanner scan = new scanner(system.in); system.out.println(""enter n:""); int n = scan.nextint(); parantezbas(n); } public static void parantezbas(int n) { } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 import java.util.arraylist; public class quiz2 { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(""\n""); system.out.println(coffeemachine.totalcoffees()); } } abstract class basecoffee { protected arraylist<coffeeaddon> addons = new arraylist<coffeeaddon>(); public void addaddon(coffeeaddon addon) { this.addons.add(addon); } public abstract double calculateprice(); } class espresso extends basecoffee { private boolean isheated = false; double price = 0; public double calculateprice() { for (int i = 0; i < this.addons.size(); i++) { this.price += (this.addons.get(i)).getcost(); } this.price += 40; return this.price; } public void heatcup() { this.isheated = true; } public boolean getheatedvalue() { return isheated; } } class latte extends basecoffee { double price = 0; public double calculateprice() { for (int i = 0; i < this.addons.size(); i++) { this.price += (this.addons.get(i)).getcost(); } this.price += 50; return this.price; } } class americano extends basecoffee { double price = 0; public double calculateprice() { for (int i = 0; i < this.addons.size(); i++) { this.price += (this.addons.get(i)).getcost(); } this.price += 45; return this.price; } } class coffeemachine { static int counter = 0; public void addaddontocoffee(basecoffee coffee, coffeeaddon addon) { if (coffee instanceof espresso) { if (addon instanceof milk) { system.out.println(""[uyari] espresso tipi kahveye milk eklenemez""); } if (addon instanceof vanillasyrup) { system.out.println(""[uyari] espresso tipi kahveye vanilla syrup eklenemez""); } else { coffee.addaddon(addon); } } if (coffee instanceof latte) { if (addon instanceof doubleshot) { system.out.println(""[uyari] latte tipi kahveye double shot eklenemez""); } else { coffee.addaddon(addon); } } if (coffee instanceof americano) { if (addon instanceof chocolate) { system.out.println(""[uyari] americano tipi kahveye chocolate eklenemez""); } if (addon instanceof doubleshot) { system.out.println(""[uyari] americano tipi kahveye double shot eklenemez""); } else { coffee.addaddon(addon); } } } public void makecoffee(basecoffee coffee) { string theorder = """"; if (coffee instanceof espresso && ((espresso) coffee).getheatedvalue() == true) { theorder += ""sipariş: espresso (sıcak fincan)""; for (int i = 0; i < coffee.addons.size(); i++) { theorder += ""+"" + (coffee.addons.get(i)).getname(); } system.out.println(theorder); system.out.println(""toplam fiyat: "" + coffee.calculateprice() + "" tl""); system.out.println(); counter++; } if (coffee instanceof espresso && ((espresso) coffee).getheatedvalue() == false) { theorder += ""sipariş: espresso ""; for (int i = 0; i < coffee.addons.size(); i++) { theorder += ""+"" + (coffee.addons.get(i)).getname(); } system.out.println(theorder); system.out.println(""toplam fiyat: "" + coffee.calculateprice() + "" tl""); system.out.println(); counter++; } if (coffee instanceof latte) { theorder += ""sipariş: latte ""; for (int i = 0; i < coffee.addons.size(); i++) { theorder += ""+"" + (coffee.addons.get(i)).getname(); } system.out.println(theorder); system.out.println(""toplam fiyat: "" + coffee.calculateprice() + "" tl""); system.out.println(); counter++; } if (coffee instanceof americano) { theorder += ""sipariş: americano ""; for (int i = 0; i < coffee.addons.size(); i++) { theorder += ""+"" + (coffee.addons.get(i)).getname(); } system.out.println(theorder); system.out.println(""toplam fiyat: "" + coffee.calculateprice() + "" tl""); system.out.println(); counter++; } } public void heatespressocup(basecoffee coffee) { if (coffee instanceof espresso) { ((espresso) coffee).heatcup(); system.out.println(""espresso kahve fincanı ısıtıldı""); } else { system.out.println(""[uyari] yalnızca espresso kahve fincanları ısıtılabilir""); } } public static string totalcoffees() { return ""tüm kahve makinelerinden toplam "" + counter + "" kahve üretildi""; } } interface coffeeaddon { double getcost(); string getname(); } class milk implements coffeeaddon { public double getcost() { return 5; } public string getname() { return "" milk ""; } } class chocolate implements coffeeaddon { public double getcost() { return 7; } public string getname() { return "" chocolate ""; } } class vanillasyrup implements coffeeaddon { public double getcost() { return 6; } public string getname() { return "" vanilla syrup ""; } } class doubleshot implements coffeeaddon { public double getcost() { return 10; } public string getname() { return "" double shot ""; } } 0",40458,5389,754,239,69,18
6202193,0,"6202193 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q3 { public static void main(string[] args){ sayac s1 = new sayac(""“10001110011”""); system.out.println(s1.say()); } public static void cocktailsort(int[] arr){ } } class sayac { string string; sayac(string metin){ this.string=metin; } public int say(){ int count = 0; for(int i = 0;i<string.length();i++) { if(string.charat(i)=='1')count+=1; } return count; } } public class lab1q2 { public static void main(string[] args){ int[] arr = {5,15,4,1,2,6,11,35,1}; cocktailsort(arr); } public static void cocktailsort(int[] arr){ boolean flag = true; int temp= 1; for(int i = 1;i<arr.length;i++) { if(arr[i]<arr[i-1]) { temp=arr[i]; arr[i]=arr[i-1]; arr[i-1]=temp; flag = false; } } if(flag){ for(int i=0;i<arr.length;i++) { system.out.print(arr[i]); } } else cocktailsort(arr); } } import java.util.scanner; public class vize2soru2 { public static void main(string[] args){ system.out.println(collatz(3516)); } public static int collatz(int i){ if(i==1) { return i; } if(i%2==0){ return collatz(i/2); } else return collatz((i*3)+1); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arrays; import java.util.list; public class lab2q1 { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { // bu kismi cikti ornegini saglayacak sekilde doldurun if(sarki instanceof metalsarki){ metalsarki temp = (metalsarki)sarki; temp.gostermetalozellikleri(); } } } } abstract class sarki{ string isim; string sanatci; abstract void oynat(); } class metalsarki extends sarki{ public string metalozellik; metalsarki(string isim, string sanatci, string metalozellik){ this.isim=isim; this.sanatci=sanatci; this.metalozellik=metalozellik; } public void gostermetalozellikleri(){ system.out.println(sanatci+"" - ""+isim+""""); } public void oynat(){ system.out.println(""[metal] ""+sanatci+"" - ""+isim+"" (""+metalozellik+"")""); } } class rocksarki extends sarki{ rocksarki(string isim, string sanatci){ this.isim=isim; this.sanatci=sanatci; } void oynat(){ system.out.println(""[rock] ""+sanatci+"" - ""+isim+"" (huzurlu ve nostaljik)""); } } class klasiksarki extends sarki{ klasiksarki(string isim, string sanatci){ this.isim=isim; this.sanatci=sanatci; } public void oynat(){ system.out.println(""[klasi̇k] ""+sanatci+"" - ""+isim+"" (hafif ve sakin)""); } } interface calmastratejisi{ void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi){ for(int i =0;i<sarkilistesi.size();i++){ sarkilistesi.get(i).oynat(); } } } class karisikcalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi){ int[] a = new int[sarkilistesi.size()]; int count = 0; while(count<sarkilistesi.size()){ int b = 1+(int)(math.random()*sarkilistesi.size()); boolean flag = true; for(int i = 0;i<a.length;i++){ if(a[i]==b)flag=false; } if(flag){ a[count]=b; count++; } } for(int i =0;i<sarkilistesi.size();i++){ sarkilistesi.get(a[i]-1).oynat(); } } } class rockcuozelcalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi){ boolean flag = false; boolean temp = false; for(int i =0;i<sarkilistesi.size();i++){ if(sarkilistesi.get(i).getclass()==new rocksarki(null, null).getclass()&&flag==false){ system.out.println(""[bilgi] ses duzeyi: yuksek""); flag=true; sarkilistesi.get(i).oynat(); } else if(sarkilistesi.get(i).getclass()!=new rocksarki(null, null).getclass()&&flag==true){ system.out.println(""[bilgi] ses duzeyi: normal""); sarkilistesi.get(i).oynat(); flag=false; } else sarkilistesi.get(i).oynat();; } } } class muzikcalar{ calmastratejisi strateji; void setstrateji(calmastratejisi s){ this.strateji=s; } void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. recursion, metodun kendisini kendi içinde çağırmasıdır. recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. base case, base condition barındırır. her recursion gerçekleştiğinde bu belirli base conditiona yaklaşır ve en sonunda zinciri tamamlar bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? baştaki ve sondaki harfleri birbiriylr değiştirip bu işlemi kaç defa yaptığımı sonraki recursiona elde ettiğim stringle gönderirdim. i̇şlem sayısı string uzunluğunun yarısından büyük olması base condition olurdu. recursive bir metotta base case olmazsa ne olur? stack overflow recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. mevcut stackin üstüne yeni bir katman oluşturulur. sonraki çağırmalar da böyle sürer. fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. her bir sayı için yeni bir stack oluşturulur ve en sonunda bütün stackler silinip başa dönüldüğünde sonuç rlde edilir. tail recurdion kullanılsa bile java bunun için optimize edilmemiştir. for döngüsü gibi ilkel çözümler daha pratik olabilir. tail recursion nedir, kısaca açıklayınız. tail recursion, base condition'un yerine getirilfiği anda hedeflenen işlemin zaten hazır ve elde olmasıdır. abstraction kavramını açıklayınız. soyutlama. nesneleri ortak özelliklerine göre ilişkilendirme ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? is a , bir classın başka bir klasın alt klası veya kendisi olması durumudur. java da inheritance of ile kontrol edilir. o classın subclasslarından biri veya kendisi olması is a ilişkisi için yeterlidir bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? default ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? c class java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? çünkü parent classların hepsi initialize edilmeden kendisi hakkında bir şey uapamayız java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? değil metot overriding ve overloading kavramlarını açıklayınız. overload, aynı isim ve farklı paramtereye sahip metod, override, oarent classtan aldığımız methodla aynı signatureda başka bir metod yazmak class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dogbark! class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? circle 8.0 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? dynamic ve static olarak ikiye ayrılır. çağırılacak bir metodun hangi classtan nasıl çağırılacağının belirlenmesi ve bağlantı kurmasıdır. hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? eğer bir metoda override yapılamazsa static binding yapılır. static, private ve final dinamik bağlamada jvm'nin görevi nedir? dinamik bağlamada kodun mevcut durumuna göre merodun çalışması runtimeda belirlenir. static bağlamada compiler işi en başta halleder. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? dinamik olsaydı değiştirilmesini istemediğimiz metodlara override yapılabilirdi java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? yeni bir obje oluşturup downcast etmek gerekir çünkü subclassta olan metod ve instance variable lar parent classta olmayabilir. bu yüzden implicit yapılsaydı sorunlar çıkardı. java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. hayır. erişilmesini istemediğimiz metodlar bu sefer oluşturulan parent classlardan erişilebilir olur class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? bark meow dinamik class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? yanlışlık yok, child display child special, dinamic binding java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract classlarda implement edilmemiş metodlar bulunabilir ve obje çağırılamaz. abstract classların constructorları olmalıdır fakat interfacelerde olmaz abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? edilebilir, eğer abstract classta hala implement edilmemiş başka metodlar bulunuyorsa ve class o interfaceden extend ediliyorsa olur abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. i̇mplement edilmemişlerdir obje çağırılamaz sonradan implement edilirler yapılacağı kesin olan ama nasıl yapılacağı henüz belirli olmayan metod ve classlar için esnek bir yöntemdir. soyutlanada çok işe yarar abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract classlarda implement edilmiş metod bulunabilir fakat interfacelerde bulunamaz. a. classların constructorları vardır ama interfacelerin yoktur. myabstractclassobj eğer metodlwrı sonradan inplement edilmişse çağırılabilir ama interfacelerde bu mümkün değildir marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interfacelerin metodu yoktur, functionalların tek bir metodu vardır. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? bir class bir den çok edebilir. i̇nterface de edebilir abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? animal objesi çağırılamaz. bunun yerine new dog(""buddy"") kullanılmalıydı. output: animal : buddy woof interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? eğer move metodu interfacelerde tanımlanmasaydı hata oluşmazdı ama default ile tanımlanmış durumda. öyle olunca duck içindeki super.move çağırılınca compiler hangi ata interface e gideceğini bilemez ve hata verir. bunun yerine ya move metodu interfacelerde abstract bırakılıp duckta tanımlanmalıydı ya da iki interfaceden yalnızca biri ata interface olmalıydı. metod signaturelarını interfacelerde farklı yapmak da olur. output tercih edilen ata interface e göre swimming veya flying şeklinde olurdu. java'da inner class nedir, avantajları nelerdir? classların içine gömülü başka classlardır. outer classa ait private ögelere erişimi vardır. inner classlar static ve private da olabilir. statik ve statik olmayan (member) inner class arasındaki temel fark nedir? statik inner classın constructoru direkt çağırılabilirken member inner classın constructoru outer class objesi aracılığıyla çağırılır. static inner class outer classın sadece static metot ve variable larına erişim sağlayabilir. anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? anonim class, anlık ihtiyaçlardan ötürü bir obje çağırılırken ona özgü behaviourlar atanmasıdır. kendi classı yoktur. yanına süslü parantez açılıp istenen metot ve değişkenler tanımlanır. çağırılan objelerden anonim sınıf yapılabilir. inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? evet erişebilir. evet değiştirebilir. class içi düzenin sağlanması için kullanılır. statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? evet tanımlanabilir. i̇nner classa ait başka bir statix inner class oluşturulduğu durumda bu static metot veya variable a erişim sağlanabilir. anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? hayır olamaz. inner classlardan farkı anonymous classların hangi class olduğu bilinmez. hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? static class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? inner class static olmasığı için constructor çağırılma şekli yanlıştır. outer objesindrn çağırılmalıdır. output value: 10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? yanlışlık: static inner objenin çağırılna şekli yanlıştır. direkt inner class constructoru çağırılmalıdır. output count: 5 yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. compile error, int a = 1.0 type mismatch, runtime, int[] a = new int[3]; a[4] arrayindexoutofbounds, exception, 1/0, arithmetic exception error, null pointer exception handlingin amacı nedir? bir kodda oluşan hatanın sonraki kodları da engellemesinin önüne geçmek exception handlingde finally bloğunun amacı nedir? exception atılsa da atılmasa da run edilir. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? birinin handle edilmesi zorunluyken diğeri değildir java'da kendi exceptionunuzu nasıl tanımlarsınız? throwable classtan extend ederek kendi exception classımızı tanımlar ve örneğin throw new myexception() deriz java'da error ve exception arasındaki fark nedir, açıklayınız errorlar daha çok compiler ve bilgisayara özgü hatalar iken exceptionlar daha çok alınan imputların beklenenden farklı olmasıyla ilişkilidir java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? exception ile olan işimiz daha bitmemiş olabilir, exception durumunda birden çok alanda düzeltmeler yapılması gerekebilir 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? throwable class veya alt classları throw edilebilir static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? hayır. birden fazla catch vardır. i̇ki catchtan biri silindiğinde kalan catch run edilir çünkü kodda oluşan hata hem arrayindexoutofbounds heö de ecceptiondır. silinen metoda göre exception caught veya array exception caught static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught fi̇nally oops done 41 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg public class quiz1q2 { public static void main(string[] args){ penguin a = new penguin(""enes"",""enes"",10,5.0); a.printpenguin(); habitat b = new habitat(""ankara"", -10); b.addpenguin(a); } } class penguin{ private string name; private string species; private int age; private double weight; public penguin(){ name=""willy""; species=""emperor""; age =10; weight= 10.0; } public penguin(string name,string species,int age,double weight){ this.name = name; this. age = age; this. weight=weight; this.species=species; } public void hunt(){ weight+=1; } public int getage(){ return age; } public string getname(){ return name; } public string getspecies(){ return species; } public double getweight(){ return weight; } public void printpenguin(){ system.out.println(""penguin name :""+name+"" species: ""+species+"" age: ""+age+"" years weight:""+weight+"" kg""); } } class habitat{ private string location; private double temperature; private arraylist<penguin> penguins; private int penguincount =0; public habitat(string location, double temperature){ this.temperature=temperature; this.location=location; } public string getlocation(){ return location; } public double gettemperature(){ return temperature; } public arraylist<> getlist(){ return penguins; } public void addpenguin(penguin penguin){ penguins.addpenguin(penguin); penguincount+=1; } public void printhabitat(){ system.out.println(""penguins living here:""); /* arraylist nasıl çalışır bilmiyorum :( muhtemelen for(int i =0;i<penguincount;i++){ system.out.println(); penguins[i].parantezbas(); } tarzı bir şey olacak. array listi import etmem de gerekilir bilmiyorum dediğim gibi. kolay gelsin. */ } } import java.lang.reflect.array; public class quiz1q1 { public static void main(string[] args){ parantezbas(1); } public static void parantezbas(int n){ a(n, 0, 0, """"); } public static void a(int n,int sag,int sol,string output){ if(sag==sol&&sol==n)system.out.print(output+"", ""); else if(sag==0)a(n, sag+1, sol, output+""(""); else if(sag==n)a(n, sag, sol+1, output+"")""); else{ a(n, sag+1, sol, output+""(""); if(sag>sol)a(n, sag, sol+1, output+"")""); } } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 import java.util.arraylist; public class main { public static void main(string[] args) throws exception { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(""\n""); anothermachine.getallcoffees(); } } class milk implements coffeeaddon{ public double getcost(){ return 5; } public string getname(){ return ""milk""; } } class chocolate implements coffeeaddon{ public double getcost(){ return 7; } public string getname(){ return ""chocolate""; } } class vanillasyrup implements coffeeaddon{ public double getcost(){ return 6; } public string getname(){ return ""vanilla syrup""; } } class doubleshot implements coffeeaddon{ public double getcost(){ return 10; } public string getname(){ return ""double shot""; } } class espresso extends basecoffee{ private boolean isheated=false; public void heatcup(){ isheated=true; system.out.println(""espresso kahve fincanı ısıtıldı.""); } @override public double calculateprice() { if(isheated)system.out.print(""(sıcak fincan) + ""); int total = 0; total+=40; for(int i =0;i<addonlist.size();i++){ total+=addonlist.get(i).getcost(); } return total; } } class americano extends basecoffee{ @override public double calculateprice() { int total = 0; total+=45; for(int i =0;i<addonlist.size();i++){ total+=addonlist.get(i).getcost(); } return total; } } class latte extends basecoffee{ @override public double calculateprice() { int total = 0; total+=50; for(int i =0;i<addonlist.size();i++){ total+=addonlist.get(i).getcost(); } return total; } } class coffeemachine{ static int coffeesmade=0; public void addaddontocoffee(basecoffee coffee, coffeeaddon addon){ if(coffee instanceof espresso){ if(addon instanceof doubleshot||addon instanceof chocolate){ coffee.addaddon(addon); } else system.out.println(""[uyari] espresso tipi kahveye ""+addon.getname()+"" eklenemez""); } else if(coffee instanceof latte){ if(addon instanceof doubleshot){ system.out.println(""[uyari] latte tipi kahveye double shot eklenemez""); } else coffee.addaddon(addon); } else if(coffee instanceof americano){ if(addon instanceof milk||addon instanceof vanillasyrup){ coffee.addaddon(addon); } else system.out.println(""[uyari] americano tipi kahveye ""+addon.getname()+"" eklenemez""); } } public void makecoffee(basecoffee coffee){ if(coffee instanceof espresso){ system.out.print(""sipraiş: espresso ""); double temp = coffee.calculateprice(); for(int i =0;i<coffee.addonlist.size();i++){ system.out.print(coffee.addonlist.get(i).getname()); if(i!=coffee.addonlist.size()-1)system.out.print( "" + ""); } system.out.println(); system.out.println(""toplam fiyat: ""+(int)temp+""tl""); coffeesmade+=1; } if(coffee instanceof latte){ system.out.println(); system.out.print(""sipraiş: latte ""); for(int i =0;i<coffee.addonlist.size();i++){ system.out.print(coffee.addonlist.get(i).getname()); if(i!=coffee.addonlist.size()-1)system.out.print( "" + ""); } system.out.println(); double temp = coffee.calculateprice(); system.out.println(""toplam fiyat: ""+(int)temp+""tl""); coffeesmade+=1; } if(coffee instanceof americano){ system.out.println(""sipraiş: americano ""); for(int i =0;i<coffee.addonlist.size();i++){ system.out.print(coffee.addonlist.get(i).getname()); if(i!=coffee.addonlist.size()-1)system.out.print( "" + ""); } system.out.println(""toplam fiyat: "" +(int)coffee.calculateprice()+""tl""); coffeesmade+=1; } } public void heatespressocup(basecoffee coffee){ if(coffee instanceof espresso){ ((espresso)coffee).heatcup(); } else { system.out.println(); system.out.println(""[uyari] yalnızca espresso kahve fincanları ısıtılabilir""); } } public void getallcoffees(){ system.out.println(""tum kahve makineleri tarafindan toplam ""+coffeesmade+"" kahve uretildi""); } } public interface coffeeaddon { double getcost(); string getname(); } import java.util.arraylist; public abstract class basecoffee{ protected arraylist<coffeeaddon> addonlist= new arraylist<>(); public void addaddon(coffeeaddon addon){ if(addonlist.equals(null)){ addonlist= new arraylist<>(); } addonlist.add(addon); } public abstract double calculateprice(); } 0",39276,4854,696,231,70,26
7817361,1,"7817361 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q3 { public lab1q3(string str){ say(); } public int say(){ return 0; } public int helper(){ return 0; } } class ana{ public static void main(string[] args){ lab1q3 s1 = new lab1q3(""10001""); lab1q3 s2 = new lab1q3(""1111""); } } public class lab1q2 { public static void main(string[] args){ int[] arr = {5,4,1,2}; for (int i = 0; i+1< arr.length; i++){ if (arr[i]< arr[i+1]){ int temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; } } cocktailsort(arr); for(int j = 0; j<arr.length; j++){ system.out.println(arr[j]); } } public static void cocktailsort(int[] arr){ int s = arr.length-1; if(arr[s-2]>arr[s-1]){ int temp = arr[s-1]; arr[s-1] = arr[s-2]; arr[s-2] = temp; straightsort(arr); s--; } } public static void straightsort(int[] arr){ int s = 0; if (arr[s]> arr[s+1]){ int temp = arr[s+1]; arr [s+1] = arr[s]; arr[s] = temp; cocktailsort(arr); s++; } } } import java.util.scanner; public class lab1q1 { public static void main(string[] args){ scanner scan = new scanner(system.in); int i = scan.nextint(); int result = collatz(i); system.out.println(result); } public static int collatz (int i){ int count = 0; if(i== 1){ return count; } else if(i%2 == 0){ collatz(i/2); count++; } else if (i%2 != 0){ collatz(i*3 + 1); count++; } return count; } public static int sayac(int s){ s++; return s; } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 package lab3; public class muzikcalar { } package lab3; public class main { } package lab3; public class klasiksarki { } package lab3; public class metalsarki { } package lab3; public class rocksarki { } package lab3; public class karisikcalma { } package lab3; public class siralicalma { } package lab3; public class sarki { } package lab3; public class rockcuozelcalma { } package lab3; public class calmastratejisi { } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. recursion bir metodun kendini çağırarak farklı katmanlar oluşturması ve bu katmanlar arasında tek tek bir diğerine geçerek işlevini gerçekleştirmesidir. recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. base case metodun sonunda istenen sonuca ulaşılmasında ger katmanda tekrar eden durumdur. bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? return içerisinde metodu çağırdıktan sonra harfi print ederek yazardım. charat(n) recursive bir metotta base case olmazsa ne olur? stack overload recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. yeni bir katman açar sonuna ulaştıgında tek tek bu katmanları terk eder. fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. optimize çalışmaz.fazla kaynak harcar. tail recursion nedir, kısaca açıklayınız. return'ün içinde sonraki katmana geçişte gereken değişkenin değişimini sağlar. abstraction kavramını açıklayınız. black box. kullanıcının kodun istediğimiz kısımlarını göstermemizi anlatan kavram. ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? extends syntax'ı ile kontrol edilir. bir class'ın diğer class'ı içermesini ifade eder. bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? protected ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? a veya b. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? class ilişkileri icinde karışmayı önlemek icin. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? hayır. metot overriding ve overloading kavramlarını açıklayınız. override, bir class'ın miras aldığı başka bir class içindeki aynı isimdeki metodu kullanmak yerine kendi içindeki metodun kullanılmasını ifade eder. overload isimleri aynı ancak parametreleri farklı iki metodu ifade eder. class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dog bark class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? circle 8.0 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? method bağlama anlamına gelir. abstraction hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? a dinamik bağlamada jvm'nin görevi nedir? a java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? bilgiler korunamazdı java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? a java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. örnek olarak public bir method private olarak override edilebilir ancak tersi yapılamaz. class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? bark meov class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? child display child special dinamik java'da inner class nedir, avantajları nelerdir? class içinde class. kodun düzenlenmesinde avantaj sağlar. statik ve statik olmayan (member) inner class arasındaki temel fark nedir? static olmayanlara diğer class'lardan da ulaşılabilirken statiklere ulaşılabilir. anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? anonymous class ismi belli olmayan, yaptıracağımız işi class'ı kurduğumuz an yaptıgımız class'lardır. new a{...}.uyguladığımız kod inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? evet, değiştiremez. verilerin belli düzeyde kullanılabilmesini sağlar. statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? hayır. class static olmadığı için içindekilere erişilebilmewi herekir. anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? olabilir. inner class'ların içindekilerin adı bellidir, sonradan kullanılabilir. hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? public class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? gözlemleyemiyorum. value: 10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? compile edilemez. static class'a ait obje üretilemez. count: 5 yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. 2. exception ve error. run time error out od bound exception exception handlingin amacı nedir? exception'ları giderip kodları çalıstırmak. exception handlingde finally bloğunun amacı nedir? her türlü çalışmasını istediğimiz kodları girdigimiz bölüm. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? a java'da kendi exceptionunuzu nasıl tanımlarsınız? exception e = new ioexception gibi java'da error ve exception arasındaki fark nedir, açıklayınız a java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? belli şartlar altında çalışmasını istediğimiz kodları çalıştırabilmek icin. 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? a static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenir. exception caught. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught, -1, finally, oops, done bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.scanner; public class lab2q1 { public static void main(string[] args){ scanner scan = new scanner (system.in); int n = scan.nextint(); parantezbas(n); } public static void parantezbas(int n){ parantezbas(n,n,n,n); } public static void parantezbas(int i, int j, int l,int m){ if(l!=0){ if(i>0){ system.out.print(""(""); parantezbas(--i,j,l,m); } if(j>=0){ system.out.print("")""); parantezbas(i,--j,l,m); } if (i == 0 && j == 0){ i = --l; j = m-i; parantezbas(i,j,l,m); } } } } import java.util.arraylist; public class lab2q2 { public static void main(string[] args){ penguin p1 = new penguin(""pingu"",""emperor"",5,12.5); penguin p2 = new penguin(""skipper"",""adelie"",3,9.8); penguin p3 = new penguin(); habitat habitat = new habitat(""antartica"", -15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); } } class penguin{ private string name; private string species; private int age; private double weight; public penguin(){ name = ""willy""; species= ""emperor""; age = 1; weight = 5.0; } public penguin(string name, string species, int age, double weight){ this.name = name; this.species=species; this.age=age; this.weight = weight; } public string getname(){ return name; } public string getspecies(){ return species; } public int getage(){ return age; } public double getweight(){ return weight; } public void setname(string newname){ name = newname; } public void setspecies(string newspecies){ species = newspecies; } public void setage(int newage){ age = newage; } public void setname(double newweight){ weight = newweight; } public void printpenguin(){ system.out.println(""penguin name: "" + name +"" species: ""+ species +"" age: ""+ age + "" weight: ""+ weight); } public void hunt(){ weight++; } } class habitat{ private string location; private double temperature; private arraylist<penguin> penguins; public habitat(string location, double temperature){ this.location = location; this.temperature=temperature; } public string getlocation(){ return location; } public double temperature(){ return temperature; } public void setlocation(string newlocation){ location= newlocation; } public void settemperature(double newtemperature){ temperature = newtemperature; } public void addpenguin(penguin penguin){ penguins.add(penguin); } public void printhabitat(){ system.out.println(""habitat location: ""+ location +""\naverage temperature: ""+ temperature+ ""°c""); for(int i= 0; i< penguins.size(); i++){ penguins.get(i).printpenguin(); } } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 package quiz2; public class latte extends basecoffee { public double calculateprice(){ return 50.0; } public string getcoffeename(){ return ""latte""; } } package quiz2; public class main { public static void main(string[] args){ coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(""tüm kahve makineleri tarafından toplam ""+ machine.say() + "" kere üretildi""); // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } package quiz2; public class espresso extends basecoffee{ private boolean isheated = false; public double calculateprice(){ return 40.0; } public void heatcup(){ isheated = true; } public string getcoffeename(){ return ""espresso""; } } package quiz2; public class vanillasyrup implements coffeeaddon { public double getcost(){ return 6.0; } public string getname(){ return ""vanilla syrup""; } } package quiz2; interface coffeeaddon{ double getcost(); string getname(); } package quiz2; import java.util.arraylist; public abstract class basecoffee { protected arraylist<coffeeaddon> addons = new arraylist<>(); public void addaddon(coffeeaddon addon){ addons.add(addon); } public abstract double calculateprice(); public abstract string getcoffeename(); } package quiz2; public class americano extends basecoffee { public double calculateprice(){ return 45.0; } public string getcoffeename(){ return ""americano""; } } package quiz2; import java.util.arraylist; public class coffeemachine { public boolean isheated = false; public double toplamtutar = 0.0; int count = 0; int m; public void addaddontocoffee(basecoffee coffee, coffeeaddon addon){ isheated = false; if ((addon.getname().equals(""milk"") || addon.getname().equals( ""vanilla syrup""))&& coffee.getcoffeename().equals(""espresso"")){ system.out.println(""[uyari] espresso tipi kahveye "" + addon.getname() + "" eklenemez.""); } if ((addon.getname().equals(""double shot"") || addon.getname().equals( ""chocolate""))&& coffee.getcoffeename().equals(""americano"")){ system.out.println(""[uyari] americano tipi kahveye "" + addon.getname() + "" eklenemez.""); } if (addon.getname().equals(""double shot"") && coffee.getcoffeename().equals(""latte"")){ system.out.println(""[uyari] latte tipi kahveye "" + addon.getname() + "" eklenemez.""); } coffee.addons.add(addon); } public void makecoffee(basecoffee coffee){ system.out.print(""sipariş: "" + coffee.getcoffeename()); if(isheated == true){ system.out.println("" (sıcak fincan) ""); } for(int i = 0; i < coffee.addons.size() ; i++){ system.out.print("" + "" + coffee.addons.get(i).getname()); toplamtutar = toplamtutar + coffee.addons.get(i).getcost(); } system.out.println(""\ntoplam fiyat: "" + (toplamtutar + coffee.calculateprice())); say(); } public void heatespressocup(basecoffee coffee){ isheated = false; if(coffee.getcoffeename().equals(""espresso"")){ system.out.println(""espresso kahve fincanı ısıtıldı""); espresso espresso = (espresso)coffee; espresso.heatcup(); isheated = true; } else{ system.out.println(""[uyari] yalnızca espresso tipi kahve fincanları ısıtılabilir.""); } } public int say(){ count++; return count; } } package quiz2; public class milk implements coffeeaddon{ public double getcost(){ return 5.0; } public string getname(){ return ""milk""; } } package quiz2; public class doubleshot implements coffeeaddon{ public double getcost(){ return 10.0; } public string getname(){ return ""double shot""; } } package quiz2; public class chocolate implements coffeeaddon{ public double getcost(){ return 7.0; } public string getname(){ return ""chocolate""; } } 1",30958,4020,575,205,65,18
6897869,0,"6897869 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. package hafta1; public class lab1q3 { public static void main(string[] args) { string str = ""10001""; string str2 = ""1111""; a a1 = new a(str); a a2 = new a(str2); system.out.println(a1.say()); system.out.println(a2.say()); } } class a { string str; int count; a() { system.out.println(""err""); } a(string str) { this.str = str; count = 0; } public int say() { return fun(0); } private int fun(int index) { if (index >= str.length()) { return 0; } if (str.charat(index) == '1') { return 1 + fun(index + 1); } else { return fun(index + 1); } } } package hafta1; public class lab1q2 { public static void main(string[] args) { int[] arr = { 5, 4, 2, 1 }; cocktailsort(arr); // *************** string str = ""[""; for (int i = 0; i < arr.length - 1; i++) { str += arr[i] + "",""; } if (arr.length != 0) { str += arr[arr.length - 1]; } str += ""]""; system.out.println(str); // ************** } public static void cocktailsort(int[] arr) { fun(arr, true); } public static void fun(int[] arr, boolean flag) { if (flag) { for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { arr[i] = arr[i] + arr[i + 1]; arr[i + 1] = arr[i] - arr[i + 1]; arr[i] = arr[i] - arr[i + 1]; } } } else { for (int i = arr.length - 2; i >= 0; i--) { if (arr[i] > arr[i + 1]) { arr[i] = arr[i] + arr[i + 1]; arr[i + 1] = arr[i] - arr[i + 1]; arr[i] = arr[i] - arr[i + 1]; } } } if (!check(arr)) { fun(arr, !flag); } } public static boolean check(int[] arr) { for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { return false; } } return true; } } package hafta1; public class lab1q1 { public static void main(string[] args) { system.out.println(collatz(5)); } public static int collatz(int i) { if (i == 1) { return 0; } else if (i % 2 == 0) { return 1 + collatz(i / 2); } else { return 1 + collatz(3 * i + 1); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { strateji = s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykırı ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumental""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sıralı çalma""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karışık çalma""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu özel çalma""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal özellikleri :""); for (sarki s : sarkilistesi) { if (s instanceof metalsarki) { metalsarki m = (metalsarki) s; system.out.println(m.sanatci + "" "" + m.isim + "" [özellik: "" + m.metalozellik + ""]""); } } } } public class klasiksarki extends sarki { klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } @override void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } public class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } @override void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } } public class rocksarki extends sarki { rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } @override void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } import java.util.arraylist; import java.util.collections; import java.util.list; public class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { arraylist<sarki> newlist = new arraylist<>(); for (sarki s : sarkilistesi) { newlist.add(s); } collections.shuffle(newlist); for (sarki s : newlist) { s.oynat(); } system.out.println(); } } import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki s : sarkilistesi) { s.oynat(); } system.out.println(); } } public abstract class sarki { string isim; string sanatci; void oynat() { system.out.println(""şarkı çalıyor""); } } import java.util.list; public class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { if (sarkilistesi.size() > 0) { if (sarkilistesi.get(0) instanceof rocksarki) { system.out.println(""[bi̇lgi̇] ses düzeyi: yüksek""); sarkilistesi.get(0).oynat(); } else { sarkilistesi.get(0).oynat(); } } for (int i = 1; i < sarkilistesi.size(); i++) { sarki bu = sarkilistesi.get(i); sarki evvelki = sarkilistesi.get(i - 1); if (bu instanceof rocksarki) { if (evvelki instanceof rocksarki) { bu.oynat(); } else { system.out.println(""[bi̇lgi̇] ses düzeyi: yüksek""); bu.oynat(); } } else { if (evvelki instanceof rocksarki) { system.out.println(""[bi̇lgi̇] ses düzeyi: normal""); bu.oynat(); } else { bu.oynat(); } } } system.out.println(); } } import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. kendi kendini çağıran metotlar özyinelemelidir. recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. metodun ne zaman kendini çağırmayı bırakıp bir değer döndüreceğini belirleyen koşul. bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? stringin 1. indexten itibaren sonuna kadar olan kısmı ile kendini tekrar çağıran, çıktıya stringin ilk karakterini ekleyip döndüren bir metot yazarım. temel koşul string uzunluğu 2 den küçük ise stringin kendisini döndürmesi. recursive bir metotta base case olmazsa ne olur? sonsuz döngüye girer. sürekli yeni metot çağırıldığından stack bellekte yer kalmaz. recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. yeni bir yer ayırılıp stack belleğin tepesine yerleştirilir. metot çalışmayı bitirene kadar hafıza serbest bırakılmaz. fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. bellekte çok fazla yer kaplar. yavaş çalışır tail recursion nedir, kısaca açıklayınız. . abstraction kavramını açıklayınız. sınıflandırma. benzer kod parçalarını gruplayıp ortak özelliklerini taşıyan bir üst class oluşturmak. ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? bir alt class aynı zamanda ata class dır. subclass is a baseclass. bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? protected ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? a,b,object java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? alt class olusturken önce üst class constructor ı çalıştırılmak zorunda. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? mümkün değil. metot overriding ve overloading kavramlarını açıklayınız. overriding üst calss ta tanımlanan fonksiyonu alt class ta değiştirmek. overloading metodun parametre tip yada sayılarını değiştirip yeni metod oluşturmak. class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dog bark class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? circle 12.56 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? associating method calls and method implementations. static binding for static and final methods. dynamic binding for others hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? static ve final niteleyicilerle tanımlanan metotlar static binding ile ilişkilendirilir. private da dahil diğer metotlar dynamic binding ile ilişkilendirilir. dinamik bağlamada jvm'nin görevi nedir? program çalışırken çağrılan metodun hangi tanımının kullanılacağına bakmak. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? programlar daha yavaş çalışırdı. nesne değiskenleri üzerinden çağrılan static metotlar farklı davranırdı. java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? down cast uygulanan nesnenin alt classın bir örneği olup olmadığını kontrol etmemiz gerekir. implicit şekilde yanlıs bir dönüşum yapmaya çalışırsak runtime error ile karşılaşılır. java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. alt class da tekrar yazıla metodun acsess modifier ı üst klasta kullanılandan dar olamaz. protected metod overriding ile public tanımlanabilir class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? bark meov. dinamik bağlama class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? parent tipi referanstan child finksiyonuna erişilmez java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? nesnesi üretilemeyean class tır. içinde abstract metotlar bulunabilir. abstract classların constructor ı olabilir. interfacelerin olamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? evet başka bir abstract class ı genişleten başka bir abstract class ata classın metodunun tanımını içerebilir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract classların nesnesi oluşturulamaz. abstract metotların sadece başlıkları olur, alt class ta tanımlanırlar. abstract classın tüm alt classlarının metoda sahip olduğundan emin oluruz ama tanımlana kadar tanımlarını bilmeyiz. programcıya böylece kolaylık sağlar abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interface bir class değildir. bir alt class 2 ata classı genişletemez ama 2 veya fazla interface i gerçekleştirebilir. ikiside tip olarak kullanılabilir. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface metot içermez sadece classın belli bir gruba dahil olduğunu belirtir. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet. interface başka interface yi genisletebilir, extends abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? . interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? . java'da inner class nedir, avantajları nelerdir? başka class içinde tanımlanan classlar statik ve statik olmayan (member) inner class arasındaki temel fark nedir? statik inner class bir outer classa bağlı olmadan oluşturulabilir. non static inner class bir outer classa bağımlı olmalı. anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? objesi oluşturulurken tanımlanan classlardır. genellikle interface lerden ayrıca abstract nonabstract classlardan oluşturulabilirler. inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? evet erişebilir değiştirebilir. staticse erişemez sadece. programın daha düzenli olmasını sağlar. statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? değişken tanımlanabilir. anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? olamaz. anonymus class için class dosyası oluşturulmaz, kendi referans tipi olmaz. hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? public olanlar class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? outer class olusturulmadan inner class oluşturulamaz. hata düzelirse output value :10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? static inner class outer class dan bağımsız olur. düzeltilirse count:5 yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. runtime errors, örnek null pointer exception. compiler errors, index outofbound exception. locigal errors, programcının yaptığı hatalar. exception handlingin amacı nedir? olağanüstü durumlarda programın düzgün çalışmasını sağlamak. dosya bulunamadığında hata verip devam etmesi gibi. exception handlingde finally bloğunun amacı nedir? hatayla karşılasılsa da karşılasılmasa da çalışacak kod parçasını belirtmek için. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? checked, catch bloğu ile yakalanıp düzeltmek için bazı işlemler yapılan exceptionlardır. java'da kendi exceptionunuzu nasıl tanımlarsınız? önceden tanımlı bir exception classı extend ederek. en az iki constructor yazmak ve ata classın constructorunu çağırmak uygun olur. java'da error ve exception arasındaki fark nedir, açıklayınız error jvm in temel işlevlerinde meydana gelen programcının genelde düzeltemeyeceği hatalardır. exception olağanüstü durumlarda oluşan düzeltmesi daha basit hatalardır. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? programın daha üst bloğunda düzeltilmedi gerekiyordur. 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? ata classın fırlatmadığı bir exceptionu subclsss fırlatamaz. static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenir. output exception caught static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.arraylist; public class lab2q1 { public static void main(string[] args) { int n = 4; parantezbas(n); } public static void parantezbas(int n) { arraylist<string> arr = new arraylist<string>(); fun("""", n, arr); system.out.print(""n = "" + n + "" ""); for (int i = 0; i < arr.size() - 1; i++) { system.out.print(arr.get(i) + "",""); } if (arr.size() != 0) { system.out.print(arr.getlast()); } } private static void fun(string str, int n, arraylist<string> arr) { if (str.length() == n * 2) { arr.add(str); } else { int close = 0; int open = n; for (int i = 0; i < str.length(); i++) { if (str.charat(i) == '(') { close++; open--; } else { close--; } } if (open > 0) { fun(str + ""("", n, arr); } if (close > 0) { fun(str + "")"", n, arr); } } } } import java.util.arraylist; class penguin { private string name; private string species; private int age; private double weight; // constructors public penguin() { name = ""willy""; species = ""emperor""; age = 1; weight = 5.0; } public penguin(string name, string species, int age, double weight) { this.name = name; this.species = species; this.age = age; this.weight = weight; } // methods public void hunt() { weight += 1.0; } public void printpenguin() { system.out.print(""penguin name:"" + name); system.out.print("" species:"" + species); system.out.print("" age:"" + age); system.out.print("" weight:"" + weight); } // getters public string getname() { return name; } public string getspecies() { return species; } public int getage() { return age; } public double getweight() { return weight; } // setters public void setname(string name) { if (name.length() < 21) { this.name = name; } } public void setspecies(string species) { if (species.length() < 101) { this.species = species; } } public void setage(int age) { if (age < 100) { this.age = age; } } public void setweight(double weight) { if (weight < 50.0) { this.weight = weight; } } } class habitat { private string location; private double tempreture; private arraylist<penguin> penguins; public habitat(string location, double tempreture) { this.penguins = new arraylist<penguin>(); this.tempreture = tempreture; this.location = location; } public void addpenguin(penguin p) { if (p != null) { penguins.add(p); } } public void printhabitat() { system.out.println(""habitat location: "" + location); system.out.println(""avarage tempreture: "" + tempreture + "" c degrees""); if (penguins.size() > 0) { system.out.println(""penguins living here:""); for (penguin p : penguins) { p.printpenguin(); system.out.println(); } } } public string getlocation() { return location; } public double gettempreture() { return tempreture; } public arraylist<penguin> getpenguins() { arraylist<penguin> out = new arraylist<penguin>(); for (penguin p : penguins) { out.add(p); } return out; } public void settempreture(double tempreture) { if (tempreture >= -273) { this.tempreture = tempreture; } } public void setlocation(string location) { if (location.length() < 101) { this.location = location; } } } public class lab2q2 { public static void main(string[] args) { penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // p2.hunt(); habitat habitat = new habitat(""antarctica"", -15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public class latte extends basecoffee { private double baseprice = 50.0; { type = ""latte""; } @override public double calculateprice() { double price = baseprice; system.out.print(""sipariş: "" + type + "" ""); for (coffeeaddon addon : addons) { price += addon.getcost(); system.out.print(""+ "" + addon.getname() + "" ""); } system.out.println(); coffemachine.allcoffees.add(this); return price; } } public class main { public static void main(string[] args) { coffemachine machine = new coffemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(); coffemachine.displaytotalcoffees(); } } public class espresso extends basecoffee { private boolean isheated = false; private double baseprice = 40.0; { type = ""epresso""; } @override public double calculateprice() { double price = baseprice; system.out.print(""sipariş: espresso ""); if (isheated) { system.out.print(""(sıcak fincan) ""); } for (coffeeaddon addon : addons) { price += addon.getcost(); system.out.print(""+ "" + addon.getname() + "" ""); } system.out.println(); coffemachine.allcoffees.add(this); return price; } public void heatcup() { isheated = true; } } public class vanillasyrup implements coffeeaddon { private double price = 6.0; private string name = ""vanillasyrup""; @override public double getcost() { return price; } @override public string getname() { return name; } } public interface coffeeaddon { double getcost(); string getname(); } import java.util.arraylist; public abstract class basecoffee { protected arraylist<coffeeaddon> addons; string type; basecoffee() { addons = new arraylist<coffeeaddon>(); } public void addaddon(coffeeaddon addon) { addons.add(addon); } public abstract double calculateprice(); } public class americano extends basecoffee { private double baseprice = 45.0; { type = ""americano""; } @override public double calculateprice() { double price = baseprice; system.out.print(""sipariş: "" + type + "" ""); for (coffeeaddon addon : addons) { price += addon.getcost(); system.out.print(""+ "" + addon.getname() + "" ""); } system.out.println(); coffemachine.allcoffees.add(this); return price; } } public class milk implements coffeeaddon { private double price = 5.0; private string name = ""milk""; @override public double getcost() { return price; } @override public string getname() { return name; } } public class doubleshot implements coffeeaddon { private double price = 10.0; private string name = ""doubleshot""; @override public double getcost() { return price; } @override public string getname() { return name; } } public class chocolate implements coffeeaddon { private double price = 7.0; private string name = ""chocolate""; @override public double getcost() { return price; } @override public string getname() { return name; } } import java.util.arraylist; public class coffemachine { static arraylist<basecoffee> allcoffees; static { allcoffees = new arraylist<basecoffee>(); } public void addaddontocoffee(basecoffee coffee, coffeeaddon addon) { if (coffee instanceof espresso) { if (addon instanceof doubleshot || addon instanceof chocolate) { coffee.addons.add(addon); } else { system.out.println(""[uyari] "" + coffee.type + "" tipi kahveye "" + addon.getname() + "" eklenemez""); } } else if (coffee instanceof latte) { if (addon instanceof milk || addon instanceof chocolate || addon instanceof vanillasyrup) { coffee.addons.add(addon); } else { system.out.println(""[uyari] "" + coffee.type + "" tipi kahveye "" + addon.getname() + "" eklenemez""); } } else if (coffee instanceof americano) { if (addon instanceof milk || addon instanceof vanillasyrup) { coffee.addons.add(addon); } else { system.out.println(""[uyari] "" + coffee.type + "" tipi kahveye "" + addon.getname() + "" eklenemez""); } } } public void makecoffee(basecoffee coffee) { double price = coffee.calculateprice(); system.out.println(""toplam fiyat: "" + (int) price + ""tl\n""); } public void heatespressocup(basecoffee coffee) { if (coffee instanceof espresso) { system.out.println(""espresso kahve fincanı ıstıldı""); ((espresso) coffee).heatcup(); } else { system.out.println(""[uyari] yalnızca espresso kahve fincanları ısıtılabilir""); } } // ??? public static void displaytotalcoffees() { system.out.println( ""tüm kahve makinaları tarafından toplam "" + allcoffees.size() + "" kahve üretildi""); } } 0",40001,5427,767,232,80,24
1764665,0,"1764665 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class app { public static void main(string[] args) throws exception { system.out.println(collatz(5)); sayac s1 = new sayac(""1111""); system.out.println(s1.say()); int[] arr = { 5, 4, 1, 2}; cocktailsort(arr); for (int i = 0; i < arr.length; i++) { system.out.println(arr[i]); } } public static int collatz(int i){ if (i == 1){ return 0; } if (i%2 == 0){ return 1 + collatz(i/2); } if (i % 2 == 1) { return 1 + collatz(i *3 +1); } return -1; } public static void cocktailsort(int[] arr){ cocktailsortdüz(arr); } public static void cocktailsortdüz(int[] arr){ boolean flag = false; for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { int temp = arr[i + 1]; arr[i + 1] = arr[i]; arr[i] = temp; flag = true; } } if (flag != false){ cocktailsortters(arr); } } public static void cocktailsortters(int[] arr) { boolean flag = false; for (int i = arr.length-1; i > 0 ; i--) { if (arr[i] < arr[i - 1]) { int temp = arr[i]; arr[i] = arr[i-1]; arr[i-1] = temp; flag = true; } } if (flag != false) { cocktailsortdüz(arr); } } } public class sayac { private string str; public sayac (string str){ this.str = str; } public int say(){ return recursivesay (str); } public int recursivesay (string str){ if(str.length() == 0){ return 0; } if (str.charat(0) == '1'){ return 1 + recursivesay(str.substring(1)); }else{ return recursivesay(str.substring(1)); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { this.strateji = s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } public class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } @override public void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } public class metalsarki extends sarki { string metalozelilk; public metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozelilk = metalozellik; } public void gostermetalozellikleri() { system.out.println(sanatci + "" - "" + isim + "" [ozellik: "" + isim + ""]""); } @override public void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozelilk + "")""); } } import java.util.arrays; import java.util.list; public class app { public static void main(string[] args) throws exception { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki.getclass().getname().equals(""metalsarki"")) { metalsarki song = (metalsarki) sarki; song.gostermetalozellikleri(); } } } } public class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } @override public void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } import java.util.arraylist; import java.util.list; import java.util.random; public class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { list<sarki> sarkilist = new arraylist<sarki>(); sarkilist.addall(sarkilistesi); random r = new random(); while (!sarkilist.isempty()) { int a = r.nextint(0, sarkilist.size()); sarkilist.get(a).oynat(); sarkilist.remove(a); } } } import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki curr : sarkilistesi) { curr.oynat(); } } } public abstract class sarki { string isim, sanatci; public abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean rock = false; for (sarki curr : sarkilistesi) { if (curr.getclass().getname().equals(""rocksarki"")) { if (!rock) { rock = true; system.out.println(""[bilgi] ses duzeyi: yuksek""); } } else { if (rock) { rock = false; system.out.println(""[bilgi] ses duzeyi: normal""); } } curr.oynat(); } } } import java.util.list; public interface calmastratejisi { public void cal(list<sarki> sarkilistesi); } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. recursion yenilemeye dayalı bir problem çözme yöntemidir. bu yöntem problemin belli bir kısmını çözen bir methodun kendini tekrar çağırmasına dayanır. her yeniden çağırma problemi biraz daha çözer. recursive bir methodun parçaları base case recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. base case problem çözümünde sona gelip gelmediğini kontrol eden kısımdır. bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? bios recursive bir metotta base case olmazsa ne olur? stackoverflow hatası ile karşılaşılır. recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. yeni bir stack açılır, bu stack yerel değişkenleri ve önceki adımda nerede kaldığımız gibi bilgileri içerir. fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. çünkü tail recursion nedir, kısaca açıklayınız. methodun kendini çağırdığı kısmın sonda olmasıdır. önceki stackte okunacak hiç kod kalmaz abstraction kavramını açıklayınız. konuyu bakış açımıza göre daha basit parçalara ayırma ve bu basit parçalar üzerinden konuyu tanımlamaya denir. ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? is a ilişkisi inheritence kavramalı için kullanılır. eğer bir class başka bir classin subclassi ise bu class aynı zamanda üst classdir. yani iki inherit class arasında subclass aynı zamanda superclassdir. ama süper class, subclassdir denemez. bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? protected ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? b olabilir. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? çünkü önce süper classlar instance edilir. subclasslar bundan sonra instance olmalıdır. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? hayır. metot overriding ve overloading kavramlarını açıklayınız. override, subclassin super class da olan bir methodu yeniden yazmasıdir. override da modifier ve signature superclassla aynıdır. ama overloadda signature farklıdır. overload aynı adda ama farklı parametrede yeni bir method oluşturmaya yarar. class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dog bark! class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? circle 4pi java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? static ve dinamik binding olarak ikiye ayrılır. method class a özgü ve objesiz calisabiliyorsa static objeye bağımlı ise dinamik olarak adlandırılır. staticler override edilemez dinamikler edilebilir. hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? eğer override edilmesi istenmiyor ve çalışmasi için obje gerekmiyorsa static, eğer her subclass ın bu methodu farklı şekilde çalıştırması gerekiyorsa (override a ihtiyaç varsa) dinamic yapılır. static methodun modifierlari private olamaz. dinamik bağlamada jvm'nin görevi nedir? methodlarin çağırıldigi referans tipine göre doğru override edilmiş methodu getirme java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? matematik sınıfi gibi objesiz çalışması gereken classlar calisamazdi java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? tüm özelliklerin olduğunu garanti etmemiz gerekir o yüzden explicittir. implicit yaparsak runtime error yaşanabilir. java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. evet yapılabilir, ama override edilen methodun modifierlari daraltilamaz. mesela public olan bir method override ile protected yapilamaz. class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? bark meov class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? parent classı special methoduna sahip değil dolayısıyla p.special çalışmaz. bu satır silinirse, ""parent display"" yazılacaktır. burada dinamik binding var çünkü override yapılmış. java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstrack class içerisinde henüz implement edilmemiş. farklı classlarda farklı şekilde overridelanacak olan methodlar içeren classlara denir. henüz tamamlanmadiklari için obje oluşturmazlar. extend edilip eksik yerlerin tamamlanması gerekir. concrete classlar tamamlamış classlardir ve obje üretebilirler. interfacelerin constructerı olmaz ama abstracklarin olmak zorundadır. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? abstract classlar abstract classlardan extend edilebilir. abstract bir classdan extend edilmiş bir abstract classda daha önceki classin abstract methodlari implement edilmiş olabilir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. polymorphism sağlar. yazılım mimarlarının henüz kod yazilamişken classlarin nasıl çalışacağını planlamasını sağlar. soyutlama yapmaya yarar. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract classlar extend edilerek kullanılır. classlarin tabii olduğu limitler sebebiyle iki classdan extend yapılamaz. interfacelerde böyle bir kısıtlama yoktur. interfaceler önceden hazırlanmış bazı özelliklerin classda eklenmesini sağlar. ikisi de tip olarak kullanılabilir. hatta bunu yapmaya yarayan marker interfaceler kullanilir. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface o interfacei kullanarak farklı atadan gelen objeleri tutmaya yarar. marker interfaceler kendi icinde kod tutmaz. functional interfaceler daha önceden hazırlanmış bir özelliği koda eklemeye yarar. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? bir class birden fazla interface implement edebilir. abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? animal calssı abstract bir calssdir obje olarak kullanılamaz. obje üretmek için o class extend edilip abstract methodlari implement edilmelidir. burda animal yerine dog classi obje olarak kullanılırsa sorun giderilir. output: animal: buddy woof interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? compile edilemez. çünkü ata classda move methodu yoktur. java'da inner class nedir, avantajları nelerdir? class içerisinde tanımlanan classa denir. kodun düzenli olması için kullanılabilir. builder class olarak kullanılabilir. statik ve statik olmayan (member) inner class arasındaki temel fark nedir? i̇kisi de üst objeye ihtiyaç duyar. ama static olan inner classdan üretilecek objeye ihtiyaç duymaz. anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? tanimlanip tanimlandigi anda tek seferde kullanılan classlara anonymous class denir. inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? erişebilirler. dışardaki classlarin görmemesi gereken sadece o iki classla alakalı bilgilerin iletilmesini sağlar. mesela builder classlar bu şekilde çalışır. statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? tanımlanabilir anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? olamaz. inner classlar isimleri olan tekrar kullanılabilir yapilar iken anonymous classlar isme sahip değildir sadece o kod yapısı içinde tek sefer kulllanilir. hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? static classlar class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? outer.inner diyerek referans tipi olusturulamaz. i̇nnner class private durumdadır. disardan goruntulenemez. eğer inner class public yapılırsa ve kullanılmadan önce outer class instantiate edilirse çalışır. çıktı: value: 10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? static inner class üst class üzerinden newlenmez. o kısım outer.statici̇nner() şeklinde düzeltilmeli. çıktı: count: 5 yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. compile time exception örneğin: syntax hataları, runtime exception örneğin: out of bound, logical exception örneğin: yanlış çözüm yolları kullanmak. exception handlingin amacı nedir? exception bir durumla karşılaşıldığında programın çökmesine sebep olmadan sorunu çözmeye yarar exception handlingde finally bloğunun amacı nedir? exception olsa da olmasa da çalışır. her şeyin sonunda o kısım okunur. örneğin aldığımız memoryi geri vermemiz gerekiyorsa bu kısim kullanılır. genel amacı her şeye rağmen çalışması gereken şeylerin exception halinde calismamasina engel olmaktir. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? checked exception try catch ile yapılır unchecked signatureda belirtilir java'da kendi exceptionunuzu nasıl tanımlarsınız? exception sınıfından extend edilmiş bir class tabimlariz java'da error ve exception arasındaki fark nedir, açıklayınız error bir hata iken exception hata değil kodun çalışmadığı istisnai durumlardır. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? exceptionlar bazı durumların bilgisini aktarmakta da kullanılabilir. bu durumda bunu yapariz 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? var olan exception ya çözülmeli ya da daraltılmalidir exception genisletilemez. static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenmez, arraylist 5 indexinde bir değere sahip değil. i̇ndex azaltılabilir ya da arraylist uzatılabilir. girilen indexteki değer yazdırılır. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.arraylist; public class habitat { private string location; private arraylist<penguin> penguins = new arraylist<penguin>(); private double temperature; public string getlocation() { return location; } public void setlocation(string str) { this.location = str; } public double gettemperature() { return temperature; } public void settemperature(int str) { this.temperature = str; } public arraylist<penguin> getpenguins() { return penguins; } public void setpenguins(arraylist<penguin> liste) { this.penguins = liste; } public habitat(string location, double temperature) { this.location = location; this.temperature = temperature; } public void addpenguin(penguin penguin) { penguins.add(penguin); } public void printhabitat() { system.out.println(""habitat location: "" + location); system.out.println(""average temprature: "" + temperature + ""°c""); system.out.println(""penguins living here: ""); for (penguin elem : penguins) { elem.printpenguin(); system.out.println(); } } } import java.util.arraylist; public class app { public static void main(string[] args) throws exception { // q1 parantezbas(3); // q2 penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(""antarctica"", -15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); } public static void parantezbas(int n) { arraylist<string> result = new arraylist<>(); parantezac(n, n, """", result); system.out.println(result); } public static void parantezac(int ac, int kapat, string curr, arraylist<string> result) { if (ac == 0 && kapat == 0) { result.add(curr); return; } if (ac > 0) { parantezac(ac - 1, kapat, curr + ""("", result); } if (kapat > ac) { parantezac(ac, kapat - 1, curr + "")"", result); } } } public class penguin { private string name, species; private int age; private double weight; public penguin() { this.name = ""willy""; this.species = ""emperor""; this.age = 1; this.weight = 5.0; } public penguin(string name, string species, int age, double weight) { this.name = name; this.species = species; this.age = age; this.weight = weight; } public void printpenguin() { system.out.print(""penguin name: "" + name); system.out.print("" species: "" + species); system.out.print("" age: "" + age); system.out.print("" weight: "" + weight + ""kg""); } public string getname() { return name; } public void setname(string str) { this.name = str; } public string getspecies() { return species; } public void setspecies(string str) { this.species = str; } public int getage() { return age; } public void setage(int str) { this.age = str; } public double getweight() { return weight; } public void setweight(int str) { this.weight = str; } public void hunt() { weight += 1; } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public class latte extends basecoffee { @override public void addaddon(coffeeaddon addon) throws exception { if (addon.getname().equals(""milk"") || addon.getname().equals(""chocolate"") || addon.getname().equals(""vanillasyrup"")) { addons.add(addon); } else { throw new exception(""""); } } @override public double calculateprice() { double p = 50; for (coffeeaddon elem : addons) { p += elem.getcost(); } return p; } } public class espresso extends basecoffee { private boolean isheated = false; public boolean getheat() { return isheated; } @override public void addaddon(coffeeaddon addon) throws exception { if (addon.getname().equals(""doubleshot"") || addon.getname().equals(""chocolate"")) { addons.add(addon); } else { throw new exception(""""); } } public void heatcup() { isheated = true; } @override public double calculateprice() { double p = 40; for (coffeeaddon elem : addons) { p += elem.getcost(); } return p; } } public class vanillasyrup implements coffeeaddon { @override public double getcost() { return 6; } @override public string getname() { return ""vanilla syrup""; } } public interface coffeeaddon { double getcost(); string getname(); } import java.util.arraylist; public abstract class basecoffee { protected arraylist<coffeeaddon> addons = new arraylist<coffeeaddon>(); public void addaddon(coffeeaddon addon) throws exception { this.addons.add(addon); } public abstract double calculateprice(); } public class americano extends basecoffee { @override public double calculateprice() { double p = 45; for (coffeeaddon elem : addons) { p += elem.getcost(); } return p; } @override public void addaddon(coffeeaddon addon) throws exception { if (addon.getname().equals(""milk"") || addon.getname().equals(""vanillasyrup"")) { addons.add(addon); } else { throw new exception(""""); } } } public class app { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); system.out.println(); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve // uretiyoruz. coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); system.out.println(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(); coffeemachine.sayiyazdir(); // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } public class coffeemachine { public static int count; public void addaddontocoffee(basecoffee coffee, coffeeaddon addon) { try { coffee.addaddon(addon); } catch (exception e) { system.out.println( ""[uyari] "" + coffee.getclass().getname() + "" tipi kahveye "" + addon.getname() + "" eklenemez""); } } public void makecoffee(basecoffee coffee) { count++; double price = coffee.calculateprice(); system.out.print(""sipariş: "" + coffee.getclass().getname()); try { espresso espresso = (espresso) coffee; if (espresso.getheat()) { system.out.print("" (sıcak fincan)""); } } catch (exception e) { } for (coffeeaddon elem : coffee.addons) { system.out.print("" + "" + elem.getname()); } system.out.println(""""); system.out.println(""toplam fiyat: "" + price + ""tl""); } public void heatespressocup(basecoffee coffee) { try { espresso espresso = (espresso) coffee; espresso.heatcup(); system.out.println(""espresso kahve fincanı ısıtıldı""); } catch (exception e) { system.out.println(""[uyari] yalnızca espresso kahve fincanları ısıtılabilir""); } } public static void sayiyazdir() { system.out.println(""tum fabrikalar kahve makineleri toplam "" + count + "" kahve uretildi""); } } public class milk implements coffeeaddon { @override public double getcost() { return 5; } @override public string getname() { return ""milk""; } } public class doubleshot implements coffeeaddon { @override public double getcost() { return 10; } @override public string getname() { return ""doubleshot""; } } public class chocolate implements coffeeaddon { @override public double getcost() { return 7; } @override public string getname() { return ""chocolate""; } } 0",40247,5302,716,241,73,27
6275288,2,"6275288 müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { calmastratejisi strateji; public void setstrateji(calmastratejisi s) { strateji = s; } public void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } public class klasiksarki extends sarki { klasiksarki(string isim, string sanatci) { super(isim, sanatci); } public void oynat() { system.out.println(""[klasi̇k] "" + sanatci + "" "" + isim + "" (hafif ve sakin)""); } } public class metalsarki extends sarki { public string metalozellik; @override public void oynat() { system.out.println(""[metal]"" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } metalsarki(string isim, string sanatci, string metalozellik) { super(isim, sanatci); this.metalozellik = metalozellik; } public void gostermetalozellik() { system.out.println(metalozellik); } } public class rocksarki extends sarki { rocksarki(string isim, string sanatci) { super(isim, sanatci); } public void oynat() { system.out.println(""[rock] "" + sanatci + "" "" + isim + "" (huzurlu ve nostaljik)""); } } import java.util.collections; import java.util.list; public class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { collections.shuffle(sarkilistesi); for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); } } } import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { (sarkilistesi.get(i)).oynat(); } } } public abstract class sarki { public string isim, sanatci; sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } public abstract void oynat(); } import java.util.arrays; import java.util.collections; import java.util.list; public class q3s1 { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(); system.out.println(""metal ozellikleri:""); for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof rocksarki) { system.out.println(""the type of this song is huzurlu ve nostaljik""); } if (sarkilistesi.get(i) instanceof metalsarki) { metalsarki a = (metalsarki) sarkilistesi.get(i); system.out.print(""the type of this song is ""); a.gostermetalozellik(); } if (sarkilistesi.get(i) instanceof klasiksarki) { system.out.println(""the type of this song is hafif ve sakin""); } } } } import java.util.list; public class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { int a = 0; for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof rocksarki) { a = i; } } if (a == 0) { for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); } } else { for (int i = 0; i < sarkilistesi.size(); i++) { if (i == a) { sarkilistesi.get(i).oynat(); system.out.println(""[bilgi] ses duzeyi: normal""); } else { sarkilistesi.get(i).oynat(); } } } } } import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. recursion metodun içinde kendisini çağırdığımız metod biçimidir. recursive metodun temel kısımları base case ve metod işlemlerinin olduğu kısımlar ve birleştirme aşamasıdır. recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. base case recursive metodu sonlandırmamıza yarayan koşuldur. bu koşulu doğru belirlememiz metodun sonsuz defa çalışmasını önler. bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? base case stringin uzunluğuyla ilgili olurdu. her defasında elimizdeki stringin son harfini alırdım ve yazardım. recursive bir metotta base case olmazsa ne olur? base case olmazsa metod sonlanmaz ve çıktı alamazsın. recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. her defasında bir çerçeve açılır. parametreleri ve nerde bulunduğumuz bilgisini tutarız. fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. bu konuda fikrim var ama doğru olduğunu düşünmüyorum tail recursion nedir, kısaca açıklayınız. bilmiyorum abstraction kavramını açıklayınız. herkes kendi bakış açısından problemi veya amacı soyutlar. arabanın şöförünün arabaya bakış açısıyla mühendisin bakış açısı aynı değildir. ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? i̇nstanceof il kontrol edilir. i̇ki class arasında bağ olup olmadığı görülür. mesela lion classının bir objesi olan lion1 aynı zamanda bir hayvandır. bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? default ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? a ve c, a is a ve c is a java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? zorunda değildir bence. eğer süper yazmazsak ata classın parametresiz constructoru çalışır. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? hayır. metot overriding ve overloading kavramlarını açıklayınız. override ata classta bulunan methodu yavru classta yeniden düzenlemek yeni özellikler eklemek. overload is aynı ada sahip ama farklı parametreler alan methodlar yazmaktır. class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dog bark class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? generic generic 8.0 java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class abstract metod içerebilen, kendisinden obje üretilemeyen(concreteden farkı), kendisini extend eden classın (eğer varsa) abstract metodu implement etmesi gereken classtır. constructor bulundurmak zorundadır. abstract metod bulundurmak zorunda değil.i̇nterface ise tamamen abstract olmuş classtır. i̇çine yazılan her metod abstract olmalı. i̇nstance variable final ve static olmalı. constructor bulundurmalı. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? ata classta implement edilmemiş abstract metod yavru classta implement edilebilir. yavru class çok başka bir abstract metod içeriyosa(zorunlu değil abstract keywordü ile declar, define edilmesi yeterli) o da abstract olur. böylece abstract metod abstract classta implement edilmiş olur. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. ortak özelliğin ne olduğunu verir biz o özelliği yavru classta implement ederiz. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interface içinde abstract olmayan metod bulunduramaz. i̇nterface implement edilir. abstract extend. 1 classı extend edersin ama implement için sınır yok. tip olarak kullanılamazlar bence. marker interface ve functional interface kavramları nedir, nasıl kullanılır? . bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet sınırsız implement olabilir. bir interface diğer bir interfacei implement edemez. abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? animal objesi oluşturamazsın çünlü abstract. new animali new dog yaparım. çıktı animal: buddy ve woof olur. interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? i̇nterfacelerde metod implement edilmez. çıktı swimming olur. java'da inner class nedir, avantajları nelerdir? inner class bir başka classın içinde tanımlanan classtır. kodun düzenini arttırır. pizza-builder örneğinde olduğu gibi dışardan müdahaleyi engelleyebilir. public private static olabilir. statik ve statik olmayan (member) inner class arasındaki temel fark nedir? static inner class için outer objesine gerek yok member inner class için var. anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? bir classı extend, ya da interfaci implement edip anında kullanan classtır. classı açıp hemen implementasyonu yaparız. ama başka classlar bundan etkilenmez. inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? evet erişebilir çünkü o classın içinde ve final değilse değiştirir. bu inner classları geliştiren bir özellik. statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? hayır çünkü static keywordu obje zorunluluğunu kaldırır. ama class static değilse objeye ihtiyacımız var. anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? olmaz çünkü obje oluşturmuyoruz. inner classlardan farkı objeleri yok bir classın içinde değiliz. hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? public ve static. class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? i̇nner static class olmalı ki obje oluştururken outer class objesine ihtiyaç duymayalım. ve valueyi static yapalım.önemli 10 çıktı. class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? hata yok. 5 output. yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. 1-) compile tim error: int i=5 ve int i=6 yazarsak mesela. 2-) runtime error: arrayoutofboundexeption mesela. logical error: mantıksal hatadır. exception handlingin amacı nedir? oluşabilecek hatalara karşı önlem alma ve hatayı engelleme. exception handlingde finally bloğunun amacı nedir? her türlü çalışmasını istediğimiz kod parçasını oraya yazarız o da çalışır. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? checked excpetionlar için ya declare işlemi ya da handle işlemi yapmalıyız. unchecked exceptionlar için yapmayız. java'da kendi exceptionunuzu nasıl tanımlarsınız? class oluşturup exceptionu extend ederim. java'da error ve exception arasındaki fark nedir, açıklayınız error jvm ile exceptionlar genellikle kullanıcı girişiyle alakalıdır. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? o exceptionun handle işleminin eksiksiz olmasını isteriz belki. 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? verdiğimiz hata türünü genişletemeyiz. throws arrayoutofboundexeption verdiysek override sonrası throws exception diyemeyiz. static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenir.hataların kaynağı indexin arrayin sınırınj aşması. hataları düzeltmek için öncelikle catch bloklarının yeri değişmeli. üst alta gelcek şekilde.arrayoutofboundexeption alacağız o yüzden ya arrayin boyutunu arttıralım ya da indexi azaltalım. i̇ndex 4 olursa output 5 olur. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.arraylist; public class q1s2 { public static void main(string[] args) { penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); habitat habitat = new habitat(""antarctica "", -15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); } } class penguin { private string name, species; private int age; private double weight; public string getname() { return name; } public string getspecies() { return species; } public int getage() { return age; } public double getweight() { return weight; } public void setname(string name) { this.name = name; } public void setspecies(string species) { this.species = species; } public void setage(int age) { this.age = age; } public void setweight(double weight) { this.weight = weight; } public void hunt() { weight = weight + 1.0; } penguin() { name = ""willy""; species = ""emperor""; age = 1; weight = 5.0; } public penguin(string name, string species, int age, double weight) { this.name = name; this.species = species; this.age = age; this.weight = weight; } public void printpenguin() { system.out.println( ""penguin name="" + name + "" species="" + species + "" age="" + age + "" years weight="" + weight + "" kg""); } } class habitat { private string location; private double temperature; private arraylist<penguin> penguins; public habitat(string location, double tempereature) { this.location = location; this.temperature = tempereature; penguins = new arraylist<>(); } public string getlocation() { return location; } public double gettemperature() { return temperature; } public arraylist<penguin> getpenguins() { return penguins; } public void setlocation(string location) { this.location = location; } public void settemperature(double temperature) { this.temperature = temperature; } public void setpenguins(arraylist<penguin> penguins) { this.penguins = penguins; } public void addpenguin(penguin penguin1) { penguins.add(penguin1); } public void printhabitat() { system.out.println(""habitat location="" + location); system.out.println(""aberage temperature is="" + temperature); system.out.println(""penguens living here are:""); for (int i = 0; i < penguins.size(); i++) { penguins.get(i).printpenguin(); } } } public class q1s1 { public static void main(string[] args) { parantezbas(3); } public static void parantezbas(int n) { if (n == 1) { system.out.print(""()""); } else { system.out.print(""(""); parantezbas(n - 1); system.out.print("")""); system.out.print(""()""); parantezbas(n - 1); } } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public class latte extends basecoffee { public double calculateprice() { return 50.0; } } public class espresso extends basecoffee { private boolean isheated = false; public boolean getter() { return isheated; } public double calculateprice() { return 40.0; } public void heatcup() { isheated = true; } } public class vanillasyrup implements coffeeaddon { @override public double getcost() { return 6.0; } @override public string getname() { return ""vanillasyrup""; } } public interface coffeeaddon { public double getcost(); public string getname(); } import java.util.arraylist; public abstract class basecoffee { protected arraylist<coffeeaddon> addons = new arraylist<>(); public void addaddon(coffeeaddon addon) { addons.add(addon); coffeemachine.count++; } public abstract double calculateprice(); } public class americano extends basecoffee { public double calculateprice() { return 45.0; } } public class coffeemachine { public static int count = 0; public void addaddontocoffee(basecoffee coffee, coffeeaddon addon) { if (coffee instanceof espresso && (addon instanceof vanillasyrup || addon instanceof milk)) { system.out.println(""[uyari̇] espresso ti̇pi̇ kahveye "" + addon.getname() + "" eklenemez""); } if (coffee instanceof latte && (addon instanceof doubleshot)) { system.out.println(""[uyari̇] latte ti̇pi̇ kahveye"" + addon.getname() + ""eklenemez""); } if (coffee instanceof americano && (addon instanceof chocolate || addon instanceof doubleshot)) { system.out.println(""[uyari̇] ameri̇cano ti̇pi̇ kahveye"" + addon.getname() + ""eklenemez""); } else { coffee.addaddon(addon); } } public void makecoffee(basecoffee coffee) { if (coffee instanceof latte) { system.out.print(""sipariş: latte""); int i = coffee.addons.size(); for (int y = 0; y < i; y++) { system.out.print(""+"" + coffee.addons.get(y).getname()); } double z = 0.0; system.out.println(); for (int y = 0; y < i; y++) { z = z + coffee.addons.get(y).getcost(); } z = z + coffee.calculateprice(); system.out.println(""toplam fiyat:"" + z); system.out.println(); } if (coffee instanceof americano) { system.out.print(""sipariş: americano""); int i = coffee.addons.size(); for (int y = 0; y < i; y++) { system.out.print(""+"" + coffee.addons.get(y).getname()); } system.out.println(); double z = 0.0; for (int y = 0; y < i; y++) { z = z + coffee.addons.get(y).getcost(); } z = z + coffee.calculateprice(); system.out.println(""toplam fiyat:"" + z); system.out.println(); } if (coffee instanceof espresso) { if (((espresso) coffee).getter()) system.out.print(""si̇pari̇s:espresso (sicak fi̇ncan)""); else system.out.print(""si̇pari̇s:espresso normal""); int i = coffee.addons.size(); for (int y = 0; y < i - 1; y++) { system.out.print(""+"" + coffee.addons.get(y).getname()); } system.out.println(); double z = 0.0; for (int y = 0; y < i; y++) { z = z + coffee.addons.get(y).getcost(); } z = z + coffee.calculateprice(); system.out.println(""toplam fiyat:"" + z); system.out.println(); } } public void heatespressocup(basecoffee coffee) { if (coffee instanceof espresso) { system.out.println(""espresso coffee isitildi""); ((espresso) coffee).heatcup(); } else { system.out.println(""[uyari]sadece espresso tipi kahve isitilabilir.""); } } public void getcount() { system.out.println(""bu kadar kahve üreti̇ldi̇:"" + (count - 1)); } } public class milk implements coffeeaddon { public double getcost() { return 5.0; } public string getname() { return ""milk""; } } public class mainim { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve // uretiyoruz. coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(); // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz machine.getcount(); } } public class doubleshot implements coffeeaddon { @override public double getcost() { return 10.0; } @override public string getname() { return ""doubleshot""; } } public class chocolate implements coffeeaddon { public double getcost() { return 7.0; } public string getname() { return ""chocolate""; } } 2",34264,4439,619,203,56,25
6194008,1,"6194008 müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arraylist; import java.util.arrays; import java.util.collections; import java.util.list; abstract class sarki { string isim; string sanatci; abstract void oynat(); } class metalsarki extends sarki { string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void gostermetalozellikleri() { system.out.println(sanatci + "" - "" + isim + "" [ozellik: "" + metalozellik + ""]"" ); } void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } } class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } interface calmastratejisi { void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); } } } class karisikcalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi) { list<sarki> sarkilistesitemp = new arraylist<>(); for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesitemp.add(i, sarkilistesi.get(i)); } collections.shuffle(sarkilistesitemp); for (int i = 0; i < sarkilistesitemp.size(); i++) { sarkilistesitemp.get(i).oynat(); } } } class rockcuozelcalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { if (i-1 >= 0) { if (i == sarkilistesi.size()-1 && sarkilistesi.get(i) instanceof rocksarki && sarkilistesi.get(i-1) instanceof rocksarki) { sarkilistesi.get(i).oynat(); system.out.println(""ses duzeyi: normal""); } else if (i == sarkilistesi.size()-1 && sarkilistesi.get(i) instanceof rocksarki) { system.out.println(""ses duzeyi: yuksek""); sarkilistesi.get(i).oynat(); system.out.println(""ses duzeyi: normal""); } else if (sarkilistesi.get(i) instanceof rocksarki && sarkilistesi.get(i-1) instanceof rocksarki ) { sarkilistesi.get(i).oynat(); continue; } else if (sarkilistesi.get(i) instanceof rocksarki) { system.out.println(""ses duzeyi: yuksek""); sarkilistesi.get(i).oynat(); } else if (sarkilistesi.get(i-1) instanceof rocksarki) { system.out.println(""ses duzeyi: normal""); sarkilistesi.get(i).oynat(); } else { sarkilistesi.get(i).oynat(); } } else { if (sarkilistesi.get(i) instanceof rocksarki) { system.out.println(""ses duzeyi: yuksek""); sarkilistesi.get(i).oynat(); } else { sarkilistesi.get(i).oynat(); } } } } } class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { strateji = s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } public class main { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } } } } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. bir metodun kendini tekrar çağırmasıdır. base case recursion gerektirmeyen gerçekleşmesi en kolay olan koşuldur. decompile case de recursion içeren kısımdır. compile case çağrılmasıdır ( benim anladığım.) recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. base case recursion içermeyen kısımdır ve bu recursiondan çıkmak için gereklidir. bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? base case 1 karakter olması olurdu. substring alırdım birden itibaren ve bunu geri metoda koyup recursion yaptırırdım sonra da artı charat 0 derdim. recursive bir metotta base case olmazsa ne olur? recursiondan çıkılamaz sonsuz döngü recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. objeleri falan tutar ve üstteki çizgi falan atılır metod burda fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. çünkü recursion loopa göre daha çok donanım kullanır bu yüzden verimsizdir tail recursion nedir, kısaca açıklayınız. recursionun olduğu case de returnde sadece recursion olmasıdır loopa en kolay döndürülen recurpn tipidir abstraction kavramını açıklayınız. soyutlama demektir. gereksiz bilgili yerleri göstermemedir. (black box) ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? birinin birine extend edilmesi gerekir. (inheritance) diyelim ki a bi class ve b extends a olsun. b is an a olur. bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? protected ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? c olabilir çünkü a c yi kapsar ama b olamaz çünkü a b yi kapsamaz java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? i̇lk önce atadan başlanır çünkü java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? değildir tek bir classı extend edebilir metot overriding ve overloading kavramlarını açıklayınız. method overriding bi classtaki metodun subclasslarında değiştirilmesidir. overloading ise bir metodun ismini falan koruyarak sadece parametrelerini değiştirmedir class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dog bark! class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? circle 8 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? statik dinamik metot bağlama çeşitlendirmesidir hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? i̇lk baş tanımlanan şeyler static binding, çalıştırıldığında olanlar dinamik dinamik bağlamada jvm'nin görevi nedir? is java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? dk java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? down casting mesela animal animal = new dog() demek de implicit explicit bilmiyorum java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. hayır edilemez public ama protected olarak override edilebilir class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik bağlama class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? p.special silinmeli parent display dinamik java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class soyut classtır ve içindeki metotlar tanımlanmadan yazılır. (; ile) constructorları olabilir ama interfacelerin olamax abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? başına abatract yzarak edilebilir abstract metotlar sadece abstract classlarda olur abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. sonradan tanımlamayı (tanımlamayı geciktirmeyi) sağlar i̇nheritance yardımcı oluyor i̇leride metodun yazılacağını garanti eder(sözleşme) abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? i̇nterfaceler bi özelliği belirtirken abstract classlar tam manasıyla soyut classlardır myclass myabstractclass’ın altındaki bi class olsun ve abstract olmasın. myabstractclass obj1; deyip onu sonradan new myclass diyebilitiz marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker boştur functionalin içinde metotlar vardır bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? bir interface başka bir interface i extend edebilir implement edemez bir class birden çok interface implement edebilir abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? animal a = new animal hatalıdır bunu animal a = new dog diyerek düzeltebiliriz buddy woof interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? duck un süper classı yoktur oraya öyle denmez aynı şekilde duckun implemenr ettiği 2 interface vardır o yüzden hangiainden alınacağı bilinemez flyabledan aldırırsak flying java'da inner class nedir, avantajları nelerdir? classın içindeki classtır statik ve statik olmayan (member) inner class arasındaki temel fark nedir? static classa class ismiyle ulaşılabilir tabi outer class yoluyla ama diğer classlara öyle ulaşılamaz anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? bilmiyorum inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? evet ve bu inner classların düzenlemeye katkısını açıklar statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? hayır çünkü mantığa aykırı anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? bilmiyorum hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? staticler class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? outer.inner.display olmalıydı value: 10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? outer.new staticinner olmalı outer.inner.showcount olmalı count: 5 yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. errorlar ve exceptionlar vardır. errorlar handle edilemez exceptionlar handle edilebilir exception handlingin amacı nedir? exceptionları yakalamak ve bunun üzerinden uygun işlemleri gerçekleştirmek exception handlingde finally bloğunun amacı nedir? exception yakalansa da yakalanmasa da çalışan bir bloktur bu işlemler için kullanılır java'da 'checked' ve 'unchecked' exceptionların farkı nedir? birinde metoda throws exception türü yazılır ama öbüründe gerek yoktur (checked da gerek yoktur) java'da kendi exceptionunuzu nasıl tanımlarsınız? extends denir ve özellik belirtilir classın içinde java'da error ve exception arasındaki fark nedir, açıklayınız error handle edilemez ama exception handle edilebilir java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? daha sonraki bi basamakta handle edilmesini sağlamak (geciktirmek) 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? error throws yazılamaz ve checkedleri throws yazılamaz static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenir ama exception out of bounds olmasına rağmen normal exception catch ine girer array out of bounds catch ine girmesi gerekirken hatayı catch exception la catch array index out of bounda exceptionun yerini değiştirerek düzeltebiliriz ve düzeltilmiş sonuç “array exception caught” olur static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.arraylist; public class q2 { public static void main(string[] args) { penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(""antarctica"",-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); } } class habitat { private string location; private double temperature; private arraylist<penguin> penguins = new arraylist<penguin>(); public habitat(string location, double temperature) { this.location = location; this.temperature = temperature; } public string getlocation() { return location; } public double gettemperature() { return temperature; } public void setlocation(string location1) { location = location1; } public void settemperature(double temperature1) { temperature = temperature1; } public void addpenguin(penguin penguin) { penguins.add(penguin); } public void printhabitat() { system.out.println(""habitat location: "" + location); system.err.println(""average temperature: "" + temperature); system.out.println(""penguins living here: ""); for (int i = 0; i < penguins.size(); i++) { system.out.println(""penguin name: "" + (penguins.get(i)).getname() + "" species: "" + (penguins.get(i)).getspecies() + "" age: "" + (penguins.get(i)).getage() + "" years"" + "" weight: "" + (penguins.get(i)).getweight() + "" kg""); } } } class penguin { private string name; private string species; private int age; private double weight; public penguin() { name = ""willy""; species = ""emperor""; age = 1; weight = 5.0; } public penguin(string name, string species, int age, double weight) { this.name = name; this.species = species; this.age = age; this.weight = weight; } public void hunt() { weight = weight+1; } public void printpenguin() { system.out.println(name); system.out.println(species); system.out.println(age); system.out.println(weight); } public string getname() { return name; } public void setname(string name1) { name = name1; } public string getspecies() { return species; } public void setspecies(string species1) { species = species1; } public int getage() { return age; } public void setage(int age1) { age = age1; } public double getweight() { return weight; } public void setweight(double weight1) { weight = weight1; } } public class q1 { public static void main(string[] args) { parantezbas(3); } public static void parantezbas(int n) { string a = """"; parantezbas1(n,a); } public static void parantezbas1(int n, string a) { if (a.length() == n*2) { system.out.println(a); } int acma = 0; int kapama = 0; for (int i = 0; i < a.length(); i++) { if (a.charat(i) == '(') { acma++; } else { kapama++; } } if (acma > kapama && n*2 - a.length() <= acma) { a = a + ')'; parantezbas1(n, a); } else { string temp = a; a = a + ')'; parantezbas1(n, a); parantezbas1(n, temp); } } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 import java.util.arraylist; interface coffeeaddon { double getcost(); string getname(); } class milk implements coffeeaddon { @override public double getcost() { return 5; } @override public string getname() { return ""milk""; } } class chocolate implements coffeeaddon { @override public double getcost() { return 7; } @override public string getname() { return ""chocolate""; } } class vanillasyrup implements coffeeaddon { @override public double getcost() { return 6; } @override public string getname() { return ""vanilla syrup""; } } class doubleshot implements coffeeaddon { @override public double getcost() { return 10; } @override public string getname() { return ""double shot""; } } abstract class basecoffee { protected arraylist<coffeeaddon> addon = new arraylist<>(); public void addaddon(coffeeaddon addons) { addon.add(addons); } public abstract double calculateprice(); } class espresso extends basecoffee { private boolean isheated = false; @override public double calculateprice() { int totaladdonsprice = 0; for (coffeeaddon a : addon) { totaladdonsprice += a.getcost(); } return 40 + totaladdonsprice; } public void heatcup() { isheated = true; } public boolean getisheated() { return isheated; } } class latte extends basecoffee { @override public double calculateprice() { int totaladdonsprice = 0; for (coffeeaddon a : addon) { totaladdonsprice += a.getcost(); } return 50 + totaladdonsprice; } } class americano extends basecoffee { @override public double calculateprice() { int totaladdonsprice = 0; for (coffeeaddon a : addon) { totaladdonsprice += a.getcost(); } return 45 + totaladdonsprice; } } class coffeemachine { static int toplamkahveuretimi = 0; public void addaddontocoffee(basecoffee coffee, coffeeaddon addons) { if (coffee instanceof espresso) { if (addons instanceof doubleshot || addons instanceof chocolate) { coffee.addaddon(addons); } else { system.out.println(""[uyari] ""+ coffee.getclass() + "" tipi kahveye "" + addons.getname() + "" eklenemez""); } } else if (coffee instanceof latte) { if (addons instanceof vanillasyrup || addons instanceof chocolate || addons instanceof milk) { coffee.addaddon(addons); } else { system.out.println(""[uyari] ""+ coffee.getclass() + "" tipi kahveye "" + addons.getname() + "" eklenemez""); } } else if (coffee instanceof americano) { if (addons instanceof milk || addons instanceof vanillasyrup) { coffee.addaddon(addons); } else { system.out.println(""[uyari] ""+ coffee.getclass() + "" tipi kahveye "" + addons.getname() + "" eklenemez""); } } } public void makecoffee(basecoffee coffee) { toplamkahveuretimi++; string ab = """"; for (coffeeaddon a : coffee.addon) { ab += "" + "" + a.getname(); } if (coffee instanceof espresso) { if (((espresso) coffee).getisheated() == true) { system.out.println(""sipariş: espresso (sıcak fincan)"" + ab); } else { system.out.println(""sipariş: espresso"" + ab); } } else if (coffee instanceof latte) { system.out.println(""sipariş: latte"" + ab); } else if (coffee instanceof americano) { system.out.println(""sipariş: americano"" + ab); } system.out.println(""toplam fiyat: "" + coffee.calculateprice() + ""tl""); system.out.println(); } public void heatespressocup(basecoffee coffee) { if (coffee instanceof espresso) { ((espresso) coffee).heatcup(); system.out.println(""espresso kahve fincanı ısıtıldı""); } else { system.out.println(""[uyari] yalnızca espresso kahve fincanları ısıtılabilir""); } } public static void totalcoffee() { system.out.println(""tüm kahve makineleri tarafindan toplam "" + toplamkahveuretimi + "" kahve üretildi""); } } public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(""\n""); coffeemachine.totalcoffee(); } } 1",35257,4576,620,229,59,16
3659398,1,"3659398 müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.*; class muzikcalar { calmastratejisi strateji; public void setstrateji(calmastratejisi s) { strateji = s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } class klasiksarki extends sarki { klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } public void oynat() { system.out.println(""[klasi̇k]"" + sanatci + ""-"" + isim + "" (hafif ve sakin)""); } } import java.util.*; public class muzikcalarsorusu { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } } } } class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } public void gostermetalozellikleri() { system.out.println(sanatci + "" - "" + isim + "" [ozellik: "" + metalozellik + ""]""); } public void oynat() { system.out.println(""[metal]"" + sanatci + ""-"" + isim + "" ("" + metalozellik + "")""); } } class rocksarki extends sarki { rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } public void oynat() { system.out.println(""[rock]"" + sanatci + ""-"" + isim + "" (huzurlu ve atmosferik)""); } } import java.util.*; class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { boolean[] arr = { false, false, false, false, false }; for (int i = 0; i < 5; i++) { int a = (int) (math.random() * 5); if (arr[a] == false) { sarkilistesi.get(a).oynat(); arr[a] = true; } else i--; } } } import java.util.*; class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); } } } abstract class sarki { string isim; string sanatci; abstract void oynat(); } import java.util.*; class rockcuozelcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { if (i == 0 && sarkilistesi.get(i) instanceof rocksarki) { system.out.println(""[bilgi] ses duzeyi: yuksek""); } if (i != 0) { if (sarkilistesi.get(i - 1) instanceof rocksarki && !(sarkilistesi.get(i - 1) instanceof rocksarki)) system.out.println(""[bilgi] ses duzeyi: yuksek""); } if (i != 0) { if (sarkilistesi.get(i) instanceof rocksarki && !(sarkilistesi.get(i) instanceof rocksarki)) system.out.println(""[bilgi] ses duzeyi: normal\r""); } sarkilistesi.get(i).oynat(); } } } import java.util.*; interface calmastratejisi { void cal(list<sarki> sarkilistesi); } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. recursion ozyinelemedir. döngü içinde döngü mantığına benzer. 3 kısımdan oluşur. bunlardan ilki base case: stack overflow olmasını engeller bizim onkosulumuzdur. recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. base case stack overflow olmasını engelleyen temel koşulumuzdur. bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? base case str.length() == 1 şeklinde if statement olurdu. stringin ilk harfini alır geri kalanını tersten yazdirmasjni sagliyacak bir recursive metod yazardım. recursive bir metotta base case olmazsa ne olur? stack overflow recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. stack memory de üst üste yerler açılır ve en üstteki kapanmaya başladığında sırasıyla hepsi kapanır. fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. çünkü fibonaccide recursive mthodta iki bilinmeyen olacağından stack memoryde oldukça yer kaplar ve verimli olmaz. tail recursion nedir, kısaca açıklayınız. . abstraction kavramını açıklayınız. soyutlama demek komleksiteyi azaltmak için ve güvenlik için kullanıyoruz. ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? i̇s a ilişkisi inheritance için kullanılır bir class diğerinin genellikle atasidir. totoloji de olabilir. bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? default ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? c ve a java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? çünkü ilk önce ata classlar tanımlanmalıdır java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? hayır metot overriding ve overloading kavramlarını açıklayınız. overriding aynı signature ama işlev değişir overload farklı signature (parametreler farklı) aynı dönüş için kullanılır. class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? animal \t generic animal sound class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? circle \t 8 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? bağlama anlamına geliyor 2 çeşit bağlama vardır static ve dynamic early compile zamanı çalışır dynamic run time zamanı çalışır makinenin karar mekanizması içindir. hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? static metodlar olduğunda static binding uygulanır override olduğunda dynamic bindic kullanilir. dinamik bağlamada jvm'nin görevi nedir? hangi methodun kullanılacağına karar verir. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? efektif olmazdi java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? çünkü downcast edildiginde override edilmiş bir metodda çocuk classin özelliklerini taşıması için açık bir şekilde downcast edilir. java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. kümeleme olarak aşağı gidilebilir yani public bir method protected override edilebilir ama tam tersi mümkün değildir. class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? child display child special output olur burada override olduğundan dinamiktir java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class soyut sınıf anlamına gelir concrete classtan farkı objesini olusturamamaktir abstrac classin constructreri olabilir interfacin olamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? hayır abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. objeleri olusturulmaz. metotlar implement edilmesi kendi class içinde. override etmek zorunludur. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract class extend edilir interfaceler implement edilir ve abstract classin constructreri olurkeen interfacin olmaz. i̇kisinde de obje olusturulamaz marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface içinde method olmayan boş interfacelere denir functional interface sadece 1 tane abstract methodu olan interfacelere denir. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? i̇lki evet ikinisi hayır implement etmez extend eder. abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? animal obje olusturamaz onun yerien dog diye olusuturlmasi gerekiuro. output:animal buddy woof interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? edilmez çünkü ata class yokken süper çağrılmış. ve iki interface de move diye defaultethod girilmiş bu methodlarin ismi değişmeli ya da ikisinden biri implement edilmemeli öyle bir durumda swimming ya da flying outputu cikacaktir java'da inner class nedir, avantajları nelerdir? i̇nner class class içine class yazmaktır birincil amacı daha duzgun bir kod yazmaktır. statik ve statik olmayan (member) inner class arasındaki temel fark nedir? statik class outer classin instance a bağlı olmadan çalışabilir ve erisilirebilir. anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? bir classi newleyip metodları override ederek bir blok içerisinde yazıldığında isimsiz class üretilir. inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? outer innera erişebilir inner outera erisemez statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? tanımlanamaz çünkü static olması bağımsız olması anlamına gelir ama class static olmadan outer classa bağlı olduğundan static tanımına aykırıdır. anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? constructor olmaz. i̇nner classtan farkı constructor olmaması ve bağımsız bir class olmasidir hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? public inner classlar class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? outer classta private değişken tanımlanmış public olmalı ve çıktı olarka value 10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? static inner class static değilmiş gibi çağrılmış compile edilmez. sonuç olarak count 5 yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. compile error örnek olarak tanımlanmamış bir değişken kullanımı olabilir. runtime error array out of index olabilir. ve logical errors yanlış algoritma kullanımı olmak üzere 3 tane hata türü vardır. exception handlingin amacı nedir? oluşabilecek istisnai hataları kontrol etmek. exception handlingde finally bloğunun amacı nedir? exception olsun olmasın execute edilmesini sağlar icindekinin. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? checked compile zamanı oluşan exceptionlardir unchecked exceptionlar runtime zamanı oluşan exceptionlardir. java'da kendi exceptionunuzu nasıl tanımlarsınız? exception sınıfından ya da throwable sınıfından extend ettiğim bir class olustururum ve super(mesaj) şeklinde atasını implement ederim. java'da error ve exception arasındaki fark nedir, açıklayınız error sistem düzeyindeki haftalardır exceptionlar compile ve runtime hatalaridir. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? bu şekilde daha üste atılır ve üstte işlem gormeisni sağlar. method dışı ya da class dışı. 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? ata sinifindan extend edildiyse daha genel bir hata oluşturamaz. static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? array exception caught çıktı olur. dizi indeksi 0dan baslamalkdir. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.*; public class penguinhabitat { public static void main(string[] args) { penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(""antartica"", -15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); } } public class habitat { private string location; private double temperature; private arraylist<penguin> penguins; public habitat(string location, double temperature) { this.location = location; this.temperature = temperature; this.penguins = new arraylist<penguin>(); } public string getlocation() { return location; } public double gettemperature() { return temperature; } public void setname(string location) { this.location = location; } public void settemperature(double temperature) { this.temperature = temperature; } public void addpenguin(penguin penguin) { penguins.add(penguin); } public void printhabitat() { for (int i = 0; i < penguins.size(); i++) system.out.println(penguins.get(i).printpenguin()); } } public class penguin { private string name; private string species; private int age; private double weight; public penguin() { this.setname(""willy""); this.setspecies(""emperor""); this.setage(1); this.setweigth(5.0); } public penguin(string name, string species, int age, double weight) { this.name = name; this.species = species; this.weigth = weight; this.age = age; } public string getname() { return name; } public string getspecies() { return species; } public int getage() { return age; } public double getweigth() { return weight; } public void setname(string name) { this.name = name; } public void setspecies(string species) { this.species = species; } public void setage(int age) { this.age = age; } public void setweigth(double weigth) { this.weigth = weigth; } public void hunt() { setweigth(weight + 1); } public void printpenguin() { system.out.println(getname()); system.out.println(getspecies()); system.out.println(getage()); system.out.println(getweigth()); } } import java.util.*; public class parantez { public static void main(string[] args) { scanner klavye = new scanner(system.in); parantez obj = new parantez(); obj.parantezbas(klavye.nextint()); } public void parantezbas(int n) { if (n == 0) system.out.print(""""); if (n == 1) system.out.print(""()""); if (n == 2) { system.out.print(""()""); parantezbas(n - 1); system.out.print(""(""); parantezbas(n - 1); system.out.print("")""); } if (n > 2) { system.out.print(""()""); parantezbas(n - 1); system.out.print(""(""); parantezbas(n - 1); system.out.print("")""); parantezbas(n - 1); system.out.print(""()""); } } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public class kahve { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(""\n""); // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz coffeemachine.numofcoffes(); } } public class latte extends basecoffee { public latte() { super(); } public double calculateprice() { double res = 50; for (int i = 0; i < addons.size(); i++) { res = res + addons.get(i).getcost(); } return res; } public void getcoffe() { system.out.print(""siparişiniz: latte""); for (int i = 0; i < addons.size(); i++) { system.out.print("" + "" + addons.get(i).getname()); } system.out.println(); system.out.println(""toplam fiyat: "" + calculateprice()); } public string getcoffename() { return ""latte""; } } public class espresso extends basecoffee { private boolean isheated; public espresso() { super(); isheated = false; } public double calculateprice() { double res = 40; for (int i = 0; i < addons.size(); i++) { res = res + addons.get(i).getcost(); } return res; } public void heatcup() { isheated = true; } public void getcoffe() { if (isheated) system.out.print(""siparişiniz: espresso (sıcak fincan)""); else system.out.print(""siparişiniz: espresso""); for (int i = 0; i < addons.size(); i++) { system.out.print("" + "" + addons.get(i).getname()); } system.out.println(); system.out.println(""toplam fiyat: "" + calculateprice()); } public string getcoffename() { return ""espresso""; } } public class vanillasyrup implements coffeeaddon { public double getcost() { return 6.0; } public string getname() { return ""vanillasyrup""; } } interface coffeeaddon { double getcost(); string getname(); } import java.util.*; abstract class basecoffee { protected arraylist<coffeeaddon> addons; public basecoffee() { this.addons = new arraylist<coffeeaddon>(); } public void addaddon(coffeeaddon addon) { addons.add(addon); } public abstract double calculateprice(); public abstract string getcoffename(); public abstract void getcoffe(); } public class americano extends basecoffee { public americano() { super(); } public double calculateprice() { double res = 45; for(int i = 0; i < addons.size(); i++) { res = res + addons.get(i).getcost(); } return res; } public void getcoffe() { system.out.print(""siparişiniz: americano""); for(int i = 0; i < addons.size(); i++) { system.out.print("" + "" + addons.get(i).getname()); } system.out.println(); system.out.println(""toplam fiyat: "" + calculateprice()); } public string getcoffename() { return ""americano""; } } public class coffeemachine { private static int coffees = 0; public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) { if (((coffee instanceof espresso) && (adddon instanceof milk || adddon instanceof vanillasyrup)) || (coffee instanceof latte && adddon instanceof doubleshot) || ((coffee.getcoffename().equals(""americano"")) && (adddon instanceof chocolate || adddon instanceof doubleshot))) { system.out.println(""[uyari] "" + coffee.getcoffename() + "" kahveye "" + adddon.getname() + "" eklenemez.""); } else coffee.addaddon(adddon); } public void makecoffee(basecoffee coffee) { coffee.getcoffe(); addcoffe(); } public void heatespressocup(basecoffee coffee) { if (coffee instanceof espresso) { espresso a = (espresso) coffee; a.heatcup(); } else { system.out.println(""[uyari] yalnızca espresso kahve fincanları ısıtılabilir""); } } public static void numofcoffes() { system.out.println(""tüm kahve makinelerinde "" + coffees + "" üretilmiştir""); } public void addcoffe() { coffees++; } } public class milk implements coffeeaddon { public double getcost() { return 5.0; } public string getname() { return ""milk""; } } public class doubleshot implements coffeeaddon { public double getcost() { return 10.0; } public string getname() { return ""doubleshot""; } } public class chocolate implements coffeeaddon { public double getcost() { return 7.0; } public string getname() { return ""chocolate""; } } 1",35414,4579,640,227,68,25
6094496,2,"6094496 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. package lab1111; public class cocktailshaker { public static void main(string[] args) { int[] arr = {5, 4, 1, 2}; cocktailsort(arr); system.out.println(""ouput:""); printarray(arr); } public static void cocktailsort(int[] arr) { cocktailrecursive(arr, 0, arr.length - 1); } private static void cocktailrecursive(int[] arr, int baslangic, int bitis) { if (baslangic >= bitis) { return; } boolean changed = false; for (int i = baslangic; i < bitis; i++) { if (arr[i] > arr[i + 1]) { change(arr, i, i + 1); changed = true; } } if (!changed) { return; } changed = false; for (int i = bitis - 1; i > baslangic; i--) { if (arr[i] < arr[i - 1]) { change(arr, i, i - 1); changed = true; } } cocktailrecursive(arr, baslangic + 1, bitis - 1); } private static void change(int[] arr, int i, int j) { int x = arr[i]; arr[i] = arr[j]; arr[j] = x; } private static void printarray(int[] arr) { for (int num : arr) { system.out.print(num + "" ""); } system.out.println(); } } package lab1111; public class stringsay { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } package lab1111; public class sayac { private string string; public sayac(string string) { this.string = string; } public int say() { return sayacbir(string, string.length() - 1); } private int sayacbir(string string, int sira) { if (sira < 0) { return 0; } if (string.charat(sira) == '1') { return 1 + sayacbir(string, sira - 1); } else { return sayacbir(string, sira - 1); } } } package lab1111; public class lab1 { public static void main(string[] args) { int x = 7; system.out.println (collatz(x)); } public static int collatz(int i) { if (i == 1) { return 0; } if (i % 2 == 0) { return 1 + collatz(i / 2); } else { return 1 + collatz((3 * i) + 1); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 package lab1111; import java.util.list; public class muzikcalar { private calmastratejisi strateji; // çalma stratejisini ayarla public void setstrateji(calmastratejisi strateji) { this.strateji = strateji; } // seçilen stratejiye göre şarkıları çal public void muzikcal(list<sarki> sarkilistesi) { if (strateji != null) { strateji.cal(sarkilistesi); } else { system.out.println(""çalma stratejisi belirleyin!.""); } } } package lab1111; import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farklı türde şarkılar oluşturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykırı ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrümantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // şarkılar çalma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // müzik çalar nesnesi muzikcalar muzikcalar = new muzikcalar(); // sıralı çalma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karışık çalma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu özel çalma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal şarkıların özelliklerini göster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } } } } package lab1111; public class klasiksarki extends sarki{ private string klasikozellik = (""hafif ve sakin""); public klasiksarki(string isim, string sanatci) { super(isim, sanatci); } @override public void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" ("" + klasikozellik + "")""); } } package lab1111; public class metalsarki extends sarki{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(isim, sanatci); // sarki classından this.metalozellik = metalozellik; } public void gostermetalozellikleri() { system.out.println("" sanatci "" + sanatci +"" - "" + isim + "" ("" + metalozellik + "")""); } @override public void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } } package lab1111; public class rocksarki extends sarki { private string rockozellik = (""huzurlu ve nostaljik""); public rocksarki(string isim, string sanatci) { super(isim, sanatci); } @override public void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" ("" + rockozellik + "")""); } } package lab1111; import java.util.collections; import java.util.list; public class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { system.out.println(""şarkılar karışık bir şekilde çalınacak !""); collections.shuffle(sarkilistesi); for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } package lab1111; import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { system.out.println(""şarkılar sıralı bir şekilde çalacak!""); for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } package lab1111; public abstract class sarki { protected string isim; protected string sanatci; public sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } public abstract void oynat(); } package lab1111; import java.util.list; public class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { system.out.println(""rock şarkılar için özel şarkı listesi çalınacak!""); boolean isrock = false; for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki) { system.out.println(""ses seviyesi : yüksek""); sarki.oynat(); isrock = true; } else { if (isrock) { system.out.println(""ses seviyesi normale döndü""); } sarki.oynat(); isrock = false; } } } } package lab1111; import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } abstraction kavramını açıklayınız. javada tanımladığımız nesnelerin bazı özelliklerini gözardı etmemize abstraction denir. soyutlama da denir dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? - protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? protected java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? - java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? olabilir. bir classın iki tane parent classı olabilir java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? b a'nın parent classıdır veya base classıdır metot overriding ve overloading kavramlarını açıklayınız. - class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? 1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? static binding overloading; dynamic binding override zamanı kullanılır java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? static baktığımızda override edilemez. private kendi sınıfına özel o da override edilemez. final değiştirilemez o yüzden override edilemez. o yüzden static binding ile bağlanır overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloading yaparken static override yaparken dynamic bining dinamik bağlamada jvm'nin görevi nedir? nesnenin türünü belirlemek ve ona uygun metotu call etmek java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? upcast yapacağımızda daha genel bir şeye çeviriyoruz. down castte durum farklı. daha özel bir şeye çeviriyoruz. down castte implicit bir şekilde yapamayız java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? -- class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child dynamic bağlama ( override) class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product dinamik bağlama java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? javada abstract classlar hem gövdeli hem gövdesiz metodlar barındırabilir. concrete classların tüm metotların gövdesi olan tanımlanmış ve nesne oluşturabilen bir sınıftır. i̇nterfacelerin constructorları yoktur. çünkü nesne oluşturamazlar. abstract classların vardır abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? hayır edilemez. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. soyutluk sağlarlar. ortak özellikleri bir arada tutarlar. kendinden türetilen sınıfların farklılaşmasını kolaylaştırır. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? extends ve implents temel farklardır yani biri genişletmek biri ise uygulamak için kullanılır. tip olarak kullanılabilir ama referans görevi görür bizim için marker interface ve functional interface kavramları nedir, nasıl kullanılır? --- bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? bir class birden çok interfaceyi implement edebilir. bir interface başka bir interface i implent edemez extend edebilir. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? shape c = new circle(); yazsaydık düzelirdi hatadan sonra drawing circle displaying çıktısı alırız interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? hocam hatayı bulamadım ama çıktı a olur. bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true package lab1111; public class robot { private string name; private string type; private int batterylevel; // 0 ile 100 arasında bir değer private boolean isoperational; // bataryası varsa true public robot() { this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public robot(string name, string type, int batterylevel) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = true; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public boolean isoperational() { return isoperational; } public void setoperational(boolean operational) { this.isoperational = operational; } public void charge() { this.batterylevel = 100; } public void printrobot() { system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + "" isoperational: "" + isoperational); } } package lab1111; public class ana { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(r1); factory.printfactory(r2); factory.printfactory(r3); } } package lab1111; import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public void factory(string name, string location) { this.name = name; this.location = location; this.robots = new arraylist<robot>(); } public void factory() { this.name = ""factory1""; this.location = ""moon""; this.robots = new arraylist<>(); } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getlocation() { return location; } public void setlocation(string location) { this.location = location; } public arraylist<robot> getrobots() { return robots; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public void addrobot(robot robot) { robots.add(robot); // robots arrayine ekliyoruz } public void chargeallrobots(robot robot) { robot.charge(); } public void work(robot robot1) { int newbatterylevel = robot1.getbatterylevel() - 15; if (newbatterylevel < 0) { newbatterylevel = 0; // 0 ın altına inerse şarjı 0 döndürür } } public void printfactory(robot robot3) { system.out.println(""factory name: "" + name); system.out.println(""factory location: "" + location); system.out.println(""robots in factory:""); robot3.printrobot(); } } package lab1111; public class test { public static void kontrol(char[] a, int index) { if (index == a.length) { system.out.print(new string(a)); } char character = a[index]; if ((character >= 'a' && character <= 'z') || (character >= 'a' && character <= 'z')) { a[index] = character.tolowercase(character); //küçükse kontrol(a, index + 1); a[index] = character.touppercase(character); //büyükse kontrol(a, index + 1); } else { // rakamsa eğer devam eder kontrol(a, index + 1); } } public static void print(string str) { kontrol(str.tochararray(), 0); } public static void main(string[] args) { string s = ""a1b2""; print(s); } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 package lab1111; public interface withbattery { int getbatterylife(); // batarya ömrünü döndürür void recharge(); // bataryayı yeniler } package lab1111; public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public int getbatterylife() { return batterylife; } @override public void recharge() { this.batterylife = 100; system.out.println(modelname + "" recharged to full battery.""); } public abstract void performtask(); } package lab1111; public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\nrobot sayımızı gösteriyoruz""); anotherfactory.showrobotsayac(); // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } package lab1111; public class securityrobot extends abstractrobot { private boolean isarmed; //robotun silahlı olup olmadığını tutuyoruz public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } public boolean geti̇sarmed() { return isarmed; } @override public void performtask() { if(batterylife >= 10) { system.out.println(modelname + ""scanning for threats..."" + ""armed:"" + isarmed); batterylife = batterylife - 10; } else { system.out.println(modelname + ""not enough battery to scan threats...""); } } public void togglearmedmode() { isarmed = !isarmed; } } package lab1111; public class cleaningrobot extends abstractrobot{ private int cleaningpower; // robotun temizlik gücü public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } public int getcleaningpower() { return cleaningpower; } public void performtask() { if(batterylife >= 10) { system.out.println(modelname + "" cleaning in progress... cleaning power: "" + cleaningpower); batterylife = batterylife - 10; } else { system.out.println(modelname + "" not enough battery to scan threats...""); } } public void boostcleaningpower(int miktar) { this.cleaningpower += miktar; system.out.println(modelname + "" cleaning power boosted by "" + miktar); } } package lab1111; import java.util.arraylist; public class robotfactory { private static int robotsayac = 0; private arraylist<abstractrobot> robots; // üretilen robotları saklar public robotfactory() { this.robots = new arraylist<>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { cleaningrobot robot = new cleaningrobot(modelname, batterylife, cleaningpower); robots.add(robot); robotsayac++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed ) { securityrobot robot = new securityrobot(modelname, batterylife, isarmed); robots.add(robot); robotsayac++; } public void performalltasks() { for (abstractrobot robot : robots) { robot.performtask(); } } public void displayrobots() { for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot) { system.out.println(""cleaningrobot - model: "" + robot.getmodelname() + "", battery: "" + robot.getbatterylife() + "", cleaning power: "" + ((cleaningrobot) robot).getcleaningpower()); } else if (robot instanceof securityrobot) { system.out.println(""securityrobot model: "" + robot.getmodelname() + "", battery: "" + robot.getbatterylife() + "", armed: "" + ((securityrobot) robot).geti̇sarmed()); } } } public void upgradecleaningrobots(int miktar) { for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot) { ((cleaningrobot) robot).boostcleaningpower(miktar); } } } public void togglesecurityrobotsmode() { for (abstractrobot robot : robots) { if (robot instanceof securityrobot) { ((securityrobot) robot).togglearmedmode(); } } } public void showrobotsayac() { system.out.println(""tüm fabrikalar tarafından toplam"" + robotsayac + "" robot üretildi""); } } //+ ((securityrobot) robot).isarmed 2",35275,4591,672,215,43,42
7732416,1,"7732416 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1 { public static void main(string[] args) { system.out.println(collatz(5)); system.out.println(); sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); system.out.println(); int[] ornek = {5,4,1,2} ; cocktailsort(ornek); for (int arrs : ornek){ system.out.println(arrs); } } public static int collatz(int i){ if (i == 1){ return 0 ; } if (i % 2 == 0){ return 1 + collatz(i/2); } return 1 + collatz(3*i + 1); } public static void cocktailsort(int[] arr){ int direction = 1 ; for (int i = 0; i < arr.length; i++) { if (i%2 == 0) direction = 1 ; else direction = -1 ; ekstra(arr,direction); } } private static void ekstra(int[] arr, int direction){ if (direction == 1) { for (int i = 0, j = 1; j < arr.length; i++, j++) { if (arr[i] > arr[j]){ int temp = arr[i] ; arr[i] = arr[j] ; arr[j] = temp ; } } } if (direction == -1){ for (int i = arr.length-2, j = arr.length-1; i > 0 ; i--, j--) { if (arr[i] > arr[j]){ int temp = arr[i] ; arr[i] = arr[j] ; arr[j] = temp ; } } } } } public class sayac { string s ; public sayac(string s) { this.s = s; } public int say(){ return yardimci(this.s.length()-1,this.s); } private static int yardimci(int index, string s){ if (index == 0){ if (s.charat(index) == '1'){ return 1; } return 0 ; } if (s.charat(index)== '1'){ return 1 + yardimci(index-1,s); } return yardimci(index-1,s); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { private calmastratejisi strateji; void setstrateji(calmastratejisi s){ strateji = s; } void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki){ metalsarki m = (metalsarki)sarki; m.gostermetalozellikleri(); } } } } public class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci) { this.setisim(isim); this.setsanatci(sanatci); } @override void oynat() { system.out.println(""[klasik] "" + getsanatci() +"" - "" + getisim() + ""(hafif ve sakin)""); } } public class metalsarki extends sarki{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { this.setisim(isim); this.setsanatci(sanatci); this.metalozellik = metalozellik; } void gostermetalozellikleri(){ system.out.println(getsanatci() + "" - "" + getisim() + ""[özellik: "" + metalozellik + ""]""); } @override void oynat() { system.out.println(""[metal] "" + getsanatci() +"" - "" + getisim() + ""("" + metalozellik+ "")""); } } public class rocksarki extends sarki{ public rocksarki(string isim, string sanatci) { this.setisim(isim); this.setsanatci(sanatci); } @override void oynat() { system.out.println(""[rock] "" +getsanatci() +"" - "" + getisim() + ""(huzurlu ve nostaljik)""); } } import java.util.arraylist; import java.util.list; import java.util.collections; public class karisikcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { list<integer> numbers = new arraylist<>(); for (int i = 0 ; i < sarkilistesi.size() ; i++){ numbers.add(i); } collections.shuffle(numbers); for (int index : numbers) { sarkilistesi.get(index).oynat(); } } } import java.util.list; public class siralicalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } abstract class sarki { private string isim ; private string sanatci ; abstract void oynat(); public string getisim() { return isim; } public string getsanatci() { return sanatci; } public void setisim(string isim) { this.isim = isim; } public void setsanatci(string sanatci) { this.sanatci = sanatci; } } import java.util.list; public class rockcuozelcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof rocksarki){ if ((i > 0) && !(sarkilistesi.get(i-1) instanceof metalsarki)){ system.out.println(""[bilgi] ses duzeyi: yuksek""); } } if (!(sarkilistesi.get(i) instanceof metalsarki)){ if ((i > 0) && (sarkilistesi.get(i-1) instanceof metalsarki)){ system.out.println(""[bilgi] ses duzeyi: normal""); } } sarkilistesi.get(i).oynat(); } } } import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } ""recursion"" kavramı nedir, kısaca açıklayınız. bir metodun kendisini çağırmasıdır recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. 3 kısımdan oluşur. base case , composition, decomposition jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. metod her çağırıldığında stack frame eklenir int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. hız anlamında daha az verimlidir. recursive metotlar daha fazla yer kaplar ve daha yavaştır bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? base case substringin boyutunun 0 olduğu noktadır. geri kalan durumlarda ise stringin ilk elemanı alınır ve geri kalan kısmının reverse esilmiş halinin üstüne eklenir. stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack local variable ları sakladığımız alan. eğer stackin alabileceğinden daha fazla stack call yapılırsa stack taşar tail recursion nedir, kısaca açıklayınız. recursive bir metoddaki returnler sonrası ekstra bir işlem yapılmaması ile olur. en son tail kısımda sonuç dönülür abstraction kavramını açıklayınız. abstraction gerçek hayat problemlerinin soyutlanması. yani dijitalde temsil etmemiz. sınıfları ise contexte göre bilgileri gösterecek şekilde tasarlamamız dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür çünkü hourly employee i̇s a employee. fakat tam tersi olamaz çünkü employee bir hourly employee değildir protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? default daha yakındır çünkü erişebilen sınıf sayısı protected a göre daha sınırlı (subclasslar erişemiyor) java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? çünkü üst sınıfın özellikleri doldurulmalıdır. en önce üst sınıf şeklinde yaratılıp sonra özellikler eklenir java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? edemez çünkü başka sınıflarda metot veya variable isimleri aynıysa bu karışıklığa sebebiyet verir java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? subclass olup olmamasını kontrol eder. a, b nin subclassı dır metot overriding ve overloading kavramlarını açıklayınız. overriding alt sınıfta üst sınıfın metodunu tekrar tanımlamaya denir ve signature aynıdır. overloading ise aynı isimli metotların farklı parametrelere sahip olmasıdır. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? base 1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? parent 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? static bindind compilerın işlemi yapmayı bildiği durumlarda yani hangi metodun kullanılabileceğini bildiğimiz durumda dynamic ise polymorphism gibi sonradan bakmamız gereken durumlarda kullanılır java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? çünkü en baştaki durumların sonradan değiştirilmesi istenmiyor veya ulaşılmasıyla alakalı kısıtlamaları var. dolasıyı ile mekanizmada sonradan karar verilecek bir durumları yok. ortak özellikleri ise override edilememeleri overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloading dynamic overriding ise static yapılır override mekanizmasında objenin polymorphism özellikleri olmasından kaynaklı sonradan karar verilir fakat overloading de her şey önceden bellidir dinamik bağlamada jvm'nin görevi nedir? . java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? çünkü is a bağlantısı vardır. down casting implicit yapılamaz çünkü triangle is a shape ama a shape is not a triangle java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? daha önceden belirlenmemiş bilgiler kullanılamazdı class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik çünkü p referansının p mi yoksa onun child sınıfını mı barındırdığını runtime da bilebiliyoruz class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik çünkü display metodunun hangisinin çağrılacağı aslında item objesinin gerçek tipine bağlı java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class objesi yaratılamayan bir sınıftır içinde abstract ya da değil metotlar bulundurabilir. constructor sahibi olabilirler çünkü alt sınıfların constructor ı çağırması gerekebilir abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? implement edildiyse zaten abstract değildir. ama abstract bir sınıfın içinde abstract olmayan bir metot bulunabilir abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. obje yaratmadan sınıf yaratma. signature belirleyip hiyerarşinin ilerisinde implement etme özgürlüğü. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract sınıflar abstraction seviyesi 0 ile 100 arasında iken interfacelerde 100 dür. tip olarak kullanılabilirler marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface ler metot veya fieldları olmayan interfaceler. functional interfaceler ise sadece bir abstract metodu olan interfacelerdir bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? class birden fazla implement edebilir fakat bir interface başka bir interface i implement etmez extend eder. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? c objesi yaratılamaz abstract class olduğu için. ya sınıfı ve draw metodunu abstract den çıkartacağız ya da alt bir sınıfın objesini kullanacağız interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? i̇ki tane aynı isimli metod ve farklı interfacelerden geliyorlar. kesinlilik yok bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot { private string name ; private string type; private int batterylevel ; private boolean isoperational ; public robot(string name, string type, int batterylevel, boolean isoperational) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = isoperational; } public robot() { this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public void charge(){ this.batterylevel = 100 ; } public void printrobot(){ system.out.println(""robot name: "" + this.name + "" robot type: "" + this.type + "" battery level: "" + this.batterylevel + ""% is operationalt: "" + this.isoperational); } public string getname() { return name; } public string gettype() { return type; } public int getbatterylevel() { return batterylevel; } public boolean isoperational() { return isoperational; } public void setname(string name) { this.name = name; } public void settype(string type) { this.type = type; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public void setoperational(boolean operational) { isoperational = operational; } } import java.lang.module.findexception; import java.net.bindexception; public class q1 { public static void main(string[] args) { string str = ""a1b2"" ; system.out.println(kombinasyon(str, 0, str)); } public static string kombinasyon(string s, int index, string modified){ if (index == s.length()-1){ return modified + olustur(s,index) ; } return kombinasyon(s,index + 1, modified + olustur(s, index) + boundcontrol(olustur(s, index),index)); } private static string olustur(string s, int index){ if ((s.charat(index) >= 65) && (s.charat(index) <= 90)){ return "" "" + s.substring(1,index) + (char)(s.charat(index)+32) + s.substring(index+1); } if ((s.charat(index) >= 97) && (s.charat(index) <= 122)){ return "" "" + s.substring(0,index) + (char)(s.charat(index)-32) + s.substring(index+1); } return """" ; } private static string boundcontrol(string s, int index){ if (index < s.length()-1){ return """" ; } return """" ; } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots = new arraylist<>(); public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55, true); robot r3 = new robot(""r2-d2"", ""astromech"", 80, true); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } public factory(string name, string location) { this.name = name; this.location = location; } public factory() { this.name = ""factory1""; this.location = ""moon"" ; } public void addrobot(robot robot){ robots.add(robot); } public void chargeallrobots(){ for (int i = 0; i < robots.size(); i++) { robots.get(i).charge(); } } public void printfactory(){ system.out.println(""factory name: "" + this.name + "" location: "" + this.location); system.out.println(""robots operating here:""); for (int i = 0; i < robots.size(); i++) { robots.get(i).printrobot(); } } public void work(){ for (int i = 0; i < robots.size(); i++) { robots.get(i).setbatterylevel(robots.get(i).getbatterylevel() - 15); } } public string getname() { return name; } public string getlocation() { return location; } public arraylist<robot> getrobots() { return robots; } public void setname(string name) { this.name = name; } public void setlocation(string location) { this.location = location; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; public static int toplamroboturetimi; public abstract void performtask(); public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public static int gettoplamroboturetimi() { return toplamroboturetimi; } } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.totalrobots(); } } public class securityrobot extends abstractrobot{ private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; toplamroboturetimi++; } public void togglearmedmode(){ if (isarmed) { isarmed = false; system.out.println(""securityrobot - "" + modelname + "" is now unarmed""); }else { isarmed = true; system.out.println(""securityrobot - "" + modelname + "" is now armed""); } } @override public void performtask() { if (batterylife >= 10){ system.out.println(""[""+ modelname +""] scanning for threats... armed: "" + isarmed ); this.batterylife -= 10; }else{ system.out.println(""[""+ modelname +""] not enough battery to scan threats...""); } } @override public int getbatterylife() { return this.batterylife; } @override public void recharge() { batterylife += 10; } public boolean isarmed() { return isarmed; } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; toplamroboturetimi++; } public void boostcleaningpower(int miktar){ cleaningpower += miktar; system.out.println(""cleaningrobot - ""+ modelname +"" now has cleaning power: ""+ cleaningpower); } @override public void performtask() { if (batterylife >= 10){ system.out.println(""[""+ modelname +""] cleaning in progress... cleaning power: "" + cleaningpower ); this.batterylife -= 10; }else{ system.out.println(""[""+ modelname +""] not enough battery to clean...""); } } @override public int getbatterylife() { return this.batterylife; } @override public void recharge() { batterylife += 10; } public int getcleaningpower() { return cleaningpower; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ robots.add(new securityrobot(modelname, batterylife, isarmed)); } public void performalltasks(){ for (abstractrobot robot : robots){ robot.performtask(); } } public void displayrobots(){ for (abstractrobot robot : robots){ if (robot instanceof cleaningrobot){ cleaningrobot a = (cleaningrobot) robot; system.out.println(""cleaningrobot - model: "" + a.getmodelname() + "", battery: "" + a.getbatterylife() + "", cleaning power: "" + a.getcleaningpower()); } if (robot instanceof securityrobot){ securityrobot b = (securityrobot) robot; system.out.println(""securityrobot - model: "" + b.getmodelname() + "", battery: "" + b.getbatterylife() + "", armed: "" + b.isarmed()); } } } public void upgradecleaningrobots(int miktar){ for (abstractrobot robot : robots){ if (robot instanceof cleaningrobot){ cleaningrobot a = (cleaningrobot) robot; a.boostcleaningpower(miktar); } } } public void togglesecurityrobotsmode(){ for (abstractrobot robot : robots){ if (robot instanceof securityrobot){ securityrobot a = (securityrobot) robot; a.togglearmedmode(); } } } public static void totalrobots(){ system.out.println( ""tum fabrikalar tarafindan toplam ""+ abstractrobot.gettoplamroboturetimi() +"" robot uretildi""); } } 1",37017,4756,669,214,42,26
2384475,1,"2384475 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q2 { public static void main(string[] args) { int arr[] = { 5, 4, 1, 2 }; cocktailsort(arr, true); for (int i = 0; i < arr.length; i++) { system.out.println(arr[i]); } } public static void cocktailsort(int[] arr, boolean x) { for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } if (arr.length < 2) return; { if (x) { arr = bubble1(arr); x = false; } else { arr = bubble2(arr); x = true; } cocktailsort(arr, x); } } public static int[] bubble1(int[] arr) { int newarr[] = new int[arr.length - 1]; for (int i = 0; i < arr.length - 1; i++) { newarr[i] = arr[i]; } for (int i = 0; i < newarr.length - 1; i++) { if (newarr[i] > newarr[i + 1]) { int temp = newarr[i]; newarr[i] = newarr[i + 1]; newarr[i + 1] = temp; } } return newarr; } public static int[] bubble2(int[] arr) { int newarr[] = new int[arr.length - 1]; for (int i = 0; i < arr.length - 1; i++) { newarr[i] = arr[i]; } for (int i = newarr.length - 1; i > 0; i--) { if (newarr[i] < newarr[i - 1]) { int temp = newarr[i]; newarr[i] = newarr[i - 1]; newarr[i - 1] = temp; } } return newarr; } } public class lab1q1 { public static void main(string[] args) { system.out.println(collatz(2)); } public static int collatz(int i) { int count = 0; if (i == 1) return count; if (i % 2 == 0) count = 1 + collatz(i / 2); else if (i % 2 == 1) count = 1 + collatz(i * 3 + 1); return count; } } class sayac { public string x; public sayac(string x) { this.x = x; } public int say() { int res = say2(x); return res; } public int say2(string x) { int res = 0; if (x.length() < 1) return res; if (x.charat(0) != '1') { res = res + say2(x.substring(1)); } else if (x.charat(0) == '1') res = res + 1 + say2(x.substring(1)); return res; } public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; import java.util.*; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { metalsarki met = (metalsarki) sarki; system.out.println(sarki.sanatci + ""-"" + sarki.isim + "" [ozellik: "" + met.metalozellik + ""]""); } // bu kismi cikti ornegini saglayacak sekilde doldurun } } } abstract class sarki { string isim; string sanatci; sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } abstract void oynat(); } class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { super(isim, sanatci); this.metalozellik = metalozellik; } @override void oynat() { } void gostermetalozellikleri() { system.out.println(metalozellik); } } class rocksarki extends sarki { string rocko; rocksarki(string isim, string sanatci) { super(isim, sanatci); this.rocko = ""huzurlu ve nostaljik""; } @override void oynat() { } } class klasiksarki extends sarki { string klasiko; klasiksarki(string isim, string sanatci) { super(isim, sanatci); this.klasiko = ""hafif ve sakin""; } @override void oynat() { } } interface calmastratejisi { void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki) { rocksarki r = (rocksarki) sarki; system.out.println( ""[rock] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + r.rocko + "")""); } else if (sarki instanceof metalsarki) { metalsarki met = (metalsarki) sarki; system.out.println(""[metal] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + met.metalozellik + "")""); } else if (sarki instanceof klasiksarki) { klasiksarki k = (klasiksarki) sarki; system.out.println( ""[klasik] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + k.klasiko + "")""); } } } } class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { // karısık calma yapamadım :( tersten caldırdım. sarkilistesi = sarkilistesi.reversed(); for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki) { rocksarki r = (rocksarki) sarki; system.out.println( ""[rock] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + r.rocko + "")""); } else if (sarki instanceof metalsarki) { metalsarki met = (metalsarki) sarki; system.out.println(""[metal] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + met.metalozellik + "")""); } else if (sarki instanceof klasiksarki) { klasiksarki k = (klasiksarki) sarki; system.out.println( ""[klasik] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + k.klasiko + "")""); } } } } class rockcuozelcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki) { rocksarki r = (rocksarki) sarki; system.out.println(""[bilgi] ses duzeyi : yuksek""); system.out.println( ""[rock] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + r.rocko + "")""); system.out.println(""[bilgi] ses duzeyi : normal""); } else if (sarki instanceof metalsarki) { metalsarki met = (metalsarki) sarki; system.out.println(""[metal] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + met.metalozellik + "")""); } else if (sarki instanceof klasiksarki) { klasiksarki k = (klasiksarki) sarki; system.out.println( ""[klasik] "" + sarki.sanatci + "" - "" + sarki.isim + ""("" + k.klasiko + "")""); } } } } class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { this.strateji = s; } void muzikcal(list<sarki> sarkilistesi) { if (strateji instanceof siralicalma) { strateji.cal(sarkilistesi); } else if (strateji instanceof karisikcalma) { strateji.cal(sarkilistesi); } else if (strateji instanceof rockcuozelcalma) { strateji.cal(sarkilistesi); } } } abstraction kavramını açıklayınız. i̇htiyacımız olan şeylerin dışındakileri yok saymaktır. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür cünkü hourlye is a e ama tam tersi degil cunku e is not a hourlye. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? package access daha yakındır. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? üst classların instance variablelarını parametre olarak gecirmek icin. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır,mümkün değil. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? verilen objenin bizim istedigimiz türden bir obje olup olmadigini kontrol eder. b objesi a objesiyle ayni class a aittir. metot overriding ve overloading kavramlarını açıklayınız. overriding signature ı aynı olan metotlar icin kullanılır. overlode ismi aynı ama parametreleri farkli metotlar icin kullanilir. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? 10 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? signatureları farklı olan methodlarda static binding aynı olanlarda dynamic binding kullanılır. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? bu metotlar değiştirilemez ve override edilemez. bu yüzden static bindingle bağlanır. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloadingde static binding overridingde dynamic binding gerçekleşir. dinamik bağlamada jvm'nin görevi nedir? run time sırasında karar verir. java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? ana classın referans variable ı alt classın objesini refer ettiği için. downcast implicit yapılamaz. typecating ile yapılır. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? run time sırasında vakit kaybederdik. class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child dinamik bağlama class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book dinamik bağlama java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? i̇çinde abstract method(implement edilmemis) bulunduran ya da bulundarmayan classlardır. abstract classlarda constructur olabilir.interfacde olamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? bir abstract classın methodu başka bir abstract classda implement edilebilir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. daha sonra kesin olarak implement edileceğini bildiğimiz bir methodu tanımlamamızı sağlar. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interfaceler class değil bir tiptir. abstract classlardan obje üretilmez. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interfacelerin içi boştur. functionallarda implement edilmeyi bekleyen methodlar vardır. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? classlar birden fazla interface implement edebilir. i̇nterface başka bir interfacei extend edebilir. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abstract classtan obje üretilmez. shape c = new circle(); olmalı drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? edilemez çünkü hangisini çalıştiracagıni bilemez. super olmamalıydı. new b().show; yapabiliriz. output: b java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 2 çeşittir. io ve runtime exception java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? trowable olmak zorundadır ve override edildiğinde kendisi ve subclassları throws edilebilir. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? her koşulda kod bloğunu çalıştırır. exception atılıp atılmaması önemli değildir. java'da kendi exceptionunuzu nasıl tanımlarsınız? i̇stediğimiz türdeki exception classını extend ederiz ve şu koşul gerçekleşirse exception fırlat deriz. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? . static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done -1 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? normalde specific olandan olmayana doğru catch ederiz ama böylede çalışır trying m1 caught2 finally bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class quiz1q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55, true); robot r3 = new robot(""r2-d2"", ""astromech"", 80, true); int i = 0; factory.addrobot(r1, i++); factory.addrobot(r2, i++); factory.addrobot(r3, i++); factory.printfactory(); } } class factory { private string name; private string location; private robot[] robots = new robot[100]; public factory(string name, string location) { this.name = name; this.location = location; } public factory() { this.name = ""factory1""; this.location = ""moon""; } public void addrobot(robot robot, int index) { robots[index] = robot; } public void chargeallrobots() { for (int i = 0; i < robots.length; i++) { robots[i].charge(); } } public void printfactory() { system.out.println(""factory name: "" + getname1() + "" location: "" + getlocation1()); for (int i = 0; i < robots.length; i++) { if (robots[i] != null) system.out.println("" robot name: "" + robots[i].getname() + "" robot type: "" + robots[i].gettype() + "" battery level: "" + robots[i].getbattery() + "" is operational: "" + robots[i].getopera()); } } public void work() { for (int i = 0; i < robots.length; i++) { int x = robots[i].getbattery() - 15; system.out.println(x); } } public string getname1() { return name; } public string getlocation1() { return location; } } class robot { private string name; private string type; private int batterylevel; // 100 ile 0 arasında bir değer private boolean isoperational;// bataryası varsa true robot() { this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } robot(string name, string type, int batterylevel, boolean isoperational) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = isoperational; } public void charge() { batterylevel = 100; } public void printrobot() { system.out.println(); } public string getname() { return name; } public string gettype() { return type; } public int getbattery() { return batterylevel; } public boolean getopera() { return isoperational; } } public class quiz1q1 { public static void main(string[] args) { string x = ""a1b2""; string[] ar = method(x); for (int i = 0; i < ar.length; i++) { system.out.println(ar[i]); } } public static string[] method(string x) { x = x.touppercase(); string[] arr = new string[2 ^ (x.length() / 2)]; for (int i = 0; i < arr.length; i++) { arr[i] = x.substring(0, i) + x.substring(i).tolowercase(); } return arr; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 package robot; public interface withbattery { int getbatterylife(); void recharge(); } package robot; public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public abstract void performtask(); public int getbatterylife() { return batterylife; } public void recharge() { final int temp = batterylife; this.batterylife = temp; system.out.println(batterylife); } } package robot; public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.robotnumber(); // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } package robot; public class securityrobot extends abstractrobot { private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } @override public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] scanning for threats... armed:"" + isarmed); batterylife = batterylife - 10; } else { system.out.println(""["" + modelname + ""] not enough battery to scan threats...""); } } public void togglearmedmode() { isarmed = !isarmed; } public boolean getisarmed() { return isarmed; } } package robot; public class cleaningrobot extends abstractrobot { private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } @override public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] cleaning in progress... cleaning power:"" + cleaningpower); batterylife = batterylife - 10; } else { system.out.println(""["" + modelname + ""] not enough battery to clean...""); } } public void boostcleaningpower() { cleaningpower = cleaningpower + 10; } public int getcleaningpower() { return cleaningpower; } } package robot; import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; static int number; robotfactory() { robots = new arraylist<abstractrobot>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { cleaningrobot x = new cleaningrobot(modelname, batterylife, cleaningpower); number++; robots.add(x); } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { securityrobot x = new securityrobot(modelname, batterylife, isarmed); number++; robots.add(x); } public void performalltasks() { for (abstractrobot r : robots) { r.performtask(); } } public void displayrobots() { for (abstractrobot r : robots) { if (r instanceof cleaningrobot) { cleaningrobot x = (cleaningrobot) r; system.out.println(""- model: "" + x.modelname + "", battery: "" + x.batterylife + "", cleaning power: "" + x.getcleaningpower()); } else if (r instanceof securityrobot) { securityrobot x = (securityrobot) r; system.out.println( ""- model: "" + x.modelname + "", battery: "" + x.batterylife + "", armed: "" + x.getisarmed()); } } } public void upgradecleaningrobots(int miktar) { for (abstractrobot r : robots) { if (r instanceof cleaningrobot) { cleaningrobot x = (cleaningrobot) r; x.boostcleaningpower(); system.out .println(""cleaningrobot - "" + x.modelname + "" now has cleaning power: "" + x.getcleaningpower()); } } } public void togglesecurityrobotsmode() { for (abstractrobot r : robots) { if (r instanceof securityrobot) { securityrobot x = (securityrobot) r; x.togglearmedmode(); system.out.print(""securityrobot - "" + x.modelname + "" is now ""); if (x.getisarmed()) { system.out.println(""armed""); } else { system.out.println(""unarmed""); } } } } public static void robotnumber() { system.out.println(""tum fabrikalar tarafindan toplam "" + number + "" robot uretildi""); } } 1",37038,4957,668,211,43,32
2786122,5,"2786122 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class q2 { public static void main(string[] args) { int[] arr = {5,4,1,2}; coctailsort(arr); } public static void coctailsort(int[] arr){ int count = 1; int a = 0; int b = arr.length; int[] arrmin = arr; for(int x = 0; x < arrmin.length; x++){ for(int y = 0; y < arrmin.length - 1;y++){ if(arrmin[y] > arrmin[y + 1]){ int temp = arrmin[y]; arrmin[y] = arrmin[y + 1]; arrmin[y + 1] = temp; } } } int min = arrmin[0]; int index; if(count % 2 == 0){ index = a; a++; } else{ index = b; b--; } for(int x = index; x < arr.length - 1; x++){ if(arr[x] > arr[x + 1]){ int temp = arr[x]; arr[x] = arr[x + 1]; arr[x + 1] = temp; } } for(int x = 0; x < arr.length;x++){ system.out.print("" "" + arr[x]); } system.out.println(); if(arr[0] != min){ for(int x = arr.length - 2; x > 0; x--){ if(arr[x] < arr[x - 1]){ int temp = arr[x - 1]; arr[x - 1] = arr[x]; arr[x] = temp; } } if(arr[0] != min){ coctailsort(arrmin); count++; } } } } public class q1 { public static void main(string[] args) { system.out.println(collatz(4)); } public static int collatz(int i){ int a = 0; if(i == 1){ return a; } else{ if(i % 2 == 0){ a++; return a + collatz(i / 2); } else{ a++; return a + collatz(i * 3 + 1); } } } } public class sayac { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } string str; public sayac(string str){ this.str = str; } public int say(){ int a = 0; if(str.length() == 1){ if(str.charat(0) == '1') a++; return a; } else{ if(str.endswith(""1"")) a++; str = str.substring(0,str.length() - 1); return a + say(); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s){ this.strateji = s; } void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki.getclass().getname() == ""metalsarki""){ system.out.print(sarki.sanatci + "" - "" + sarki.isim + "" [ozellik: ""); metalsarki s = (metalsarki) sarki; s.gostermetalozellikleri(); system.out.print(""]""); system.out.println(); } } } } public class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci) { super(isim, sanatci); } @override void oynat() { system.out.print(""[klasi̇k] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } public class metalsarki extends sarki { string metalozellik; string nitelik; metalsarki(string isim, string sanatci, string metalozellik) { super(isim, sanatci); this.metalozellik = metalozellik; } void gostermetalozellikleri(){ system.out.print(metalozellik); } @override void oynat() { system.out.print(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } } public class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { super(isim, sanatci); } @override void oynat() { system.out.print(""[rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } import java.util.list; import java.util.random; public class karisikcalma implements calmastratejisi { int count; @override public void cal(list<sarki> sarkilistesi) { random random = new random(); while(count < sarkilistesi.size()){ int x = random.nextint(sarkilistesi.size()); sarkilistesi.get(x).oynat(); count += 1; system.out.println(); } } } import java.util.list; public class siralicalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); system.out.println(); } } } public abstract class sarki { string isim; string sanatci; public sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat(){ } } import java.util.list; public class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean d = false; for (int i = 0; i < sarkilistesi.size(); i++) { string str = sarkilistesi.get(i).getclass().getname(); if(str == ""rocksarki"" && d == false){ system.out.println(""[bilgi] ses duzeyi: yuksek""); d = true; } if(d == true && str != ""rocksarki"") system.out.println(""[bilgi] ses duzeyi: normal""); sarkilistesi.get(i).oynat(); system.out.println(); } } } import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public robot(){ name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } public robot(string name,string type,int batterylevel){ this.name = name; this.type = type; this.batterylevel = batterylevel; isoperational = true; } public void charge() { this.batterylevel = 100; } public void printrobot() { system.out.println(""robot name: "" + getname()); system.out.println(""robot type: "" + gettype()); system.out.println(""battery level: "" + getbatterylevel()); system.out.println(""is operational: "" + getisoperational()); } public void setname(string name) { this.name = name; } public void settype(string type) { this.type = type; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public void setisoperational(boolean isoperational) { this.isoperational = isoperational; } public string getname() { return name; } public string gettype() { return type; } public int getbatterylevel() { return batterylevel; } public boolean getisoperational() { return isoperational; } } public class q1 { public static void main(string[] args) { string str = ""a1b2""; char[] harfler = new char[str.length()]; int harfcount = 0; char[] diger = new char[str.length()]; for(int x = 0; x < str.length(); x++) { int asci = str.charat(x); if(asci >= 65 && asci <= 97+32) { harfler[x] = str.charat(x); harfcount++; } else diger[x] = str.charat(x); } int dongucount = (int)math.pow(2, harfcount); boolean a = false; for(int x = 0; x < dongucount; x++) { for(int y = 0; y < str.length(); y++) { if(harfler[y] >= 65 && harfler[y] <= 97+32){ if(x >= dongucount/2 && a == false) { system.out.print((char)(harfler[y] - 32)); a = true; } else system.out.print(harfler[y]); } else system.out.print(diger[y]); } system.out.println(); a = false; } } } import java.util.arraylist; class factory extends robot{ private string name; private string location; private arraylist<robot> robots; public factory() { name = ""factory1""; location = ""moon""; } public factory(string name, string location) { this.name = name; this.location = location; this.robots = null; } public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for(int x = 0; x < robots.size(); x++) { robots.get(x).charge(); } } public void work() { for(int x = 0; x < robots.size(); x++) { robots.get(x).setbatterylevel(robots.get(x).getbatterylevel() - 15); } } public void printfactory() { system.out.println(""factory name: "" + getname()); system.out.println(""location: "" + getlocation()); system.out.println(""robots operating here:""); for(int x = 0; x < robots.size(); x++) { robots.get(x).printrobot(); } } public void setname(string name) { this.name = name; } public void setlocation(string location) { this.location = location; } public string getname() { return name; } public string getlocation() { return location; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""produced robots:""); factory.displayrobots(); system.out.println(""performing all robot tasks:""); factory.performalltasks(); system.out.println(""upgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""toggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""final robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(); factory.robotcount(); } } public class securityrobot extends abstractrobot{ private boolean isarmed; private int yedekbatterylife; public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; this.yedekbatterylife = batterylife; } public void performtask() { if(batterylife >= 10){ system.out.println(""["" + modelname + ""] scanning for threats... armed: "" + isarmed); batterylife -= 10; } else system.out.println(""["" + modelname + ""] not enough battery to scan threats...""); } public void togglearmedmode() { isarmed = !isarmed; if(isarmed == true) system.out.println(""armed""); else system.out.println(""unarmed""); } @override public int getbatterylife() { return batterylife; } @override public void recharge() { batterylife = yedekbatterylife; } public boolean isarmed() { return isarmed; } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; private int yedekbatterylife; public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; this.yedekbatterylife = batterylife; } public void performtask() { if(batterylife >= 10){ system.out.println(""["" + modelname + ""] cleaning in progress... cleaning power: "" + cleaningpower); batterylife -= 10; } else system.out.println(""["" + modelname + ""] not enough battery to clean...""); } public void boostcleaningpower(int miktar) { system.out.println(cleaningpower += miktar); } @override public int getbatterylife() { return batterylife; } @override public void recharge() { batterylife = yedekbatterylife; } public int getcleaningpower() { return cleaningpower; } } import java.util.arraylist; public class robotfactory { private arraylist <abstractrobot> robots = new arraylist<>(); private static int count = 0; public void producecleaningrobot(string modelname,int batterylife, int cleaningpower) { cleaningrobot r1 = new cleaningrobot(modelname,batterylife,cleaningpower); robots.add(r1); setcount(count + 1); } public void producesecurityrobot(string modelname,int batterylife, boolean isarmed) { securityrobot r1 = new securityrobot(modelname,batterylife,isarmed); robots.add(r1); setcount(count + 1); } public void performalltasks() { for (int x = 0; x < robots.size(); x++) { robots.get(x).performtask(); } } public void displayrobots() { for (int x = 0; x < robots.size(); x++) { system.out.print(robots.get(x).getclass().getname() + "" - model: "" + robots.get(x).modelname + "", battery: "" + robots.get(x).batterylife + "", ""); if(robots.get(x).getclass().getname() == ""cleaningrobot""){ cleaningrobot c1 = (cleaningrobot) robots.get(x); system.out.println(""cleaning power: "" + c1.getcleaningpower()); } else{ securityrobot s1 = (securityrobot) robots.get(x); system.out.println(""armed: "" + s1.isarmed()); } } } public void upgradecleaningrobots(int miktar) { for (int x = 0; x < robots.size(); x++) { if(robots.get(x).getclass().getname() == ""cleaningrobot""){ cleaningrobot c1 = (cleaningrobot) robots.get(x); system.out.print(c1.getclass().getname() + "" - model: "" + c1.modelname + "" now has cleaning power: ""); c1.boostcleaningpower(miktar); } } } public void togglesecurityrobotsmode() { for (int x = 0; x < robots.size(); x++) { if(robots.get(x).getclass().getname() == ""securityrobot""){ securityrobot s1 = (securityrobot) robots.get(x); system.out.print(s1.getclass().getname() + "" - model: "" + s1.modelname + "" is now ""); s1.togglearmedmode(); } } } public int getcount() { return robotfactory.count; } public void setcount(int count) { robotfactory.count = count; } public void robotcount() { system.out.println(""tum fabrikalar tarafindan toplam "" + getcount() + "" robot uretildi""); } } 5",28938,3700,516,173,23,23
9367691,6,"9367691 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. import java.util.scanner; public class collatz { public static void main(string[] args){ scanner input= new scanner(system.in); system.out.println(""enter a number :""); int i= input.nextint(); int result= collatz.collatz(i); system.out.println(""result = ""+ result); } public static int collatz(int i){ if(i==1){ return 0; } else if(i%2==0){ i=i/2; return collatz(i)+1; } else{ i=(3*i+1); return collatz(i)+1; } } } public class count { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); } } public class sayac{ string str; public sayac(string str){ this.str=str; } public int say(){ if(str.indexof(""1"")==-1){ return 0; } str=str.substring(str.indexof(""1"")+1,str.length()); return say()+1; } } public class cocktail { public static void main(string[] args) { int[] array= {5,4,1,2}; cocktailsort(array); } public static void cocktailsort(int[] arr){ boolean control=true; for(int i=0; i<arr.length-1; i++){ if(arr[i]>arr[i+1]){ control=false; } } if(control){ for(int i=0; i<arr.length; i++){ system.out.print("" ""+arr[i]); } } else{ for(int i=0; i<arr.length-1; i++){ if(arr[i]>arr[i+1]){ int tut=arr[i+1]; arr[i+1]=arr[i]; arr[i]=tut; } } cocktailsort(arr); } } } ""recursion"" kavramı nedir, kısaca açıklayınız. bir metodun kendi içinde kendini çağırmasıdır recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. metodun kendisi, kendini çağırdığı kısım ve base case jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. her çağırmada yeni bir stack olarak üst üste ekliyor. int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. i̇teratif olarak daha verimlidir çünkü yeni stack açmak zorunda kalmadan tek bir döngüde yapılabilir. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? - stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. i̇şlemin hafızada tutulduğu yerdir. bu yerler yetersiz gelip taşmasına overflow denir. eğer metot base case'e ulaşamazsan overflow olur. tail recursion nedir, kısaca açıklayınız. - bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class q1q1 { public static void main(string[] args){ string s=""a1b2""; int i=s.length(); combinations(s,i); } public static void combinations(string s, int i){ if(i==0){ system.out.println(); } string first=s.substring(0,i-1); string last=s.substring(i-1,s.length()); system.out.println(first.tolowercase()+last); system.out.println(first.touppercase()+last); while((s.charat(i-1)<'z' || s.charat(i-1)>'a') && i>0){ i--; } combinations(s,i); } } import java.util.arraylist; public class q1q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } class robot{ private string name; private string type; private int batterylevel; private boolean isoperational; public robot(){ name=""wall-e""; type=""trash""; batterylevel=100; isoperational=true; } public void setfeatures(string name, string type, int batterylevel, boolean isoperational ){ this.name=name; this.type=type; this.batterylevel=batterylevel; this.isoperational=isoperational; } private string getname(){ return name; } private string gettype(){ return type; } private int getbatterylevel(){ return batterylevel; } private boolean getisoperational(){ return isoperational; } public void charge(){ batterylevel=100; } public void printrobot(){ system.out.println(""name: ""+getname()+"" robot type: ""+gettype()+"" batterylevel: ""+getbatterylevel()+""% isoperational: ""+getisoperational()); } } class factory{ private string name; private string location; private arraylist<robot> robots; public factory(string name, string location){ this.name=name; this.location=location; if(name="""" && location=""""){ this.name= ""factory1""; this.location=""moon""; } } public void addrobot(robot robot){ robots.add(robot); } public void chargeallrobots(){ } public void printfactory(){ r1.printrobot(); r2.printrobot(); r3.printrobot(); } public void work(){ } } 6",8312,1084,174,53,9,5
2179244,1,"2179244 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q3 { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); // 2 basacak. system.out.println(s2.say()); // 4 basacak. } } class sayac{ public string sayi; public sayac(string sayi){ this.sayi=sayi; } public int say(){ if(sayi.length()!=0){ if(sayi.substring(0,1).equals(""1"")){ return 1 + new sayac(sayi.substring(1)).say(); } else{ return new sayac(sayi.substring(1)).say(); } } else{ return 0; } } } public class lab1q2 { public static void main(string[] args) { } public static void cocktailsort(int[] arr){ } } public class lab1q1 { public static void main(string[] args) { int i=3; system.out.println(collatz(i)); } public static int collatz(int i){ if(i%2==0){ return 1+ collatz(i/2); } else if(i==1){ return 0; } else{ return 1+ collatz((i*3) + 1); } } } /* if(i == 1){ return 1; } else if(i % 2 == 0){ return collatz(i/2); } else{ return collatz(3*i +1); } */ müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.*; abstract class sarki{ public string isim; public string sanatci; public sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } public abstract void oynat(); } class metalsarki extends sarki { public string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(isim, sanatci); this.metalozellik = metalozellik; } @override public void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + isim+""(""+metalozellik+"")""); } public void gostermetalozellikleri() { system.out.println( sanatci + "" - "" + isim+ "" [ozellik: ]""+metalozellik); } } class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { super(isim, sanatci); } @override public void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + isim+""(huzurlu ve nostaljik)""); } } class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { super(isim, sanatci); } @override public void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } //*************************************************************/ interface calmastratejisi { void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { list<sarki> karisikliste = new arraylist<>(sarkilistesi); collections.shuffle(karisikliste); for (sarki sarki : karisikliste) { sarki.oynat(); } } } class rockcuozelcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi){ boolean sesyukseltildi=false; for (int i=0; i < sarkilistesi.size(); i++) { sarki sarki=sarkilistesi.get(i); //***** if (sarki instanceof rocksarki) { if (!sesyukseltildi) { system.out.println(""[bilgi] ses duzeyi: yuksek""); sesyukseltildi = true; } sarki.oynat(); } else { if (sesyukseltildi) { system.out.println(""[bilgi] ses duzeyi: normal""); sesyukseltildi = false; } sarki.oynat(); } } if (sesyukseltildi) { system.out.println(""[bilgi] ses duzeyi: normal""); } } } class muzikcalar{ private calmastratejisi strateji; public void setstrateji(calmastratejisi s){ this.strateji=s; } public void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } //*****************************************************************/ //mai̇n public class main { public static void main(string[] args) { // şarkılar oluşturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // şarkı listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // müzik çalar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali çalma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik çalma stratejisi system.out.println(""\nkarisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu özel çalma stratejisi system.out.println(""\nrockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal şarkıların özelliklerini gösterme system.out.println(""\nmetal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } } } } abstraction kavramını açıklayınız. gereksiz değerlerin çıkarılmasıyla kullanıcıya yalın bir kod sunmaktır. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? java kendisi object sınıfı oluşturur ve kendisi super oluşturur. bir üst sınıfın class ın çağrılması için java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? mümkün değildir java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a nesnesinin b türünden olması metot overriding ve overloading kavramlarını açıklayınız. overloading: aynı class içerisinde metodun farklı parametre isimleri veya sayılarıyla çağrılması demektir. overriding ise inheritance gerektirir ve bir üst classtaki metodun subclassta çağrılmasıdır. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? . class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? . java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? static, private ve final metotlar kullanıldığında static bindingle bağlanır. diğer zamanlarda dynamic binding yapılır. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? override edilemezler overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? dynamic binding dinamik bağlamada jvm'nin görevi nedir? jvm hangi metodun veya sınıfın çağrılacağına karar verir java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? 1. çünkü java otomatik olarak bir üst class özelliklerini subclass a da ekler. 2. hayır java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? değişmemesini istediğimiz metotlar da değişirdi class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dynamic class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dynamic java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class obje oluşturamaz. concrtete ve abstract methodlar bulundyrabilir. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? evet. abstract içinde abstract atarsak conctrete metodu da implement etmek zorundayız abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. 1concrete metotlar bulundurabilir 2. concrete olmayan method bulundurabilir 3. obje oluşturamaz abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? evet reference type olarak olabilir. marker interface ve functional interface kavramları nedir, nasıl kullanılır? market interface içinde metot bulunmaz functional interface içinde 1 abstract metot bulunur. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet evet abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abatract class ta obje oluşmaz. display circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? hayır super shpw metodu hatalı a.super.show() olmalı a java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. checked exception, unchecked exception, errors java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? checked exception throw ediliyorsa, override edilen metotta aynı ya da alt türden ecception olmalı finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? kaynakları serbest bırakmak ve temizlemek için kullanılır çalışır java'da kendi exceptionunuzu nasıl tanımlarsınız? class myexception extends exception { public myexception(string message) { super(message); } } java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? i̇şlenmiş exceptionu dışarı throw etmek için static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? ioexception zaten exception’ın alt sınıfı olduğundan aynı try bloğunda iki kez catch edilemez. catch(ioexception e) bloğunu silmek veya exception’ı daha sonra catch etmek. trying m1 finally caught1 bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true import java.util.arraylist; public class delfin_kütükcü_quiz1q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); //factory name: factory1 location: moon robot r3 = new robot(""r2-d2"", ""astromech"", 80); // factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } class robot{ private string name; private string type; private int batterylevel; // 100 ile 0 arasında bir değer private boolean isoperational; // bataryası varsa true public robot(string name, string type, int batterylevel) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = batterylevel > 0; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; this.isoperational = batterylevel > 0; } public boolean isoperational() { return isoperational; } public void charge() { this.batterylevel = 100; this.isoperational = true; } public robot() { this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public void printrobot(){ system.out.println(""robot name: ""+name+""robot type: ""+type + "" batterylevel: "" + batterylevel+ "" isoperational: ""+ isoperational); } } class factory { private string name; private string location; private arraylist<robot> robots ; public factory() { name=""factory1""; location=""moon""; } //getter setterlar public void setname(string name) { this.name = name; } public string getname() { return name; } public void setlocation(string location) { this.location = location; } public string getlocation() { return location; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public arraylist<robot> getrobots() { return robots; } //************************************************/ public void addrobot(robot robot){ if (robots == null) { robots = new arraylist<>(); } robots.add(robot); } public void chargeallrobots() { for (robot robot : robots) { robot.charge(); } } public void printfactory(){ system.out.println(""factory name: "" + name + "" location: "" + location); system.out.println(""robots operating here:""); for (robot robot : robots) { robot.printrobot(); } } } public class delfin_kütükcü_quiz1q1 { public static void main(string[] args) { string s = ""a1b2""; chars(s); //s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] } public static void chars(string s){ kombinasyon(s.tochararray(),0); } public static void kombinasyon(char[] chars, int index){ if(index==chars.length){ system.out.println(chars); } else if(chars[index] >= 65 && chars[index] <= 90) { chars[index] += 32; kombinasyon(chars, index + 1); chars[index] -= 32; kombinasyon(chars, index + 1); } else if(chars[index] >= 97 && chars[index] <= 122) { chars[index] -= 32; kombinasyon(chars, index + 1); chars[index] += 32; kombinasyon(chars, index + 1); } else{ kombinasyon(chars, index+1); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 // withbattery interface public interface withbattery { int getbatterylife(); void recharge(); } // abstractrobot class public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public int getbatterylife() { return batterylife; } public void recharge() { batterylife = 100; } //? public abstract void performtask(); //soyut metod. cleaningrobot ve securityrobot sınıfları tarafından tanımlanacak. } // securityrobot class public class securityrobot extends abstractrobot { private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } public boolean getisarmed() { return isarmed; } public void performtask(){ if(batterylife>=10){ system.out.println(modelname+"" scanning for threats... armed: ""+isarmed); batterylife-=10; } else{ system.out.println(modelname+ "" not enough battery to scan threats..."" ); } } public void togglearmedmode(){ isarmed=!isarmed; } public string displayarmedmode(){ return (isarmed ? ""armed"" : ""unarmed""); } } // cleaningrobot class public class cleaningrobot extends abstractrobot { private int cleaningpower; public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } public int getcleaningpower() { return cleaningpower; } /*public void setcleaningpower(int cleaningpower) { this.cleaningpower = cleaningpower; }*/ public void performtask() { if (batterylife>=10) { system.out.println(modelname + "" cleaning in progress... cleaning power: "" + cleaningpower); batterylife-=10; } else { system.out.println(modelname + "" not enough battery to clean...""); } } public void boostcleaningpower() { cleaningpower +=10; } } // main class public class main_quiz2 { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); //yeni̇ robot robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.displaytotalrobotproduction(); system.out.println(""\n""); } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); private static int toplamroboturetimi = 0; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); toplamroboturetimi++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); toplamroboturetimi++; } public void performalltasks() { for (abstractrobot robot : robots) { robot.performtask(); } } public void displayrobots() { for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot) { system.out.println(""cleaningrobot- model: "" + robot.getmodelname() + "", battery: "" + robot.getbatterylife()+ "", cleaning power: "" + ((cleaningrobot) robot).getcleaningpower()); } else if (robot instanceof securityrobot) { system.out.println(""securityrobot- model: "" + robot.getmodelname() + "", battery: "" + robot.getbatterylife()+ "", armed: "" + ((securityrobot) robot).getisarmed()); } } } public void upgradecleaningrobots(int amount) { for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot) { ((cleaningrobot) robot).boostcleaningpower(); system.out.println(""cleaningrobot - "" + robot.getmodelname() + "" now has cleaningpower: ""+ ((cleaningrobot) robot).getcleaningpower()); } } } public void togglesecurityrobotsmode() { for (abstractrobot robot : robots) { if (robot instanceof securityrobot) { ((securityrobot) robot).togglearmedmode(); system.out.println(""securityrobot - "" + robot.getmodelname() + "" is now "" + ((securityrobot) robot).displayarmedmode()); } } } //??? public static void displaytotalrobotproduction() { system.out.println(""tum fabrikalar tarafindan toplam "" + toplamroboturetimi + "" robot uretildi""); } } 1",35241,4423,658,222,52,55
6343320,0,"6343320 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. package pkg; public class hello { public static void main(string args[]) { int x = 5; system.out.print(collatz(x)); } public static int collatz(int i) { int adım = 0; if(i != 1 ) { if(i%2 == 0) { i = i/2; } else { i = i * 3 + 1; } adım++; collatz(i, adım); } return (adım); } public static int collatz(int sayı, int adım) { if(sayı != 1 ) { if(sayı%2 == 0) { sayı = sayı/2; } else { sayı = sayı * 3 + 1; } adım++; collatz(sayı, adım); } return (adım); } } package pckg; public class lab1 { public static void main(string args[]) { int [] arr = {5, 4, 1, 2}; cocktailsort(arr); for(int i = 0; i < arr.length; i++) { system.out.print(arr[i]); } } public static void cocktailsort(int[] arr) { int uzunluk = arr.length; int start = 0; if(start%2 == 0) { for(int i = 1; i < uzunluk; i++) { if(arr[start] > arr[i] ) { int temp = arr[i]; arr[i] = arr[start]; arr[start] = temp; } } start++; } else { cocktailsort(arr, start); start++; } } public static void cocktailsort(int[] arr, int x) { int uzunluk = arr.length - 2; for(;x > 0 ;uzunluk --) { if(arr[x] > arr[uzunluk]) { int temp = arr[x]; arr[x] = arr[uzunluk]; arr[uzunluk] = temp; } } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 package pckg; import java.util.arrays; import java.util.list; import java.util.random; public class lab2 { public static void main(string[] args) { // todo auto-generated method stub sarki s1 = new metalsarki(""years of silence"",""thurisaz"",""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"",""death"",""enstrumantal""); sarki s3 = new rocksarki(""small mountain"",""midlake""); sarki s4 = new rocksarki(""ankara"",""vega""); sarki s5 = new klasiksarki(""una mattina"",""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); müzikcalar muzikcalar = new müzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new sıralıcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metak ozellikleri:""); for(sarki sarki : sarkilistesi) { } } } abstract class sarki{ string isim; string sanatci; public void oynat() { } } class metalsarki extends sarki{ string metalozellik; metalsarki(string name, string singer , string tür){} metalsarki(string name, string singer){} public void gostermetalozellikleri(string isim, string sanatci, string metalozellik) { system.out.println(metalozellik); } } class rocksarki extends sarki{ rocksarki(string name, string singer, string tür){} rocksarki(string name, string singer){} } class klasiksarki extends sarki{ klasiksarki(string name, string singer, string tür){} klasiksarki(string name, string singer){} } class calmastratejisi{ public static void cal(list<sarki> sarkilistesi) { for(sarki m : sarkilistesi) { system.out.println(m); } } } class sıralıcalma extends calmastratejisi{ for(sarki s : sarkilistesi) { system.out.println(s.sanatci + ""-"" + s.isim); } } class karisikcalma extends calmastratejisi{ for (sarki s : sarkilistesi) { random sayı = new random(2); } } class rockcuozelcalma extends calmastratejisi{ private string ses_duzeyi = ""normal""; for(sarki s : sarkilistesi) { if(s.equals(""rock"")) { ses_duzeyi = ""yüksek""; } else { ses_duzeyi = ""normal""; } } } class müzikcalar{ calmastratejisi calmayöntemi; public void setstrateji(calmastratejisi a) { calmayöntemi = a; } public void muzikcal(list<sarki> sarkilistesi) { if(calmayöntemi.equals(""siralicalma"")) { for(sarki s : sarkilistesi) system.out.println(s.sanatci + ""-"" + s.isim); } else { for(sarki s : sarkilistesi) system.out.println(s.sanatci + ""-"" + s.isim); } } } ""recursion"" kavramı nedir, kısaca açıklayınız. metodun içinde o metodun aynısını kullanarak döngü yaratmaktır recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case, stack jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. . int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. iteratif olarak daha verimli çalışır çünkü stackte çok fazla birikme olmiyacağı için bilgisayar daha az yorulur bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? string i ilk eleman ve geri kalanlar diye iki string e bölerdim ve her metoda girdiğinde ilk stringin boyutunu bir arttırıp ikinciyi bir azaltırdım ve bu metodun içinde length diye bir değişken tutup onu her bu metoda girildiğinde 1 arttırırdım stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack bir metodda veya bir döngüde kodların hangi sırayla çalışacağını tutar. tail recursion nedir, kısaca açıklayınız. . abstraction kavramını açıklayınız. . dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? hayır çünkü override etmek için metodların signature ve isim kısmı aynı olmalı protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? çünkü eğer super olursa erişimi kısıtlamış oluruz java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır ama eğer b c yi extend etmişse ve a da b yi extend ediyorsa a otomatikmen c yi de extend etmiş olur java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a b midir yani extend edilmiş mi diye bakar metot overriding ve overloading kavramlarını açıklayınız. override bir metodu farklı bir classın içinde aynı signature ve isimle tekrardan yazmaktır, overload ise metodu fazladan yüklemektir class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? 101 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? static binding yapmamız gerekenler ilk olarak kullanılmasını istediklerimizdir dynamicler ise öncelik vermek istemediklerimizdir java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? static ile bağlanmazsa değer değiştirme recursion gibi şeylerin yapılabilir olması gerekir ortak özellikleri bu methodlara recursion uygulanamamasıdır overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? dynamic çünkü static olursa override veya overload yapamayız dinamik bağlamada jvm'nin görevi nedir? . java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? . java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? hepsi atama sırasına göre stackde sıralanırdı istediğimize öncelik veremezdik class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? hata verir çünkü parent ile child a ait obje üretemeyiz class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? edilebilir, abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. . abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract soyutlama yapılarak çalışırken, interface nesneyle çalışır marker interface ve functional interface kavramları nedir, nasıl kullanılır? . bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? 1-evet ,2-evet abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? b java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 3 çeşittir out of bound io exception arithmetic exception java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? . finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally bloğu exception catch edilse bile çalışan blokdur. evet çalışır java'da kendi exceptionunuzu nasıl tanımlarsınız? exception class ından yeni bir exception object i oluşturarak java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? o exception haricinde bir exception var mı yok mu bunu bulmak için static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenmez çünkü bu metotlar hiçbir yerde çağırılmıyor bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true package pkg; public class quiz1q2 { public static void main(string[] args) { } } public class robot{ private string name; private string type; private int batterylevel; private boolean isoperational; public string getname() { this.name = name; } public static void setname(string name) { } public string gettype() { this.type = type; } public static void settype(string type) { } public int getbatterylevel() { this.batterylevel = batterylevel; } public static void setbatterylevel(int batterylevel) { } public boolean getisoperational() { this.isoperational = isoperational; } public static void setisoperational(boolean isoperational) { } public void charge() { this.batterylevel = 100; } public void printrobot() { system.out.println(""robot name: "" + robot.getname() + ""robot type: "" + robot.gettype() + ""batterylevel: "" + get.batterylevel() + ""isoperational: "" + get.isoperational()); } } public class factory{ private string name; private string location; private arraylist<robot> robots; public factory(string name, string location){ } public void addrobot(robot robot) { } public void chargeallrobots() { } public void printfactory() { } public void work() { robot.setbatterylevel(batterylevel - 15); } } package pkg; public class quiz1 { public static void main(string[] args) { // todo auto-generated method stub string str = ""a1b2""; changecase(str); } public static void changecase(string str) { string[] string = string[100]; char[] arr = arr[str.length()]; int loc = 0; int sayac = 0; if(str.length() != 0) { for(int i = 0; i < str.length() ; i++) { int control = 0; if(str.charat(i) < 96 && str.charat(i) > 65) { sayac++; control = 1; arr[i] = (char)(str.charat(i) + 32); } else if(str.charat(i) < 129 && str.charat(i) > 96) { sayac++; control = 1; arr[i] = (char)(str.charat(i) - 32); } if(control == 1) { string[loc] = str; loc++; } else { string[loc] = """"; loc++; } system.out.println(string[i]); } } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 interface withbattery{ int getbatterylife(); string getvariety(); void recharge(); } abstract class abstractrobot implements withbattery{ string modelvariety; string modelname; int batterylife; public abstractrobot(string modelname, int batterylife) {} public string getmodelname() { return modelname; } public abstract void performtask(); public int getbatterylife() { return batterylife; } public string getvariety() { return modelvariety; } public void recharge() { batterylife = 100; } } public class quiz2 { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduce robots: ""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks: ""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots: ""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes: ""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status: ""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); anotherfactory.numberofrobots(); } } class securityrobot extends abstractrobot{ private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); } public void performtask() {} public void togglearmedmode() { if(isarmed == false) isarmed = true; else isarmed = false; } } class cleaningrobot extends abstractrobot{ private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); } public void performtask() { if(batterylife >= 10) { system.out.println( modelname + ""cleaning in progress... cleaning power: "" + cleaningpower); batterylife -= 10; } else { system.out.println(modelname + ""not enough battery to clean...""); } } public void boostcleaningpower() { cleaningpower += 10; } } class robotfactory{ private arraylist<abstractrobot> robots; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); } public void performalltasks() { for(int i = 0; i < robots.size(); i++) { robots.get(i).performtask(); } } public void displayrobots() { for(int i = 0; i < robots.size(); i++) { system.out.println(""model"" + robots.get(i).getmodelname() +"", battery:"" + robots.get(i).getbatterylife()); } } public void upgradecleaningrobots(int miktar) { for(int i = 0; i < robots.size(); i++) { } } public void togglesecurityrobotsmode() { for(int i = 0; i < robots.size(); i++) { } } public void numberofrobots() { system.out.println(""tüm fabrikalar tarafından toplam "" + (robots.size() - 1) + "" robot üretildi""); } } 0",31939,4169,550,188,43,20
4275079,1,"4275079 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. import java.util.arrays; public class main { public static void main(string[] args) { system.out.println(q1.collatz(6)); system.out.println(q1.collatz(7)); sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); sayac s3 = new sayac(""1120393129211""); system.out.println(s1.say()); system.out.println(s2.say()); system.out.println(s3.say()); int arr[] = {12, 43, 1, 5, 241, 56, 532, 0}; int arr1[] = {18, 132, 51, 57, 261, 516, 932, 3}; q2.coctailsort(arr); q2.coctailsort(arr1); } } import java.util.arrays; //ek method gerekmedi. public class q2 { public static void coctailsort(int []arr){ int minindex=0; for(int i=0;i<arr.length-1;i++){ if( arr[i]>arr[i+1]){ int temp=arr[i]; arr[i]=arr[i+1]; arr[i+1]=temp; minindex++; } } if(minindex!=0) { coctailsort(arr); } else system.out.println(arrays.tostring(arr)); } } public class q1 { public static int collatz(int n){ if(n==1){ return 0; } else{ if(n%2==0){ return 1+collatz(n/2); } else if(n%2==1){ return 1+collatz(n*3+1); } else return 0; } } } public class sayac { public string number; public sayac(string str){ this.number=str; } public int say() { if (number.length() == 0) { return 0; } else { if (number.charat(0) == ('1')) { number= number.substring(1); return 1 + say(); } else { number= number.substring(1); return say(); } } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { private calmastratejisi strateji; void setstrateji(calmastratejisi s){ this.strateji=s; } void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } //rockçu özel çalma hariç her şey doğru çalışıyor. import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); system.out.println(s3); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi){ if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); }} } } public class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci) { super(isim,sanatci); } @override void oynat() { system.out.println(""[ klasik ] ""+isim+"" - ""+sanatci+"" (hafif ve sakin)""); } } public class metalsarki extends sarki{ private string metalozellik; @override void oynat() { system.out.println(""[ metal ] ""+sanatci+"" - ""+isim+"" ( ""+metalozellik +"" )""); } metalsarki(string isim, string sanatci, string metalozellik){ super(isim,sanatci); this.metalozellik=metalozellik; } void gostermetalozellikleri(){ system.out.println(sanatci+"" - ""+isim+"" [ozellik: ""+metalozellik +"" ]""); } public string getmetalozellik() { return metalozellik; } } public class rocksarki extends sarki{ public rocksarki(string isim, string sanatci) { super(isim,sanatci); } @override void oynat() { system.out.println(""[ rock ] ""+isim+"" - ""+sanatci+"" (huzurlu ve nostaljik)""); } } import java.util.list; public class karisikcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { int i=0; int x; while(i<sarkilistesi.size()){ x= (int) (math.random()*5+0); sarkilistesi.get(x).oynat(); i++; } } } import java.util.list; public class siralicalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { for(int i=0;i<sarkilistesi.size();i++){ sarkilistesi.get(i).oynat(); } } } public abstract class sarki { string isim ; string sanatci; public sarki(string isim, string sanatci) { this.sanatci=sanatci; this.isim=isim; } abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean d; for(int i=0;i<sarkilistesi.size();i++){ string str=""rocksarki.java""; if (sarkilistesi.get(i).getclass().getname().equals(str)){ d=true; if(d){ system.out.println( ""[bilgi] ses duzeyi: yuksek""); } else d=false; if(!d){ system.out.println( ""[bilgi] ses duzeyi: normal""); } } sarkilistesi.get(i).oynat(); }} } import java.util.list; interface calmastratejisi { void cal(list<sarki> sarkilistesi); } abstraction kavramını açıklayınız. ihtiyac duyulmayan methodların soyutlanarak kullanici tarafindan gorulmesini engeller. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür ama tersi mümkün değildir. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? default daha yakindir. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? java da bir class sadece bir üst classına erisebildigi icin 2 üst class erismek recursive bir durum alır bunun uygulanabilmesi icin de her classin ilk satiri super olmalidir java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayir. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a, b nin upper classidir. metot overriding ve overloading kavramlarını açıklayınız. overriding ayni signatura sahip metotlarin farkli classlar icin farkli gorevler icin kullanilmasidir ancak overloading ayni classta farkli parametreler alarak farkli gorevlerde kullanilmasi icindir class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? output yok. class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 10 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? object olusturulacaksa dinamik sınıfın tamamı çagrilaracaksa statik binding yapilir. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? metotlar sınıf ismi ile çağrılır.override edilemez . overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? dynamic gerçekleşir.object olusturularak kullanilir. dinamik bağlamada jvm'nin görevi nedir? ? java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? down classlar upper classtaki metotlara sahiptir o yüzden implicit casting yapilabilir ancak tam tersi gecerli degildir. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? degismeyen metotlar elde edemezdik sinifi cagiramazdik. bilgi güvenliği saglanmazdı. class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? parent, dinamik. class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product \n product , dinamik. java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class soyutlanmış class olarak bilinir. abstract classlarda constructer olabilir ancak interfacelerde yoktur. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? evet abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. kullanicinin ihtiyaci olmayan methodları saklar abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interfaceler ile obje oluşturulamaz .abstract classlar ile oluşturulabilir. marker interface ve functional interface kavramları nedir, nasıl kullanılır? . bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet,evet. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? shape deki draw methodu abstract yapilmalidir hata duzeldikten sonra output drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? compile edilemez . implements edilen iki methodda overriding olmamalidir sadece implements a derse mesela output a olarak cikti verir yani tek implement yapilmali ya da interfacelerin birinden show methodu silinmeli ya da signature degismelidir. java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 2 çesit checked ve unchecked java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? . finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? catchden sonra try catch blogunda kapanistan once yapilmasi gereken seyler icin kullanilir . java'da kendi exceptionunuzu nasıl tanımlarsınız? throwable bir exception objesi olusturarak. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? baska bir try catch metodu icin bir isleve sahip olabilir. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally -1 oops done 41 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenmez cunku excepti̇on io excepti̇onun üst sınfı olmasina rağmen daha once olan bir catch blogunda yakalamistir eger catch bloklari yer degistirirse hata düzelir. output: tryi̇ng m1 caught1 finally bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public robot(string name, string type, int batterylevel) { this.batterylevel = batterylevel; this.name = name; this.type = type; } public robot() { this.batterylevel = 100; this.name = ""wall-e""; this.type = ""trash""; this.isoperational = true; } public void charge() { batterylevel = 100; } public void printrobot() { system.out.println(""robot name: "" + getname() + ""robot type"" + gettype() + ""batterylevel : "" + getbatterylevel() + ""isopeational : "" + isoperational(this)); } public boolean isoperational(robot robot) { if (robot.getbatterylevel() > 0) { return true; } else return false; } public string getname() { return name; } public void setname(string name) { this.name = name; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public void setoperational(boolean operational) { isoperational = operational; } } public class main { public static void main(string[] args) { factory factory = new factory(); factory factory1 = new factory(""okul"",""dünya""); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory1.addrobot(r1); factory1.addrobot(r2); factory.addrobot(r3); factory.chargeallrobots(); factory1.work(); r1.printrobot(); r2.charge(); r2.printrobot(); factory1.printfactory(); } } public class q1 { public string[] perm(string s,int index,string[] strs){ for(int i=0;i<s.length();i++){ strs[index]=s; if (toupperortolower(s.charat(0))) { toupperortolower(s.charat(0)); strs[index + 1] = s; } } return null; } public boolean toupperortolower(char c){ if(c<='z'&&c>='a'){ c= (char) (c+'a'-'a'); return true; } else if(c<='z'&&c>='a'){ c= (char) (c+'a'-'z'); return true; } else return false; } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name,string location){ this.name=name; this.location=location; } //burda eklemeden kaynaklı bir hata alıyorum ve kodun factory fonksiyonları this.robots null olduğundan çalışmıyor.düzelirse her şey doğru çalışıyor. public void addrobot(robot robot){ robots.add(robot); } public factory(){ this.name=""factory1""; this.location=""moon""; } public void chargeallrobots(){ for (robot robot : robots) { robot.setbatterylevel(100); } } public void printfactory(){ system.out.println(""factory name:""+getname()+"" location:"" +getlocation()); } public void work(){ for (robot robot : robots) { robot.setbatterylevel(robot.getbatterylevel() - 15); } } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getlocation() { return location; } public void setlocation(string location) { this.location = location; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public arraylist<robot> getrobots() { return robots; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 interface withbattery { int getbatterylife(); void recharge(); } import java.lang.reflect.constructor; abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; protected int batterylife2; public abstractrobot(string modelname, int batterylife){ this.modelname=modelname; this.batterylife=batterylife; this.batterylife2=batterylife; } public abstract void performtask(); public string getmodelname() { return modelname; } public int getbatterylife2() { return batterylife2; } @override public int getbatterylife() { return batterylife; } } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); //toplam üretilen robot sayısı için yazdığım fonksiyonum. robotfactory.numofrobots(); } } public class securityrobot extends abstractrobot{ private boolean isarmed ; public securityrobot(string modelname, int batterylife,boolean isarmed) { super(modelname, batterylife); this.isarmed=isarmed; } public void performtask(){ if(getbatterylife()>=10){ system.out.println( ""[""+modelname+""] scanning for threats... armed: ""+isarmed); batterylife = batterylife - 10; } else { system.out.println(""[""+modelname+""] not enough battery to scan threats....""); } } public void togglearmedmode(){ if(isarmed){ isarmed=false; } else{ isarmed=true; } } public boolean isarmed() { return isarmed; } @override public void recharge() { batterylife=getbatterylife(); } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; public cleaningrobot(string modelname, int batterylife,int cleaningpower) { super(modelname, batterylife); this.cleaningpower=cleaningpower; } public void performtask(){ if(getbatterylife()>=10){ system.out.println(""[""+ modelname +""] cleaning in progress... cleaning power: ""+cleaningpower); batterylife = batterylife - 10; } else { system.out.println(""[""+modelname+""] not enough battery to clean...""); } } public void boostcleaningpower(int miktar){ cleaningpower+=miktar; } public int getcleaningpower() { return cleaningpower; } @override public void recharge() { batterylife=getbatterylife2(); } } import java.awt.*; import java.util.arraylist; public class robotfactory { static int numberofrobots; arraylist<abstractrobot> robots; robotfactory(){ this.robots=new arraylist<>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ robots.add(new cleaningrobot(modelname,batterylife,cleaningpower)); numberofrobots++; } //toplam üretilen robot sayısı için yazdığım fonksiyonum. public static void numofrobots(){ system.out.println("" tum fabrikalar tarafindan toplam ""+numberofrobots+"" robot uretildi""); } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ robots.add(new securityrobot(modelname,batterylife,isarmed)); numberofrobots++; } public void upgradecleaningrobots(int miktar){ for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot) { ((cleaningrobot) robot).boostcleaningpower(miktar); system.out.println("" cleaningrobot - ""+robot.modelname+"" now has cleaning power: ""+((cleaningrobot) robot).getcleaningpower()); } } } public void togglesecurityrobotsmode() { for (abstractrobot robot : robots) { if (robot instanceof securityrobot) { ((securityrobot) robot).togglearmedmode(); if (((securityrobot) robot).isarmed() == false) { system.out.println(""securityrobot - "" + robot.modelname + "" is now unarmed""); } else system.out.println(""securityrobot - "" + robot.modelname + "" is now armed""); } } } public void displayrobots(){ for (abstractrobot robot : robots) { if(robot instanceof cleaningrobot){ system.out.println( robot.getclass().getname() +"" - model: ""+robot.getmodelname()+ "", battery: ""+robot.batterylife +"", cleaning power: ""+((cleaningrobot) robot).getcleaningpower()); } else if(robot instanceof securityrobot){ system.out.println( robot.getclass().getname() +"" - model: ""+robot.getmodelname()+ "", battery: ""+robot.batterylife +"", cleaning power: ""+ ((securityrobot) robot).isarmed()); } } } public void performalltasks(){ for (abstractrobot robot : robots) { robot.performtask(); } } } 1",35834,4390,669,217,46,32
7374887,0,"7374887 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class cocktailshakersort { public static void main(string[] args) { int[] arr = { 5, 4, 1, 2 }; cocktailsort(arr); for (int i = 0; i < arr.length; i++) { system.out.println(arr[i]); } } public static void cocktailsort(int[] arr) { if (!issorted(arr)) { int temp = 0; for (int j = 0; j < arr.length - 1; j++) { if (arr[j] > arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } if (!issorted(arr)) { for (int j = arr.length - 1; j > 0; j--) { if (arr[j] < arr[j - 1]) { temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; } } if (!issorted(arr)) { cocktailsort(arr); } } } } public static boolean issorted(int[] arr) { for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { return false; } } return true; } } public class collatz { public static void main(string[] args) { system.out.println(collatz(6));// 6-> 3 ->10 ->5-> 16-> 8 ->4-> 2 ->1 system.out.println(collatz(5));// 5 -> 16 -> 8 -> 4 -> 2 -> 1 } public static int collatz(int i) { int count = 0; if (i == 1) { return 0; } if (i % 2 == 0) { i = i / 2; } else { i = i * 3 + 1; } count++; count += collatz(i); return count; } } public class sayac { string input; sayac(string input) { this.input = input; } public int say() { if (this.input.length() == 0) { return 0; } if (this.input.charat(0) == '1') { this.input = this.input.substring(1); return 1 + this.say(); } else { this.input = this.input.substring(1); return this.say(); } } public static void main(string[] args) { sayac x1 = new sayac(""10001"");// 2 sayac x2 = new sayac(""1111"");// 4 sayac x3 = new sayac(""681611161651816541"");// 8 system.out.println(x1.say()); system.out.println(x2.say()); system.out.println(x3.say()); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arraylist; import java.util.arrays; import java.util.list; import java.util.random; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi sarki[] x = { s1, s2, s3, s4, s5 }; list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki.getclass() == metalsarki.class) { metalsarki temp = (metalsarki) sarki; system.out.println(sarki.sanatci + "" - "" + sarki.name + "" [ozellik:"" + temp.metalozellik + ""]""); } } } } abstract class sarki { string name; string sanatci; abstract void oynat(); } class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { this.name = isim; this.metalozellik = metalozellik; this.sanatci = sanatci; } void gostermetalozellikleri() { system.out.print(metalozellik); } void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + name + "" ("" + metalozellik + "")""); } } class rocksarki extends sarki { rocksarki(string name, string sanatci) { this.name = name; this.sanatci = sanatci; } void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + name + "" (huzurlu ve nostaljik)""); } } class klasiksarki extends sarki { klasiksarki(string name, string sanatci) { this.name = name; this.sanatci = sanatci; } void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + name + "" (hafif ve sakin)""); } } interface calmastratejisi { public void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { sarki song = sarkilistesi.get(i); song.oynat(); } } } class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { arraylist<sarki> arr = new arraylist<sarki>(); for (int i = 0; i < sarkilistesi.size(); i++) { arr.add(sarkilistesi.get(i)); } random gen = new random(); while (arr.size() != 0) { int x = gen.nextint(arr.size()); arr.get(x).oynat(); arr.remove(x); } } } class rockcuozelcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { boolean isvol = false; for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof rocksarki) { if (!(isvol)) { system.out.println(""[bilgi] ses duzeyi: yuksek""); isvol = true; } sarkilistesi.get(i).oynat(); } else { if (isvol) { isvol = false; system.out.println(""[bilgi] ses duzeyi: normal""); } sarkilistesi.get(i).oynat(); } } } } class muzikcalar { calmastratejisi strateji; muzikcalar() { } void setstrateji(calmastratejisi s) { strateji = s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } ""recursion"" kavramı nedir, kısaca açıklayınız. recursion bir fonkisyonun kendini çağırarak işlem yapmasıdır. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. problemin çözebildiğimiz kısmı olan base case,çözmeye çalıştığımız ana problem ve bu ikisi arasında bağ kuran recursive calls jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. bir recursive call a geldiğinde stack de tüm local variablelar in yeni alan açar ve base case e kadar devam eder base case e ulaşınca tüm local variablelar silinir int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. eğer kuvveti hesaplarken küçük parçalara bölersek recursive daha hızlıdır. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? stringi tek tek karakterlere bölersek 1 karakterin uzunluğunu bildiğimizden base case olarak kullanabiliriz. stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack overflow hatası stack memory de saklanan local variable ların stack memorynin boyutunu aşması sonuvu ortaya çıkar tail recursion nedir, kısaca açıklayınız. - abstraction kavramını açıklayınız. abstraction sadece bizim için önemli olan kısımları kullanıp diğer kısımların nasıl çalıştığına bakmadan kullanmak dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkün değildir ancak tersi mümkündür protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? protected java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? üst classının constructorını öncrlikli olarak çalıştırıp düzgün bir şekilde initialze olabilmesi için java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? mümkün değildir her bir class tek bir classı extend edebilir java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a ve b nin aynı tipte olup olmadığına bakar ve bunu yaparken sub-super class ilişkisinide kontrol eder birbirinin sub super classı olan classlarda true sonucu verir metot overriding ve overloading kavramlarını açıklayınız. overriding super classtan bir methodu ad veya signature ı değiştirmeden sub classta içeriğini değiştirmek .overloading ise aynı classta aynı isim farklı signature ile methotlar yapmaktır. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? base class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? parent 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? static binding hangi metodun çalıştırılacağı runtimedan önce belli olan methotlarda olur örneğin static veya final methotlar dynamic binding ise runtime da belli olan methotlarda olur. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? çünkü bu methotlar override edilemez dolayısıyla binding problemi yoktur overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloadingde static binding gerçekleşir çünkü methot signature ı farklı olduğundan kargaşa yoktur overridingde ise dynamic binding gerçekleşir dinamik bağlamada jvm'nin görevi nedir? önce reference typeta methodun olup olmadığına bakmak varsa o methodun en son override edildiği yere kadar gidip o methodu çalıştırmak java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? çünkü alt classın objesi üst kcassında objesidir. downcasting implicit şeklide yapılamaz çünkü üst class alt classın tüm özelliklerini taşımadığından java izin vermez java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? bir anlamı olmazdı çünkü static bindingdeki methotlar zaten override edilemediği için sadece zaman kaybı olurdu. class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child .dinamik bağlama vardır. class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book dinamik bağlama java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class içinde abstract metot içerir.abstract metot tamamlanmamış metottur sadece metodun signatureı vardır.abstract metotların constructorı olabilir.i̇nterface in constructorı olamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? eğer abstract metot class a ata classtan geliyorsa implement edilebilir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract classtan obje oluşturulamaz.abstract classların alt classları da abstract metot implement edilmediği sürece abstract olur.şuanda nasıl implement edeceğini bilmediğimiz metotların gelecekte biri tarafından implement edilmesini kesinleştirmiş oluruz. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? i̇nterfaceler class değildir.i̇çlerinde oluşturulan tüm attributelar final ve privatedır.hem abstract class hemde interfaceler tip olarak kullanılabilir. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface bir classın bir özelliğe sahip olduğunu belirtmek için kullanılabilir.functional interface classlara yetenekler sağlar. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? i̇kiside mümkün. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? shape classı abstracttır obje oluşturulamaz.shape c = new circle(); yaparak hata düzeltilir. drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? c classında ata class yoktur bu yüzden kod çalışmaz. c classındaki show metodunda başka system.out.println(""c"");yazılabilir. c java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. i̇o exceptions örneğin filenotfound,runtime exceptions örn arrayoutofbounds, java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? throws keywordundan sonra yazacağımız şeyin ""throwable"" olması gerekir.override da ise overrde ettiğimiz metottan daha genel bir exception fırlatamayız örneğin ata classın metotunda i̇o exception fırlatırken override ettiğimiz metotta exception fırlatamayız. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally bloğu her şekilde çalışır exception bulunsada bulunmasada. java'da kendi exceptionunuzu nasıl tanımlarsınız? exception classını extend eden bir class yazarak java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? yapılan işlem hatayı düzeltmek için yeterli olmama ihtimali varsa olabilir. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? m2() metotundaki 2.catch bloğu erişilemez kod olduğundan kod çalışmaz catch bloklarının yerleri değiştirilerek çözülebilir.output tryi̇ng m1 caught2 fi̇nally bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true import java.util.arraylist; public class quiz1q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } class robot { private string name; private string type; private int batterylevel;// 100 ile 0 arasında bir değer private boolean isoperational;// bataryası varsa true robot() { this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } robot(string name, string type, int batterylevel) { this.type = type; this.name = name; if (batterylevel >= 0 && batterylevel <= 100) { this.batterylevel = batterylevel; } if (batterylevel > 0 && batterylevel < 100) { this.isoperational = true; } } public void printrobot() { system.out.println(""robot name:"" + getname() + "" robot type:"" + gettype() + "" batterylevel :"" + getbatterylevel() + "" isoperational:"" + getisoperational()); } public string getname() { return this.name; } public string gettype() { return this.type; } public int getbatterylevel() { return this.batterylevel; } public boolean getisoperational() { return this.isoperational; } public void setname(string name) { this.name = name; } public void settype(string type) { this.type = type; } public void setbatterylevel(int batterylevel) { if (batterylevel >= 0 && batterylevel <= 100) { this.batterylevel = batterylevel; } } public void setisoperational(boolean value) { this.isoperational = value; } public void charge() { this.batterylevel = 100; } } class factory { private string name; private string location; private arraylist<robot> robots = new arraylist<robot>(); public factory(string name, string location) { this.location = location; this.name = name; } public factory() { this.location = ""moon""; this.name = ""factory1""; } public void addrobot(robot robot) { this.robots.add(robot); } public void chargeallrobots() { for (int i = 0; i < robots.size(); i++) { robots.get(i).charge(); } } public void work() { for (int i = 0; i < robots.size(); i++) { robot x = robots.get(i); x.setbatterylevel(x.getbatterylevel() - 15); } } public void printfactory() { system.out.println(""factory name: "" + this.name + "" location: "" + this.location); system.out.println(""robots operating here:""); if (robots.size() > 0) { for (int i = 0; i < robots.size(); i++) { robots.get(i).printrobot(); } } else system.out.println(""none""); } public string getname() { return this.name; } public string getlocation() { return this.location; } public void setname(string name) { this.name = name; } public void setlocation(string location) { this.location = location; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; private final int originalbatterylevel; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; originalbatterylevel = batterylife; } public string getmodelname() { return modelname; } public void recharge() { batterylife = originalbatterylevel; } public int getbatterylife() { return batterylife; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.print(""\n""); robotfactory.displayrobotcount(); } } public class securityrobot extends abstractrobot { private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } public void performtask() { if (this.batterylife >= 10) { system.out.println(""["" + modelname + ""]"" + ""scanning for threats... armed:"" + isarmed); batterylife -= 10; } else { system.out.println(""["" + modelname + ""]"" + ""not enough battery to scan threats...""); } } public void togglearmedmode() { isarmed = !isarmed; if (isarmed) { system.out.println(""securityrobot - "" + modelname + "" is now armed""); } else { system.out.println(""securityrobot - "" + modelname + "" is now unarmed""); } } public boolean getisarmed() { return isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } public void performtask() { if (this.batterylife >= 10) { system.out.println(""["" + modelname + ""]"" + ""cleaning in progress... cleaning power:"" + cleaningpower); batterylife -= 10; } else { system.out.println(""["" + modelname + ""]"" + ""not enough battery to clean...""); } } public void boostcleaningpower(int x) { this.cleaningpower += x; system.out.println(""cleaningrobot - "" + modelname + "" now has cleaning power: "" + cleaningpower); } public int getcleaningpower() { return cleaningpower; } } import java.util.arraylist; public class robotfactory { private static int robotcount = 0; private arraylist<abstractrobot> robots = new arraylist<abstractrobot>(); public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); robotcount++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); robotcount++; } public void performalltasks() { for (abstractrobot abstractrobot : robots) { abstractrobot.performtask(); } } public void displayrobots() { for (int i = 0; i < robots.size(); i++) { abstractrobot abstractrobot = robots.get(i); if (abstractrobot.getclass() == securityrobot.class) { securityrobot k = (securityrobot) abstractrobot; system.out.println(""securityrobot - model: "" + k.modelname + "", battery: "" + k.getbatterylife() + "", armed: "" + k.getisarmed()); } else { cleaningrobot k = (cleaningrobot) abstractrobot; system.out.println(""cleaning robot - model: "" + k.modelname + "", battery: "" + k.getbatterylife() + "", armed: "" + k.getcleaningpower()); } } } public void upgradecleaningrobots(int miktar) { for (abstractrobot abstractrobot : robots) { if (abstractrobot.getclass() == cleaningrobot.class) { cleaningrobot k = (cleaningrobot) abstractrobot; k.boostcleaningpower(miktar); } } } public void togglesecurityrobotsmode() { for (abstractrobot abstractrobot : robots) { if (abstractrobot.getclass() == securityrobot.class) { securityrobot k = (securityrobot) abstractrobot; k.togglearmedmode(); } } } public static void displayrobotcount() { system.out.println(""tum fabrikalar tarafindan toplam "" + robotfactory.robotcount + "" robot uretildi""); } } 0",38148,4974,671,206,53,34
6539697,0,"6539697 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class main { public static void main(string[] args) { system.out.println(""collatz: ""+collatz(5)); int[] arr ={5,4,1,2}; cocktailsort(arr); system.out.print(""cocktail sort: ""); for(int n : arr) system.out.print(n + "" ""); system.out.println(); sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(""say 10001: ""+s1.say()); system.out.println(""say 1111: ""+s2.say()); } public static int collatz(int i){ if(i==1) return 0; else if(i%2==0) return 1+collatz(i/2); return 1+collatz(3*i+1); } public static void cocktailsort(int[] arr){ bubblesort(arr,0); } public static int[] bubblesort(int[] arr,int target){ for(int i=target+1; i<arr.length;i++) { if(arr[target]>=arr[i]) { int temp = arr[i]; arr[i] = arr[target]; arr[target] = temp; bubblesort(arr,target+1); i=target; } } return arr; } } class sayac { string s; public sayac(string s) { this.s = s; } public int say() { if (s.isempty()) return 0; else if (s.charat(0) == '1') return 1 + new sayac(s.substring(1)).say(); return new sayac(s.substring(1)).say(); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { this.strateji = s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1,s2,s3,s4,s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri:""); for(sarki sarki : sarkilistesi) if (sarki instanceof metalsarki) system.out.println(sarki.sanatci + "" - "" + sarki.isim + "" [ozellik: "" + ((metalsarki) sarki).metalozellik + ""]""); } } class klasiksarki extends sarki { string klasikozellik; klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; this.klasikozellik = ""hafif ve sakin""; } void oynat() { system.out.println(""[klasik] ""+sanatci+"" - ""+isim+"" (""+klasikozellik+"")""); } } public class metalsarki extends sarki { string metalozellik; metalsarki(string isim,string sanatci,string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void oynat() { system.out.println(""[metal] ""+sanatci+"" - ""+isim+"" (""+metalozellik+"")""); } void gostermetalozellikleri() { system.out.println(metalozellik); } } public class rocksarki extends sarki { string rockozellik; rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; this.rockozellik = ""huzurlu ve nostaljik""; } void oynat() { system.out.println(""[rock] ""+sanatci+"" - ""+isim+"" (""+rockozellik+"")""); } } import java.util.list; public class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { boolean[] calindi = new boolean[sarkilistesi.size()]; while(!bitti(calindi)) { int sayi = (int)(math.random()*sarkilistesi.size()); sarki sarki = sarkilistesi.get(sayi); if(!calindi[sayi]) { sarki.oynat(); calindi[sayi] = true; } } } public boolean bitti(boolean[] calindi) { for(boolean sarkicalindi : calindi) if(!sarkicalindi) return false; return true; } } import java.util.list; public class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) sarki.oynat(); } } abstract class sarki { string isim; string sanatci; abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { boolean rockcaliyor = false; for (sarki sarki : sarkilistesi) { if(sarki instanceof rocksarki && !rockcaliyor) { system.out.println(""[bilgi] ses duzeyi: yuksek""); rockcaliyor = true; } else if(!(sarki instanceof rocksarki) && rockcaliyor) { system.out.println(""[bilgi] ses duzeyi: normal""); rockcaliyor = false; } sarki.oynat(); } } } import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } ""recursion"" kavramı nedir, kısaca açıklayınız. bir metodun tekrar tekrar kendini çağırması recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. metottan çıkabilmek için en temel çözüm olan base case, jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. jvm için normal bir metottan farksız olarak çalışır int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. iteratif olarak daha verimli olduğunu düşünüyorum çünkü tekrar tekrar değişken oluşturmak yerine bir değişkeni sürekli değiştirmek daha verimli olacaktır bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? string boş olduğunda metottan çıkacak şekilde stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack bellekte metot değişkenlerinin bulunduğu bölgedir, çok sayıda değişken oluşturulması sonucu overflow olur, örneğin recursive bir metodun base case'e hiç girmemesi buna sebep olabilir tail recursion nedir, kısaca açıklayınız. recursive metodun yaptığı işlemin sonucunun en sonda tekrar geri geri gelmek yerine direkt return edilmesi abstraction kavramını açıklayınız. gerekli verileri kullanıp önemli olmayanları göz ardı etmek dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür ancak tersi mümkün değildir çünkü her hourlyemployee aynı zamanda bir employee'dir ancak her employee bir hourlyemployee değildir. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? her class parent classının özelliklerini taşımak durumundadır java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? mümkün değildir java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a'nın b'nin subclassı olup olmadığını kontrol eder, eğer true dönüyor ise a classı b'nin bir subclassıdır metot overriding ve overloading kavramlarını açıklayınız. override= parent classtaki bir metot ile aynı signature'a sahip ancak farklı işlemler yapacak bir metot yazmak, overloading=parent class'taki bir metot ile aynı isme sahip fakat farklı parametreleri alan bir metot yazmak class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? 1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? parent 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? metot override edilmiş ise dynamic binding, yoksa static binding yapılır java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? bu metotlar override edilemeyeceğinden ötürü her zaman static binding ile bağlanırlar overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloading -> static binding overriding -> dynamic binding overload edilmiş bir metot çalışırken compile zamanında hangisinin çalışacağı bellidir ancak override edilmiş bir metot için hangi kod parçasının çalışacağı program çalıştırılırken belirlenir dinamik bağlamada jvm'nin görevi nedir? objeye en yakın olan override'ı bulup o metodu çalıştırmak java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? b, a'nın subclass'ı olsun. her b objesi aynı zamanda bir a olduğundan upcasting yaparken sorun yaşanmaz ancak her a objesi aynı zamanda b olmak zorunda değildir bu sebeple downcasting yapılırken sorun yaşanır java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? - class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child dinamik bağlama class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book dinamik bağlama java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class en az bir metodu abstract olan classtır. bu metodun ne yapacağı belli olmadığından abstract class objesi oluşturulamaz. abstract class ve interfacelerin objesi oluşturulamadığından constructoru olmasının bi anlamı yoktur. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? abstract a classı olsun. abstract b extends a classı olsun. a'daki bir abstract metodu b'de implement edip b'de başka bir abstract metot yazarsak hem abstractlığını bozmamış oluruz hem de parent classından aldığı abstract metodu implement etmiş oluruz. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract classları bir reference type olarak kullanabiliriz. abstract metotlar parent classta gerekli olmayan ancak subclasslarda override edilecek metotları çağırmamızı sağlar abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract classlar tip olarak kullanılabilirken interfaceler tip olarak kullanılamaz marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker=işlevi yok,sınıflandırma vs. amaçlı functional=metotları, değişkenleri bulunur bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet evet abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abstract classın objesi oluşturulmaya çalışılmış, mümkün değildir. shape c = new circle(); şeklinde yazılmalıydı. output : drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? hayır, hangi metodun çalışacağı belli değildir. super.show(); yerine a.show(); ya da b.show(); yazılmalıdır. bunlara göre output: a -ya da- b olur. java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. run-time exception = outofboundexception java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? override ederken bir üstteki metottan daha genel veya farklı tür bir exception atamayız. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally bloğu exception atılsa da atılmasa da en sonda çalışır java'da kendi exceptionunuzu nasıl tanımlarsınız? exception e = new exception(); ile yeni exception objesi oluşturulabilir, class myexception extends exception ile yeni bir exception classı oluşturulabilir java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? o metodun çağırıldığı diğer metotların da bu exception karşısında yapması gereken işlemler vardır, onların da görebilmesi için tekrar aynı exception fırlatılabilir. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done -1 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? 2 tane catch bloğu olduğu ve exception türü ikisine de uyduğu için hangisini çalıştıracağını bilemez, ikisinden biri silinirse kod çalışacaktır. output da buna göre trying m1 caugth1 ya da trying m1 caught2 olabilir. bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true import java.util.arraylist; // çınar şahin 241101012 public class lab2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); factory.work(); factory.printfactory(); factory.chargeallrobots(); factory.printfactory(); string s = ""a1b2""; printall(s,0); } public static void printall(string s,int index) { if(index+1==s.length()) { system.exit(0); } else if(s.charat(index)>64 & s.charat(index)<91) { system.out.println(s.substring(0, index+1).tolowercase() + s.substring(index+1)); } else if(s.charat(index)>96 & s.charat(index)<123) { system.out.println(s.substring(0, index+1).touppercase() + s.substring(index+1)); } else system.out.println(s); printall(s,index+1); } } class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public robot() { name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } public robot(string name,string type,int batterylevel) { this.name = name; this.type = type; this.batterylevel = batterylevel; isoperational = true; } public string getname() { return new string(name); } public string gettype() { return new string(type); } public int getbatterylevel() { int x = batterylevel; return x; } public boolean getisoperational() { boolean x = isoperational; return x; } public void setname(string name) { this.name = name; } public void settype(string type) { this.type = type; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public void setisoperational(boolean isoperational) { this.isoperational = isoperational; } public void charge() { batterylevel = 100; } public void printrobot() { system.out.print(""robot name: ""+name); system.out.print("" robot type: ""+type); system.out.print("" battery level: ""+batterylevel+""%""); system.out.println("" operational?: ""+isoperational); } } class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name,string location) { this.name = name; this.location = location; robots = new arraylist<robot>(); } public factory() { name = ""factory1""; location = ""moon""; robots = new arraylist<robot>(); } public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for(robot robot : robots) robot.setbatterylevel(100); } public void printfactory() { system.out.print(""factory name: ""+name); system.out.println("" location: ""+location); system.out.println(""robots operating here:""); for(robot robot : robots) robot.printrobot(); system.out.println(); } public void work() { for(robot robot : robots) { robot.setbatterylevel(robot.getbatterylevel()-15); if(robot.getbatterylevel()<0) robot.setbatterylevel(0); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public int getbatterylife() { return batterylife; } public void recharge() { batterylife = 150; } public boolean hasenoughbattery() { return batterylife >= 10; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""produced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(); robotfactory.gettotalrobots(); } } public class securityrobot extends abstractrobot { private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname,batterylife); this.isarmed = isarmed; } public void performtask() { if(hasenoughbattery()) { system.out.println(""[""+modelname+""]""+"" scanning for threats... armed: ""+isarmed); batterylife -= 10; } else system.out.println(""[""+modelname+""]""+"" not enough battery to scan threats...""); } public void togglearmedmode() { if(isarmed) system.out.println(""security robot - ""+modelname+"" is now unarmed""); else system.out.println(""security robot - ""+modelname+"" is now armed""); isarmed = !isarmed; } protected boolean getisarmed() { return isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname,batterylife); this.cleaningpower = cleaningpower; } public void performtask() { if(hasenoughbattery()) { system.out.println(""[""+modelname+""]""+"" cleaning in progress... cleaning power: ""+cleaningpower); batterylife -= 10; } else system.out.println(""[""+modelname+""]""+"" not enough battery to clean...""); } public void boostcleaningpower(int miktar) { cleaningpower += miktar; system.out.println(""cleaningrobot - ""+modelname+"" now has cleaning power: ""+cleaningpower); } protected int getcleaningpower() { return cleaningpower; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; private static int totalrobots; public robotfactory() { this.robots = new arraylist<abstractrobot>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname,batterylife,cleaningpower)); totalrobots++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname,batterylife,isarmed)); totalrobots++; } public void performalltasks() { for(abstractrobot robot : robots) robot.performtask(); } public void displayrobots() { for(abstractrobot robot : robots) if(robot instanceof cleaningrobot) system.out.println(""cleaningrobot - model: ""+robot.modelname+"",""+"" battery: ""+robot.batterylife+"",""+"" cleaning power: ""+ ((cleaningrobot) robot).getcleaningpower()); else system.out.println(""securityrobot - model: ""+robot.modelname+"",""+"" battery: ""+robot.batterylife+"",""+"" armed: ""+ ((securityrobot) robot).getisarmed()); } public void upgradecleaningrobots(int miktar) { for(abstractrobot robot : robots) if(robot instanceof cleaningrobot) ((cleaningrobot) robot).boostcleaningpower(miktar); } public void togglesecurityrobotsmode() { for(abstractrobot robot : robots) if(robot instanceof securityrobot) ((securityrobot) robot).togglearmedmode(); } public static void gettotalrobots() { system.out.println(""tum fabrikalar tarafindan toplam ""+totalrobots+"" robot uretildi""); } } 0",36979,4542,639,213,45,19
9905145,1,"9905145 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class soru3 { public static void main(string[] args) { count s1 = new count(""10001""); count s2 = new count(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } class count{ public string numbers; public count(string str) { this.numbers = str; } public int say() { if(numbers.length() == 0) { return 0; } if(numbers.charat(0) == '1') { numbers = numbers.substring(1); return 1 + say(); } else { numbers = numbers.substring(1); return say(); } } } public class soru2 { public static void main(string[] args) { int[] arr = {5,4,1,2}; cocktailsort(arr); } public static void cocktailsort(int[] arr) { int count = 0; for(int i = 0; i < arr.length-1; i++) { if(arr[i] > arr[i+1]) { int temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; count++; } } if(count == 0) { for(int j = 0; j < arr.length; j++) { system.out.print(arr[j]); } } else { cocktailsort(arr); } } } public class soru1 { public static void main(string[] args) { int x = 5; system.out.println(collatz(x)); } public static int collatz(int i) { if(i == 1) { return 0; } else if ( i % 2 == 0) { return 1 + collatz(i/2); } else { return 1 + collatz((i*3) + 1); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { if(s instanceof karisikcalma) { strateji = new karisikcalma(); } else if(s instanceof siralicalma) { strateji = new siralicalma(); } else if(s instanceof rockcuozelcalma) { strateji = new rockcuozelcalma(); } } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki) { sarki.oynat(); } } } } public class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci) { super(isim,sanatci); } void gosterklasikozellikleri() { this.isim = isim; this.sanatci = sanatci; } @override public void oynat() { system.out.println(""[klasik]"" + sanatci + "" "" + isim + ""(hafif ve sakin)""); } } public class metalsarki extends sarki { string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(isim,sanatci); } void gostermetalozellikleri() { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; system.out.println(metalozellik); } @override public void oynat() { system.out.println(""[metal]"" + sanatci + "" "" + isim + ""("" + metalozellik + "")""); } } public class rocksarki extends sarki{ public rocksarki(string isim, string sanatci) { super(isim,sanatci); } void gosterrockozellikleri() { this.isim = isim; this.sanatci = sanatci; } @override public void oynat() { system.out.println(""[rock]"" + sanatci +"" ""+ isim + ""(huzurlu ve nostaljik)""); } } import java.util.list; import java.util.random; public class karisikcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { int x = 0; int i = 0; while(i<sarkilistesi.size()) { x = (int) (math.random()*5+0); sarkilistesi.get(x).oynat(); i++; } } } import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for(int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); } } } abstract class sarki { string isim; string sanatci; public sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } public abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { for(int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); } } } import java.util.list; public interface calmastratejisi { public abstract void cal(list<sarki> sarkilistesi); } abstraction kavramını açıklayınız. bize gerektigi kadariyla görmek geri kalanini önemsememek (blackbox) dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? evet mumkundur employee, hourlyemp in ata classidir o yuzden hourlyemp de bir employedir ancak tam tersi mumkun degil protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier daha yakindir(default) çünkü package ve classtan erisimi var java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? ata class daki verileri kullanmak icin super olmasi gerekiyor ve her class en sonunda objecte baglandigi icin super olmasi gerek java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? edemez çünkü b ve c nin ortak ozellikleri var ise b c yi extend ederdi veya c b yi ederdi java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a ve b nin birbirinin alt classi olup olmadigini kontrol eder metot overriding ve overloading kavramlarını açıklayınız. metot overriding ayni ismi ve parametreleri kullanan 2 metotu kasteder, overloading ise ayni ismi kullanan ancak farkli parametreleri olan metotlari kasteder class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? base1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? parent30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? sonradan degistirmek istiyorsan dynamic kullanmamiz gerek (overwriting), static icindekileri sonradan degistiremiyoruz java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? overwriting yapilamadiklari icin static ile baglanirlar(üçününde ortak ozelligi) overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overridingde dynamic, loadingde static ve dynamic dinamik bağlamada jvm'nin görevi nedir? overwriting yazilan metotlari ve classlari kontrol etmesi, hangisinin kullanilacagina karar verilmesi java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? java otomatik olarak upcastingi gerceklestirir ancak bunun downcasting olarak algilanmasi icin parantez icinde bunu belirtmemiz gerek java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? kullandigimiz seyler daha onceden yaratilmadigindan onlari kullanmak mumkun olmazdi veya bütün olarak düzgün bir siraya koymamiz gerekirdi runtimeda oluşup kullanilmasi icin class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? parent statik baglama class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book dinamik baglama java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract sonradan degistirilebilen, ici sonradan doldurulabilen classlar icin kullanilir. evet olabilir abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? edilebilir, abstract metotismi(parametreler) seklinde yazabiliyoruz abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. sonradan degistirilebilme, overwrite, farkli yerlerde farklı kullanimlar abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interfaceler tip olarak kullanilabilir ancak abstract kullanilamaz. myinterface obj2 mumkundur marker interface ve functional interface kavramları nedir, nasıl kullanılır? - bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? iki sorunun cevabida evet abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? c.draw() obje shape de acildigi icin calismiyor bu yuzden circle c = new circle() yaparsak output: drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? super.show metodunun a ve b interfacelerinden hangisini sececegi belirsiz bu yuzden compile etmez,o yuzden c implements a diye duzeltirsek output: a java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 2, checked ve unchecked java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? throws komudu icin atilan seyin throwable olmasi gerekiyor, override edilen metotlara sirayla bakmak gerekir finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally bolugu scan gibi sonrasinda kapanmasi gereken metodlari kapatmak icin kullanilabilir, finally blogu her durumda çalışır java'da kendi exceptionunuzu nasıl tanımlarsınız? yazdigimiz classi extends exception yaparak java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? sorunu tam olarak cozebilmek icin tekrar firlatilmasi gerekiyor olabilir, veya baska bir yerde hataya sebep olup olmadigina bakmak icin static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finalyy oops done static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenir ancak catch blogunda en uste exception u koydugumuz icin altindaki ioexception hicbir sey yakalayamaz(exception daha genel oldugu icin kendisi tutar) trying m1 caught 1 finally bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class lab2q1 { public static void main(string[] args) { string str = ""a1b2""; int y = 2*uzunluk(str); sort(str,y); // sonuncusu neden null dönüyor çözemedim, ilk başta yanlış anladığım tarafı yorum satına alıp // aşağısına başka bir çözüm yapmak zorunda kaldım } /*public static string sort(string str) { if(str.length() == 0) { return """"; } else { int x = str.charat(0); if(x <= 9) { str = str.substring(1); } } if(str.length() != 0) { string s1 = str.substring(0,1); string s2 = str.substring(1); char a = str.charat(0); int b = (int) a; if(b < 97) { s1.tolowercase(); } else if(b > 97) { s1.touppercase(); } str = s1 + s2; } return""""; } */ public static int uzunluk(string str) { string str1 = str.touppercase(); int x = 0; for(int i = 0; i < str.length(); i++) { if(str1.charat(i) >= 65 && str1.charat(i) < 97) { x++; } } return x; } public static void sort(string str, int y) { string[] arr = new string[y]; arr[0] = str; int t = 1; for(int i = 1; i < y+1; i++) { if(str.charat(i-1) >= 65 && str.charat(i-1) < 97) { string str2 = str.tolowercase(); string s1 = str.substring(0,i-1); string s2 = str2.substring(i-1,i); string s3 = str.substring(i); arr[t] = s1 + s2 + s3; t++; } else if(str.charat(i-1) >= 97) { string str3 = str.touppercase(); string s1 = str.substring(0,i-1); string s2 = str3.substring(i-1,i); string s3 = str.substring(i); arr[t] = s1 + s2 + s3; t++; } } for(int i = 0; i < y; i++) { system.out.print(arr[i] + "" ""); } } } import java.util.arraylist; public class lab2q2 { public static void main(string[] args){ factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public void charge() { this.batterylevel = 100; } robot() { this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } robot(string name, string type, int batterylevel) { isoperational = true; } public void printrobot() { system.out.println(""robot name: ""+name+""robot type: ""+type+""batterylevel: ""+batterylevel+""isoperational: ""+isoperational); } } class factory extends robot { private string name; private string location; private arraylist<robot> robots; public factory(string name, string location) { } public factory(){ this.name = ""factory1""; this.location = ""moon""; } public void addrobot(robot robot) { //arraylist kullanımını bilmediğim için oluşan robotları burda ekleyemiyorum } public void chargeallrobots() { //super.batterylevel = 100 yapmam gerekiyor ama aynı şekil arraylisti bilmiyorum } public void printfactory() { system.out.println(""factory name: "" + name + "" location: "" + location); system.out.println(""robots operating here:""); //system.out.println(""robot name: ""+ +""type: ""+ +""battery level: ""+ +""isoperational: ""+); } public void work() { } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot { protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { } public string getmodelname() { return this.modelname = modelname; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz system.out.println(""\ntoplam üretilen robot sayısı:""); factory.toplamroboturetimi(); } } public class securityrobot extends abstractrobot { private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname,batterylife); this.modelname = modelname; this.batterylife = batterylife; this.isarmed = isarmed; } @override public void performtask() { if(batterylife >= 10) { system.out.println(""["" + modelname + ""]"" + ""scanning for threats..."" + ""armed: "" + isarmed); batterylife -= 10; } else { system.out.println(""["" + modelname + ""]"" + ""not enough battery to scan threats...""); } } public void togglearmedmode() { if(!isarmed) { isarmed = true; } else if(isarmed) { isarmed = false; } } public string getmodelname() { return this.modelname = modelname; } public int getbatterylife() { return this.batterylife = batterylife; } public boolean getisarmed() { return this.isarmed = isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname,batterylife); this.modelname = modelname; this.batterylife = batterylife; this.cleaningpower = cleaningpower; } @override public void performtask() { if(batterylife >= 10) { system.out.println(""["" + modelname + ""]"" + ""cleaning in progress..."" + ""cleaning power: "" + cleaningpower); batterylife -= 10; } else { system.out.println(""["" + modelname + ""]"" + ""not enough battery to clean...""); } } public string getmodelname() { return this.modelname = modelname; } public int getbatterylife() { return this.batterylife = batterylife; } public int getcleaningpower() { return this.cleaningpower = cleaningpower; } public void boostcleaningpower() { cleaningpower += 10; } } import java.awt.*; import java.util.arraylist; import java.util.list; public class robotfactory { private arraylist<abstractrobot> robots; robotfactory() { robots = new arraylist<>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { cleaningrobot cleaningrobot = new cleaningrobot(modelname,batterylife,cleaningpower); robots.add(cleaningrobot); } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { securityrobot securityrobot = new securityrobot(modelname,batterylife,isarmed); robots.add(securityrobot); } public void performalltasks() { for(int i = 0; i < robots.size(); i++) { if (robots.get(i) instanceof cleaningrobot) { robots.get(i).performtask(); } else if(robots.get(i) instanceof securityrobot) { robots.get(i).performtask(); } } } public void displayrobots() { for(int i = 0; i < robots.size(); i++) { if (robots.get(i) instanceof cleaningrobot) { string modelname = robots.get(i).getmodelname(); int batterylife = ((cleaningrobot) robots.get(i)).getbatterylife(); int cleaningpower = ((cleaningrobot) robots.get(i)).getcleaningpower(); system.out.println(""cleaningrobot - model: "" + modelname + ""battery: "" + batterylife + ""cleaning power: "" + cleaningpower); } else if(robots.get(i) instanceof securityrobot) { string modelname = robots.get(i).getmodelname(); int batterylife = ((securityrobot) robots.get(i)).getbatterylife(); boolean isarmed = ((securityrobot) robots.get(i)).getisarmed(); system.out.println(""securityrobot - model: "" + modelname + ""battery: "" + batterylife + ""armed: "" + isarmed); } } } public void upgradecleaningrobots() { for(int i = 0; i < robots.size(); i++) { if (robots.get(i) instanceof cleaningrobot) { ((cleaningrobot) robots.get(i)).boostcleaningpower(); } } } public void togglesecurityrobotsmode() { for(int i = 0; i < robots.size(); i++) { if (robots.get(i) instanceof securityrobot) { ((securityrobot) robots.get(i)).togglearmedmode(); } } } public void toplamroboturetimi() { system.out.println(""tüm fabrikalar tarafından toplam "" + robots.size() + "" robot üretildi""); } } 1",36512,4715,670,222,44,35
5902250,3,"5902250 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class cocktailshakersort { private static boolean yon = false; public static void main(string[] args) { int[] arr = {5,4,1,2}; cocktailsort(arr); system.out.print(""sorted array: ""); for(int i = 0; i < arr.length; i++) { system.out.print(arr[i] + "" ""); } } public static int[] cocktailsort(int[] arr) { if(issorted(arr)) { return arr; } if(yon) { for(int i = 0; i < arr.length-1; i++) { if(arr[i] > arr[i+1]) { int temp = arr[i+1]; arr[i+1] = arr[i]; arr[i] = temp; } } } else { for(int i = arr.length-1; i > 1; i--) { if(arr[i] < arr[i-1]) { int temp = arr[i-1]; arr[i-1] = arr[i]; arr[i] = temp; } } } yon = !yon; return cocktailsort(arr); } public static boolean issorted(int[] arr) { for(int i = 0; i < arr.length-1; i++) { if(arr[i] > arr[i+1]) return false; } return true; } } import java.util.scanner; public class collatz { static int count = 0; public static void main(string[] args) { scanner scan = new scanner(system.in); system.out.print(""enter a number: ""); int number = scan.nextint(); collatz(number); system.out.print(""the result is: "" + count); scan.close(); } public static int collatz(int i) { if(i == 1) { return 1; } count++; if(i%2 == 0) { return collatz(i/2); } else { return collatz(3*i + 1); } } } public class sayac { string word; int birler, index; sayac(string word){ this.word = word; this.birler = 0; this.index = 0; } int say() { if(word.charat(index) == '1') { birler++; } if(index == word.length()-1) { return birler; } index++; return say(); } public static void main(string[] args) { sayac s1 = new sayac(""110000111""); system.out.println(s1.say()); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 package lab2; import java.util.list; public class muzikcalar { private calmastratejisi strateji; void setstrateji(calmastratejisi s) { this.strateji = s; } void muzikcal(list<sarki> sarkilistesi) { this.strateji.cal(sarkilistesi); } } package lab2; import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { // bu kismi cikti ornegini saglayacak sekilde doldurun if(sarki instanceof metalsarki) { system.out.println(sarki.getartist() + ""-"" + sarki.getname() + ""[ozellik: "" + ((metalsarki) sarki).getozellik() + ""]""); } } } } package lab2; public class klasiksarki extends sarki{ private string klasikozellik; klasiksarki(string isim, string sanatci, string klasikozellik){ this.isim = isim; this.sanatci = sanatci; this.klasikozellik = klasikozellik; } public klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; this.klasikozellik = ""hafif ve sakin""; } void gosterklasikozellikleri() { system.out.println(""("" + this.klasikozellik + "")""); } @override void oynat() { system.out.print(""[klasik] "" + this.sanatci + "" - "" + this.isim); gosterklasikozellikleri(); } string getozellik(){ return this.klasikozellik; } string getname() { return this.isim; } string getartist() { return this.sanatci; } } package lab2; public class metalsarki extends sarki { private string metalozellik; metalsarki(string isim, string sanatci, string metalozellik){ this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } metalsarki(string isim, string sanatci){ this.isim = isim; this.sanatci = sanatci; this.metalozellik = ""bagiranadamlar""; } void gostermetalozellikleri() { system.out.println(""("" + this.metalozellik + "")""); } @override void oynat() { system.out.print(""[metal] "" + this.sanatci + "" - "" + this.isim); gostermetalozellikleri(); } string getozellik(){ return this.metalozellik; } string getname() { return this.isim; } string getartist() { return this.sanatci; } } package lab2; public class rocksarki extends sarki { private string rockozellik; rocksarki(string isim, string sanatci, string rockozellik){ this.isim = isim; this.sanatci = sanatci; this.rockozellik = rockozellik; } rocksarki(string isim, string sanatci){ this.isim = isim; this.sanatci = sanatci; this.rockozellik = ""huzurlu ve nostaljik""; } void gosterrockozellikleri() { system.out.println(""("" + this.rockozellik + "")""); } @override void oynat() { system.out.print(""[rock] "" + this.sanatci + "" - "" + this.isim); gosterrockozellikleri(); } string getozellik(){ return this.rockozellik; } string getname() { return this.isim; } string getartist() { return this.sanatci; } } package lab2; import java.util.collections; import java.util.list; public class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { collections.shuffle(sarkilistesi); for(int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); } } } package lab2; import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for(int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); } } } package lab2; public abstract class sarki { string isim; string sanatci; abstract void oynat(); //getter ve setter'lar serbest brakld. abstract string getname(); abstract string getartist(); abstract string getozellik(); } package lab2; import java.util.list; public class rockcuozelcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { boolean lastwasrock = false; for(int i = 0; i < sarkilistesi.size(); i++) { sarki siradakisarki = sarkilistesi.get(i); if(lastwasrock) { if(siradakisarki instanceof rocksarki) { siradakisarki.oynat(); } else { system.out.println(""[bilgi] ses duzeyi: normal""); siradakisarki.oynat(); lastwasrock = false; } } else { if(siradakisarki instanceof rocksarki) { system.out.println(""[bilgi] ses duzeyi: yksek""); lastwasrock = true; } siradakisarki.oynat(); } } } } package lab2; import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } ""recursion"" kavramı nedir, kısaca açıklayınız. bir işlemi tekrar tekrar çağırarak problemleri adım adım çözmektir recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. i̇stenen sonuca ulaşılıp ulaşılmadığını kontrol eden bir kod parçası ve eğer hedefe ulaşılmadıysa “parçalar” üzerinde istenen işlemi yapan kısım. jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. bir stack üzerinde tekrar tekrar yeni işlemler açıyor, sonsuz/beklenenden uzun recursive döngüye girildiğinde ise stackoverflow ile çıkış yapıyor int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. her iki şekilde de yapılabilir fakat iteratif olarak daha verimlidir. i̇teratif yolla basit şekilde yapılabilen kodlar recursive yapılırsa kod verimsiz çalışabilir. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? if(str.length() == 1) stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack, işlemlerin ayrı ayrı, kabaca üst üste konulduğu ve ayrı ayrı çalıştırıldığı hafızadır. bu hafızaya çok fazla işlem girerse overflow olur. örnek sonsuz recursion tail recursion nedir, kısaca açıklayınız. - abstraction kavramını açıklayınız. hide states, reveal behaviour. gerekli olan bilgileri paylaşırken diğer bilgileri saklamak. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür fakat tersi mümkün değildir. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? default, no modifier java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? nasıl her aslan bir hayvansa, her child class kendi super classına üyedir. super class nesnesi oluşturmak zorundadır. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a, b classı veya b’den türetilmiş bir class demektir. metot overriding ve overloading kavramlarını açıklayınız. override, metodun yaptığı işi, ismini, return type’ını, signature’ını tamamiyle yeni yazacağımız kodla değiştirmek demek. overload ise, metodun sadece signature’ını değiştirebildiğimiz ve içine yeni kod yazabildiğimiz bir yöntem. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? base class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? parent 1020 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? static binding, compile time’da; dynamic binding ise runtime’da gerçekleşir. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? sonradan @override edilmeleri gibi bi durum yoktur. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overload static, @override ise runtime’da gerçekleşir. metod overload edildiğinde metodu nereden çağıracağımız, signature’dan bellidir. fakat override işinde java, tek tek kodu gezer, kodu bağlayan en son @override şeklini bulur. bulamazsa bulduğunu çağırır. onu da bulamazsa yapacak bişey yok dinamik bağlamada jvm'nin görevi nedir? kodu gezip, çağırılan elemanın nerede çağırıldığına bağlı olarak, bir scope dahilinde adım adım o elemanı aramaktır. java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? türkçe anlatırsak, her aslan bir hayvandır ve hayvanların her özelliğini gösterir. fakat her hayvan aslan değildir. bir aslan objesi oluşturduğumuzda aslan olmanın her özelliğini yerine getirmesini bekleriz fakat heap’te hayvan objesine bağlarsak, hayvan sınıfı, aslan sınıfının gerektirdiklerini karşılayamaz. aslan daha detaylıdır çünkü. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? kodumuzu başlatmak, çalıştırmak hep uzun sürerdi. class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child. dinamik bağlama var. class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book i̇lk objede statik, ikinci objede dinamik bağlama var. robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 package quiz2; interface withbattery { int getbatterylife(); void recharge(); } package quiz2; public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return this.modelname; } public abstract void performtask(); public void recharge() { if(this.batterylife < 100) this.batterylife = 100; else this.batterylife += 10; } } package quiz2; public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""produced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.gettotalproduction(); // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } package quiz2; public class securityrobot extends abstractrobot { private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } @override public void performtask() { if(this.batterylife >= 10) { system.out.println(""["" + this.getmodelname() + ""] scanning for threats...armed: "" + this.getar()); this.batterylife -= 10; } else { system.out.println(""["" + this.getmodelname() + ""] not enough battery to scan threats...""); } } public void togglearmedmode() { this.isarmed = !this.isarmed; system.out.println(""securityrobot - "" + this.getmodelname() + "" is now "" + this.strarmed()); } public boolean getar() { return this.isarmed; } @override public int getbatterylife() { return this.batterylife; } public string strarmed() { if(this.isarmed) return ""armed""; return ""unarmed""; } } package quiz2; public class cleaningrobot extends abstractrobot { private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } @override public void performtask() { if(this.batterylife >= 10) { system.out.println(""["" + this.getmodelname() + ""] cleaning in progress...cleaning power: "" + this.getcp()); this.batterylife -= 10; } else { system.out.println(""["" + this.getmodelname() + ""] not enough battery to clean...""); } } public void boostcleaningpower(int miktar) { this.cleaningpower += miktar; system.out.println(""cleaningrobot - "" + this.getmodelname() + "" now has cleaning power: "" + this.getcp()); } public int getcp() { return this.cleaningpower; } @override public int getbatterylife() { return this.batterylife; } } package quiz2; import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; static int toplamroboturetimi = 0; // bu ekilde ???'ni hallettim. robotfactory() { this.robots = new arraylist<abstractrobot>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); toplamroboturetimi++; // byle } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); toplamroboturetimi++; // byle } public void performalltasks() { for(abstractrobot robot : robots) robot.performtask(); } public void displayrobots() { for(abstractrobot robot : robots) { if(robot instanceof cleaningrobot) { cleaningrobot cr = (cleaningrobot) robot; system.out.println(""cleaningrobot - model: "" + cr.getmodelname() + "", battery: "" + cr.getbatterylife() + "", cleaning power: "" + cr.getcp()); } else if(robot instanceof securityrobot) { securityrobot sr = (securityrobot) robot; system.out.println(""securityrobot - model: "" + sr.getmodelname() + "", battery: "" + sr.getbatterylife() + "", armed: "" + sr.getar()); } } } public void upgradecleaningrobots(int miktar) { for(abstractrobot robot: robots) { if(robot instanceof cleaningrobot) { cleaningrobot cr = (cleaningrobot) robot; cr.boostcleaningpower(miktar); cr.recharge(); } } } public void togglesecurityrobotsmode() { for(abstractrobot robot: robots) { if(robot instanceof securityrobot) { securityrobot sr = (securityrobot) robot; sr.togglearmedmode(); sr.recharge(); } } } public static void gettotalproduction() { system.out.println(""tum fabrikalar tarafindan "" + toplamroboturetimi + "" robot uretildi""); } } 3",30238,3814,536,167,34,27
4810237,2,"4810237 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. package collatz; import java.util.scanner; public class main { static int adim_sayisi=0; public static int collatz(int i) { if(i==1){ return adim_sayisi; } if(i%2==0) { i/=2; adim_sayisi++; collatz(i); } else { i=i*3+1; adim_sayisi++; collatz(i); } return adim_sayisi; } public static void main(string[] args) { system.out.println(""sayı giriniz""); scanner scanner=new scanner(system.in); int sayi=scanner.nextint(); if(sayi<=0) { system.out.println(""geçersiz sayı""); } else { system.out.println(sayi+"" sayısı ""+collatz(sayi)+"" adımda 1 sayısına dönüyor""); } } } package coctail; public class main { static int i=0; static int j=1; static int k=0; public static void cocktailsort(int[] arr) { if(dogrumu(arr)==1){ system.out.println(arr); } else { while(arr[j]<arr[arr.length]) { if(arr[i]>arr[j]){ int gecici=arr[i]; arr[i]=arr[j]; arr[j]=gecici; i=j; j++; cocktailsort(arr); } else { j++; cocktailsort(arr); } } i=0; j=1; cocktailsort(arr); } } public static int dogrumu(int []dizi) { while(dizi[k]<dizi[dizi.length]) { if(dizi[k]>dizi[k+1]) { return -1; } else { k++; dogrumu(dizi); } } return 1; } public static void main(string[] args) { int [] dizi= {5,4,1,2}; cocktailsort(dizi); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 package muzikcalar; import java.util.list; public class muzikcalar { muzikcalar() { } private calmastratejisi strateji; void setstrateji(calmastratejisi s) { strateji=s; } void muzikcal(list<sarki> sarkilistesi) { if(strateji.equals(new siralicalma())) { for (sarki sarki : sarkilistesi) { system.out.println(""[""+sarki.getclass()+""] ""+sarki.getsanatci()+"" - ""+sarki.getisim()); } } } else if(strateji.equals(new karisikcalma())) { sarkilistesi.listiterator(); system.out.println(sarkilistesi); } else { } } } package muzikcalar; public class main { } package muzikcalar; public class klasiksarki extends sarki { klasiksarki(string isim, string sanatci) { super(isim,sanatci); } void gosterklasikozellik() { system.out.println(""[""+sarki.); } } package muzikcalar; public class metalsarki extends sarki { private string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { super(isim,sanatci); this.setmetalozellik(metalozellik); } void gostermetalozellikleri() { system.out.println(getisim()); system.out.println(getsanatci()); system.out.println(getmetalozellik()); } public string getmetalozellik() { return metalozellik; } public void setmetalozellik(string metalozellik) { this.metalozellik = metalozellik; } } package muzikcalar; public class rocksarki { } package muzikcalar; public class karisikcalma { } package muzikcalar; public class siralicalma { siralicalma() { } void.cal(){ } } package muzikcalar; public abstract class sarki { private string isim; private string sanatci; sarki(string isim, string sanatci) { this.setisim(isim); this.setsanatci(sanatci); } public void oynat() { } public string getsanatci() { return sanatci; } public void setsanatci(string sanatci) { this.sanatci = sanatci; } public string getisim() { return isim; } public void setisim(string isim) { this.isim = isim; } } package muzikcalar; public class rockcuozelcalma { } package muzikcalar; import java.util.list; public interface calmastratejisi { default void cal(list<sarki> sarkilistesi) { } } ""recursion"" kavramı nedir, kısaca açıklayınız. geçen hafta derse gelmedim bilmiyorum. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. geçen hafta derse gelmedim bilmiyorum jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. geçen hafta derse gelmedim bilmiyorum int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. geçen hafta derse gelmedim bilmiyorum bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? geçen hafta derse gelmedim bilmiyorum stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. geçen hafta derse gelmedim bilmiyorum tail recursion nedir, kısaca açıklayınız. geçen hafta derse gelmedim bilmiyorum abstraction kavramını açıklayınız. abstraction kavramı java gibi nesne tabanlı olan dillerde kullanıcılara ihtiyaçları olan kadar bilgi vermeyi sağlar. kullanıcılar sadece onlarla alakalı olan bilgilere erişebilir ve bu da karmaşıklığı önler. black box bunun en önemli örneklerinden biridir. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? bilmiyorum protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? package access private modifierına daha yakındır. erişimin en az sıralandığından en çok sıralandığına göre sıra public protected package ve private şeklindedir. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? çünkü classın constructor'unun classın java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? bilmiyorum java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a b'nin bir örneğiyse b bir nesnedir(object) ve a da b nesnesinin bir örneğidir. metot overriding ve overloading kavramlarını açıklayınız. method overloading parametreleri farklı olan metodların isimleri aynı olarak yazılabilmesidir. bu da signature'ları farklı isimleri aynı olan metotların tanımlanmasını sağlar. metot overriding ise signature'ları aynı olan metotların isimleri farklı olarak tanımlanabilmesidir. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? bilmiyorum class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? bilmiyorum java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? static binding method overloading kullanıldığı durumlarda yapılır. yani aynı sınıfta aynı isimde farklı parametrelerle metod tanımlandığında.dynamic binding ise method overriding kullanıldığı durumlarda yapılır.yani farklı classlarda aynı isimde ve parametrelerde method tanımlandığı durumlarda. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? static,private ve final metodların ortak özelliği parent classtan sub classlara aktarılmasıdır. alt classlara aktarılmadığı için metod overriding işlemi gerçekleşemez dolayısıyla dynamic bindingle bağlanamaz. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloading yaparken static binding overriding yaparken dynamic binding gerçekleşir. overloading durumlarında binding compiler aşamasında çözülür. overriding durumlarında ise run time aşamasında çözülür. dinamik bağlamada jvm'nin görevi nedir? bilmiyorum java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? bilmiyorum java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? aynı class içerisinde aynı isimle sadece parametrelerin farklı olduğu metodları tanımlayamazdık class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true package robotfactory; public class robot { private string name; private string type; private int batterylevel;// 100 ile 0 arasında bir değer private boolean isoperational; // bataryası varsa true public robot(){ name=""wall-e""; type=""trash""; batterylevel=100; isoperational=true; } public robot(string name ,string type,int batterylevel) { this.name=name; this.type=type; this.batterylevel=batterylevel; } public robot(string name ,string type,int batterylevel,boolean isoperational) { this.name=name; this.type=type; this.batterylevel=batterylevel; this.isoperational=isoperational; } public void printrobot() { system.out.print(""robot name:""+name); system.out.print(""robot type:""+type); system.out.print(""batterylevel:""+batterylevel); system.out.print(""isoperational:""+isoperational); } public boolean isoperational() { return isoperational; } public void setoperational(boolean isoperational) { this.isoperational = isoperational; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public string getname() { return name; } public void setname(string name) { this.name = name; } public void charge(int nekadar) { batterylevel+=nekadar; } } package robotfactory; public class main { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } package robotfactory; import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name, string location) { this.location=location; this.name=name; } public factory() { name=""factory1""; location=""moon""; } public void addrobot(robot robot) { robots.add(robot); } public void printfactory() { system.out.println(""factory name:""+name); system.out.println(""robots operating here:""); for(int i=0;i<robots.size();i++) { robots.get(i).printrobot(); } } public void workchargeallrobots() { for(int i=0;i<robots.size();i++) { robots.get(i).setbatterylevel(100); } } public void work() { for(int i=0;i<robots.size();i++) { robots.get(i).charge(-15); } } public arraylist<robot> getrobots() { return robots; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public string getlocation() { return location; } public void setlocation(string location) { this.location = location; } public string getname() { return name; } public void setname(string name) { this.name = name; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname=modelname; this.batterylife=batterylife; } public string getmodelname() { return modelname; } public int getbatterylife() { return batterylife; } public void recharge() { batterylife=getbatterylife(); } public abstract void performtask(); } public class securityrobot extends abstractrobot{ private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } public void performtask() { if(batterylife>=10) { system.out.println(""|""+modelname+""| scanning for threats... armed:""+isarmed); batterylife=-10; } else { system.out.println(""|""+modelname+""| not enough battery to sean threads...""); } } public void togglearmedmode() { if(isarmed==false) { isarmed=true; } else { isarmed=false; } } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } public int getcleaningpower() { return cleaningpower; } public void performtask() { if(batterylife>=10) { system.out.println(""|""+modelname+""| cleaning in progress... cleaning power:""+cleaningpower); batterylife=-10; } else { system.out.println(""|""+modelname+""| not enough battery to clean...""); } } public void boostcleaningpower(int i) { cleaningpower=+i; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { cleaningrobot a = new cleaningrobot(modelname,batterylife,cleaningpower); robots.add(a); } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { securityrobot b=new securityrobot(modelname,batterylife,isarmed); robots.add(b); } public void performalltasks() { securityrobot[] a = (securityrobot[]) robots.toarray(); for(int i=0;i<a.length;i++) { a[i].performtask(); } } public void displayrobots() { object[] a = robots.toarray(); for(int i=0;i<a.length;i++) { system.out.println(a[i]); } } public void upgradecleaningrobots(int miktar) { cleaningrobot[] a = (cleaningrobot[]) robots.toarray(); for(int i=0;i<a.length;i++) { a[i].boostcleaningpower(miktar); } } public void togglesecurityrobotsmode() { securityrobot[] a = (securityrobot[]) robots.toarray(); for(int i=0;i<a.length;i++) { a[i].togglearmedmode(); } } public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); } } 2",29880,3647,526,178,33,20
9245287,0,"9245287 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class q2 { public static void main(string[] args) { int[] a = { 5, 4, 1, 2, 6 }; cocktailsort(a); for (int x : a) system.out.println(x); } public static void helper(int i, int[] arr) { if (i + 1 == arr.length) // eger son elemana geldiysek return; if (arr[i] > arr[i + 1]) { int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } helper(i + 1, arr); } public static void helper2(int i, int[] arr) { if (i == 0) // eger ilk elemana geldiysek - base return; if (arr[i - 1] > arr[i]) { int temp = arr[i]; arr[i] = arr[i - 1]; arr[i - 1] = temp; } helper2(i - 1, arr); } public static void cocktailsort(int[] arr) { for (int i = 0; i < arr.length / 2; i++) { helper(i, arr); helper2(arr.length - 1 - i, arr); } } } public class q1 { public static void main(string[] args) { system.out.println(collatz(5)); } public static int collatz(int i) { if (i == 1) return 0; if (i % 2 == 0) return collatz(i / 2) + 1; else return collatz(3 * i + 1) + 1; } } public class q3 { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } class sayac { string s; public sayac(string s) { this.s = s; } public int say() { if (s.length() == 1) { // base condition if (s.charat(0) == '1') return 1; else return 0; } sayac d = new sayac(s.substring(1)); if (s.charat(0) == '1') return 1 + d.say(); else return d.say(); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arraylist; import java.util.arrays; import java.util.list; public class q1 { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { metalsarki m = (metalsarki) sarki; system.out.print(m.sanatci + "" - "" + m.name + "" ""); m.gostermetalozellikleri(); } } } } abstract class sarki { string name; string sanatci; abstract void oynat(); } class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { this.name = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } public void gostermetalozellikleri() { system.out.println(""[ozellik: "" + metalozellik + ""]""); } public void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + name + "" ("" + metalozellik + "")""); } } class rocksarki extends sarki { rocksarki(string isim, string sanatci) { this.name = isim; this.sanatci = sanatci; } public void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + name + "" (huzurlu ve nostaljik)""); } } class klasiksarki extends sarki { klasiksarki(string isim, string sanatci) { this.name = isim; this.sanatci = sanatci; } public void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + name + "" (hafif ve sakin)""); } } interface calmastratejisi { void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); } } } class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { arraylist<integer> a = new arraylist<>(); for (int i = 0; i < sarkilistesi.size(); i++) { a.add(i); } for (int i = 0; i < sarkilistesi.size(); i++) { int randomnum = (int) (math.random() * (sarkilistesi.size() - i)); int index = a.get(randomnum); sarkilistesi.get(index).oynat(); a.remove(randomnum); } } } class rockcuozelcalma implements calmastratejisi { private string sesduzeyi; public rockcuozelcalma() { sesduzeyi = ""normal""; } @override public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof rocksarki) { if (!sesduzeyi.equals(""yuksek"")) { system.out.println(""[bilgi] ses duzeyi: yuksek""); } sesduzeyi = ""yuksek""; } else { if (!sesduzeyi.equals(""normal"")) { system.out.println(""[bilgi] ses duzeyi: normal""); } sesduzeyi = ""normal""; } sarkilistesi.get(i).oynat(); } } } class muzikcalar { calmastratejisi s; void setstrateji(calmastratejisi s) { this.s = s; } void muzikcal(list<sarki> sarkilistesi) { if (s instanceof karisikcalma) { new karisikcalma().cal(sarkilistesi); } else if (s instanceof siralicalma) { new siralicalma().cal(sarkilistesi); } else if (s instanceof rockcuozelcalma) { new rockcuozelcalma().cal(sarkilistesi); } } } ""recursion"" kavramı nedir, kısaca açıklayınız. bir fonksiyonun kendini çağırması recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case(olmazsa stackoverflow) kodun kendini cagiracagi kisim(recursion) jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. stackler halinde işliyor int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. iteratif daha verimlidir bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? string.substring(1) ile ilk karakteri çıkararak recursive halde cagiririm.base case string length=0 stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. memorye eklenen islemler eger ust uste ramin kaldiramayacagindan fazla stack gelirse stackoverflow olur tail recursion nedir, kısaca açıklayınız. en sonda kendini cagiran recursive fonksiyon abstraction kavramını açıklayınız. kullaniciya sadece ise yarar kadar bilgi veriyoruz. kullanicinin isine yaramayan arka planda bilgisayar tarafindan calistirilan bazi kodlar soyutlanir dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mumkundur cunku hourlyemployee bir employeedir ama tersi mumkun degil protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier(default) private daha yakindir java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? cunku classin metodlarin ve degiskenlerin duzgun calisabilmesi icin oncelikle parent classtaki degiskenler initialize edilmelidir. aksi halde parent classindan inherit ettigi bir degiskeni duzgun kullanamaz java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? mumkun degil. her classin bir tane parenti vardir ancak bir parentin birden fazla cocugu(child) olabilir java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a, b objenin turu veya subclassi mi diye bakar. yani kalitim agacinda a, b ye esit veya asagi bir classta mi. ornegin animal mammal dog diye olsa dog instance of animal true doner. metot overriding ve overloading kavramlarını açıklayınız. overriding: parentindan aldigi bir metodu ayni signatureda kalmak sartiyla yeniden yazilmasidir, polymorphisim ile iliskilidir. overload: ayni metod ismini parametrelerini degistirerek tekrar yazmaktir ornegin num(int a) ve num(int a, int b) bir overloadingtir class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? base class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? eğer programda o metottan veya degiskenden sadece bir tane varsa static binding yapilir. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? static final ve private override edilemez overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? dynamic binding gerceklesir, çünkü program çalışırken polymorphism den dolayı dinamik bağlamada jvm'nin görevi nedir? program çalışırken binding işlemini gerçekleştirmek java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? upcasting yaparken upcasting yapılan classin veya değişkenin bütün özellikleri direkt upcastlenerek aktarılabilir. ama downcasting de ise veri kaybı olabileceğinden izin verilmez. örneğin long değişkenin tuttuğu bir veriyi int her zaman tutamayacagindan explicit olarak belirtmek gerekir java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? programın çalışma zamanı artardi program yavaşlardi cost artardi class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dynamic ve output child class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract classlar daha sonra bir başka subclassta override edilip metodlarin ozellikleri subclassta tanimlanir. abstract classlarin constructori olabilir ancak direkt cagirilamaz, alt classlarin constructorina diğer aktarmak için kullanılabilir abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? evet edilebilir ancak abatract metodlarin içi boş olmali. adı üstünde soyut classlar abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. üzerinden direkt olarak object olusturulamaz, abstract metodlarin içi boş olmalıdır, subclasslarda abstract metodlar override edilmelidir abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interfaceler %100 soyut classlar iken abstract classlarin soyutluklari %0-100 arasındadır. tip olarak kullanılabilir çünkü hala onlardan object instantiate etmedik marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interfacede içinde metod bulunmazken functional interface içinde yalnızca bir tane metod bulunur. serializable bir marker interface türüdür. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? ikisi de mumkundur abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? new shape() hata verir bunun yerine shape c = new circle(); yapsak düzelir output drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? compile edilemez super.show() hata verir çünkü fonksiyon iki tane interface implement etmiş. onun yerine a.show() yazarsak çıktı a olur java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. iki çeşittir. checked ve unchecked exceptions.ornegin runtime checked exception iken compile time unchecked exception. java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? throws sadece throwable objeler için geçerlidir. method override edilirken throws yazmak zorunlu değil. eğer yazılırsa parent classin throws ettiği classa eşit veya daha alt seviyede bir exception türü yazılmalıdır. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally blogu hata olsa da olmasa da çalışır. exception atılmayan durumlarda da çalışır. java'da kendi exceptionunuzu nasıl tanımlarsınız? myexception extends throwable or myexception extends exception. yani throwable olan bir objeyi extend ederim. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? exception düzeltiğinden emin olmak. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally done -1 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? unreaceble code trying m1 bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true import java.util.arraylist; public class q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public robot() { this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public robot(string name, string type, int batterylevel) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = true; // default olarak isoperational true aldim cunku parametreli constructorda // isoperational icin bir alan verilmemis } public void printrobot() { system.out.println(""robot name: "" + name + "" type: "" + type + "" batterylevel: "" + batterylevel + ""% isoperational: "" + isoperational); } public string getname() { return name; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public boolean getisoperational() { return isoperational; } public void isoperational(boolean isoperational) { this.isoperational = isoperational; } public void charge() { this.batterylevel = 100; } } class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name, string location) { this.name = name; this.location = location; robots = new arraylist<robot>(); } public factory() { this.name = ""factory1""; this.location = ""moon""; robots = new arraylist<robot>(); } public string getname() { return name; } public void setname(string s) { name = s; } public string getlocation() { return location; } public void setlocation(string s) { location = s; } public arraylist<robot> getrobots() { return robots; } public void setrobots(arraylist<robot> r) { robots = r; } public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for (int i = 0; i < robots.size(); i++) { robots.get(i).setbatterylevel(100); } } public void work() { for (int i = 0; i < robots.size(); i++) { int b = robots.get(i).getbatterylevel(); robots.get(i).setbatterylevel(b - 15); } } public void printfactory() { system.out.println(""factory name: "" + name + "" location: "" + location); system.out.println(""robots operating here:""); for (robot r : robots) { r.printrobot(); } } } public class q1 { public static void main(string[] args) { string s = ""a1b2""; print(s, """", 0); } public static void print(string s, string sub, int ind) { if (sub.length() == s.length()) { system.out.println(sub); return; } if (s.charat(ind) <= '9' && s.charat(ind) >= '0') { print(s, sub + s.charat(ind), ind + 1); } else if (s.charat(ind) <= 'z' && s.charat(ind) >= 'a') { print(s, sub + s.charat(ind), ind + 1); string r = sub + (char) (s.charat(ind) - 32); print(s, r, ind + 1); } else if (s.charat(ind) <= 'z' && s.charat(ind) >= 'a') { print(s, sub + s.charat(ind), ind + 1); string r = sub + (char) (s.charat(ind) + 32); print(s, r, ind + 1); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; protected int initialbattery = 100; // default deger 100 alindi public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; this.initialbattery = batterylife; } public string getmodelname() { return modelname; } public void recharge() { batterylife = initialbattery; } public int getbatterylife() { return batterylife; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.mymethod(); } } public class securityrobot extends abstractrobot { private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } public void performtask() { if (batterylife < 10) { system.out.println(""["" + modelname + ""]"" + "" not enough battery to scan threats...""); } else { system.out.println(""["" + modelname + ""]"" + "" scanning for threats... armed: "" + isarmed); batterylife -= 10; } } public void togglearmedmode() { if (isarmed) { isarmed = false; system.out.println(""securityrobot - "" + getmodelname() + "" is now unarmed""); } else { isarmed = true; system.out.println(""securityrobot - "" + getmodelname() + "" is now armed""); } } public string tostring() { return ""securityrobot - model: "" + modelname + "", battery: "" + batterylife + "", armed: "" + isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); // super koymazsak hata veriyor sebebini arastir this.cleaningpower = cleaningpower; } public void performtask() { if (batterylife < 10) { system.out.println(""["" + modelname + ""]"" + "" not enough battery to clean...""); // super.modelname } else { system.out.println(""["" + modelname + ""]"" + "" cleaning in progress... cleaning power: "" + cleaningpower); batterylife -= 10; } } public void boostcleaningpower(int miktar) { cleaningpower += miktar; } public int getcleaningpower() { return cleaningpower; } @override public string tostring() { return ""cleaningrobot - model: "" + modelname + "", battery: "" + batterylife + "", cleaning power: "" + cleaningpower; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; static int totalnum = 0; public robotfactory() { robots = new arraylist<abstractrobot>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); totalnum += 1; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); totalnum += 1; } public void performalltasks() { for (int i = 0; i < robots.size(); i++) { robots.get(i).performtask(); } } public void displayrobots() { for (abstractrobot a : robots) { system.out.println(a); } } public void upgradecleaningrobots(int miktar) { for (int i = 0; i < robots.size(); i++) { if (robots.get(i) instanceof cleaningrobot) { cleaningrobot c = (cleaningrobot) robots.get(i); c.boostcleaningpower(miktar); system.out.println( ""cleaning robot - "" + c.modelname + "" now has cleaning power: "" + c.getcleaningpower()); } } } public void togglesecurityrobotsmode() { for (int i = 0; i < robots.size(); i++) { if (robots.get(i) instanceof securityrobot) { securityrobot s = (securityrobot) robots.get(i); s.togglearmedmode(); } } } public static void mymethod() { system.out.println(""tum fabrikalar tarafindan toplam "" + totalnum + "" robot uretildi""); } } 0",38188,5050,687,231,42,34
3963286,2,"3963286 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. import java.util.scanner; public class collatz { public static void main(string[] args) { scanner scan=new scanner(system.in); system.out.println(collatz(scan.nextint())); scan.close(); } public static int collatz(int i) { if(i==1) { return 0; } else if(i%2==0) { return collatz(i/2)+1; } else { return collatz(i*3+1)+1; } } } public class birler { public static void main(string[] args) { sayac s=new sayac(""10001""); system.out.println(s.say()); } } class sayac { string str; public sayac(string str) { this.str=str; } public int say() { if(str.equals("""")) { return 0; } else if(str.charat(0)=='1') { str=str.substring(1); return 1+say(); } else { str=str.substring(1); return 0+say(); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arraylist; import java.util.list; import java.util.random; public class lab2 { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi arraylist<sarki> sarkilistesi =new arraylist<>(); sarkilistesi.add(s1); sarkilistesi.add(s2); sarkilistesi.add(s3); sarkilistesi.add(s4); sarkilistesi.add(s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); ((metalsarki) s1).gostermetalozellikleri(); } } abstract class sarki { string isim; string sanatçi; abstract void oynat(); } class metalsarki extends sarki { private string metalozellik; metalsarki(string isim,string sanatçi,string metalozellik ) { this.isim=isim; this.sanatçi=sanatçi; this.metalozellik=metalozellik; } void oynat() { system.out.println(""[metal]""+sanatçi+""-""+isim+""(""+metalozellik+"")""); } public void gostermetalozellikleri() { system.out.println(sanatçi+""-""+isim+"" [özellik:""+metalozellik+""]""); } } class rocksarki extends sarki { rocksarki(string isim,string sanatçi) { this.isim=isim; this.sanatçi=sanatçi; } void oynat() { system.out.println(""[rock]""+sanatçi+""-""+isim+ ""(huzurlu ve nostaljik)""); } } class klasiksarki extends sarki { klasiksarki(string isim,string sanatçi ) { this.isim=isim; this.sanatçi=sanatçi; } void oynat() { system.out.println(""[klasi̇k]""+sanatçi+""-""+isim+"" (hafif ve sakin)""); } } interface calmastratejisi { void cal(arraylist<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { public void cal(arraylist<sarki> sarkilistesi) { for(int i=0;i<sarkilistesi.size();i++) { sarkilistesi.get(i).oynat(); } } } class karisikcalma implements calmastratejisi { public void cal(arraylist<sarki> sarkilistesi) { arraylist<sarki> fakelist=sarkilistesi; random random=new random(); while(fakelist.size()!=0) { int i=random.nextint(fakelist.size()); fakelist.get(i).oynat(); fakelist.remove(i); } } } class rockcuozelcalma implements calmastratejisi { boolean rock=true; public void cal(arraylist<sarki> sarkilistesi) { for(int i=0;i<sarkilistesi.size();i++) { if(rock&&sarkilistesi.get(i) instanceof rocksarki) { system.out.println("" [bilgi] ses duzeyi: yuksek""); sarkilistesi.get(i).oynat(); rock=true; } else if((!rock&&sarkilistesi.get(i) instanceof rocksarki)) { sarkilistesi.get(i).oynat(); } else if(!rock) { system.out.println("" [bilgi] ses duzeyi: normal""); sarkilistesi.get(i).oynat(); rock=true; } else { sarkilistesi.get(i).oynat(); } } } } class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { strateji=s; } void muzikcal(arraylist<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } ""recursion"" kavramı nedir, kısaca açıklayınız. sonuc olarak kendini dönen metoddur. bu islemi istenilen en kucuk parçaya kadar yapar. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case, recursive call kısmı jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. ramde,steak kısmında üst üste yıkarak cağırmasıyla int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. i̇teratif olarak daha verimlidir.çünkü bilgisayar recursive metodu cağirirken daha maliyetlidir. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? i̇f blogunun icinde string.length==1 kosulu saglandiginda base case olacak sekilde, 1 sayisini döner.recursive call kiminda 1+recursive(string,n+1) döner stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. ramin medot islemlerini yaptigi kismidir. eger recursiveden cikalamdiginda dolar. tail recursion nedir, kısaca açıklayınız. donulecej cevabin en sonda hesaplandigi recursion tipidir. abstraction kavramını açıklayınız. projelerimizde,sadece kullanıcıya ihtiyacı oldugu kadarıyla sisteme erisim vermektir. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür,sadece super classın metodu cocugunuda override edildiginde return type değisebilir.tersi mümkün değildir protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? ... java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? mümkün değildir,sadece bir class ,baska bir classı extend edebilir java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? seçilen atadan itibaren classların aynı olup olmadıgını kontrol eder,yani a dan itibaren bnin a nın subclassı olup olmadigini kontrol eder. metot overriding ve overloading kavramlarını açıklayınız. overloading:metodların signaturelerı farklı,yaptıkları farklı.overridingde tek farkı metodun üste extra işlevler yüklenmesidir. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? base1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? parent30 java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? soyut bir klasik ifade eder.obje olarak çağrılması ve en az bir metodu overide edilerek implement edilir. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? edilemez abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. prensiplerimizden ilan abstraction sağlaması,encapsulation ve polimorfizum sağlamı. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interfaceler absttqct classinin daha da soyutlama halidir.extra olarak interfaceler bir den fazla clasa extent edilebilirler. i̇kinci sorusu mümkündür. marker interface ve functional interface kavramları nedir, nasıl kullanılır? ... bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? i̇kisinin cevabı: edebilir olacaktır abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? c değişkenin shape üzerinden tanimladigimizdan draw metodu override edilemedi abstract olarak jaldi interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? edemez,hata java hangi iterface in metodunu alacağını bilemez hata verir.o yüzden hangi interface i kullanacagini süperdi belirtmeniz lazım. cevap hangisini belirtecegimize bağlı olark a veya b olacak java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 2 tanedir io(dosya okuma) ve run time (outofbound) java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? throws attığımızda mutlaka hatayı geri yakalamaĺıyız finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? try yapısında en sonda mutlaka yapılan işlemdir. her durumda çalışır. java'da kendi exceptionunuzu nasıl tanımlarsınız? class myexeption extend exception java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? hata oluştuğunda belili işlemleri yaptırıp ,sorunu ertelemek static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? .. bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class quziz1q1 { public static void alfanumaratik(string str) { string ilk=""""; if(str=="""") { system.out.print("" ""); } else if(str.charat(0)<='9'&&str.charat(0)>='0') { ilk+=str.charat(0); alfanumaratik(str.substring(1),ilk); } else { string s=str.charat(0)+""""; ilk+=s.tolowercase(); alfanumaratik(str.substring(1),ilk); ilk=ilk.substring(0,ilk.length()-1)+s.touppercase(); alfanumaratik(str.substring(1),ilk); } } public static void alfanumaratik(string str,string ilk) { if(str=="""") { system.out.print(ilk+"" ""); } else if(str.charat(0)<='9'&&str.charat(0)>='0') { ilk+=str.charat(0); alfanumaratik(str.substring(1),ilk); } else { string s=str.charat(0)+""""; ilk+=s.tolowercase(); alfanumaratik(str.substring(1),ilk); ilk=ilk.substring(0,ilk.length()-1)+s.touppercase(); alfanumaratik(str.substring(1),ilk); } } public static void main(string[] args) { alfanumaratik(""a1b2c""); } } import java.util.arraylist; public class quiz1q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); r1.printrobot(); } } class robot { private string name; private string type; private int batterylevel; private boolean isoperational; robot() { name=""wall-e""; type=""trash""; batterylevel=100; isoperational=true; } robot(string name,string type,int batterylevel) { this.name=name; this.type=type; this.batterylevel=batterylevel; isoperational=true; } public void charge() { batterylevel=100; } public string getname() { return name; } public string gettype() { return type; } public int getbatetery() { return batterylevel; } public boolean getoperational() { return isoperational; } public void printrobot() { system.out.println(""robot name:"" +name+"" robot type:""+type+"" batterylevel :"" +batterylevel+"" isoperationalt:"" +isoperational); } public void setname(string name) { this.name=name; } public void settype(string name) { this.type=name; } public void setbatterylevel(int name) { this.batterylevel=name; } public void setoperation(boolean name) { this.isoperational=name; } } class factory { private string name ; private string location ; private arraylist<robot> robots=new arraylist<>(); public factory() { this.name=""factory1""; this.location=""moon""; } public factory(string name,string location) { this.name=name; this.location=location; } public string getname() { return name; } public string getlocation() { return location; } public arraylist<robot> getrobots() { return robots; } public void setname(string name) { this.name=name; } public void setlocation(string name) { this.location=name; } public void setrobots(arraylist<robot> name) { this.robots=name; } public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for(int i=0;i<robots.size();i++) { robots.get(i).charge(); } } public void printfactory() { system.out.println(""factory name:""+name+"" factory1 location:"" +location); for(int i=0;i<robots.size();i++) { robots.get(i).printrobot(); } } public void work() { for(int i=0;i<robots.size();i++) { if(robots.get(i).getbatetery()<0) { robots.get(i).setbatterylevel(0); } else { robots.get(i).setbatterylevel(robots.get(i).getbatetery()-15); } } } } 2",23165,2862,402,150,31,24
1889298,2,"1889298 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class q2 { public static void main(string[] args) { int[] arr ={5,4,1,2}; cocktailsort(arr); } public static void cocktailsort(int[] arr){ righttoleft(arr); } //==========================================================================================0 public static void righttoleft(int[] arr){ boolean y = false; for(int x = 0; x<arr.length;x++){ for(int i =x+1;i<arr.length-x;i++){ int temp = 0; if(arr[x]>arr[i]){ temp=arr[x]; arr[x]=arr[i]; arr[i]=temp; } } if (issorted(arr)){ y=true; if (y){ for(int i=0;i<arr.length;i++){ system.out.print(arr[i]); } } else{ lefttoright(arr); } } } } //==========================================================================================0 public static void lefttoright(int[] arr){ boolean y = false; for(int x = arr.length; 0<x;x--){ for(int i =x-1;i>0;i--){ int temp = 0; if(arr[x]<arr[i]){ temp=arr[x]; arr[x]=arr[i]; arr[i]=temp; } } if (issorted(arr)){ y=true; if (y){ for(int i=0;i<arr.length;i++){ system.out.print(arr[i]); } } else{ righttoleft(arr); } } } } //==========================================================================================0 public static boolean issorted(int[] arr){ boolean boo = true; for(int i = 0;i<arr.length-1;i++){ for(int j = i+1;j<arr.length;j++) if(arr[i]>arr[j]){ boo = false; } } if(boo){ return true; } else{ return false; } } //==========================================================================================0 } import java.util.*; class q1{ public static void main(string[] args) { scanner scan = new scanner(system.in); int x = scan.nextint(); system.out.println(collatz(x)); scan.close(); } public static int collatz (int i){ if(i%2==0){ i=i/2; } else{ i=3*i+1; } if (i==1){ return 1; } else{ return 1+collatz(i); } } } public class q3 { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); s1.say(); } } class sayac{ public string str; public string getstr() { return str; } public sayac(string str){ this.str=str; } public int say() { string string = getstr(); return sayanadam(string, 1); } public int sayanadam(string str,int x){ string f = str.substring(0,str.length()-x); string h = str.substring(str.length()-x, str.length()-x+1); if(f.length()==1){ if(h.equals(""1"")){ return 1; } else{ return 0; } } else{ if(h.equals(""1"")){ return 1 + f.say(); } else{ return f.say(); } } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 public abstract class sarki{ public string isim; public string sanatci; void oynat(){}; } public class metalsarki extends sarki { public string metalozellik; metalsarki(string isim, string sanatci, string metalozellik){ this.isim=isim; this.sanatci=sanatci; this.metalozellik=metalozellik; } void oynat(){ system.out.print(isim+""- ""+sanatci+"" (""+metalozellik+"") ""); } } public class rocksarki extends sarki { public string rockozellik = "" (huzurlu ve nostaljik)""; rocksarki(string isim, string sanatci){ this.isim=isim; this.sanatci=sanatci; } void oynat(){ system.out.print(isim+""- ""+sanatci+ rockozellik); } } public class klasiksarki extends sarki { public string klasikozellik = "" (hafif ve sakin)""; klasiksarki(string isim, string sanatci){ this.isim=isim; this.sanatci=sanatci; } void oynat(){ system.out.print(isim+""- ""+sanatci+klasikozellik); } } public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } public class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi){ for(int i=0;i<sarkilistesi.size();i++){ sarkilistesi.get(i).oynat(); } } } public class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi){ for(int i=0;i<sarkilistesi.size();i++){ int x = math.random(sarkilistesi.size()-i); sarkilistesi.get(x).oynat(); sarkilistesi.remove(x); } } } public class rockcuozelcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi){ boolean flag=true; for(int i=0;i<sarkilistesi.size();i++){ sarki r = new rocksarki(sarkilistesi.get(i).isim,sarkilistesi.get(i).sanatci); if(sarkilistesi.get(i)== r){ if(flag){ system.out.println(""ses yükseltiliyor...""); } sarkilistesi.get(i).oynat(); system.out.print("" (huzurlu ve nostaljik)""); flag=false; } else{ if(!flag){ system.out.println(""ses normal düzeye döndürülüyor...""); } sarkilistesi.get(i).oynat(); flag=true; } } } } public class muzikcalar { public calmastratejisi strateji; void setstrateji(calmastratejisi s){ strateji=s; } void muzikcal(list<sarki> sarkilistesi){ strateji.cal(); } } ""recursion"" kavramı nedir, kısaca açıklayınız. belirli bir metodun içerisinde sınırlar dahilinde (if ile sınırlayarak) metodu tekrar kullanarak bir fonksiyon oluşturmak recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case ve recursive case jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. stackte üste doğru depoluyor ve sınır değere ulaştığında tekrardan sonuçları ters yönde stackten siliyor int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. i̇teratif olarak daha verimlidir bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? int n=0 sayacı tanımlayarak başta stringin kendisine substring(n,str.length()) olarak kendi içerisine metodu tekrar yazarım if koşulu ule substringden çıktı gelmediğindede sayac değerinin uzunluğa eşit olduğu değeri çıktı olarak veririm stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack recursionda verilerin geçici olarak depolanmasını sağlar overflow olmasının nedeni ise recursionun if koşulu ile sınırlandırılmaması sonucu tail recursion nedir, kısaca açıklayınız. - abstraction kavramını açıklayınız. kodun sadece belirli bir kısmını kullanıcının değiştirmesine açık kılmak dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? hourlyemployee tipi bir objeden employee döndürürsek eksikler kalır ama tersi bir durum geçerli olabilir (hourlyemployee employeeyi kapsıyor çünkü) protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier yani default modifier daha yakındir java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? base class ve kullandığımız classın atası olan subclasslardaki metod ve parametreleri korumak için java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? c b'nin subclassıysa a extends c şeklinde edebilir ama üstteki gibi bir kullanım olamaz java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a'nın b'nin subclassı olup olmadığını kontrol eder metot overriding ve overloading kavramlarını açıklayınız. overriding signiture kısmı aynı overloading ise signiture kısmı farklı olan metodları tekrar subclassda kullanmaktır class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? 1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract classların olabilirken interfacelerin olamaz abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? abstract bir metod abstract bir classta implement edilebilir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. 1-abstract classlar bize sonradan belirleyeceğimiz metodlar için bir cerçeve oluşturur 2-abstract classlar inherit edilebildikleri için önceden belirlenmemiş bir fonksiyonu tekrar override edebilmemizi sağlar 3- abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstarct classlar belirlenmemiş metodların yanında belirlenmiş metodlar da içerebilirken interfacelerde bu durum gözlenmez. interfaceler tip olarak kullanılabilirken abstract classlar kullanılamaz. i̇ki türlü declarationlar mümkün değildir marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker belirlemek amaçlı functional ise sonradan kullanılmak amaçlı yazılır (?) bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet bir class birden fazla interface implement edebilir. evet bir interface başka bir interface implement edebilir. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? hata shape c = new shape kısmindadır bu kısmı shape c = new circle(); seklinde yazarsak outout ""drawing circle"" ""displaying"" şeklinde olur. interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? - bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true import java.util.arraylist; public class q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55, true); robot r3 = new robot(""r2-d2"", ""astromech"", 80, true); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } //==================================================================================0 public class robot{ private string name; private string type; private int batterylevel; private boolean isoperational; robot(){ this.name=""wall-e""; this.type=""trash""; this.batterylevel=100; this.isoperational=true; } robot(string name, string type, int batterylevel,boolean isoperational) { this.batterylevel=batterylevel; this.isoperational=isoperational; this.type=type; this.name=name; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public boolean isoperational() { return isoperational; } public void setoperational(boolean isoperational) { this.isoperational = isoperational; } public void charge(){ this.batterylevel = 100; } public void printrobot(){ system.out.println(""robot name: ""+this.name + ""robot type: "" + this.type + ""batterylevel: "" + this.batterylevel+""% isoperational: "" + this.isoperational ); } //=============================================================================================== public class factory{ private string name; private string location; private arraylist<robot> robots; public factory(string name, string location){ this.name=name; this.location=location; } public factory(){ this.name=""factory1""; this.location=""moon""; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getlocation() { return location; } public void setlocation(string location) { this.location = location; } public void addrobot(robot robot){ robots.add(robot); } public void chargeallrobots(){ for(int i=0;i<robots.size();i++){ robots.get(i).charge(); } } public void printfactory(){ system.out.println(""factory name: "" + this.name + "" location: "" + this.location); system.out.println(""robots operating here: ""); for(int i =0;i<robots.size();i++){ robots.get(i).printrobot(); } } public void work(){ for(int i=0;i<robots.size();i++){ robots.get(i).setbatterylevel(robots.get(i).getbatterylevel()-15); } } } } import java.util.arraylist; public class q1 { public static void main(string[] args) { string str=""a1b2""; char[] ch = str.tochararray(); arraylist<string> arraylist = new arraylist<string>(); arraylist.add(str); for(int i = 0;i<ch.length;i++){ if (detectletter(ch[i])){ string temp1 = str.substring(i, i+1); string temp2 = temp1.touppercase(); if(temp1==temp2){ temp2=temp1.tolowercase(); } string newstr = str.substring(0, i) + temp2 + str.substring(i+1, str.length()); arraylist.add(newstr); } } str = str.touppercase(); char[] ch2 = str.tochararray(); arraylist.add(str); for(int i = 0;i<ch2.length;i++){ if (detectletter(ch2[i])){ string temp1 = str.substring(i, i+1); string temp2 = temp1.touppercase(); if(temp1==temp2){ temp2=temp1.tolowercase(); } string newstr = str.substring(0, i) + temp2 + str.substring(i+1, str.length()); arraylist.add(newstr); } } for(int i =0; i<arraylist.size()-1;i++){ for (int j =i+1; j<arraylist.size();j++){ if(arraylist.get(i).equals(arraylist.get(j))){ arraylist.remove(j); } } } system.out.println(arraylist); } public static boolean detectletter (char c){ int i = (int) (c); if(i<80 && i>=65){ return true; } else if(i<123 && i>=97){ return true; } else{ return false; } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 import java.util.*; public class quizq1 { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); anotherfactory.fonksiyon();// burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisini } } interface withbattery { int getbatterylife(); void recharge(); } abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife){ this.modelname=modelname; this.batterylife=batterylife; } public string getmodelname(){ return modelname; } public abstract void performtask(); public int getbatterylife(){ return batterylife; } public void recharge(){ this.batterylife=100; } } class cleaningrobot extends abstractrobot{ private int cleaningpower; public void setcleaningpower(int cleaningpower) { this.cleaningpower = cleaningpower; } public int getcleaningpower() { return cleaningpower; } cleaningrobot(string modelname, int batterylife, int cleaningpower){ super(modelname, batterylife); setcleaningpower(cleaningpower); } public void performtask(){ if(batterylife>=10){ system.out.println(modelname+"" cleaning in progress...""+"" cleaning power: ""+ getcleaningpower()); batterylife=batterylife-10; } } public void boostcleaningpower(){ setcleaningpower(getcleaningpower()+10); } } class securityrobot extends abstractrobot{ private boolean isarmed; public boolean isarmed() { return isarmed; } public void setarmed(boolean isarmed) { this.isarmed = isarmed; } public void performtask(){ if(batterylife>=10){ system.out.println(modelname+"" cleaning in progress...""+"" armed: ""+ isarmed()); batterylife=batterylife-10; } } securityrobot(string modelname, int batterylife, boolean isarmed){ super(modelname, batterylife); setarmed(isarmed); } public void togglearmedmode(){ setarmed(!isarmed()); } } class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); public arraylist<abstractrobot> getrobots() { return robots; } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ getrobots().add(new cleaningrobot(modelname, batterylife, cleaningpower)); } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ getrobots().add(new securityrobot(modelname, batterylife, isarmed)); } public void performalltasks(){ for(int i=0;i<getrobots().size();i++){ getrobots().get(i).performtask(); } } public void displayrobots(){ for (int i=0;i<getrobots().size();i++){ if(getrobots().get(i) instanceof cleaningrobot){ cleaningrobot c = (cleaningrobot) robots.get(i); system.out.println(""cleaningrobot - model: "" + c.modelname+"", battery: ""+c.batterylife+ ""cleaning power: ""+ c.getcleaningpower()); } else{ securityrobot s = (securityrobot) robots.get(i); system.out.println(""securityrobot - model: "" + s.modelname+"", battery: ""+s.batterylife+ ""armed: ""+ s.isarmed()); } } } public void upgradecleaningrobots(int miktar){ for(int i=0;i<getrobots().size();i++){ if(getrobots().get(i) instanceof cleaningrobot){ cleaningrobot cl = (cleaningrobot) robots.get(i); cl.setcleaningpower(cl.getcleaningpower()+10); system.out.println(""cleaningrobot - ""+cl.modelname+"" now has cleaning power:""+ cl.getcleaningpower()); } } } public void togglesecurityrobotsmode(){ for(int i=0;i<robots.size();i++){ if(getrobots().get(i) instanceof securityrobot){ securityrobot se = (securityrobot) robots.get(i); se.togglearmedmode(); if(se.isarmed()){ system.out.println(""securityrobot - ""+se.modelname+"" is now armed""); } else{ system.out.println(""securityrobot - ""+se.modelname+"" is now unarmed""); } } } } public void fonksiyon(){ system.out.println(""tüm fabrikalar tarafından toplam ""+ getrobots().size()+ "" robot üretildi.""); } } 2",33574,3988,620,189,37,25
6494434,2,"6494434 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class sayac { private string str; public sayac(string str) { this.str = str; } public int say() { return sayrecursive(str); } private int sayrecursive(string str) { if (str.length() == 0) { return 0; // boş string } int count = (str.charat(0) == '1') ? 1 : 0; return count + sayrecursive(str.substring(1)); } } public class lab1 { public static void main(string[] args) { system.out.println(collatz(5)); system.out.println(collatz(8)); system.out.println(""------------""); sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); sayac s3 = new sayac(""0101001""); system.out.println(""------------""); system.out.println(s1.say()); system.out.println(s2.say()); system.out.println(s3.say()); system.out.println(""------------""); int [] array1 = {5,4,1,2}; cocktailsort(array1); printarr(array1); int [] array2 = {6,4,8,1,3,9}; cocktailsort(array2); printarr(array2); } public static int collatz(int i) { if (i == 1) { return 0; // 1'e ulaştığımızda adım sayısı 0'dır. } if (i % 2 == 0) { return 1 + collatz(i / 2); } else { return 1 + collatz(3 * i + 1); } } public static void cocktailsort(int[] arr) { cocktailsort2(arr, 0, arr.length - 1); } public static void cocktailsort2(int[] arr, int start, int end) { if (start >= end) { return; // işlem tamam } boolean degistimi = false; // soldan sağa bubble sort for (int i = start; i < end; i++) { if (arr[i] > arr[i + 1]) { int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; degistimi = true; } } // degistimi = false ise dizi sıralıdır if (!degistimi) { return; } degistimi = false; // sağdan sola bubble sort for (int i = end - 1; i > start; i--) { if (arr[i] < arr[i - 1]) { int temp = arr[i]; arr[i] = arr[i - 1]; arr[i - 1] = temp; degistimi = true; } } // baş ve son hari̇ci̇ tekrar bak cocktailsort2(arr, start + 1, end - 1); } public static void printarr(int[] arr) { for (int i : arr) { system.out.print(i + "" ""); } system.out.println(); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; class muzikcalar{ private calmastratejisi strateji; public void setstrateji(calmastratejisi strateji){ this.strateji = strateji; } public void muzikcal(list<sarki> sarkilistesi){ if(strateji != null){ strateji.cal(sarkilistesi); } } } import java.util.list; import java.util.arrays; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki){ ((metalsarki) sarki).gostermetalozellikleri(); } } } } class klasiksarki extends sarki{ private string klasikstring = "" (hafif ve sakin)""; public klasiksarki(string isim,string sanatci){ super(isim,sanatci); } public void oynat(){ system.out.println(""[klasi̇k] "" + sanatci + "" - ""+ isim + klasikstring); } } class metalsarki extends sarki { public string metalozellik; public metalsarki(string isim,string sanatci,string metalozellik){ super(isim,sanatci); this.metalozellik = metalozellik; } public void oynat(){ system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } public void gostermetalozellikleri(){ system.out.println(sanatci + "" - "" + isim + "" [ozellik: "" + metalozellik + ""]""); } } class rocksarki extends sarki { private string rockstring = "" (huzurlu ve nostaljik)""; public rocksarki(string isim,string sanatci){ super(isim,sanatci); } public void oynat(){ system.out.println(""[rock] "" + sanatci + "" - "" + isim + rockstring); } } import java.util.collections; import java.util.list; import java.util.arraylist; class karisikcalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi){ list<sarki> karisikliste = new arraylist<>(sarkilistesi); collections.shuffle(sarkilistesi); for(sarki sarki : sarkilistesi){ sarki.oynat(); } } } import java.util.list; class siralicalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi){ for(sarki s : sarkilistesi){ s.oynat(); } } } abstract class sarki { public string isim; public string sanatci; public sarki(string isim,string sanatci){ this.isim = isim; this.sanatci = sanatci; } public abstract void oynat(); } import java.util.list; class rockcuozelcalma implements calmastratejisi { boolean sesyuksek = false; public void cal(list<sarki> sarkilistesi) { boolean sesyuksek = false; for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof rocksarki) { if (!sesyuksek) { system.out.println(""[bilgi] ses düzeyi: yüksek""); sesyuksek = true; } } else { if (sesyuksek) { system.out.println(""[bilgi] ses düzeyi: normal""); sesyuksek = false; } } sarkilistesi.get(i).oynat(); } if (sesyuksek) { system.out.println(""[bilgi] ses düzeyi: normal""); } } } import java.util.list; interface calmastratejisi{ void cal(list<sarki> sarkilistesi); } ""recursion"" kavramı nedir, kısaca açıklayınız. bir fonksiyonun kendi kendini çağırarak problemi çözdüğü yöntemdir. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case ve recursive case jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. . int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. recursive olarak daha verimli bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? . stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack girdiğimiz verileri tutan ve ilk giren veriyi son çıkartan bir yapıdır. sonsuz döngüye girerse mesela overflow olur tail recursion nedir, kısaca açıklayınız. recursionun sadece parametresini azaltarak veya arttırarak çağırma yapılması. java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? dynamic binding override edilen metotlarla kullanılır. static binding overloading için kullanılır. derleme zamanında belirlenir. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? ortak noktaları override edilemez olmaları. bu yüzden de dynamic binding yapamazlar. static binding yaparlar. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloadingde static binding çünkü derleme aşamasında oluyor. overrisidingde dynamic binding çünkü çalışma zamanında oluyor. dinamik bağlamada jvm'nin görevi nedir? çalışma zamanında nesnenin gerçek türünü belirler ve uygun metodu çağırır. java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? upcasting daha genel türe çevirme bu yüzden implicit. downcasting daha özel türe çevirme bu yüzden explicit java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? performans düşerdi çünkü her metod çalışma zamanında belirlenlemesi gerekirdi class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child dynamic binding class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? ""product"" ve ""book"" dynamic binding java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class en az bir abstract metot içeren ve direkt olarak örneklendirilemeyen bir sınıftır. concrete class ise tüm metotları tanımlı olan new operatörü ile nesnesi oluşturulanilen sınıflardır. abstract classların constructoru olabilir. i̇nterfacelerin construturu olamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? hayır abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. hem soyut hem somut metotlar bulunur. new ile nesne oluşturulumaz. override edilmek zorundadır. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract classda somut metotlar olabilir. i̇nterface ise tamamen soyuttur. evet tip olarak kullanılabilir. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface içinde metot olmayan. functional interface ise tek adet abstract metot içerendiir. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? 1.soru cevap evet 2.soru cevap hayır ama extends edebilir. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? shape c = new shape(); satırı hatalı. shape c = new circle(); yaparak düzeltilir. output: drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? hayır. abstract classdan nesne oluşturmaya çalışmış. böyle bir şey olmaz. public void show() {a.super.show();} output: a bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true class robot { private string name; private string type; private int batterylevel; // 100 ile 0 arasında bir değer private boolean isoperational; // batarya var ise true public robot() { this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public robot(string name, string type, int batterylevel) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = batterylevel > 0; } public int getbatterylevel() { return batterylevel; } public boolean getisoperational() { return isoperational; } public string getname(){ return name; } public string gettype(){ return type; } public void setbatterylevel(int batterylevel){ this.batterylevel = batterylevel; } public void setisoperational(boolean isoperational){ this.isoperational = isoperational; } public void setname(string name){ this.name = name; } public void settype(string type){ this.type = type; } public void charge() { this.batterylevel = 100; this.isoperational = true; } public void printrobot() { system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + ""% is operational: "" + isoperational); } } class q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // varsayılan robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } public class q1 { public static void recursive(string str, int index, string simdiki) { if (index == str.length()) { system.out.print(simdiki + "" ""); return; } char ch = str.charat(index); // harf i̇se if (character.isletter(ch)) { recursive(str, index + 1, simdiki + character.tolowercase(ch)); recursive(str, index + 1, simdiki + character.touppercase(ch)); } else { // rakam i̇se recursive(str, index + 1, simdiki + ch); } } public static void main(string[] args) { string s = ""a1b2""; recursive(s, 0, """"); system.out.println(); string str = ""ab12cd""; recursive(str,0,""""); } } import java.util.arraylist; class factory { private string name; private string location; private arraylist<robot> robots; public factory() { this.name = ""factory1""; this.location = ""moon""; this.robots = new arraylist<>(); } public factory(string name, string location) { this.name = name; this.location = location; this.robots = new arraylist<>(); } public string getname(){ return name; } public string getlocation(){ return location; } public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for (robot r : robots) { r.charge(); } } public void work() { for (robot r : robots) { int n = 0; n = r.getbatterylevel(); r.setbatterylevel(n-15); if(r.getbatterylevel() <= 0 ){ r.setisoperational(false); } } } public void printfactory() { system.out.println(""factory name: "" + name + "" location: "" + location); system.out.println(""robots operating here:""); for (robot r : robots) { r.printrobot(); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 interface withbattery { int getbatterylife(); void recharge(); } abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public int getbatterylife() { return batterylife; } public void setmodelname(string modelname) { this.modelname = modelname; } public void setbatterylife(int batterylife) { this.batterylife = batterylife; } public abstract void performtask(); public void recharge() { this.batterylife = 100; } } class securityrobot extends abstractrobot { private boolean isarmed; public securityrobot(string modelname, int batterlife, boolean isarmed) { super(modelname,batterlife); this.isarmed = isarmed; } public boolean getisarmed(){ return isarmed; } public void setarmed(boolean isarmed) { this.isarmed = isarmed; } public void togglearmedmode() { isarmed = !isarmed; } public void performtask() { if(batterylife >= 10) { system.out.println(""["" + modelname + ""] scanning for threats... armed: "" + isarmed); batterylife -= 10; }else{ system.out.println(""["" + modelname + ""] not enough battery to scan threats...""); } } public int getbatterylife() { return batterylife; } public void recharge() { this.batterylife = 100; } } class cleaningrobot extends abstractrobot { private int cleaningpower; //robot temizlik güç public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname,batterylife); this.cleaningpower = cleaningpower; } public int getcleaningpower() { return cleaningpower; } public void setcleaningpower(int cleaningpower) { this.cleaningpower = cleaningpower; } public void performtask(){ if(batterylife >= 10 ){ system.out.println(""["" + modelname + ""] cleaning in progress ... cleaning power: "" + cleaningpower); batterylife -= 10; }else{ system.out.println(""["" + modelname + ""] not enough battery to clean...""); } } public void boostcleaningpower(int miktar){ cleaningpower += miktar; } public int getbatterylife() { return batterylife; } public void recharge() { this.batterylife = 100; } } import java.util.arraylist; class robotfactory { private arraylist<abstractrobot> robots; private static int toplamrobotlar = 0; public robotfactory() { robots = new arraylist<>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); toplamrobotlar++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); toplamrobotlar++; } public void performalltasks() { for (abstractrobot robot : robots) { robot.performtask(); } } public void displayrobots() { for (abstractrobot robot : robots) { if(robot instanceof securityrobot) { system.out.println(""securityrobot - model: "" + robot.getmodelname() + "", battery: "" + robot.getbatterylife() + "", armed: "" + ((securityrobot) robot).getisarmed()); }else if (robot instanceof cleaningrobot) { system.out.println(""cleaningrobot - model: "" + robot.getmodelname() + "", battery: "" + robot.getbatterylife() + "", cleaning power: "" + ((cleaningrobot) robot).getcleaningpower()); } } } public void upgradecleaningrobots(int miktar) { for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot) { ((cleaningrobot) robot).boostcleaningpower(miktar); system.out.println(""cleaningrobot- "" + robot.modelname + ""now has cleaning power: "" + ((cleaningrobot) robot).getcleaningpower()); } } } public void togglesecurityrobotsmode() { for(abstractrobot robot : robots) { if(robot instanceof securityrobot) { ((securityrobot) robot ).togglearmedmode(); if(((securityrobot) robot).getisarmed() == true){ system.out.println(""security robot - "" + robot.modelname + "" is now armed""); }else{ system.out.println(""security robot - "" + robot.modelname + "" is now unarmed""); } } } } public static void displaytoplamroboturetimi() { system.out.println(""tum fabrikalar tarafindan toplam "" + toplamrobotlar + "" robot uretildi""); } } public class quizmain { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.displaytoplamroboturetimi(); } } 2",34348,4389,613,214,37,35
8857652,1,"8857652 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q2 { public static void main(string[] args) { int[] arr = {5,4,1,2}; cocktailsort(arr); for(int arrs : arr){ system.out.print(arrs); } } public static void cocktailsort(int[] arr){ int count=1; for(int i=0; i<arr.length; i++){ if(i%2==0){ count=1; } else{ count=0; } cocktailsort(arr,count); } } private static void cocktailsort(int[] arr, int count){ if(count==1){ int temp=0; for(int i=0, j=1; j<arr.length; i++,j++){ if(arr[i]>arr[j]){ temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } if(count==0){ int temp=0; for(int i=arr.length-2, j=arr.length-1; i>0; i--,j--){ if(arr[i]>arr[j]){ temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } } /* public static void up(int[] arr){ //int index=0; } */ /* public static void down(int[] arr){ //int index=0; } */ } /* public static void bubblesortup(int[] arr) { int n = arr.length; int temp = 0; for(int i=0; i < n; i++){ for(int j=1; j < (n-i); j++){ if(arr[j-1] > arr[j]){ temp = arr[j-1]; arr[j-1] = arr[j]; arr[j] = temp; } } } count=0; } */ public class sayac { private string str; public sayac(string str){ this.str=str; } public int say(){ return(say(str)); } private static int say(string str){ if(str.length()<1){ return 0; } else if(str.charat(0)!='1'){ return 0 + say(str.substring(1)); } else{ return 1 + say(str.substring(1)); } } public static void main(string[] args) { sayac s1 = new sayac(""10001""); system.out.println(s1.say()); } } public class lab1q1 { public static void main(string[] args) { system.out.println(collatz(1)); //collatz(16); system.out.println(collatz(16)); system.out.println(collatz(5)); } public static int collatz(int i){ if(i==1){ return 0; } else if(i%2==0){//i even ise return 1 + collatz(i/2); } else { //i odd ise return 1 + collatz((3*i)+1); } //return collatz(i); // return i; } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { private calmastratejisi strateji; /* public muzikcalar(calmastratejisi strateji){ this.strateji=strateji; } */ public calmastratejisi getstrateji() { return strateji; } public void setstrateji(calmastratejisi strateji) { this.strateji = strateji; } /* void setstrateji(calmastratejisi s){ } */ void muzikcal(list<sarki> sarkilistesi){ //if(getstrateji().equals(""sirali calma"")){ //} strateji.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki){ //sarki.oynat(); sarki = (metalsarki) sarki; metalsarki temp=(metalsarki) sarki; system.out.println("""" + sarki.getsanatci() + "" - "" + sarki.getisim() + "" [ozellik: "" + temp.getmetalozellik() + ""]""); } } } } public class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci){ super(isim, sanatci); } @override void oynat() { system.out.println(""[rock] "" + getsanatci() + "" - "" + getisim() + ""(hafif ve sakin)""); } } public class metalsarki extends sarki{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik){ super(isim, sanatci); this.metalozellik=metalozellik; } public string getmetalozellik() { return metalozellik; } public void setmetalozellik(string metalozellik) { this.metalozellik = metalozellik; } @override void oynat() { system.out.println(""[metal] "" + getsanatci() + "" - "" + getisim() + "" ("" + getmetalozellik() + "")""); } public void gostermetalozellikleri(){ system.out.println("""" + getmetalozellik()); } } public class rocksarki extends sarki{ public rocksarki(string isim, string sanatci){ super(isim, sanatci); } @override void oynat() { system.out.println(""[rock] "" + getsanatci() + "" - "" + getisim() + "" (huzurlu ve nostaljik)""); } } import java.util.arraylist; import java.util.collection; import java.util.collections; import java.util.list; import java.util.random; public class karisikcalma implements calmastratejisi { //random random = new random(); //collections @override public void cal(list<sarki> sarkilistesi) { /*sarki[] songs = new sarki[sarkilistesi.size()]; //list<sarki> sarkilistesimix= new list()<>; for(int i=0; i<sarkilistesi.size(); i++){ //double random =math.random(); if(sarkilistesi.get(i) instanceof metalsarki){ sarkilistesi.get(i).oynat(); } else if(sarkilistesi.get(i) instanceof rocksarki){ sarkilistesi.get(i).oynat(); } else if(sarkilistesi.get(i) instanceof klasiksarki){ sarkilistesi.get(i).oynat(); } } */ list<integer> numbers = new arraylist<>(); for(int i=0; i<sarkilistesi.size(); i++){ numbers.add(i); } collections.shuffle(numbers); for(int index : numbers){ sarkilistesi.get(index).oynat(); } system.out.println(); } } import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { //sarki[] songs = new sarki[sarkilistesi.size()]; for(int i=0; i<sarkilistesi.size(); i++){ if(sarkilistesi.get(i) instanceof metalsarki){ sarkilistesi.get(i).oynat(); } else if(sarkilistesi.get(i) instanceof rocksarki){ sarkilistesi.get(i).oynat(); } else if(sarkilistesi.get(i) instanceof klasiksarki){ sarkilistesi.get(i).oynat(); } } system.out.println(); } } public abstract class sarki { private string isim; private string sanatci; public sarki(string isim, string sanatci){ this.isim=isim; this.sanatci=sanatci; } public string getisim() { return isim; } public void setisim(string isim) { this.isim = isim; } public string getsanatci() { return sanatci; } public void setsanatci(string sanatci) { this.sanatci = sanatci; } abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { //sarki[] songs = new sarki[sarkilistesi.size()]; for(int i=0; i<sarkilistesi.size(); i++){ if(sarkilistesi.get(i) instanceof metalsarki){ sarkilistesi.get(i).oynat(); } else if(sarkilistesi.get(i) instanceof rocksarki){ system.out.println(""[bilgi] ses duzeyi: yuksek""); sarkilistesi.get(i).oynat(); if(sarkilistesi.get(i+1) instanceof rocksarki){ sarkilistesi.get(i+1).oynat(); system.out.println(""[bilgi] ses duzeyi: normal""); i=i+1; } } else if(sarkilistesi.get(i) instanceof klasiksarki){ sarkilistesi.get(i).oynat(); } } system.out.println(); } } import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } abstraction kavramını açıklayınız. ne yaptığımız sorusuna yanıt buluruz, nasıl yaptığımızla ilgilenmeyiz. örneğin bir arabada gaza basınca arabanın ileri hareket etmesi ama bunun arkasındaki mekanizmayla ilgilenmeyiz. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? evet mümkündür. covariant return type olmuş olur çünkü hourlyemployee de aynı zamanda bir employee'dir( is a relation). tam olarak bundan dolayı bunun tersi mümkün olmayacaktır çünkü hourly employee daha restricteddir. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? private > default > protected > public (en restrictedden en aza) en yakin olan bir sonrakidir yani mantiken java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? genel özellikleri sistemli ve en hatasız şekilde inherit edebilmek için java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır sadece 1 tane için mümkündür. bir çocuğun 2 annesi olamaması ile bağdaşım yapılabilir. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a classı bnin child classıdır. bunun sayesinde pek çok işlemin hatasıx yapilmasi saglanabilir. metot overriding ve overloading kavramlarını açıklayınız. overload metodun signatureünün farklı olması olayı (isim ya da parametre) bu durumda gelen veriye (compatibility) göre o işleve özel metoda implement saglanir. override ise birbiriyle iliskili (child parent) sınıflardaki metodların işleviyle alakalıdır örnegın animal classındaki ses çıkar metodu dog classında overeide edilerek spesifik olarak objenin havlayarak ses çıkarmasını sağlayacaktır class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? 1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? parent /n 10 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? final statice ve private metodlarda static(compiler), diğerlerinde overriding yapabileceğimiz için dynamic (runtime) kullanırız. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? override edilemezler overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overload için static binding override için dynamic binding (runtime reading olduğundan daha yavaş) dinamik bağlamada jvm'nin görevi nedir? kodu run ettigimizde metodun farklı nesneler icin farklı davranıslar sergilemesini sağlar (runtime) java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? örnek üzerinden aciklayayim: parent ve child classlarında parent variableı child classının objesine refer edebilir çünkü child is a parent ama tam tersi olamaz typecasting yapmak gereklidir çünkü her parent bir child değildir. (çocuk annesini doğuramaz:)) java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? final static ve private methodları kullanımda sıkıntı yasardık. çünkü dynamic binding override içindir ve bu methodlar override edilemez. class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dynamic çünkü override var class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? hem dinamik hem statik java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract ifadesiyle belirtmezseniz class otomatik olarak concretetir. abstract class abstract method içerebilir. implement etmek istedigim ama sonra implementini gerçeklestirmek istediğim şeyler icin abstract classları kullanırım. abstract classların constructorı olabilir ama interfacerlerin olamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? abstract classlar abstract metodlar içerebileceği icin evet. (abstract metod final static ya da private değil) abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. gızlemeye ve delay etmeye yarar implementasyonu hakkinda bilgi sahibi olduğum ama şimdi implement etmek istemediğim metodları yazabilmemi sağlar. hiyerarşik olarak daha iyi kod yazılımını sağlar(blueprint özelligi) abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? obj2li olan olmaz çünkü interface objeyle alakalı işlem yapmaz ama obj1 olur abstarct class islem yapar. interfacede constructor yoktur ama abstract classlarda olabilir. interfaceler daha çok birden fazla aynı özelliği birbiriyle bağlantısı çok kurulamayan sınıfları bağlamak için kullanılabilir. abstarct classlar ise başlı başına birer sınıftır. interface full abstractiondır denebilir. abstractionda override olurken interfacede olmaz. marker interface ve functional interface kavramları nedir, nasıl kullanılır? (tam emin degilim adından çıkartmaya çalısıcam) marker olan hiyerarşi bozulmasın diye functional olan da gerçekten işe yarar bir şeyler yapan interface. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet. evet. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? new shape yerine new circle derim drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? super kullanarak çagırdık ama bunlar interface oldugu için saçma olur cünkü 2 interfacei de java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. checked ve unchecked olmak üzere 2 şekil. checked compile zamanı unchecked ise runtime exception olur. java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? override edildiğinde kendinden daha kısıtlı bir exception çağıramaz hiyerarşik olarak. daha da özelleştiremez ama genelleştirebilir. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally bloğu her durumda execute edilir(return olsa bile). system.exit olup direkt sistemden çıkarsa çalışamaz. exception atılmayan durumlarda da çalışır yani her durumda çalısmasinı istediğim bir kod varsa o bloğa yazarım. java'da kendi exceptionunuzu nasıl tanımlarsınız? normal method gibi ama exception'ı extend etmeli. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? başka bir kısmında exceptionlarla karşılasılmıs olabilir. multiple exception türüyle karsılaşılmış olunabilir. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? m2'de hiyerarşik bozukluk var. exception daha genel olduğu için ioexception'dan daha önce gelmeliydi. caught2 finally bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot { private string name; private string type; private int batterylevel; //0-100 private boolean isoperational; //bataryasi var mi public robot(){ this.name=""wall-e""; this.type=""trash""; this.batterylevel=100; isoperational=true; } public robot(string name, string type, int batterylevel){ this.name=name; this.type=type; this.batterylevel=batterylevel; isoperational=true; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public void charge(){ setbatterylevel(100); } public boolean isoperational() { if(this.getbatterylevel()<0){ isoperational=false; } else{ isoperational=true; } return isoperational; } public void printrobot(){ system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + ""%""+ "" is operational: ""+ isoperational); //system.out.println(""robot type: "" + type); //system.out.println(""batterylevel: "" + batterylevel); //system.out.println(""isoperational: ""+ isoperational); } } public class q1 { //combinationi kendi icinde de cagirmam gerekiyodu ama soruyu bi tik sonradan anladigim icin bu kadar kaldı public static void allcombinations(string str, int index){ if(index>=str.length()){ system.out.println(""hatalı input""); } else{ system.out.println(combination(str, index)); } } public static string combination(string str,int index){ //index++; if(index>=str.length()){ return """"; } else if(index==-1){ return """" + str + "" "" + combination(str, index+1); } /* else if(index==str.length()){ return """" + str.touppercase(); } */ else if(str.charat(index)>='a' && str.charat(index)<='z'){ //lower case ise upper yap return """" + str.substring(0, index) + str.substring(index,index+1).touppercase() + str.substring(index+1) + "" "" + combination(str,index+1); } else if(str.charat(index)>='a' && str.charat(index)<='z'){ //upper case ise lower yap return """" + str.substring(0, index) + str.substring(index,index+1).tolowercase() + str.substring(index+1) + "" "" + combination(str,index+1); } else{ return """" + combination(str, index+1) + "" ""; } } public static void main(string[] args) { string str = ""a1b2""; allcombinations(str,-1); //system.out.println(allcombinations(str)); } //s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] } /*if(str.length()==0){ return """"; } else if(){ return """" + str + combination(str); } else if(str.charat(0)<'z' && str.charat(0)>'a'){ return """" + str.substring(0,1).touppercase() + str.substring(1) + combination(str.substring(0)); } else if(str.charat(0)<'z' && str.charat(0)>'a'){ return """" + str.substring(0,1).tolowercase() + str.substring(1) + combination(str.substring(0)); } else{ return """" + str + combination(str.substring(1)); } } public static string allthecombinations(string str){ if(str.length()==0){ return """"; } else{ str=str.substring(1); system.out.println(combination(str)); } return """"; */ import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name, string location){ this.name=name; this.location=location; //arraylist robots = new arraylist<robot>(); } public factory(){ this.name=""factory1""; this.location=""moon""; robots = new arraylist<robot>(); } public string getlocation() { return location; } public void setlocation(string location) { this.location = location; } public string getname() { return name; } public void setname(string name) { this.name = name; } public arraylist<robot> getrobots() { return robots; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public void addrobot(robot robot){ robots.add(robot); } public void chargeallrobots(){ for(int i=0; i<robots.size() ; i++){ robots.get(i).charge(); } } public void printfactory(){ system.out.println(""factory name: "" + name + "" location: "" + location); system.out.println(""robots operating here: ""); for(int i=0; i<robots.size() ; i++){ robots.get(i).printrobot(); } } public void work(){ for(int i=0; i<robots.size() ; i++){ robots.get(i).setbatterylevel(robots.get(i).getbatterylevel()*85/100); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; public static int robocount=0; public abstractrobot(string modelname, int batterylife){ this.modelname=modelname; this.batterylife=batterylife; robocount++; } public string getmodelname() { return modelname; } public void setmodelname(string modelname) { this.modelname = modelname; } public void setbatterylife(int batterylife) { this.batterylife = batterylife; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); system.out.println(""tum fabrikalar tarafindan toplam "" + abstractrobot.robocount + "" robot uretildi""); //??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } public class securityrobot extends abstractrobot{ private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed){ super(modelname, batterylife); this.isarmed=isarmed; } public boolean isarmed() { return isarmed; } public void setarmed(boolean isarmed) { this.isarmed = isarmed; } @override public int getbatterylife() { return batterylife; } @override public void setbatterylife(int batterylife) { this.batterylife=batterylife; } @override public void recharge() { setbatterylife(getbatterylife()+10); } @override public void performtask() { if(getbatterylife()>=10){ system.out.println(""["" + getmodelname() + ""]"" + "" scanning for threats... armed: "" + isarmed); batterylife=getbatterylife()-10; } else{ system.out.println(""["" + getmodelname() + ""] "" + ""not enough battery to scan threats...""); } } public void togglearmedmode(){ if(isarmed()){ setarmed(false); system.out.println(""security robot - "" + getmodelname() + "" is now unarmed""); } else{ setarmed(true); system.out.println(""security robot - "" + getmodelname() + "" is now armed""); } } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower){ super(modelname, batterylife); this.cleaningpower=cleaningpower; } public int getcleaningpower() { return cleaningpower; } public void setcleaningpower(int cleaningpower) { this.cleaningpower = cleaningpower; } @override public int getbatterylife() { return batterylife; } @override public void setbatterylife(int batterylife) { this.batterylife=batterylife; } @override public void recharge() { setbatterylife(getbatterylife()+10); } @override public void performtask() { if(getbatterylife()>=10){ system.out.println(""["" + getmodelname() + ""] "" + ""cleaning in progress... cleaning power: "" + getcleaningpower()); batterylife=getbatterylife()-10; } else{ system.out.println(""["" + getmodelname() + ""] "" + ""not enough battery to clean...""); } } public void boostcleaningpower(){ setcleaningpower(getcleaningpower()+10); } } import java.util.arraylist; public class robotfactory { //public int factorycount=0; private arraylist<abstractrobot> robots; public robotfactory(){ robots=new arraylist<abstractrobot>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ robots.add(new securityrobot(modelname, batterylife, isarmed)); } public void performalltasks(){ for(int i=0; i<robots.size(); i++){ if(robots.get(i) instanceof cleaningrobot){ robots.get(i).performtask(); } else if(robots.get(i) instanceof securityrobot){ robots.get(i).performtask(); } } } public void displayrobots(){ //system.out.println(""produced robots:""); for(int i=0; i<robots.size(); i++){ if(robots.get(i) instanceof cleaningrobot){ cleaningrobot roboc=(cleaningrobot) robots.get(i); system.out.println(""cleaningrobot - model: "" + robots.get(i).getmodelname() + "", battery: "" + robots.get(i).getbatterylife() + "", cleaning power: "" + roboc.getcleaningpower()); } else if(robots.get(i) instanceof securityrobot){ securityrobot robos = (securityrobot) robots.get(i); system.out.println(""securityrobot - model: "" + robots.get(i).getmodelname() + "", battery: "" + robots.get(i).getbatterylife() + "", cleaning power: "" + robos.isarmed()); } } } public void upgradecleaningrobots(int miktar){ //system.out.println(""upgrading cleaning robots:""); for(int i=0; i<robots.size(); i++){ if(robots.get(i) instanceof cleaningrobot){ cleaningrobot roboc=(cleaningrobot) robots.get(i); roboc.setcleaningpower(roboc.getcleaningpower() + miktar); system.out.println(""cleaning robot - "" + robots.get(i).getmodelname() + "" now has cleaning power: "" + roboc.getcleaningpower()); } } } public void togglesecurityrobotsmode(){ //system.out.println(""toggling security robot modes:""); for(int i=0; i<robots.size(); i++){ if(robots.get(i) instanceof securityrobot){ securityrobot robos = (securityrobot) robots.get(i); robos.togglearmedmode(); } } } public void finaldisplay(){ system.out.println(""tum fabrikalar tarafindan toplam "" + abstractrobot.robocount + "" robot uretildi\r""); } } 1",42411,5147,829,257,43,76
2103960,0,"2103960 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab1q2 { public static void main(string[] args) { int[] arr = { 5, 4, 1, 2 }; cocktailsort(arr); for (int i = 0; i < arr.length; i++) { system.out.println(arr[i]); } } public static void cocktailsort(int[] arr) { while (!sorted(arr)) { for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } cocktailsort1(arr); } } public static void cocktailsort1(int[] arr) { while (!sorted(arr)) { for (int i = arr.length - 1; i > 0; i--) { if (arr[i] < arr[i - 1]) { int temp = arr[i]; arr[i] = arr[i - 1]; arr[i - 1] = temp; } } cocktailsort(arr); } } public static boolean sorted(int[] arr) { boolean flag = true; for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { flag = false; } } return flag; } } public class lab1q1 { public static void main(string[] args) { system.out.println(collatz(5)); } public static int collatz(int i) { if (i == 1) { return 0; } else if (i % 2 == 0) { return 1 + collatz(i / 2); } else { return 1 + collatz(3 * i + 1); } } } public class lab1q3 { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } class sayac { public string str; sayac(string str) { this.str = str; } public int say() { string str2 = this.str; if (str2.length() == 1) { if (str2.charat(0) == '1') { return 1; } else { return 0; } } if (str2.charat(0) == '1') { sayac s2 = new sayac(str2.substring(1)); return 1 + s2.say(); } else { sayac s2 = new sayac(str2.substring(1)); return s2.say(); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; import java.util.arrays; import java.util.arraylist; public class lab2 { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri:""); for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof metalsarki) { metalsarki m1 = (metalsarki) sarkilistesi.get(i); system.out.println(sarkilistesi.get(i).sanatci + "" - "" + sarkilistesi.get(i).isim); m1.gostermetalozellikleri(); } } } } abstract class sarki { string isim; string sanatci; abstract void oynat(){ } } class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void gostermetalozellikleri() { system.out.println(metalozellik); } void oynat() { system.out.println(""[metal] "" + this.sanatci + "" - "" + this.isim + "" ("" + this.metalozellik + "" )""); } } class rocksarki extends sarki { rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[rock] "" + this.sanatci + "" - "" + this.isim + "" (huzurlu ve nostaljik)""); } } class klasiksarki extends sarki { klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[klasik] "" + this.sanatci + "" - "" + this.isim + "" (hafif ve sakin)""); } } interface calmastratejisi { // void cal(list<sarki> sarkilistesi){ } } class siralicalma implements calmastratejisi { void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); } } } class karisikcalma implements calmastratejisi { void cal(list<sarki> sarkilistesi) { arraylist<sarki> sarkilistesi2 = new arraylist(); for (int i = 0; i < sarkilistesi.size(); i++) { int x = 0; while (0 <= x && x <= i) { x = math.random() * 10 / 1; } sarkilistesi2.get(x).oynat(); } } } class rockcuozelcalma implements calmastratejisi { void cal(list<sarki> sarkilistesi) { boolean flag = false; for (int i = 0; i < sarkilistesi.size(); i++) { if (flag && sarkilistesi.get(i).getclass() != rocksarki) { flag = false; system.out.println(""[bilgi] ses duzeyi: normal""); } if (sarkilistesi.get(i).getclass() == rocksarki) { system.out.println(""[bilgi] ses duzeyi: yuksek""); flag = true; } sarkilistesi.get(i).oynat(); } } } class muzikcalar { calmastratejisi strateji; void setstrateji(calmastratejisi s) { this.strateji = s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(); } } ""recursion"" kavramı nedir, kısaca açıklayınız. bir metodun kendisini içinde çağırması recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. 1 base recursive olmadan çözülen kısım, 2 base'e yaklaştıran case çağırma, 3 jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. stackler oluşturuyor int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. i̇teratif çok stack kullanmadığından daha hızlı bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? lenght 0 olmadığı sürece substring alırım ve countı 1 artırırım substringim giderek 1 küçülür , base case length ==1 olur stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. bir memory biçimi çok fazla üstüste gelirse kaldıramaz overflow olur tail recursion nedir, kısaca açıklayınız. en son stackte sonucun bulunması abstraction kavramını açıklayınız. soyutlama gerekli bilgi açık gereksiz bilgi kapalı dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? evet mümkün tersi olmaz protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? default daha yakın java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? her classın parent classına kolayca sürekli super yazmadan ulaşmayı sağlar parentn constructerını çağırır java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a bnin objesi metot overriding ve overloading kavramlarını açıklayınız. override aynı signatureın subclasslarda yeniden tanınlanması overload ise aynı isim farklı signature class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? parent 10 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? static static metodlar ve overloadlarda yapılır. dynamic ise override yapılanlarda runtimeda yapılır java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? hiçbiri daha sonra override edilemeyeceğinden static binding ile yapılır. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overload da imza farklıdır bu yüzden compile edilirken static binding ile yapılır. override dynamic binding ile runtime sırasında bakılarak yapılır dinamik bağlamada jvm'nin görevi nedir? runtime sırasında overrideları kontrol eder java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? çünkü child class parenttakinin özelliklerine sapihtir ancak tam tersi olmaz parenttakiler childın tüm özelliklerine sahip değildir java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? overload compile da olur normalde ancak runtimea bırakılırsa isimden dolayı karışıklık çıkabilir? class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstractde metodlar signature olarak tanımlanıyor ancak içi boş oluyor. hayır abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? hayır? abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. ? constructor/ objesi olmaz abstract metodlar tanımlanır, veya normal merodlarda tanımlanabilir abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interfacelerde birden fazla ata olabilir. classta olmaz. hayır abstractın objesi olmaz marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker sadece kolay anlaşılsın diye içi boş functional ise işlevli metodları olan bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet ikisi de olur abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? interfacete obje olmaz? circle olarak tanımlarım drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? hayır i̇ki interfaceten hangisini seçeceğini bilemez. ? b implements a b java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? try chatchten sonra hata bulunsa da bulunmasa da finally bloğu yapılır. exception atılmazsa trydan sonra catchi atlar ve finallyi yapar java'da kendi exceptionunuzu nasıl tanımlarsınız? exception classından yeni bir obje oluşturulur java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught -1 finally oops done static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? hayır exception ioexceptionı kapsadığı için sıkıntı çıkar ikisini yer değiştirebiliriz trying caught 1 finally bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class lab2q1 { public static void main(string[] args) { string s = ""a1b2""; int countletter = 0; int countcomb = 1; for (int i = 0; i < s.length(); i++) { if (isletter(s.charat(i))) { countletter++; } } for (int i = 0; i < countletter; i++) { countcomb = 2 * countcomb; } s = turnlower(s); combinations(s, countcomb); } public static boolean isletter(char c1) { if (c1 < 97 && c1 > 64) return true; else if (96 < c1 && c1 < 129) return true; else return false; } public static string turnlower(string s) { string s1 = """"; for (int i = 0; i < s.length(); i++) { if (isletter(s.charat(i))) { if (islower(s.charat(i))) { s1 += (char) (s.charat(i)); } else { s1 += s.charat(i) + 32; } } else { s1 += s.charat(i); } } return s1; } public static boolean islower(char c1) { if (96 < c1 && c1 < 129) return true; else return false; } public static void combinations(string s, int countcomb) { if (countcomb == 0) { } else { string s1 = s; for (int i = 0; i < s1.length(); i++) { if (isletter(s1.charat(i))) { system.out.println(s1); if (islower(s1.charat(i))) { system.out.println(s1); combinations(s1.substring(i), countcomb - 1); } } } } } } import java.util.arraylist; public class lab2q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } class robot { private string name; private string type; private int batterylevel; private boolean isoperational; robot() { this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } robot(string name, string type, int batterylevel) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = true; // main örneğinde isoperational verilmemiş o yüzden parametre olarak almadım. } public string getname() { return this.name; } public string gettype() { return this.type; } public int getbatterylevel() { return this.batterylevel; } public boolean getisoperational() { return this.isoperational; } public void setname(string name) { this.name = name; } public void settype(string type) { this.type = type; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public void setisoperational(boolean isoperational) { this.isoperational = isoperational; } public void charge() { this.batterylevel = 100; } public void printrobot() { system.out.println(this.name); system.out.println(this.type); system.out.println(this.batterylevel); system.out.println(this.isoperational); } } class factory { private string name; private string location; private arraylist<robot> robots; public factory() { this.name = ""factory1""; this.location = ""moon""; this.robots = new arraylist<>(); } public factory(string name, string location) { this.name = name; this.location = location; } public string getname() { return this.name; } public string getlocation() { return this.location; } public arraylist<robot> getrobots() { return this.robots; } public void setname(string name) { this.name = name; } public void setlocation(string name) { this.name = location; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public void addrobot(robot robot) { this.robots.add(robot); } public void chargeallrobots() {// for (int i = 0; i < robots.size(); i++) { getrobots().get(i).setbatterylevel(100); } } public void printfactory() {// system.out .println(""factory name: "" + this.name + ""\nlocation: "" + this.location + ""\n robots operating here: ""); for (int i = 0; i < robots.size(); i++) { this.getrobots(i).get(i).printrobot(); } } public void work() {// for (int i = 0; i < robots.size(); i++) { robots.get(i).setbatterylevel(robots(i).getbatterylevel() - 15); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public int batteryfull; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; this.batteryfull = batterylife; } public string getmodelname() { return modelname; } public int getbatterylife() { return batterylife; } public void recharge() { this.batterylife = batteryfull; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.toplamroboturetimi(); } } public class securityrobot extends abstractrobot { private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] scanning for threats... armed: "" + isarmed); batterylife -= 10; } else { system.out.println(""["" + modelname + ""] not enough battery to scan threats...""); } } public void togglearmedmode() { // if (isarmed) isarmed = false; else isarmed = true; } public boolean getisarmed() { return isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] cleaning in progress... cleaning power: "" + cleaningpower); batterylife -= 10; } else { system.out.println(""["" + modelname + ""] not enough battery to clean...""); } } public void boostcleaningpower(int miktar) { // this.cleaningpower += miktar; } public int getcleaningpower() { return cleaningpower; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<abstractrobot>(); // public static int factorycount = 0; public static arraylist<robotfactory> factories = new arraylist<robotfactory>(); public robotfactory() { factorycount++; factories.add(this); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); } public void performalltasks() { for (int i = 0; i < robots.size(); i++) { robots.get(i).performtask(); } } public void displayrobots() { for (int i = 0; i < robots.size(); i++) { if (robots.get(i) instanceof cleaningrobot) { cleaningrobot c1 = (cleaningrobot) robots.get(i); system.out.println(""cleaning robot - model: "" + robots.get(i).getmodelname() + "" battery: "" + robots.get(i).getbatterylife() + "" cleaning power:"" + c1.getcleaningpower()); } else if (robots.get(i) instanceof securityrobot) { securityrobot s1 = (securityrobot) robots.get(i); system.out.println(""security robot - model: "" + robots.get(i).getmodelname() + "" battery: "" + robots.get(i).getbatterylife() + "" armed:"" + s1.getisarmed()); } } } public void upgradecleaningrobots(int miktar) { for (int i = 0; i < robots.size(); i++) { cleaningrobot c2; if (robots.get(i) instanceof cleaningrobot) { c2 = (cleaningrobot) robots.get(i); c2.boostcleaningpower(miktar); system.out.println( ""cleaning robot - "" + c2.getmodelname() + "" now has cleaning power: "" + c2.getcleaningpower()); } else { } } } public void togglesecurityrobotsmode() { for (int i = 0; i < robots.size(); i++) { securityrobot s2; if (robots.get(i) instanceof securityrobot) { s2 = (securityrobot) robots.get(i); s2.togglearmedmode(); if (s2.getisarmed()) { system.out.println(""security robot - "" + s2.getmodelname() + "" is now armed""); } else { system.out.println(""security robot - "" + s2.getmodelname() + "" is now unarmed""); } } else { } } } public arraylist<abstractrobot> getallrobots() { return robots; } public static void toplamroboturetimi() { int toprobot = 0; for (int i = 0; i < factorycount; i++) { toprobot += factories.get(i).getallrobots().size(); } system.out.println(""tum fabrikalar tarafindan toplam "" + toprobot + "" robot uretildi.""); } } 0",37249,4920,725,216,43,26
5361565,1,"5361565 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. import java.util.scanner; public class l1q3 { public static void main(string[] args) { scanner scan=new scanner(system.in); system.out.println(""enter the number""); int i=scan.nextint(); sayac s1=new sayac(i); system.out.println(s1.say(i)); } } class sayac{ int i; public sayac(int i){ this.i=i; } public static int say(int i){ if(i<10){ if(i==1){ return 1; } else{ return 0; } } else{ if(i%10==1){ return 1 +say(i/10); } else{ return say(i/10); } } } } public class l1q2 { public static void main(string[] args) { int[] arr={5,4,2,1}; cocktailsort(arr); for(int a=0 ;a<arr.length; a++){ system.out.print(arr[a] +"" ""); } } public static void cocktailsort(int[] arr){ for(int a=0;a<arr.length; a++){ help(arr, a); help2(arr, arr.length-1-a); } } public static void help(int[] arr,int m) { if(m==arr.length-1){ return; } if(arr[m]>arr[m+1]){ int t=arr[m]; arr[m]=arr[m+1]; arr[m+1]=t; } help(arr, m+1); } public static void help2(int[] arr,int n){ if(n==0){ return ; } if(arr[n]<arr[n-1]){ int p=arr[n]; arr[n]=arr[n-1]; arr[n-1]=p; } help2(arr,n-1); } } import java.util.scanner; public class l1q1 { public static void main(string[] args) { scanner scan=new scanner(system.in); system.out.println(""enter the number i""); int i=scan.nextint(); int output=collatz(i); system.out.println(i); } public static int collatz(int i){ if(i==1){ return 0; } else{ if(i%2==0){ return collatz(i/2); } else{ return collatz((i*3)+1); } } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arraylist; import java.util.arrays; import java.util.list; import java.util.collections; public class lab2 { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri:""); for (int a=0; a<sarkilistesi.size(); a++) { if(sarkilistesi.get(a) instanceof metalsarki){ metalsarki o= (metalsarki) sarkilistesi.get(a); system.out.print(o.sanatci +""-"" +o.isim + "" [ozellik:""); o.gostermetalozelllikleri(); system.out.print(""]""); system.out.println(""""); } } } } abstract class sarki{ string isim; string sanatci; abstract public void oynat(); } class metalsarki extends sarki{ string metalozellik; public metalsarki(string isim,string sanatci,string metalozellik){ this.isim=isim; this.sanatci=sanatci; this.metalozellik=metalozellik; } public void gostermetalozelllikleri(){ system.out.print(this.metalozellik); } @override public void oynat(){ system.out.println(""[metal] "" + this.sanatci + ""-"" +this.isim + "" ("" + this.metalozellik + "")""); } } class rocksarki extends sarki{ public rocksarki(string isim,string sanatci){ this.isim=isim; this.sanatci=sanatci; } @override public void oynat(){ system.out.println(""[rock] "" + this.sanatci + ""-""+ this.isim + "" (huzurlu ve nostaljik)""); } } class klasiksarki extends sarki{ public klasiksarki(string isim ,string sanatci){ this.isim=isim; this.sanatci=sanatci; } @override public void oynat(){ system.out.println(""[klasik] "" + this.sanatci + ""-""+ this.isim + "" (hafif ve sakin)""); } } interface calmastratejisi{ public void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi){ for(int a=0; a<sarkilistesi.size(); a++){ sarkilistesi.get(a).oynat(); } } } class karisikcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi){ list<sarki> karma=new arraylist<sarki>(); karma.addall(sarkilistesi); collections.shuffle(karma); for(int a=0; a<sarkilistesi.size(); a++){ karma.get(a).oynat(); } } } class rockcuozelcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi){ // buraya gel random kullan bi de kullanılmış mı bak!!! for(int a=0; a<sarkilistesi.size(); a++){ if( a<sarkilistesi.size()-1 && sarkilistesi.get(a+1) instanceof rocksarki && !(sarkilistesi.get(a) instanceof rocksarki)){ sarkilistesi.get(a).oynat(); system.out.println(""[bilgi] ses duzeyi: yuksek""); } else if( a<sarkilistesi.size()-1 && sarkilistesi.get(a) instanceof rocksarki && !(sarkilistesi.get(a+1) instanceof rocksarki)){ sarkilistesi.get(a).oynat(); system.out.println(""[bilgi] ses duzeyi: normal""); } else { sarkilistesi.get(a).oynat(); } } } } class muzikcalar{ calmastratejisi strateji; public void setstrateji(calmastratejisi s){ this.strateji=s; } public void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } ""recursion"" kavramı nedir, kısaca açıklayınız. öz yinelemeli demektir.bir methodun kendini kendi içinde çağırmasıdır. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case vardır metodun sonsuz döngüye girmesini engellemek için. bir de base case dışındaki kısmı vardır o da elimizde ki problemi küçültmeye çalışır ve sonrasında da küçük problemlerin çözümleri birleşip büyük çözümü oluşturur. jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. recursive callları iterasyona dönüştürüyor önce ve bu şekilde handle ediyor int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. iteratif olarak daha verimli olur makine adına. çünkü makine için iteratif daha verimlidir. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? base casesi uzunluğu 1 olan string olur stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack her defasında recursive call olduğunda yeni açılan alandır ve bunlar üst üste binerler. overflow olmasının sebebi stacklerin ulaşabilrcekleri en fazla miktara ulaşmasıdır. örnek olarak ise sonsuz döngüye giren bir recursionı örnek verebiliriz. tail recursion nedir, kısaca açıklayınız. tail recursion methodun son komutunu kendisi olan yani recursive callın en sonda yapıldığı ve diğer işlemlerin bundan önce yapıldığı recursive methodlardır. java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? static binding final , static , private olan durumlarda yapılır ve overload olan yerlerde olur dynamic binding iste override edilen kodlarda olur polymorphismde olur java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? çünkü override edilemezler ve o yüzden polymorphismde kullanilamazlar ve dynamic binding gerekmediği icin static binding olur. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloadda dynamic çünkü runtimeda karar verir ama overloadda compile timeda karar verir ve metotların imzaları farklı olduğu için dynamic binding gerekmez o yüzden static binding kullanılır dinamik bağlamada jvm'nin görevi nedir? run timeda hangi metodun cagirilacagini bulmak java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? bir alt sınıf zaten ust sınıfın bütün ozelliklerini içerir o yüzden impilicit bir şekilde yapilabilir./down casting implicit bir sekilde yapilamaz hata alabiliriz sonucunda java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? daha az efficient olurdu kodlarımız çünkü hepsi run timeda binding edilirdi class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? output:child burada dinamik bağlama gözlenir class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? output: product book burada da dinamik bağlama olur. java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract classların tamamlanmamış methodları yani sadece imzası olan methodları bulunur concrete bir classta ise bütün methodlar tamamlanmıştır. abstract classların constructoru olabilir ama interfacelerin olamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? evet bir abstract classın abstract bir tane sub classı varsa ve bunda implement edersek olur.cunku sadece bir tane methodun tamamlanmamış olması o classın abstract olması için yeterli olur. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract classlar tamamlanmamis methodlar bulundururlar, bunlardan obje oluşturmayız, ama type olarak kullanabiliriz. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? bir class birden fazla interfacei implement edebilir ama birden fazla classı extend edemez.evet tip olarak kullanılabilirler. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interfaceler method içermezler belirteç olarak kullanılırlar functional interfaceler ise sadece bir tane abstract methoda sahiptirler ayrıca lambdalı bir şeyler hatırlıyorum. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? ikisinin de cevabı evet. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? hatamız cyi tanımlarken new shape yazmamızda new circle yazmamız lazim. output: drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? bu şekilde compile edilebilir ama runtimeda hata verir. koddaki problem aynı signaturea sahip iki adet methodun bulunduğu iki interfacei tek bir classin implement etmesi.problemli satırda iki farklı method tanimplanip ayri ayri cagirilabilirler ya da super çağırmak yerine c yazdirilabilir. ayrı ayrı method olsuturulursa hem a hem b basılır ama ikincisi yapilirsa c basılır sadece. java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 2 çeşittir checked ve unchecked checkede ornek olarak ioexception verebiliriz uncheckede ornek olarak ise runtime exception verebiliriz. java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? sadece throwable olan objeler için kullanilabilir. unchecked olan exceptionlarda throws diye bildirmemiz gerekmez.bir metot birden fazla thow yapabilir.overrideda ise daha az spesifik bir exception throw edemeyiz bu checkedler icin uncheckedlerde böyle bir kisitlama yok. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally blogu her zaman çalışır açık olan socketları falan kapatmak için kullanilir.kaynaklarin bosa harcamasını engeller java'da kendi exceptionunuzu nasıl tanımlarsınız? exceptions classından extend ederek yeni bir class olusturabiliriz ve bunun objesini olusturarak da kendi exceptionımızı oluşturabiliriz. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? farklı bir exception varsa bunu da yakalayabilmek için. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 77 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? ? bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true import java.util.scanner; public class l2q1 { public static void main(string[] args) { scanner scan=new scanner(system.in); system.out.println(""enter the string""); string s=scan.nextline(); comb(s.tochararray(), 0, """"); } public static void comb(char[] chars,int index,string s){ if(index==chars.length){ system.out.println(s); return ; } else{ if(chars[index]>='a' && chars[index]<='z'){ comb(chars, index+1, s+chars[index]); comb(chars, index+1, s+ (char)(chars[index]-32)); } else if(chars[index]>='a' && chars[index]<='z'){ comb(chars, index+1, s+chars[index]); comb(chars, index+1, s+(char)(chars[index]+32)); } else{ comb(chars, index+1, s+chars[index]); } } }} import java.util.arraylist; public class l2q2 { public static void main(string[] args) { factory factory=new factory(); robot r1=new robot(); robot r2=new robot(""bender"", ""bending unit"", 55, true);//constructor oluşturulurken isoperational parametre olarak alonsın denmiş ama maindeki kodda görünmüyor robot r3=new robot(""r2-d2"", ""astromech"", 80, true); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } class robot{ private string name; private string type; private int batterylevel; private boolean isoperational; public robot(){ this.batterylevel=100; this.isoperational=true; this.name=""wall-e""; this.type=""trash""; } public robot(string name,string type, int batterylevel,boolean isoperational){ this.name=name; this.batterylevel=batterylevel; this.isoperational=isoperational; this.type=type; } public string getname(){ return name; } public string gettype(){ return type; } public boolean getisoperaional(){ return isoperational; } public int getbatterylevel(){ return batterylevel; } public void setname(string name){ this.name=name; } public void setstype(string type){ this.type=type; } public void setbatterylevel(int batterylevel){ this.batterylevel=batterylevel; } public void setisoperational(boolean isoperational){ this.isoperational=isoperational; } public void charge(){ this.batterylevel=100; } public void printrobot(){ system.out.println(""robot name: "" +this.getname() + "" robot type: "" +this.gettype() + "" batterylevel: "" + this.getbatterylevel()+ "" is operational: ""+this.getisoperaional()); } } class factory{ private string name; private string location; private arraylist <robot> robots; public factory(){ this.location=""moon""; this.name=""factory1""; } public factory(string name, string location){ this.location=location; this.name=name; } public string getname(){ return name; } public string getlocation(){ return location; } public void setname(string name){ this.name=name; } public void setlocation(string location){ this.location=location; } public void work(){ for(int a=0; a<robots.size(); a++){ this.robots.get(a).setbatterylevel(this.robots.get(a).getbatterylevel()-15); } } public void printfactory(){ for(int b=0; b<robots.size(); b++){ this.robots.get(b).printrobot(); } } public void chargeallrobots(){ for(int a=0; a<robots.size();a++){ this.robots.get(a).setbatterylevel(100); } } public void addrobot(robot robot){ if(robots==null){ robots=new arraylist<robot>(); } this.robots.add(robot); } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { public int getbatterylife(); public void recharge(); } public class quiz2 { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\ntum fabrikalar tarafindan toplam "" + robotfactory.num + "" robot uretildi""); }} public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; int b; public abstractrobot(string modelname,int batterylife){ this.batterylife=batterylife; this.modelname=modelname; b=batterylife; } public string getmodelname(){ return this.modelname; } public int getbatterylife(){ return this.batterylife; } public void recharge(){ this.batterylife=b; } public abstract void performtask(); } public class securityrobot extends abstractrobot { private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed){ super(modelname, batterylife); this.isarmed=isarmed; } public boolean getisarmed(){ return this.isarmed; } public void performtask(){ if(this.batterylife>=10){ system.out.println(""[""+this.getmodelname() + ""] scaning for threats... armed: "" +this.isarmed); this.batterylife-=10; } else{ system.out.println( ""[""+this.getmodelname()+""] not enough battery to scan threats...""); } } public void togglearmedmode(){ if(this.isarmed){ this.isarmed=false; } else if(!this.isarmed){ this.isarmed=true; } } } public class cleaningrobot extends abstractrobot{ private int cleaningpower; public cleaningrobot(string modelname, int batterylife, int cleaningpower){ super(modelname, batterylife); this.cleaningpower=cleaningpower; } public void performtask(){ if(this.batterylife>=10){ system.out.println(""[""+this.getmodelname()+ ""] cleaning in progress... cleaning power:"" + this.cleaningpower); this.batterylife-=10;} else{ system.out.println(""[""+this.getmodelname() + ""] not enough battery to clean...""); } } public int getcleaningpower(){ return cleaningpower; } public void boostcleaningpower(int r){ this.cleaningpower+=r; } } import java.util.arraylist; public class robotfactory { static int num=0; private arraylist<abstractrobot> robots=new arraylist<>(); public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ cleaningrobot r=new cleaningrobot(modelname, batterylife, cleaningpower); robots.add(r); num++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ securityrobot r=new securityrobot(modelname, batterylife, isarmed); robots.add(r); num++; } public void performalltasks(){ for(int a=0 ;a<robots.size(); a++){ robots.get(a).performtask(); } } public void displayrobots(){ for(int a=0; a<robots.size(); a++){ if(robots.get(a) instanceof cleaningrobot){ cleaningrobot r=(cleaningrobot) robots.get(a); system.out.println(""cleaningrobot - model: ""+ r.getmodelname()+ "" , battery: "" + r.batterylife + "" , cleaning power: "" +r.getcleaningpower()); } else{ securityrobot r=(securityrobot) robots.get(a); system.out.println(""securityrobot - model: ""+ r.getmodelname()+ "" , battery: "" + r.batterylife + "" , armed: "" + r.getisarmed()); } } } public void upgradecleaningrobots(int miktar){ for(int a=0; a<robots.size(); a++){ if(robots.get(a) instanceof cleaningrobot){ cleaningrobot r=(cleaningrobot) robots.get(a); r.boostcleaningpower(miktar); robots.set(a,r); system.out.println(""cleaningrobot - ""+ r.modelname +"" now has cleaning power: "" +r.getcleaningpower()); } } } public void togglesecurityrobotsmode(){ for(int a=0 ;a<robots.size(); a++){ if(robots.get(a) instanceof securityrobot){ securityrobot r=(securityrobot) robots.get(a); r.togglearmedmode(); robots.set(a, r); system.out.print(""securityrobot - ""+ r.modelname +"" is now ""); if(r.getisarmed()){ system.out.print(""armed""); } else if(!r.getisarmed()){ system.out.print(""unarmed""); } system.out.println(); } } } public int robsum(){ return num; } } 1",36805,4362,695,214,39,19
3688139,2,"3688139 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class lab { public static void main(string[] args) { system.out.println(collatz(5)); } public static int collatz(int i) { if (i == 1) { return 0; } else if (i % 2 == 0) { return collatz(i / 2) + 1; } else { return collatz(i * 3 + 1) + 1; } } } public class labq3 { public static void main(string[] args) { sayac s1 = new sayac(""101101""); sayac s2 = new sayac(""0111""); system.out.println(s2.say()); } } class sayac { string num; string newnum; // ilk num kaybolmasın diye iki tane oluşturdum// int ind = 0; public sayac(string num) { this.num = num; newnum = num; } public int say() { if (ind == num.length() - 1) { if (num.charat(ind) == '1') { return 1; } else { return 0; } } else if (newnum.charat(0) == '1') { newnum = newnum.substring(1); ind++; return say() + 1; } else { newnum = newnum.substring(1); ind++; return say(); } } } public class labq2 { public static void main(string[] args) { int[] arr = { 5, 8, 1, 2, 1, 8, 0, 11, }; cocktailsort(arr); system.out.println(arrayprint(arr, 0)); } public static void cocktailsort(int[] arr) { if (control(arr, 0) != 0) { cocktailsort(arr); } } public static int control(int[] arr, int a) { if (a == arr.length - 1) { return 0; } else { if ((arr[a] > arr[a + 1])) { int x = arr[a]; arr[a] = arr[a + 1]; arr[a + 1] = x; return control(arr, a + 1) + 1; } else return control(arr, a + 1); } } public static string arrayprint(int[] arr, int a) { if (a == arr.length - 1) { return """" + arr[a]; } else { return """" + arr[a] + "","" + arrayprint(arr, a + 1); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arraylist; import java.util.arrays; import java.util.list; import java.util.random; import java.util.random.randomgenerator; abstract class sarki { public string isim; public string sanatci; abstract void oynat(); abstract void gostermetalozellikleri(); } class metalsarki extends sarki { string metalozellik; metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void oynat() { system.out.print(""[metal] ""); system.out.println(sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } public void gostermetalozellikleri() { system.out.println(sanatci + "" - "" + isim + "" "" + ""["" + metalozellik + ""]""); } } class rocksarki extends sarki { rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.print(""[rock] ""); system.out.println(sanatci + "" - "" + isim); } } class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.print(""[klasik] ""); system.out.println(sanatci + "" - "" + isim); } } interface calmastratejisi { public void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); } } } class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { boolean[] arr = new boolean[sarkilistesi.size()]; boolean flag = true; random a = new random(); int p = 0; int r = 0; while (flag) { p++; int x = a.nextint(sarkilistesi.size()); for (int i = 0; i < arr.length; i++) { if (arr[i] == false) { p++; } } if (p > 100000) { break; } if (p == 0) { flag = false; } else if (arr[x] == true) { continue; } sarkilistesi.get(x).oynat(); arr[x] = true; } } } class rockcuozelcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { int y = 0; for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof rocksarki) { if (y == 0) { system.out.println(""[bilgi] ses duzeyi: yuksek""); y++; } } else if (y == 1) { system.out.println(""[bilgi] ses duzeyi : standart""); } sarkilistesi.get(i).oynat(); } } } class muzikcalar { public calmastratejisi strateji; public void setstrateji(calmastratejisi s) { this.strateji = s; } public void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } public class lab2 { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri:""); for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof metalsarki) { sarkilistesi.get(i).gostermetalozellikleri(); } } } } ""recursion"" kavramı nedir, kısaca açıklayınız. methodoverriding, metot içinde metot çalıştırmak recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. tek tek hafıza da bölümler oluşturarak int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. recursive olarak daha iyi okunabilir, hata bulma kısmında daha işlevsel olur. iteratif ise daha az yer kaplar, performans açısından daha iyidir. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? tek tek charat ile baglariz cagiririz. stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack jvm de her bir değer için oluşturan hafıza bölümleridir. stackoverflow ise bunların sonunun olmayıp dolmasıdır. fonskiyonun base casei olmazsa oluşabilir. tail recursion nedir, kısaca açıklayınız. tail recursion fonksiyon baseinin işlemin en sonunda olmasidir. abstraction kavramını açıklayınız. soyutlama. kullanıcıya sadece kendisi için gerekli bilgileri verme. altta ne yapıldığını gizlemek. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? employee returnlu metodu hourlyemployee olarak override etmek mumkundur. tersi ise mumkun degildir cunku atadan alta override edilir. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? protected java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? ata classin constructoruna da ulasmamiz icin. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır. bir atadan birden fazla subclass cikabilir ama her subclass bir ataya baglidir java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a ve b arasında kalitim iliskisi vardir. metot overriding ve overloading kavramlarını açıklayınız. metot overriding subclassların ata classlardan gelen aynı imzalı metotları kendi returnu ile kullanması. metot overloading aynı isimli metotlara farklı parametre verilmesiyle farklı imzalı metotlar olmasıdir. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? 1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract classlar abstract govdesiz metotlar icerebilen siniflardir. normal siniflardan farki nesne olusturamamalaridir. abstract classlarin constructoru olabilir interfacelerin olamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? eger sonrasinda alt sinifta override ediliyorsa (mecbur edecek) evet edilebilir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract metotlar govdesiz metotlardir. ileride kalitim derinlestiginde bize esneklik ve kolaylik saglar. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interfaceler tip olarak kullanilabilir abstractlar kullanilamaz. interfacelerde instance variablelar olusturulmaz. bir class sadece 1 abstract class extend edebilirken birden cok interfacei implement edebilir. marker interface ve functional interface kavramları nedir, nasıl kullanılır? bilmiyorum. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? 1)evet edebilir.2) evet edebilir abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abstract classtan nesne olusturulmus. o kod satiri yerine circle c= new circle(); yazilirsa hata duzeltilmis olur. cikti: drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? hayir edilemez. b interfaceinin a interfaceini implement etmesi gerekir bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true import java.util.arraylist; class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public robot() { name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } public robot(string name, string type, int batterylevel, boolean isoperational) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = isoperational; } public int getbattery() { return batterylevel; } public string getname() { return name; } public string gettype() { return type; } public boolean getisoperational() { return isoperational; } public void setbattery(int a) { batterylevel = a; } public void setname(string n) { name = n; } public void settype(string t) { type = t; } public void setisoperational(boolean o) { isoperational = o; } public void charge() { batterylevel = 100; } public void printrobot() { system.out.print(""robot name= "" + name + "" || ""); system.out.print(""robot type= "" + type + "" || ""); system.out.print(""battery level= "" + batterylevel + "" || ""); system.out.println(""is operational= "" + isoperational); } } public class quizq1 { public static void main(string[] args) { string s = ""a1b2""; int ind = 0; int a = 0; int k = 0; for (int i = 0; i < s.length(); i++) { if ((s.charat(i) >= 'a' && s.charat(i) <= 'z') || (s.charat(i) >= 'a' && s.charat(i) <= 'z')) { a++; } } int[] arg = new int[a]; for (int i = 0; i < s.length(); i++) { if ((s.charat(i) >= 'a' && s.charat(i) <= 'z') || (s.charat(i) >= 'a' && s.charat(i) <= 'z')) { arg[k] = i; k++; } } int size = (int) math.pow(2, a); string[] arr = new string[size]; for (int x = 0; x < a; x++) { if ((s.charat(arg[a]) >= 'a' && s.charat(arg[a]) <= 'z')) { arr[ind] = s.substring(a) + ((char) s.charat(arg[a]) - 'a' + 'a') + s.substring(a + 1); ind++; arr[ind] = s.substring(a) + s.charat(arg[a]) + s.substring(a + 1); ind++; if ((s.charat(arg[a]) >= 'a' && s.charat(arg[a]) <= 'z')) { arr[ind] = s.substring(a) + ((char) s.charat(arg[a]) - 'a' + 'a') + s.substring(a + 1); ind++; arr[ind] = s.substring(a) + s.charat(arg[a]) + s.substring(a + 1); ind++; } } else { arr[ind] = s.substring(a) + ((char) s.charat(arg[a]) - 'a' + 'a') + s.substring(a + 1); ind++; arr[ind] = s.substring(a) + s.charat(arg[a]) + s.substring(a + 1); ind++; } } for (int u = 0; u < size; u++) { system.out.println(arr[u]); } } } import java.util.arraylist; class factory { private string name; private string location; private arraylist<robot> robots = new arraylist<>(); public factory(string name, string location) { this.name = name; this.location = location; } public factory() { name = ""factory1""; location = ""moon""; } public string getname() { return name; } public string getlocation() { return location; } public void setname(string n) { name = n; } public void setlocation(string l) { location = l; } public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for (int i = 0; i < robots.size() - 1; i++) { robots.get(i).charge(); } } public void printfactory() { system.out.print(""factory name= "" + name + "" || ""); system.out.println(""location= "" + location); system.out.println(""robots operating here: ""); for (int i = 0; i < robots.size(); i++) { robots.get(i).printrobot(); } } public void work() { for (int i = 0; i < robots.size() - 1; i++) { robots.get(i).setbattery(robots.get(i).getbattery() - 15); } } } import java.util.arraylist; public class quizzq2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55, true); robot r3 = new robot(""r2-d2"", ""astromech"", 80, true); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } import java.util.arraylist; class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public robot() { name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } public robot(string name, string type, int batterylevel, boolean isoperational) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = isoperational; } public int getbattery() { return batterylevel; } public string getname() { return name; } public string gettype() { return type; } public boolean getisoperational() { return isoperational; } public void setbattery(int a) { batterylevel = a; } public void setname(string n) { name = n; } public void settype(string t) { type = t; } public void setisoperational(boolean o) { isoperational = o; } public void charge() { batterylevel = 100; } public void printrobot() { system.out.print(""robot name= "" + name + "" || ""); system.out.print(""robot type= "" + type + "" || ""); system.out.print(""battery level= "" + batterylevel + "" || ""); system.out.println(""is operational= "" + isoperational); } } import java.util.arraylist; class factory { private string name; private string location; private arraylist<robot> robots = new arraylist<>(); public factory(string name, string location) { this.name = name; this.location = location; } public factory() { name = ""factory1""; location = ""moon""; } public string getname() { return name; } public string getlocation() { return location; } public void setname(string n) { name = n; } public void setlocation(string l) { location = l; } public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for (int i = 0; i < robots.size() - 1; i++) { robots.get(i).charge(); } } public void printfactory() { system.out.print(""factory name= "" + name + "" || ""); system.out.println(""location= "" + location); system.out.println(""robots operating here: ""); for (int i = 0; i < robots.size(); i++) { robots.get(i).printrobot(); } } public void work() { for (int i = 0; i < robots.size() - 1; i++) { robots.get(i).setbattery(robots.get(i).getbattery() - 15); } } } import java.util.arraylist; public class quizzq2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55, true); robot r3 = new robot(""r2-d2"", ""astromech"", 80, true); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public abstract void performtask(); public void recharge(int a) { batterylife = batterylife + a; } public int getbatterylife() { return batterylife; } } import java.util.arraylist; public class quizq2 { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""produced robots:""); factory.displayrobots(); system.out.println(""performing all robot tasks:""); factory.performalltasks(); system.out.println(""upgrading cleaning robots...""); factory.upgradecleaningrobots(10); system.out.println(""toggling security robot modes...""); factory.togglesecurityrobotsmode(); system.out.println(""final robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); robotfactory.robotcount(); } } import java.util.arraylist; public class robotfactory { public static int count = 0; private arraylist<abstractrobot> robots = new arraylist<>(); public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); count++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); count++; } public void performalltasks() { for (int i = 0; i < robots.size(); i++) { robots.get(i).performtask(); } } public void displayrobots() { for (int i = 0; i < robots.size(); i++) { if (robots.get(i) instanceof cleaningrobot) { cleaningrobot a = (cleaningrobot) robots.get(i); system.out.println(""cleaning robot - model: "" + robots.get(i).getmodelname() + "", battery:"" + robots.get(i).getbatterylife() + "", cleaning power:"" + a.getcleaningpower()); } else { securityrobot b = (securityrobot) robots.get(i); system.out.println(""security robot - model: "" + robots.get(i).getmodelname() + "", battery:"" + robots.get(i).getbatterylife() + "", cleaning power:"" + b.getisarmed()); } } } public void upgradecleaningrobots(int miktar) { for (int i = 0; i < robots.size(); i++) { if (robots.get(i) instanceof cleaningrobot) { cleaningrobot a = (cleaningrobot) robots.get(i); a.boostcleaningpower(miktar); system.out.println( ""cleaning robot - "" + a.modelname + "" now has cleaning power: "" + a.getcleaningpower()); } } } public void togglesecurityrobotsmode() { for (int i = 0; i < robots.size(); i++) { if (robots.get(i) instanceof securityrobot) { securityrobot c = (securityrobot) robots.get(i); c.togglearmedmode(); if (c.getisarmed()) { system.out.println(""security robot - "" + c.modelname + "" is now armed""); } else { system.out.println(""security robot - "" + c.modelname + "" is now unarmed""); } } } } public static void robotcount() { system.out.println(""tum fabrikalar tarafindan toplam "" + count + "" robot uretildi""); } } public class securityrobot extends abstractrobot { private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] scanning for threats... armed:"" + isarmed); batterylife = batterylife - 10; } else { system.out.println(""["" + modelname + ""] not enough battery to scan threats...""); } } public void togglearmedmode() { if (isarmed) { isarmed = false; } else { isarmed = true; } } public boolean getisarmed() { return isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] cleaning in progress... cleaning power:"" + cleaningpower); batterylife = batterylife - 10; } else { system.out.println(""["" + modelname + ""] not enough battery to clean...""); } } public void boostcleaningpower() { cleaningpower = cleaningpower + 10; } public int getcleaningpower() { return cleaningpower; } public void boostcleaningpower(int a) { cleaningpower = cleaningpower + a; } } 2",36505,4921,687,230,41,19
6157698,2,"6157698 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class q2 { public static void cocktailsort(int[] arr) { boolean swapped = false; for(int i= 0; i<arr.length-1; i++) { if(arr[i] > arr[i+1]) { int temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; swapped = true; } } if(swapped) { int arr2[] = new int[arr.length-1]; for(int i=1; i< arr.length; i++) { arr2[i-1]= arr[i]; } cocktailsort(arr); } } public static void main(string[] args) { // todo auto-generated method stub int arr[] = {5,4,1,2,7,125,90,12}; cocktailsort(arr); for(int i=0; i< arr.length; i++) { system.out.println(arr[i]); } } } /* if(arr.length == 2) return ; int arr2[] = new int[arr.length-1]; if(arr[0] > arr[1]) { int temp = arr[0]; arr[0]=arr[1]; arr[1]=temp; } for(int i=1; i< arr.length; i++) { arr2[i-1]= arr[i]; } cocktailsort(arr2); cocktailsort(arr2);*/ public class q1 { public static int collatz(int i) { if(i == 1) return 0; if(i%2 == 0) return collatz(i/2)+1; else return collatz(i*3+1)+1; } public static void main(string[] args) { // todo auto-generated method stub system.out.println(""\n""+collatz(5)); } } public class q3 { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); // 2 basacak. } } class sayac{ public string str; public sayac(string str){ this.str = str; } public int say(){ if(str.length()==0) return 0; if(str.indexof('1') == -1) return 0; else { str = str.substring(str.indexof('1')+1); return say()+1; } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arraylist; import java.util.arrays; import java.util.list; import java.util.random; public class q1 { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki.getclass().getname().equals(""metalsarki"")) { metalsarki s = (metalsarki) sarki; s.gostermetalozellikleri(); } // bu kismi cikti ornegini saglayacak sekilde doldurun } } } abstract class sarki{ string isim; string sanatci; abstract void oynat(); } class metalsarki extends sarki{ string metalozellik; //şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void oynat() { system.out.println(""[metal] ""+sanatci+"" - ""+isim+"" (""+metalozellik+"")""); } void gostermetalozellikleri() { system.out.println(sanatci+"" - ""+isim+"" [ozellik: ""+metalozellik+""]""); } } class rocksarki extends sarki{ rocksarki(string isim, string sanatci){ this.isim=isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[rock] ""+sanatci+"" - ""+isim+"" (huzurlu ve nostaljik)""); } } class klasiksarki extends sarki{ klasiksarki(string isim, string sanatci){ this.isim=isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[klasik] ""+sanatci+"" - ""+isim+"" (hafif ve sakin)""); } } abstract class calmastratejisi{ abstract void cal(list<sarki> sarkilistesi); } class siralicalma extends calmastratejisi{ void cal(list<sarki> sarkilistesi){ for(sarki sarki : sarkilistesi) { sarki.oynat(); } system.out.println(); } } class karisikcalma extends calmastratejisi{ void cal(list<sarki> sarkilistesi){ random rand = new random(); list<sarki> calinmamis = new arraylist<sarki>(sarkilistesi); while(calinmamis.size() > 0) { int x = rand.nextint(calinmamis.size()); calinmamis.get(x).oynat(); calinmamis.remove(x); } system.out.println(); } } class rockcuozelcalma extends calmastratejisi{ void cal(list<sarki> sarkilistesi){ boolean stillrock = false; for(sarki sarki : sarkilistesi) { if(sarki.getclass().getname().equals(""rocksarki"")) { if(!stillrock) system.out.println(""[bilgi] ses duzeyi: yuksek""); stillrock = true; } else if(stillrock){ system.out.println(""[bilgi] ses duzeyi: normal""); stillrock =false; } sarki.oynat(); } system.out.println(); } } class muzikcalar{ calmastratejisi strateji; void setstrateji(calmastratejisi s) { this.strateji = s; } void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } abstraction kavramını açıklayınız. amacımıza ulaşmak için gerekli olmayan bilgileri atmak ve sadece ilgili olanları bırakmak. dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? eğer hourlyemployee employee nin subclassı ise mümkündür. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? protected java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? subclasslardan hemen üstünde olmayan parent classın değerlerine erişebilmek için java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır bu durum olası karışıklıkları engellemek için mümkün değildir ve diamond problem olarak adlandırılır java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a b'nin subclasslarından birisi demektir metot overriding ve overloading kavramlarını açıklayınız. overriding aynı sinature'a sahip bir methodun tekrar yazılması ve parent classtaki halinin yerine kullanılmasıdır. ovrloading aynı isimli bir methodun parametrelerinin değiştirilmesi sonucu genelde aynı işlemi daha fazla ya da az parametreyle yapacak bir methodun oluşturulmasıdır class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? yazdırmaz class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? static binding methodların override edilme ihtimalinin olmadığı durumlarda olur iken dynamic binding methodların override edilme ihtimali olduğu durumlarda olur. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? static private ve final methodlar override edilemedikleri için static bindingle bağlanır. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloading yaparken signature birbirinden ayrı olduğu için static binding gerçekleşir. overriding yaparken reference variable'dan objeye kadar en son override edilmiş method kullanılacağı için dynamic binding olur dinamik bağlamada jvm'nin görevi nedir? methodun override edilme ihtimaline karşı reference variable'ın olduğu class'tan objeye kadar methodun en son override edildiği noktadaki halini bulmaktır. java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? .parent childın bütün özelliklerine sahip olmayabileceği için sıkıntı olabilir.(implicit ne bilmiyorum) java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? dynamic binding sürekli override edilip edilmediğini kontrol etmesi gerektiği için zaman kaybı yaşanırdı.(dynamic yavaş olduğundan) class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? dinamik child class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? book product dinamik java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class içinde tanımlanmamış abstract methodu olan ya da üstündeki class ya da interfaceden tanımlanmamış abstract method alan class'lara denir. objeleri olamadığı için constructorları olamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? evet edilebilir ama implement edilen method dışında classda abstract başka bir methodun olmaaı gerekir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. nasıl implement edileceği belli olmayan methodlar yazmamızı sağlar. bir sınıflandırma yapmış oluruz. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract classlar interfacelerden farklı olarak reference variable olarak kullanılabilir ve classlar başka bir classa extend edilirken interfaceler implement edilir ve 1 class 1den fazla interface implement edebilir. abstractclass onje oluşturamasada refence variable olarak kullanılabilir. interface kullanılamaz. marker interface ve functional interface kavramları nedir, nasıl kullanılır? sadece düzenleme amaçlı kullanılır. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet evet abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? new shape() objesi shape abstract bir clss olduğundan oluşturulamaz. yerine new circle() ifadesi gelirse output: drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? compile edilmez. implement edilen interfacelerde aynı signature'a sahip methodun olması. java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. 3 fileio numericalmismatch java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? override ettiği metoddan daha üst, genel bir şey throw edemez eğer override ettiği metod exception throwluyorsa throwable throwlayamaz finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally bloğu try da ya da catch exception olup olmamasına bakmaksızın çalışan kod bloğudur java'da kendi exceptionunuzu nasıl tanımlarsınız? throw new aexception(""this is aexception"") java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? . static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done -1 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? trying m1 caught1 finally bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true import java.util.arraylist; public class q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } class robot{ private string name; private string type; private int batterylevel; // 100 ile 0 arasında bir değer private boolean isoperational; // bataryası varsa true robot(){ this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } robot(string name, string type, int batterylevel){ this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = true; } public string getname () {return name;} public string gettype () {return type;} public int getbatterylevel () {return batterylevel;} public boolean getisoperational () {return isoperational;} public void setname(string name) {this.name = name;} public void settype(string type) {this.type = type;} public void setbatterylevel(int batterylevel) {this.batterylevel = batterylevel;} public void setisoperational(boolean isoperational) {this.isoperational = isoperational;} public void charge() {batterylevel = 100;} public void printrobot() { system.out.println(""robot name: ""+name+""\nrobot type: ""+type+""\nbatterylevel: ""+batterylevel+""\nisoperational: ""+isoperational); } } class factory{ private string name; private string location; private arraylist<robot> robots = new arraylist<robot>(); public factory(string name, string location) { this.name = name; this.location = location; } public factory(){ this.name = ""factory1""; this.location = ""moon""; }// name = “factory1” ve location = “moon” yapar. //private değişkenler için get ve set metotları. public string getname () {return name;} public string getlocation () {return location;} public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for(int i = 0; i<robots.size();i++) { robots.get(i).charge(); } } //tüm robotların şarjını 100 yapar. public void printfactory() { system.out.println(""factory name: ""+name); system.out.println(""location: ""+location); system.out.println(""robots operating here:""); for(int i = 0; i<robots.size();i++) { robots.get(i).printrobot(); system.out.println(); } } //ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work() { for(int i = 0; i<robots.size();i++) { robots.get(i).setbatterylevel(robots.get(i).getbatterylevel()-15); } } //her robotun şarjı %15 azalır. } public class q1_calismiyor { public static void main(string[] args) { string s = ""a1b2""; //abc /* * abc * abc * abc * abc * abc * abc * abc * abc * * ab * * ab * ab * ab */ // int[] indexes = letterindexes(s); // int nletters =0; //number of letters // for(int i : indexes) { // if(i != 0) // nletters++; // } // // boolean[] changed = new boolean[s.length()]; // changed = booleanreset(changed); // // for(int i=0; i<math.pow(2, nletters);i++) { // } system.out.println(recurv(s)); } public static string recurv(string str) { if(str.length()==0) return """"; char c = str.charat(0); if( c >= 'a' && c <= 'z') return """"+(char)(c+'a'-'a') + recurv(str.substring(1)); else if(c >= 97 && c <= 122) return """"+(char)(c-('a'-'a')) + recurv(str.substring(1)); return """"+c+recurv(str.substring(1)); } public static int[] letterindexes(string str) { int[] indexes = new int[str.length()]; for(int i =0; i<indexes.length; i++) { indexes[i] = 0; } for(int i=0; i<str.length();i++) { char c =str.charat(i); if( c >= 65 && c <= 90) indexes[i] = 2; if(c >= 97 && c <= 122) indexes[i] = 1; } return indexes; } public static boolean[] booleanreset(boolean[] arr) { for(boolean a : arr) { a = false; } return arr; } } 2",25863,3401,501,156,42,53
9167236,5,"9167236 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. package lab1; public class ibrahimerenyilmaz { public static void main(string[] args) { system.out.println(""\n"" + ""---------------------- soru - 1 ----------------------"" + ""\n""); system.out.print(""5: ""); system.out.println(collatz(5) + ""\n""); system.out.print(""7: ""); system.out.println(collatz(7) + ""\n""); system.out.print(""10: ""); system.out.println(collatz(10) + ""\n""); system.out.println(""---------------------- soru - 2 ----------------------"" + ""\n""); int arr1[] = {5, 4, 1, 2}; cocktailsort(arr1); system.out.print(""5, 4, 1, 2 -> ""); for (int i = 0; i < arr1.length - 1; i++) { system.out.print(arr1[i] + "", ""); } system.out.print(arr1[3]); system.out.println(""\n""); int arr2[] = {10, 3, 8, 2, 6, 1, 5}; cocktailsort(arr2); system.out.print(""10, 3, 8, 2, 6, 1, 5 -> ""); for (int i = 0; i < arr2.length - 1; i++) { system.out.print(arr2[i] + "", ""); } system.out.print(arr2[6]); system.out.println(""\n""); int arr3[] = {7, 5, 4, 1, 6, 9}; cocktailsort(arr3); system.out.print(""7, 5, 4, 1, 6, 9 -> ""); for (int i = 0; i < arr3.length - 1; i++) { system.out.print(arr3[i] + "", ""); } system.out.print(arr3[5]); system.out.println(""\n""); system.out.println(""---------------------- soru - 3 ----------------------"" + ""\n""); sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); sayac s3 = new sayac(""010010010100100001000000010000""); system.out.println(s1.tostring() + "": "" + s1.say()); // 2 system.out.println(s2.tostring() + "": "" + s2.say()); // 4 system.out.println(s3.tostring() + "": "" + s3.say()); // 7 system.out.println(); } //------------------------------------------------------------------------------------------- public static int collatz(int i){ if(i == 1){ system.out.print(i + "" -> ""); return 0; } else{ if(i % 2 == 0){ system.out.print(i + "", ""); return 1 + collatz(i / 2); } else{ system.out.print(i + "", ""); return 1 + collatz((i * 3) + 1); } } } //------------------------------------------------------------------------------------------- public static void cocktailsort(int[] arr) { cocktailsortrecursive(arr, 0, arr.length - 1, true); } public static void cocktailsortrecursive(int[] arr, int left, int right, boolean forward) { if (left >= right) { return; } boolean swapped = false; if (forward) { for (int i = left; i < right; i++) { if (arr[i] > arr[i + 1]) { swap(arr, i, i + 1); swapped = true; } } if (!swapped) { return; } cocktailsortrecursive(arr, left, right - 1, false); } else { for (int i = right; i > left; i--) { if (arr[i] < arr[i - 1]) { swap(arr, i, i - 1); swapped = true; } } if (!swapped) { return; } cocktailsortrecursive(arr, left + 1, right, true); } } private static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } //------------------------------------------------------------------------------------------- public static class sayac { string input; public sayac(string input){ this.input = input; } public int ozyinelisay(string n){ if(n.length() == 0){ return 0; } else{ return (n.charat(0) == '1' ? 1 : 0) + ozyinelisay(n.substring(1)); } } public int say(){ int output = ozyinelisay(input); return output; } @override public string tostring(){ return """" + this.input; } } } //------------------------------------------------------------------------------------------- müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { calmastratejisi strateji; public void setstrateji(calmastratejisi s) { this.strateji = s; } public void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki metalsarki){ metalsarki.gostermetalozellikleri(); } } } } public class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } @override public void oynat() { system.out.println(""[klasik] "" + this.sanatci + "" - "" + this.isim + "" (hafif ve sakin)""); } } public class metalsarki extends sarki { string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void gostermetalozellikleri(){ system.out.println(this.sanatci + "" - "" + this.isim + "" [ozellik: "" + metalozellik + ""]""); } @override public void oynat() { system.out.println(""[metal] "" + this.sanatci + "" - "" + this.isim + "" ("" + this.metalozellik + "")""); } } public class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } @override public void oynat() { system.out.println(""[rock] "" + this.sanatci + "" - "" + this.isim + "" (huzurlu ve nostaljik)""); } } import java.util.list; public class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean[] calindi = new boolean[sarkilistesi.size()]; for (int i = 0; i < calindi.length; i++) { calindi[i] = false; } int count = 0; int index; while(count < sarkilistesi.size()){ index = (int)(math.random() * sarkilistesi.size()); if(calindi[index] == false){ calindi[index] = true; sarkilistesi.get(index).oynat(); count++; } } } } import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { sarkilistesi.get(i).oynat(); } } } public abstract class sarki { string isim; string sanatci; abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean sesyuksek = false; for (int i = 0; i < sarkilistesi.size(); i++) { if(!sesyuksek && sarkilistesi.get(i).getclass().getname().equals(""rocksarki"")){ system.out.println(""[bilgi] ses duzeyi: yuksek""); sarkilistesi.get(i).oynat(); sesyuksek = true; } else if(sesyuksek && !(sarkilistesi.get(i).getclass().getname().equals(""rocksarki""))){ system.out.println(""[bilgi] ses duzeyi: normal""); sarkilistesi.get(i).oynat(); sesyuksek = false; } else{ sarkilistesi.get(i).oynat(); } } } } import java.util.list; public interface calmastratejisi{ public void cal(list<sarki> sarkilistesi); } bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true // i̇brahim eren yılmaz - 231101031 import java.util.arraylist; public class q2 { public static class robot { private string name; private string type; private int batterylevel; // 100 ile 0 arasında bir değer private boolean isoperational; // bataryası varsa true public robot(){ this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public robot(string name, string type, int batterylevel){ this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = true; } public string getname() { return name; } public string gettype() { return type; } public int getbatterylevel() { return batterylevel; } public boolean isisoperational() { return isoperational; } public void setname(string name) { this.name = name; } public void settype(string type) { this.type = type; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public void setisoperational(boolean isoperational) { this.isoperational = isoperational; } public void charge(){ this.batterylevel = 100; } public void printrobot(){ system.out.println( ""robot name: "" + this.name + "" robot type: "" + this.type + "" batterylevel: "" + this.batterylevel + ""%"" + "" isoperational: "" + this.isoperational ); } } public static class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name, string location){ this.name = name; this.location = location; robots = new arraylist<>(); } public factory(){ this.name = ""factory1""; this.location = ""moon""; robots = new arraylist<>(); } public string getname() { return name; } public string getlocation() { return location; } public arraylist<robot> getrobots() { return robots; } public void setname(string name) { this.name = name; } public void setlocation(string location) { this.location = location; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public void addrobot(robot robot){ this.robots.add(robot); } public void chargeallrobots(){ for (int i = 0; i < this.robots.size(); i++) { robots.get(i).charge(); } } public void work(){ // her robotun şarjı %15 azalır. for (int i = 0; i < this.robots.size(); i++) { robots.get(i).setbatterylevel(robots.get(i).getbatterylevel() - 15); } } public void printfactory(){ system.out.println(""factory name: "" + this.name + ""location: "" + this.location); system.out.println(""robots operating here: ""); for (int i = 0; i < this.robots.size(); i++) { robots.get(i).printrobot(); } } } public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } // i̇brahim eren yılmaz - 231101031 import java.util.arraylist; public class q1 { public static void main(string[] args) { system.out.println(subsets(""a1b2"")); } public static arraylist<string> subsets(string input) { arraylist<string> result = new arraylist<>(); recursive(input, 0, """", result); return result; } private static void recursive(string input, int index, string current, arraylist<string> result) { if (index == input.length()) { result.add(current); return; } char ch = input.charat(index); if (ch >= 'a' && ch <= 'z') { recursive(input, index + 1, current + ("""" + ch).tolowercase(), result); recursive(input, index + 1, current + ch, result); } else if (ch >= 'a' && ch <= 'z') { recursive(input, index + 1, current + ("""" + ch).touppercase(), result); recursive(input, index + 1, current + ch, result); } else { recursive(input, index + 1, current + ch, result); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery{ int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife){ this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname(){ return modelname; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); // ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz system.out.println(""\n""); robotfactory.displaytotalmanufacturedrobots(); system.out.println(""\n""); } } public class securityrobot extends abstractrobot { private boolean isarmed; public securityrobot(string name, int batterylife, boolean isarmed) { super(name, batterylife); this.isarmed = isarmed; } @override public void recharge() { this.batterylife = 100; } @override public int getbatterylife() { return batterylife; } @override public void performtask(){ if(batterylife >= 10){ system.out.println(""["" + modelname + ""] scanning for threats... armed: "" + isarmed); batterylife = batterylife - 10; } else{ system.out.println(""["" + modelname + ""] not enough battery to scan threats...""); } } public void togglearmedmode(){ this.isarmed = !this.isarmed; } public boolean isisarmed() { return isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; public cleaningrobot(string name, int batterylife, int cleaningpower) { super(name, batterylife); this.cleaningpower = cleaningpower; } @override public void recharge() { this.batterylife = 100; } @override public int getbatterylife() { return batterylife; } @override public void performtask(){ if(batterylife >= 10){ system.out.println(""["" + modelname + ""] cleaning in progress... cleaning power: "" + cleaningpower); batterylife = batterylife - 10; } else{ system.out.println(""["" + modelname + ""] not enough battery to clean...""); } } public void boostcleaningpower(int miktar){ this.cleaningpower += miktar; } public int getcleaningpower() { return cleaningpower; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; private static int totalmanufacturedrobots = 0; public robotfactory(){ this.robots = new arraylist<>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); totalmanufacturedrobots++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ robots.add(new securityrobot(modelname, batterylife, isarmed)); totalmanufacturedrobots++; } public void performalltasks(){ for (int i = 0; i < robots.size(); i++) { robots.get(i).performtask(); } } public void displayrobots(){ for (int i = 0; i < robots.size(); i++) { if(robots.get(i) instanceof cleaningrobot cleaningrobot){ system.out.println(""cleaningrobot - model: "" + cleaningrobot.getmodelname() + "", battery: "" + cleaningrobot.getbatterylife() + "", cleaning power: "" + cleaningrobot.getcleaningpower() ); } else if(robots.get(i) instanceof securityrobot securityrobot){ system.out.println(""securityrobot - model: "" + securityrobot.getmodelname() + "", battery: "" + securityrobot.getbatterylife() + "", armed: "" + securityrobot.isisarmed() ); } } } public void upgradecleaningrobots(int miktar){ for (int i = 0; i < robots.size(); i++) { if(robots.get(i) instanceof cleaningrobot cleaningrobot){ cleaningrobot.boostcleaningpower(miktar); system.out.println(""cleaningrobot - "" + cleaningrobot.getmodelname() + "" now has cleaning power: "" + cleaningrobot.getcleaningpower()); } } } public void togglesecurityrobotsmode(){ string armed = ""armed""; string unarmed = ""unarmed""; for (int i = 0; i < robots.size(); i++) { if(robots.get(i) instanceof securityrobot securityrobot){ securityrobot.togglearmedmode(); system.out.println(""securityrobot - "" + securityrobot.getmodelname() + "" is now "" + (securityrobot.isisarmed() ? armed : unarmed)); } } } public static void displaytotalmanufacturedrobots() { system.out.println(""tum fabrikalar tarafindan toplam "" + totalmanufacturedrobots + "" robot uretildi""); } } 5",31583,3962,575,184,23,38
4856424,0,"4856424 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class fatmasemra1 { public static void main(string[] args) { int[] sayilar; system.out.println(); } public static void cocktailsort(int[] arr) { for(int i=0; i< arr.length;i++) { if(arr[i]>arr[i+1]) { int temp = arr[i]; arr[i] = arr[i+1]; temp = arr[i+1]; } } } } public class fatmasemraozmen { public static void main(string[] args) { system.out.println(collatz(5)); } public static int collatz(int i) { if(i == 1) { return 0; } if(i % 2 == 0) { i = i/2; return 1+ collatz(i); }else { i = 3*i+1; return 1 +collatz(i); } } } public class sayacmain { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } public class sayac { private string str; public sayac(string str){ this.str = str; } public int say(){ return helper(str,0); } private int helper(string str,int i) { if(i >= str.length()) { return 0; } if(str.charat(i) == '1') { return 1 + helper(str,i+1); } else { return helper(str,i+1); } } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.collections; import java.util.list; import java.util.arrays; abstract class sarki{ string isim; string sanatci; abstract void oynat(); } class metalsarki extends sarki{ string metalozellik; metalsarki(string isim,string sanatci,string metalozellik){ this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } void oynat() { if(metalozellik.equals(""aykiri ve atmosferik"")) { system.out.println(""[metal] "" + this.sanatci +""-""+ this.isim +""aykiri ve atmosferik""); } if(metalozellik.equals(""enstrumantal"")) { system.out.println(""[metal] "" + this.sanatci +""-""+ this.isim +""enstrumantal""); } } void gostermetalozellikleri(){ system.out.println(""[metal] "" + this.sanatci +""-""+ this.isim + "" [ozellik: this.metalozellik]""); } } class rocksarki extends sarki{ rocksarki(string isim,string sanatci){ this.isim = isim; this.sanatci = sanatci; } void oynat() { system.out.println(""[rock] "" + this.sanatci +""-""+ this.isim +""(huzurlu ve nostaljik)""); } } class klasiksarki extends sarki{ void oynat() { system.out.println(""[klasik] "" + this.sanatci +""-""+ this.isim +""(hafif ve sakin)""); } klasiksarki(string isim,string sanatci){ this.isim = isim; this.sanatci = sanatci; } } interface calmastratejisi{ void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi) { for(sarki sarki: sarkilistesi) { sarki.oynat(); } } } class karisikcalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi) { collections.shuffle(sarkilistesi); for(sarki sarki: sarkilistesi) { sarki.oynat(); } } } class rockcuozelcalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi) { boolean yuksekses = false; for(sarki sarki: sarkilistesi) { if(sarki instanceof rocksarki && yuksekses == false) { system.out.println(""[bilgi] ses duzeyi: yuksek""); yuksekses = true; }else if(!(sarki instanceof rocksarki && yuksekses == true)) { system.out.println(""[bilgi] ses duzeyi: normal""); yuksekses = false; } sarki.oynat(); } } } class muzikcalar{ calmastratejisi strateji; void setstrateji(calmastratejisi s) { this.strateji = s; } void muzikcal(list<sarki>sarkilistesi) { strateji.cal(sarkilistesi); } } public class lab2 { public static void main(string[] args) { sarki s1 = new metalsarki("" years of silence"", ""thurisaz "", ""aykiri ve atmosferik""); sarki s2 = new metalsarki("" voice of the soul"",""death "","" enstrumantal""); sarki s3 = new rocksarki("" small mountain"",""midlake""); sarki s4 = new rocksarki("" ankara"",""vega""); sarki s5 = new klasiksarki(""una mattina"","" ludovico einaudi ""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } } } } ""recursion"" kavramı nedir, kısaca açıklayınız. fonksiyonu tekrar çağırma işlemidir recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. parametreler, cagirilan fonksiyon ve parametreyi güncelleme jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. bilmiyorum int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. iteratif olarak daha verimlidir hem zaman hem bilgisayar kullanimi acisindan bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? stringin 0. endeksi base case olur stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. bilmiyorum tail recursion nedir, kısaca açıklayınız. problemi bölerek elde edilen çözümleri birleştirmek abstraction kavramını açıklayınız. gerekli bilgileri alıp kalanıyla ilgilenmeme dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? ikiside olmaz protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? inheritance dan dolayı parent class daki degiskenleri almak için java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? bilmiyorum metot overriding ve overloading kavramlarını açıklayınız. override: parent classtaki bir metodun uzantisindaki baska bir sinifta yine olmasi ama farkli bir ifadeyle mesela kedi köpek ve balık üçününde parent classi hayvanlardir ama kuş koşamaz uçabilir overloading ise bir metodun ismi ayni ama parametrelerinin farkli olarak kullanilmasidir class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? 1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? bilmiyorum java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? cagrilan methodlarin turune gore degisir java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? derleme zamanlari bellidir overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloading icin statik overriding icin dinamik dinamik bağlamada jvm'nin görevi nedir? bilmiyorum java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? bilmiyorum java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? bilmiyorum class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child dinamik class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book statik java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class ın concrete classlarda oldugu gibi objesi tanımlanamaz , constructorları olabilir abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? alt sınıflarda implement ederse edilebilir abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. nesneleri olamaz içlerinde hem abstract hem de concrete metodlar bulunabilir abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? bilmiyorum marker interface ve functional interface kavramları nedir, nasıl kullanılır? bilmiyorum bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? ikisi de evet abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abstract class ın direkt olarak objesini tanımlayamayız circle c = new shape(); c.draw(); c.display(); drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? bilmiyorum java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. kontrol edilen ve kontrol edilmeyen java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? bilmiyorum finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? bilmiyorum java'da kendi exceptionunuzu nasıl tanımlarsınız? exceptionu extend ederek java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? bu duruma rethrowing denir hata kaynağını saklamak amaç olabilir static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? bilmiyorum static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? bilmiyorum bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class soru1main { public static void main(string[] args) { string str = ""a1b2""; soru1class obj = new soru1class(str); system.out.println(obj.yenidizi()); } } public class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public robot(){ name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } public robot(string name, string type, int batterylevel, boolean isoperational){ this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = isoperational; } public string getname() { return name; } public string gettype() { return type; } public int getbatterylevel() { return batterylevel; } public boolean getisoperational() { return isoperational; } public void setname() { this.name = name; } public void settype() { this.type = type; } public void setbatterylevel() { this.batterylevel = batterylevel; } public void setisoperational() { this.isoperational = isoperational; } public void charge() { batterylevel = 100; } public void printrobot() { system.out.println(""robot name:""+ name + "" robot"" + "" type:"" + type + ""batterylevel:"" + batterylevel + ""%"" + ""isoperational:"" + isoperational) ; } } public class soru2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"",55,true); robot r3 = new robot(""r2-d2"",""astromech"",80,true); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name,string location) { this.name = ""factory1""; this.location = ""moon""; } public string getname(){ return name; } public string getlocation() { return location; } public arraylist<robot> getrobots() { return robots; } public void setname(string name) { this.name = name; } public void setlocation(string location) { this.location = location; } public void setrobots(arraylist<robot> robots) { for(int i = 0; i < robots.size();i++) { } } public void addrobot(robot robot) { } public void chargeallrobots() { for(int i = 0; i<robots.size(); i++) { } } public void printfactory() { system.out.println(""fcatory name:"" + name + "" location"" + location); system.out.println(""robots operating here:""); for(int i = 0; i<robots.size(); i++) { system.out.println(""robot name:"" + r1.getname() + ""type:"" + ) } } public void work() { for(int i = 0; i<robots.size();i++) { } } } public class soru1class { string str; soru1class(string str){ this.str = str; } public string yenidizi() { return helper(str,0); } private string helper(string str,int i) { if(str.charat(i) == '1') { return helper(str,i+1); } if(str.charat(i) == '2') { return helper(str,i+1); } if(str.charat(i) == 'a') { str.tolowercase(); return helper(str,i+1); } if(str.charat(i) == 'a') { str.touppercase(); return helper(str,i+1); } if(str.charat(i) == 'b') { str.tolowercase(); return helper(str,i+1); } if(str.charat(i) == 'b') { str.touppercase(); return helper(str,i+1); } return str; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public class quiz2 { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); //factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); //factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); } } public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public abstractrobot(string modelname,int bbatterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public abstract void performtask(); } public class securityrobot extends abstractrobot{ private boolean isarmed; securityrobot(string modelname, int batterylife, boolean isarmed){ super(modelname,batterylife); this.isarmed = isarmed; } public int getbatterylife() { return this.batterylife; } public void recharge() { this.batterylife = 100; } @override public void performtask() { if(this.batterylife>=10) { system.out.println(""[""+this.modelname+""]""+ "" scanning for threats...""+ "" armed:""+this.isarmed); this.batterylife -= 10; }else { system.out.println(""[""+this.modelname+""]""+ "" not enough battery to scan threats...""); } } public void togglearmedmode() { if(isarmed == true) { isarmed = false; }else { isarmed = true; } } } public class cleaningrobot extends abstractrobot { private int cleaningpower; cleaningrobot(string modelname,int batterylife,int cleaningpower){ super(modelname,batterylife); this.cleaningpower = cleaningpower; } public int getbatterylife() { return this.batterylife; } public void recharge() { this.batterylife = 100; } public void performtask() { if(this.batterylife>=10) { system.out.println(""[""+this.modelname+""]""+ "" cleaning in progress...""+ "" cleaningpower:""+this.cleaningpower); this.batterylife -= 10; }else { system.out.println(""[""+this.modelname+""]""+ "" not enough battery to clean...""); } //public void boostcleaningpower() { } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { cleaningrobot robot = new cleaningrobot(modelname, batterylife, cleaningpower); string modelname1; int batterylife1; int cleaningpower1; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { securityrobot robot = new securityrobot(modelname, batterylife, isarmed); string modelname1; int batterylife1; int cleaningpower1; } public void performalltasks() { for(abstractrobot robot: robots) { robot.performtask(); } } public void displayrobots() { for(abstractrobot robot: robots) { if(robot instanceof cleaningrobot){ system.out.println(""cleaningrobot"" + "" -"" + ""model:"" + robot.modelname + "", "" + ""battery:"" + robot.batterylife +"", "" + ""cleaning power:"" ); }else { system.out.println(""securityrobot"" + "" -"" + ""model:"" + robot.modelname + "", "" + ""battery:"" + robot.batterylife +"", "" + ""armed:"" ); } } } public void upgradecleaningrobots(int miktar) { } public void togglesecurityrobotsmodel() { } } ",33788,4256,633,219,46,21
9164612,3,"9164612 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. //tip to <b>run</b> code, press <shortcut actionid=""run""/> or // click the <icon src=""allicons.actions.execute""/> icon in the gutter. public class main { public static void main(string[] args) { int i = 5; system.out.println(collatz(i)); int []ar = {5,4,1,2}; cocktailsort(ar); for (int j = 0;j<ar.length;j++) { system.out.print(ar[j] + "" ""); } system.out.println(); sayac s1 = new sayac(""10001""); system.out.println(s1.say()); } public static int collatz(int i) { if(i == 1) { return 0 ; // 1 oldugu zaman 0 donerek cikmasi icin bir base case yazdim } else { if(i%2 == 0) { return 1 + collatz(i/2); // 2 ile bolumunden kalan 0 ise adim sayisi 1 artarak 2ye bolunmus hali gelecek } else { return 1+ collatz((i*3) + 1); // 2 ile bolumunden kalan 0 degil ise adim sayisi 1 artarak 3 ile capilip 1 eklenmis hali gelecek } } } public static void cocktailsort(int[] arr) { cocktailsort2(arr, 0, arr.length - 1); // yazdigim methodu recursive cagirdim. } public static void cocktailsort2(int[] arr, int start, int end) { if (start >= end){ // start end degerinden buyukse program sona erecek. return; } boolean degisme = false; // sonrasında guncellemek ve degisebilir mi diye bakmak icin boolean tuttum. for (int i = start; i < end; i++) { // diziyi ileriye dogru bubble sort ile siraladim. if (arr[i] > arr[i + 1]) { int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; degisme = true; } } if (!degisme) { return; // eger degisme degiskeninde degisiklik olmadiysa dizi sıralidir anlamina gelir. } degisme = false; // bir sonraki siralamaya bakmak icin degiskeni tekrar false yaptim. for (int i = end - 1; i > start; i--) { if (arr[i] < arr[i - 1]) { int temp = arr[i]; arr[i] = arr[i - 1]; // geriye yonlü bubble sort ile siraladim. arr[i - 1] = temp; degisme = true; } } cocktailsort2(arr, start + 1, end - 1); // methodu start ve end degerlerini guncelleyerek recursive cagirdim. } } import java.util.stack; public class sayac { private string input; public sayac(string input) { this.input = input; } public int say() { return countones(input,0); // yazdigim yardimci methodu burada cagirdim } public int countones(string input, int index) { int count = 0; if(index >= input.length()) { return 0; // index out of bounds almamak icin base case yazdim. } else { if(input.charat(index) == '1') { count = 1; // 1 gordugu zaman count degiskeni 1 olacak } else { count = 0; // 1 yoksa 0 olarak kalacak. } } int sonuc = countones(input,index+1); // her bir karakterde recursive cagirdim ve bunu yeni bir degiskene atadim. count += sonuc; // count degerini surekli guncelledim. return count; } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { private calmastratejisi strateji; public void setstrateji(calmastratejisi strateji) { this.strateji = strateji; } public void muzikcal(list<sarki> sarkilistesi) { if (strateji != null) { strateji.cal(sarkilistesi); } else { system.out.println(""calma stratejisi secilmedi.""); } } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrümantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""\nsirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""\nkarisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""\nrockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""\nmetal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } } } } public class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { super(isim, sanatci); } @override public void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } public class metalsarki extends sarki { private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(isim, sanatci); this.metalozellik = metalozellik; } @override public void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } public void gostermetalozellikleri() { system.out.println(sanatci + "" - "" + isim + "" [ozellik]: "" + metalozellik); } } public class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { super(isim, sanatci); } @override public void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } import java.util.collections; import java.util.list; public class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { collections.shuffle(sarkilistesi); for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } import java.util.list; class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } public abstract class sarki { public string isim; public string sanatci; public sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } public abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean sesyukseltildi = false; for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki) { if (!sesyukseltildi) { system.out.println(""[bilgi] ses duzeyi: yuksek""); sesyukseltildi = true; } } sarki.oynat(); } if (sesyukseltildi) { system.out.println(""[bilgi] ses duzeyi: normal""); } } } import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? java'da abstract class genellikle diğer sınıflar tarafından miras alınması için kullanılan ve kendisinden nesne oluşturulamayan bir sınıftır.concrete class tüm metotları tanımlanmış ve doğrudan nesne oluşturulabilen normal bir sınıftır. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? evet, abstract bir metot, abstract bir class içinde implement edilebilir, ancak bu zorunlu değildir. abstract class içinde bir metodu implement etmek isterseniz, metot gövdesini yazabilirsiniz. eğer metodu gövdesiz bırakırsanız, bu metodun alt sınıflar tarafından override edilmesi gerekir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. ortak davranışları tanımlayarak kod tekrarını azaltır. kalıtım ile polymorphism sağlar.nesne üretimini kısıtlayarak güvenli bir yapı sunar. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract class hem abstract hem de concrete metotlar içerebilir, interface ise sadece abstract metotlar içerebilir. interface multiple inheritance destekler, abstract class sadece single inheritance destekler.abstract class ve interface bir değişkenin veri tipi olarak kullanılabilir. ancak doğrudan nesne oluşturulamaz, bir alt sınıf veya implement eden bir sınıfın nesnesi bu tip değişkenlere atanmalıdır. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface, herhangi bir metot içermeyen ancak bir sınıfa özel bir anlam kazandıran bir interface türüdür.functional interface, yalnızca bir tane abstract metot içeren bir interface’dir. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? bir class birden fazla interface’i implement edebilir. java'da çoklu kalıtım doğrudan desteklenmez, ancak interface’ler aracılığıyla çoklu implementasyon mümkündür. bir interface başka bir interface’i implement edemez, çünkü implementasyon yalnızca class'lara özgüdür. ancak, bir interface başka bir interface’i extends anahtar kelimesi ile genişletebilir. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abstract class’lardan doğrudan nesne oluşturulamaz. shape sınıfı abstract olduğu için abstract sınıfın yerine onun alt sınıfı olan circle kullanılarak düzeltilebilir. output: drawing circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? edilemez bir class'ın birden fazla interface’i implement etmesi ve aynı isimli default metotları içermesi durumunda hangi metodu çağıracağını bilemez. a.super.show() veya b.super.show() şeklinde hangi interface’in metodu çağrılacaksa onu açıkça belirtmeliyiz. outuput: a.super.show() yazılırsa a, b.super.show() yazılırsa b java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. . java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? . finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? . java'da kendi exceptionunuzu nasıl tanımlarsınız? . java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? . static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? . static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? . bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot { private string type; private string name; private int batterylevel; private boolean isoperational; public robot() { this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public string getname() { return name; } public void setname(string name) { this.name = name; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public boolean isoperational() { return isoperational; } public void setoperational(boolean isoperational) { this.isoperational = isoperational; } public robot(string name, string type, int batterylevel) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = batterylevel > 0; } public void charge() { this.batterylevel = 100; this.isoperational = true; } public void printrobot() { system.out.println(""robot name: "" + name + "" type: "" + type + "" battery level: "" + batterylevel + "" is operational: "" + isoperational); } public void decreasebattery() { this.batterylevel -= 15; if (batterylevel <= 0) { this.batterylevel = 0; this.isoperational = false; } } } //tip to <b>run</b> code, press <shortcut actionid=""run""/> or // click the <icon src=""allicons.actions.execute""/> icon in the gutter. public class main { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); string s = ""a1b2""; char []ar = s.tochararray(); int index = 0; combinations(ar,index); } public static void combinations(char[] ar, int index) { if (index == ar.length) { // arrayin sonuna geldiğinde arrayi basması için base case oluşturdum. for (char c : ar) { system.out.print(c); } system.out.println(); return; } if (character.isletter(ar[index])) { // önce küçük harf olarak ayarla ve fonksiyonu bir sonraki karakter için çağır ar[index] = character.tolowercase(ar[index]); combinations(ar, index + 1); // sonra büyük harf olarak ayarla ve fonksiyonu tekrar çağır ar[index] = character.touppercase(ar[index]); combinations(ar, index + 1); } else { // eğer karakter harf değilse direkt bir sonraki karaktere geç combinations(ar, index + 1); } } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot>robots; public factory(string name, string location) { this.name = name; this.location = location; this.robots = new arraylist<>(); } public factory() { this.name =""factory1""; this.location = ""moon""; this.robots = new arraylist<>(); } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getlocation() { return location; } public void setlocation(string location) { this.location = location; } public arraylist<robot> getrobots() { return robots; } public void setrobots(arraylist<robot> robots) { this.robots = robots; } public void addrobot(robot robot) { robots.add(robot); } public void work() { for(robot robot : robots) { robot.decreasebattery(); } } public void chargeallrobots() { for(robot robot: robots) { robot.charge(); } } public void printfactory() { system.out.println(""factory name: "" + name + "" location: "" + location); system.out.println(""robots operating here:""); for(robot robot : robots) { robot.printrobot(); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 // withbattery arayüzü interface withbattery { int getbatterylife(); void recharge(); } abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public abstract void performtask(); @override public int getbatterylife() { return batterylife; } @override public void recharge() { batterylife = 100; } public abstract string getstatus(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(); robotfactory.displaytotalrobotproduction(); } } class securityrobot extends abstractrobot { private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } @override public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""]"" + "" scanning for threats... armed: "" + isarmed); batterylife -= 10; } else { system.out.println(modelname + "" not enough battery to scan threats...""); } } public void togglearmedmode() { isarmed = !isarmed; system.out.println(""securityrobot - "" + modelname + "" is now "" + (isarmed ? ""armed"" : ""unarmed"")); } @override public string getstatus() { return ""securityrobot - model: "" + modelname + "", battery: "" + batterylife + "", armed: "" + isarmed; } } class cleaningrobot extends abstractrobot { private int cleaningpower; public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } @override public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""]"" + "" cleaning in progress... cleaning power: "" + cleaningpower); batterylife -= 10; } else { system.out.println(modelname + "" not enough battery to clean...""); recharge(); // batarya çalışamayacak durumda olduğu için recharge ettim ve final productta 100(bataryanın default değeri) olarak çıktı verdi. } } public void boostcleaningpower(int amount) { cleaningpower += amount; system.out.println(""cleaningrobot - "" + modelname + "" now has cleaning power: "" + cleaningpower); } @override public string getstatus() { return ""cleaningrobot - model: "" + modelname + "", battery: "" + batterylife + "", cleaning power: "" + cleaningpower; } } import java.util.*; class robotfactory { private list<abstractrobot> robots = new arraylist<>(); private static int totalrobotproduction = 0; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); totalrobotproduction++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); totalrobotproduction++; } public void performalltasks() { for (abstractrobot robot : robots) { robot.performtask(); } } public void displayrobots() { for (abstractrobot robot : robots) { system.out.println(robot.getstatus()); } } public void upgradecleaningrobots(int amount) { for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot) { ((cleaningrobot) robot).boostcleaningpower(amount); } } } public void togglesecurityrobotsmode() { for (abstractrobot robot : robots) { if (robot instanceof securityrobot) { ((securityrobot) robot).togglearmedmode(); } } } public static void displaytotalrobotproduction() { system.out.println(""tüm fabrikalar tarafından toplam "" + totalrobotproduction + "" robot uretildi""); } } 3",34508,4456,631,199,39,43
2112376,6,"2112376 müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 package lab2; import java.util.list; public class muzikcalar { private calmastratejisi strateji; public void setstrateji(calmastratejisi strateji) { this.strateji = strateji; } public void muzikcal (list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } package lab2; import java.util.*; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } // bu kismi cikti ornegini saglayacak sekilde doldurun } } } package lab2; public class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { super(isim , sanatci); } public void oynat() { system.out.println(""[klasi̇k] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } package lab2; public class metalsarki extends sarki { private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(isim , sanatci); this.metalozellik = metalozellik; } public void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } void gostermetalozellikleri() { system.out.println(sanatci + "" - "" + isim + ""[ozellik: "" + metalozellik + ""]""); } } package lab2; public class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { super(isim , sanatci); } public void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } package lab2; import java.util.collections; import java.util.list; public class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { collections.shuffle(sarkilistesi); for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } package lab2; import java.util.list; public class siralicalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } package lab2; abstract class sarki { string isim; string sanatci; public sarki (string isim , string sanatci) { this.isim = isim; this.sanatci = sanatci; } abstract void oynat (); } package lab2; import java.util.list; public class rockcuozelcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { if(sarki instanceof rocksarki) { system.out.println(""[bilgi] ses duzeyi: yuksek""); sarki.oynat(); } else { system.out.println(""[bilgi] ses duzeyi: normal""); sarki.oynat(); } } } } package lab2; import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. - java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? exception verebileceğini belirtir, kısıt olarak da ya kendi içerisinde ya da overrideda try catch ile handle edilmesi gerekir finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? try catch durumuna bakmaksızın her durumda çalışmasını sağlar java'da kendi exceptionunuzu nasıl tanımlarsınız? - java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? başka bir yerde handle edilip edilmediğini görmek için static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? - static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? - robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 ",16613,2022,219,103,11,19
8862077,5,"8862077 müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { private calmastratejisi strateji; void setstrateji(calmastratejisi strateji) { this.strateji=strateji; } void muzikcal(list<sarki> sarkilistesi){ strateji.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if(sarki instanceof metalsarki) ((metalsarki) sarki).gostermetalozellikleri(); } } } public class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci) { super(); this.sanatci=sanatci; this.isim=isim; } void oynat() { system.out.println(""[klasi̇k] ""+sanatci+"" - ""+isim+ "" (hafif ve sakin)""); } } public class metalsarki extends sarki{ string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(); this.metalozellik = metalozellik; this.sanatci=sanatci; this.isim=isim; } void oynat() { system.out.println(""[metal] ""+sanatci+"" - ""+isim+ "" (""+metalozellik+"")""); } void gostermetalozellikleri() { system.out.println(metalozellik); } } public class rocksarki extends sarki{ public rocksarki(string isim, string sanatci) { super(); this.sanatci=sanatci; this.isim=isim; } void oynat() { system.out.println(""[rock] ""+sanatci+"" - ""+isim+ "" (huzurlu ve nostaljik)""); } } import java.util.collections; import java.util.list; public class karisikcalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi){ collections.shuffle(sarkilistesi); for(int i=0;i<sarkilistesi.size();i++) { sarkilistesi.get(i).oynat(); } } } import java.util.list; public class siralicalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi){ for(int i=0;i<sarkilistesi.size();i++) { sarkilistesi.get(i).oynat(); } } } public abstract class sarki { public string isim; public string sanatci; abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi){ boolean sesarttirildimi = false; for (int i = 0; i < sarkilistesi.size(); i++) { sarki sarki = sarkilistesi.get(i); if (sarki instanceof rocksarki && !sesarttirildimi) { system.out.println(""[bilgi] ses duzeyi: yüksek""); sesarttirildimi = true; } sarki.oynat(); if (!(sarki instanceof rocksarki) && sesarttirildimi) { system.out.println(""[bilgi] ses duzeyi: normal""); sesarttirildimi = false; } if (i == sarkilistesi.size() - 1 && sesarttirildimi) { system.out.println(""[bilgi] ses duzeyi: normal""); sesarttirildimi = false; }}}} import java.util.list; public interface calmastratejisi { void cal(list <sarki> sarkilistesi); } ""recursion"" kavramı nedir, kısaca açıklayınız. özyineleme, tekrar tekrar kendini çağırma recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case, body, recursive call jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. stack ve heaple int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. iteratif olarak, çünkü tek iterasyon öbürü çoklu iterasyon bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? stringin uzunluğunun 0 olması stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. recursive calların stackin alabileceğinden çok çağırılması, taşması. sebebi base caseye hiç girmemesi tail recursion nedir, kısaca açıklayınız. methodun kendisinin hiçbir sayıyla çarpılmadan returnlenmesi değişkenleri değişerek bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot { private string name; private string type; private int batterylevel; private boolean isoperational=true; public robot() { super(); name = ""wall-e""; type= ""trash""; batterylevel = 100; isoperational = true; } public robot(string name, string type, int batterylevel) { super(); this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = isoperational; } public string printrobot() { return ""robot [name="" + name + "", type="" + type + "", batterylevel="" + batterylevel + ""%, isoperational="" + isoperational + ""]""; } public void charge() { batterylevel=100; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public boolean isoperational() { return isoperational; } public void setoperational(boolean isoperational) { this.isoperational = isoperational; } } public class main { public static void main(string[] args) { // todo auto-generated method stub factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } import java.util.iterator; public class soru1 { public static void main() { string string = ""a1b2""; combination(string,0); } public static void combination(string string, int helper) { if (helper!=string.length()) { for(int i=0;i<helper;i++) { if(string.charat(i).islower) string.charat(i).tolowercase(); else if(string.charat(i).isupper) string.charat(i).touppercase(); } combination(string,helper+1); } system.out.println(string); } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name, string location) { super(); this.name = name; this.location = location; this.robots=new arraylist<robot>(); } public factory() { name = ""factory1""; location = ""moon""; this.robots=new arraylist<robot>(); } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getlocation() { return location; } public void setlocation(string location) { this.location = location; } public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for (int i=0;i<robots.size();i++) { robots.get(i).setbatterylevel(100); } } public void printfactory() {//size sordum signature değiştirip sout olarak yazmama izin verdiniz. system.out.println(""factory [name="" + name + "", location="" + location + ""]""); system.out.println(""robots operating here:""); for (int i=0;i<robots.size();i++) { system.out.println(robots.get(i).printrobot()); } } public void work() { for (int i=0;i<robots.size();i++) { robots.get(i).setbatterylevel(robots.get(i).getbatterylevel()-15); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; int ilkbattery; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; ilkbattery=batterylife; } public string getmodelname() { return modelname; } public int getbatterylife() { return batterylife; } public void recharge() { batterylife = ilkbattery; } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); anotherfactory.toplamrobot();// burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } public class securityrobot extends abstractrobot{ private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed=isarmed; } public void performtask() { if(batterylife>=10) { system.out.println(""[""+modelname+""] scanning for threats... armed: ""+isarmed); batterylife=batterylife-10; } else { system.out.println(""[""+modelname+""] not enough battery to scan threats...""); } } public void togglearmedmode() { isarmed=!isarmed; if(isarmed) system.out.println(""securityrobot - ""+modelname+"" is now armed""); else { system.out.println(""securityrobot - ""+modelname+"" is now unarmed""); } } public boolean isarmed() { return isarmed; } public void setarmed(boolean isarmed) { this.isarmed = isarmed; } } public class cleaningrobot extends abstractrobot { private int cleaningpower; public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } public void performtask() { if (batterylife >= 10) { system.out.println(""[""+modelname+""] cleaning in progress... cleaning power: ""+cleaningpower); batterylife = batterylife-10; } else { system.out.println(""[""+modelname+""] not enough battery to clean...""); } } public void boostcleaningpower(int miktar) { cleaningpower = cleaningpower+miktar; system.out.println(""cleaningrobot - ""+modelname+"" now has cleaning power: ""+cleaningpower); } public int getcleaningpower() { return cleaningpower; } public void setcleaningpower(int cleaningpower) { this.cleaningpower = cleaningpower; } } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots=new arraylist<abstractrobot>(); static int robotsayi = 0; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); robotsayi++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); robotsayi++; } public void performalltasks() { for (int i=0; i<robots.size();i++) { robots.get(i).performtask(); } } public void displayrobots() { for (int i=0; i<robots.size();i++) { if (robots.get(i) instanceof cleaningrobot) { cleaningrobot temp = (cleaningrobot) robots.get(i); system.out.println(""cleaningrobot - model: ""+robots.get(i).modelname+"" battery: ""+robots.get(i).batterylife+"" cleaning power: ""+temp.getcleaningpower()); } else { securityrobot temp= (securityrobot) robots.get(i); system.out.println(""securityrobot - model: ""+robots.get(i).modelname+"" battery: ""+robots.get(i).batterylife+"" armed: ""+temp.isarmed()); } } } public void upgradecleaningrobots(int miktar) { for (int i=0; i<robots.size();i++) { if (robots.get(i) instanceof cleaningrobot) { ((cleaningrobot) robots.get(i)).boostcleaningpower(miktar); } } } public void togglesecurityrobotsmode() { for (int i=0; i<robots.size();i++) { if (robots.get(i) instanceof securityrobot) { ((securityrobot) robots.get(i)).togglearmedmode(); } } } public static void toplamrobot() { system.out.println(""tum fabrikalar tarafindan toplam ""+robotsayi+"" robot uretildi""); } } 5",26119,3026,441,163,20,26
8700334,6,"8700334 müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.*; abstract class sarki { public string isim; public string sanatci; public sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } public abstract void oynat(); } class metalsarki extends sarki { private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(isim, sanatci); this.metalozellik = metalozellik; } @override public void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } public void gostermetalozellikleri() { system.out.println(sanatci + "" - "" + isim + "" [ozellik: "" + metalozellik + ""]""); } } class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { super(isim, sanatci); } @override public void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { super(isim, sanatci); } @override public void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } interface calmastratejisi { void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { list<sarki> karisikliste = new arraylist<>(sarkilistesi); collections.shuffle(karisikliste); for (sarki sarki : karisikliste) { sarki.oynat(); } } } class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean sesyukseldi = false; for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki && !sesyukseldi) { system.out.println(""[bilgi] ses duzeyi: yuksek""); sesyukseldi = true; } if (!(sarki instanceof rocksarki) && sesyukseldi) { system.out.println(""[bilgi] ses duzeyi: normal""); sesyukseldi = false; } sarki.oynat(); } } } class muzikcalar { private calmastratejisi strateji; public void setstrateji(calmastratejisi s) { this.strateji = s; } public void muzikcal(list<sarki> sarkilistesi) { if (strateji != null) { strateji.cal(sarkilistesi); } else { system.out.println(""calma stratejisi secilmedi!""); } } } public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println("" ""); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println("" ""); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println("" ""); system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } } } } bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true public class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public void setname(string name) { this.name = name; } public void settype(string type) { this.type = type ; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; } public void setisoperational(boolean isoperational) { this.isoperational = isoperational; } public string getname() { return name; } public string gettype() { return type; } public int getbatterylevel() { return batterylevel; } public boolean getisoperational() { return isoperational; } public void charge() { batterylevel = 100; } public robot(string name , string type , int batterylevel , boolean isoperational) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = isoperational; } public robot(string name , string type , int batterylevel) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = true; } public robot () { name = ""wall-e""; type = ""trash""; batterylevel = 100; isoperational = true; } public void printrobot() { system.out.print(""robot name: ""); system.out.print(name); system.out.print(""robot type: ""); system.out.print(type); system.out.print("" batterylevel: ""); system.out.print(batterylevel); system.out.print("" is operational: ""); system.out.println(isoperational); } } public class main { public static void main (string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory(string name, string location) { this.name = name; this.location = location; this.robots = new arraylist<>();} public factory() { this.name = ""factory1""; this.location = ""moon""; this.robots = new arraylist<>();} public string getname(){ return name;} public void setname(string name){ this.name = name;} public string getlocation(){ return location;} public void setlocation(string location){ this.location = location;} public arraylist<robot> getrobots(){ return robots;} public void setrobots(arraylist<robot> robots){ this.robots = robots;} public void addrobot(robot robot){ robots.add(robot);} public void chargeallrobots(){ for (robot robot : robots){ robot.setbatterylevel(100);}} public void work(){ for (robot robot : robots){ robot.setbatterylevel(robot.getbatterylevel() - 15);}} public void printfactory(){ system.out.println(""factory name: "" + name); system.out.println(""location: "" + location); system.out.println(""robots operating here:""); for (robot robot : robots){ robot.printrobot();}}} robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 public interface withbattery { int getbatterylife(); void recharge(); } public abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public int getbatterylife() { return batterylife; } public void recharge() { batterylife = 100; system.out.println(modelname + "" is fully recharged.""); } public abstract void performtask(); } public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.kacroboturetildi(); } } public class securityrobot extends abstractrobot { protected boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } public void performtask() { if (batterylife >= 10) { system.out.println(modelname + "" scanning for threats... armed: "" + isarmed); batterylife = batterylife - 10; } if (batterylife < 10) { system.out.println(modelname + "" not enough battery to scan threats...""); } } public void togglearmedmode() { isarmed = !isarmed; system.out.println(modelname + "" is now "" + (isarmed ? ""armed"" : ""unarmed"")); } } public class cleaningrobot extends abstractrobot { protected int cleaningpower; public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } public void performtask() { if (batterylife >= 10) { system.out.println(modelname + "" cleaning in progress... cleaning power: "" + cleaningpower); batterylife = batterylife - 10; } if (batterylife < 10) { system.out.println(modelname + "" not enough battery to clean...""); } } public void boostcleaningpower() { cleaningpower = cleaningpower + 10; system.out.println(modelname + "" now has cleaning power: "" + cleaningpower); } } import java.util.arraylist; public class robotfactory { private static int totalrobotsproduced = 0; private arraylist<abstractrobot> robots = new arraylist<>(); public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); totalrobotsproduced++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); totalrobotsproduced++; } public void performalltasks() { for (abstractrobot robot : robots) { robot.performtask(); } } public void displayrobots() { for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot) { cleaningrobot crobot = (cleaningrobot) robot; system.out.println(""cleaningrobot - model: "" + crobot.getmodelname() + "", battery: "" + crobot.getbatterylife() + "", cleaning power: "" + crobot.cleaningpower); } else if (robot instanceof securityrobot) { securityrobot srobot = (securityrobot) robot; system.out.println(""securityrobot - model: "" + srobot.getmodelname() + "", battery: "" + srobot.getbatterylife() + "", armed: "" + srobot.isarmed); } } } public void upgradecleaningrobots(int amount) { for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot) { ((cleaningrobot) robot).boostcleaningpower(); } } } public void togglesecurityrobotsmode() { for (abstractrobot robot : robots) { if (robot instanceof securityrobot) { ((securityrobot) robot).togglearmedmode(); } } } public static void kacroboturetildi() { system.out.println(""tum fabrikalar tarafindan toplam "" + totalrobotsproduced + "" robot uretildi""); } } 6",24570,2966,401,159,19,22
1762204,0,"1762204 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class question2 { public static void main(string[] args) { int arr[] = {5, 4, 1, 2}; cocktailsort(arr); for (int i = 0; i < arr.length; i++) { system.out.print(arr[i] + "" ""); } } public static void cocktailsort(int[] arr) { sort(false, arr); } public static void sort(boolean reverse, int[] arr) { boolean sorted = true; for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { sorted = false; break; } } if (sorted) return; if (reverse) { for (int i = arr.length - 1; i > 0; i--) { if (arr[i] < arr[i - 1]) { int temp = arr[i]; arr[i] = arr[i - 1]; arr[i - 1] = temp; } } } else { for (int i = 0; i < arr.length - 1; i++) { if (arr[i] > arr[i + 1]) { int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } } sort(!reverse, arr); } } public class question1 { public static void main(string[] args) { int count = collatz(5); system.out.println(count); } public static int collatz(int i) { return calculate(0, i); } public static int calculate(int count, int number) { int newnumber = 0; if (number == 1) return count; if (number % 2 == 0) newnumber = number / 2; else if (number % 2 != 0) newnumber = number * 3 + 1; return calculate(count + 1, newnumber); } } public class question3 { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } class sayac { public string text = """"; public sayac(string text) { this.text = text; } public int say() { return count(0, text); } public int count(int number, string text) { if (text.length() == 0) { return number; } if (text.charat(0) == '1') { number++; } return count(number, text.substring(1)); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.list; public class muzikcalar { private calmastratejisi strateji; public void setstrateji(calmastratejisi s) { this.strateji = s; } public void muzikcal(list<sarki> sarkilistesi) { strateji.cal(sarkilistesi); } } import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { metalsarki metalsarki = (metalsarki)sarki; metalsarki.gostermetalozellikleri(); } } } } public class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } @override void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } public class metalsarki extends sarki { private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { this.isim = isim; this.sanatci = sanatci; this.metalozellik = metalozellik; } public void gostermetalozellikleri() { system.out.println(sanatci + "" - "" + isim + "" [ozellik: "" + metalozellik + ""]""); } @override void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } } public class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } @override void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } import java.util.arraylist; import java.util.list; public class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { list<sarki> sarkilistesicopy = new arraylist<>(sarkilistesi); while (!sarkilistesicopy.isempty()) { int randomnumber = (int) (math.random() * sarkilistesicopy.size()); sarkilistesicopy.get(randomnumber).oynat(); sarkilistesicopy.remove(randomnumber); } } } import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } public abstract class sarki { string isim; string sanatci; abstract void oynat(); } import java.util.list; public class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (int i = 0; i < sarkilistesi.size(); i++) { if (sarkilistesi.get(i) instanceof rocksarki) { if ((i == 0) || (i > 0 && !(sarkilistesi.get(i-1) instanceof rocksarki))) system.out.println(""[bilgi] ses duzeyi: yuksek""); } sarkilistesi.get(i).oynat(); if (sarkilistesi.get(i) instanceof rocksarki) { if ((i == sarkilistesi.size()-1) || (i < sarkilistesi.size()-1 && !(sarkilistesi.get(i+1) instanceof rocksarki))) system.out.println(""[bilgi] ses duzeyi: normal""); } } } } import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } ""recursion"" kavramı nedir, kısaca açıklayınız. bir metodun kendi kendini çağırması demektir. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. base case, decomposition, composition jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. her call edildiğinde stack üzerine yeni değişkenleri yerleştirir. call bittiğinde de değişkenleri siler. int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. i̇teratif olarak çünkü sürekli olarak bir metot çağırma ve stack'e değişken oluşturma işlemleri yapmamıza gerek kalmaz. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? base case, string uzunluğunun 1 olduğu durumdur. string uzunluğu bir olana kadar string uzunluğunu bir bir azaltarak recursive metodu çağırırız. recursive metot base case'e ulaştıktan sonra metotlardan bir bir çıkarken dışarıda tutulan string uzunluğunu tutan static değişken 1 artırılır. en son metot main'e return ettiği zaman uzunluğunu bulmuş oluruz. stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. base case'i olmayan bir recursion yazarsak infinite loop'a gideceğinden dolayı ve her recursive call'da yeni değişken oluşturacağı için stack dolar. stack, local variable'ların ram'de tutulduğu yerdir. tail recursion nedir, kısaca açıklayınız. bulmak istediğimiz sonucun recursion'da işimiz bittikten sonra geri dönerken hesaplanması yerine ileri giderken ve en sona ulaşınca hesaplanmasıdır. abstraction kavramını açıklayınız. sadece bizimle ilgili olan kısımla ilgilenip, bizimle ilgili olmayan kısımlara ilgilenmeye gerek kalmamasıdır. ""is a"" ilişkisi nedir, java'da nasıl kontrol edilir? i̇ki class arasında ""is a"" ilişkisi olması için ne gereklidir, nelere dikkat edersiniz? ""object"" instanceof ""class"" ile kontrol edilebilir. is a ilişkisi olması için objeyi kontrol ettiğimiz class ya kendi class'ı ya da super class'ı olması gerekmektedir. bir metoda subclasslardan erişilebilmesi ama dışarıdan (package dışından) erişilememesi için hangi access modifier kullanılmalı? protected modifier ""a extends b"" ve ""c extends a"" olmak üzere, dönüş tipi a olan bir metot override edileceği zaman olası dönüş tipleri nelerdir? a ve b olabilir. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? çünkü sub class oluştururken super class'ın da oluşması gerekir. bunun için super() diyerek super class'ın construct'ırını çalıştırmamız ve super class'taki değişkenleri de initialize etmemiz gerekir. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün mü? hayır değildir. metot overriding ve overloading kavramlarını açıklayınız. override ettiğimiz zaman sub class'ta, super class'ın metodunu override ederiz ve signature aynı olması gerekir. overload yaptığımızda ise ismi aynı fakat parametrelerinin farklı olması gerekir. class animal { public string type = ""animal""; public void makesound() { system.out.println(""generic animal sound.""); }} class dog extends animal { public dog() { super(); type = ""dog""; } public void makesound() { system.out.println(""bark!""); }} // test sınıfı, main metodu içinde animal a = new dog(); system.out.println(a.type); a.makesound(); output? dog bark class shape { public string name; final static int pi = 2; public shape() { name = ""generic""; printname(); } public void printname() { system.out.println(name); } } class circle extends shape { private double radius; public circle(double r) { radius = r; name = ""circle""; } public double getarea() { return pi * radius * radius; } } // test sınıfı, main metodu içinde circle c = new circle(2.0); c.printname(); system.out.println(c.getarea()); output? generic circle 8.0 java'da 'method binding' kavramı ne anlama gelir, çeşitleri nelerdir? static ve dynamic binding vardır ve metodun çağrıldığı yer ile metodun kendisinin eşleştirilmesine denir. hangi tür metotlarda static hangi durumlarda dynamic binding yapılır, static binding yapılan metotların modifierleri nelerdir? static, private ve final olan metotlar static binding yapılır, gerisinde dynamic binding olur. override edilemeyen metotlarda static binding olur. dinamik bağlamada jvm'nin görevi nedir? çağrılan metodun hangi objedeki metot olduğunu belirlemektir. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? dynamic binding runtime hatası olduğu için, compile time sırasında yanlış yazılan kodlardaki hataları göremezdik ve kod çalıştıktan sonra sorunlu yere gelirse görebilirdik sadece hatayı. java'da down casting explicit şekilde yapılır, bunun nedeni nedir; implicit şekilde yaparsak ne olur? bunun nedeni, her üst class objesi her alt class objesi e cast edilememesindendir. sadece emin olduğumuz objeleri cast edebiliriz. alt class objesi olmayan objeyi cast etmeye çalışırsak hata alırız. java'da method overriding yapılırken access modifierleri ile ilgili bir kısıt var mıdır, mesela protected bir metot public bir şekilde override edilebilir mi? bunun polimorfizm ile ilişkisini açıklayınız. eğer override edeceksek sadece daha az kısıtı olan modifier ile override edilebilir. ve de return type olarak sadece override edilen metodun return ettiği tipin ya kendisini ya da subclass'ını koyabiliriz. class animal { void makesound() { system.out.println(""animal sound""); } } class dog extends animal { void makesound() { system.out.println(""bark""); } } class cat extends animal { void makesound(){ system.out.println(""meov""); } } public class testsound { public static void main(string[] args) { animal[] animals = {new dog(), new cat()}; for (animal animal : animals) animal.makesound(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? bark meov burada dynamic binding vardır. class parent { void display() { system.out.println(""parent display""); } } class child extends parent { void display() { system.out.println(""child display""); } void special() { system.out.println(""child special""); } } public class demo { public static void main(string[] args) { parent p = new child(); p.display(); p.special(); } } kodda bir yanlışlık görüyor musunuz, varsa nerede? (eğer varsa yanlış satır silindikten sonra) output? burada static binding mi dinamik binding mi gözlemlemektesiniz? p.special() çağrılamaz çünkü parent objesinin special isimli metodu yok. bu satır silinmelidir. dynamic binding vardır. çıktı: child display java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class'ta oluşturulan abstract metotların içeriği olmaz fakat concrete'te olur. abstract class'larda constructor olabilir fakat interface'lerde olamaz. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? abstract metot implemente edilemez, sadece metodun içi olmadan yazılabilir. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. nasıl yapılacağını şu an bilmediğimiz fakat daha sonra yazılımcının yapmasını zorlamak istediğimiz metotlar için kullanabiliriz. yazılımcının yeni class'lar oluştururken kesinlikle oluşturmasını isteğimiz metotlar için kullanabiliriz. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? interface içerisine metotların içi yazılamaz ve bir class birden fazla interface'i implements ile kullanabilirken abstract class'larda concrete metot da yazmak mümkündür ve bir class sadece bir abstract class extend edebilir. ikisi de tıp olarak kullanılamaz. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface içerisinde değişkenler ve metotlar bulunmaz, sadece class'ın ne olduğunu belirtmek için kullanılırken functional interface içerisine metot da konulabilir. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? evet birden fazla interface implement edebilir fakat bir interface başka interface'i implement edemez. abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? new dog(""buddy""); yazılmalıydı output: animal: buddy woof interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? compile edemez çünkü interface içerisine concrete metot yazılamaz. metotların içi interface'den silinip duck class'ına yazılırsa ve içerisine ""swimming"" yazılırsa output: swimming java'da inner class nedir, avantajları nelerdir? dosyayı daha düzenli yapmamızı sağlar. statik ve statik olmayan (member) inner class arasındaki temel fark nedir? eğer inner class static ise outer class'ın static değişkenlerine erişebilir ve outer class objesi olmadan oluşturulabilir. anonymous class nedir, nasıl tanımlanır, nelerden (hangi kod yapılarından) anonim sınıf yapılabilir? new sınıf() {void mymethod(){...} }; diyerek anonymous class oluşturabiliriz. interface, abstract ve normal class'lar üzerinden oluşturulabilir. inner classlar tanımlandıkları classın private değişkenlerine erişebilir mi; peki değiştirebilir mi? evet/hayır ise bu neyi sağlar? evet private değişkenlere erişip değiştirebilir. bu sayede outer class içerisindeki bir constructor'ı inner class içinden çağırabiliriz. statik olmayan inner classlarda 'static' keywordü ile bir şey tanımlanabilir mi? neden? hayır tanımlanamaz. anonymus classların constructorları olabilir mi? inner classlardan farkı nedir? hayır olamaz. inner class'larda ise constructor olabilir. hangi tür inner classlar outer classları dışında instantiate (nesne yaratılabilir) edilebilirler? inner class static ise outer class olmadan oluşturabiliriz. çünkü her şey static final olarak tanımlanır. class outer { private int value = 10; class inner { void display() { system.out.println(""value: "" + value); } } public static void main(string[] args) { outer.inner inner = outer.new inner(); inner.display(); } } kodda hata gözlemliyor musunuz? eğer gözlemliyorsanız hata nedir, nasıl düzeltilir? (varsa hatayı düzelttikten sonra) output? inner class'ı oluşturup ve value değerine ulaşabilmemiz için once outer class için obje oluşturup onun üzerinden inner class oluşturmalıydık. onu yaptıktan sonra cevap: value: 10 class outer { private static int count = 5; static class staticinner { void showcount() { system.out.println(""count: "" + count); } } public static void main(string[] args) { outer outer = new outer(); outer.staticinner inner = outer.new staticinner(); inner.showcount(); } } kod bu halde compile edilir mi? kodda bir yanlışlık var mıdır, varsa nedir? (varsa hatayı düzelttikten sonra) output? kod bu şekilde çalışır. output: count: 5 yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. compile time, runtime hataları. compile time hatası syntax error olur. runtime ise divide by zero hatası olur. exception handlingin amacı nedir? hata olduğu zaman programın çökmesi yerine kendi istediğimiz bir şeyi yapmak. örnek olarak gracefully exit yapmamıza da yarar. exception handlingde finally bloğunun amacı nedir? hata olsa da olmasa da en son çalışacak bir kod bloğunu buraya yazarız. en son dosya kapatma işlemi gibi kodları buraya yazarız. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? checked exception olursa java compile ederken hata verir ve düzeltilmesini ister. unchecked'de ise sadece hatalı kod çalıştığı zaman hata verir. java'da kendi exceptionunuzu nasıl tanımlarsınız? exception class'ını extend eden başka bir class oluşturarak istediğimiz exception'ı oluşturabiliriz. java'da error ve exception arasındaki fark nedir, açıklayınız error daha ciddi hatalar için kullanılırken exception daha az ciddi hatalarda olur. error'lar handle edilemezken exception'lar edilebilir. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? stack'ten çıkıp bir üstteki metodun da hatayı handle etmesi için kullanılabilir. 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? üst sınıfın fırlattığı exception'dan daha geniş bir exception firlatamaz. static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? kod derlenir. çıktısı: array exception caught static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 bil21 1 quiz 1 section 1 quizleri uzak sistemine yükleyeceksiniz. q1 : bir program yazın ki, verilen n değeri için n çift parantezden oluşan tüm geçerli parantez dizilimlerini üretsin ve ekrana bassın . kurallar: ● her açma parantezi '(' kapama parantezi ')' ile kapanmalıdır .. ● herhangi bir noktada, kapama parantez ‘ ) ’ sayısı açma parantez ‘ ( ‘sayısından fazla olamaz. ● n çift parantez için tüm olası geçerli dizilimleri bulun. örnek: n = 3: ((())), (()()), (())(), ()(()) ,()()() n = 2: (()) ()() imzası: public void parantezbas(int n) q2 : bu soruda penguin ve habitat adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. penguin: değişkenler: private string name private string species private int age private double weight metotlar: private değişkenler için get ve set metotları. public void hunt(): penguenin ağırlığını 1 arttır. constructorlar: bir tane parametresiz ve parametreli constructor . parametresiz olan name= “willy”, species = “emperor”, age= 1 ve weight = 5.0 yapmalıdır . public void printpenguin(): pengueni ekrana basmalıdır . örnek: penguin name: willy species: emperor age: 1 years weight: 5.0 kg habitat: değişkenler: private string location private double temperature private arraylist<penguin> penguins metotlar: public habitat(string location, double temperature) private değişkenler için get ve set metotları. public void addpenguin(penguin penguin) public void printhabitat(): ekrana basar . örnek main(): penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); // default olarak ""willy"" ismiyle gelir habitat habitat = new habitat(“antarctica ”,-15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); çıktı: habitat location: antarctica average temperature: -15.0°c penguins living here: penguin name: pingu species: emperor age: 5 years weight: 12.5 kg penguin name: skipper species: adelie age: 3 years weight: 9.8 kg penguin name: willy species: emperor age: 1 years weight: 5.0 kg import java.util.arraylist; public class question2 { public static void main(string[] args) { penguin p1 = new penguin(""pingu"", ""emperor"", 5, 12.5); penguin p2 = new penguin(""skipper"", ""adelie"", 3, 9.8); penguin p3 = new penguin(); habitat habitat = new habitat(""antarctica"", -15.0); habitat.addpenguin(p1); habitat.addpenguin(p2); habitat.addpenguin(p3); habitat.printhabitat(); } } class penguin { private string name; private string species; private int age; private double weight; public penguin() { name = ""willy""; species = ""emperor""; age = 1; weight = 5.0; } public penguin(string name, string species, int age, double weight) { this.name = name; this.species = species; this.age = age; this.weight = weight; } public void hunt() { weight += 1; } public void printpenguin() { system.out.print(""penguin name: "" + name); system.out.print("" species: "" + species); system.out.print("" age: "" + age + "" years""); system.out.print("" weight: "" + weight + "" kg\n""); } public string getname() { return name; } public string getspecies() { return species; } public int getage() { return age; } public double getweight() { return weight; } public void setname(string name) { this.name = name; } public void setspecies(string species) { this.species = species; } public void setage(int age) { this.age = age; } public void setweight(double weight) { this.weight = weight; } } class habitat { private string location; private double temperature; private arraylist<penguin> penguins; public habitat(string location, double temperature) { this.location = location; this.temperature = temperature; penguins = new arraylist<penguin>(); } public void addpenguin(penguin penguin) { penguins.add(penguin); } public void printhabitat() { system.out.println(""habitat location: "" + location); system.out.println(""average temperature: "" + temperature + ""°c""); system.out.println(""penguins living here:""); for (penguin penguin : penguins) { penguin.printpenguin(); } } public string getlocation() { return location; } public double gettemperature() { return temperature; } public arraylist<penguin> getpenguins() { return penguins; } public void setlocation(string location) { this.location = location; } public void settemperature(double temperature) { this.temperature = temperature; } public void setpenguins(arraylist<penguin> penguins) { this.penguins = penguins; } } public class question1 { public static void main(string[] args) { int n = 3; question1 q1 = new question1(); q1.parantezbas(n); } public void parantezbas(int n) { accumulateparantez("""", n*2, 0); } public void accumulateparantez(string accumulated, int n, int openparantezcount) { if (n == 0) { system.out.println(accumulated); } else { if (openparantezcount > 0) { accumulateparantez(accumulated + "")"", n - 1, openparantezcount - 1); } if (openparantezcount < n) { accumulateparantez(accumulated + ""("", n - 1, openparantezcount + 1); } } } } kahve sipariş sistemi bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir kahve sipariş sistemi geliştire- ceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: eklenti arayüzü (coffeeaddon). kahveye eklenen tüm bileşenleri tanımlar. soyut kahve sınıfı (basecoffee). ortak kahve özelliklerini içerir. özel kahve sınıfları (espresso, latte, americano). farklı kahve türlerini temsil eder. eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot). kahveye eklenebilecek bileşenleri içerir. kahve makinesi sınıfı (coffeemachine). kahve yapımı ve özelliklerin eklenmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 coffeeaddon arayüzü metotlar: - double getcost() eklentinin kahveye eklediği fiyatı döner. - string getname() eklentinin adını döner. 3.2 eklenti sınıfları (milk, chocolate, vanillasyrup, doubleshot) her bir eklenti coffeeaddon arayüzünü uygular. eklenti sınıflarının arayüz fonksiyonlarında döneceği değer- ler aşağıdaki tabloda verilmiştir. table 1: eklentiler ve fiyatları fiyat (tl) 5 7 6 10 eklenti milk chocolate vanillasyrup doubleshot 3.3 basecoffee sınıfı (soyut sınıf ) değişkenler: - addons (protected arraylist<coffeeaddon>) kahveye eklenen eklentileri saklar. metotlar: - public void addaddon(coffeeaddon addon) kahveye eklenti ekler. - public abstract double calculateprice() soyut metod. kahvenin toplam fiyatını gösterir (taban fiyat ve eklentiler). 1 table 2: kahve türleri ve fiyatları kahve türü baz fiyat (tl) espresso latte americano 40 50 45 3.4 espresso sınıfı - basecoffee sınıfını geliştirir (extend) değişkenler: - isheated (private bool) fincan ısıtılma durumunu belirtir. i̇lk değeri her zaman false olmalı. eğer isheated doğru ise calculateprice fonksiyonunda sipariş yazılırken kahve ismi ""espresso (sıcak fincan)"" olarak belirtilir. metotlar: - public void heatcup() isheated değişkenini true yapar. 3.5 latte sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.6 americano sınıfı - basecoffee sınıfını geliştirir (extend) basecoffee’nın metodları ve değişkenleri dışında bir şey gerçeklemez. 3.7 coffee machine sınıfı metotlar: - public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) kahveye eklenti ekler. kahveye eklenemeyen bir eklenti seçildiğinde kahveye eklentiyi eklemeden ekrana ""[uyari] kahveismi tipi kahveye eklentiadi eklenemez"" yazdırır (kahveismi ve eklentiadi yerine kahve sınıfının ve eklentinin ismi yazdırılmalı, ana program kısmında örnek mevcut). - public void makecoffee(basecoffee coffee) kahvenin özelliklerini ve toplam fiyatını ekrana yazdırır (gösterim formatı ana program bölümünde mevcut). - public void heatespressocup(basecoffee coffee) eğer kahve espresso sınıfındansa ekrana ""espresso kahve fincanı ısıtıldı"" yazdırır ve kahvenin heatcup fonksiyonunu çağırır. diğer kahve türleri için ""[uyari] yalnızca espresso kahve fincanları ısıtılabilir"" yazdırır. - ??? bu fonksiyon tüm farklı coffeemachine’ler tarafından üretilmiş kahve sayısını ekrana ""tum fabrikalar kahve makineleri toplam toplamkahveuretimi kahve uretildi"" yazdırır (toplamkahveuretimi yerine toplam üretilen kahve sayısı yazılmalıdır). bu fonksiyonu tamamlamak için coffeemachine sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yap- mayın. table 3: kahve türlerine eklenebilen özellikler kahve türü espresso latte americano eklenebilen özellikler doubleshot, chocolate milk, vanillasyrup, chocolate milk, vanillasyrup 2 4 ana program (main sınıfı) public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffemachine anothermachine = new coffemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.our.println(""\n""); ??? // burada coffeemachine sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği [uyari] espresso tipi kahveye milk eklenemez espresso kahve fincanı ısıtıldı sipariş: espresso (sıcak fincan) + double shot toplam fiyat: 50tl sipariş: latte + milk + vanilla syrup toplam fiyat: 61tl [uyari] yalnızca espresso kahve fincanları ısıtılabilir sipariş: americano toplam fiyat: 45tl tum kahve makineleri tarafindan toplam 3 kahve uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmış arşivin ismini isim_numara_sube1 şeklinde isimlendirin (örn., johnnash_181101014_sube1.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 3 public class latte extends basecoffee { public latte() { super(""latte""); } public double calculateprice() { double addonssum = 0; for (coffeeaddon coffeeaddon : addons) { addonssum += coffeeaddon.getcost(); } return addonssum += 50; } } public class main { public static void main(string[] args) { coffeemachine machine = new coffeemachine(); basecoffee espresso = new espresso(); machine.addaddontocoffee(espresso, new doubleshot()); machine.addaddontocoffee(espresso, new milk()); machine.heatespressocup(espresso); machine.makecoffee(espresso); basecoffee latte = new latte(); machine.addaddontocoffee(latte, new milk()); machine.addaddontocoffee(latte, new vanillasyrup()); machine.makecoffee(latte); // ??? fonksiyonunu test etmek icin baska bir kahve makinesinden kahve uretiyoruz. coffeemachine anothermachine = new coffeemachine(); basecoffee americano = new americano(); anothermachine.heatespressocup(americano); anothermachine.makecoffee(americano); system.out.println(""\n""); system.out.println(""tum kahve makineleri tarafindan toplam "" + coffeemachine.gettotalnumberofcoffeesfromallmachines() + "" kahve uretildi""); } } public class espresso extends basecoffee { private boolean isheated; public espresso() { super(""espresso""); } public string getname() { if (isheated) return super.getname() + "" (sıcak fincan)""; else return super.getname(); } public double calculateprice() { double addonssum = 0; for (coffeeaddon coffeeaddon : addons) { addonssum += coffeeaddon.getcost(); } return addonssum += 40; } public void heatcup() { system.out.println(getname() + "" kahve fincanı ısıtıldı""); isheated = true; } } public class vanillasyrup implements coffeeaddon { public string getname() { return ""vanillasyrup""; } public double getcost() { return 6; } } public interface coffeeaddon { double getcost(); string getname(); } import java.util.arraylist; public abstract class basecoffee { private string name; protected arraylist<coffeeaddon> addons = new arraylist<coffeeaddon>(); public basecoffee(string name) { this.name = name; } public void addaddon(coffeeaddon addon) { addons.add(addon); } public abstract double calculateprice(); public void setname(string name) { this.name = name; } public string getname() { return name; } } public class americano extends basecoffee { public americano() { super(""americano""); } public double calculateprice() { double addonssum = 0; for (coffeeaddon coffeeaddon : addons) { addonssum += coffeeaddon.getcost(); } return addonssum += 45; } } import java.util.arraylist; public class coffeemachine { private static arraylist<coffeemachine> allcoffeemachines = new arraylist<coffeemachine>(); private int totalnumberofcoffees = 0; public coffeemachine() { allcoffeemachines.add(this); } public void addaddontocoffee(basecoffee coffee, coffeeaddon adddon) { if (coffee instanceof espresso && !(adddon instanceof doubleshot || adddon instanceof chocolate)) { system.out.println(""[uyari] espresso tipi kahveye "" + adddon.getname() + "" eklenemez""); return; } if (coffee instanceof latte && !(adddon instanceof milk || adddon instanceof vanillasyrup || adddon instanceof chocolate)) { system.out.println(""[uyari] latte tipi kahveye "" + adddon.getname() + "" eklenemez""); return; } if (coffee instanceof americano && !(adddon instanceof milk || adddon instanceof vanillasyrup)) { system.out.println(""[uyari] americano tipi kahveye "" + adddon.getname() + "" eklenemez""); return; } coffee.addaddon(adddon); } public void makecoffee(basecoffee coffee) { string addonsstring = """"; for (coffeeaddon coffeeaddon : coffee.addons) { addonsstring += "" + "" + coffeeaddon.getname(); } totalnumberofcoffees++; system.out.println(""sipariş: "" + coffee.getname() + addonsstring); system.out.println(""toplam fiyat: "" + (int)coffee.calculateprice()); } public void heatespressocup(basecoffee coffee) { if (coffee instanceof espresso) { espresso espresso = (espresso) coffee; espresso.heatcup(); } else { system.out.println(""[uyari] yalnızca espresso kahve fincanları ısıtılabilir""); } } public int totalnumberofcoffees() { return totalnumberofcoffees; } public static int gettotalnumberofcoffeesfromallmachines() { int totalnumberofcoffees = 0; for (coffeemachine coffeemachine : allcoffeemachines) { totalnumberofcoffees += coffeemachine.totalnumberofcoffees(); } return totalnumberofcoffees; } } public class milk implements coffeeaddon { public string getname() { return ""milk""; } public double getcost() { return 5; } } public class doubleshot implements coffeeaddon { public string getname() { return ""doubleshot""; } public double getcost() { return 10; } } public class chocolate implements coffeeaddon { public string getname() { return ""chocolate""; } public double getcost() { return 7; } } 0",41162,5437,788,253,95,24
5628146,2,"5628146 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. package lab1; public class lab1q2 { public static void cocktailsort(int[] arr) { cocktailsortrecursive(arr, 0, arr.length - 1); } private static void cocktailsortrecursive(int[] arr, int start, int end) { if (start >= end) { return; } boolean flag = false; for (int i = start; i < end; i++) { if (arr[i] > arr[i + 1]) { // bubble sort önden int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; flag = true; } } if (!flag) { // eğer değişim olmadıysa işlem yapılmayacak return; } end--; for (int i = end; i > start; i--) { // bubble sort arkadan if (arr[i] < arr[i - 1]) { int temp = arr[i]; arr[i] = arr[i - 1]; arr[i - 1] = temp; flag = true; } } start++; cocktailsortrecursive(arr, start, end); } public static void main(string[] args) { int[] arr = {5, 4, 1, 2}; cocktailsort(arr); for (int num : arr) { system.out.print(num + "" ""); } } } package lab1; public class lab1q3 { public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } package lab1; public class lab1q1 { public static int collatz(int n) { if (n == 1) { return 0; } else if (n % 2 == 0) { return 1 + collatz(n / 2); } else { return 1 + collatz(3 * n + 1); } } public static void main(string[] args) { int input = 5; system.out.println(collatz(input)); } } package lab1; public class sayac { private string str; public sayac(string str) { this.str = str; } public int say() { return countones(str, 0); } private int countones(string str, int index) { if (index == str.length()) { return 0; } int count = 0; if (str.charat(index) == '1') { count = 1; } return count + countones(str, index + 1); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 package lab3; import java.util.list; class muzikcalar { private calmastratejisi strateji; public void setstrateji(calmastratejisi s) { this.strateji = s; } public void muzikcal(list<sarki> sarkilistesi) { if (strateji != null) { strateji.cal(sarkilistesi); } } } package lab3; import java.util.arrays; import java.util.list; public class main { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""\nkarisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""\nrockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""\nmetal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } } } } package lab3; class klasiksarki extends sarki { public klasiksarki(string isim, string sanatci) { super(isim, sanatci); } @override public void oynat() { system.out.println(""[klasik] "" + sanatci + "" - "" + isim + "" (hafif ve sakin)""); } } package lab3; class metalsarki extends sarki { private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(isim, sanatci); this.metalozellik = metalozellik; } @override public void oynat() { system.out.println(""[metal] "" + sanatci + "" - "" + isim + "" ("" + metalozellik + "")""); } public void gostermetalozellikleri() { system.out.println(sanatci + "" - "" + isim + "" [ozellik: "" + metalozellik + ""]""); } } package lab3; class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { super(isim, sanatci); } @override public void oynat() { system.out.println(""[rock] "" + sanatci + "" - "" + isim + "" (huzurlu ve nostaljik)""); } } package lab3; import java.util.random; import java.util.arraylist; import java.util.list; class karisikcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { list<sarki> kopyaliste = new arraylist<>(sarkilistesi); random rand = new random(); for (int i = 0; i < kopyaliste.size(); i++) { //random sınıfıyla swap işlemi yapıyorum int randomindex = rand.nextint(kopyaliste.size()); sarki temp = kopyaliste.get(i); kopyaliste.set(i, kopyaliste.get(randomindex)); kopyaliste.set(randomindex, temp); } for (sarki sarki : kopyaliste) { sarki.oynat(); } } } package lab3; import java.util.list; class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } package lab3; abstract class sarki { protected string isim; protected string sanatci; public sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } public abstract void oynat(); } package lab3; import java.util.list; class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean sesyuksek = false; for (sarki sarki : sarkilistesi) { if (sarki instanceof rocksarki && !sesyuksek) { system.out.println(""[bilgi] ses duzeyi: yuksek""); sesyuksek = true; } sarki.oynat(); if (sesyuksek && !(sarki instanceof rocksarki)) { sesyuksek = false; system.out.println(""[bilgi] ses duzeyi: normal""); } } } } package lab3; import java.util.list; interface calmastratejisi { void cal(list<sarki> sarkilistesi); } abstraction kavramını açıklayınız. soyutlama, karmaşıok bir sistemi kolay ve anlaşılır hale getirir dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? evet mümkündür java covraiant return typesı destekler tersi mümkün değil çünkü subclass olmalı protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier(default) class ve package içerirken protected için bunun üstüne subclass eklenir yani no modifier daha yakın java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? üst sınıfta kullandığımız constructuru subclasslarda kullanabilmek için java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? mümkün değil sadece birini yapabilir java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? bir nesnenin belirli bir sınıfın veya arayüzün örneği olup olmadığını kontrol eder a,b'nin subclasıysa true döner metot overriding ve overloading kavramlarını açıklayınız. overloading : aynı isimdeki metotların farklı parametre listeleriyle tanımlanması overriding : subclasın üst sınıfta tanımlı bir metodu yeniden tanımlaması class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? 0 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? derleme ve çalışma zamanlarına göre yapılır java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? bu metotların derleme zamanında davranışlarının sabit ve kesin olması override edilemezler overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloading için static overriding dynamic çünkü override edilmiş metodu çağrılacaksa, o belirlenir overloarding içinderleme zamanı önemli dinamik bağlamada jvm'nin görevi nedir? objenin türünü belirlemek ve doğru metodu çağırmak java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? upcating implicit yapılabilir çünkü subclss üst sınıfın tüm özelliklerini metot ve değişken gibi alabilir down casting implicit yapılmaz üst sınıfın referansı subclassın özelliklerini taşımaz java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? işlemci ve bellek kullanımları artardı class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child dynamic class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product , dynamic java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract classda en az 1 metoda sahip olabilirken concrete classta tüm metotlar tanımlıdır abstract classların constructerı olabilir interfacelerin olamaz abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? hayır edilemez abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstraction ,partial implementation, polimorfizim abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstractlar hem abstract hem concrete metotlar içerebilir. interface yalnızca abstract metotlar içerir abstclar extends edilir interface impelements marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker : içinde hiçbir metot bulunmayan bir arayüz functional :tek bir abstract metodu olan interface bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? 1. evet implements ile edilir 2. bir interface başka bir interface’i implements edemez ama extends edebilir abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? animal a = new animal(""buddy""); animal classı abstract olduğu için doğrudan bir obje oluşturulamaz. onun yerine subclass olan dogdan oluştururuz interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? çalışmaz java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. checked(io),unchecked(null) java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? checked exception fırlatıyorsa, bu exception ya çağıran metot tarafından try-catch bloğunda ele alınmalı override edildiyse daha fazla expection eklenemez finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? exception olsa da olmasa da her durumda çalışır işlevi bellek temizleme,dosya kapatma vs. java'da kendi exceptionunuzu nasıl tanımlarsınız? exceptiondan türetilmiş bir sınıf yazarım java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? exception yakalanıp ek bilgi isteniyor olabilir veya mesaj verilebilir static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? trying m1 caught2 bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true package lab2; public class robot { private string name; private string type; private int batterylevel; private boolean isoperational; public robot() { //parametresiz this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public robot(string name, string type, int batterylevel) { //parametreli this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = batterylevel > 0; //bataryası varsa true } public string getname() { return name; } public void setname(string name) { this.name = name; } public string gettype() { return type; } public void settype(string type) { this.type = type; } public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { this.batterylevel = batterylevel; this.isoperational = batterylevel > 0; } public boolean isoperational() { return isoperational; } public void charge() { this.batterylevel = 100; this.isoperational = true; } public void printrobot() { system.out.println(""robot name: "" + name + "" robot type: "" + type + "" battery level: "" + batterylevel + ""%"" + "" is operational: "" + isoperational); } } package lab2; import java.util.*; public class lab2q1 { public static void main(string[] args) { string s = ""a1b2""; system.out.println(getallpermutations(s)); } public static void generatepermutations(string s, int index, list<string> result) { if (index == s.length()) { result.add(s); return; } char currentchar = s.charat(index); if (currentchar >= 'a' && currentchar <= 'z') { //harfse küçükse büyük büyükse küçük yapma // 32 yapma sebebim küçük a 97 büyük a 65 ascide generatepermutations(s.substring(0, index) + (char)(currentchar - 32) + s.substring(index + 1), index + 1, result); } else if (currentchar >= 'a' && currentchar <= 'z') { generatepermutations(s.substring(0, index) + (char)(currentchar + 32) + s.substring(index + 1), index + 1, result); } generatepermutations(s, index + 1, result); } public static list<string> getallpermutations(string s) { list<string> result = new arraylist<>(); generatepermutations(s, 0, result); return result; } } package lab2; public class lab2q2 { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } package lab2; import java.util.arraylist; public class factory { private string name; private string location; private arraylist<robot> robots; public factory() { this.name = ""factory1""; this.location = ""moon""; this.robots = new arraylist<>(); } public factory(string name, string location) { this.name = name; this.location = location; this.robots = new arraylist<>(); } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getlocation() { return location; } public void setlocation(string location) { this.location = location; } public void addrobot(robot robot) { robots.add(robot); } public void chargeallrobots() { for (robot robot : robots) { robot.charge(); } } public void work() { for (robot robot : robots) { if((robot.getbatterylevel() - 15) < 0) { //sarjın negatif olmaması için min 0 int newbatterylevel = 0; robot.setbatterylevel(newbatterylevel); } else { int newbatterylevel = robot.getbatterylevel() - 15; robot.setbatterylevel(newbatterylevel); } } } public void printfactory() { system.out.println(""factory name: "" + name + "" location: "" + location); system.out.println(""robots operating here: ""); for (robot robot : robots) { robot.printrobot(); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 package quiz2_1; public interface withbattery { int getbatterylife(); void recharge(); } package quiz2_1; abstract class abstractrobot implements withbattery { protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public int getbatterylife() { return batterylife; } public void recharge() { batterylife = 100; } public abstract void performtask(); } package quiz2_1; public class main {public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.displaytotalproduction(); } } package quiz2_1; class securityrobot extends abstractrobot { private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed = isarmed; } public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] scanning for threats... armed: "" + isarmed); batterylife -= 10; } else { system.out.println(""["" + modelname + ""] not enough battery to scan threats...""); } } public void togglearmedmode() { isarmed = !isarmed; system.out.println(""securityrobot - "" + modelname + "" is now "" + (isarmed ? ""armed"" : ""unarmed"")); } public boolean isarmed() { return isarmed; } } package quiz2_1; class cleaningrobot extends abstractrobot { private int cleaningpower; public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower = cleaningpower; } public void performtask() { if (batterylife >= 10) { system.out.println(""["" + modelname + ""] cleaning in progress... cleaning power: "" + cleaningpower); batterylife -= 10; } else { system.out.println(""["" + modelname + ""] not enough battery to clean...""); } } public void boostcleaningpower(int amount) { cleaningpower += amount; system.out.println(""cleaningrobot - "" + modelname + "" now has cleaning power: "" + cleaningpower); } public int getcleaningpower() { return cleaningpower; } } package quiz2_1; import java.util.arraylist; class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); private static int totalrobotproduction = 0; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); totalrobotproduction++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); totalrobotproduction++; } public void performalltasks() { for (abstractrobot robot : robots) { robot.performtask(); } } public void displayrobots() { for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot) { cleaningrobot cr = (cleaningrobot) robot; system.out.println(""cleaningrobot - model: "" + cr.getmodelname() + "", battery: "" + cr.getbatterylife() + "", cleaning power: "" + cr.getcleaningpower()); } else if (robot instanceof securityrobot) { securityrobot sr = (securityrobot) robot; system.out.println(""securityrobot - model: "" + sr.getmodelname() + "", battery: "" + sr.getbatterylife() + "", armed: "" + sr.isarmed()); } } } public void upgradecleaningrobots(int amount) { for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot) { ((cleaningrobot) robot).boostcleaningpower(amount); } } } public void togglesecurityrobotsmode() { for (abstractrobot robot : robots) { if (robot instanceof securityrobot) { ((securityrobot) robot).togglearmedmode(); } } } public static void displaytotalproduction() { system.out.println(""tum fabrikalar tarafindan toplam "" + totalrobotproduction + "" robot uretildi""); } } 2",37046,4833,714,223,45,28
6429016,1,"6429016 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. /*cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor. cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir. bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır. yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. */ public class cocktailshakersort { public static void cocktailsort(int[] arr) { cocktail(arr, 0, arr.length); } public static void cocktail(int[] arr, int start, int end) { if (start >= end) { //base elemanlar sirali return; } boolean swapped= false; for (int i=start;i<end-1;i++) {// soldan saga sıralama if (arr[i] > arr[i + 1]) { swap(arr, i, i+ 1); swapped = true; } } if (swapped=false) { //zaten swapli return; } swapped = false; for (int i = end - 2; i > start; i--) { // sagdan sola sıralama if (arr[i] < arr[i - 1]) { swap(arr, i, i - 1); swapped = true; } } cocktail(arr,start+1,end-1); } public static void swap(int[] arr, int i, int j) { //yanyana olanları yer degistirme int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } public static void main(string[] args) { int[] arr = {3, 4, 1,8}; cocktailsort(arr); system.out.println(arr[0]+"",""+arr[1]+"",""+arr[2]+"",""+ arr[3]); } } //collatz problemi. //bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır. //kurallar şu şekildedir: //eğer sayı çift ise 2’ye bölünür //eğer sayı tek ise 3 ile çarpılıp 1 eklenir. //örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. //bu işlemi yapan recursive metodu yazmanız gerekmektedir. bu metodun imzası public static int collatz(int i) olmalıdır. ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. public class collatz { public static int collatz(int i) { if (i == 1) { return 0; //base } else if (i % 2 == 0) { return 1 + collatz(i/2); // cift sayi } else { return 1 + collatz(3*i+1); // tek sayi } } public static void main(string[] args) { int sayi = 1; system.out.println(sayi + "" icin adim sayisi: "" +collatz(sayi)); int sayi2 = 11; system.out.println(sayi2 +"" icin adim sayisi: "" +collatz(sayi2)); int sayi3 = 8; system.out.println(sayi3 +"" icin adim sayisi: "" +collatz(sayi3)); } } public class sayac { string input; public sayac(string input) { this.input = input; } public int say() { //yardimci return birsay(input, 0); } public int birsay(string str, int index) { if (index == str.length()) {//base iterasyon return 0; } if (str.charat(index) == '1') { return 1 + birsay(str, index + 1); } return birsay(str, index + 1); } public static void main(string[] args) { sayac s1 = new sayac(""10001""); sayac s2 = new sayac(""11001100110""); system.out.println(""birinci sayinin icinde ""+ s1.say() + "" tane 1 var.""); system.out.println(""ikinci sayinin icinde ""+ s2.say() + "" tane 1 var.""); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 package lab2; import java.util.list; class muzikcalar { private calmastratejisi strateji; public void setstrateji(calmastratejisi strateji) { this.strateji = strateji; } public void muzikcal(list<sarki> sarkilistesi) { if (strateji == null) { system.out.println(""calma stratejisi secilmedi.""); return; } strateji.cal(sarkilistesi); } } package lab2; public class klasiksarki extends sarki{ public klasiksarki(string isim, string sanatci) { super(isim, sanatci); } @override void oynat() { system.out.println(""[klasik] "" + isim + "" by "" + sanatci + "" (hafif ve sakin)""); } } package lab2; public class metalsarki extends sarki{ private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik) { super(isim, sanatci); this.metalozellik = metalozellik; } @override void oynat() { system.out.println(""[metal] "" + isim + "" by "" + sanatci + "" ("" +metalozellik +"")""); } public void gostermetalozellikleri() { system.out.println(isim + "" - metal özelliği: "" + metalozellik); } public string metal(){ return metalozellik; } } package lab2; public class rocksarki extends sarki{ public rocksarki(string isim, string sanatci) { super(isim, sanatci); } @override public void oynat() { system.out.println(""[rock] "" + isim + "" by "" + sanatci + "" (huzurlu ve nostaljik)""); } } package lab2; import java.util.collections; import java.util.list; public class karisikcalma implements calmastratejisi{ @override public void cal(list<sarki> sarkilistesi) { list<sarki> karisikliste = (sarkilistesi); collections.shuffle(karisikliste); for (sarki sarki : karisikliste) { sarki.oynat(); } } } package lab2; import java.util.list; public class siralicalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } package lab2; import java.util.arrays; import java.util.list; public class test { public static void main(string[] args) { sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); muzikcalar muzikcalar = new muzikcalar(); system.out.println(""\nsirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""\nkarisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""\nrockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); system.out.println(""\nmetal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { //((metalsarki) sarki).gostermetalozellikleri(); system.out.println(sarki.sanatci+"" - ""+ sarki.isim +"" [ozellik: "" + ((metalsarki) sarki).metal() + ""]""); } } } } package lab2; import java.util.list; import java.util.collections; public abstract class sarki { string isim; string sanatci; public sarki(string isim, string sanatci) { this.isim = isim; this.sanatci = sanatci; } abstract void oynat(); @override public string tostring() { return isim + "" by "" + sanatci; } } package lab2; import java.util.list; class rockcuozelcalma implements calmastratejisi { @override public void cal(list<sarki> sarkilistesi) { boolean isvolumehigh = false; for (int i = 0; i < sarkilistesi.size(); i++) { sarki sarki = sarkilistesi.get(i); if (sarki instanceof rocksarki) { if (!isvolumehigh) { system.out.println(""[bilgi] ses duzeyi: yuksek""); isvolumehigh = true; } } else { if (isvolumehigh) { system.out.println(""[bilgi] ses duzeyi: normal""); isvolumehigh = false; } } sarki.oynat(); } } } package lab2; import java.util.list; public interface calmastratejisi { void cal(list<sarki> sarkilistesi); } ""recursion"" kavramı nedir, kısaca açıklayınız. bir fonksiyonun içinde belirli bir baz duruma kadar kendini tekrar çağırmasıdır. recursive bir metodun temel kısımları nelerdır, kısaca açıklayınız. recursive method kendini çağırma, işlev ve durdurucu temel koşuldan oluşur. jvm recursive call'ları nasıl handle ediyor, kısaca açıklayınız. çıkış durumu noktasına kadar içeri doğru yeniden çağırır. çıkış noktası yoksa stack overflow durumu yaşanır. int power(x, y) metodu recursive olarak mı daha verimlidir, iteratif olarak mı; kısaca açıklayınız. 2 üzeri 2 ye kadar iteratif olarak daha verimlidir. bundan sonra ise recursive olarak daha verimli olur. bir stringin uzunluğunu bulduracak recursive bir metodu nasıl yazarsınız, base casesi ne olurdu? scanner ile bir arrayin içine sürekli i+1 alacak şekilde recursive method ile alırım alırım. sonrasında arrayin length ine bakarım. stack nedir, neden overflow olur; overflow olma nedenlerinden bir tanesini açıklayınız. stack hafızada açılan sayfalardır. bu sayfaların dışına çıkacak kadar tail recursion nedir, kısaca açıklayınız. recursive metot içinde başka bir recursive metot olması. yani iç içe recursive kullanimidir. merhaba abstraction kavramını açıklayınız. soyutluk veriye nesneye erişilmesi için gereklilikleri azaltma işi dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? mümkündür çünkü horuly employee employeenin alt kumesidir. tersi mümkün değildir kümedeb çıkamayız. protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier daha yakındır. java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? çünkü atasının constructorunu taşımalı ve nesiller arası bir zincir olusturmalidir. bu bir kuraldır. java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır java'da tek ata olabilir. ancak bunu sağlamak için b extends c, a extends b yaparsak a ikisinin de override edilmeyen özelliklerini taşır. java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? a byi extend ediyor mu. b a'nın atası ya da a'nın kendisi mıdır. a objesi b classın in objesinin bir örneği mıdır? metot overriding ve overloading kavramlarını açıklayınız. metot overriding bir subclassın üst classın aynı adda metodunu ezmesidir. subclassın metodu calisir. method overloading farklı parametrelere sahip aynı isimli farklı metodlar taninlamaktır. aynı method ismi ile farklı parametrelere işlem yapmaya metodun daha esnek olmasına olanak tanır. class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? 1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? parent 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? static binding compile zamanında yapılır dynamic binding run zamanında yapılır. java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? override edilemezler. bu nedenle tek bir metot bulunur. onun cagrilacagi belirlidir. overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overriding yaparken dynamic binding gerçekleşir. overloading yaparken static binding gerçekleşir. dinamik bağlamada jvm'nin görevi nedir? hangi classtan çağrıldığını bulma sonrasında çağrıldığı nesnenin classına kadar parenttan childa doğru override edilip edilmediğini kontrol etme. buna göre son override edilen metodu uygulama. java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? çünkü upcasting de alt sınıflar üst sınıfların ebeveynin tüm özelliklerine sahiptir. extend eder. ama downcastingde bir ebeveyni birden fazla child extend edebileceği için ve ebeveyn childın tüm özelliklerine sahip olamayabilecrgi için yapılamaz. java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? final, static, private metotları çağırmak yerine obje classının içindeki metodu çağırabilirdi. class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child dinamik bağlama vardır. class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? book dinamik bağlama gozlemekteyiz java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class nesne oluşturmaz. soyut ve somut metodlar içerir ve kendini extend edenlerin bu metodlari bulundurması zorunludur. abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? evet edilebilir. ama yine abstract olacaktır. bir gövde görevi görmez. implementation olmaz abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. abstract classlar nesne oluşturmaz. abstract metodlar bulundurabilir.bu metotların gövdesi olmaz. ancak alt sınıflar bunları bulundurmak zorunda kalır. abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstractın constructor metodu vardır. interface in constructor metodu yoktur. abstractta çoklu kalıtım yoktur. interfacede çoklu kalıtım vardır. interface instance variable bulundurma. marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker interface method içermeyen interfacetir. functional interface bir abstract method içeren interfacetir. bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? bir interface başka bir interfaceyi extend edebilir. bu, bir interface'in diğer interface'in metodlarını miras almasını sağlar. bir class birden fazla interfaceyi implement edebilir. burada çoklu kalıtım devreye girer. abstract class shape { abstract void draw(); void display() { system.out.println(""displaying""); } } class circle extends shape { void draw() { system.out.println(""drawing circle""); } } shape c = new shape(); c.draw(); c.display(); yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? abstract class nesne oluşturmaz. new shape yerine new circle yazarak düzeltiriz. circle displaying interface a { default void show() { system.out.println(""a""); } } interface b { default void show() { system.out.println(""b""); } } class c implements a, b { public void show() { super.show(); } } new c().show(); kod bu halde compile edilebilir mi? yukarıdaki koddaki problem nedir? problemli satırın yeni hali ne olabilir? hata düzeltildikten sonra output? show metodu override ederken bir sorun oluşuyor. super kullanımı yanlış. yazılım geliştirirken genelde kaç çeşit hata ile karşılaşılır, her tür için birer örnek veriniz. logical örneğin bir sayının 0a bölünmesi. syntax hatası compiler içinde çözülebilir ;unutmak. runtime hatası çok uzun süren bitmeyen recursionlar. exceptionlar. exception handlingin amacı nedir? programın hatalar nedeniyle kapanmasını önlemek. hataları user görmeden önce yakalamak ve düzeltmek. hata kaynaklarını görmek. exception handlingde finally bloğunun amacı nedir? finally end durumundan sonra bile çalışmasını istediğimiz bloktur. java'da 'checked' ve 'unchecked' exceptionların farkı nedir? checked derleme sırasında kontrol edilir unchecked exception lar ise runtime exceptionlaridir. runtime sınıfından üretilir diğeri exception sınıfından. java'da kendi exceptionunuzu nasıl tanımlarsınız? exception classını kullanarak tanımlarız içine bir throw be if ekleriz. java'da error ve exception arasındaki fark nedir, açıklayınız error sistem seviyesinde ciddi hataları gösterir. exception yazılıma müdahale edilerek çözülebilecek hataları. exception lar daha basittir ikisi de trowable dır. java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? başka bir exceptiona çevirmek için olabilir. 'throws' declarationunun metot overriding yaparken kısıtları nelerdir? daha geniş kapsamlı bir exception atamaz. static void printindex(int[] arr, int index){ try{ system.out.println(arr[index]); } catch(exception e){ system.out.println(""exception caught""); } catch(arrayindexoutofboundsexception e){ system.out.println(""array exception caught""); } } //psvm printindex({1, 2, 3, 4, 5}, 5); kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? derlenmez çünkü daha genel bir exception daha önce yakalanmış ve sonradan daha alt bir exception firlatilmis. hatayı çözmek için hiyerarşisi düzeltmek gerekir. genel istisna daha sonra yakalnamlali. çıktı array exception caught. static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally oops done 41 bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true package quiz; import java.util.arraylist; import java.util.list; public class kombinasyon { public static boolean isletter(char ch) { return (ch>= 'a' && ch<= 'z') || (ch>= 'a' && ch<= 'z'); } public static boolean lower(char ch) { return (ch>= 'a'&& ch<='z'); } public static boolean upper(char ch) { return (ch>= 'a'&& ch<='z'); } public static void kombinasyon(char[] chars, int index, list<string> result) { if (index == chars.length) { result.add(new string(chars)); return; } char currentchar = chars[index]; if (isletter(currentchar)) { if (lower(currentchar)) { chars[index] = (char) (currentchar- 32); kombinasyon(chars, index+1, result); } if (upper(currentchar)) { chars[index] = (char) (currentchar+ 32); kombinasyon(chars, index+1, result); } } chars[index] = currentchar; kombinasyon(chars, index+1, result); } public static void main(string[] args) { string s = ""a1b2""; list<string> result = new arraylist<>(); kombinasyon(s.tochararray(), 0, result); system.out.println( result); } } package quiz.robot; public class robot { private string name; public string getname() { return name; } public void setname(string name) { this.name = name; } private string type; public string gettype() { return type; } public void settype(string type) { this.type = type; } private int batterylevel; public int getbatterylevel() { return batterylevel; } public void setbatterylevel(int batterylevel) { if (batterylevel < 0) { this.batterylevel = 0; } else if (batterylevel > 100) { this.batterylevel = 100; } else { this.batterylevel = batterylevel; } // batarya sıfırsa robot çalışamaz this.isoperational = (this.batterylevel > 0); } private boolean isoperational; public boolean isoperational() { return isoperational; } public void setoperational(boolean isoperational) { this.isoperational = isoperational; } public robot(string name, string type, int batterylevel) { this.name = name; this.type = type; this.batterylevel = batterylevel; this.isoperational = (this.batterylevel>0); } public robot() { this.name = ""wall-e""; this.type = ""trash""; this.batterylevel = 100; this.isoperational = true; } public void charge(){ setbatterylevel(100); this.isoperational =true; } public void printrobot(){ system.out.println(""robot name: "" + this.name + "" robot type: "" + this.type +"" battery level: "" + this.batterylevel +""% ""+ "" is operational: "" + this.isoperational); } } package quiz.robot; public class main { public static void main(string[] args) { factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } package quiz.robot; import java.util.arraylist; public class factory { private string name; public string getname() { return name; } public void setname(string name) { this.name = name; } private string location; public string getlocation() { return location; } public void setlocation(string location) { this.location = location; } private arraylist<robot>robots; public factory(string name, string location){ this.name=name; this.location=location; this.robots = new arraylist<>(); } public factory(){ this.name=""factory1""; this.location=""moon""; this.robots = new arraylist<>(); } public void addrobot(robot robot){ robots.add(robot); } public void chargeallrobots(){ for (robot robot : robots) { robot.charge(); } } public void work(){ for(robot robot:robots){ int tempbattery = robot.getbatterylevel() - 15; if( tempbattery<0 ){ tempbattery=0; } robot.setbatterylevel(tempbattery); } } public void printfactory() { system.out.println(""factory name: "" + this.name + "" location: "" + this.location); system.out.println(""robots operating here:""); for (robot robot :robots) { robot.printrobot(); } } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 package quiz2bil211; public interface withbattery { public int getbatterylife(); void recharge(); } package quiz2bil211; public abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; public abstractrobot(string modelname, int batterylife) { this.modelname = modelname; this.batterylife = batterylife; } public string getmodelname() { return modelname; } public abstract void performtask(); } package quiz2bil211; public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); factory.countrobots(); } } package quiz2bil211; public class securityrobot extends abstractrobot{ private boolean isarmed; public string getisarmed() { if(isarmed==true){ return ""armed""; } else{ return ""unarmed""; } } public boolean getarmed() { return isarmed; } public securityrobot(string modelname, int batterylife, boolean isarmed) { super(modelname, batterylife); this.isarmed=isarmed; this.modelname=modelname; this.isarmed=isarmed; } public void togglearmedmode(){ isarmed=!isarmed; } @override public int getbatterylife() { return batterylife; } @override public void recharge() { batterylife=batterylife+150; } @override public void performtask() { if(batterylife==10 || batterylife>10){ system.out.println(""[""+modelname+""]""+"" scanning for threats... armed: "" + isarmed); batterylife=batterylife-10; } else if(batterylife<10){ system.out.println(""[""+modelname+""]""+ "" not enough battery to scan threats...""); } } @override public string tostring() { return ""securityrobot - model: "" + getmodelname() + "", battery: "" + getbatterylife() + "", armed: "" + getisarmed(); } } package quiz2bil211; public class cleaningrobot extends abstractrobot { private int cleaningpower; protected string modelname; protected int batterylife; public cleaningrobot(string modelname, int batterylife, int cleaningpower) { super(modelname, batterylife); this.cleaningpower=cleaningpower; this.modelname=modelname; this.batterylife=batterylife; } public int getcleaningpower() { return cleaningpower; } public void boostcleaningpower(int amount){ cleaningpower=cleaningpower+amount; } public string getmodelname(){ return modelname; } @override public int getbatterylife() { return batterylife; } @override public void recharge() { batterylife=batterylife+150; } @override public void performtask() { if(batterylife==10 || batterylife>10){ system.out.println(""[""+modelname+""]""+"" cleaning in progress... cleaning power: "" + cleaningpower); batterylife=batterylife-10; } else if(batterylife<10){ system.out.println(""[""+modelname+""]""+ "" not enough battery to clean...""); } } @override public string tostring() { return ""cleaningrobot - model: "" + getmodelname() + "", battery: "" + getbatterylife() + "", cleaning power: "" + cleaningpower; } } package quiz2bil211; import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots = new arraylist<>(); private static int totalrobotcount = 0; public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) { robots.add(new cleaningrobot(modelname, batterylife, cleaningpower)); totalrobotcount++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) { robots.add(new securityrobot(modelname, batterylife, isarmed)); totalrobotcount++; } public void performalltasks() { for (abstractrobot robot : robots) { robot.performtask(); } } public void displayrobots() { for (abstractrobot robot : robots) { system.out.println(robot); } } public void upgradecleaningrobots(int amount) { for (abstractrobot robot : robots) { if (robot instanceof cleaningrobot) { ((cleaningrobot) robot).boostcleaningpower(amount); } if(robot instanceof cleaningrobot){ system.out.println(""cleaningrobot - "" + robot.getmodelname() + "" now has cleaning power: ""+ ((cleaningrobot) robot).getcleaningpower() );} } } public void togglesecurityrobotsmode() { for (abstractrobot robot : robots) { if (robot instanceof securityrobot) { ((securityrobot) robot).togglearmedmode(); } if(robot instanceof securityrobot){ system.out.println(""securityrobot - "" + robot.getmodelname() + "" armed: ""+ ((securityrobot) robot).getarmed() ); } } } public void countrobots(){ system.out.println(""tüm fabrikalar tarafından ""+totalrobotcount+"" robot üretildi.""); } } 1",41992,5386,767,235,44,42
8059049,1,"8059049 recursion 1) collatz problemi. bu kısımda amacımız bize verilen bir pozitif tam sayının collatz kuralları uygulanarak kaç adım sonra 1 olacağını hesaplamaktır . kurallar şu şekildedir: eğer sayı çift ise 2’ye bölünür eğer sayı tek ise 3 ile çarpılıp 1 eklenir . örneğin 5 -> 16 -> 8 -> 4 -> 2 -> 1 5 adım sürdüğü için cevap 5 inputu için 5’tir. bu işlemi yapan recursive metodu yazmanız gerekmektedir . bu metodun imzası public static int collatz(int i) olmalıdır . ancak yardımcı metotlar kullanabilirsiniz. burada girdinin sadece pozitif tam sayı olduğunu varsayabilirsiniz. 2) cocktail shaker sort bu kısımda sizden cocktail shaker sort implement etmeniz bekleniyor . cocktail shaker sort bubble sort’un bir yukarıdan bir aşağıdan baloncuk gönderilmesi ile yapılan sıralama işlemidir . bu sıralamayı recursive olarak yapmalısınız. imzası public static void cocktailsort(int[] arr) olmalıdır . yardımcı metotlar kullanmalısınız. örneğin girdi 5 4 1 2 olsun. ilk önce 5 < 4 değil 4 5 1 2 sonra 5 < 1 değil 4 1 5 2 5 < 2 değil 4 1 2 5 sonra recursive call ile bir sonraki kısma geçilecek. 1 < 2 işlem yapılmayacak. 4 < 1 değil 1 4 2 5 ve son iterasyonda sağdan soldan sağa doğru ilerleyip 4 < 2 değil 1 2 4 5 ile sıralı hale gelecek. eğer sınırları tutmak istemez iseniz direk her aşamada tüm arrayin üstünden de geçebilirsiniz. 3) bu kısımda bir stringdeki “1” leri sayan bir sınıf yazacaksınız. bu sınıf constructor da stringi alacak. public int say() metodu ile recursive şekilde bu stringdeki 1 değerlerini sayacak(helper metot kullanılması lazım). bu class objesi oluşturularak çalıştırılacak ve birden fazla string için birden fazla obje oluşturulacaktır . çalıştırma örneği: sayac s1 = new sayac(“10001”); sayac s2 = new sayac(“1 111”); system.out.println(s1.say()); // 2 basacak. public class bil211lab1q2 { public static void main(string[] args) { int[]arr={5,4,1,2}; cocktailsort(arr); for(int i=0;i<arr.length;i++){ system.out.print(arr[i]+"" ""); } } public static void cocktailsort(int[]arr){ recursiveshake(arr, 1); } public static void recursiveshake(int[]arr,int index){ if(index>=arr.length) return ; for(int i=0;i<index;i++){ if(arr[i]>arr[i+1]){ int temp=arr[i]; arr[i]=arr[i+1]; arr[i+1]=temp; } } for(int i=index;i<arr.length-1;i++){ if(arr[i]>arr[i+1]){ int tem=arr[i]; arr[i]=arr[i+1]; arr[i+1]=tem; } } recursiveshake(arr,index+1); } } public class bil211lab1q1 { public static void main(string[] args) { system.out.print(collatz(5)); } public static int collatz(int i){ if(i==1) return 0; if(i%2==0){ return 1+collatz(i/2); } return 1+collatz (i*3+1); } } public class bil211lab1q3 { public static void main(string[] args) { sayac s1=new sayac(""10001""); sayac s2=new sayac(""1111""); system.out.println(s1.say()); system.out.println(s2.say()); } } class sayac{ private string str; public sayac(string str){ this.str=str; } public int say(){ return counter(str,0); } private int counter(string str,int i){ if(i>=str.length()) return 0; if(str.charat(i)=='1'){ return 1+counter(str.substring(1),i); } return counter(str.substring(1),i); } } müzik çalar simülasyonu bil 211 - laboratuvar 2 6 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir müzik çalar simülasyonu geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: şarkı (sarki) sınıfı ve türevleri. farklı müzik türlerini temsil eder. çalma stratejisi arayüzü (calmastratejisi). farklı çalma yöntemlerini tanımlar. müzik çalar (muzikcalar) sınıfı. stratejilere bağlı olarak şarkıları çalar. 3 sınıf ve arayüz tanımları 3.1 sarki sınıfı (soyut sınıf ) değişkenler: - isim (string) - şarkının adı - sanatci (string) - sanatçının adı metodlar: - void oynat() - soyut metod, türetilmiş sınıflar tarafından override edilecek 3.2 metalsarki, rocksarki, klasiksarki sınıfları bu sınıflar sarki sınıfından türetilmiştir. oynat() metodu şarkıları türlerine özgü şekilde çalar ve ekrana yazdırır. doküman sonunda (ana program bölümü) her sınıfın şarkıları ne şekilde çaldığına ve ekrana yazdırdığına dair bir örnek bulabilirsiniz. rocksarki ve klasiksarki sınıflarında sarki sınıfında bulun- mayan constructor metodlar mevcuttur (kullanımları ana program bölümünde mevcut). metalsarki sınıfının sarki sınıfında bulunmayan değişken ve metodları aşağıda belirtilmiştir. 3.2.1 metalsarki sınıfı değişkenler: - metalozellik (string) - şarkıya ait nitelik (örn., agresif ritim, yüksek enerji) metodlar: - metalsarki(string isim, string sanatci, string metalozellik) - constructor - void gostermetalozellikleri() - metalozellik değişkenini ekrana yazdırır 3.3 calmastratejisi arayüzü metodlar: - void cal(list<sarki> sarkilistesi) - şarkıları belirli bir sıra ile çalar 1 3.4 siralicalma ve karisikcalma sınıfları bu sınıflar calmastratejisi arayüzünü uygular ve cal(list<sarki> sarkilistesi) metodunu tanımlar. siralicalma. sarkilistesi’ni liste sırasında çalar. karisikcalma. sarkilistesi’ni her şarkı bir kere çalınmak üzere karışık sırada çalar. rockcuozelcalma. sarkilistesi’ni liste sırasında çalar. rocksarki çalarken sesi yükseltir ve diğer şarkılar için sesi normal düzeye döndürür (ana program bölümünde örnek bilgi mesajları bulabilirsiniz). listede ardışık rocksarki bulunduğunda, ses yalnızca ardışık bölümdeki ilk şarkıdan önce yükseltilir ve ardışık bölümdeki son şarkıdan sonra normal düzeye döndürülür. 3.5 muzikcalar sınıfı değişkenler: - strateji (calmastratejisi) - çalma yöntemi metodlar: - void setstrateji(calmastratejisi s) - çalma stratejisini günceller. - void muzikcal(list<sarki> sarkilistesi) - seçilen stratejiye göre şarkıları çalar. 4 ana program (main sınıfı) ana programda, farklı türlerde şarkılar oluşturulacak ve çeşitli çalma stratejileri uygulanacaktır. 4.1 ana program örneği public class main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { ... // bu kismi cikti ornegini saglayacak sekilde doldurun } } } 2 4.2 çıktı örneği sirali calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) karisik calma: [rock] vega - ankara (huzurlu ve nostaljik) [klasik] ludovico einaudi - una mattina (hafif ve sakin) [metal] thurisaz - years of silence (aykiri ve atmosferik) [rock] midlake - small mountain (huzurlu ve nostaljik) [metal] death - voice of the soul (enstrumantal) rockcu ozel calma: [metal] thurisaz - years of silence (aykiri ve atmosferik) [metal] death - voice of the soul (enstrumantal) [bilgi] ses duzeyi: yuksek [rock] midlake - small mountain (huzurlu ve nostaljik) [rock] vega - ankara (huzurlu ve nostaljik) [bilgi] ses duzeyi: normal [klasik] ludovico einaudi - una mattina (hafif ve sakin) metal ozellikleri: thurisaz - years of silence [ozellik: aykiri ve atmosferik] death - voice of the soul [ozellik: enstrumantal] 3 import java.util.arrays; import java.util.list; public class bil211lab2main { public static void main(string[] args) { // farkli turde sarkilar olusturuluyor sarki s1 = new metalsarki(""years of silence"", ""thurisaz"", ""aykiri ve atmosferik""); sarki s2 = new metalsarki(""voice of the soul"", ""death"", ""enstrumantal""); sarki s3 = new rocksarki(""small mountain"", ""midlake""); sarki s4 = new rocksarki(""ankara"", ""vega""); sarki s5 = new klasiksarki(""una mattina"", ""ludovico einaudi""); // sarkilari iceren calma listesi list<sarki> sarkilistesi = arrays.aslist(s1, s2, s3, s4, s5); // muzik calar objesi muzikcalar muzikcalar = new muzikcalar(); // sirali calma stratejisi system.out.println(""sirali calma:""); muzikcalar.setstrateji(new siralicalma()); muzikcalar.muzikcal(sarkilistesi); // karisik calma stratejisi system.out.println(""karisik calma:""); muzikcalar.setstrateji(new karisikcalma()); muzikcalar.muzikcal(sarkilistesi); // rockcu ozel calma stratejisi system.out.println(""rockcu ozel calma:""); muzikcalar.setstrateji(new rockcuozelcalma()); muzikcalar.muzikcal(sarkilistesi); // metal sarkilarin ozelliklerini goster system.out.println(""metal ozellikleri:""); for (sarki sarki : sarkilistesi) { if (sarki instanceof metalsarki) { ((metalsarki) sarki).gostermetalozellikleri(); } } } } import java.util.arraylist; import java.util.list; import java.util.random; interface calmastratejisi { void cal(list<sarki> sarkilistesi); } class siralicalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi) { for (sarki sarki : sarkilistesi) { sarki.oynat(); } } } class karisikcalma implements calmastratejisi { public void cal(list<sarki> sarkilistesi) { random rand=new random(); arraylist<sarki> karisik = new arraylist<>(sarkilistesi); while(!karisik.isempty()){ int random = rand.nextint(karisik.size()); sarki sarki = karisik.get(random); sarki.oynat(); karisik.remove(random); } } } class rockcuozelcalma implements calmastratejisi{ public void cal(list<sarki> sarkilistesi) { boolean ses = false; for (int i = 0; i < sarkilistesi.size(); i++) { sarki sarki = sarkilistesi.get(i); if (sarki instanceof rocksarki) { if (!ses) { system.out.println(""[bilgi] ses duzeyi: yuksek""); ses = true; } } else { if (ses) { system.out.println(""[bilgi] ses duzeyi: normal""); ses = false; } } sarki.oynat(); } if (ses) { system.out.println(""[bilgi] ses duzeyi: normal""); } } } import java.util.list; public class muzikcalar { private calmastratejisi strateji; public void setstrateji(calmastratejisi strateji) { this.strateji = strateji; } public void muzikcal(list<sarki> sarkilistesi) { if (strateji != null) { strateji.cal(sarkilistesi); } } } class klasiksarki extends sarki { public klasiksarki(string isim,string sanatci){ super(isim, sanatci); } public void oynat(){ system.out.println(""[klasik] "" + getsanatci() + ""- "" + getisim() + "" (hafif ve sakin)""); } } class metalsarki extends sarki { private string metalozellik; public metalsarki(string isim, string sanatci, string metalozellik){ super(isim, sanatci); this.metalozellik=metalozellik; } void gostermetalozellikleri(){ system.out.println(getsanatci() + ""- "" + getisim() + "" [ozellik: "" + metalozellik + ""]""); } public void oynat() { system.out.println(""[metal] "" + getisim() + ""- "" + getsanatci() + "" ("" + metalozellik + "")""); } } public class rocksarki extends sarki { public rocksarki(string isim, string sanatci) { super(isim, sanatci); } public void oynat() { system.out.println(""[rock] "" + getsanatci()+ ""- "" + getisim()+ "" (huzurlu ve nostaljik)""); } } abstract class sarki { private string isim; private string sanatci; public sarki(string isim,string sanatci){ this.isim=isim; this.sanatci=sanatci; } abstract void oynat(); public string getsanatci(){ return sanatci; } public string getisim(){ return isim; } } recursion nedir? recursive bir metodun temel kısımları nelerdir, bu kısımları kısaca açıklayınız. recursion bir metodun kendi kendini çağırmasıdır.base case ,input ve recursive partlara sahiptir. recursive bir metotta base case ne demektir, neden gereklidir; kısaca açıklayınız. base case recursion dan çıkmamızı sağlayan koşuldur,sonsuz döngüye girmemek için gereklidir. bir stringi ters çeviren bir recursive metodu nasıl yazardınız, base case ne olurdu? string in karakter sayısının 1 olması durumu recursive bir metotta base case olmazsa ne olur? metod recursiondan çıkamaz recursive bir metot kendisini çağırdığında stack'te neler olur, kısaca açıklayınız. stack te yeni bir alan açılır,recursionla sonuca yaklaştıkça alan küçülür fibonacci sayılarını recursive bir metotla hesaplamak neden verimsiz olur, kısaca açıklayınız. durmadan diğer sayılar için metodu çağıracağımızdan(örneğin 2 için 1 ve 0 gibi) bellekte çok fazla yer tutar tail recursion nedir, kısaca açıklayınız. son koşulu metodun kendisinin sağladığı recursion tipi abstraction kavramını açıklayınız. black boxing dir,kodun gerekli kısımlarını tutar gereksiz kısımlarını gizleriz dönüş tipi employee olan bir metodu dönüş tipi hourlyemployee olan bir metot olarak override etmek mümkün müdür? peki ya bunun tersi? hourly employee için evet(subclass ise )tersi için hayır protected ve no modifier (package access) access modifierlerinden hangisi private modifierine daha yakındır? no modifier subclass a erişemediğinden no modifier daha yakındır java'da neden her bir classın constructorunun ilk satırı 'super' olmak zorundadır? üst sınıfın constructorına erişmek ve initialize edebilmek için java'da bir class birden çok classı extend edebilir mi, ""a extends b, c"" gibi bir şey mümkün müdür? hayır java'da ""instanceof"" operatörü hangi ilişkiyi kontrol eder? ""a instanceof b"" ise a ve b arasındaki ilişki nedir? is a ilişkisidir metot overriding ve overloading kavramlarını açıklayınız. overriding de aynı isim ve signature ile yeni bir metod tanımlarız.overloading de ise isim aynı ama parametreler farklıdır class base { int x = 10; base() { print(); } void print() { system.out.print(""base""); } } class derived extends base { int x = 1; void print() { system.out.print(x); } } // test sınıfı, main metodu içinde new derived(); output? base /n(alt satır) 1 class parent { protected int x = 10; { system.out.println(""parent"");} public int getvalue() { return x; } } class child extends parent { private int x = 20; public int getvalue() { return super.x + x; } } // test sınıfı, main metodu içinde parent c = new child(); system.out.println(c.getvalue()); output? parent /n 30 java'da ne zaman static binding yapılır, ne zaman dynamic binding yapılır? compile da static, run da dynamic binding yapılır java'da static, private ve final metotlar neden static bindingle bağlanır; static, private ve final metotların ortak özelliği nedir? çünkü bu metodlar override edilemezler ve sadece dinamik binding de override gerçekleşir overloading ve overriding yaparken hangi tür binding gerçekleşir, neden? overloading de static,overriding de dinamik binding gerçekleşir dinamik bağlamada jvm'nin görevi nedir? jvm in görevi runtime da kullanılacak metotları seçmektir java'da upcasting neden implicit bir şekilde yapılabilir, neden? peki ya down casting implicit bir şekilde yapılabilir mi? çünkü otomatik olarak alt class dan üst class a erişime uygundur,down casting implicit yapılırsa compioe hatası verebilir java'da tüm bindingler dinamik olsaydı ne olurdu, nasıl bir sorunla karşılaşırdık? compile time da hata verirdi,static metodları kullanamazdık class parent { void show() { system.out.println(""parent""); } } class child extends parent { void show() { system.out.println(""child""); } } public class test { public static void main(string[] args) { parent p = new child(); p.show(); } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? child dynamic binding class product { void display() { system.out.println(""product""); } } class book extends product { void display() { system.out.println(""book""); } } public class test { public static void main(string[] args) { product[] items = {new product(), new book()}; for(product item : items) { item.display(); } } } output? burada statik bağlama mı dinamik bağlama mı gözlemlemektesiniz? product book dynamic binding var java'da abstract class nedir, concrete bir classtan farkı nedir? abstract classların veya interfacelerin constructoru olabilir mi? abstract class soyut bir classtır,içindeki metodlar da soyut yani bodysiz olabilir,concrete de metodlar da concrete olmalıdır.interface de constructor olmaz,abstract de olur abstract bir metot abstract bir classta implement edilebilir mi, evet ise nasıl? evet edilebilir,normal bir şekilde abstract class ve metodları tanımlarız. abstract metot/classların 3 temel özelliğini (veya bize sağladığı yetenekleri) yazınız. 1-şablon oluştururlar 2-kod tekrarını engellerler 3-bu metodlarda body kısmı boştur abstract class ile interfaceler arasındaki fark nedir? abstract classlar ve interfaceler tip olarak kullanılabilir mi? yani 'myabstractclass obj1;' veya 'myinterface obj2;' şeklindeki declarationlar mümkün müdür? abstract class da extend seçeneği mevcuttur,her zaman yüzde 100 soyutlama olmaz,interface ise yüzde 100 soyutlamadır.i̇kisi de referans tipi olarak kullanılabilir marker interface ve functional interface kavramları nedir, nasıl kullanılır? marker da metod bulunmaz,functional de bulunur bir class birden çok interfaceyi implement edebilir mi? bir interface başka bir interfaceyi implement edebilir mi? class interface i implement eder,interface ise diğer interface i extend eder abstract class animal { string name; animal(string name) { this.name = name; } abstract void sound(); void printname() { system.out.println(""animal: "" + name); } } class dog extends animal { dog(string name) { super(name); } void sound() { system.out.println(""woof""); } } public class testanimals { public static void main(string[] args) { animal a = new animal(""buddy""); a.printname(); a.sound(); } } yukarıdaki kodda hata nerededir, bu hatayı nasıl düzeltirsiniz? hatayı düzelttikten sonra output? animal la obje yapılamaz, new dog denmeli. output:buddy woof interface flyable { default void move() { system.out.println(""flying""); } } interface swimmable { default void move() { system.out.println(""swimming""); } } class duck implements flyable, swimmable { public void move() { super.move(); } } public class testduck { public static void main(string[] args) { duck d = new duck(); d.move(); } } kod bu haliyle compile edilebilir mi? koddaki hata nedir, nasıl düzeltilir? yeni haliyle output? burada hata super kullanılması,nereden bilebiliriz hangi interface i kullanacağını? yapılacak şey süper.move u kaldırmak muhtemel çıktılar da swimming veya flying veya ikisi birden olabilir,hangi interface veya interfaceleri işaret ettiğimize bağlı . java'da exceptionlar kaç çeşittir, her çeşit için birer örnek verin. checked ve unchecked.checked e file io,unchecked e arrayindexoutofbounds exceptionları örnek verilebilir java'da 'throws' keywordunu kullanırken kısıtlar nedir, override edilen metotlarda bu kısıtlar nasıl işler? checked exception da try catch ile kontrol edilmeli.override da exception ı tekrar yazman gerekmez. finally bloğunun işlevi nedir? finally bloğu exception atılmayan durumlarda da çalışır mı? finally kaynak temizleme vb. için kullanılan bir bloktur. finally bloğu exception olsa da olmasa da çalışır. java'da kendi exceptionunuzu nasıl tanımlarsınız? extends exception şeklinde derived bir exception class ı yazarım java'da bazen catch edilen bir exception bazı işlemler yapıldıktan sonra tekrar fırlatılır, bunun amacı ne olabilir? sadece exception ı catch etmek yetmez,üst class a atıp bilgi isteyebilir static int doexceptionalmath(int x){ try{ int result = x / 0; return result; } catch(arithmeticexception e){ system.out.println(""caught""); return -1; } finally{ system.out.println(""finally""); try{ finalmath(); } catch(exception e){ catchfinal(); } return 41; } } static void finalmath() throws exception{ system.out.println(""oops""); throw new exception(); } static void catchfinal(){ system.out.println(""done""); } // psvm system.out.println(doexceptionalmath(77)); output? caught finally done 41 static void m2(){ try{ system.out.println(""trying m1""); m1(); } catch(exception e){ system.out.println(""caught1""); } catch(ioexception e){ system.out.println(""caught2""); } finally{ system.out.println(""finally""); } } static void m1() throws ioexception { try { throw new filenotfoundexception(); } catch (filenotfoundexception e) { throw new ioexception(); } } kod bu şekilde derlenir mi? eğer derlenmezse hata(lar)nın kaynağı nedir? varsa hatay(lar)ı nasıl düzeltirsiniz? varsa hata(lar)yı düzelttikten sonra output ne olur? trying m1 caught2 finally bil211 quiz 1 section 2 quizleri uzak sistemine yükleyeceksiniz. q1: verilen bir alfanumerik string içindeki harflerin büyük/küçük harfli tüm kombinasyonlarını üretin ve ekrana basın. rakamlar değiştirilemez, sadece harfler farklı kombinasyonlarda olmalıdır. kurallar: 1. string içindeki harfler büyük veya küçük olabilir, ancak rakamlar sabit kalır. 2. çıkış dizisi tekrarsız tüm büyük/küçük harf kombinasyonlarını içermelidir. 3. sıra korunmalıdır, yani karakterlerin sırası değiştirilemez. örnek: s = ""a1b2"": [""a1b2"", ""a1b2"", ""a1b2"", ""a1b2""] q2:bu soruda robot ve factory adında iki sınıf oluşturacağız ve bu sınıfların metodlarını test edeceğiz. robot: değişkenler: private string name private string type private int batterylevel // 100 ile 0 arasında bir değer private boolean isoperational // bataryası varsa true metotlar: private değişkenler için get ve set metotları. public void charge(): batarya seviyesini 100 e çıkarır. constructorlar: bir tane parametresiz ve parametreli constructor. parametresiz olan name= “wall-e”, type= “trash”, batterylevel = 100 ve isoperational = true yapmalıdır. public void printrobot(): pengueni ekrana basmalıdır. örnek: robot name: wall-e robot type: trash batterylevel : 100% isoperationalt: true factory: değişkenler: private string name private string location private arraylist<robot> robots metotlar: public factory(string name, string location) public factory()// name = “factory1” ve location = “moon” yapar. private değişkenler için get ve set metotları. public void addrobot(robot robot) public void chargeallrobots(): tüm robotların şarjını 100 yapar. public void printfactory(): ekrana basar. aşağıdaki formatta çıktı vermelidir: public void work(): her robotun şarjı %15 azalır. main: factory factory = new factory(); robot r1 = new robot(); // default robot ""wall-e"" robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); çıktı: factory name: factory1 location: moon robots operating here: robot name: wall-e robot type: trash battery level: 100% is operational: true robot name: bender robot type: bending unit battery level: 55% is operational: true robot name: r2-d2 robot type: astromech battery level: 80% is operational: true import java.util.arraylist; public class bil211qui1z1{ public static void main(string[] args) { string s = ""a1b2""; arraylist<string> result=new arraylist<>(); kombinasyon(s, 0, """", result); system.out.println(result); } //büyük harf ile küçük harf arasında 32 fark olduğu belirtildi,o yüzden +-32 ile charları elde ettim public static void kombinasyon(string s, int index, string current, arraylist<string> result) { if (index == s.length()) { result.add(current); return; } char c = s.charat(index); if (c>='a'&&c<='z') { char d=(char)(c-32); kombinasyon(s, index + 1, current +c , result); kombinasyon(s, index + 1, current +d , result); } else if(c>='a'&&c<='z'){ char e=(char)(c+32); kombinasyon(s, index + 1, current +c , result); kombinasyon(s, index + 1, current +e , result); } else { kombinasyon(s, index + 1, current + c, result); } } } import java.util.*; public class bil2111quiz1q2 { public static void main(string[]args){ factory factory = new factory(); robot r1 = new robot(); // robot r2 = new robot(""bender"", ""bending unit"", 55); robot r3 = new robot(""r2-d2"", ""astromech"", 80); factory.addrobot(r1); factory.addrobot(r2); factory.addrobot(r3); factory.printfactory(); } } class robot{ private string name; private string type; private int batterylevel; private boolean isoperational; public robot(){ this.name=""wall-e""; this.type=""trash""; this.batterylevel=100; this.isoperational=true; } public robot(string name,string type,int batterylevel){ this.name=name; this.type=type; this.batterylevel=batterylevel; this.isoperational=true; } public void charge(){ this.batterylevel=100; } public void printrobot(){ system.out.println(""robot name: ""+this.name+"" robot type: ""+this.type+"" battery level: ""+this.batterylevel+""%""+ "" is operational:""+this.isoperational); } public string getname(){ return name; } public int getbattery(){ return batterylevel; } public string gettype(){ return type; } public void setbattery(int battery){ this.batterylevel=battery; } public void setoperation(){ if(this.batterylevel<=0) isoperational=false; } public boolean getoperational(){ return isoperational; } } class factory{ private string name; private string location; private arraylist<robot> robots; public factory(string name, string location){ this.name=name; this.location=location; this.robots=new arraylist<>(); } public factory(){ this.name=""factory1""; this.location=""moon""; this.robots=new arraylist<>(); } public void chargeallrobots(){ for(robot robot:robots){ robot.charge(); } } public void addrobot(robot robot){ this.robots.add(robot); } public void printfactory(){ system.out.println(""factory name: ""+this.name+"" factory location: ""+ this.location); system.out.println(""robots operating here:""); for(robot robot:robots) robot.printrobot(); } public void work(){ for(robot robot:robots){ robot.setbattery(robot.getbattery()-15); if(!robot.getoperational()){ robot.setbattery(0); } } } public string getname(){ return name; } public string getlocation(){ return location; } public arraylist<robot> getrobots(){ return robots; } } robot fabrikası bil 211 - quiz 2 13 şubat 2025 1 giriş bu laboratuvarda inheritance, polymorphism ve interface kullanarak bir robot fabrikası geliştireceğiz. 2 genel yapı sistem, üç ana bileşenden oluşmaktadır: bataryalı ( withbattery ) arayüzü. bataryası olan objelerle etkileşimi tanımlar. soyut robot sınıfı ( abstractrobot ).ortak robot özelliklerini içerir. özel robot sınıfları ( cleaningrobot vesecurityrobot ).farklı robot türlerini temsil eder. robot fabrikası ( robotfactory ).robotların üretilmesini ve yönetilmesini sağlar. 3 sınıf ve arayüz tanımları 3.1 withbattery arayüzü metotlar: -int getbatterylife() batarya ömrünü döner. -void recharge() bataryayı yeniler. 3.2 abstractrobot sınıfı (soyut sınıf) - withbattery arayüzünü gerçekler (implement) değişkenler: -modelname (protected string) robotun modeli. -batterylife (protected int) robotun batarya ömrü. metotlar: -public abstractrobot(string modelname, int batterylife) constructor. -public string getmodelname() model adını döner. -public abstract void performtask() soyut metod. cleaningrobot vesecurityrobot sınıfları tarafından tanımlanacak. 3.3 cleaningrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -cleaningpower (private int) robotun temizlik gücü. ekstra metotlar: -cleaningrobot(string modelname, int batterylife, int cleaningpower) constructor. 1 -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] cleaning in progress... cleaning power: cleaningpower "" mesajını yazdırır ( modelname vecleaningpower yerine değişken değerleri göster- ilmeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[modelname ] not enough battery to clean..."" mesajı gösterilmeli. -public void boostcleaningpower(int miktar) temizlik gücünü miktarkadar artırır. 3.4 securityrobot sınıfı - abstractrobot sınıfını geliştirir (extend) ekstra değişken: -isarmed (private boolean) robotun silahlı olup olmadığı. ekstra metotlar: -securityrobot(string modelname, int batterylife, bool isarmed) constructor. -public void performtask() eğer batarya ömrü 10 ya da daha fazla ise ""[ modelname ] scanning for threats... armed: isarmed"" mesajını yazdırır ( modelname veisarmed yerine değişken değerleri göstermeli). mesaj gösterildikten sonra batarya ömrü 10 azalır. metod çağırıldığında yeterli batarya ömrü yoksa ""[ modelname ] not enough battery to scan threats..."" mesajı gösterilmeli. -public void togglearmedmode() silah modunu değiştirir. 3.5 robotfactory sınıfı değişkenler: -robots(private arraylist<abstractrobot>) üretilen robotları saklar. metotlar: -public void producecleaningrobot(string modelname, int batterylife, int cleaningpower) robotsdizisine verilen parametrelerle bir cleaningrobot ekler. -public void producesecurityrobot(string modelname, int batterylife, boolean isarmed) robotsdizisine verilen parametrelerle bir securityrobot ekler. -public void performalltasks() robotsdizisindeki robotların dizi sırasında performtask metodlarını çağırır. -public void displayrobots() tüm robotları ekrana yazdırır (çıktının formatı ana program bölümünde mevcut). -public void upgradecleaningrobots(int miktar) temizlik robotlarının gücünü miktarkadar artırır. -public void togglesecurityrobotsmode() güvenlik robotlarının modunu tersine döndürür. -??? bu fonksiyon tüm farklı robotfactory’ler tarafından üretilmiş robot sayısını ekrana ""tum fabrikalar tarafindan toplam toplamroboturetimi robot uretildi"" yazdırır ( toplamroboturetimi yerine toplam üretilen robot sayısı yazılmalıdır). bu fonksiyonu tamamlamak için robotfactory sınıfına yardımcı değişkenler ve metodlar ekleyebilirsiniz ancak yukarıda belirtilmiş metodlarda değişiklik yapmayın . 2 4 ana program ( mainsınıfı) public class main { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\performing all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.our.println(""\n""); ??? // burada robotfactory sinifinda yazdiginiz ??? fonksiyonunu cagirmalisiniz } } 5 çıktı örneği produced robots: cleaningrobot - model: cleanmaster 3000, battery: 100, cleaning power: 80 securityrobot - model: guardbot x, battery: 150, armed: true securityrobot - model: patrolbot, battery: 120, armed: false cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 150 performıng all robot tasks: [cleanmaster 3000] cleaning in progress... cleaning power: 80 [guardbot x] scanning for threats... armed: true [patrolbot] scanning for threats... armed: false [cleanmaster 3500] not enough battery to clean... upgrading cleaning robots: cleaningrobot - cleanmaster 3000 now has cleaning power: 90 cleaningrobot - cleanmaster 3500 now has cleaning power: 160 toggling security robot modes: securityrobot - guardbot x is now unarmed securityrobot - patrolbot is now armed 3 final robot status: cleaningrobot - model: cleanmaster 3000, battery: 90, cleaning power: 90 securityrobot - model: guardbot x, battery: 140, armed: false securityrobot - model: patrolbot, battery: 110, armed: true cleaningrobot - model: cleanmaster 3500, battery: 5, cleaning power: 160 tum fabrikalar tarafindan toplam 6 robot uretildi 6 gönderim formatı - tüm sınıflar için ayrı bir dosya oluşturun (main.java, robotfactory.java, ...). - quizi bitirdiğinizde oluşturduğunuz tüm dosyaları sıkıştırın (zip, rar, 7z, tar, tar.gz formatlarından herhangi birisi uygun). - sıkıştırılmışarşivinisminiisim_numara_sube2şeklindeisimlendirin(örn.,johnnash_181101014_sube2.zip). - i̇simlendirdiğiniz arşivi canpolatog@gmail.com e-mail adresine ""quiz2 şube2"" başlıklı bir mail ile gönderin. 4 abstract class abstractrobot implements withbattery{ protected string modelname; protected int batterylife; protected int totalrobots; public abstractrobot(string modelname, int batterylife){ this.modelname=modelname; this.batterylife=batterylife; } public string getmodelname(){ return modelname; } public abstract void performtask(); } public class cleaningrobot extends abstractrobot { private int cleaningpower; private final int initialbattery; public cleaningrobot(string modelname, int batterylife, int cleaningpower){ super(modelname,batterylife); this.cleaningpower=cleaningpower; this.initialbattery=batterylife; } public int getbatterylife(){ return batterylife; } public void setbatterylife(int val){ this.batterylife=val; } public int getcleaningpower(){ return cleaningpower; } public void recharge(){ setbatterylife(initialbattery); } public void performtask(){ if(getbatterylife()>=10){ system.out.println(""[""+getmodelname()+""] cleaning in progres... cleaning power:""+this.cleaningpower); setbatterylife(getbatterylife()-10); } else{ system.out.println(""[""+getmodelname()+""] not enough battery to scan threats...""); } } public void boostcleaningpower(){ this.cleaningpower+=10; system.out.println(""cleaningrobot- ""+getmodelname()+"" now has cleaning power: ""+getcleaningpower()); } } public class robotmain { public static void main(string[] args) { robotfactory factory = new robotfactory(); factory.producecleaningrobot(""cleanmaster 3000"", 100, 80); factory.producesecurityrobot(""guardbot x"", 150, true); factory.producesecurityrobot(""patrolbot"", 120, false); factory.producecleaningrobot(""cleanmaster 3500"", 5, 150); system.out.println(""\nproduced robots:""); factory.displayrobots(); system.out.println(""\nperforming all robot tasks:""); factory.performalltasks(); system.out.println(""\nupgrading cleaning robots:""); factory.upgradecleaningrobots(10); system.out.println(""\ntoggling security robot modes:""); factory.togglesecurityrobotsmode(); system.out.println(""\nfinal robot status:""); factory.displayrobots(); // ??? fonksiyonunu test etmek icin baska bir fabrikadan robot uretiyoruz. robotfactory anotherfactory = new robotfactory(); anotherfactory.producecleaningrobot(""checkmaster 3000"", 100, 80); anotherfactory.producesecurityrobot(""checkbot x"", 150, true); system.out.println(""\n""); robotfactory.getsizer(); } } public class securityrobot extends abstractrobot { private boolean isarmed; public securityrobot(string modelname, int batterylife, boolean isarmed){ super(modelname, batterylife); this.isarmed=isarmed; } public int getbatterylife(){ return batterylife; } public void setbatterylife(int val){ this.batterylife=val; } public void recharge(){ setbatterylife(150); } public boolean getisarmed(){ return isarmed; } public void performtask(){ if(getbatterylife()>=10){ system.out.println(""[""+getmodelname()+""] scanning for threads... armed:""+this.isarmed); setbatterylife(getbatterylife()-10); } else{ system.out.println(""[""+getmodelname()+""] not enough battery to scan threats...""); } } public void togglearmedmode(){ if(!this.isarmed){ this.isarmed=true; system.out.println(""securityrobot- ""+getmodelname() +"" is now armed.""); } else{ this.isarmed=false; system.out.println(""securityrobot- ""+getmodelname()+"" is now unarmed.""); } } } interface withbattery { int getbatterylife(); void recharge(); } import java.util.arraylist; public class robotfactory { private arraylist<abstractrobot> robots; private static int sizer; public robotfactory(){ this.robots=new arraylist<>(); } public void producecleaningrobot(string modelname, int batterylife, int cleaningpower){ abstractrobot robot=new cleaningrobot(modelname, batterylife, cleaningpower); robots.add(robot); sizer++; } public void producesecurityrobot(string modelname, int batterylife, boolean isarmed){ abstractrobot robot=new securityrobot(modelname, batterylife, isarmed); robots.add(robot); sizer++; } public void performalltasks(){ for(abstractrobot robot:robots){ robot.performtask(); } } public void displayrobots(){ for(abstractrobot robot:robots){ if(robot instanceof cleaningrobot){ system.out.println(""cleaningrobot -model: ""+robot.getmodelname()+"", battery: ""+robot.getbatterylife()+"", cleaning power: ""+((cleaningrobot) robot).getcleaningpower()); } else system.out.println(""securityrobot -model: ""+robot.getmodelname()+"", battery: ""+robot.getbatterylife()+"", cleaning power: ""+((securityrobot) robot).getisarmed()); } } public void upgradecleaningrobots(int miktar){ for (abstractrobot robot: robots ){ if(robot instanceof cleaningrobot) ((cleaningrobot) robot).boostcleaningpower(); } } public void togglesecurityrobotsmode(){ for (abstractrobot robot: robots ){ if(robot instanceof securityrobot){ ((securityrobot) robot).togglearmedmode(); } } } public static int getsize() { return sizer; } public static void getsizer(){ system.out.print("" tüm fabrikalar tarafından toplam ""+getsize()+"" robot üretildi ""); } } 1",37356,4523,721,225,52,28
